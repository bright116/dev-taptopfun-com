function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    })(e);
}

function set(e, t, n, r) {
    return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(e, t, n, r) {
        var i, a = _superPropBase(e, t);
        if (a) {
            if ((i = Object.getOwnPropertyDescriptor(a, t)).set) return i.set.call(r, n), !0;
            if (!i.writable) return !1;
        }
        if (i = Object.getOwnPropertyDescriptor(r, t)) {
            if (!i.writable) return !1;
            i.value = n, Object.defineProperty(r, t, i);
        } else _defineProperty(r, t, n);
        return !0;
    })(e, t, n, r);
}

function _set(e, t, n, r, i) {
    if (!set(e, t, n, r || e) && i) throw new Error("failed to set property");
    return n;
}

function _defineProperty(e, t, n) {
    return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n, e;
}

function _get(e, t, n) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, n) {
        var r = _superPropBase(e, t);
        if (r) {
            var i = Object.getOwnPropertyDescriptor(r, t);
            return i.get ? i.get.call(n) : i.value;
        }
    })(e, t, n || e);
}

function _superPropBase(e, t) {
    for (;!Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)); ) ;
    return e;
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t;
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}

function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
    })(e);
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t);
}

function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
        return e.__proto__ = t, e;
    })(e, t);
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, t) {
    for (var n = 0; n < t.length; n++) {
        var r = t[n];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), 
        Object.defineProperty(e, r.key, r);
    }
}

function _createClass(e, t, n) {
    return t && _defineProperties(e.prototype, t), n && _defineProperties(e, n), e;
}

!function(e, t) {
    var n = function() {
        function MathUtils3D() {
            _classCallCheck(this, MathUtils3D);
        }
        return _createClass(MathUtils3D, null, [ {
            key: "isZero",
            value: function(e) {
                return Math.abs(e) < MathUtils3D.zeroTolerance;
            }
        }, {
            key: "nearEqual",
            value: function(e, t) {
                return !!MathUtils3D.isZero(e - t);
            }
        }, {
            key: "fastInvSqrt",
            value: function(e) {
                return MathUtils3D.isZero(e) ? e : 1 / Math.sqrt(e);
            }
        } ]), MathUtils3D;
    }();
    n.zeroTolerance = 1e-6, n.MaxValue = 3.40282347e38, n.MinValue = -3.40282347e38, 
    n.Deg2Rad = Math.PI / 180;
    var r = function() {
        function Vector2() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, Vector2), this.x = e, this.y = t;
        }
        return _createClass(Vector2, [ {
            key: "setValue",
            value: function(e, t) {
                this.x = e, this.y = t;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector2();
                return this.cloneTo(e), e;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([ this.x, this.y ]), 
                Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1);
            }
        } ], [ {
            key: "scale",
            value: function(e, t, n) {
                n.x = e.x * t, n.y = e.y * t;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var n = e.x, r = e.y, i = n * n + r * r;
                i > 0 && (i = 1 / Math.sqrt(i), t.x = n * i, t.y = r * i);
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x, n = e.y;
                return Math.sqrt(t * t + n * n);
            }
        }, {
            key: "rewriteNumProperty",
            value: function(e, t, n) {
                Object.defineProperty(e, t, {
                    get: function() {
                        return this.elements[n];
                    },
                    set: function(e) {
                        this.elements[n] = e;
                    }
                });
            }
        } ]), Vector2;
    }();
    r.ZERO = new r(0, 0), r.ONE = new r(1, 1);
    var i = function() {
        function Vector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, Vector4), this.x = e, this.y = t, this.z = n, this.w = r;
        }
        return _createClass(Vector4, [ {
            key: "setValue",
            value: function(e, t, n, r) {
                this.x = e, this.y = t, this.z = n, this.w = r;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
                this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
                r.rewriteNumProperty(this, "x", 0), r.rewriteNumProperty(this, "y", 1), r.rewriteNumProperty(this, "z", 2), 
                r.rewriteNumProperty(this, "w", 3);
            }
        } ], [ {
            key: "lerp",
            value: function(e, t, n, r) {
                var i = e.x, a = e.y, o = e.z, s = e.w;
                r.x = i + n * (t.x - i), r.y = a + n * (t.y - a), r.z = o + n * (t.z - o), r.w = s + n * (t.w - s);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = e.w, s = t.elements;
                n.x = r * s[0] + i * s[4] + a * s[8] + o * s[12], n.y = r * s[1] + i * s[5] + a * s[9] + o * s[13], 
                n.z = r * s[2] + i * s[6] + a * s[10] + o * s[14], n.w = r * s[3] + i * s[7] + a * s[11] + o * s[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return n.nearEqual(Math.abs(e.x), Math.abs(t.x)) && n.nearEqual(Math.abs(e.y), Math.abs(t.y)) && n.nearEqual(Math.abs(e.z), Math.abs(t.z)) && n.nearEqual(Math.abs(e.w), Math.abs(t.w));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var n = e.length();
                if (n > 0) {
                    var r = 1 / n;
                    t.x = e.x * r, t.y = e.y * r, t.z = e.z * r, t.w = e.w * r;
                }
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w;
            }
        }, {
            key: "subtract",
            value: function(e, t, n) {
                n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w;
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n.w = e.w * t.w;
            }
        }, {
            key: "scale",
            value: function(e, t, n) {
                n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, n, r) {
                var i = e.x, a = e.y, o = e.z, s = e.w, l = t.x, u = t.y, c = t.z, h = t.w, _ = n.x, d = n.y, f = n.z, m = n.w;
                i = (i = i > _ ? _ : i) < l ? l : i, a = (a = a > d ? d : a) < u ? u : a, o = (o = o > f ? f : o) < c ? c : o, 
                s = (s = s > m ? m : s) < h ? h : s, r.x = i, r.y = a, r.z = o, r.w = s;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var n = e.x - t.x, r = e.y - t.y, i = e.z - t.z, a = e.w - t.w;
                return n * n + r * r + i * i + a * a;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var n = e.x - t.x, r = e.y - t.y, i = e.z - t.z, a = e.w - t.w;
                return Math.sqrt(n * n + r * r + i * i + a * a);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "min",
            value: function(e, t, n) {
                n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n.w = Math.min(e.w, t.w);
            }
        }, {
            key: "max",
            value: function(e, t, n) {
                n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n.w = Math.max(e.w, t.w);
            }
        } ]), Vector4;
    }();
    i.ZERO = new i(), i.ONE = new i(1, 1, 1, 1), i.UnitX = new i(1, 0, 0, 0), i.UnitY = new i(0, 1, 0, 0), 
    i.UnitZ = new i(0, 0, 1, 0), i.UnitW = new i(0, 0, 0, 1);
    var a, o = function() {
        function Vector3() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            _classCallCheck(this, Vector3), this.x = e, this.y = t, this.z = n;
        }
        return _createClass(Vector3, [ {
            key: "setValue",
            value: function(e, t, n) {
                this.x = e, this.y = t, this.z = n;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector3();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.x = 0, this.y = 0, this.z = 0;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([ this.x, this.y, this.z ]), 
                r.rewriteNumProperty(this, "x", 0), r.rewriteNumProperty(this, "y", 1), r.rewriteNumProperty(this, "z", 2);
            }
        } ], [ {
            key: "distanceSquared",
            value: function(e, t) {
                var n = e.x - t.x, r = e.y - t.y, i = e.z - t.z;
                return n * n + r * r + i * i;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var n = e.x - t.x, r = e.y - t.y, i = e.z - t.z;
                return Math.sqrt(n * n + r * r + i * i);
            }
        }, {
            key: "min",
            value: function(e, t, n) {
                n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z);
            }
        }, {
            key: "max",
            value: function(e, t, n) {
                n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.x, s = t.y, l = t.z, u = t.w, c = u * r + s * a - l * i, h = u * i + l * r - o * a, _ = u * a + o * i - s * r, d = -o * r - s * i - l * a;
                n.x = c * u + d * -o + h * -l - _ * -s, n.y = h * u + d * -s + _ * -o - c * -l, 
                n.z = _ * u + d * -l + c * -s - h * -o;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x, n = e.y, r = e.z;
                return Math.sqrt(t * t + n * n + r * r);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.x, n = e.y, r = e.z;
                return t * t + n * n + r * r;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var n = e.x, r = e.y, i = e.z, a = n * n + r * r + i * i;
                a > 0 && (a = 1 / Math.sqrt(a), t.x = n * a, t.y = r * a, t.z = i * a);
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z;
            }
        }, {
            key: "scale",
            value: function(e, t, n) {
                n.x = e.x * t, n.y = e.y * t, n.z = e.z * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, n, r) {
                var i = e.x, a = e.y, o = e.z;
                r.x = i + n * (t.x - i), r.y = a + n * (t.y - a), r.z = o + n * (t.z - o);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, n) {
                var r = Vector3._tempVector4;
                Vector3.transformV3ToV4(e, t, r), n.x = r.x, n.y = r.y, n.z = r.z;
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.elements;
                n.x = r * o[0] + i * o[4] + a * o[8] + o[12], n.y = r * o[1] + i * o[5] + a * o[9] + o[13], 
                n.z = r * o[2] + i * o[6] + a * o[10] + o[14], n.w = r * o[3] + i * o[7] + a * o[11] + o[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.elements;
                n.x = r * o[0] + i * o[4] + a * o[8], n.y = r * o[1] + i * o[5] + a * o[9], n.z = r * o[2] + i * o[6] + a * o[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.elements, s = r * o[3] + i * o[7] + a * o[11] + o[15];
                n.x = (r * o[0] + i * o[4] + a * o[8] + o[12]) / s, n.y = (r * o[1] + i * o[5] + a * o[9] + o[13]) / s, 
                n.z = (r * o[2] + i * o[6] + a * o[10] + o[14]) / s;
            }
        }, {
            key: "Clamp",
            value: function(e, t, n, r) {
                var i = e.x, a = e.y, o = e.z, s = t.x, l = t.y, u = t.z, c = n.x, h = n.y, _ = n.z;
                i = (i = i > c ? c : i) < s ? s : i, a = (a = a > h ? h : a) < l ? l : a, o = (o = o > _ ? _ : o) < u ? u : o, 
                r.x = i, r.y = a, r.z = o;
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z;
            }
        }, {
            key: "subtract",
            value: function(e, t, n) {
                n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z;
            }
        }, {
            key: "cross",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.x, s = t.y, l = t.z;
                n.x = i * l - a * s, n.y = a * o - r * l, n.z = r * s - i * o;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z;
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return n.nearEqual(e.x, t.x) && n.nearEqual(e.y, t.y) && n.nearEqual(e.z, t.z);
            }
        } ]), Vector3;
    }();
    o._tempVector4 = new i(), o._ZERO = new o(0, 0, 0), o._ONE = new o(1, 1, 1), o._NegativeUnitX = new o(-1, 0, 0), 
    o._UnitX = new o(1, 0, 0), o._UnitY = new o(0, 1, 0), o._UnitZ = new o(0, 0, 1), 
    o._ForwardRH = new o(0, 0, -1), o._ForwardLH = new o(0, 0, 1), o._Up = new o(0, 1, 0), 
    (a = e.PBRRenderQuality || (e.PBRRenderQuality = {}))[a.High = 0] = "High", a[a.Low = 1] = "Low";
    var s = function() {
        function Matrix3x3() {
            _classCallCheck(this, Matrix3x3);
            var e = this.elements = new Float32Array(9);
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
            e[8] = 1;
        }
        return _createClass(Matrix3x3, [ {
            key: "determinant",
            value: function() {
                var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3], a = e[4], o = e[5], s = e[6], l = e[7], u = e[8];
                return t * (u * a - o * l) + n * (-u * i + o * s) + r * (l * i - a * s);
            }
        }, {
            key: "translate",
            value: function(e, t) {
                var n = t.elements, r = this.elements, i = r[0], a = r[1], o = r[2], s = r[3], l = r[4], u = r[5], c = r[6], h = r[7], _ = r[8], d = e.x, f = e.y;
                n[0] = i, n[1] = a, n[2] = o, n[3] = s, n[4] = l, n[5] = u, n[6] = d * i + f * s + c, 
                n[7] = d * a + f * l + h, n[8] = d * o + f * u + _;
            }
        }, {
            key: "rotate",
            value: function(e, t) {
                var n = t.elements, r = this.elements, i = r[0], a = r[1], o = r[2], s = r[3], l = r[4], u = r[5], c = r[6], h = r[7], _ = r[8], d = Math.sin(e), f = Math.cos(e);
                n[0] = f * i + d * s, n[1] = f * a + d * l, n[2] = f * o + d * u, n[3] = f * s - d * i, 
                n[4] = f * l - d * a, n[5] = f * u - d * o, n[6] = c, n[7] = h, n[8] = _;
            }
        }, {
            key: "scale",
            value: function(e, t) {
                var n = t.elements, r = this.elements, i = e.x, a = e.y;
                n[0] = i * r[0], n[1] = i * r[1], n[2] = i * r[2], n[3] = a * r[3], n[4] = a * r[4], 
                n[5] = a * r[5], n[6] = r[6], n[7] = r[7], n[8] = r[8];
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = e.elements, n = this.elements, r = n[0], i = n[1], a = n[2], o = n[3], s = n[4], l = n[5], u = n[6], c = n[7], h = n[8], _ = h * s - l * c, d = -h * o + l * u, f = c * o - s * u, m = r * _ + i * d + a * f;
                m || (e = null), m = 1 / m, t[0] = _ * m, t[1] = (-h * i + a * c) * m, t[2] = (l * i - a * s) * m, 
                t[3] = d * m, t[4] = (h * r - a * u) * m, t[5] = (-l * r + a * o) * m, t[6] = f * m, 
                t[7] = (-c * r + i * u) * m, t[8] = (s * r - i * o) * m;
            }
        }, {
            key: "transpose",
            value: function(e) {
                var t = e.elements, n = this.elements;
                if (e === this) {
                    var r = n[1], i = n[2], a = n[5];
                    t[1] = n[3], t[2] = n[6], t[3] = r, t[5] = n[7], t[6] = i, t[7] = a;
                } else t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], 
                t[6] = n[2], t[7] = n[5], t[8] = n[8];
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
                e[8] = 1;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, n, r;
                if ((n = this.elements) !== (r = e.elements)) for (t = 0; t < 9; ++t) r[t] = n[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Matrix3x3();
                return this.cloneTo(e), e;
            }
        } ], [ {
            key: "createRotationQuaternion",
            value: function(e, t) {
                var n = e.x, r = e.y, i = e.z, a = e.w, o = n * n, s = r * r, l = i * i, u = n * r, c = i * a, h = i * n, _ = r * a, d = r * i, f = n * a, m = t.elements;
                m[0] = 1 - 2 * (s + l), m[1] = 2 * (u + c), m[2] = 2 * (h - _), m[3] = 2 * (u - c), 
                m[4] = 1 - 2 * (l + o), m[5] = 2 * (d + f), m[6] = 2 * (h + _), m[7] = 2 * (d - f), 
                m[8] = 1 - 2 * (s + o);
            }
        }, {
            key: "createFromTranslation",
            value: function(e, t) {
                var n = t.elements;
                n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 1, n[5] = 0, n[6] = e.x, n[7] = e.y, 
                n[8] = 1;
            }
        }, {
            key: "createFromRotation",
            value: function(e, t) {
                var n = t.elements, r = Math.sin(e), i = Math.cos(e);
                n[0] = i, n[1] = r, n[2] = 0, n[3] = -r, n[4] = i, n[5] = 0, n[6] = 0, n[7] = 0, 
                n[8] = 1;
            }
        }, {
            key: "createFromScaling",
            value: function(e, t) {
                var n = t.elements;
                n[0] = e.x, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = e.y, n[5] = 0, n[6] = 0, n[7] = 0, 
                n[8] = e.z;
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var n = e.elements, r = t.elements;
                r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = n[4], r[4] = n[5], r[5] = n[6], r[6] = n[8], 
                r[7] = n[9], r[8] = n[10];
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = e.elements, i = t.elements, a = n.elements, o = r[0], s = r[1], l = r[2], u = r[3], c = r[4], h = r[5], _ = r[6], d = r[7], f = r[8], m = i[0], T = i[1], p = i[2], g = i[3], E = i[4], y = i[5], v = i[6], S = i[7], C = i[8];
                a[0] = m * o + T * u + p * _, a[1] = m * s + T * c + p * S, a[2] = m * l + T * h + p * f, 
                a[3] = g * o + E * u + y * _, a[4] = g * s + E * c + y * d, a[5] = g * l + E * h + y * f, 
                a[6] = v * o + S * u + C * _, a[7] = v * s + S * c + C * d, a[8] = v * l + S * h + C * f;
            }
        }, {
            key: "lookAt",
            value: function(e, t, n, r) {
                o.subtract(e, t, Matrix3x3._tempV30), o.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30), 
                o.cross(n, Matrix3x3._tempV30, Matrix3x3._tempV31), o.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31), 
                o.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
                var i = Matrix3x3._tempV30, a = Matrix3x3._tempV31, s = Matrix3x3._tempV32, l = r.elements;
                l[0] = a.x, l[3] = a.y, l[6] = a.z, l[1] = s.x, l[4] = s.y, l[7] = s.z, l[2] = i.x, 
                l[5] = i.y, l[8] = i.z;
            }
        } ]), Matrix3x3;
    }();
    s.DEFAULT = new s(), s._tempV30 = new o(), s._tempV31 = new o(), s._tempV32 = new o();
    var l = function ILaya3D() {
        _classCallCheck(this, ILaya3D);
    };
    l.Shader3D = null, l.Scene3D = null, l.MeshRenderStaticBatchManager = null, l.MeshRenderDynamicBatchManager = null, 
    l.SubMeshDynamicBatch = null, l.Laya3D = null, l.Matrix4x4 = null, l.Physics3D = null, 
    l.ShadowLightType = null;
    var u = function() {
        function Quaternion() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            _classCallCheck(this, Quaternion), this.x = e, this.y = t, this.z = n, this.w = r;
        }
        return _createClass(Quaternion, [ {
            key: "scaling",
            value: function(e, t) {
                t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t, 
                e.w = this.w * t);
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                e *= .5;
                var n = Math.sin(e), r = Math.cos(e);
                t.x = this.x * r + this.w * n, t.y = this.y * r + this.z * n, t.z = this.z * r - this.y * n, 
                t.w = this.w * r - this.x * n;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                e *= .5;
                var n = Math.sin(e), r = Math.cos(e);
                t.x = this.x * r - this.z * n, t.y = this.y * r + this.w * n, t.z = this.z * r + this.x * n, 
                t.w = this.w * r - this.y * n;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                e *= .5;
                var n = Math.sin(e), r = Math.cos(e);
                t.x = this.x * r + this.y * n, t.y = this.y * r - this.x * n, t.z = this.z * r + this.w * n, 
                t.w = this.w * r - this.z * n;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                o.transformQuat(o._ForwardRH, this, Quaternion.TEMPVector31), o.transformQuat(o._Up, this, Quaternion.TEMPVector32);
                var t = Quaternion.TEMPVector32;
                Quaternion.angleTo(o._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
                var n = Quaternion.TEMPVector33;
                n.x == Math.PI / 2 ? (n.y = Quaternion.arcTanAngle(t.z, t.x), n.z = 0) : n.x == -Math.PI / 2 ? (n.y = Quaternion.arcTanAngle(-t.z, -t.x), 
                n.z = 0) : (l.Matrix4x4.createRotationY(-n.y, l.Matrix4x4.TEMPMatrix0), l.Matrix4x4.createRotationX(-n.x, l.Matrix4x4.TEMPMatrix1), 
                o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix0, Quaternion.TEMPVector32), 
                o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32), 
                n.z = Quaternion.arcTanAngle(t.y, -t.x)), n.y <= -Math.PI && (n.y = Math.PI), n.z <= -Math.PI && (n.z = Math.PI), 
                n.y >= Math.PI && n.z >= Math.PI && (n.y = 0, n.z = 0, n.x = Math.PI - n.x);
                var r = e;
                r.x = n.y, r.y = n.x, r.z = n.z;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.x, n = this.y, r = this.z, i = this.w, a = t * t + n * n + r * r + i * i, o = a ? 1 / a : 0;
                e.x = -t * o, e.y = -n * o, e.z = -r * o, e.w = i * o;
            }
        }, {
            key: "identity",
            value: function() {
                this.x = 0, this.y = 0, this.z = 0, this.w = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Quaternion();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function(e) {
                return n.nearEqual(this.x, e.x) && n.nearEqual(this.y, e.y) && n.nearEqual(this.z, e.z) && n.nearEqual(this.w, e.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
                this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
                r.rewriteNumProperty(this, "x", 0), r.rewriteNumProperty(this, "y", 1), r.rewriteNumProperty(this, "z", 2), 
                r.rewriteNumProperty(this, "w", 3);
            }
        } ], [ {
            key: "createFromYawPitchRoll",
            value: function(e, t, n, r) {
                var i = .5 * n, a = .5 * t, o = .5 * e, s = Math.sin(i), l = Math.cos(i), u = Math.sin(a), c = Math.cos(a), h = Math.sin(o), _ = Math.cos(o);
                r.x = _ * u * l + h * c * s, r.y = h * c * l - _ * u * s, r.z = _ * c * s - h * u * l, 
                r.w = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = e.w, s = t.x, l = t.y, u = t.z, c = t.w, h = i * u - a * l, _ = a * s - r * u, d = r * l - i * s, f = r * s + i * l + a * u;
                n.x = r * c + s * o + h, n.y = i * c + l * o + _, n.z = a * c + u * o + d, n.w = o * c - f;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, n) {
                o.subtract(t, e, Quaternion.TEMPVector30), o.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30), 
                n.x = Math.asin(Quaternion.TEMPVector30.y), n.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, n) {
                t *= .5;
                var r = Math.sin(t);
                n.x = r * e.x, n.y = r * e.y, n.z = r * e.z, n.w = Math.cos(t);
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var n, r, i = e.elements, a = i[0] + i[5] + i[10];
                a > 0 ? (n = Math.sqrt(a + 1), t.w = .5 * n, n = .5 / n, t.x = (i[6] - i[9]) * n, 
                t.y = (i[8] - i[2]) * n, t.z = (i[1] - i[4]) * n) : i[0] >= i[5] && i[0] >= i[10] ? (r = .5 / (n = Math.sqrt(1 + i[0] - i[5] - i[10])), 
                t.x = .5 * n, t.y = (i[1] + i[4]) * r, t.z = (i[2] + i[8]) * r, t.w = (i[6] - i[9]) * r) : i[5] > i[10] ? (r = .5 / (n = Math.sqrt(1 + i[5] - i[0] - i[10])), 
                t.x = (i[4] + i[1]) * r, t.y = .5 * n, t.z = (i[9] + i[6]) * r, t.w = (i[8] - i[2]) * r) : (r = .5 / (n = Math.sqrt(1 + i[10] - i[0] - i[5])), 
                t.x = (i[8] + i[2]) * r, t.y = (i[9] + i[6]) * r, t.z = .5 * n, t.w = (i[1] - i[4]) * r);
            }
        }, {
            key: "slerp",
            value: function(e, t, n, r) {
                var i, a, o, s, l, u = e.x, c = e.y, h = e.z, _ = e.w, d = t.x, f = t.y, m = t.z, T = t.w;
                return (a = u * d + c * f + h * m + _ * T) < 0 && (a = -a, d = -d, f = -f, m = -m, 
                T = -T), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math.sin((1 - n) * i) / o, 
                l = Math.sin(n * i) / o) : (s = 1 - n, l = n), r.x = s * u + l * d, r.y = s * c + l * f, 
                r.z = s * h + l * m, r.w = s * _ + l * T, r;
            }
        }, {
            key: "lerp",
            value: function(e, t, n, r) {
                var i = 1 - n;
                Quaternion.dot(e, t) >= 0 ? (r.x = i * e.x + n * t.x, r.y = i * e.y + n * t.y, r.z = i * e.z + n * t.z, 
                r.w = i * e.w + n * t.w) : (r.x = i * e.x - n * t.x, r.y = i * e.y - n * t.y, r.z = i * e.z - n * t.z, 
                r.w = i * e.w - n * t.w), r.normalize(r);
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, n) {
                Quaternion.lookAt(o._ZERO, e, t, n);
            }
        }, {
            key: "lookAt",
            value: function(e, t, n, r) {
                s.lookAt(e, t, n, Quaternion._tempMatrix3x3), Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, r);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var r = e.lengthSquared();
                n.isZero(r) || (r = 1 / r, t.x = -e.x * r, t.y = -e.y * r, t.z = -e.z * r, t.w = e.w * r);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var n, r, i = e.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], h = i[6], _ = i[7], d = i[8], f = a + u + d;
                f > 0 ? (n = Math.sqrt(f + 1), t.w = .5 * n, n = .5 / n, t.x = (c - _) * n, t.y = (h - s) * n, 
                t.z = (o - l) * n) : a >= u && a >= d ? (r = .5 / (n = Math.sqrt(1 + a - u - d)), 
                t.x = .5 * n, t.y = (o + l) * r, t.z = (s + h) * r, t.w = (c - _) * r) : u > d ? (r = .5 / (n = Math.sqrt(1 + u - a - d)), 
                t.x = (l + o) * r, t.y = .5 * n, t.z = (_ + c) * r, t.w = (h - s) * r) : (r = .5 / (n = Math.sqrt(1 + d - a - u)), 
                t.x = (h + s) * r, t.y = (_ + c) * r, t.z = .5 * n, t.w = (o - l) * r);
            }
        } ]), Quaternion;
    }();
    u.TEMPVector30 = new o(), u.TEMPVector31 = new o(), u.TEMPVector32 = new o(), u.TEMPVector33 = new o(), 
    u._tempMatrix3x3 = new s(), u.DEFAULT = new u(), u.NAN = new u(NaN, NaN, NaN, NaN);
    var c = function() {
        function Matrix4x4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0, s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0, l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, u = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1, h = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0, _ = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0, d = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0, f = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0, m = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1, T = arguments.length > 16 && void 0 !== arguments[16] ? arguments[16] : null;
            _classCallCheck(this, Matrix4x4);
            var p = this.elements = T || new Float32Array(16);
            p[0] = e, p[1] = t, p[2] = n, p[3] = r, p[4] = i, p[5] = a, p[6] = o, p[7] = s, 
            p[8] = l, p[9] = u, p[10] = c, p[11] = h, p[12] = _, p[13] = d, p[14] = f, p[15] = m;
        }
        return _createClass(Matrix4x4, [ {
            key: "setRotation",
            value: function(e) {
                var t = e.x, n = e.y, r = e.z, i = e.w, a = t * t, o = n * n, s = r * r, l = t * n, u = r * i, c = r * t, h = n * i, _ = n * r, d = t * i, f = this.elements;
                f[0] = 1 - 2 * (o + s), f[1] = 2 * (l + u), f[2] = 2 * (c - h), f[4] = 2 * (l - u), 
                f[5] = 1 - 2 * (s + a), f[6] = 2 * (_ + d), f[8] = 2 * (c + h), f[9] = 2 * (_ - d), 
                f[10] = 1 - 2 * (o + a);
            }
        }, {
            key: "setPosition",
            value: function(e) {
                var t = this.elements;
                t[12] = e.x, t[13] = e.y, t[14] = e.z;
            }
        }, {
            key: "getElementByRowColumn",
            value: function(e, t) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * e + t];
            }
        }, {
            key: "setElementByRowColumn",
            value: function(e, t, n) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * e + t] = n;
            }
        }, {
            key: "equalsOtherMatrix",
            value: function(e) {
                var t = this.elements, r = e.elements;
                return n.nearEqual(t[0], r[0]) && n.nearEqual(t[1], r[1]) && n.nearEqual(t[2], r[2]) && n.nearEqual(t[3], r[3]) && n.nearEqual(t[4], r[4]) && n.nearEqual(t[5], r[5]) && n.nearEqual(t[6], r[6]) && n.nearEqual(t[7], r[7]) && n.nearEqual(t[8], r[8]) && n.nearEqual(t[9], r[9]) && n.nearEqual(t[10], r[10]) && n.nearEqual(t[11], r[11]) && n.nearEqual(t[12], r[12]) && n.nearEqual(t[13], r[13]) && n.nearEqual(t[14], r[14]) && n.nearEqual(t[15], r[15]);
            }
        }, {
            key: "decomposeTransRotScale",
            value: function(e, t, n) {
                var r = Matrix4x4._tempMatrix4x4;
                return this.decomposeTransRotMatScale(e, r, n) ? (u.createFromMatrix4x4(r, t), !0) : (t.identity(), 
                !1);
            }
        }, {
            key: "decomposeTransRotMatScale",
            value: function(e, t, r) {
                var i = this.elements, a = e, s = t.elements, l = r;
                a.x = i[12], a.y = i[13], a.z = i[14];
                var u = i[0], c = i[1], h = i[2], _ = i[4], d = i[5], f = i[6], m = i[8], T = i[9], p = i[10], g = l.x = Math.sqrt(u * u + c * c + h * h), E = l.y = Math.sqrt(_ * _ + d * d + f * f), y = l.z = Math.sqrt(m * m + T * T + p * p);
                if (n.isZero(g) || n.isZero(E) || n.isZero(y)) return s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[8] = s[9] = s[11] = s[12] = s[13] = s[14] = 0, 
                s[0] = s[5] = s[10] = s[15] = 1, !1;
                var v = Matrix4x4._tempVector0;
                v.x = m / y, v.y = T / y, v.z = p / y;
                var S = Matrix4x4._tempVector1;
                S.x = u / g, S.y = c / g, S.z = h / g;
                var C = Matrix4x4._tempVector2;
                o.cross(v, S, C);
                var R = Matrix4x4._tempVector1;
                return o.cross(C, v, R), s[3] = s[7] = s[11] = s[12] = s[13] = s[14] = 0, s[15] = 1, 
                s[0] = R.x, s[1] = R.y, s[2] = R.z, s[4] = C.x, s[5] = C.y, s[6] = C.z, s[8] = v.x, 
                s[9] = v.y, s[10] = v.z, s[0] * u + s[1] * c + s[2] * h < 0 && (l.x = -g), s[4] * _ + s[5] * d + s[6] * f < 0 && (l.y = -E), 
                s[8] * m + s[9] * T + s[10] * p < 0 && (l.z = -y), !0;
            }
        }, {
            key: "decomposeYawPitchRoll",
            value: function(e) {
                var t = Math.asin(-this.elements[9]);
                e.y = t, Math.cos(t) > n.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]), 
                e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]), 
                e.x = 0);
            }
        }, {
            key: "normalize",
            value: function() {
                var e = this.elements, t = e[0], n = e[1], r = e[2], i = Math.sqrt(t * t + n * n + r * r);
                if (!i) return e[0] = 0, e[1] = 0, void (e[2] = 0);
                1 != i && (i = 1 / i, e[0] = t * i, e[1] = n * i, e[2] = r * i);
            }
        }, {
            key: "transpose",
            value: function() {
                var e, t;
                return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], 
                e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7], 
                e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.elements, n = e.elements, r = t[0], i = t[1], a = t[2], o = t[3], s = t[4], l = t[5], u = t[6], c = t[7], h = t[8], _ = t[9], d = t[10], f = t[11], m = t[12], T = t[13], p = t[14], g = t[15], E = r * l - i * s, y = r * u - a * s, v = r * c - o * s, S = i * u - a * l, C = i * c - o * l, R = a * c - o * u, D = h * T - _ * m, M = h * p - d * m, A = h * g - f * m, x = _ * p - d * T, L = _ * g - f * T, I = d * g - f * p, O = E * I - y * L + v * x + S * A - C * M + R * D;
                0 !== Math.abs(O) && (O = 1 / O, n[0] = (l * I - u * L + c * x) * O, n[1] = (a * L - i * I - o * x) * O, 
                n[2] = (T * R - p * C + g * S) * O, n[3] = (d * C - _ * R - f * S) * O, n[4] = (u * A - s * I - c * M) * O, 
                n[5] = (r * I - a * A + o * M) * O, n[6] = (p * v - m * R - g * y) * O, n[7] = (h * R - d * v + f * y) * O, 
                n[8] = (s * L - l * A + c * D) * O, n[9] = (i * A - r * L - o * D) * O, n[10] = (m * C - T * v + g * E) * O, 
                n[11] = (_ * v - h * C - f * E) * O, n[12] = (l * M - s * x - u * D) * O, n[13] = (r * x - i * M + a * D) * O, 
                n[14] = (T * y - m * S - p * E) * O, n[15] = (h * S - _ * y + d * E) * O);
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
                e[0] = e[5] = e[10] = e[15] = 1;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, n, r;
                if ((n = this.elements) !== (r = e.elements)) for (t = 0; t < 16; ++t) r[t] = n[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Matrix4x4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "getTranslationVector",
            value: function(e) {
                var t = this.elements;
                e.x = t[12], e.y = t[13], e.z = t[14];
            }
        }, {
            key: "setTranslationVector",
            value: function(e) {
                var t = this.elements, n = e;
                t[12] = n.x, t[13] = n.y, t[14] = n.z;
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "setForward",
            value: function(e) {
                var t = this.elements;
                t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
            }
        } ], [ {
            key: "createRotationX",
            value: function(e, t) {
                var n = t.elements, r = Math.sin(e), i = Math.cos(e);
                n[1] = n[2] = n[3] = n[4] = n[7] = n[8] = n[11] = n[12] = n[13] = n[14] = 0, n[0] = n[15] = 1, 
                n[5] = n[10] = i, n[6] = r, n[9] = -r;
            }
        }, {
            key: "createRotationY",
            value: function(e, t) {
                var n = t.elements, r = Math.sin(e), i = Math.cos(e);
                n[1] = n[3] = n[4] = n[6] = n[7] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[5] = n[15] = 1, 
                n[0] = n[10] = i, n[2] = -r, n[8] = r;
            }
        }, {
            key: "createRotationZ",
            value: function(e, t) {
                var n = t.elements, r = Math.sin(e), i = Math.cos(e);
                n[2] = n[3] = n[6] = n[7] = n[8] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[10] = n[15] = 1, 
                n[0] = n[5] = i, n[1] = r, n[4] = -r;
            }
        }, {
            key: "createRotationYawPitchRoll",
            value: function(e, t, n, r) {
                u.createFromYawPitchRoll(e, t, n, Matrix4x4._tempQuaternion), Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, r);
            }
        }, {
            key: "createRotationAxis",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = Math.cos(t), s = Math.sin(t), l = r * r, u = i * i, c = a * a, h = r * i, _ = r * a, d = i * a, f = n.elements;
                f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + o * (1 - l), 
                f[1] = h - o * h + s * a, f[2] = _ - o * _ - s * i, f[4] = h - o * h - s * a, f[5] = u + o * (1 - u), 
                f[6] = d - o * d + s * r, f[8] = _ - o * _ + s * i, f[9] = d - o * d - s * r, f[10] = c + o * (1 - c);
            }
        }, {
            key: "createRotationQuaternion",
            value: function(e, t) {
                var n = t.elements, r = e.x, i = e.y, a = e.z, o = e.w, s = r * r, l = i * i, u = a * a, c = r * i, h = a * o, _ = a * r, d = i * o, f = i * a, m = r * o;
                n[3] = n[7] = n[11] = n[12] = n[13] = n[14] = 0, n[15] = 1, n[0] = 1 - 2 * (l + u), 
                n[1] = 2 * (c + h), n[2] = 2 * (_ - d), n[4] = 2 * (c - h), n[5] = 1 - 2 * (u + s), 
                n[6] = 2 * (f + m), n[8] = 2 * (_ + d), n[9] = 2 * (f - m), n[10] = 1 - 2 * (l + s);
            }
        }, {
            key: "createTranslate",
            value: function(e, t) {
                var n = t.elements;
                n[4] = n[8] = n[1] = n[9] = n[2] = n[6] = n[3] = n[7] = n[11] = 0, n[0] = n[5] = n[10] = n[15] = 1, 
                n[12] = e.x, n[13] = e.y, n[14] = e.z;
            }
        }, {
            key: "createScaling",
            value: function(e, t) {
                var n = t.elements;
                n[0] = e.x, n[5] = e.y, n[10] = e.z, n[1] = n[4] = n[8] = n[12] = n[9] = n[13] = n[2] = n[6] = n[14] = n[3] = n[7] = n[11] = 0, 
                n[15] = 1;
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = t.elements, i = e.elements, a = n.elements, o = r[0], s = r[1], l = r[2], u = r[3], c = r[4], h = r[5], _ = r[6], d = r[7], f = r[8], m = r[9], T = r[10], p = r[11], g = r[12], E = r[13], y = r[14], v = r[15], S = i[0], C = i[1], R = i[2], D = i[3], M = i[4], A = i[5], x = i[6], L = i[7], I = i[8], O = i[9], P = i[10], N = i[11], b = i[12], k = i[13], w = i[14], B = i[15];
                a[0] = o * S + s * M + l * I + u * b, a[1] = o * C + s * A + l * O + u * k, a[2] = o * R + s * x + l * P + u * w, 
                a[3] = o * D + s * L + l * N + u * B, a[4] = c * S + h * M + _ * I + d * b, a[5] = c * C + h * A + _ * O + d * k, 
                a[6] = c * R + h * x + _ * P + d * w, a[7] = c * D + h * L + _ * N + d * B, a[8] = f * S + m * M + T * I + p * b, 
                a[9] = f * C + m * A + T * O + p * k, a[10] = f * R + m * x + T * P + p * w, a[11] = f * D + m * L + T * N + p * B, 
                a[12] = g * S + E * M + y * I + v * b, a[13] = g * C + E * A + y * O + v * k, a[14] = g * R + E * x + y * P + v * w, 
                a[15] = g * D + E * L + y * N + v * B;
            }
        }, {
            key: "multiplyForNative",
            value: function(e, n, r) {
                t.LayaGL.instance.matrix4x4Multiply(e.elements, n.elements, r.elements);
            }
        }, {
            key: "createFromQuaternion",
            value: function(e, t) {
                var n = t.elements, r = e.x, i = e.y, a = e.z, o = e.w, s = r + r, l = i + i, u = a + a, c = r * s, h = i * s, _ = i * l, d = a * s, f = a * l, m = a * u, T = o * s, p = o * l, g = o * u;
                n[0] = 1 - _ - m, n[1] = h + g, n[2] = d - p, n[3] = 0, n[4] = h - g, n[5] = 1 - c - m, 
                n[6] = f + T, n[7] = 0, n[8] = d + p, n[9] = f - T, n[10] = 1 - c - _, n[11] = 0, 
                n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1;
            }
        }, {
            key: "createAffineTransformation",
            value: function(e, t, n, r) {
                var i = r.elements, a = t.x, o = t.y, s = t.z, l = t.w, u = a + a, c = o + o, h = s + s, _ = a * u, d = a * c, f = a * h, m = o * c, T = o * h, p = s * h, g = l * u, E = l * c, y = l * h, v = n.x, S = n.y, C = n.z;
                i[0] = (1 - (m + p)) * v, i[1] = (d + y) * v, i[2] = (f - E) * v, i[3] = 0, i[4] = (d - y) * S, 
                i[5] = (1 - (_ + p)) * S, i[6] = (T + g) * S, i[7] = 0, i[8] = (f + E) * C, i[9] = (T - g) * C, 
                i[10] = (1 - (_ + m)) * C, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
            }
        }, {
            key: "createLookAt",
            value: function(e, t, n, r) {
                var i = r.elements, a = Matrix4x4._tempVector0, s = Matrix4x4._tempVector1, l = Matrix4x4._tempVector2;
                o.subtract(e, t, l), o.normalize(l, l), o.cross(n, l, a), o.normalize(a, a), o.cross(l, a, s), 
                i[3] = i[7] = i[11] = 0, i[15] = 1, i[0] = a.x, i[4] = a.y, i[8] = a.z, i[1] = s.x, 
                i[5] = s.y, i[9] = s.z, i[2] = l.x, i[6] = l.y, i[10] = l.z, i[12] = -o.dot(a, e), 
                i[13] = -o.dot(s, e), i[14] = -o.dot(l, e);
            }
        }, {
            key: "createPerspective",
            value: function(e, t, n, r, i) {
                var a = 1 / Math.tan(.5 * e), o = n / (a / t), s = n / a;
                Matrix4x4.createPerspectiveOffCenter(-o, o, -s, s, n, r, i);
            }
        }, {
            key: "createPerspectiveOffCenter",
            value: function(e, t, n, r, i, a, o) {
                var s = o.elements, l = a / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0, s[0] = 2 * i / (t - e), 
                s[5] = 2 * i / (r - n), s[8] = (e + t) / (t - e), s[9] = (r + n) / (r - n), s[10] = -l, 
                s[11] = -1, s[14] = -i * l;
            }
        }, {
            key: "createOrthoOffCenter",
            value: function(e, t, n, r, i, a, o) {
                var s = o.elements, l = 1 / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0, s[15] = 1, s[0] = 2 / (t - e), 
                s[5] = 2 / (r - n), s[10] = -l, s[12] = (e + t) / (e - t), s[13] = (r + n) / (n - r), 
                s[14] = -i * l;
            }
        }, {
            key: "billboard",
            value: function(e, t, r, i, a, s) {
                o.subtract(e, t, Matrix4x4._tempVector0);
                var l = o.scalarLengthSquared(Matrix4x4._tempVector0);
                n.isZero(l) ? (o.scale(a, -1, Matrix4x4._tempVector1), Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0)) : o.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(l), Matrix4x4._tempVector0), 
                o.cross(i, Matrix4x4._tempVector0, Matrix4x4._tempVector2), o.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2), 
                o.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
                var u = Matrix4x4._tempVector2, c = Matrix4x4._tempVector3, h = Matrix4x4._tempVector0, _ = e, d = s.elements;
                d[0] = u.x, d[1] = u.y, d[2] = u.z, d[3] = 0, d[4] = c.x, d[5] = c.y, d[6] = c.z, 
                d[7] = 0, d[8] = h.x, d[9] = h.y, d[10] = h.z, d[11] = 0, d[12] = _.x, d[13] = _.y, 
                d[14] = _.z, d[15] = 1;
            }
        }, {
            key: "translation",
            value: function(e, t) {
                var n = t.elements;
                n[0] = n[5] = n[10] = n[15] = 1, n[12] = e.x, n[13] = e.y, n[14] = e.z;
            }
        } ]), Matrix4x4;
    }();
    c._tempMatrix4x4 = new c(), c.TEMPMatrix0 = new c(), c.TEMPMatrix1 = new c(), c._tempVector0 = new o(), 
    c._tempVector1 = new o(), c._tempVector2 = new o(), c._tempVector3 = new o(), c._tempQuaternion = new u(), 
    c.DEFAULT = new c(), c.ZERO = new c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var h = function() {
        function ColliderShape() {
            _classCallCheck(this, ColliderShape), this._scale = new o(1, 1, 1), this._centerMatrix = new c(), 
            this._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null, 
            this._referenceCount = 0, this._localOffset = new o(0, 0, 0), this._localRotation = new u(0, 0, 0, 1), 
            this.needsCustomCollisionCallback = !1;
        }
        return _createClass(ColliderShape, [ {
            key: "_setScale",
            value: function(e) {
                if (this._compoundParent) this.updateLocalTransformations(); else {
                    var t = l.Physics3D._bullet;
                    t.btVector3_setValue(ColliderShape._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale);
                }
            }
        }, {
            key: "_addReference",
            value: function() {
                this._referenceCount++;
            }
        }, {
            key: "_removeReference",
            value: function() {
                this._referenceCount--;
            }
        }, {
            key: "updateLocalTransformations",
            value: function() {
                if (this._compoundParent) {
                    var e = ColliderShape._tempVector30;
                    o.multiply(this.localOffset, this._scale, e), ColliderShape._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
                } else ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation), 
                t.localOffset = t.localOffset, t.localRotation = t.localRotation;
            }
        }, {
            key: "clone",
            value: function() {
                return null;
            }
        }, {
            key: "destroy",
            value: function() {
                this._btShape && (l.Physics3D._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "localOffset",
            get: function() {
                return this._localOffset;
            },
            set: function(e) {
                this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        }, {
            key: "localRotation",
            get: function() {
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = l.Physics3D._bullet;
                ColliderShape._btScale = e.btVector3_create(1, 1, 1), ColliderShape._btVector30 = e.btVector3_create(0, 0, 0), 
                ColliderShape._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), ColliderShape._btTransform0 = e.btTransform_create();
            }
        }, {
            key: "_createAffineTransformation",
            value: function(e, t, n) {
                var r = t.x, i = t.y, a = t.z, o = t.w, s = r + r, l = i + i, u = a + a, c = r * s, h = r * l, _ = r * u, d = i * l, f = i * u, m = a * u, T = o * s, p = o * l, g = o * u;
                n[0] = 1 - (d + m), n[1] = h + g, n[2] = _ - p, n[3] = 0, n[4] = h - g, n[5] = 1 - (c + m), 
                n[6] = f + T, n[7] = 0, n[8] = _ + p, n[9] = f - T, n[10] = 1 - (c + d), n[11] = 0, 
                n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1;
            }
        } ]), ColliderShape;
    }();
    h.SHAPEORIENTATION_UPX = 0, h.SHAPEORIENTATION_UPY = 1, h.SHAPEORIENTATION_UPZ = 2, 
    h.SHAPETYPES_BOX = 0, h.SHAPETYPES_SPHERE = 1, h.SHAPETYPES_CYLINDER = 2, h.SHAPETYPES_CAPSULE = 3, 
    h.SHAPETYPES_CONVEXHULL = 4, h.SHAPETYPES_COMPOUND = 5, h.SHAPETYPES_STATICPLANE = 6, 
    h.SHAPETYPES_CONE = 7, h._tempVector30 = new o();
    var _ = function(e) {
        function StaticPlaneColliderShape(e, t) {
            var n;
            _classCallCheck(this, StaticPlaneColliderShape), (n = _possibleConstructorReturn(this, _getPrototypeOf(StaticPlaneColliderShape).call(this)))._normal = e, 
            n._offset = t, n._type = h.SHAPETYPES_STATICPLANE;
            var r = l.Physics3D._bullet;
            return r.btVector3_setValue(StaticPlaneColliderShape._btNormal, -e.x, e.y, e.z), 
            n._btShape = r.btStaticPlaneShape_create(StaticPlaneColliderShape._btNormal, t), 
            n;
        }
        return _inherits(StaticPlaneColliderShape, h), _createClass(StaticPlaneColliderShape, [ {
            key: "clone",
            value: function() {
                var e = new StaticPlaneColliderShape(this._normal, this._offset);
                return this.cloneTo(e), e;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                StaticPlaneColliderShape._btNormal = l.Physics3D._bullet.btVector3_create(0, 0, 0);
            }
        } ]), StaticPlaneColliderShape;
    }(), d = function(e) {
        function CompoundColliderShape() {
            var e;
            return _classCallCheck(this, CompoundColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CompoundColliderShape).call(this)))._childColliderShapes = [], 
            e._type = h.SHAPETYPES_COMPOUND, e._btShape = l.Physics3D._bullet.btCompoundShape_create(), 
            e;
        }
        return _inherits(CompoundColliderShape, h), _createClass(CompoundColliderShape, [ {
            key: "_clearChildShape",
            value: function(e) {
                e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
            }
        }, {
            key: "_addReference",
            value: function() {}
        }, {
            key: "_removeReference",
            value: function() {}
        }, {
            key: "_updateChildTransform",
            value: function(e) {
                var t = l.Physics3D._bullet, n = e.localOffset, r = e.localRotation, i = h._btVector30, a = h._btQuaternion0, o = h._btTransform0;
                t.btVector3_setValue(i, -n.x, n.y, n.z), t.btQuaternion_setValue(a, -r.x, r.y, r.z, -r.w), 
                t.btTransform_setOrigin(o, i), t.btTransform_setRotation(o, a), t.btCompoundShape_updateChildTransform(this._btShape, e._indexInCompound, o, !0);
            }
        }, {
            key: "addChildShape",
            value: function(e) {
                if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
                e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length, 
                this._childColliderShapes.push(e);
                var t = e.localOffset, n = e.localRotation, r = l.Physics3D._bullet;
                r.btVector3_setValue(CompoundColliderShape._btOffset, -t.x, t.y, t.z), r.btQuaternion_setValue(CompoundColliderShape._btRotation, -n.x, n.y, n.z, -n.w), 
                r.btTransform_setOrigin(CompoundColliderShape._btTransform, CompoundColliderShape._btOffset), 
                r.btTransform_setRotation(CompoundColliderShape._btTransform, CompoundColliderShape._btRotation);
                var i = r.btCollisionShape_getLocalScaling(this._btShape);
                r.btCollisionShape_setLocalScaling(this._btShape, CompoundColliderShape._btVector3One), 
                r.btCompoundShape_addChildShape(this._btShape, CompoundColliderShape._btTransform, e._btShape), 
                r.btCollisionShape_setLocalScaling(this._btShape, i), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
            }
        }, {
            key: "removeChildShape",
            value: function(e) {
                if (e._compoundParent === this) {
                    var t = e._indexInCompound;
                    this._clearChildShape(e);
                    var n = this._childColliderShapes[this._childColliderShapes.length - 1];
                    n._indexInCompound = t, this._childColliderShapes[t] = n, this._childColliderShapes.pop(), 
                    l.Physics3D._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, t);
                }
            }
        }, {
            key: "clearChildShape",
            value: function() {
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this._clearChildShape(this._childColliderShapes[e]), 
                l.Physics3D._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
                this._childColliderShapes.length = 0;
            }
        }, {
            key: "getChildShapeCount",
            value: function() {
                return this._childColliderShapes.length;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.clearChildShape();
                for (var n = 0, r = this._childColliderShapes.length; n < r; n++) t.addChildShape(this._childColliderShapes[n].clone());
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CompoundColliderShape();
                return this.cloneTo(e), e;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(CompoundColliderShape.prototype), "destroy", this).call(this);
                for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                    var n = this._childColliderShapes[e];
                    0 === n._referenceCount && n.destroy();
                }
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = l.Physics3D._bullet;
                CompoundColliderShape._btVector3One = e.btVector3_create(1, 1, 1), CompoundColliderShape._btTransform = e.btTransform_create(), 
                CompoundColliderShape._btOffset = e.btVector3_create(0, 0, 0), CompoundColliderShape._btRotation = e.btQuaternion_create(0, 0, 0, 1);
            }
        } ]), CompoundColliderShape;
    }(), f = function(e) {
        function Transform3D(e) {
            var t;
            return _classCallCheck(this, Transform3D), (t = _possibleConstructorReturn(this, _getPrototypeOf(Transform3D).call(this)))._localPosition = new o(0, 0, 0), 
            t._localRotation = new u(0, 0, 0, 1), t._localScale = new o(1, 1, 1), t._localRotationEuler = new o(0, 0, 0), 
            t._localMatrix = new c(), t._position = new o(0, 0, 0), t._rotation = new u(0, 0, 0, 1), 
            t._scale = new o(1, 1, 1), t._rotationEuler = new o(0, 0, 0), t._worldMatrix = new c(), 
            t._children = null, t._parent = null, t._dummy = null, t._transformFlag = 0, t._owner = e, 
            t._children = [], t._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !1), 
            t._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, !0), 
            t;
        }
        return _inherits(Transform3D, t.EventDispatcher), _createClass(Transform3D, [ {
            key: "_getScaleMatrix",
            value: function() {
                var e = Transform3D._tempQuaternion0, t = Transform3D._tempMatrix3x30, n = Transform3D._tempMatrix3x31, r = Transform3D._tempMatrix3x32;
                return s.createFromMatrix4x4(this.worldMatrix, n), this.rotation.invert(e), s.createRotationQuaternion(e, t), 
                s.multiply(t, n, r), r;
            }
        }, {
            key: "_setTransformFlag",
            value: function(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children, n = t.indexOf(this);
                        t.splice(n, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "_onWorldPositionRotationTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldPositionScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldPositionTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldPositionTransform();
                }
            }
        }, {
            key: "_onWorldRotationTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, !0), 
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "translate",
            value: function(e) {
                !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? (c.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0), 
                o.transformCoordinate(e, Transform3D._tempMatrix0, Transform3D._tempVector30), o.add(this.localPosition, Transform3D._tempVector30, this._localPosition), 
                this.localPosition = this._localPosition) : (o.add(this.position, e, this._position), 
                this.position = this._position);
            }
        }, {
            key: "rotate",
            value: function(e) {
                var t, n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? t = e : (o.scale(e, Math.PI / 180, Transform3D._tempVector30), 
                t = Transform3D._tempVector30), u.createFromYawPitchRoll(t.y, t.x, t.z, Transform3D._tempQuaternion0), 
                n ? (u.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation), 
                this.localRotation = this._localRotation) : (u.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation), 
                this.rotation = this._rotation);
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "getUp",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[4], e.y = t[5], e.z = t[6];
            }
        }, {
            key: "getRight",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[0], e.y = t[1], e.z = t[2];
            }
        }, {
            key: "lookAt",
            value: function(e, t) {
                var r;
                if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
                    if (r = this._localPosition, Math.abs(r.x - e.x) < n.zeroTolerance && Math.abs(r.y - e.y) < n.zeroTolerance && Math.abs(r.z - e.z) < n.zeroTolerance) return;
                    u.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation), 
                    this.localRotation = this._localRotation;
                } else {
                    var i = this.position;
                    if (r = i, Math.abs(r.x - e.x) < n.zeroTolerance && Math.abs(r.y - e.y) < n.zeroTolerance && Math.abs(r.z - e.z) < n.zeroTolerance) return;
                    u.lookAt(i, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
                }
            }
        }, {
            key: "getWorldLossyScale",
            value: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    if (null !== this._parent) {
                        var e = this._getScaleMatrix().elements;
                        this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8];
                    } else this._localScale.cloneTo(this._scale);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
                }
                return this._scale;
            }
        }, {
            key: "setWorldLossyScale",
            value: function(e) {
                if (null !== this._parent) {
                    var t = Transform3D._tempMatrix3x33, n = Transform3D._tempMatrix3x33, r = n.elements, i = this._parent._getScaleMatrix();
                    i.invert(i), s.createFromScaling(e, t), s.multiply(i, t, n), this._localScale.x = r[0], 
                    this._localScale.y = r[4], this._localScale.z = r[8];
                } else e.cloneTo(this._localScale);
                this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
            }
        }, {
            key: "_isFrontFaceInvert",
            get: function() {
                var e = this.getWorldLossyScale(), t = e.x < 0;
                return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
            }
        }, {
            key: "owner",
            get: function() {
                return this._owner;
            }
        }, {
            key: "worldNeedUpdate",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
            }
        }, {
            key: "localPositionX",
            get: function() {
                return this._localPosition.x;
            },
            set: function(e) {
                this._localPosition.x = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionY",
            get: function() {
                return this._localPosition.y;
            },
            set: function(e) {
                this._localPosition.y = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionZ",
            get: function() {
                return this._localPosition.z;
            },
            set: function(e) {
                this._localPosition.z = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0), 
                this._onWorldPositionTransform();
            }
        }, {
            key: "localRotationX",
            get: function() {
                return this.localRotation.x;
            },
            set: function(e) {
                this._localRotation.x = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationY",
            get: function() {
                return this.localRotation.y;
            },
            set: function(e) {
                this._localRotation.y = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationZ",
            get: function() {
                return this.localRotation.z;
            },
            set: function(e) {
                this._localRotation.z = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationW",
            get: function() {
                return this.localRotation.w;
            },
            set: function(e) {
                this._localRotation.w = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                    var e = this._localRotationEuler;
                    u.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._localRotation), 
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1);
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation), 
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !0), 
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1), this._onWorldRotationTransform();
            }
        }, {
            key: "localScaleX",
            get: function() {
                return this._localScale.x;
            },
            set: function(e) {
                this._localScale.x = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleY",
            get: function() {
                return this._localScale.y;
            },
            set: function(e) {
                this._localScale.y = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleZ",
            get: function() {
                return this._localScale.z;
            },
            set: function(e) {
                this._localScale.z = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0), 
                this._onWorldScaleTransform();
            }
        }, {
            key: "localRotationEulerX",
            get: function() {
                return this.localRotationEuler.x;
            },
            set: function(e) {
                this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerY",
            get: function() {
                return this.localRotationEuler.y;
            },
            set: function(e) {
                this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerZ",
            get: function() {
                return this.localRotationEuler.z;
            },
            set: function(e) {
                this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                    this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30, t = this._localRotationEuler;
                    t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin, 
                    t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1);
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1), 
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, !0), 
                this._onWorldRotationTransform();
            }
        }, {
            key: "localMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX) && (c.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix), 
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix;
            },
            set: function(e) {
                this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale), 
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1), 
                this._onWorldTransform();
            }
        }, {
            key: "position",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    if (null != this._parent) {
                        var e = this.worldMatrix.elements;
                        this._position.x = e[12], this._position.y = e[13], this._position.z = e[14];
                    } else this._localPosition.cloneTo(this._position);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
                }
                return this._position;
            },
            set: function(e) {
                if (null != this._parent) {
                    var t = Transform3D._tempMatrix0;
                    this._parent.worldMatrix.invert(t), o.transformCoordinate(e, t, this._localPosition);
                } else e.cloneTo(this._localPosition);
                this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? u.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)), this._rotation;
            },
            set: function(e) {
                null != this._parent ? (this._parent.rotation.invert(Transform3D._tempQuaternion0), 
                u.multiply(Transform3D._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation), 
                this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1);
            }
        }, {
            key: "rotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30, t = this._rotationEuler;
                    t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin, 
                    t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
                }
                return this._rotationEuler;
            },
            set: function(e) {
                u.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._rotation), 
                this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
            }
        }, {
            key: "worldMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && (null != this._parent ? c.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix), 
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix;
            },
            set: function(e) {
                null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix), 
                c.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix, 
                this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1);
            }
        }, {
            key: "scale",
            get: function() {
                return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."), 
                this.getWorldLossyScale();
            },
            set: function(e) {
                console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."), 
                this.setWorldLossyScale(e);
            }
        } ]), Transform3D;
    }();
    f._tempVector30 = new o(), f._tempQuaternion0 = new u(), f._tempMatrix0 = new c(), 
    f._tempMatrix3x30 = new s(), f._tempMatrix3x31 = new s(), f._tempMatrix3x32 = new s(), 
    f._tempMatrix3x33 = new s(), f.TRANSFORM_LOCALQUATERNION = 1, f.TRANSFORM_LOCALEULER = 2, 
    f.TRANSFORM_LOCALMATRIX = 4, f.TRANSFORM_WORLDPOSITION = 8, f.TRANSFORM_WORLDQUATERNION = 16, 
    f.TRANSFORM_WORLDSCALE = 32, f.TRANSFORM_WORLDMATRIX = 64, f.TRANSFORM_WORLDEULER = 128, 
    f._angleToRandin = 180 / Math.PI;
    var m = function() {
        function Physics3DUtils() {
            _classCallCheck(this, Physics3DUtils);
        }
        return _createClass(Physics3DUtils, null, [ {
            key: "setColliderCollision",
            value: function(e, t, n) {}
        }, {
            key: "getIColliderCollision",
            value: function(e, t) {
                return !1;
            }
        } ]), Physics3DUtils;
    }();
    m.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, m.COLLISIONFILTERGROUP_STATICFILTER = 2, 
    m.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, m.COLLISIONFILTERGROUP_DEBRISFILTER = 8, 
    m.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, m.COLLISIONFILTERGROUP_CHARACTERFILTER = 32, 
    m.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, m.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128, 
    m.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, m.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512, 
    m.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, m.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048, 
    m.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, m.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192, 
    m.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, m.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768, 
    m.COLLISIONFILTERGROUP_ALLFILTER = -1, m.gravity = new o(0, -9.81, 0);
    var T = function(e) {
        function BoxColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
            _classCallCheck(this, BoxColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderShape).call(this)))._sizeX = t, 
            e._sizeY = n, e._sizeZ = r, e._type = h.SHAPETYPES_BOX;
            var i = l.Physics3D._bullet;
            return i.btVector3_setValue(BoxColliderShape._btSize, t / 2, n / 2, r / 2), e._btShape = i.btBoxShape_create(BoxColliderShape._btSize), 
            e;
        }
        return _inherits(BoxColliderShape, h), _createClass(BoxColliderShape, [ {
            key: "clone",
            value: function() {
                var e = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
                return this.cloneTo(e), e;
            }
        }, {
            key: "sizeX",
            get: function() {
                return this._sizeX;
            }
        }, {
            key: "sizeY",
            get: function() {
                return this._sizeY;
            }
        }, {
            key: "sizeZ",
            get: function() {
                return this._sizeZ;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                BoxColliderShape._btSize = l.Physics3D._bullet.btVector3_create(0, 0, 0);
            }
        } ]), BoxColliderShape;
    }(), p = function(e) {
        function CapsuleColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1.25, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
            _classCallCheck(this, CapsuleColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CapsuleColliderShape).call(this)))._radius = t, 
            e._length = n, e._orientation = r, e._type = h.SHAPETYPES_CAPSULE;
            var i = l.Physics3D._bullet;
            switch (r) {
              case h.SHAPEORIENTATION_UPX:
                e._btShape = i.btCapsuleShapeX_create(t, n - 2 * t);
                break;

              case h.SHAPEORIENTATION_UPY:
                e._btShape = i.btCapsuleShape_create(t, n - 2 * t);
                break;

              case h.SHAPEORIENTATION_UPZ:
                e._btShape = i.btCapsuleShapeZ_create(t, n - 2 * t);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(CapsuleColliderShape, h), _createClass(CapsuleColliderShape, [ {
            key: "_setScale",
            value: function(e) {
                var t = CapsuleColliderShape._tempVector30;
                switch (this.orientation) {
                  case h.SHAPEORIENTATION_UPX:
                    t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
                    break;

                  case h.SHAPEORIENTATION_UPY:
                    t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
                    break;

                  case h.SHAPEORIENTATION_UPZ:
                    t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
                    break;

                  default:
                    throw "CapsuleColliderShape:unknown orientation.";
                }
                _get(_getPrototypeOf(CapsuleColliderShape.prototype), "_setScale", this).call(this, t);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CapsuleColliderShape(this._radius, this._length, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "length",
            get: function() {
                return this._length;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        } ]), CapsuleColliderShape;
    }();
    p._tempVector30 = new o();
    var g = function(e) {
        function ConeColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
            _classCallCheck(this, ConeColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeColliderShape).call(this)))._radius = 1, 
            e._height = .5, e._radius = t, e._height = n, e._orientation = r, e._type = h.SHAPETYPES_CYLINDER;
            var i = l.Physics3D._bullet;
            switch (r) {
              case h.SHAPEORIENTATION_UPX:
                e._btShape = i.btConeShapeX_create(t, n);
                break;

              case h.SHAPEORIENTATION_UPY:
                e._btShape = i.btConeShape_create(t, n);
                break;

              case h.SHAPEORIENTATION_UPZ:
                e._btShape = i.btConeShapeZ_create(t, n);
                break;

              default:
                throw "ConeColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(ConeColliderShape, h), _createClass(ConeColliderShape, [ {
            key: "clone",
            value: function() {
                var e = new ConeColliderShape(this._radius, this._height, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        } ]), ConeColliderShape;
    }(), E = function(e) {
        function CylinderColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
            _classCallCheck(this, CylinderColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CylinderColliderShape).call(this)))._radius = 1, 
            e._height = .5, e._radius = t, e._height = n, e._orientation = r, e._type = h.SHAPETYPES_CYLINDER;
            var i = l.Physics3D._bullet;
            switch (r) {
              case h.SHAPEORIENTATION_UPX:
                i.btVector3_setValue(CylinderColliderShape._btSize, n / 2, t, t), e._btShape = i.btCylinderShapeX_create(CylinderColliderShape._btSize);
                break;

              case h.SHAPEORIENTATION_UPY:
                i.btVector3_setValue(CylinderColliderShape._btSize, t, n / 2, t), e._btShape = i.btCylinderShape_create(CylinderColliderShape._btSize);
                break;

              case h.SHAPEORIENTATION_UPZ:
                i.btVector3_setValue(CylinderColliderShape._btSize, t, t, n / 2), e._btShape = i.btCylinderShapeZ_create(CylinderColliderShape._btSize);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            return e;
        }
        return _inherits(CylinderColliderShape, h), _createClass(CylinderColliderShape, [ {
            key: "clone",
            value: function() {
                var e = new CylinderColliderShape(this._radius, this._height, this._orientation);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        }, {
            key: "height",
            get: function() {
                return this._height;
            }
        }, {
            key: "orientation",
            get: function() {
                return this._orientation;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                CylinderColliderShape._btSize = l.Physics3D._bullet.btVector3_create(0, 0, 0);
            }
        } ]), CylinderColliderShape;
    }(), y = function(e) {
        function MeshColliderShape() {
            var e;
            return _classCallCheck(this, MeshColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshColliderShape).call(this)))._mesh = null, 
            e._convex = !1, e;
        }
        return _inherits(MeshColliderShape, h), _createClass(MeshColliderShape, [ {
            key: "_setScale",
            value: function(e) {
                if (this._compoundParent) this.updateLocalTransformations(); else {
                    var t = l.Physics3D._bullet;
                    t.btVector3_setValue(h._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, h._btScale), 
                    t.btGImpactShapeInterface_updateBound(this._btShape);
                }
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.convex = this._convex, t.mesh = this._mesh, _get(_getPrototypeOf(MeshColliderShape.prototype), "cloneTo", this).call(this, e);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new MeshColliderShape();
                return this.cloneTo(e), e;
            }
        }, {
            key: "destroy",
            value: function() {
                this._btShape && (l.Physics3D._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                if (this._mesh !== e) {
                    var t = l.Physics3D._bullet;
                    this._mesh && t.btCollisionShape_destroy(this._btShape), e && (this._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()), 
                    t.btGImpactShapeInterface_updateBound(this._btShape)), this._mesh = e;
                }
            }
        }, {
            key: "convex",
            get: function() {
                return this._convex;
            },
            set: function(e) {
                this._convex = e;
            }
        } ]), MeshColliderShape;
    }(), v = function(e) {
        function SphereColliderShape() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5;
            return _classCallCheck(this, SphereColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderShape).call(this)))._radius = t, 
            e._type = h.SHAPETYPES_SPHERE, e._btShape = l.Physics3D._bullet.btSphereShape_create(t), 
            e;
        }
        return _inherits(SphereColliderShape, h), _createClass(SphereColliderShape, [ {
            key: "clone",
            value: function() {
                var e = new SphereColliderShape(this._radius);
                return this.cloneTo(e), e;
            }
        }, {
            key: "radius",
            get: function() {
                return this._radius;
            }
        } ]), SphereColliderShape;
    }(), S = function(e) {
        function PhysicsComponent(e, t) {
            var n;
            return _classCallCheck(this, PhysicsComponent), (n = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsComponent).call(this)))._restitution = 0, 
            n._friction = .5, n._rollingFriction = 0, n._ccdMotionThreshold = 0, n._ccdSweptSphereRadius = 0, 
            n._collisionGroup = m.COLLISIONFILTERGROUP_DEFAULTFILTER, n._canCollideWith = m.COLLISIONFILTERGROUP_ALLFILTER, 
            n._colliderShape = null, n._transformFlag = 2147483647, n._controlBySimulation = !1, 
            n._enableProcessCollisions = !0, n._inPhysicUpdateListIndex = -1, n.canScaleShape = !0, 
            n._collisionGroup = e, n._canCollideWith = t, PhysicsComponent._physicObjectsMap[n.id] = _assertThisInitialized(n), 
            n;
        }
        return _inherits(PhysicsComponent, t.Component), _createClass(PhysicsComponent, [ {
            key: "_parseShape",
            value: function(e) {
                var t = e.length;
                if (1 === t) {
                    var n = PhysicsComponent._creatShape(e[0]);
                    this.colliderShape = n;
                } else {
                    for (var r = new d(), i = 0; i < t; i++) n = PhysicsComponent._creatShape(e[i]), 
                    r.addChildShape(n);
                    this.colliderShape = r;
                }
            }
        }, {
            key: "_onScaleChange",
            value: function(e) {
                this._colliderShape._setScale(e);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this._simulation = this.owner._scene.physicsSimulation, l.Physics3D._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 1e30), 
                this._colliderShape && (this._derivePhysicsTransformation(!0), this._addToSimulation());
            }
        }, {
            key: "_onDisable",
            value: function() {
                this._colliderShape && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)), 
                this._simulation = null;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                delete PhysicsComponent._physicObjectsMap[this.id], l.Physics3D._bullet.btCollisionObject_destroy(this._btColliderObject), 
                this._colliderShape.destroy(), _get(_getPrototypeOf(PhysicsComponent.prototype), "_onDestroy", this).call(this), 
                this._btColliderObject = null, this._colliderShape = null, this._simulation = null, 
                this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_isValid",
            value: function() {
                return this._simulation && this._colliderShape && this._enabled;
            }
        }, {
            key: "_parse",
            value: function(e) {
                null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith), 
                null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold), 
                null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
            }
        }, {
            key: "_setTransformFlag",
            value: function(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_addToSimulation",
            value: function() {}
        }, {
            key: "_removeFromSimulation",
            value: function() {}
        }, {
            key: "_derivePhysicsTransformation",
            value: function(e) {
                var t = l.Physics3D._bullet, n = this._btColliderObject, r = t.btCollisionObject_getWorldTransform(n);
                this._innerDerivePhysicsTransformation(r, e), t.btCollisionObject_setWorldTransform(n, r);
            }
        }, {
            key: "_innerDerivePhysicsTransformation",
            value: function(e, t) {
                var n = l.Physics3D._bullet, r = this.owner._transform;
                if (t || this._getTransformFlag(f.TRANSFORM_WORLDPOSITION)) {
                    var i = this._colliderShape.localOffset, a = r.position, s = PhysicsComponent._btVector30;
                    if (0 !== i.x || 0 !== i.y || 0 !== i.z) {
                        var u = PhysicsComponent._tempVector30, c = r.worldMatrix;
                        o.transformCoordinate(i, c, u), n.btVector3_setValue(s, -u.x, u.y, u.z);
                    } else n.btVector3_setValue(s, -a.x, a.y, a.z);
                    n.btTransform_setOrigin(e, s), this._setTransformFlag(f.TRANSFORM_WORLDPOSITION, !1);
                }
                if (t || this._getTransformFlag(f.TRANSFORM_WORLDQUATERNION)) {
                    var h = this._colliderShape.localRotation, _ = PhysicsComponent._btQuaternion0, d = r.rotation;
                    if (0 !== h.x || 0 !== h.y || 0 !== h.z || 1 !== h.w) {
                        var m = PhysicsComponent._tempQuaternion0;
                        PhysicsComponent.physicQuaternionMultiply(d.x, d.y, d.z, d.w, h, m), n.btQuaternion_setValue(_, -m.x, m.y, m.z, -m.w);
                    } else n.btQuaternion_setValue(_, -d.x, d.y, d.z, -d.w);
                    n.btTransform_setRotation(e, _), this._setTransformFlag(f.TRANSFORM_WORLDQUATERNION, !1);
                }
                (t || this._getTransformFlag(f.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(r.getWorldLossyScale()), 
                this._setTransformFlag(f.TRANSFORM_WORLDSCALE, !1));
            }
        }, {
            key: "_updateTransformComponent",
            value: function(e) {
                var t = l.Physics3D._bullet, n = this._colliderShape, r = n.localOffset, i = n.localRotation, a = this.owner._transform, s = a.position, u = a.rotation, c = t.btTransform_getOrigin(e), h = t.btTransform_getRotation(e), _ = -t.btQuaternion_x(h), d = t.btQuaternion_y(h), f = t.btQuaternion_z(h), m = -t.btQuaternion_w(h);
                if (0 !== i.x || 0 !== i.y || 0 !== i.z || 1 !== i.w) {
                    var T = PhysicsComponent._tempQuaternion0;
                    i.invert(T), PhysicsComponent.physicQuaternionMultiply(_, d, f, m, T, u);
                } else u.x = _, u.y = d, u.z = f, u.w = m;
                if (a.rotation = u, 0 !== r.x || 0 !== r.y || 0 !== r.z) {
                    var p = t.btCollisionShape_getLocalScaling(n._btShape), g = PhysicsComponent._tempVector30;
                    g.x = r.x * t.btVector3_x(p), g.y = r.y * t.btVector3_y(p), g.z = r.z * t.btVector3_z(p), 
                    o.transformQuat(g, u, g), s.x = -t.btVector3_x(c) - g.x, s.y = t.btVector3_y(c) - g.y, 
                    s.z = t.btVector3_z(c) - g.z;
                } else s.x = -t.btVector3_x(c), s.y = t.btVector3_y(c), s.z = t.btVector3_z(c);
                a.position = s;
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                var t = this._btColliderObject, n = l.Physics3D._bullet, r = n.btCollisionObject_getCollisionFlags(t);
                e.needsCustomCollisionCallback ? 0 == (r & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && n.btCollisionObject_setCollisionFlags(t, r | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (r & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && n.btCollisionObject_setCollisionFlags(t, r ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
            }
        }, {
            key: "_onAdded",
            value: function() {
                this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction, 
                this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold, 
                this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                !PhysicsComponent._addUpdateList && this._controlBySimulation || (e &= f.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e, 
                this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                var t = e;
                t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction, 
                t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius, 
                t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith, 
                t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
            }
        }, {
            key: "restitution",
            get: function() {
                return this._restitution;
            },
            set: function(e) {
                this._restitution = e, this._btColliderObject && l.Physics3D._bullet.btCollisionObject_setRestitution(this._btColliderObject, e);
            }
        }, {
            key: "friction",
            get: function() {
                return this._friction;
            },
            set: function(e) {
                this._friction = e, this._btColliderObject && l.Physics3D._bullet.btCollisionObject_setFriction(this._btColliderObject, e);
            }
        }, {
            key: "rollingFriction",
            get: function() {
                return this._rollingFriction;
            },
            set: function(e) {
                this._rollingFriction = e, this._btColliderObject && l.Physics3D._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, e);
            }
        }, {
            key: "ccdMotionThreshold",
            get: function() {
                return this._ccdMotionThreshold;
            },
            set: function(e) {
                this._ccdMotionThreshold = e, this._btColliderObject && l.Physics3D._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e);
            }
        }, {
            key: "ccdSweptSphereRadius",
            get: function() {
                return this._ccdSweptSphereRadius;
            },
            set: function(e) {
                this._ccdSweptSphereRadius = e, this._btColliderObject && l.Physics3D._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e);
            }
        }, {
            key: "isActive",
            get: function() {
                return !!this._btColliderObject && l.Physics3D._bullet.btCollisionObject_isActive(this._btColliderObject);
            }
        }, {
            key: "colliderShape",
            get: function() {
                return this._colliderShape;
            },
            set: function(e) {
                var t = this._colliderShape;
                if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e, 
                e) {
                    if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                    if (e._attatched = !0, e._attatchedCollisionObject = this, this._btColliderObject) {
                        l.Physics3D._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, e._btShape);
                        var n = this._simulation && this._enabled;
                        n && t && this._removeFromSimulation(), this._onShapeChange(e), n && (this._derivePhysicsTransformation(!0), 
                        this._addToSimulation());
                    }
                } else this._simulation && this._enabled && t && this._removeFromSimulation();
            }
        }, {
            key: "simulation",
            get: function() {
                return this._simulation;
            }
        }, {
            key: "collisionGroup",
            get: function() {
                return this._collisionGroup;
            },
            set: function(e) {
                this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
                this._addToSimulation()));
            }
        }, {
            key: "canCollideWith",
            get: function() {
                return this._canCollideWith;
            },
            set: function(e) {
                this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
                this._addToSimulation()));
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = l.Physics3D._bullet;
                PhysicsComponent._btVector30 = e.btVector3_create(0, 0, 0), PhysicsComponent._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1);
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function(e, t, n, r, i, a, o, s, l) {
                var u = r + r, c = i + i, h = a + a, _ = r * u, d = r * c, f = r * h, m = i * c, T = i * h, p = a * h, g = o * u, E = o * c, y = o * h, v = s[0], S = s[1], C = s[2];
                l[0] = (1 - (m + p)) * v, l[1] = (d + y) * v, l[2] = (f - E) * v, l[3] = 0, l[4] = (d - y) * S, 
                l[5] = (1 - (_ + p)) * S, l[6] = (T + g) * S, l[7] = 0, l[8] = (f + E) * C, l[9] = (T - g) * C, 
                l[10] = (1 - (_ + m)) * C, l[11] = 0, l[12] = e, l[13] = t, l[14] = n, l[15] = 1;
            }
        }, {
            key: "_creatShape",
            value: function(e) {
                var n;
                switch (e.type) {
                  case "BoxColliderShape":
                    var r = e.size;
                    n = r ? new T(r[0], r[1], r[2]) : new T();
                    break;

                  case "SphereColliderShape":
                    n = new v(e.radius);
                    break;

                  case "CapsuleColliderShape":
                    n = new p(e.radius, e.height, e.orientation);
                    break;

                  case "MeshColliderShape":
                    var i = new y();
                    e.mesh && (i.mesh = t.Loader.getRes(e.mesh)), n = i;
                    break;

                  case "ConeColliderShape":
                    n = new g(e.radius, e.height, e.orientation);
                    break;

                  case "CylinderColliderShape":
                    n = new E(e.radius, e.height, e.orientation);
                    break;

                  default:
                    throw "unknown shape type.";
                }
                if (e.center) {
                    var a = n.localOffset;
                    a.fromArray(e.center), n.localOffset = a;
                }
                return n;
            }
        }, {
            key: "physicVector3TransformQuat",
            value: function(e, t, n, r, i, a) {
                var o = e.x, s = e.y, l = e.z, u = i * o + n * l - r * s, c = i * s + r * o - t * l, h = i * l + t * s - n * o, _ = -t * o - n * s - r * l;
                a.x = u * i + _ * -t + c * -r - h * -n, a.y = c * i + _ * -n + h * -t - u * -r, 
                a.z = h * i + _ * -r + u * -n - c * -t;
            }
        }, {
            key: "physicQuaternionMultiply",
            value: function(e, t, n, r, i, a) {
                var o = i.x, s = i.y, l = i.z, u = i.w, c = t * l - n * s, h = n * o - e * l, _ = e * s - t * o, d = e * o + t * s + n * l;
                a.x = e * u + o * r + c, a.y = t * u + s * r + h, a.z = n * u + l * r + _, a.w = r * u - d;
            }
        } ]), PhysicsComponent;
    }();
    S.ACTIVATIONSTATE_ACTIVE_TAG = 1, S.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, S.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3, 
    S.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, S.ACTIVATIONSTATE_DISABLE_SIMULATION = 5, 
    S.COLLISIONFLAGS_STATIC_OBJECT = 1, S.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, S.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4, 
    S.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, S.COLLISIONFLAGS_CHARACTER_OBJECT = 16, 
    S.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, S.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64, 
    S._tempVector30 = new o(), S._tempQuaternion0 = new u(), S._tempQuaternion1 = new u(), 
    S._tempMatrix4x40 = new c(), S._physicObjectsMap = {}, S._addUpdateList = !0;
    var C = function() {
        function SingletonList() {
            _classCallCheck(this, SingletonList), this.elements = [], this.length = 0;
        }
        return _createClass(SingletonList, [ {
            key: "_add",
            value: function(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
            }
        }, {
            key: "add",
            value: function(e) {
                this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e, 
                this.length++;
            }
        } ]), SingletonList;
    }(), R = function(e) {
        function PhysicsUpdateList() {
            return _classCallCheck(this, PhysicsUpdateList), _possibleConstructorReturn(this, _getPrototypeOf(PhysicsUpdateList).call(this));
        }
        return _inherits(PhysicsUpdateList, C), _createClass(PhysicsUpdateList, [ {
            key: "add",
            value: function(e) {
                if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                this._add(e), e._inPhysicUpdateListIndex = this.length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._inPhysicUpdateListIndex;
                if (this.length--, t !== this.length) {
                    var n = this.elements[this.length];
                    this.elements[t] = n, n._inPhysicUpdateListIndex = t;
                }
                e._inPhysicUpdateListIndex = -1;
            }
        } ]), PhysicsUpdateList;
    }(), D = function ContactPoint() {
        _classCallCheck(this, ContactPoint), this._idCounter = 0, this.colliderA = null, 
        this.colliderB = null, this.distance = 0, this.normal = new o(), this.positionOnA = new o(), 
        this.positionOnB = new o(), this._id = ++this._idCounter;
    }, M = function HitResult() {
        _classCallCheck(this, HitResult), this.succeeded = !1, this.collider = null, this.point = new o(), 
        this.normal = new o(), this.hitFraction = 0;
    }, A = function() {
        function Collision() {
            _classCallCheck(this, Collision), this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, 
            this._isTrigger = !1, this.contacts = [];
        }
        return _createClass(Collision, [ {
            key: "_setUpdateFrame",
            value: function(e) {
                this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
            }
        } ]), Collision;
    }(), x = function() {
        function CollisionTool() {
            _classCallCheck(this, CollisionTool), this._hitResultsPoolIndex = 0, this._hitResultsPool = [], 
            this._contactPonintsPoolIndex = 0, this._contactPointsPool = [], this._collisionsPool = [], 
            this._collisions = {};
        }
        return _createClass(CollisionTool, [ {
            key: "getHitResult",
            value: function() {
                var e = this._hitResultsPool[this._hitResultsPoolIndex++];
                return e || (e = new M(), this._hitResultsPool.push(e)), e;
            }
        }, {
            key: "recoverAllHitResultsPool",
            value: function() {
                this._hitResultsPoolIndex = 0;
            }
        }, {
            key: "getContactPoints",
            value: function() {
                var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
                return e || (e = new D(), this._contactPointsPool.push(e)), e;
            }
        }, {
            key: "recoverAllContactPointsPool",
            value: function() {
                this._contactPonintsPoolIndex = 0;
            }
        }, {
            key: "getCollision",
            value: function(e, t) {
                var n, r = e.id, i = t.id, a = this._collisions[r];
                return a && (n = a[i]), n || (a || (a = {}, this._collisions[r] = a), (n = 0 === this._collisionsPool.length ? new A() : this._collisionsPool.pop())._colliderA = e, 
                n._colliderB = t, a[i] = n), n;
            }
        }, {
            key: "recoverCollision",
            value: function(e) {
                var t = e._colliderA.id, n = e._colliderB.id;
                this._collisions[t][n] = null, this._collisionsPool.push(e);
            }
        }, {
            key: "garbageCollection",
            value: function() {
                for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0, 
                this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                    var t = this._collisionsPool[e], n = !0;
                    for (var r in t) t[r] ? n = !1 : delete t[r];
                    n && delete this._collisionsPool[e];
                }
            }
        } ]), CollisionTool;
    }(), L = function() {
        function PhysicsSimulation(e) {
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            _classCallCheck(this, PhysicsSimulation), this._gravity = new o(0, -10, 0), this._btVector3Zero = l.Physics3D._bullet.btVector3_create(0, 0, 0), 
            this._btDefaultQuaternion = l.Physics3D._bullet.btQuaternion_create(0, 0, 0, -1), 
            this._collisionsUtils = new x(), this._previousFrameCollisions = [], this._currentFrameCollisions = [], 
            this._currentConstraint = {}, this._physicsUpdateList = new R(), this._characters = [], 
            this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60, 
            this.maxSubSteps = e.maxSubSteps, this.fixedTimeStep = e.fixedTimeStep;
            var t = l.Physics3D._bullet;
            this._btCollisionConfiguration = t.btDefaultCollisionConfiguration_create(), this._btDispatcher = t.btCollisionDispatcher_create(this._btCollisionConfiguration), 
            this._btBroadphase = t.btDbvtBroadphase_create(), t.btOverlappingPairCache_setInternalGhostPairCallback(t.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), t.btGhostPairCallback_create());
            var n = e.flags;
            if (n & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._btCollisionWorld = new t.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration); else {
                if (n & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var r = t.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = t.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, r, this._btCollisionConfiguration), 
                this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            this._btDiscreteDynamicsWorld && (this._btSolverInfo = t.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld), 
            this._btDispatchInfo = t.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld)), 
            this._btClosestRayResultCallback = t.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btAllHitsRayResultCallback = t.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btClosestConvexResultCallback = t.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btAllConvexResultCallback = t.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            t.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        return _createClass(PhysicsSimulation, [ {
            key: "_simulate",
            value: function(e) {
                this._updatedRigidbodies = 0;
                var t = l.Physics3D._bullet;
                this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t.PerformDiscreteCollisionDetection(this._btCollisionWorld);
            }
        }, {
            key: "_destroy",
            value: function() {
                var e = l.Physics3D._bullet;
                this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld), 
                this._btDiscreteDynamicsWorld = null) : (e.btCollisionWorld_destroy(this._btCollisionWorld), 
                this._btCollisionWorld = null), e.btDbvtBroadphase_destroy(this._btBroadphase), 
                this._btBroadphase = null, e.btCollisionDispatcher_destroy(this._btDispatcher), 
                this._btDispatcher = null, e.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration), 
                this._btCollisionConfiguration = null;
            }
        }, {
            key: "_addPhysicsCollider",
            value: function(e, t, n) {
                l.Physics3D._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, n);
            }
        }, {
            key: "_removePhysicsCollider",
            value: function(e) {
                l.Physics3D._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addRigidBody",
            value: function(e, t, n) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, e._btColliderObject, t, n);
            }
        }, {
            key: "_removeRigidBody",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addCharacter",
            value: function(e, t, n) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var r = l.Physics3D._bullet;
                r.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, n), 
                r.btDynamicsWorld_addAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "_removeCharacter",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var t = l.Physics3D._bullet;
                t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject), 
                t.btDynamicsWorld_removeAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "raycastFromTo",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m.COLLISIONFILTERGROUP_ALLFILTER, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m.COLLISIONFILTERGROUP_ALLFILTER, a = l.Physics3D._bullet, o = this._btClosestRayResultCallback, s = PhysicsSimulation._btTempVector30, u = PhysicsSimulation._btTempVector31;
                if (a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(u, -t.x, t.y, t.z), 
                a.ClosestRayResultCallback_set_m_rayFromWorld(o, s), a.ClosestRayResultCallback_set_m_rayToWorld(o, u), 
                a.RayResultCallback_set_m_collisionFilterGroup(o, r), a.RayResultCallback_set_m_collisionFilterMask(o, i), 
                a.RayResultCallback_set_m_collisionObject(o, null), a.RayResultCallback_set_m_closestHitFraction(o, 1), 
                a.btCollisionWorld_rayTest(this._btCollisionWorld, s, u, o), a.RayResultCallback_hasHit(o)) {
                    if (n) {
                        n.succeeded = !0, n.collider = S._physicObjectsMap[a.btCollisionObject_getUserIndex(a.RayResultCallback_get_m_collisionObject(o))], 
                        n.hitFraction = a.RayResultCallback_get_m_closestHitFraction(o);
                        var c = a.ClosestRayResultCallback_get_m_hitPointWorld(o), h = n.point;
                        h.x = -a.btVector3_x(c), h.y = a.btVector3_y(c), h.z = a.btVector3_z(c);
                        var _ = a.ClosestRayResultCallback_get_m_hitNormalWorld(o), d = n.normal;
                        d.x = -a.btVector3_x(_), d.y = a.btVector3_y(_), d.z = a.btVector3_z(_);
                    }
                    return !0;
                }
                return n && (n.succeeded = !1), !1;
            }
        }, {
            key: "raycastAllFromTo",
            value: function(e, t, n) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m.COLLISIONFILTERGROUP_ALLFILTER, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m.COLLISIONFILTERGROUP_ALLFILTER, a = l.Physics3D._bullet, o = this._btAllHitsRayResultCallback, s = PhysicsSimulation._btTempVector30, u = PhysicsSimulation._btTempVector31;
                n.length = 0, a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(u, -t.x, t.y, t.z), 
                a.AllHitsRayResultCallback_set_m_rayFromWorld(o, s), a.AllHitsRayResultCallback_set_m_rayToWorld(o, u), 
                a.RayResultCallback_set_m_collisionFilterGroup(o, r), a.RayResultCallback_set_m_collisionFilterMask(o, i);
                var c = a.AllHitsRayResultCallback_get_m_collisionObjects(o), h = a.AllHitsRayResultCallback_get_m_hitPointWorld(o), _ = a.AllHitsRayResultCallback_get_m_hitNormalWorld(o), d = a.AllHitsRayResultCallback_get_m_hitFractions(o);
                a.tBtCollisionObjectArray_clear(c), a.tVector3Array_clear(h), a.tVector3Array_clear(_), 
                a.tScalarArray_clear(d), a.btCollisionWorld_rayTest(this._btCollisionWorld, s, u, o);
                var f = a.tBtCollisionObjectArray_size(c);
                if (f > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var T = 0; T < f; T++) {
                        var p = this._collisionsUtils.getHitResult();
                        n.push(p), p.succeeded = !0, p.collider = S._physicObjectsMap[a.btCollisionObject_getUserIndex(a.tBtCollisionObjectArray_at(c, T))], 
                        p.hitFraction = a.tScalarArray_at(d, T);
                        var g = a.tVector3Array_at(h, T), E = p.point;
                        E.x = -a.btVector3_x(g), E.y = a.btVector3_y(g), E.z = a.btVector3_z(g);
                        var y = a.tVector3Array_at(_, T), v = p.normal;
                        v.x = -a.btVector3_x(y), v.y = a.btVector3_y(y), v.z = a.btVector3_z(y);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "rayCast",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m.COLLISIONFILTERGROUP_ALLFILTER, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m.COLLISIONFILTERGROUP_ALLFILTER, a = e.origin, s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s), o.scale(s, n, s), o.add(a, s, s), this.raycastFromTo(a, s, t, r, i);
            }
        }, {
            key: "rayCastAll",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m.COLLISIONFILTERGROUP_ALLFILTER, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m.COLLISIONFILTERGROUP_ALLFILTER, a = e.origin, s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s), o.scale(s, n, s), o.add(a, s, s), this.raycastAllFromTo(a, s, t, r, i);
            }
        }, {
            key: "shapeCast",
            value: function(e, t, n) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : m.COLLISIONFILTERGROUP_ALLFILTER, s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : m.COLLISIONFILTERGROUP_ALLFILTER, u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c = l.Physics3D._bullet, h = this._btClosestConvexResultCallback, _ = PhysicsSimulation._btTempVector30, d = PhysicsSimulation._btTempVector31, f = PhysicsSimulation._btTempQuaternion0, T = PhysicsSimulation._btTempQuaternion1, p = PhysicsSimulation._btTempTransform0, g = PhysicsSimulation._btTempTransform1, E = e._btShape;
                if (c.btVector3_setValue(_, -t.x, t.y, t.z), c.btVector3_setValue(d, -n.x, n.y, n.z), 
                c.ConvexResultCallback_set_m_collisionFilterGroup(h, o), c.ConvexResultCallback_set_m_collisionFilterMask(h, s), 
                c.btTransform_setOrigin(p, _), c.btTransform_setOrigin(g, d), i ? (c.btQuaternion_setValue(f, -i.x, i.y, i.z, -i.w), 
                c.btTransform_setRotation(p, f)) : c.btTransform_setRotation(p, this._btDefaultQuaternion), 
                a ? (c.btQuaternion_setValue(T, -a.x, a.y, a.z, -a.w), c.btTransform_setRotation(g, T)) : c.btTransform_setRotation(g, this._btDefaultQuaternion), 
                c.ClosestConvexResultCallback_set_m_hitCollisionObject(h, null), c.ConvexResultCallback_set_m_closestHitFraction(h, 1), 
                c.btCollisionWorld_convexSweepTest(this._btCollisionWorld, E, p, g, h, u), c.ConvexResultCallback_hasHit(h)) {
                    if (r) {
                        r.succeeded = !0, r.collider = S._physicObjectsMap[c.btCollisionObject_getUserIndex(c.ClosestConvexResultCallback_get_m_hitCollisionObject(h))], 
                        r.hitFraction = c.ConvexResultCallback_get_m_closestHitFraction(h);
                        var y = c.ClosestConvexResultCallback_get_m_hitPointWorld(h), v = c.ClosestConvexResultCallback_get_m_hitNormalWorld(h), C = r.point, R = r.normal;
                        C.x = -c.btVector3_x(y), C.y = c.btVector3_y(y), C.z = c.btVector3_z(y), R.x = -c.btVector3_x(v), 
                        R.y = c.btVector3_y(v), R.z = c.btVector3_z(v);
                    }
                    return !0;
                }
                return r && (r.succeeded = !1), !1;
            }
        }, {
            key: "shapeCastAll",
            value: function(e, t, n, r) {
                var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : m.COLLISIONFILTERGROUP_ALLFILTER, s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : m.COLLISIONFILTERGROUP_ALLFILTER, u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c = l.Physics3D._bullet, h = this._btAllConvexResultCallback, _ = PhysicsSimulation._btTempVector30, d = PhysicsSimulation._btTempVector31, f = PhysicsSimulation._btTempQuaternion0, T = PhysicsSimulation._btTempQuaternion1, p = PhysicsSimulation._btTempTransform0, g = PhysicsSimulation._btTempTransform1, E = e._btShape;
                r.length = 0, c.btVector3_setValue(_, -t.x, t.y, t.z), c.btVector3_setValue(d, -n.x, n.y, n.z), 
                c.ConvexResultCallback_set_m_collisionFilterGroup(h, o), c.ConvexResultCallback_set_m_collisionFilterMask(h, s), 
                c.btTransform_setOrigin(p, _), c.btTransform_setOrigin(g, d), i ? (c.btQuaternion_setValue(f, -i.x, i.y, i.z, -i.w), 
                c.btTransform_setRotation(p, f)) : c.btTransform_setRotation(p, this._btDefaultQuaternion), 
                a ? (c.btQuaternion_setValue(T, -a.x, a.y, a.z, -a.w), c.btTransform_setRotation(g, T)) : c.btTransform_setRotation(g, this._btDefaultQuaternion);
                var y = c.AllConvexResultCallback_get_m_collisionObjects(h);
                c.tBtCollisionObjectArray_clear(y), c.btCollisionWorld_convexSweepTest(this._btCollisionWorld, E, p, g, h, u);
                var v = c.tBtCollisionObjectArray_size(y);
                if (v > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var C = c.AllConvexResultCallback_get_m_hitPointWorld(h), R = c.AllConvexResultCallback_get_m_hitNormalWorld(h), D = c.AllConvexResultCallback_get_m_hitFractions(h), M = 0; M < v; M++) {
                        var A = this._collisionsUtils.getHitResult();
                        r.push(A), A.succeeded = !0, A.collider = S._physicObjectsMap[c.btCollisionObject_getUserIndex(c.tBtCollisionObjectArray_at(y, M))], 
                        A.hitFraction = c.tScalarArray_at(D, M);
                        var x = c.tVector3Array_at(C, M), L = A.point;
                        L.x = -c.btVector3_x(x), L.y = c.btVector3_y(x), L.z = c.btVector3_z(x);
                        var I = c.tVector3Array_at(R, M), O = A.normal;
                        O.x = -c.btVector3_x(I), O.y = c.btVector3_y(I), O.z = c.btVector3_z(I);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "addConstraint",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btCollisionWorld_addConstraint(this._btDiscreteDynamicsWorld, e._btConstraint, t), 
                this._currentConstraint[e.id] = e;
            }
        }, {
            key: "removeConstraint",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btCollisionWorld_removeConstraint(this._btDiscreteDynamicsWorld, e._btConstraint), 
                delete this._currentConstraint[e.id];
            }
        }, {
            key: "_updatePhysicsTransformFromRender",
            value: function() {
                for (var e = this._physicsUpdateList.elements, t = 0, n = this._physicsUpdateList.length; t < n; t++) {
                    var r = e[t];
                    r._derivePhysicsTransformation(!1), r._inPhysicUpdateListIndex = -1;
                }
                this._physicsUpdateList.length = 0;
            }
        }, {
            key: "_updateCharacters",
            value: function() {
                for (var e = 0, t = this._characters.length; e < t; e++) {
                    var n = this._characters[e];
                    n._updateTransformComponent(l.Physics3D._bullet.btCollisionObject_getWorldTransform(n._btColliderObject));
                }
            }
        }, {
            key: "_updateCollisions",
            value: function() {
                this._collisionsUtils.recoverAllContactPointsPool();
                var e = this._currentFrameCollisions;
                this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0, 
                this._previousFrameCollisions = e;
                for (var n = t.Stat.loopCount, r = l.Physics3D._bullet, i = r.btDispatcher_getNumManifolds(this._btDispatcher), a = 0; a < i; a++) {
                    var o, s = r.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, a), u = S._physicObjectsMap[r.btCollisionObject_getUserIndex(r.btPersistentManifold_getBody0(s))], c = S._physicObjectsMap[r.btCollisionObject_getUserIndex(r.btPersistentManifold_getBody1(s))], h = null, _ = null;
                    if ((u.isTrigger || c.isTrigger) && (u.owner._needProcessTriggers || c.owner._needProcessTriggers)) for (var d = r.btPersistentManifold_getNumContacts(s), f = 0; f < d; f++) {
                        var m = r.btPersistentManifold_getContactPoint(s, f), T = r.btManifoldPoint_getDistance(m);
                        if (T <= 0) {
                            _ = (h = this._collisionsUtils.getCollision(u, c)).contacts, (o = h._updateFrame !== n) && (h._isTrigger = !0, 
                            _.length = 0);
                            break;
                        }
                    } else if ((u.owner._needProcessCollisions || c.owner._needProcessCollisions) && (u._enableProcessCollisions || c._enableProcessCollisions)) for (d = r.btPersistentManifold_getNumContacts(s), 
                    f = 0; f < d; f++) if (m = r.btPersistentManifold_getContactPoint(s, f), (T = r.btManifoldPoint_getDistance(m)) <= 0) {
                        var p = this._collisionsUtils.getContactPoints();
                        p.colliderA = u, p.colliderB = c, p.distance = T;
                        var g = r.btManifoldPoint_get_m_normalWorldOnB(m), E = p.normal;
                        E.x = -r.btVector3_x(g), E.y = r.btVector3_y(g), E.z = r.btVector3_z(g);
                        var y = r.btManifoldPoint_get_m_positionWorldOnA(m), v = p.positionOnA;
                        v.x = -r.btVector3_x(y), v.y = r.btVector3_y(y), v.z = r.btVector3_z(y);
                        var C = r.btManifoldPoint_get_m_positionWorldOnB(m), R = p.positionOnB;
                        R.x = -r.btVector3_x(C), R.y = r.btVector3_y(C), R.z = r.btVector3_z(C), h || (_ = (h = this._collisionsUtils.getCollision(u, c)).contacts, 
                        (o = h._updateFrame !== n) && (h._isTrigger = !1, _.length = 0)), _.push(p);
                    }
                    h && o && (this._currentFrameCollisions.push(h), h._setUpdateFrame(n));
                }
            }
        }, {
            key: "_eventScripts",
            value: function() {
                for (var e = t.Stat.loopCount, n = 0, r = this._currentFrameCollisions.length; n < r; n++) {
                    var i = this._currentFrameCollisions[n], a = i._colliderA, o = i._colliderB;
                    if (!a.destroyed && !o.destroyed) if (e - i._lastUpdateFrame == 1) {
                        var s = a.owner, l = s._scripts;
                        if (l) if (i._isTrigger) {
                            if (s._needProcessTriggers) for (var u = 0, c = l.length; u < c; u++) l[u].onTriggerStay(o);
                        } else if (s._needProcessCollisions) for (u = 0, c = l.length; u < c; u++) i.other = o, 
                        l[u].onCollisionStay(i);
                        var h = o.owner, _ = h._scripts;
                        if (_) if (i._isTrigger) {
                            if (h._needProcessTriggers) for (u = 0, c = _.length; u < c; u++) _[u].onTriggerStay(a);
                        } else if (h._needProcessCollisions) for (u = 0, c = _.length; u < c; u++) i.other = a, 
                        _[u].onCollisionStay(i);
                    } else {
                        if (l = (s = a.owner)._scripts) if (i._isTrigger) {
                            if (s._needProcessTriggers) for (u = 0, c = l.length; u < c; u++) l[u].onTriggerEnter(o);
                        } else if (s._needProcessCollisions) for (u = 0, c = l.length; u < c; u++) i.other = o, 
                        l[u].onCollisionEnter(i);
                        if (_ = (h = o.owner)._scripts) if (i._isTrigger) {
                            if (h._needProcessTriggers) for (u = 0, c = _.length; u < c; u++) _[u].onTriggerEnter(a);
                        } else if (h._needProcessCollisions) for (u = 0, c = _.length; u < c; u++) i.other = a, 
                        _[u].onCollisionEnter(i);
                    }
                }
                for (n = 0, r = this._previousFrameCollisions.length; n < r; n++) {
                    var d = this._previousFrameCollisions[n], f = d._colliderA, m = d._colliderB;
                    if (!f.destroyed && !m.destroyed && e - d._updateFrame == 1) {
                        if (this._collisionsUtils.recoverCollision(d), l = (s = f.owner)._scripts) if (d._isTrigger) {
                            if (s._needProcessTriggers) for (u = 0, c = l.length; u < c; u++) l[u].onTriggerExit(m);
                        } else if (s._needProcessCollisions) for (u = 0, c = l.length; u < c; u++) d.other = m, 
                        l[u].onCollisionExit(d);
                        if (_ = (h = m.owner)._scripts) if (d._isTrigger) {
                            if (h._needProcessTriggers) for (u = 0, c = _.length; u < c; u++) _[u].onTriggerExit(f);
                        } else if (h._needProcessCollisions) for (u = 0, c = _.length; u < c; u++) d.other = f, 
                        _[u].onCollisionExit(d);
                    }
                }
                for (var T in this._currentConstraint) {
                    var p = this._currentConstraint[T], g = p.owner._scripts;
                    if (p.enabled && p._isBreakConstrained() && g && 0 != g.length) for (n = 0, r = g.length; n < r; n++) g[n].onJointBreak();
                }
            }
        }, {
            key: "clearForces",
            value: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
            }
        }, {
            key: "continuousCollisionDetection",
            get: function() {
                return l.Physics3D._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
            },
            set: function(e) {
                l.Physics3D._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, e);
            }
        }, {
            key: "gravity",
            get: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._gravity;
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._gravity = e;
                var t = l.Physics3D._bullet, n = PhysicsSimulation._btTempVector30;
                t.btVector3_setValue(n, -e.x, e.y, e.z), t.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, n);
            }
        }, {
            key: "speculativeContactRestitution",
            get: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                return l.Physics3D._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                l.Physics3D._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, e);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = l.Physics3D._bullet;
                PhysicsSimulation._btTempVector30 = e.btVector3_create(0, 0, 0), PhysicsSimulation._btTempVector31 = e.btVector3_create(0, 0, 0), 
                PhysicsSimulation._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), PhysicsSimulation._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1), 
                PhysicsSimulation._btTempTransform0 = e.btTransform_create(), PhysicsSimulation._btTempTransform1 = e.btTransform_create();
            }
        }, {
            key: "createConstraint",
            value: function() {}
        } ]), PhysicsSimulation;
    }();
    L.PHYSICSENGINEFLAGS_NONE = 0, L.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, L.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2, 
    L.PHYSICSENGINEFLAGS_MULTITHREADED = 4, L.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, 
    L.SOLVERMODE_RANDMIZE_ORDER = 1, L.SOLVERMODE_FRICTION_SEPARATE = 2, L.SOLVERMODE_USE_WARMSTARTING = 4, 
    L.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, L.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, 
    L.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, L.SOLVERMODE_CACHE_FRIENDLY = 128, 
    L.SOLVERMODE_SIMD = 256, L.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512, 
    L.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, L._tempVector30 = new o(), 
    L.disableSimulation = !1;
    var I = function() {
        function TextureGenerator() {
            _classCallCheck(this, TextureGenerator);
        }
        return _createClass(TextureGenerator, null, [ {
            key: "lightAttenTexture",
            value: function(e, t, n, r, i, a) {
                var o = e / n, s = 1 / (1 + 25 * o);
                o >= .64 && (o > 1 ? s = 0 : s *= 1 - (o - .64) / .36), a[i] = Math.floor(255 * s + .5);
            }
        }, {
            key: "haloTexture",
            value: function(e, t, n, r, i, a) {
                var o = (e - (n >>= 1)) / n, s = (t - (r >>= 1)) / r, l = o * o + s * s;
                l > 1 && (l = 1), a[i] = Math.floor(255 * (1 - l) + .5);
            }
        }, {
            key: "_generateTexture2D",
            value: function(e, n, r, i) {
                var a = 0, o = 0;
                switch (e.format) {
                  case t.TextureFormat.R8G8B8:
                    o = 3;
                    break;

                  case t.TextureFormat.R8G8B8A8:
                    o = 4;
                    break;

                  case t.TextureFormat.Alpha8:
                    o = 1;
                    break;

                  default:
                    throw "GeneratedTexture._generateTexture: unkonw texture format.";
                }
                for (var s = new Uint8Array(n * r * o), l = 0; l < r; l++) for (var u = 0; u < n; u++) i(u, l, n, r, a, s), 
                a += o;
                e.setPixels(s);
            }
        } ]), TextureGenerator;
    }(), O = function() {
        function Utils3D() {
            _classCallCheck(this, Utils3D);
        }
        return _createClass(Utils3D, null, [ {
            key: "_createFloatTextureBuffer",
            value: function(e, n) {
                var r = new t.Texture2D(e, n, t.TextureFormat.R32G32B32A32, !1, !1);
                return r.filterMode = t.FilterMode.Point, r.wrapModeU = t.WarpMode.Clamp, r.wrapModeV = t.WarpMode.Clamp, 
                r.anisoLevel = 0, r;
            }
        }, {
            key: "_convertToLayaVec3",
            value: function(e, t, n) {
                var r = l.Physics3D._bullet;
                t.x = n ? -r.btVector3_x(e) : r.btVector3_x(e), t.y = r.btVector3_y(e), t.z = r.btVector3_z(e);
            }
        }, {
            key: "_convertToBulletVec3",
            value: function(e, t, n) {
                l.Physics3D._bullet.btVector3_setValue(t, n ? -e.x : e.x, e.y, e.z);
            }
        }, {
            key: "_rotationTransformScaleSkinAnimation",
            value: function(e, t, n, r, i, a, o, s, l, u, c, h) {
                var _, d, f, m, T, p = Utils3D._tempArray16_0, g = Utils3D._tempArray16_1, E = Utils3D._tempArray16_2, y = r + r, v = i + i, S = a + a, C = r * y, R = i * y, D = i * v, M = a * y, A = a * v, x = a * S, L = o * y, I = o * v, O = o * S;
                for (p[15] = 1, p[0] = 1 - D - x, p[1] = R + O, p[2] = M - I, p[4] = R - O, p[5] = 1 - C - x, 
                p[6] = A + L, p[8] = M + I, p[9] = A - L, p[10] = 1 - C - D, g[15] = 1, g[0] = s, 
                g[5] = l, g[10] = u, _ = 0; _ < 4; _++) d = p[_], f = p[_ + 4], m = p[_ + 8], T = p[_ + 12], 
                E[_] = d, E[_ + 4] = f, E[_ + 8] = m, E[_ + 12] = d * e + f * t + m * n + T;
                for (_ = 0; _ < 4; _++) d = E[_], f = E[_ + 4], m = E[_ + 8], T = E[_ + 12], c[_ + h] = d * g[0] + f * g[1] + m * g[2] + T * g[3], 
                c[_ + h + 4] = d * g[4] + f * g[5] + m * g[6] + T * g[7], c[_ + h + 8] = d * g[8] + f * g[9] + m * g[10] + T * g[11], 
                c[_ + h + 12] = d * g[12] + f * g[13] + m * g[14] + T * g[15];
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxix",
            value: function(e, t, n, r, i, a) {
                var o, s, l = 0, u = 0, c = e.length;
                for (o = 0; o < c; l += e[o].keyframeWidth, u += 16, o++) Utils3D._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], r, u), 
                0 != o && (s = 16 * e[o].parentIndex, Utils3D.mulMatrixByArray(r, s, r, u, r, u));
                var h = n.length;
                for (o = 0; o < h; o++) Utils3D.mulMatrixByArrayAndMatrixFast(r, 16 * a[o], n[o], i, 16 * o);
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFast",
            value: function(e, t, n, r) {
                for (var i = 0, a = e.length; i < a; i++) Utils3D.mulMatrixByArrayAndMatrixFast(t, 16 * r[i], e[i], n, 16 * i);
            }
        }, {
            key: "_computeBoneAndAnimationDatasByBindPoseMatrxixOld",
            value: function(e, t, n, r, i) {
                var a, o, s = 0, l = 0, u = e.length;
                for (a = 0; a < u; s += e[a].keyframeWidth, l += 16, a++) Utils3D._rotationTransformScaleSkinAnimation(t[s + 7], t[s + 8], t[s + 9], t[s + 3], t[s + 4], t[s + 5], t[s + 6], t[s + 0], t[s + 1], t[s + 2], r, l), 
                0 != a && (o = 16 * e[a].parentIndex, Utils3D.mulMatrixByArray(r, o, r, l, r, l));
                var c = n.length;
                for (a = 0; a < c; a++) {
                    var h = 16 * a;
                    Utils3D.mulMatrixByArrayAndMatrixFast(r, h, n[a], i, h);
                }
            }
        }, {
            key: "_computeAnimationDatasByArrayAndMatrixFastOld",
            value: function(e, t, n) {
                for (var r = e.length, i = 0; i < r; i++) {
                    var a = 16 * i;
                    Utils3D.mulMatrixByArrayAndMatrixFast(t, a, e[i], n, a);
                }
            }
        }, {
            key: "_computeRootAnimationData",
            value: function(e, t, n) {
                for (var r = 0, i = 0, a = 0, o = e.length; r < o; i += e[r].keyframeWidth, a += 16, 
                r++) Utils3D.createAffineTransformationArray(t[i + 0], t[i + 1], t[i + 2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i + 8], t[i + 9], n, a);
            }
        }, {
            key: "transformVector3ArrayByQuat",
            value: function(e, t, n, r, i) {
                var a = e[t], o = e[t + 1], s = e[t + 2], l = n.x, u = n.y, c = n.z, h = n.w, _ = h * a + u * s - c * o, d = h * o + c * a - l * s, f = h * s + l * o - u * a, m = -l * a - u * o - c * s;
                r[i] = _ * h + m * -l + d * -c - f * -u, r[i + 1] = d * h + m * -u + f * -l - _ * -c, 
                r[i + 2] = f * h + m * -c + _ * -u - d * -l;
            }
        }, {
            key: "mulMatrixByArray",
            value: function(e, t, n, r, i, a) {
                var o, s, l, u, c;
                if (i === n) {
                    for (n = Utils3D._tempArray16_3, o = 0; o < 16; ++o) n[o] = i[a + o];
                    r = 0;
                }
                for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[t + o + 12], 
                i[a + o] = s * n[r + 0] + l * n[r + 1] + u * n[r + 2] + c * n[r + 3], i[a + o + 4] = s * n[r + 4] + l * n[r + 5] + u * n[r + 6] + c * n[r + 7], 
                i[a + o + 8] = s * n[r + 8] + l * n[r + 9] + u * n[r + 10] + c * n[r + 11], i[a + o + 12] = s * n[r + 12] + l * n[r + 13] + u * n[r + 14] + c * n[r + 15];
            }
        }, {
            key: "mulMatrixByArrayFast",
            value: function(e, t, n, r, i, a) {
                var o, s, l, u, c;
                for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[t + o + 12], 
                i[a + o] = s * n[r + 0] + l * n[r + 1] + u * n[r + 2] + c * n[r + 3], i[a + o + 4] = s * n[r + 4] + l * n[r + 5] + u * n[r + 6] + c * n[r + 7], 
                i[a + o + 8] = s * n[r + 8] + l * n[r + 9] + u * n[r + 10] + c * n[r + 11], i[a + o + 12] = s * n[r + 12] + l * n[r + 13] + u * n[r + 14] + c * n[r + 15];
            }
        }, {
            key: "mulMatrixByArrayAndMatrixFast",
            value: function(e, t, n, r, i) {
                var a, o, s, l, u, c = n.elements, h = c[0], _ = c[1], d = c[2], f = c[3], m = c[4], T = c[5], p = c[6], g = c[7], E = c[8], y = c[9], v = c[10], S = c[11], C = c[12], R = c[13], D = c[14], M = c[15], A = t, x = t + 4, L = t + 8, I = t + 12, O = i, P = i + 4, N = i + 8, b = i + 12;
                for (a = 0; a < 4; a++) o = e[A + a], s = e[x + a], l = e[L + a], u = e[I + a], 
                r[O + a] = o * h + s * _ + l * d + u * f, r[P + a] = o * m + s * T + l * p + u * g, 
                r[N + a] = o * E + s * y + l * v + u * S, r[b + a] = o * C + s * R + l * D + u * M;
            }
        }, {
            key: "createAffineTransformationArray",
            value: function(e, t, n, r, i, a, o, s, l, u, c, h) {
                var _ = r + r, d = i + i, f = a + a, m = r * _, T = r * d, p = r * f, g = i * d, E = i * f, y = a * f, v = o * _, S = o * d, C = o * f;
                c[h + 0] = (1 - (g + y)) * s, c[h + 1] = (T + C) * s, c[h + 2] = (p - S) * s, c[h + 3] = 0, 
                c[h + 4] = (T - C) * l, c[h + 5] = (1 - (m + y)) * l, c[h + 6] = (E + v) * l, c[h + 7] = 0, 
                c[h + 8] = (p + S) * u, c[h + 9] = (E - v) * u, c[h + 10] = (1 - (m + g)) * u, c[h + 11] = 0, 
                c[h + 12] = e, c[h + 13] = t, c[h + 14] = n, c[h + 15] = 1;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayCoordinate",
            value: function(e, t, n, r, i) {
                var a = e[t + 0], o = e[t + 1], s = e[t + 2], l = n.elements, u = a * l[3] + o * l[7] + s * l[11] + l[15];
                r[i] = a * l[0] + o * l[4] + s * l[8] + l[12] / u, r[i + 1] = a * l[1] + o * l[5] + s * l[9] + l[13] / u, 
                r[i + 2] = a * l[2] + o * l[6] + s * l[10] + l[14] / u;
            }
        }, {
            key: "transformVector3ArrayToVector3ArrayNormal",
            value: function(e, t, n, r, i) {
                var a = e[t + 0], o = e[t + 1], s = e[t + 2], l = n.elements;
                r[i] = a * l[0] + o * l[4] + s * l[8], r[i + 1] = a * l[1] + o * l[5] + s * l[9], 
                r[i + 2] = a * l[2] + o * l[6] + s * l[10];
            }
        }, {
            key: "transformLightingMapTexcoordArray",
            value: function(e, t, n, r, i) {
                r[i + 0] = e[t + 0] * n.x + n.z, r[i + 1] = 1 - ((1 - e[t + 1]) * n.y + n.w);
            }
        }, {
            key: "getURLVerion",
            value: function(e) {
                var t = e.indexOf("?");
                return t >= 0 ? e.substr(t) : null;
            }
        }, {
            key: "_createAffineTransformationArray",
            value: function(e, t, n, r) {
                var i = t.x, a = t.y, o = t.z, s = t.w, l = i + i, u = a + a, c = o + o, h = i * l, _ = i * u, d = i * c, f = a * u, m = a * c, T = o * c, p = s * l, g = s * u, E = s * c, y = n.x, v = n.y, S = n.z;
                r[0] = (1 - (f + T)) * y, r[1] = (_ + E) * y, r[2] = (d - g) * y, r[3] = 0, r[4] = (_ - E) * v, 
                r[5] = (1 - (h + T)) * v, r[6] = (m + p) * v, r[7] = 0, r[8] = (d + g) * S, r[9] = (m - p) * S, 
                r[10] = (1 - (h + f)) * S, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
            }
        }, {
            key: "_mulMatrixArray",
            value: function(e, t, n, r, i) {
                var a = t, o = e, s = r, l = a[n], u = a[n + 1], c = a[n + 2], h = a[n + 3], _ = a[n + 4], d = a[n + 5], f = a[n + 6], m = a[n + 7], T = a[n + 8], p = a[n + 9], g = a[n + 10], E = a[n + 11], y = a[n + 12], v = a[n + 13], S = a[n + 14], C = a[n + 15], R = o[0], D = o[1], M = o[2], A = o[3], x = o[4], L = o[5], I = o[6], O = o[7], P = o[8], N = o[9], b = o[10], k = o[11], w = o[12], B = o[13], V = o[14], F = o[15];
                s[i] = l * R + u * x + c * P + h * w, s[i + 1] = l * D + u * L + c * N + h * B, 
                s[i + 2] = l * M + u * I + c * b + h * V, s[i + 3] = l * A + u * O + c * k + h * F, 
                s[i + 4] = _ * R + d * x + f * P + m * w, s[i + 5] = _ * D + d * L + f * N + m * B, 
                s[i + 6] = _ * M + d * I + f * b + m * V, s[i + 7] = _ * A + d * O + f * k + m * F, 
                s[i + 8] = T * R + p * x + g * P + E * w, s[i + 9] = T * D + p * L + g * N + E * B, 
                s[i + 10] = T * M + p * I + g * b + E * V, s[i + 11] = T * A + p * O + g * k + E * F, 
                s[i + 12] = y * R + v * x + S * P + C * w, s[i + 13] = y * D + v * L + S * N + C * B, 
                s[i + 14] = y * M + v * I + S * b + C * V, s[i + 15] = y * A + v * O + S * k + C * F;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, n) {
                o.subtract(t, e, u.TEMPVector30), o.normalize(u.TEMPVector30, u.TEMPVector30), n.x = Math.asin(u.TEMPVector30.y), 
                n.y = Utils3D.arcTanAngle(-u.TEMPVector30.z, -u.TEMPVector30.x);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, n) {
                var r = t, i = e.x, a = e.y, o = e.z, s = r[0], l = r[1], u = r[2], c = r[3], h = c * i + l * o - u * a, _ = c * a + u * i - s * o, d = c * o + s * a - l * i, f = -s * i - l * a - u * o;
                n.x = h * c + f * -s + _ * -u - d * -l, n.y = _ * c + f * -l + d * -s - h * -u, 
                n.z = d * c + f * -u + h * -l - _ * -s;
            }
        }, {
            key: "quaternionWeight",
            value: function(e, t, n) {
                n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w;
            }
        }, {
            key: "quaternionConjugate",
            value: function(e, t) {
                t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
            }
        }, {
            key: "scaleWeight",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z;
                n.x = r > 0 ? Math.pow(Math.abs(r), t) : -Math.pow(Math.abs(r), t), n.y = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), 
                n.z = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t);
            }
        }, {
            key: "scaleBlend",
            value: function(e, t, n, r) {
                var i = Utils3D._tempVector3_0, a = Utils3D._tempVector3_1;
                Utils3D.scaleWeight(e, 1 - n, i), Utils3D.scaleWeight(t, n, a);
                var o = n > .5 ? t : e;
                r.x = o.x > 0 ? Math.abs(i.x * a.x) : -Math.abs(i.x * a.x), r.y = o.y > 0 ? Math.abs(i.y * a.y) : -Math.abs(i.y * a.y), 
                r.z = o.z > 0 ? Math.abs(i.z * a.z) : -Math.abs(i.z * a.z);
            }
        }, {
            key: "matrix4x4MultiplyFFF",
            value: function(e, t, n) {
                var r, i, a, o, s;
                if (n === t) for (t = new Float32Array(16), r = 0; r < 16; ++r) t[r] = n[r];
                var l = t[0], u = t[1], c = t[2], h = t[3], _ = t[4], d = t[5], f = t[6], m = t[7], T = t[8], p = t[9], g = t[10], E = t[11], y = t[12], v = t[13], S = t[14], C = t[15];
                for (r = 0; r < 4; r++) i = e[r], a = e[r + 4], o = e[r + 8], s = e[r + 12], n[r] = i * l + a * u + o * c + s * h, 
                n[r + 4] = i * _ + a * d + o * f + s * m, n[r + 8] = i * T + a * p + o * g + s * E, 
                n[r + 12] = i * y + a * v + o * S + s * C;
            }
        }, {
            key: "matrix4x4MultiplyFFFForNative",
            value: function(e, n, r) {
                t.LayaGL.instance.matrix4x4Multiply(e, n, r);
            }
        }, {
            key: "matrix4x4MultiplyMFM",
            value: function(e, t, n) {
                Utils3D.matrix4x4MultiplyFFF(e.elements, t, n.elements);
            }
        }, {
            key: "_buildTexture2D",
            value: function(e, n, r, i) {
                var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o = new t.Texture2D(e, n, r, a, !0);
                return o.anisoLevel = 1, o.filterMode = t.FilterMode.Point, I._generateTexture2D(o, e, n, i), 
                o;
            }
        }, {
            key: "_drawBound",
            value: function(e, t, n) {
                e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
                var r = Utils3D._tempVector3_0, i = Utils3D._tempVector3_1, a = t.min, o = t.max;
                r.setValue(a.x, a.y, a.z), i.setValue(o.x, a.y, a.z), e.addLine(r, i, n, n), r.setValue(a.x, a.y, a.z), 
                i.setValue(a.x, a.y, o.z), e.addLine(r, i, n, n), r.setValue(o.x, a.y, a.z), i.setValue(o.x, a.y, o.z), 
                e.addLine(r, i, n, n), r.setValue(a.x, a.y, o.z), i.setValue(o.x, a.y, o.z), e.addLine(r, i, n, n), 
                r.setValue(a.x, a.y, a.z), i.setValue(a.x, o.y, a.z), e.addLine(r, i, n, n), r.setValue(a.x, a.y, o.z), 
                i.setValue(a.x, o.y, o.z), e.addLine(r, i, n, n), r.setValue(o.x, a.y, a.z), i.setValue(o.x, o.y, a.z), 
                e.addLine(r, i, n, n), r.setValue(o.x, a.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(r, i, n, n), 
                r.setValue(a.x, o.y, a.z), i.setValue(o.x, o.y, a.z), e.addLine(r, i, n, n), r.setValue(a.x, o.y, a.z), 
                i.setValue(a.x, o.y, o.z), e.addLine(r, i, n, n), r.setValue(o.x, o.y, a.z), i.setValue(o.x, o.y, o.z), 
                e.addLine(r, i, n, n), r.setValue(a.x, o.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(r, i, n, n);
            }
        }, {
            key: "_getHierarchyPath",
            value: function(e, t, n) {
                n.length = 0;
                for (var r = t; r !== e; ) {
                    var i = r._parent;
                    if (!i) return null;
                    n.push(i.getChildIndex(r)), r = i;
                }
                return n;
            }
        }, {
            key: "_getNodeByHierarchyPath",
            value: function(e, t) {
                for (var n = e, r = t.length - 1; r >= 0; r--) n = n.getChildAt(t[r]);
                return n;
            }
        } ]), Utils3D;
    }();
    O._tempVector3_0 = new o(), O._tempVector3_1 = new o(), O._tempArray16_0 = new Float32Array(16), 
    O._tempArray16_1 = new Float32Array(16), O._tempArray16_2 = new Float32Array(16), 
    O._tempArray16_3 = new Float32Array(16), O._compIdToNode = new Object();
    var P = function(e) {
        function CharacterController() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m.COLLISIONFILTERGROUP_DEFAULTFILTER, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, CharacterController), (e = _possibleConstructorReturn(this, _getPrototypeOf(CharacterController).call(this, r, i)))._upAxis = new o(0, 1, 0), 
            e._maxSlope = 45, e._jumpSpeed = 10, e._fallSpeed = 55, e._gravity = new o(0, 3 * -9.8, 0), 
            e._btKinematicCharacter = null, e._stepHeight = t, n && (e._upAxis = n), e._controlBySimulation = !0, 
            e;
        }
        return _inherits(CharacterController, S), _createClass(CharacterController, [ {
            key: "_constructCharacter",
            value: function() {
                var e = l.Physics3D._bullet;
                this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this._btKinematicCharacter);
                var t = CharacterController._btTempVector30;
                e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z), this._btKinematicCharacter = e.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, t), 
                this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed, 
                this.gravity = this._gravity;
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_onShapeChange", this).call(this, e), 
                this._constructCharacter();
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = l.Physics3D._bullet, t = e.btPairCachingGhostObject_create();
                e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_setCollisionFlags(t, S.COLLISIONFLAGS_CHARACTER_OBJECT), 
                this._btColliderObject = t, this._colliderShape && this._constructCharacter(), _get(_getPrototypeOf(CharacterController.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removeCharacter(this);
                var e = this._simulation._characters;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this._maxSlope, 
                t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t.gravity = this._gravity;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                l.Physics3D._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter), 
                _get(_getPrototypeOf(CharacterController.prototype), "_onDestroy", this).call(this), 
                this._btKinematicCharacter = null;
            }
        }, {
            key: "move",
            value: function(e) {
                var t = CharacterController._btVector30, n = l.Physics3D._bullet;
                n.btVector3_setValue(t, -e.x, e.y, e.z), n.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, t);
            }
        }, {
            key: "jump",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = l.Physics3D._bullet, n = CharacterController._btVector30;
                e ? (O._convertToBulletVec3(e, n, !0), t.btKinematicCharacterController_jump(this._btKinematicCharacter, n)) : (t.btVector3_setValue(n, 0, 0, 0), 
                t.btKinematicCharacterController_jump(this._btKinematicCharacter, n));
            }
        }, {
            key: "fallSpeed",
            get: function() {
                return this._fallSpeed;
            },
            set: function(e) {
                this._fallSpeed = e, l.Physics3D._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "jumpSpeed",
            get: function() {
                return this._jumpSpeed;
            },
            set: function(e) {
                this._jumpSpeed = e, l.Physics3D._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "gravity",
            get: function() {
                return this._gravity;
            },
            set: function(e) {
                this._gravity = e;
                var t = l.Physics3D._bullet, n = CharacterController._btTempVector30;
                t.btVector3_setValue(n, -e.x, e.y, e.z), t.btKinematicCharacterController_setGravity(this._btKinematicCharacter, n);
            }
        }, {
            key: "maxSlope",
            get: function() {
                return this._maxSlope;
            },
            set: function(e) {
                this._maxSlope = e, l.Physics3D._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e / 180 * Math.PI);
            }
        }, {
            key: "isGrounded",
            get: function() {
                return l.Physics3D._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
            }
        }, {
            key: "stepHeight",
            get: function() {
                return this._stepHeight;
            },
            set: function(e) {
                this._stepHeight = e, l.Physics3D._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e);
            }
        }, {
            key: "upAxis",
            get: function() {
                return this._upAxis;
            },
            set: function(e) {
                this._upAxis = e;
                var t = CharacterController._btTempVector30;
                O._convertToBulletVec3(e, t, !1), l.Physics3D._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, t);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                CharacterController._btTempVector30 = l.Physics3D._bullet.btVector3_create(0, 0, 0);
            }
        } ]), CharacterController;
    }();
    P.UPAXIS_X = 0, P.UPAXIS_Y = 1, P.UPAXIS_Z = 2;
    var N = function(e) {
        function PhysicsTriggerComponent(e, t) {
            var n;
            return _classCallCheck(this, PhysicsTriggerComponent), (n = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsTriggerComponent).call(this, e, t)))._isTrigger = !1, 
            n;
        }
        return _inherits(PhysicsTriggerComponent, S), _createClass(PhysicsTriggerComponent, [ {
            key: "_onAdded",
            value: function() {
                _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_onAdded", this).call(this), 
                this.isTrigger = this._isTrigger;
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_cloneTo", this).call(this, e), 
                e.isTrigger = this._isTrigger;
            }
        }, {
            key: "isTrigger",
            get: function() {
                return this._isTrigger;
            },
            set: function(e) {
                this._isTrigger = e;
                var t = l.Physics3D._bullet;
                if (this._btColliderObject) {
                    var n = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
                    e ? 0 == (n & S.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, n | S.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (n & S.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, n ^ S.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                }
            }
        } ]), PhysicsTriggerComponent;
    }(), b = function(e) {
        function Rigidbody3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m.COLLISIONFILTERGROUP_DEFAULTFILTER, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, Rigidbody3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Rigidbody3D).call(this, t, n)))._isKinematic = !1, 
            e._mass = 1, e._gravity = new o(0, -10, 0), e._angularDamping = 0, e._linearDamping = 0, 
            e._overrideGravity = !1, e._totalTorque = new o(0, 0, 0), e._totalForce = new o(0, 0, 0), 
            e._linearVelocity = new o(), e._angularVelocity = new o(), e._linearFactor = new o(1, 1, 1), 
            e._angularFactor = new o(1, 1, 1), e._detectCollisions = !0, e._controlBySimulation = !0, 
            e;
        }
        return _inherits(Rigidbody3D, N), _createClass(Rigidbody3D, [ {
            key: "_updateMass",
            value: function(e) {
                if (this._btColliderObject && this._colliderShape) {
                    var t = l.Physics3D._bullet;
                    t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e, Rigidbody3D._btInertia), 
                    t.btRigidBody_setMassProps(this._btColliderObject, e, Rigidbody3D._btInertia), t.btRigidBody_updateInertiaTensor(this._btColliderObject);
                }
            }
        }, {
            key: "_onScaleChange",
            value: function(e) {
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_onScaleChange", this).call(this, e), 
                this._updateMass(this._isKinematic ? 0 : this._mass);
            }
        }, {
            key: "_derivePhysicsTransformation",
            value: function(e) {
                var t = l.Physics3D._bullet, n = this._btColliderObject, r = t.btCollisionObject_getWorldTransform(n), i = Rigidbody3D._btTransform0;
                t.btTransform_equal(i, r), this._innerDerivePhysicsTransformation(i, e), t.btRigidBody_setCenterOfMassTransform(n, i);
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = l.Physics3D._bullet, t = e.layaMotionState_create();
                e.layaMotionState_set_rigidBodyID(t, this._id), this._btLayaMotionState = t;
                var n = e.btRigidBodyConstructionInfo_create(0, t, null, Rigidbody3D._btVector3Zero), r = e.btRigidBody_create(n);
                e.btCollisionObject_setUserIndex(r, this.id), this._btColliderObject = r, _get(_getPrototypeOf(Rigidbody3D.prototype), "_onAdded", this).call(this), 
                this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor, 
                this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
                this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic, 
                e.btRigidBodyConstructionInfo_destroy(n);
            }
        }, {
            key: "_onEnable",
            value: function() {
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_onEnable", this).call(this), this._constaintRigidbodyA && this._constaintRigidbodyA.connectedBody._simulation && (this._constaintRigidbodyA._createConstraint(), 
                this._constaintRigidbodyA._onEnable()), this._constaintRigidbodyB && this._constaintRigidbodyB.ownBody._simulation && (this._constaintRigidbodyB._createConstraint(), 
                this._constaintRigidbodyB._onEnable());
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                if (_get(_getPrototypeOf(Rigidbody3D.prototype), "_onShapeChange", this).call(this, e), 
                this._isKinematic) this._updateMass(0); else {
                    var t = l.Physics3D._bullet;
                    t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t.btCollisionObject_getWorldTransform(this._btColliderObject)), 
                    this._updateMass(this._mass);
                }
            }
        }, {
            key: "_parse",
            value: function(e) {
                if (null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
                null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
                null != e.mass && (this.mass = e.mass), null != e.linearDamping && (this.linearDamping = e.linearDamping), 
                null != e.angularDamping && (this.angularDamping = e.angularDamping), null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), 
                null != e.linearFactor) {
                    var t = this.linearFactor;
                    t.fromArray(e.linearFactor), this.linearFactor = t;
                }
                if (null != e.angularFactor) {
                    var n = this.angularFactor;
                    n.fromArray(e.angularFactor), this.angularFactor = n;
                }
                e.gravity && (this.gravity.fromArray(e.gravity), this.gravity = this.gravity), _get(_getPrototypeOf(Rigidbody3D.prototype), "_parse", this).call(this, e), 
                this._parseShape(e.shapes), null != e.isKinematic && (this._isKinematic = e.isKinematic);
            }
        }, {
            key: "_onDestroy",
            value: function() {
                l.Physics3D._bullet.btMotionState_destroy(this._btLayaMotionState), _get(_getPrototypeOf(Rigidbody3D.prototype), "_onDestroy", this).call(this), 
                this._btLayaMotionState = null, this._gravity = null, this._totalTorque = null, 
                this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null, 
                this._angularFactor = null, this.constaintRigidbodyA && this.constaintRigidbodyA._breakConstrained(), 
                this.constaintRigidbodyB && (this.constaintRigidbodyB.connectedBody = null, this.constaintRigidbodyB._onDisable());
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removeRigidBody(this);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(Rigidbody3D.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this._gravity, 
                t.angularDamping = this._angularDamping, t.linearDamping = this._linearDamping, 
                t.overrideGravity = this._overrideGravity, t.linearVelocity = this._linearVelocity, 
                t.angularVelocity = this._angularVelocity, t.linearFactor = this._linearFactor, 
                t.angularFactor = this._angularFactor, t.detectCollisions = this._detectCollisions;
            }
        }, {
            key: "applyForce",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var n = l.Physics3D._bullet, r = Rigidbody3D._btTempVector30;
                if (n.btVector3_setValue(r, -e.x, e.y, e.z), t) {
                    var i = Rigidbody3D._btTempVector31;
                    n.btVector3_setValue(i, -t.x, t.y, t.z), n.btRigidBody_applyForce(this._btColliderObject, r, i);
                } else n.btRigidBody_applyCentralForce(this._btColliderObject, r);
            }
        }, {
            key: "applyTorque",
            value: function(e) {
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = l.Physics3D._bullet, n = Rigidbody3D._btTempVector30;
                t.btVector3_setValue(n, -e.x, e.y, e.z), t.btRigidBody_applyTorque(this._btColliderObject, n);
            }
        }, {
            key: "applyImpulse",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var n = l.Physics3D._bullet;
                n.btVector3_setValue(Rigidbody3D._btImpulse, -e.x, e.y, e.z), t ? (n.btVector3_setValue(Rigidbody3D._btImpulseOffset, -t.x, t.y, t.z), 
                n.btRigidBody_applyImpulse(this._btColliderObject, Rigidbody3D._btImpulse, Rigidbody3D._btImpulseOffset)) : n.btRigidBody_applyCentralImpulse(this._btColliderObject, Rigidbody3D._btImpulse);
            }
        }, {
            key: "applyTorqueImpulse",
            value: function(e) {
                if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = l.Physics3D._bullet, n = Rigidbody3D._btTempVector30;
                t.btVector3_setValue(n, -e.x, e.y, e.z), t.btRigidBody_applyTorqueImpulse(this._btColliderObject, n);
            }
        }, {
            key: "wakeUp",
            value: function() {
                this._btColliderObject && l.Physics3D._bullet.btCollisionObject_activate(this._btColliderObject, !1);
            }
        }, {
            key: "clearForces",
            value: function() {
                var e = this._btColliderObject;
                if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                var t = l.Physics3D._bullet;
                t.btRigidBody_clearForces(e);
                var n = Rigidbody3D._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(e, n), t.btRigidBody_setLinearVelocity(e, n), 
                t.btCollisionObject_setInterpolationAngularVelocity(e, n), t.btRigidBody_setAngularVelocity(e, n);
            }
        }, {
            key: "mass",
            get: function() {
                return this._mass;
            },
            set: function(e) {
                e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
            }
        }, {
            key: "isKinematic",
            get: function() {
                return this._isKinematic;
            },
            set: function(e) {
                this._isKinematic = e, this._controlBySimulation = !e;
                var t = l.Physics3D._bullet, n = !!(this._simulation && this._enabled && this._colliderShape);
                n && this._removeFromSimulation();
                var r = this._btColliderObject, i = t.btCollisionObject_getCollisionFlags(r);
                e ? (i |= S.COLLISIONFLAGS_KINEMATIC_OBJECT, t.btCollisionObject_setCollisionFlags(r, i), 
                t.btCollisionObject_forceActivationState(this._btColliderObject, S.ACTIVATIONSTATE_DISABLE_DEACTIVATION), 
                this._enableProcessCollisions = !1, this._updateMass(0)) : ((i & S.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (i ^= S.COLLISIONFLAGS_KINEMATIC_OBJECT), 
                t.btCollisionObject_setCollisionFlags(r, i), t.btCollisionObject_setActivationState(this._btColliderObject, S.ACTIVATIONSTATE_ACTIVE_TAG), 
                this._enableProcessCollisions = !0, this._updateMass(this._mass));
                var a = Rigidbody3D._btVector3Zero;
                t.btCollisionObject_setInterpolationLinearVelocity(r, a), t.btRigidBody_setLinearVelocity(r, a), 
                t.btCollisionObject_setInterpolationAngularVelocity(r, a), t.btRigidBody_setAngularVelocity(r, a), 
                n && this._addToSimulation();
            }
        }, {
            key: "linearDamping",
            get: function() {
                return this._linearDamping;
            },
            set: function(e) {
                this._linearDamping = e, this._btColliderObject && l.Physics3D._bullet.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping);
            }
        }, {
            key: "angularDamping",
            get: function() {
                return this._angularDamping;
            },
            set: function(e) {
                this._angularDamping = e, this._btColliderObject && l.Physics3D._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e);
            }
        }, {
            key: "overrideGravity",
            get: function() {
                return this._overrideGravity;
            },
            set: function(e) {
                this._overrideGravity = e;
                var t = l.Physics3D._bullet;
                if (this._btColliderObject) {
                    var n = t.btRigidBody_getFlags(this._btColliderObject);
                    e ? 0 == (n & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) && t.btRigidBody_setFlags(this._btColliderObject, n | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) : (n & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this._btColliderObject, n ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                }
            }
        }, {
            key: "gravity",
            get: function() {
                return this._gravity;
            },
            set: function(e) {
                this._gravity = e;
                var t = l.Physics3D._bullet;
                t.btVector3_setValue(Rigidbody3D._btGravity, -e.x, e.y, e.z), t.btRigidBody_setGravity(this._btColliderObject, Rigidbody3D._btGravity);
            }
        }, {
            key: "totalForce",
            get: function() {
                if (this._btColliderObject) {
                    var e = l.Physics3D._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                    return O._convertToLayaVec3(e, this._totalForce, !0), this._totalForce;
                }
                return null;
            }
        }, {
            key: "linearFactor",
            get: function() {
                return this._linearFactor;
            },
            set: function(e) {
                this._linearFactor = e;
                var t = Rigidbody3D._btTempVector30;
                O._convertToBulletVec3(e, t, !1), l.Physics3D._bullet.btRigidBody_setLinearFactor(this._btColliderObject, t);
            }
        }, {
            key: "linearVelocity",
            get: function() {
                return this._btColliderObject && O._convertToLayaVec3(l.Physics3D._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity, !0), 
                this._linearVelocity;
            },
            set: function(e) {
                if (this._linearVelocity = e, this._btColliderObject) {
                    var t = Rigidbody3D._btTempVector30;
                    O._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), l.Physics3D._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "angularFactor",
            get: function() {
                return this._angularFactor;
            },
            set: function(e) {
                this._angularFactor = e;
                var t = Rigidbody3D._btTempVector30;
                O._convertToBulletVec3(e, t, !1), l.Physics3D._bullet.btRigidBody_setAngularFactor(this._btColliderObject, t);
            }
        }, {
            key: "angularVelocity",
            get: function() {
                return this._btColliderObject && O._convertToLayaVec3(l.Physics3D._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity, !0), 
                this._angularVelocity;
            },
            set: function(e) {
                if (this._angularVelocity = e, this._btColliderObject) {
                    var t = Rigidbody3D._btTempVector30;
                    O._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), l.Physics3D._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, t);
                }
            }
        }, {
            key: "totalTorque",
            get: function() {
                if (this._btColliderObject) {
                    var e = l.Physics3D._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                    return O._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque;
                }
                return null;
            }
        }, {
            key: "detectCollisions",
            get: function() {
                return this._detectCollisions;
            },
            set: function(e) {
                this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this), 
                this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
            }
        }, {
            key: "isSleeping",
            get: function() {
                return !!this._btColliderObject && l.Physics3D._bullet.btCollisionObject_getActivationState(this._btColliderObject) === S.ACTIVATIONSTATE_ISLAND_SLEEPING;
            }
        }, {
            key: "sleepLinearVelocity",
            get: function() {
                return l.Physics3D._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
            },
            set: function(e) {
                var t = l.Physics3D._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
            }
        }, {
            key: "sleepAngularVelocity",
            get: function() {
                return l.Physics3D._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
            },
            set: function(e) {
                var t = l.Physics3D._bullet;
                t.btRigidBody_setSleepingThresholds(this._btColliderObject, t.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e);
            }
        }, {
            key: "btColliderObject",
            get: function() {
                return this._btColliderObject;
            }
        }, {
            key: "constaintRigidbodyA",
            set: function(e) {
                this._constaintRigidbodyA = e;
            },
            get: function() {
                return this._constaintRigidbodyA;
            }
        }, {
            key: "constaintRigidbodyB",
            set: function(e) {
                this._constaintRigidbodyB = e;
            },
            get: function() {
                return this._constaintRigidbodyB;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = l.Physics3D._bullet;
                Rigidbody3D._btTempVector30 = e.btVector3_create(0, 0, 0), Rigidbody3D._btTempVector31 = e.btVector3_create(0, 0, 0), 
                Rigidbody3D._btVector3Zero = e.btVector3_create(0, 0, 0), Rigidbody3D._btInertia = e.btVector3_create(0, 0, 0), 
                Rigidbody3D._btImpulse = e.btVector3_create(0, 0, 0), Rigidbody3D._btImpulseOffset = e.btVector3_create(0, 0, 0), 
                Rigidbody3D._btGravity = e.btVector3_create(0, 0, 0), Rigidbody3D._btTransform0 = e.btTransform_create();
            }
        } ]), Rigidbody3D;
    }();
    b.TYPE_STATIC = 0, b.TYPE_DYNAMIC = 1, b.TYPE_KINEMATIC = 2, b._BT_DISABLE_WORLD_GRAVITY = 1, 
    b._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    var k = function() {
        function Physics3D() {
            _classCallCheck(this, Physics3D);
        }
        return _createClass(Physics3D, null, [ {
            key: "__bulletinit__",
            value: function() {
                this._bullet = window.Physics3D, this._bullet && (_.__init__(), h.__init__(), d.__init__(), 
                S.__init__(), L.__init__(), T.__init__(), E.__init__(), P.__init__(), b.__init__());
            }
        }, {
            key: "__cannoninit__",
            value: function() {
                this._cannon = window.CANNON, this._cannon && (t.CannonColliderShape.__init__(), 
                t.CannonPhysicsComponent.__init__(), t.CannonPhysicsSimulation.__init__(), t.CannonBoxColliderShape.__init__(), 
                t.CannonRigidbody3D.__init__());
            }
        } ]), Physics3D;
    }();
    k._bullet = null, k._cannon = null, k._enablePhysics = !1;
    var w = function() {
        function Config3D() {
            _classCallCheck(this, Config3D), this._defaultPhysicsMemory = 16, this._maxLightCount = 32, 
            this._lightClusterCount = new o(12, 12, 12), this._editerEnvironment = !1, this.isAntialias = !0, 
            this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.enableMultiLight = !0, 
            this.octreeCulling = !1, this.octreeInitialSize = 64, this.octreeInitialCenter = new o(0, 0, 0), 
            this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, this.debugFrustumCulling = !1, 
            this.pbrRenderQuality = e.PBRRenderQuality.High, this.isUseCannonPhysicsEngine = !1, 
            this._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount.z - 1), this._maxLightCount);
        }
        return _createClass(Config3D, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment, 
                t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha, 
                t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter), 
                t.octreeInitialSize = this.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize, 
                t.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this.debugFrustumCulling, 
                t.maxLightCount = this.maxLightCount, t.enableMultiLight = this.enableMultiLight;
                var n = t.lightClusterCount;
                this.lightClusterCount.cloneTo(n), t.lightClusterCount = n, t.pbrRenderQuality = this.pbrRenderQuality;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Config3D();
                return this.cloneTo(e), e;
            }
        }, {
            key: "defaultPhysicsMemory",
            get: function() {
                return this._defaultPhysicsMemory;
            },
            set: function(e) {
                if (e < 16) throw "defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = e;
            }
        }, {
            key: "maxLightCount",
            get: function() {
                return this._maxLightCount;
            },
            set: function(e) {
                e > 2048 ? (this._maxLightCount = 2048, console.warn("Config3D: maxLightCount must less equal 2048.")) : this._maxLightCount = e;
            }
        }, {
            key: "lightClusterCount",
            get: function() {
                return this._lightClusterCount;
            },
            set: function(e) {
                e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)), 
                console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e.cloneTo(this._lightClusterCount);
                var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
                t < this._maxLightCount && console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + t + ",maybe the far away culster will ingonre some light."), 
                this._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount);
            }
        } ], [ {
            key: "useCannonPhysics",
            get: function() {
                return Config3D._config.isUseCannonPhysicsEngine;
            },
            set: function(e) {
                Config3D._config.isUseCannonPhysicsEngine = e, e && (k.__cannoninit__(), l.Scene3D.cannonPhysicsSettings || (l.Scene3D.cannonPhysicsSettings = new t.CannonPhysicsSettings()));
            }
        } ]), Config3D;
    }();
    w._config = new w(), window.Config3D = w;
    var B = function() {
        function KeyframeNode() {
            _classCallCheck(this, KeyframeNode), this._ownerPath = [], this._propertys = [], 
            this._keyFrames = [];
        }
        return _createClass(KeyframeNode, [ {
            key: "_setOwnerPathCount",
            value: function(e) {
                this._ownerPath.length = e;
            }
        }, {
            key: "_setOwnerPathByIndex",
            value: function(e, t) {
                this._ownerPath[e] = t;
            }
        }, {
            key: "_joinOwnerPath",
            value: function(e) {
                return this._ownerPath.join(e);
            }
        }, {
            key: "_setPropertyCount",
            value: function(e) {
                this._propertys.length = e;
            }
        }, {
            key: "_setPropertyByIndex",
            value: function(e, t) {
                this._propertys[e] = t;
            }
        }, {
            key: "_joinProperty",
            value: function(e) {
                return this._propertys.join(e);
            }
        }, {
            key: "_setKeyframeCount",
            value: function(e) {
                this._keyFrames.length = e;
            }
        }, {
            key: "_setKeyframeByIndex",
            value: function(e, t) {
                this._keyFrames[e] = t;
            }
        }, {
            key: "getOwnerPathByIndex",
            value: function(e) {
                return this._ownerPath[e];
            }
        }, {
            key: "getPropertyByIndex",
            value: function(e) {
                return this._propertys[e];
            }
        }, {
            key: "getKeyframeByIndex",
            value: function(e) {
                return this._keyFrames[e];
            }
        }, {
            key: "ownerPathCount",
            get: function() {
                return this._ownerPath.length;
            }
        }, {
            key: "propertyCount",
            get: function() {
                return this._propertys.length;
            }
        }, {
            key: "keyFramesCount",
            get: function() {
                return this._keyFrames.length;
            }
        } ]), KeyframeNode;
    }(), V = function AnimationEvent() {
        _classCallCheck(this, AnimationEvent);
    }, F = function() {
        function Keyframe() {
            _classCallCheck(this, Keyframe);
        }
        return _createClass(Keyframe, [ {
            key: "cloneTo",
            value: function(e) {
                e.time = this.time;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Keyframe();
                return this.cloneTo(e), e;
            }
        } ]), Keyframe;
    }(), U = function(e) {
        function FloatKeyframe() {
            return _classCallCheck(this, FloatKeyframe), _possibleConstructorReturn(this, _getPrototypeOf(FloatKeyframe).call(this));
        }
        return _inherits(FloatKeyframe, F), _createClass(FloatKeyframe, [ {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(FloatKeyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this.value;
            }
        } ]), FloatKeyframe;
    }(), G = function(e) {
        function QuaternionKeyframe() {
            var e;
            return _classCallCheck(this, QuaternionKeyframe), (e = _possibleConstructorReturn(this, _getPrototypeOf(QuaternionKeyframe).call(this))).inTangent = new i(), 
            e.outTangent = new i(), e.value = new u(), e;
        }
        return _inherits(QuaternionKeyframe, F), _createClass(QuaternionKeyframe, [ {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(QuaternionKeyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
            }
        } ]), QuaternionKeyframe;
    }(), H = function(e) {
        function Vector3Keyframe() {
            var e;
            return _classCallCheck(this, Vector3Keyframe), (e = _possibleConstructorReturn(this, _getPrototypeOf(Vector3Keyframe).call(this))).inTangent = new o(), 
            e.outTangent = new o(), e.value = new o(), e;
        }
        return _inherits(Vector3Keyframe, F), _createClass(Vector3Keyframe, [ {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(Vector3Keyframe.prototype), "cloneTo", this).call(this, e);
                var t = e;
                this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
            }
        } ]), Vector3Keyframe;
    }(), z = function() {
        function AnimationClipParser03() {
            _classCallCheck(this, AnimationClipParser03);
        }
        return _createClass(AnimationClipParser03, null, [ {
            key: "READ_DATA",
            value: function() {
                AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(), 
                AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16(), t = AnimationClipParser03._BLOCK.blockStarts = [], n = AnimationClipParser03._BLOCK.blockLengths = [], r = 0; r < e; r++) t.push(AnimationClipParser03._reader.getUint32()), 
                n.push(AnimationClipParser03._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = AnimationClipParser03._reader.getUint32(), t = AnimationClipParser03._reader.getUint16(), n = AnimationClipParser03._reader.pos;
                AnimationClipParser03._reader.pos = e + AnimationClipParser03._DATA.offset;
                for (var r = 0; r < t; r++) AnimationClipParser03._strings[r] = AnimationClipParser03._reader.readUTFString();
                AnimationClipParser03._reader.pos = n;
            }
        }, {
            key: "parse",
            value: function(e, t) {
                AnimationClipParser03._animationClip = e, AnimationClipParser03._reader = t;
                t.__getBuffer();
                AnimationClipParser03.READ_DATA(), AnimationClipParser03.READ_BLOCK(), AnimationClipParser03.READ_STRINGS();
                for (var n = 0, r = AnimationClipParser03._BLOCK.count; n < r; n++) {
                    var i = t.getUint16(), a = AnimationClipParser03._strings[i], o = AnimationClipParser03["READ_" + a];
                    if (null == o) throw new Error("model file err,no this function:" + i + " " + a);
                    o.call(null);
                }
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, n, r, i = AnimationClipParser03._reader, a = (i.__getBuffer(), []), o = i.getUint16();
                for (a.length = o, e = 0; e < o; e++) a[e] = i.getFloat32();
                var s = AnimationClipParser03._animationClip;
                s.name = AnimationClipParser03._strings[i.getUint16()];
                var l = s._duration = i.getFloat32();
                s.islooping = !!i.getByte(), s._frameRate = i.getInt16();
                var u = i.getInt16(), c = s._nodes;
                c.count = u;
                var h = s._nodesMap = {}, _ = s._nodesDic = {};
                for (e = 0; e < u; e++) {
                    r = new B(), c.setNodeByIndex(e, r), r._indexInList = e;
                    var d = r.type = i.getUint8(), f = i.getUint16();
                    for (r._setOwnerPathCount(f), n = 0; n < f; n++) r._setOwnerPathByIndex(n, AnimationClipParser03._strings[i.getUint16()]);
                    var m = r._joinOwnerPath("/"), T = h[m];
                    T || (h[m] = T = []), T.push(r), r.propertyOwner = AnimationClipParser03._strings[i.getUint16()];
                    var p = i.getUint16();
                    for (r._setPropertyCount(p), n = 0; n < p; n++) r._setPropertyByIndex(n, AnimationClipParser03._strings[i.getUint16()]);
                    var g = m + "." + r.propertyOwner + "." + r._joinProperty(".");
                    _[g] = r, r.fullPath = g;
                    var E = i.getUint16();
                    for (r._setKeyframeCount(E), n = 0; n < E; n++) switch (d) {
                      case 0:
                        var y = new U();
                        r._setKeyframeByIndex(n, y), y.time = a[i.getUint16()], y.inTangent = i.getFloat32(), 
                        y.outTangent = i.getFloat32(), y.value = i.getFloat32();
                        break;

                      case 1:
                      case 3:
                      case 4:
                        var v = new H();
                        if (r._setKeyframeByIndex(n, v), v.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (var S = v.data = new Float32Array(9), C = 0; C < 3; C++) S[C] = i.getFloat32();
                            for (C = 0; C < 3; C++) S[3 + C] = i.getFloat32();
                            for (C = 0; C < 3; C++) S[6 + C] = i.getFloat32();
                        } else {
                            var R = v.inTangent, D = v.outTangent, M = v.value;
                            R.x = i.getFloat32(), R.y = i.getFloat32(), R.z = i.getFloat32(), D.x = i.getFloat32(), 
                            D.y = i.getFloat32(), D.z = i.getFloat32(), M.x = i.getFloat32(), M.y = i.getFloat32(), 
                            M.z = i.getFloat32();
                        }
                        break;

                      case 2:
                        var A = new G();
                        if (r._setKeyframeByIndex(n, A), A.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (S = A.data = new Float32Array(12), C = 0; C < 4; C++) S[C] = i.getFloat32();
                            for (C = 0; C < 4; C++) S[4 + C] = i.getFloat32();
                            for (C = 0; C < 4; C++) S[8 + C] = i.getFloat32();
                        } else {
                            var x = A.inTangent, L = A.outTangent, I = A.value;
                            x.x = i.getFloat32(), x.y = i.getFloat32(), x.z = i.getFloat32(), x.w = i.getFloat32(), 
                            L.x = i.getFloat32(), L.y = i.getFloat32(), L.z = i.getFloat32(), L.w = i.getFloat32(), 
                            I.x = i.getFloat32(), I.y = i.getFloat32(), I.z = i.getFloat32(), I.w = i.getFloat32();
                        }
                        break;

                      default:
                        throw "AnimationClipParser03:unknown type.";
                    }
                }
                var O = i.getUint16();
                for (e = 0; e < O; e++) {
                    var P, N = new V();
                    N.time = Math.min(l, i.getFloat32()), N.eventName = AnimationClipParser03._strings[i.getUint16()];
                    var b = i.getUint16();
                    for (b > 0 && (N.params = P = []), n = 0; n < b; n++) {
                        switch (i.getByte()) {
                          case 0:
                            P.push(!!i.getByte());
                            break;

                          case 1:
                            P.push(i.getInt32());
                            break;

                          case 2:
                            P.push(i.getFloat32());
                            break;

                          case 3:
                            P.push(AnimationClipParser03._strings[i.getUint16()]);
                            break;

                          default:
                            throw new Error("unknown type.");
                        }
                    }
                    s.addEvent(N);
                }
            }
        } ]), AnimationClipParser03;
    }();
    z._strings = [], z._BLOCK = {
        count: 0
    }, z._DATA = {
        offset: 0,
        size: 0
    };
    var W = function() {
        function HalfFloatUtils() {
            _classCallCheck(this, HalfFloatUtils);
        }
        return _createClass(HalfFloatUtils, null, [ {
            key: "__init__",
            value: function() {
                for (var e = 0; e < 256; ++e) {
                    var t = e - 127;
                    t < -27 ? (HalfFloatUtils._baseTable[0 | e] = 0, HalfFloatUtils._baseTable[256 | e] = 32768, 
                    HalfFloatUtils._shiftTable[0 | e] = 24, HalfFloatUtils._shiftTable[256 | e] = 24) : t < -14 ? (HalfFloatUtils._baseTable[0 | e] = 1024 >> -t - 14, 
                    HalfFloatUtils._baseTable[256 | e] = 1024 >> -t - 14 | 32768, HalfFloatUtils._shiftTable[0 | e] = -t - 1, 
                    HalfFloatUtils._shiftTable[256 | e] = -t - 1) : t <= 15 ? (HalfFloatUtils._baseTable[0 | e] = t + 15 << 10, 
                    HalfFloatUtils._baseTable[256 | e] = t + 15 << 10 | 32768, HalfFloatUtils._shiftTable[0 | e] = 13, 
                    HalfFloatUtils._shiftTable[256 | e] = 13) : t < 128 ? (HalfFloatUtils._baseTable[0 | e] = 31744, 
                    HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 24, 
                    HalfFloatUtils._shiftTable[256 | e] = 24) : (HalfFloatUtils._baseTable[0 | e] = 31744, 
                    HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 13, 
                    HalfFloatUtils._shiftTable[256 | e] = 13);
                }
                for (HalfFloatUtils._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                    var n = e << 13;
                    for (t = 0; 0 == (8388608 & n); ) t -= 8388608, n <<= 1;
                    n &= -8388609, t += 947912704, HalfFloatUtils._mantissaTable[e] = n | t;
                }
                for (e = 1024; e < 2048; ++e) HalfFloatUtils._mantissaTable[e] = 939524096 + (e - 1024 << 13);
                for (HalfFloatUtils._exponentTable[0] = 0, e = 1; e < 31; ++e) HalfFloatUtils._exponentTable[e] = e << 23;
                for (HalfFloatUtils._exponentTable[31] = 1199570944, HalfFloatUtils._exponentTable[32] = 2147483648, 
                e = 33; e < 63; ++e) HalfFloatUtils._exponentTable[e] = 2147483648 + (e - 32 << 23);
                for (HalfFloatUtils._exponentTable[63] = 3347054592, HalfFloatUtils._offsetTable[0] = 0, 
                e = 1; e < 64; ++e) HalfFloatUtils._offsetTable[e] = 32 === e ? 0 : 1024;
            }
        }, {
            key: "roundToFloat16Bits",
            value: function(e) {
                HalfFloatUtils._floatView[0] = e;
                var t = HalfFloatUtils._uint32View[0], n = t >> 23 & 511;
                return HalfFloatUtils._baseTable[n] + ((8388607 & t) >> HalfFloatUtils._shiftTable[n]);
            }
        }, {
            key: "convertToNumber",
            value: function(e) {
                var t = e >> 10;
                return HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[t] + (1023 & e)] + HalfFloatUtils._exponentTable[t], 
                HalfFloatUtils._floatView[0];
            }
        } ]), HalfFloatUtils;
    }();
    W._buffer = new ArrayBuffer(4), W._floatView = new Float32Array(W._buffer), W._uint32View = new Uint32Array(W._buffer), 
    W._baseTable = new Uint32Array(512), W._shiftTable = new Uint32Array(512), W._mantissaTable = new Uint32Array(2048), 
    W._exponentTable = new Uint32Array(64), W._offsetTable = new Uint32Array(64);
    var X = function() {
        function AnimationClipParser04() {
            _classCallCheck(this, AnimationClipParser04);
        }
        return _createClass(AnimationClipParser04, null, [ {
            key: "READ_DATA",
            value: function() {
                AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(), 
                AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16(), t = AnimationClipParser04._BLOCK.blockStarts = [], n = AnimationClipParser04._BLOCK.blockLengths = [], r = 0; r < e; r++) t.push(AnimationClipParser04._reader.getUint32()), 
                n.push(AnimationClipParser04._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = AnimationClipParser04._reader.getUint32(), t = AnimationClipParser04._reader.getUint16(), n = AnimationClipParser04._reader.pos;
                AnimationClipParser04._reader.pos = e + AnimationClipParser04._DATA.offset;
                for (var r = 0; r < t; r++) AnimationClipParser04._strings[r] = AnimationClipParser04._reader.readUTFString();
                AnimationClipParser04._reader.pos = n;
            }
        }, {
            key: "parse",
            value: function(e, t, n) {
                AnimationClipParser04._animationClip = e, AnimationClipParser04._reader = t, AnimationClipParser04._version = n, 
                AnimationClipParser04.READ_DATA(), AnimationClipParser04.READ_BLOCK(), AnimationClipParser04.READ_STRINGS();
                for (var r = 0, i = AnimationClipParser04._BLOCK.count; r < i; r++) {
                    var a = t.getUint16(), o = AnimationClipParser04._strings[a], s = AnimationClipParser04["READ_" + o];
                    if (null == s) throw new Error("model file err,no this function:" + a + " " + o);
                    s.call(null);
                }
                AnimationClipParser04._version = null, AnimationClipParser04._reader = null, AnimationClipParser04._animationClip = null;
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, n, r, i = AnimationClipParser04._reader, a = (i.__getBuffer(), []), o = i.getUint16();
                for (a.length = o, e = 0; e < o; e++) a[e] = i.getFloat32();
                var s = AnimationClipParser04._animationClip;
                s.name = AnimationClipParser04._strings[i.getUint16()];
                var l = s._duration = i.getFloat32();
                s.islooping = !!i.getByte(), s._frameRate = i.getInt16();
                var u = i.getInt16(), c = s._nodes;
                c.count = u;
                var h = s._nodesMap = {}, _ = s._nodesDic = {};
                for (e = 0; e < u; e++) {
                    r = new B(), c.setNodeByIndex(e, r), r._indexInList = e;
                    var d = r.type = i.getUint8(), f = i.getUint16();
                    for (r._setOwnerPathCount(f), n = 0; n < f; n++) r._setOwnerPathByIndex(n, AnimationClipParser04._strings[i.getUint16()]);
                    var m = r._joinOwnerPath("/"), T = h[m];
                    T || (h[m] = T = []), T.push(r), r.propertyOwner = AnimationClipParser04._strings[i.getUint16()];
                    var p = i.getUint16();
                    for (r._setPropertyCount(p), n = 0; n < p; n++) r._setPropertyByIndex(n, AnimationClipParser04._strings[i.getUint16()]);
                    var g = m + "." + r.propertyOwner + "." + r._joinProperty(".");
                    _[g] = r, r.fullPath = g;
                    var E = i.getUint16();
                    switch (r._setKeyframeCount(E), AnimationClipParser04._version) {
                      case "LAYAANIMATION:04":
                        for (n = 0; n < E; n++) switch (d) {
                          case 0:
                            var y = new U();
                            r._setKeyframeByIndex(n, y), y.time = a[i.getUint16()], y.inTangent = i.getFloat32(), 
                            y.outTangent = i.getFloat32(), y.value = i.getFloat32();
                            break;

                          case 1:
                          case 3:
                          case 4:
                            var v = new H();
                            if (r._setKeyframeByIndex(n, v), v.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                for (var S = v.data = new Float32Array(9), C = 0; C < 3; C++) S[C] = i.getFloat32();
                                for (C = 0; C < 3; C++) S[3 + C] = i.getFloat32();
                                for (C = 0; C < 3; C++) S[6 + C] = i.getFloat32();
                            } else {
                                var R = v.inTangent, D = v.outTangent, M = v.value;
                                R.x = i.getFloat32(), R.y = i.getFloat32(), R.z = i.getFloat32(), D.x = i.getFloat32(), 
                                D.y = i.getFloat32(), D.z = i.getFloat32(), M.x = i.getFloat32(), M.y = i.getFloat32(), 
                                M.z = i.getFloat32();
                            }
                            break;

                          case 2:
                            var A = new G();
                            if (r._setKeyframeByIndex(n, A), A.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                for (S = A.data = new Float32Array(12), C = 0; C < 4; C++) S[C] = i.getFloat32();
                                for (C = 0; C < 4; C++) S[4 + C] = i.getFloat32();
                                for (C = 0; C < 4; C++) S[8 + C] = i.getFloat32();
                            } else {
                                var x = A.inTangent, L = A.outTangent, I = A.value;
                                x.x = i.getFloat32(), x.y = i.getFloat32(), x.z = i.getFloat32(), x.w = i.getFloat32(), 
                                L.x = i.getFloat32(), L.y = i.getFloat32(), L.z = i.getFloat32(), L.w = i.getFloat32(), 
                                I.x = i.getFloat32(), I.y = i.getFloat32(), I.z = i.getFloat32(), I.w = i.getFloat32();
                            }
                            break;

                          default:
                            throw "AnimationClipParser04:unknown type.";
                        }
                        break;

                      case "LAYAANIMATION:COMPRESSION_04":
                        for (n = 0; n < E; n++) switch (d) {
                          case 0:
                            y = new U(), r._setKeyframeByIndex(n, y), y.time = a[i.getUint16()], y.inTangent = W.convertToNumber(i.getUint16()), 
                            y.outTangent = W.convertToNumber(i.getUint16()), y.value = W.convertToNumber(i.getUint16());
                            break;

                          case 1:
                          case 3:
                          case 4:
                            if (v = new H(), r._setKeyframeByIndex(n, v), v.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                for (S = v.data = new Float32Array(9), C = 0; C < 3; C++) S[C] = W.convertToNumber(i.getUint16());
                                for (C = 0; C < 3; C++) S[3 + C] = W.convertToNumber(i.getUint16());
                                for (C = 0; C < 3; C++) S[6 + C] = W.convertToNumber(i.getUint16());
                            } else R = v.inTangent, D = v.outTangent, M = v.value, R.x = W.convertToNumber(i.getUint16()), 
                            R.y = W.convertToNumber(i.getUint16()), R.z = W.convertToNumber(i.getUint16()), 
                            D.x = W.convertToNumber(i.getUint16()), D.y = W.convertToNumber(i.getUint16()), 
                            D.z = W.convertToNumber(i.getUint16()), M.x = W.convertToNumber(i.getUint16()), 
                            M.y = W.convertToNumber(i.getUint16()), M.z = W.convertToNumber(i.getUint16());
                            break;

                          case 2:
                            if (A = new G(), r._setKeyframeByIndex(n, A), A.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                for (S = A.data = new Float32Array(12), C = 0; C < 4; C++) S[C] = W.convertToNumber(i.getUint16());
                                for (C = 0; C < 4; C++) S[4 + C] = W.convertToNumber(i.getUint16());
                                for (C = 0; C < 4; C++) S[8 + C] = W.convertToNumber(i.getUint16());
                            } else x = A.inTangent, L = A.outTangent, I = A.value, x.x = W.convertToNumber(i.getUint16()), 
                            x.y = W.convertToNumber(i.getUint16()), x.z = W.convertToNumber(i.getUint16()), 
                            x.w = W.convertToNumber(i.getUint16()), L.x = W.convertToNumber(i.getUint16()), 
                            L.y = W.convertToNumber(i.getUint16()), L.z = W.convertToNumber(i.getUint16()), 
                            L.w = W.convertToNumber(i.getUint16()), I.x = W.convertToNumber(i.getUint16()), 
                            I.y = W.convertToNumber(i.getUint16()), I.z = W.convertToNumber(i.getUint16()), 
                            I.w = W.convertToNumber(i.getUint16());
                            break;

                          default:
                            throw "AnimationClipParser04:unknown type.";
                        }
                    }
                }
                var O = i.getUint16();
                for (e = 0; e < O; e++) {
                    var P, N = new V();
                    N.time = Math.min(l, i.getFloat32()), N.eventName = AnimationClipParser04._strings[i.getUint16()];
                    var b = i.getUint16();
                    for (b > 0 && (N.params = P = []), n = 0; n < b; n++) {
                        switch (i.getByte()) {
                          case 0:
                            P.push(!!i.getByte());
                            break;

                          case 1:
                            P.push(i.getInt32());
                            break;

                          case 2:
                            P.push(i.getFloat32());
                            break;

                          case 3:
                            P.push(AnimationClipParser04._strings[i.getUint16()]);
                            break;

                          default:
                            throw new Error("unknown type.");
                        }
                    }
                    s.addEvent(N);
                }
            }
        } ]), AnimationClipParser04;
    }();
    X._strings = [], X._BLOCK = {
        count: 0
    }, X._DATA = {
        offset: 0,
        size: 0
    };
    var Y = function() {
        function KeyframeNodeList() {
            _classCallCheck(this, KeyframeNodeList), this._nodes = [];
        }
        return _createClass(KeyframeNodeList, [ {
            key: "getNodeByIndex",
            value: function(e) {
                return this._nodes[e];
            }
        }, {
            key: "setNodeByIndex",
            value: function(e, t) {
                this._nodes[e] = t;
            }
        }, {
            key: "count",
            get: function() {
                return this._nodes.length;
            },
            set: function(e) {
                this._nodes.length = e;
            }
        } ]), KeyframeNodeList;
    }(), j = function(e) {
        function AnimationClip() {
            var e;
            return _classCallCheck(this, AnimationClip), (e = _possibleConstructorReturn(this, _getPrototypeOf(AnimationClip).call(this)))._nodes = new Y(), 
            e._animationEvents = [], e;
        }
        return _inherits(AnimationClip, t.Resource), _createClass(AnimationClip, [ {
            key: "duration",
            value: function() {
                return this._duration;
            }
        }, {
            key: "_hermiteInterpolate",
            value: function(e, t, n, r) {
                var i = e.outTangent, a = t.inTangent;
                if (Number.isFinite(i) && Number.isFinite(a)) {
                    var o = n * n, s = o * n, l = s - 2 * o + n, u = s - o, c = -2 * s + 3 * o;
                    return (2 * s - 3 * o + 1) * e.value + l * i * r + u * a * r + c * t.value;
                }
                return e.value;
            }
        }, {
            key: "_hermiteInterpolateVector3",
            value: function(e, t, n, r, i) {
                var a = e.value, o = e.outTangent, s = t.value, l = t.inTangent, u = n * n, c = u * n, h = 2 * c - 3 * u + 1, _ = c - 2 * u + n, d = c - u, f = -2 * c + 3 * u, m = o.x, T = l.x;
                Number.isFinite(m) && Number.isFinite(T) ? i.x = h * a.x + _ * m * r + d * T * r + f * s.x : i.x = a.x, 
                m = o.y, T = l.y, Number.isFinite(m) && Number.isFinite(T) ? i.y = h * a.y + _ * m * r + d * T * r + f * s.y : i.y = a.y, 
                m = o.z, T = l.z, Number.isFinite(m) && Number.isFinite(T) ? i.z = h * a.z + _ * m * r + d * T * r + f * s.z : i.z = a.z;
            }
        }, {
            key: "_hermiteInterpolateQuaternion",
            value: function(e, t, n, r, i) {
                var a = e.value, o = e.outTangent, s = t.value, l = t.inTangent, u = n * n, c = u * n, h = 2 * c - 3 * u + 1, _ = c - 2 * u + n, d = c - u, f = -2 * c + 3 * u, m = o.x, T = l.x;
                Number.isFinite(m) && Number.isFinite(T) ? i.x = h * a.x + _ * m * r + d * T * r + f * s.x : i.x = a.x, 
                m = o.y, T = l.y, Number.isFinite(m) && Number.isFinite(T) ? i.y = h * a.y + _ * m * r + d * T * r + f * s.y : i.y = a.y, 
                m = o.z, T = l.z, Number.isFinite(m) && Number.isFinite(T) ? i.z = h * a.z + _ * m * r + d * T * r + f * s.z : i.z = a.z, 
                m = o.w, T = l.w, Number.isFinite(m) && Number.isFinite(T) ? i.w = h * a.w + _ * m * r + d * T * r + f * s.w : i.w = a.w;
            }
        }, {
            key: "_evaluateClipDatasRealTime",
            value: function(e, t, n, r, i, a) {
                for (var o = 0, s = e.count; o < s; o++) {
                    var l, c = e.getNodeByIndex(o), h = c.type, _ = c._keyFrames, d = _.length, f = n[o];
                    if (i) for (-1 !== f && t < _[f].time && (f = -1, n[o] = f), l = f + 1; l < d && !(_[l].time > t); ) f++, 
                    l++, n[o] = f; else for ((l = f + 1) !== d && t > _[l].time && (f = d - 1, n[o] = f), 
                    l = f + 1; f > -1 && !(_[f].time < t); ) f--, l--, n[o] = f;
                    var m = l === d;
                    switch (h) {
                      case 0:
                        if (-1 !== f) {
                            var T = _[f];
                            if (m) a[o] = T.value; else {
                                var p, g = _[l], E = g.time - T.time;
                                p = 0 !== E ? (t - T.time) / E : 0, a[o] = this._hermiteInterpolate(T, g, p, E);
                            }
                        } else a[o] = _[0].value;
                        r && (a[o] = a[o] - _[0].value);
                        break;

                      case 1:
                      case 4:
                        var y = a[o];
                        if (this._evaluateFrameNodeVector3DatasRealTime(_, f, m, t, y), r) {
                            var v = _[0].value;
                            y.x -= v.x, y.y -= v.y, y.z -= v.z;
                        }
                        break;

                      case 2:
                        var S = a[o];
                        if (this._evaluateFrameNodeQuaternionDatasRealTime(_, f, m, t, S), r) {
                            var C = AnimationClip._tempQuaternion0, R = _[0].value;
                            O.quaternionConjugate(R, C), u.multiply(C, S, S);
                        }
                        break;

                      case 3:
                        y = a[o], this._evaluateFrameNodeVector3DatasRealTime(_, f, m, t, y), r && (v = _[0].value, 
                        y.x /= v.x, y.y /= v.y, y.z /= v.z);
                        break;

                      default:
                        throw "AnimationClip:unknown node type.";
                    }
                }
            }
        }, {
            key: "_evaluateClipDatasRealTimeForNative",
            value: function(e, n, r, i) {
                t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, n, r, i);
            }
        }, {
            key: "_evaluateFrameNodeVector3DatasRealTime",
            value: function(e, t, n, r, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (n) {
                        var o = a.value;
                        i.x = o.x, i.y = o.y, i.z = o.z;
                    } else {
                        var s, l = e[t + 1], u = a.time, c = l.time - u;
                        s = 0 !== c ? (r - u) / c : 0, this._hermiteInterpolateVector3(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x, i.y = h.y, i.z = h.z;
                }
            }
        }, {
            key: "_evaluateFrameNodeQuaternionDatasRealTime",
            value: function(e, t, n, r, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (n) {
                        var o = a.value;
                        i.x = o.x, i.y = o.y, i.z = o.z, i.w = o.w;
                    } else {
                        var s, l = e[t + 1], u = a.time, c = l.time - u;
                        s = 0 !== c ? (r - u) / c : 0, this._hermiteInterpolateQuaternion(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x, i.y = h.y, i.z = h.z, i.w = h.w;
                }
            }
        }, {
            key: "_binarySearchEventIndex",
            value: function(e) {
                for (var t, n = 0, r = this._animationEvents.length - 1; n <= r; ) {
                    t = Math.floor((n + r) / 2);
                    var i = this._animationEvents[t].time;
                    if (i == e) return t;
                    i > e ? r = t - 1 : n = t + 1;
                }
                return n;
            }
        }, {
            key: "addEvent",
            value: function(e) {
                var t = this._binarySearchEventIndex(e.time);
                this._animationEvents.splice(t, 0, e);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._nodes = null, this._nodesMap = null;
            }
        } ], [ {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var n = new AnimationClip(), r = new t.Byte(e), i = r.readUTFString();
                switch (i) {
                  case "LAYAANIMATION:03":
                    z.parse(n, r);
                    break;

                  case "LAYAANIMATION:04":
                  case "LAYAANIMATION:COMPRESSION_04":
                    X.parse(n, r, i);
                    break;

                  default:
                    throw "unknown animationClip version.";
                }
                return n;
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.ILaya.loader.create(e, n, null, AnimationClip.ANIMATIONCLIP);
            }
        } ]), AnimationClip;
    }();
    j.ANIMATIONCLIP = "ANIMATIONCLIP", j._tempQuaternion0 = new u();
    var Z = function() {
        function AnimatorPlayState() {
            _classCallCheck(this, AnimatorPlayState), this._currentState = null;
        }
        return _createClass(AnimatorPlayState, [ {
            key: "_resetPlayState",
            value: function(e) {
                this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0, 
                this._lastIsFront = !0;
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime, 
                e._normalizedTime = this._normalizedTime, e._normalizedPlayTime = this._normalizedPlayTime, 
                e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
            }
        }, {
            key: "normalizedTime",
            get: function() {
                return this._normalizedTime;
            }
        }, {
            key: "duration",
            get: function() {
                return this._duration;
            }
        }, {
            key: "animatorState",
            get: function() {
                return this._currentState;
            }
        } ]), AnimatorPlayState;
    }(), Q = function() {
        function AnimatorControllerLayer(e) {
            _classCallCheck(this, AnimatorControllerLayer), this._defaultState = null, this._referenceCount = 0, 
            this._playType = -1, this._crossDuration = -1, this._crossMark = 0, this._crossNodesOwnersCount = 0, 
            this._crossNodesOwners = [], this._crossNodesOwnersIndicesMap = {}, this._srcCrossClipNodeIndices = [], 
            this._destCrossClipNodeIndices = [], this._statesMap = {}, this._states = [], this._playStateInfo = new Z(), 
            this._crossPlayStateInfo = new Z(), this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE, 
            this.defaultWeight = 1, this.playOnWake = !0, this.name = e;
        }
        return _createClass(AnimatorControllerLayer, [ {
            key: "_removeClip",
            value: function(e, t, n, r) {
                var i = r._clip, a = e[n];
                if (e.splice(n, 1), delete t[r.name], this._animator) {
                    var o = i._nodes, s = a._nodeOwners;
                    i._removeReference();
                    for (var l = 0, u = o.count; l < u; l++) this._animator._removeKeyframeNodeOwner(s, o.getNodeByIndex(l));
                }
            }
        }, {
            key: "_getReferenceCount",
            value: function() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, n = this._states.length; t < n; t++) this._states[t]._addReference(e);
                this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, n = this._states.length; t < n; t++) this._states[t]._removeReference(e);
                this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "getCurrentPlayState",
            value: function() {
                return this._playStateInfo;
            }
        }, {
            key: "getAnimatorState",
            value: function(e) {
                var t = this._statesMap[e];
                return t || null;
            }
        }, {
            key: "addState",
            value: function(e) {
                var t = e.name;
                if (this._statesMap[t]) throw "AnimatorControllerLayer:this stat's name has exist.";
                this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip._addReference(), 
                this._animator._getOwnersByClip(e));
            }
        }, {
            key: "removeState",
            value: function(e) {
                for (var t = this._states, n = -1, r = 0, i = t.length; r < i; r++) if (t[r] === e) {
                    n = r;
                    break;
                }
                -1 !== n && this._removeClip(t, this._statesMap, n, e);
            }
        }, {
            key: "destroy",
            value: function() {
                this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null, 
                this._crossPlayStateInfo = null, this._defaultState = null;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight, 
                t.playOnWake = this.playOnWake;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimatorControllerLayer(this.name);
                return this.cloneTo(e), e;
            }
        }, {
            key: "defaultState",
            get: function() {
                return this._defaultState;
            },
            set: function(e) {
                this._defaultState = e, this._statesMap[e.name] = e;
            }
        } ]), AnimatorControllerLayer;
    }();
    Q.BLENDINGMODE_OVERRIDE = 0, Q.BLENDINGMODE_ADDTIVE = 1;
    var q = function() {
        function ConchVector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, ConchVector4);
            var i = this.elements = new Float32Array(4);
            i[0] = e, i[1] = t, i[2] = n, i[3] = r;
        }
        return _createClass(ConchVector4, [ {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2], 
                this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements, n = this.elements;
                t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        } ], [ {
            key: "lerp",
            value: function(e, t, n, r) {
                var i = r.elements, a = e.elements, o = t.elements, s = a[0], l = a[1], u = a[2], c = a[3];
                i[0] = s + n * (o[0] - s), i[1] = l + n * (o[1] - l), i[2] = u + n * (o[2] - u), 
                i[3] = c + n * (o[3] - c);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, n) {
                var r = e.elements, i = r[0], a = r[1], o = r[2], s = r[3], l = t.elements, u = n.elements;
                u[0] = i * l[0] + a * l[4] + o * l[8] + s * l[12], u[1] = i * l[1] + a * l[5] + o * l[9] + s * l[13], 
                u[2] = i * l[2] + a * l[6] + o * l[10] + s * l[14], u[3] = i * l[3] + a * l[7] + o * l[11] + s * l[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var r = e.elements, i = t.elements;
                return n.nearEqual(Math.abs(r[0]), Math.abs(i[0])) && n.nearEqual(Math.abs(r[1]), Math.abs(i[1])) && n.nearEqual(Math.abs(r[2]), Math.abs(i[2])) && n.nearEqual(Math.abs(r[3]), Math.abs(i[3]));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = e.length();
                i > 0 && (r[0] = n[0] * i, r[1] = n[1] * i, r[2] = n[2] * i, r[3] = n[3] * i);
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] + a[0], r[1] = i[1] + a[1], r[2] = i[2] + a[2], r[3] = i[3] + a[3];
            }
        }, {
            key: "subtract",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] - a[0], r[1] = i[1] - a[1], r[2] = i[2] - a[2], r[3] = i[3] - a[3];
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] * a[0], r[1] = i[1] * a[1], r[2] = i[2] * a[2], r[3] = i[3] * a[3];
            }
        }, {
            key: "scale",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements;
                r[0] = i[0] * t, r[1] = i[1] * t, r[2] = i[2] * t, r[3] = i[3] * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, n, r) {
                var i = e.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = t.elements, c = u[0], h = u[1], _ = u[2], d = u[3], f = n.elements, m = f[0], T = f[1], p = f[2], g = f[3], E = r.elements;
                a = (a = a > m ? m : a) < c ? c : a, o = (o = o > T ? T : o) < h ? h : o, s = (s = s > p ? p : s) < _ ? _ : s, 
                l = (l = l > g ? g : l) < d ? d : l, E[0] = a, E[1] = o, E[2] = s, E[3] = l;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = n[0] - r[0], a = n[1] - r[1], o = n[2] - r[2], s = n[3] - r[3];
                return i * i + a * a + o * o + s * s;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = n[0] - r[0], a = n[1] - r[1], o = n[2] - r[2], s = n[3] - r[3];
                return Math.sqrt(i * i + a * a + o * o + s * s);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var n = e.elements, r = t.elements;
                return n[0] * r[0] + n[1] * r[1] + n[2] * r[2] + n[3] * r[3];
            }
        }, {
            key: "min",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = Math.min(i[0], a[0]), r[1] = Math.min(i[1], a[1]), r[2] = Math.min(i[2], a[2]), 
                r[3] = Math.min(i[3], a[3]);
            }
        }, {
            key: "max",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = Math.max(i[0], a[0]), r[1] = Math.max(i[1], a[1]), r[2] = Math.max(i[2], a[2]), 
                r[3] = Math.max(i[3], a[3]);
            }
        } ]), ConchVector4;
    }();
    q.ZERO = new q(), q.ONE = new q(1, 1, 1, 1), q.UnitX = new q(1, 0, 0, 0), q.UnitY = new q(0, 1, 0, 0), 
    q.UnitZ = new q(0, 0, 1, 0), q.UnitW = new q(0, 0, 0, 1);
    var K = function() {
        function ConchVector3() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            _classCallCheck(this, ConchVector3), e = i || new Float32Array(3), this.elements = e, 
            e[0] = t, e[1] = n, e[2] = r;
        }
        return _createClass(ConchVector3, [ {
            key: "setValue",
            value: function(e, t, n) {
                this.elements[0] = e, this.elements[1] = t, this.elements[2] = n;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements, n = this.elements;
                t[0] = n[0], t[1] = n[1], t[2] = n[2];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector3();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        } ], [ {
            key: "distanceSquared",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = n[0] - r[0], a = n[1] - r[1], o = n[2] - r[2];
                return i * i + a * a + o * o;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = n[0] - r[0], a = n[1] - r[1], o = n[2] - r[2];
                return Math.sqrt(i * i + a * a + o * o);
            }
        }, {
            key: "min",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = Math.min(i[0], a[0]), r[1] = Math.min(i[1], a[1]), r[2] = Math.min(i[2], a[2]);
            }
        }, {
            key: "max",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = Math.max(i[0], a[0]), r[1] = Math.max(i[1], a[1]), r[2] = Math.max(i[2], a[2]);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements, o = i[0], s = i[1], l = i[2], u = a[0], c = a[1], h = a[2], _ = a[3], d = _ * o + c * l - h * s, f = _ * s + h * o - u * l, m = _ * l + u * s - c * o, T = -u * o - c * s - h * l;
                r[0] = d * _ + T * -u + f * -h - m * -c, r[1] = f * _ + T * -c + m * -u - d * -h, 
                r[2] = m * _ + T * -h + d * -c - f * -u;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.elements, n = t[0], r = t[1], i = t[2];
                return Math.sqrt(n * n + r * r + i * i);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.elements, n = t[0], r = t[1], i = t[2];
                return n * n + r * r + i * i;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var n = e.elements, r = t.elements, i = n[0], a = n[1], o = n[2], s = i * i + a * a + o * o;
                s > 0 && (s = 1 / Math.sqrt(s), r[0] = n[0] * s, r[1] = n[1] * s, r[2] = n[2] * s);
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] * a[0], r[1] = i[1] * a[1], r[2] = i[2] * a[2];
            }
        }, {
            key: "scale",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements;
                r[0] = i[0] * t, r[1] = i[1] * t, r[2] = i[2] * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, n, r) {
                var i = r.elements, a = e.elements, o = t.elements, s = a[0], l = a[1], u = a[2];
                i[0] = s + n * (o[0] - s), i[1] = l + n * (o[1] - l), i[2] = u + n * (o[2] - u);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, n) {
                var r = ConchVector3._tempVector4;
                ConchVector3.transformV3ToV4(e, t, r);
                var i = r.elements, a = n.elements;
                a[0] = i[0], a[1] = i[1], a[2] = i[2];
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, n) {
                var r = e.elements, i = r[0], a = r[1], o = r[2], s = t.elements, l = n.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8] + s[12], l[1] = i * s[1] + a * s[5] + o * s[9] + s[13], 
                l[2] = i * s[2] + a * s[6] + o * s[10] + s[14], l[3] = i * s[3] + a * s[7] + o * s[11] + s[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, n) {
                var r = e.elements, i = r[0], a = r[1], o = r[2], s = t.elements, l = n.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8], l[1] = i * s[1] + a * s[5] + o * s[9], l[2] = i * s[2] + a * s[6] + o * s[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, n) {
                var r = e.elements, i = r[0], a = r[1], o = r[2], s = t.elements, l = i * s[3] + a * s[7] + o * s[11] + s[15], u = n.elements;
                u[0] = i * s[0] + a * s[4] + o * s[8] + s[12] / l, u[1] = i * s[1] + a * s[5] + o * s[9] + s[13] / l, 
                u[2] = i * s[2] + a * s[6] + o * s[10] + s[14] / l;
            }
        }, {
            key: "Clamp",
            value: function(e, t, n, r) {
                var i = e.elements, a = i[0], o = i[1], s = i[2], l = t.elements, u = l[0], c = l[1], h = l[2], _ = n.elements, d = _[0], f = _[1], m = _[2], T = r.elements;
                a = (a = a > d ? d : a) < u ? u : a, o = (o = o > f ? f : o) < c ? c : o, s = (s = s > m ? m : s) < h ? h : s, 
                T[0] = a, T[1] = o, T[2] = s;
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] + a[0], r[1] = i[1] + a[1], r[2] = i[2] + a[2];
            }
        }, {
            key: "subtract",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] - a[0], r[1] = i[1] - a[1], r[2] = i[2] - a[2];
            }
        }, {
            key: "cross",
            value: function(e, t, n) {
                var r = e.elements, i = t.elements, a = n.elements, o = r[0], s = r[1], l = r[2], u = i[0], c = i[1], h = i[2];
                a[0] = s * h - l * c, a[1] = l * u - o * h, a[2] = o * c - s * u;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var n = e.elements, r = t.elements;
                return n[0] * r[0] + n[1] * r[1] + n[2] * r[2];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var r = e.elements, i = t.elements;
                return n.nearEqual(r[0], i[0]) && n.nearEqual(r[1], i[1]) && n.nearEqual(r[2], i[2]);
            }
        } ]), ConchVector3;
    }();
    K._tempVector4 = new q(), K.ZERO = new K(0, 0, 0), K.ONE = new K(1, 1, 1), K.NegativeUnitX = new K(-1, 0, 0), 
    K.UnitX = new K(1, 0, 0), K.UnitY = new K(0, 1, 0), K.UnitZ = new K(0, 0, 1), K.ForwardRH = new K(0, 0, -1), 
    K.ForwardLH = new K(0, 0, 1), K.Up = new K(0, 1, 0), K.NAN = new K(NaN, NaN, NaN);
    var J = function() {
        function ConchQuaternion() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            _classCallCheck(this, ConchQuaternion), (e = a || new Float32Array(4))[0] = t, e[1] = n, 
            e[2] = r, e[3] = i, this.elements = e;
        }
        return _createClass(ConchQuaternion, [ {
            key: "scaling",
            value: function(e, t) {
                var n = t.elements, r = this.elements;
                n[0] = r[0] * e, n[1] = r[1] * e, n[2] = r[2] * e, n[3] = r[3] * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                ConchQuaternion._normalizeArray(this.elements, e.elements);
            }
        }, {
            key: "length",
            value: function() {
                var e = this.elements, t = e[0], n = e[1], r = e[2], i = e[3];
                return Math.sqrt(t * t + n * n + r * r + i * i);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                var n = t.elements, r = this.elements;
                e *= .5;
                var i = r[0], a = r[1], o = r[2], s = r[3], l = Math.sin(e), u = Math.cos(e);
                n[0] = i * u + s * l, n[1] = a * u + o * l, n[2] = o * u - a * l, n[3] = s * u - i * l;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                var n = t.elements, r = this.elements;
                e *= .5;
                var i = r[0], a = r[1], o = r[2], s = r[3], l = Math.sin(e), u = Math.cos(e);
                n[0] = i * u - o * l, n[1] = a * u + s * l, n[2] = o * u + i * l, n[3] = s * u - a * l;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                var n = t.elements, r = this.elements;
                e *= .5;
                var i = r[0], a = r[1], o = r[2], s = r[3], l = Math.sin(e), u = Math.cos(e);
                n[0] = i * u + a * l, n[1] = a * u - i * l, n[2] = o * u + s * l, n[3] = s * u - o * l;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                K.transformQuat(K.ForwardRH, this, ConchQuaternion.TEMPVector31), K.transformQuat(K.Up, this, ConchQuaternion.TEMPVector32);
                var t = ConchQuaternion.TEMPVector32.elements;
                ConchQuaternion.angleTo(K.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33);
                var n = ConchQuaternion.TEMPVector33.elements;
                n[0] == Math.PI / 2 ? (n[1] = ConchQuaternion.arcTanAngle(t[2], t[0]), n[2] = 0) : n[0] == -Math.PI / 2 ? (n[1] = ConchQuaternion.arcTanAngle(-t[2], -t[0]), 
                n[2] = 0) : (c.createRotationY(-n[1], ConchQuaternion.TEMPMatrix0), c.createRotationX(-n[0], ConchQuaternion.TEMPMatrix1), 
                K.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32), 
                K.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32), 
                n[2] = ConchQuaternion.arcTanAngle(t[1], -t[0])), n[1] <= -Math.PI && (n[1] = Math.PI), 
                n[2] <= -Math.PI && (n[2] = Math.PI), n[1] >= Math.PI && n[2] >= Math.PI && (n[1] = 0, 
                n[2] = 0, n[0] = Math.PI - n[0]);
                var r = e.elements;
                r[0] = n[1], r[1] = n[0], r[2] = n[2];
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = e.elements, n = this.elements, r = n[0], i = n[1], a = n[2], o = n[3], s = r * r + i * i + a * a + o * o, l = s ? 1 / s : 0;
                t[0] = -r * l, t[1] = -i * l, t[2] = -a * l, t[3] = o * l;
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2], 
                this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, n, r;
                if ((n = this.elements) !== (r = e.elements)) for (t = 0; t < 4; ++t) r[t] = n[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchQuaternion();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function(e) {
                var t = this.elements, r = e.elements;
                return n.nearEqual(t[0], r[0]) && n.nearEqual(t[1], r[1]) && n.nearEqual(t[2], r[2]) && n.nearEqual(t[3], r[3]);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                var e = this.elements[0], t = this.elements[1], n = this.elements[2], r = this.elements[3];
                return e * e + t * t + n * n + r * r;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        } ], [ {
            key: "_dotArray",
            value: function(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
            }
        }, {
            key: "_normalizeArray",
            value: function(e, t) {
                var n = e[0], r = e[1], i = e[2], a = e[3], o = n * n + r * r + i * i + a * a;
                o > 0 && (o = 1 / Math.sqrt(o), t[0] = n * o, t[1] = r * o, t[2] = i * o, t[3] = a * o);
            }
        }, {
            key: "_lerpArray",
            value: function(e, t, n, r) {
                var i = 1 - n;
                ConchQuaternion._dotArray(e, t) >= 0 ? (r[0] = i * e[0] + n * t[0], r[1] = i * e[1] + n * t[1], 
                r[2] = i * e[2] + n * t[2], r[3] = i * e[3] + n * t[3]) : (r[0] = i * e[0] - n * t[0], 
                r[1] = i * e[1] - n * t[1], r[2] = i * e[2] - n * t[2], r[3] = i * e[3] - n * t[3]), 
                ConchQuaternion._normalizeArray(r, r);
            }
        }, {
            key: "createFromYawPitchRoll",
            value: function(e, t, n, r) {
                var i = .5 * n, a = .5 * t, o = .5 * e, s = Math.sin(i), l = Math.cos(i), u = Math.sin(a), c = Math.cos(a), h = Math.sin(o), _ = Math.cos(o), d = r.elements;
                d[0] = _ * u * l + h * c * s, d[1] = h * c * l - _ * u * s, d[2] = _ * c * s - h * u * l, 
                d[3] = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, n) {
                var r = e.elements, i = t.elements, a = n.elements, o = r[0], s = r[1], l = r[2], u = r[3], c = i[0], h = i[1], _ = i[2], d = i[3], f = s * _ - l * h, m = l * c - o * _, T = o * h - s * c, p = o * c + s * h + l * _;
                a[0] = o * d + c * u + f, a[1] = s * d + h * u + m, a[2] = l * d + _ * u + T, a[3] = u * d - p;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, n) {
                K.subtract(t, e, ConchQuaternion.TEMPVector30), K.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30), 
                n.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y), n.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements;
                t *= .5;
                var a = Math.sin(t);
                r[0] = a * i[0], r[1] = a * i[1], r[2] = a * i[2], r[3] = Math.cos(t);
            }
        }, {
            key: "createFromMatrix3x3",
            value: function(e, t) {
                var n, r = t.elements, i = e.elements, a = i[0] + i[4] + i[8];
                if (a > 0) n = Math.sqrt(a + 1), r[3] = .5 * n, n = .5 / n, r[0] = (i[5] - i[7]) * n, 
                r[1] = (i[6] - i[2]) * n, r[2] = (i[1] - i[3]) * n; else {
                    var o = 0;
                    i[4] > i[0] && (o = 1), i[8] > i[3 * o + o] && (o = 2);
                    var s = (o + 1) % 3, l = (o + 2) % 3;
                    n = Math.sqrt(i[3 * o + o] - i[3 * s + s] - i[3 * l + l] + 1), r[o] = .5 * n, n = .5 / n, 
                    r[3] = (i[3 * s + l] - i[3 * l + s]) * n, r[s] = (i[3 * s + o] + i[3 * o + s]) * n, 
                    r[l] = (i[3 * l + o] + i[3 * o + l]) * n;
                }
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var n, r, i = e.elements, a = t.elements, o = i[0] + i[5] + i[10];
                o > 0 ? (n = Math.sqrt(o + 1), a[3] = .5 * n, n = .5 / n, a[0] = (i[6] - i[9]) * n, 
                a[1] = (i[8] - i[2]) * n, a[2] = (i[1] - i[4]) * n) : i[0] >= i[5] && i[0] >= i[10] ? (r = .5 / (n = Math.sqrt(1 + i[0] - i[5] - i[10])), 
                a[0] = .5 * n, a[1] = (i[1] + i[4]) * r, a[2] = (i[2] + i[8]) * r, a[3] = (i[6] - i[9]) * r) : i[5] > i[10] ? (r = .5 / (n = Math.sqrt(1 + i[5] - i[0] - i[10])), 
                a[0] = (i[4] + i[1]) * r, a[1] = .5 * n, a[2] = (i[9] + i[6]) * r, a[3] = (i[8] - i[2]) * r) : (r = .5 / (n = Math.sqrt(1 + i[10] - i[0] - i[5])), 
                a[0] = (i[8] + i[2]) * r, a[1] = (i[9] + i[6]) * r, a[2] = .5 * n, a[3] = (i[1] - i[4]) * r);
            }
        }, {
            key: "slerp",
            value: function(e, t, n, r) {
                var i, a, o, s, l, u = e.elements, c = t.elements, h = r.elements, _ = u[0], d = u[1], f = u[2], m = u[3], T = c[0], p = c[1], g = c[2], E = c[3];
                return (a = _ * T + d * p + f * g + m * E) < 0 && (a = -a, T = -T, p = -p, g = -g, 
                E = -E), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math.sin((1 - n) * i) / o, 
                l = Math.sin(n * i) / o) : (s = 1 - n, l = n), h[0] = s * _ + l * T, h[1] = s * d + l * p, 
                h[2] = s * f + l * g, h[3] = s * m + l * E, h;
            }
        }, {
            key: "lerp",
            value: function(e, t, n, r) {
                ConchQuaternion._lerpArray(e.elements, t.elements, n, r.elements);
            }
        }, {
            key: "add",
            value: function(e, t, n) {
                var r = n.elements, i = e.elements, a = t.elements;
                r[0] = i[0] + a[0], r[1] = i[1] + a[1], r[2] = i[2] + a[2], r[3] = i[3] + a[3];
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return ConchQuaternion._dotArray(e.elements, t.elements);
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, n) {
                ConchQuaternion.lookAt(K.ZERO, e, t, n);
            }
        }, {
            key: "lookAt",
            value: function(e, t, n, r) {
                s.lookAt(e, t, n, ConchQuaternion._tempMatrix3x3), ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, r);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var r = e.elements, i = t.elements, a = e.lengthSquared();
                n.isZero(a) || (a = 1 / a, i[0] = -r[0] * a, i[1] = -r[1] * a, i[2] = -r[2] * a, 
                i[3] = r[3] * a);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var n, r, i = e.elements, a = i[0], o = i[1], s = i[2], l = i[3], u = i[4], c = i[5], h = i[6], _ = i[7], d = i[8], f = t.elements, m = a + u + d;
                m > 0 ? (n = Math.sqrt(m + 1), f[3] = .5 * n, n = .5 / n, f[0] = (c - _) * n, f[1] = (h - s) * n, 
                f[2] = (o - l) * n) : a >= u && a >= d ? (r = .5 / (n = Math.sqrt(1 + a - u - d)), 
                f[0] = .5 * n, f[1] = (o + l) * r, f[2] = (s + h) * r, f[3] = (c - _) * r) : u > d ? (r = .5 / (n = Math.sqrt(1 + u - a - d)), 
                f[0] = (l + o) * r, f[1] = .5 * n, f[2] = (_ + c) * r, f[3] = (h - s) * r) : (r = .5 / (n = Math.sqrt(1 + d - a - u)), 
                f[0] = (h + s) * r, f[1] = (_ + c) * r, f[2] = .5 * n, f[3] = (o - l) * r);
            }
        } ]), ConchQuaternion;
    }();
    J.TEMPVector30 = new K(), J.TEMPVector31 = new K(), J.TEMPVector32 = new K(), J.TEMPVector33 = new K(), 
    J.TEMPMatrix0 = new c(), J.TEMPMatrix1 = new c(), J._tempMatrix3x3 = new s(), J.DEFAULT = new J(), 
    J.NAN = new J(NaN, NaN, NaN, NaN);
    var $ = function() {
        function AnimatorState() {
            _classCallCheck(this, AnimatorState), this._referenceCount = 0, this._clip = null, 
            this._nodeOwners = [], this._currentFrameIndices = null, this._realtimeDatas = [], 
            this._scripts = null, this.speed = 1, this.clipStart = 0, this.clipEnd = 1;
        }
        return _createClass(AnimatorState, [ {
            key: "_getReferenceCount",
            value: function() {
                return this._referenceCount;
            }
        }, {
            key: "_addReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                this._clip && this._clip._addReference(e), this._referenceCount += e;
            }
        }, {
            key: "_removeReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                this._clip && this._clip._removeReference(e), this._referenceCount -= e;
            }
        }, {
            key: "_clearReference",
            value: function() {
                this._removeReference(-this._referenceCount);
            }
        }, {
            key: "_resetFrameIndices",
            value: function() {
                for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this._currentFrameIndices[e] = -1;
            }
        }, {
            key: "addScript",
            value: function(e) {
                var t = new e();
                return this._scripts = this._scripts || [], this._scripts.push(t), t;
            }
        }, {
            key: "getScript",
            value: function(e) {
                if (this._scripts) for (var t = 0, n = this._scripts.length; t < n; t++) {
                    var r = this._scripts[t];
                    if (r instanceof e) return r;
                }
                return null;
            }
        }, {
            key: "getScripts",
            value: function(e) {
                var t;
                if (this._scripts) for (var n = 0, r = this._scripts.length; n < r; n++) {
                    var i = this._scripts[n];
                    i instanceof e && (t = t || []).push(i);
                }
                return t;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd, 
                t.clip = this._clip;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimatorState();
                return this.cloneTo(e), e;
            }
        }, {
            key: "clip",
            get: function() {
                return this._clip;
            },
            set: function(e) {
                if (this._clip !== e) {
                    if (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount), 
                    e) {
                        var n = this._realtimeDatas, r = e._nodes, i = r.count;
                        this._currentFrameIndices = new Int16Array(i), this._resetFrameIndices(), this._referenceCount > 0 && e._addReference(this._referenceCount), 
                        this._realtimeDatas.length = i;
                        for (var a = 0; a < i; a++) switch (r.getNodeByIndex(a).type) {
                          case 0:
                            break;

                          case 1:
                          case 3:
                          case 4:
                            n[a] = t.Render.supportWebGLPlusAnimation ? new K() : new o();
                            break;

                          case 2:
                            n[a] = t.Render.supportWebGLPlusAnimation ? new J() : new u();
                            break;

                          default:
                            throw "AnimationClipParser04:unknown type.";
                        }
                    }
                    this._clip = e;
                }
            }
        } ]), AnimatorState;
    }(), ee = function() {
        function KeyframeNodeOwner() {
            _classCallCheck(this, KeyframeNodeOwner), this.indexInList = -1, this.referenceCount = 0, 
            this.updateMark = -1, this.type = -1, this.fullPath = null, this.propertyOwner = null, 
            this.property = null, this.defaultValue = null, this.value = null, this.crossFixedValue = null;
        }
        return _createClass(KeyframeNodeOwner, [ {
            key: "saveCrossFixedValue",
            value: function() {
                if (this.propertyOwner) switch (this.type) {
                  case 0:
                    this.crossFixedValue = this.value;
                    break;

                  case 1:
                  case 3:
                  case 4:
                  case 2:
                    this.value.cloneTo(this.crossFixedValue);
                    break;

                  default:
                    throw "Animator:unknown type.";
                }
            }
        } ]), KeyframeNodeOwner;
    }(), te = function(e) {
        function Animator() {
            var e;
            return _classCallCheck(this, Animator), (e = _possibleConstructorReturn(this, _getPrototypeOf(Animator).call(this)))._keyframeNodeOwners = [], 
            e._linkAvatarSpritesData = {}, e._linkAvatarSprites = [], e._renderableSprites = [], 
            e.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY, e._controllerLayers = [], e._linkSprites = {}, 
            e._speed = 1, e._keyframeNodeOwnerMap = {}, e._updateMark = 0, e;
        }
        return _inherits(Animator, t.Component), _createClass(Animator, [ {
            key: "_linkToSprites",
            value: function(e) {
                for (var t in e) {
                    for (var n = this.owner, r = e[t], i = 0, a = r.length; i < a; i++) {
                        var o = r[i];
                        if ("" === o) break;
                        if (!(n = n.getChildByName(o))) break;
                    }
                    n && this.linkSprite3DToAvatarNode(t, n);
                }
            }
        }, {
            key: "_addKeyframeNodeOwner",
            value: function(e, t, n) {
                var r = t._indexInList, i = t.fullPath, a = this._keyframeNodeOwnerMap[i];
                if (a) a.referenceCount++, e[r] = a; else {
                    for (var o = n, s = 0, l = t.propertyCount; s < l && (o = o[t.getPropertyByIndex(s)]); s++) ;
                    (a = this._keyframeNodeOwnerMap[i] = new ee()).fullPath = i, a.indexInList = this._keyframeNodeOwners.length, 
                    a.referenceCount = 1, a.propertyOwner = n;
                    var u = t.propertyCount, c = [];
                    for (s = 0; s < u; s++) c[s] = t.getPropertyByIndex(s);
                    if (a.property = c, a.type = t.type, o) if (0 === t.type) a.defaultValue = o; else {
                        var h = new o.constructor();
                        o.cloneTo(h), a.defaultValue = h, a.value = new o.constructor(), a.crossFixedValue = new o.constructor();
                    }
                    this._keyframeNodeOwners.push(a), e[r] = a;
                }
            }
        }, {
            key: "_removeKeyframeNodeOwner",
            value: function(e, t) {
                var n = t.fullPath, r = this._keyframeNodeOwnerMap[n];
                r && (r.referenceCount--, 0 === r.referenceCount && (delete this._keyframeNodeOwnerMap[n], 
                this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(r), 1)), e[t._indexInList] = null);
            }
        }, {
            key: "_getOwnersByClip",
            value: function(e) {
                var t = e._clip._nodes, n = t.count, r = e._nodeOwners;
                r.length = n;
                for (var i = 0; i < n; i++) {
                    for (var a = t.getNodeByIndex(i), o = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, s = 0, l = a.ownerPathCount; s < l; s++) {
                        var u = a.getOwnerPathByIndex(s);
                        if ("" === u) break;
                        if (!(o = o.getChildByName(u))) break;
                    }
                    if (o) {
                        var c = a.propertyOwner;
                        c && (o = o[c]), o && this._addKeyframeNodeOwner(r, a, o);
                    }
                }
            }
        }, {
            key: "_updatePlayer",
            value: function(e, t, n, r) {
                var i = e._clip._duration * (e.clipEnd - e.clipStart), a = t._elapsedTime, o = a + n;
                t._lastElapsedTime = a, t._elapsedTime = o;
                var s = o / i;
                t._normalizedTime = s;
                var l = s % 1;
                t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = i;
                var u = e._scripts;
                if (!r && o >= i) {
                    if (t._finish = !0, t._elapsedTime = i, t._normalizedPlayTime = 1, u) for (var c = 0, h = u.length; c < h; c++) u[c].onStateExit();
                } else if (u) for (c = 0, h = u.length; c < h; c++) u[c].onStateUpdate();
            }
        }, {
            key: "_eventScript",
            value: function(e, t, n, r, i) {
                if (i) for (var a = t.length; n < a; n++) {
                    var o = t[n];
                    if (!(o.time <= r)) break;
                    for (var s = 0, l = e.length; s < l; s++) {
                        var u = e[s], c = u[o.eventName];
                        c && c.apply(u, o.params);
                    }
                } else for (;n >= 0 && (o = t[n]).time >= r; n--) for (s = 0, l = e.length; s < l; s++) (c = (u = e[s])[o.eventName]) && c.apply(u, o.params);
                return n;
            }
        }, {
            key: "_updateEventScript",
            value: function(e, t) {
                var n = this.owner._scripts;
                if (n) {
                    var r = e._clip, i = r._animationEvents, a = r._duration, o = t._elapsedTime, s = o % a, l = Math.abs(Math.floor(o / a) - Math.floor(t._lastElapsedTime / a)), u = t._elapsedTime >= t._lastElapsedTime;
                    if (t._lastIsFront !== u && (u ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = u), 
                    u) {
                        t._playEventIndex = this._eventScript(n, i, t._playEventIndex, l > 0 ? a : s, !0);
                        for (var c = 0, h = l - 1; c < h; c++) this._eventScript(n, i, 0, a, !0);
                        l > 0 && s > 0 && (t._playEventIndex = this._eventScript(n, i, 0, s, !0));
                    } else {
                        t._playEventIndex = this._eventScript(n, i, t._playEventIndex, l > 0 ? 0 : s, !1);
                        var _ = i.length - 1;
                        for (c = 0, h = l - 1; c < h; c++) this._eventScript(n, i, _, 0, !1);
                        l > 0 && s > 0 && (t._playEventIndex = this._eventScript(n, i, _, s, !1));
                    }
                }
            }
        }, {
            key: "_updateClipDatas",
            value: function(e, t, n, r) {
                var i = e._clip, a = i._duration, o = e.clipStart * a + n._normalizedPlayTime * n._duration, s = e._currentFrameIndices, l = n._elapsedTime > n._lastElapsedTime;
                i._evaluateClipDatasRealTime(i._nodes, o, s, t, l, e._realtimeDatas);
            }
        }, {
            key: "_applyFloat",
            value: function(e, t, n, r, i, a, o) {
                if (n.updateMark === this._updateMark) if (r) e[t] += i * o; else {
                    var s = e[t];
                    e[t] = s + i * (o - s);
                } else if (a) e[t] = r ? n.defaultValue + o : o; else if (r) e[t] = n.defaultValue + i * o; else {
                    var l = n.defaultValue;
                    e[t] = l + i * (o - l);
                }
            }
        }, {
            key: "_applyPositionAndRotationEuler",
            value: function(e, t, n, r, i, a) {
                if (e.updateMark === this._updateMark) if (t) a.x += n * i.x, a.y += n * i.y, a.z += n * i.z; else {
                    var o = a.x, s = a.y, l = a.z;
                    a.x = o + n * (i.x - o), a.y = s + n * (i.y - s), a.z = l + n * (i.z - l);
                } else if (r) if (t) {
                    var u = e.defaultValue;
                    a.x = u.x + i.x, a.y = u.y + i.y, a.z = u.z + i.z;
                } else a.x = i.x, a.y = i.y, a.z = i.z; else if (u = e.defaultValue, t) a.x = u.x + n * i.x, 
                a.y = u.y + n * i.y, a.z = u.z + n * i.z; else {
                    var c = u.x, h = u.y, _ = u.z;
                    a.x = c + n * (i.x - c), a.y = h + n * (i.y - h), a.z = _ + n * (i.z - _);
                }
            }
        }, {
            key: "_applyRotation",
            value: function(e, t, n, r, i, a) {
                if (e.updateMark === this._updateMark) if (t) {
                    var o = Animator._tempQuaternion1;
                    O.quaternionWeight(i, n, o), o.normalize(o), u.multiply(a, o, a);
                } else u.lerp(a, i, n, a); else if (r) if (t) {
                    var s = e.defaultValue;
                    u.multiply(s, i, a);
                } else a.x = i.x, a.y = i.y, a.z = i.z, a.w = i.w; else s = e.defaultValue, t ? (o = Animator._tempQuaternion1, 
                O.quaternionWeight(i, n, o), o.normalize(o), u.multiply(s, o, a)) : u.lerp(s, i, n, a);
            }
        }, {
            key: "_applyScale",
            value: function(e, t, n, r, i, a) {
                if (e.updateMark === this._updateMark) if (t) {
                    var o = Animator._tempVector31;
                    O.scaleWeight(i, n, o), a.x = a.x * o.x, a.y = a.y * o.y, a.z = a.z * o.z;
                } else O.scaleBlend(a, i, n, a); else if (r) if (t) {
                    var s = e.defaultValue;
                    a.x = s.x * i.x, a.y = s.y * i.y, a.z = s.z * i.z;
                } else a.x = i.x, a.y = i.y, a.z = i.z; else s = e.defaultValue, t ? (o = Animator._tempVector31, 
                O.scaleWeight(i, n, o), a.x = s.x * o.x, a.y = s.y * o.y, a.z = s.z * o.z) : O.scaleBlend(s, i, n, a);
            }
        }, {
            key: "_applyCrossData",
            value: function(e, t, n, r, i, a, o) {
                var s = e.propertyOwner;
                if (s) {
                    switch (e.type) {
                      case 0:
                        for (var l = e.property, c = l.length - 1, h = 0; h < c && (s = s[l[h]]); h++) ;
                        var _ = i + o * (a - i);
                        e.value = _, this._applyFloat(s, l[c], e, t, n, r, _);
                        break;

                      case 1:
                        var d = s.localPosition, f = e.value, m = i.x, T = i.y, p = i.z;
                        f.x = m + o * (a.x - m), f.y = T + o * (a.y - T), f.z = p + o * (a.z - p), this._applyPositionAndRotationEuler(e, t, n, r, f, d), 
                        s.localPosition = d;
                        break;

                      case 2:
                        var g = s.localRotation, E = e.value;
                        u.lerp(i, a, o, E), this._applyRotation(e, t, n, r, E, g), s.localRotation = g;
                        break;

                      case 3:
                        var y = s.localScale, v = e.value;
                        O.scaleBlend(i, a, o, v), this._applyScale(e, t, n, r, v, y), s.localScale = y;
                        break;

                      case 4:
                        var S = s.localRotationEuler, C = e.value;
                        m = i.x, T = i.y, p = i.z, C.x = m + o * (a.x - m), C.y = T + o * (a.y - T), C.z = p + o * (a.z - p), 
                        this._applyPositionAndRotationEuler(e, t, n, r, C, S), s.localRotationEuler = S;
                    }
                    e.updateMark = this._updateMark;
                }
            }
        }, {
            key: "_setClipDatasToNode",
            value: function(e, t, n, r) {
                for (var i = e._realtimeDatas, a = e._clip._nodes, o = e._nodeOwners, s = 0, l = a.count; s < l; s++) {
                    var u = o[s];
                    if (u) {
                        var c = u.propertyOwner;
                        if (c) {
                            switch (u.type) {
                              case 0:
                                for (var h = u.property, _ = h.length - 1, d = 0; d < _ && (c = c[h[d]]); d++) ;
                                this._applyFloat(c, h[_], u, t, n, r, i[s]);
                                break;

                              case 1:
                                var f = c.localPosition;
                                this._applyPositionAndRotationEuler(u, t, n, r, i[s], f), c.localPosition = f;
                                break;

                              case 2:
                                var m = c.localRotation;
                                this._applyRotation(u, t, n, r, i[s], m), c.localRotation = m;
                                break;

                              case 3:
                                var T = c.localScale;
                                this._applyScale(u, t, n, r, i[s], T), c.localScale = T;
                                break;

                              case 4:
                                var p = c.localRotationEuler;
                                this._applyPositionAndRotationEuler(u, t, n, r, i[s], p), c.localRotationEuler = p;
                            }
                            u.updateMark = this._updateMark;
                        }
                    }
                }
            }
        }, {
            key: "_setCrossClipDatasToNode",
            value: function(e, t, n, r, i) {
                for (var a = e._crossNodesOwners, o = e._crossNodesOwnersCount, s = e.blendingMode !== Q.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, u = n._realtimeDatas, c = e._destCrossClipNodeIndices, h = n._nodeOwners, _ = t._realtimeDatas, d = e._srcCrossClipNodeIndices, f = t._nodeOwners, m = 0; m < o; m++) {
                    var T = a[m];
                    if (T) {
                        var p = d[m], g = c[m], E = -1 !== p ? _[p] : h[g].defaultValue, y = -1 !== g ? u[g] : f[p].defaultValue;
                        this._applyCrossData(T, s, l, i, E, y, r);
                    }
                }
            }
        }, {
            key: "_setFixedCrossClipDatasToNode",
            value: function(e, t, n, r) {
                for (var i = e._crossNodesOwners, a = e._crossNodesOwnersCount, o = e.blendingMode !== Q.BLENDINGMODE_OVERRIDE, s = e.defaultWeight, l = t._realtimeDatas, u = e._destCrossClipNodeIndices, c = 0; c < a; c++) {
                    var h = i[c];
                    if (h) {
                        var _ = u[c], d = h.crossFixedValue, f = -1 !== _ ? l[_] : h.defaultValue;
                        this._applyCrossData(h, o, s, r, d, f, n);
                    }
                }
            }
        }, {
            key: "_revertDefaultKeyframeNodes",
            value: function(e) {
                for (var t = e._nodeOwners, n = 0, r = t.length; n < r; n++) {
                    var i = t[n];
                    if (i) {
                        var a = i.propertyOwner;
                        if (a) switch (i.type) {
                          case 0:
                            for (var o = i.property, s = o.length - 1, l = 0; l < s && (a = a[o[l]]); l++) ;
                            a[o[s]] = i.defaultValue;
                            break;

                          case 1:
                            var u = a.localPosition, c = i.defaultValue;
                            u.x = c.x, u.y = c.y, u.z = c.z, a.localPosition = u;
                            break;

                          case 2:
                            var h = a.localRotation, _ = i.defaultValue;
                            h.x = _.x, h.y = _.y, h.z = _.z, h.w = _.w, a.localRotation = h;
                            break;

                          case 3:
                            var d = a.localScale;
                            c = i.defaultValue, d.x = c.x, d.y = c.y, d.z = c.z, a.localScale = d;
                            break;

                          case 4:
                            var f = a.localRotationEuler;
                            c = i.defaultValue, f.x = c.x, f.y = c.y, f.z = c.z, a.localRotationEuler = f;
                            break;

                          default:
                            throw "Animator:unknown type.";
                        }
                    }
                }
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = this.owner._parent;
                this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
            }
        }, {
            key: "_onDestroy",
            value: function() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) this._controllerLayers[e]._removeReference();
                var n = this.owner._parent;
                this.owner._clearHierarchyAnimator(this, n ? n._hierarchyAnimator : null);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this.owner._scene._animatorPool.add(this);
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                    if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
                }
            }
        }, {
            key: "_onDisable",
            value: function() {
                this.owner._scene._animatorPool.remove(this);
            }
        }, {
            key: "_handleSpriteOwnersBySprite",
            value: function(e, t, n) {
                for (var r = 0, i = this._controllerLayers.length; r < i; r++) for (var a = this._controllerLayers[r]._states, o = 0, s = a.length; o < s; o++) {
                    var l = a[o], u = l._clip, c = t.join("/"), h = u._nodesMap[c];
                    if (h) for (var _ = l._nodeOwners, d = 0, f = h.length; d < f; d++) e ? this._addKeyframeNodeOwner(_, h[d], n) : this._removeKeyframeNodeOwner(_, h[d]);
                }
            }
        }, {
            key: "_parse",
            value: function(e) {
                var n = e.avatar;
                if (n) {
                    this.avatar = t.Loader.getRes(n.path);
                    var r = n.linkSprites;
                    this._linkSprites = r, this._linkToSprites(r);
                }
                e.clipPaths;
                for (var i = e.playOnWake, a = e.layers, o = 0; o < a.length; o++) {
                    var s = a[o], l = new Q(s.name);
                    l.defaultWeight = 0 === o ? 1 : s.weight;
                    var u = s.blendingMode;
                    u && (l.blendingMode = u), this.addControllerLayer(l);
                    for (var c = s.states, h = 0, _ = c.length; h < _; h++) {
                        var d = c[h], f = d.clipPath;
                        if (f) {
                            var m, T = d.name;
                            if (m = t.Loader.getRes(f)) {
                                var p = new $();
                                p.name = T, p.clip = m, l.addState(p), 0 === h && (this.getControllerLayer(o).defaultState = p);
                            }
                        }
                    }
                    void 0 !== i && (l.playOnWake = i);
                }
                var g = e.cullingMode;
                void 0 !== g && (this.cullingMode = g);
            }
        }, {
            key: "_update",
            value: function() {
                var e = this.owner._scene.timer, n = e._delta / 1e3;
                if (0 !== this._speed && 0 !== n) {
                    var r;
                    if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) {
                        r = !1;
                        for (var i = 0, a = this._renderableSprites.length; i < a; i++) if (this._renderableSprites[i]._render.isRender) {
                            r = !0;
                            break;
                        }
                    } else r = !0;
                    this._updateMark++;
                    var o = e.scale;
                    for (i = 0, a = this._controllerLayers.length; i < a; i++) {
                        var s = this._controllerLayers[i], l = s._playStateInfo, u = s._crossPlayStateInfo;
                        switch (f = s.blendingMode !== Q.BLENDINGMODE_OVERRIDE, s._playType) {
                          case 0:
                            var c = l._currentState, h = c._clip, _ = this._speed * c.speed, d = l._finish;
                            if (d || this._updatePlayer(c, l, n * _, h.islooping), r) {
                                var f = s.blendingMode !== Q.BLENDINGMODE_OVERRIDE;
                                this._updateClipDatas(c, f, l, o * _), this._setClipDatasToNode(c, f, s.defaultWeight, 0 === i), 
                                d || this._updateEventScript(c, l);
                            }
                            break;

                          case 1:
                            h = (c = l._currentState)._clip;
                            var m = s._crossPlayState, T = m._clip, p = s._crossDuration, g = u._startPlayTime, E = T._duration - g, y = p > E ? E / p : 1, v = this._speed * m.speed;
                            this._updatePlayer(m, u, n * y * v, T.islooping);
                            var S = (u._elapsedTime - g) / y / p;
                            S >= 1 ? r && (this._updateClipDatas(m, f, u, o * v), this._setClipDatasToNode(m, f, s.defaultWeight, 0 === i), 
                            s._playType = 0, l._currentState = m, u._cloneTo(l)) : (l._finish || (_ = this._speed * c.speed, 
                            this._updatePlayer(c, l, n * _, h.islooping), r && this._updateClipDatas(c, f, l, o * _)), 
                            r && (this._updateClipDatas(m, f, u, o * y * v), this._setCrossClipDatasToNode(s, c, m, S, 0 === i))), 
                            r && (this._updateEventScript(c, l), this._updateEventScript(m, u));
                            break;

                          case 2:
                            T = (m = s._crossPlayState)._clip, p = s._crossDuration, g = u._startPlayTime, y = p > (E = T._duration - g) ? E / p : 1, 
                            v = this._speed * m.speed, this._updatePlayer(m, u, n * y * v, T.islooping), r && ((S = (u._elapsedTime - g) / y / p) >= 1 ? (this._updateClipDatas(m, f, u, o * v), 
                            this._setClipDatasToNode(m, f, 1, 0 === i), s._playType = 0, l._currentState = m, 
                            u._cloneTo(l)) : (this._updateClipDatas(m, f, u, o * y * v), this._setFixedCrossClipDatasToNode(s, m, S, 0 === i)), 
                            this._updateEventScript(m, u));
                        }
                    }
                    r && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices), 
                    this._updateAvatarNodesToSprite());
                }
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                var t = e;
                t.avatar = this.avatar, t.cullingMode = this.cullingMode;
                for (var n = 0, r = this._controllerLayers.length; n < r; n++) {
                    var i = this._controllerLayers[n];
                    t.addControllerLayer(i.clone());
                    for (var a = i._states, o = 0, s = a.length; o < s; o++) {
                        var l = a[o].clone(), u = t.getControllerLayer(n);
                        u.addState(l), 0 == o && (u.defaultState = l);
                    }
                }
                t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
            }
        }, {
            key: "getDefaultState",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e].defaultState;
            }
        }, {
            key: "addState",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this._controllerLayers[t].addState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
            }
        }, {
            key: "removeState",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this._controllerLayers[t].removeState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
            }
        }, {
            key: "addControllerLayer",
            value: function(e) {
                this._controllerLayers.push(e), e._animator = this, e._addReference();
                for (var t = e._states, n = 0, r = t.length; n < r; n++) this._getOwnersByClip(t[n]);
            }
        }, {
            key: "getControllerLayer",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e];
            }
        }, {
            key: "play",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.NEGATIVE_INFINITY, r = this._controllerLayers[t];
                if (r) {
                    var i = r.defaultState;
                    if (!e && !i) throw new Error("Animator:must have default clip value,please set clip property.");
                    var a = r._playStateInfo, o = a._currentState, s = e ? r._statesMap[e] : i, l = s._clip._duration;
                    o !== s ? (n !== Number.NEGATIVE_INFINITY ? a._resetPlayState(l * n) : a._resetPlayState(0), 
                    null !== o && o !== s && this._revertDefaultKeyframeNodes(o), r._playType = 0, a._currentState = s) : n !== Number.NEGATIVE_INFINITY && (a._resetPlayState(l * n), 
                    r._playType = 0);
                    var u = s._scripts;
                    if (u) for (var c = 0, h = u.length; c < h; c++) u[c].onStateEnter();
                } else console.warn("Invalid layerIndex " + t + ".");
            }
        }, {
            key: "crossFade",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.NEGATIVE_INFINITY, i = this._controllerLayers[n];
                if (i) {
                    var a = i._statesMap[e];
                    if (a) {
                        var o = i._playType;
                        if (-1 === o) return void this.play(e, n, r);
                        var s = i._crossPlayStateInfo, l = i._crossNodesOwners, u = i._crossNodesOwnersIndicesMap, c = i._playStateInfo._currentState, h = a._nodeOwners, _ = i._destCrossClipNodeIndices, d = a._clip, f = d._nodes, m = d._nodesDic;
                        switch (o) {
                          case 0:
                            var T = c._nodeOwners, p = i._srcCrossClipNodeIndices, g = c._clip, E = g._nodes, y = g._nodesDic;
                            i._playType = 1;
                            for (var v = ++i._crossMark, S = i._crossNodesOwnersCount = 0, C = 0, R = E.count; C < R; C++) {
                                var D = E.getNodeByIndex(C), M = D._indexInList, A = T[M];
                                if (A) {
                                    var x = D.fullPath;
                                    p[S] = M;
                                    var L = m[x];
                                    _[S] = L ? L._indexInList : -1, u[x] = v, l[S] = A, S++;
                                }
                            }
                            for (C = 0, R = f.count; C < R; C++) {
                                var I = (L = f.getNodeByIndex(C))._indexInList, O = h[I];
                                if (O) {
                                    var P = L.fullPath;
                                    y[P] || (p[S] = -1, _[S] = I, u[P] = v, l[S] = O, S++);
                                }
                            }
                            break;

                          case 1:
                          case 2:
                            for (i._playType = 2, C = 0, R = l.length; C < R; C++) {
                                var N = l[C];
                                N.saveCrossFixedValue(), L = m[N.fullPath], _[C] = L ? L._indexInList : -1;
                            }
                            for (S = i._crossNodesOwnersCount, v = i._crossMark, C = 0, R = f.count; C < R; C++) (O = h[I = (L = f.getNodeByIndex(C))._indexInList]) && u[P = L.fullPath] !== v && (_[S] = I, 
                            u[P] = v, N = h[I], l[S] = N, N.saveCrossFixedValue(), S++);
                        }
                        i._crossNodesOwnersCount = S, i._crossPlayState = a, i._crossDuration = c._clip._duration * t, 
                        r !== Number.NEGATIVE_INFINITY ? s._resetPlayState(d._duration * r) : s._resetPlayState(0);
                        var b = a._scripts;
                        if (b) for (C = 0, R = b.length; C < R; C++) b[C].onStateEnter();
                    } else console.warn("Invalid name " + n + ".");
                } else console.warn("Invalid layerIndex " + n + ".");
            }
        }, {
            key: "getCurrentAnimatorPlayState",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return this._controllerLayers[e]._playStateInfo;
            }
        }, {
            key: "_isLinkSpriteToAnimationNodeData",
            value: function(e, t, n) {
                var r = this._linkAvatarSpritesData[t];
                if (n) r || (this._linkAvatarSpritesData[t] = r = []), r.push(e); else {
                    var i = r.indexOf(e);
                    r.splice(i, 1);
                }
            }
        }, {
            key: "_getAvatarOwnersAndInitDatasAsync",
            value: function() {
                for (var e = 0, t = this._controllerLayers.length; e < t; e++) for (var n = this._controllerLayers[e]._states, r = 0, i = n.length; r < i; r++) this._getOwnersByClip(n[r]);
                for (var a in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                    var o = this._linkAvatarSpritesData[a];
                    if (o) for (var s = 0, l = o.length; s < l; s++) this._isLinkSpriteToAnimationNode(o[s], a, !0);
                }
            }
        }, {
            key: "_isLinkSpriteToAnimationNode",
            value: function(e, t, n) {
                if (this._avatar) {
                    var r = this._avatarNodeMap[t];
                    if (r) if (n) {
                        e._transform._dummy = r.transform, this._linkAvatarSprites.push(e);
                        var i = r.transform, a = e.transform;
                        if (!a.owner.isStatic && i) {
                            var o = a.worldMatrix, s = this.owner._transform._parent;
                            if (s) O.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), o); else for (var l = o.elements, u = i.getWorldMatrix(), c = 0; c < 16; c++) l[c] = u[c];
                            a.worldMatrix = o;
                        }
                    } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
                }
            }
        }, {
            key: "_updateAvatarNodesToSprite",
            value: function() {
                for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                    var n = this._linkAvatarSprites[e], r = n.transform._dummy, i = n.transform;
                    if (!i.owner.isStatic && r) {
                        var a = i.worldMatrix, o = this.owner._transform;
                        O.matrix4x4MultiplyMFM(o.worldMatrix, r.getWorldMatrix(), a), i.worldMatrix = a;
                    }
                }
            }
        }, {
            key: "linkSprite3DToAvatarNode",
            value: function(e, t) {
                return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), 
                !0;
            }
        }, {
            key: "unLinkSprite3DToAvatarNode",
            value: function(e) {
                var t = e.transform._dummy;
                if (t) {
                    var n = t._owner.name;
                    return this._isLinkSpriteToAnimationNodeData(e, n, !1), this._isLinkSpriteToAnimationNode(e, n, !1), 
                    !0;
                }
                return !1;
            }
        }, {
            key: "_updateAnimationNodeWorldMatix",
            value: function(e, n, r, i, a) {
                t.LayaGL.instance.updateAnimationNodeWorldMatix(e, n, r, a, i);
            }
        }, {
            key: "speed",
            get: function() {
                return this._speed;
            },
            set: function(e) {
                this._speed = e;
            }
        }, {
            key: "avatar",
            get: function() {
                return this._avatar;
            },
            set: function(e) {
                if (this._avatar !== e) if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(), 
                this.owner._changeHierarchyAnimatorAvatar(this, e); else {
                    var t = this.owner._parent;
                    this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
                }
            }
        } ], [ {
            key: "_update",
            value: function(e) {
                for (var t = e._animatorPool, n = t.elements, r = 0, i = t.length; r < i; r++) {
                    var a = n[r];
                    a && a.enabled && a._update();
                }
            }
        } ]), Animator;
    }();
    te._tempVector30 = new o(), te._tempVector31 = new o(), te._tempQuaternion0 = new u(), 
    te._tempQuaternion1 = new u(), te.CULLINGMODE_ALWAYSANIMATE = 0, te.CULLINGMODE_CULLCOMPLETELY = 2;
    var ne = function PostProcessRenderContext() {
        _classCallCheck(this, PostProcessRenderContext), this.source = null, this.destination = null, 
        this.camera = null, this.compositeShaderData = null, this.command = null, this.deferredReleaseTextures = [];
    }, re = function RenderContext3D() {
        _classCallCheck(this, RenderContext3D), this.invertY = !1;
    };
    re._instance = new re();
    var ie = function(e) {
        function RenderTexture(e, n) {
            var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16;
            return _classCallCheck(this, RenderTexture), (r = _possibleConstructorReturn(this, _getPrototypeOf(RenderTexture).call(this, i, !1)))._inPool = !1, 
            r._isCameraTarget = !1, r._glTextureType = t.LayaGL.instance.TEXTURE_2D, r._width = e, 
            r._height = n, r._depthStencilFormat = a, r._mipmapCount = 1, r._create(e, n), r;
        }
        return _inherits(RenderTexture, t.BaseTexture), _createClass(RenderTexture, [ {
            key: "_create",
            value: function(e, n) {
                var r = t.LayaGL.instance, i = r, a = this._glTextureType, o = t.LayaGL.layaGPUInstance, s = o._isWebGL2, l = this._format;
                if (this._frameBuffer = r.createFramebuffer(), r.bindFramebuffer(r.FRAMEBUFFER, this._frameBuffer), 
                l !== t.RenderTextureFormat.Depth && l !== t.RenderTextureFormat.ShadowMap) {
                    switch (t.WebGLContext.bindTexture(r, a, this._glTexture), l) {
                      case t.RenderTextureFormat.R8G8B8:
                        s ? i.texStorage2D(a, this._mipmapCount, i.RGB8, e, n) : r.texImage2D(a, 0, r.RGB, e, n, 0, r.RGB, r.UNSIGNED_BYTE, null);
                        break;

                      case t.RenderTextureFormat.R8G8B8A8:
                        s ? i.texStorage2D(a, this._mipmapCount, i.RGBA8, e, n) : r.texImage2D(a, 0, r.RGBA, e, n, 0, r.RGBA, r.UNSIGNED_BYTE, null);
                        break;

                      case t.RenderTextureFormat.Alpha8:
                        s ? i.texStorage2D(a, 0, i.R8, e, n) : r.texImage2D(a, 0, r.ALPHA, e, n, 0, r.ALPHA, r.UNSIGNED_BYTE, null);
                        break;

                      case t.RenderTextureFormat.R16G16B16A16:
                        s ? i.texStorage2D(a, this._mipmapCount, i.RGBA16F, e, n) : r.texImage2D(a, 0, r.RGBA, e, n, 0, r.RGBA, o._oesTextureHalfFloat.HALF_FLOAT_OES, null);
                    }
                    r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this._glTexture, 0);
                }
                if (l == t.RenderTextureFormat.Depth || l == t.RenderTextureFormat.ShadowMap) {
                    switch (t.WebGLContext.bindTexture(r, a, this._glTexture), this._depthStencilFormat) {
                      case t.RenderTextureDepthFormat.DEPTH_16:
                        s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH_COMPONENT16, e, n) : r.texImage2D(a, 0, r.DEPTH_COMPONENT, e, n, 0, r.DEPTH_COMPONENT, r.UNSIGNED_SHORT, null), 
                        r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, this._glTexture, 0);
                        break;

                      case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                        s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH24_STENCIL8, e, n) : r.texImage2D(a, 0, r.DEPTH_STENCIL, e, n, 0, r.DEPTH_STENCIL, o._webgl_depth_texture.UNSIGNED_INT_24_8_WEBGL, null), 
                        r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, this._glTexture, 0);
                        break;

                      default:
                        throw "RenderTexture: depth format RenderTexture must use depthFormat with DEPTH_16 and DEPTHSTENCIL_16_8.";
                    }
                    s && l == t.RenderTextureFormat.ShadowMap && i.texParameteri(a, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE);
                } else if (this._depthStencilFormat !== t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE) {
                    switch (this._depthStencilBuffer = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._depthStencilBuffer), 
                    this._depthStencilFormat) {
                      case t.RenderTextureDepthFormat.DEPTH_16:
                        r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_COMPONENT16, e, n), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                      case t.RenderTextureDepthFormat.STENCIL_8:
                        r.renderbufferStorage(r.RENDERBUFFER, r.STENCIL_INDEX8, e, n), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.STENCIL_ATTACHMENT, r.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                      case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                        r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, e, n), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, this._depthStencilBuffer);
                        break;

                      default:
                        throw "RenderTexture: unkonw depth format.";
                    }
                    r.bindRenderbuffer(r.RENDERBUFFER, null);
                }
                r.bindFramebuffer(r.FRAMEBUFFER, null), this._setWarpMode(r.TEXTURE_WRAP_S, this._wrapModeU), 
                this._setWarpMode(r.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), 
                this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource(), 
                this._setGPUMemory(e * n * 4);
            }
        }, {
            key: "_start",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), RenderTexture._currentActive = this, 
                this._isCameraTarget && (re._instance.invertY = !0), this._readyed = !1;
            }
        }, {
            key: "_end",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, null), RenderTexture._currentActive = null, this._isCameraTarget && (re._instance.invertY = !1), 
                this._readyed = !0;
            }
        }, {
            key: "getData",
            value: function(e, n, r, i, a) {
                if (t.Render.isConchApp && 2 == window.conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
                var o = t.LayaGL.instance;
                return o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o.checkFramebufferStatus(o.FRAMEBUFFER) === o.FRAMEBUFFER_COMPLETE ? (o.readPixels(e, n, r, i, o.RGBA, o.UNSIGNED_BYTE, a), 
                o.bindFramebuffer(o.FRAMEBUFFER, null), a) : (o.bindFramebuffer(o.FRAMEBUFFER, null), 
                null);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                if (this._frameBuffer) {
                    var e = t.LayaGL.instance;
                    e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer), 
                    this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null, 
                    this._setGPUMemory(0);
                }
            }
        }, {
            key: "getDataAsync",
            value: function(e, n, r, i, a) {
                var o = t.LayaGL.instance;
                o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o.readPixelsAsync(e, n, r, i, o.RGBA, o.UNSIGNED_BYTE, function(e) {
                    a(new Uint8Array(e));
                }), o.bindFramebuffer(o.FRAMEBUFFER, null);
            }
        }, {
            key: "depthStencilFormat",
            get: function() {
                return this._depthStencilFormat;
            }
        }, {
            key: "defaulteTexture",
            get: function() {
                return t.Texture2D.grayTexture;
            }
        } ], [ {
            key: "createFromPool",
            value: function(e, n) {
                for (var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16, o = 0, s = RenderTexture._pool.length; o < s; o++) if ((r = RenderTexture._pool[o])._width == e && r._height == n && r._format == i && r._depthStencilFormat == a) {
                    r._inPool = !1;
                    var l = RenderTexture._pool[s - 1];
                    return RenderTexture._pool[o] = l, RenderTexture._pool.length -= 1, r;
                }
                return (r = new RenderTexture(e, n, i, a)).lock = !0, r;
            }
        }, {
            key: "recoverToPool",
            value: function(e) {
                e._inPool || (RenderTexture._pool.push(e), e._inPool = !0);
            }
        }, {
            key: "currentActive",
            get: function() {
                return RenderTexture._currentActive;
            }
        } ]), RenderTexture;
    }();
    ie._pool = [];
    var ae = function() {
        function DefineDatas() {
            _classCallCheck(this, DefineDatas), this._mask = [], this._length = 0;
        }
        return _createClass(DefineDatas, [ {
            key: "_intersectionDefineDatas",
            value: function(e) {
                for (var t = e._mask, n = this._mask, r = this._length - 1; r >= 0; r--) {
                    var i = n[r] & t[r];
                    0 == i && r == this._length - 1 ? this._length-- : n[r] = i;
                }
            }
        }, {
            key: "add",
            value: function(e) {
                var t = e._index, n = t + 1, r = this._mask, i = this._length;
                if (i < n) {
                    for (r.length < n && (r.length = n); i < t; i++) r[i] = 0;
                    r[t] = e._value, this._length = n;
                } else n > this._length ? (r[t] = e._value, this._length = n) : r[t] |= e._value;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._index, n = this._mask, r = this._length - 1;
                if (!(t > r)) {
                    var i = n[t] & ~e._value;
                    t == r && 0 === i ? this._length-- : n[t] = i;
                }
            }
        }, {
            key: "addDefineDatas",
            value: function(e) {
                var t = e._mask, n = e._length, r = this._mask, i = r.length;
                if (i < n) {
                    r.length = n;
                    for (var a = 0; a < i; a++) r[a] |= t[a];
                    for (;i < n; i++) r[i] = t[i];
                    this._length = n;
                } else {
                    for (a = 0; a < n; a++) r[a] |= t[a];
                    this._length = Math.max(this._length, n);
                }
            }
        }, {
            key: "removeDefineDatas",
            value: function(e) {
                for (var t = e._mask, n = this._mask, r = this._length - 1, i = e._length - 1; i >= 0; i--) if (!(i > r)) {
                    var a = n[i] & ~t[i];
                    i == r && 0 === a ? (r--, this._length--) : n[i] = a;
                }
            }
        }, {
            key: "has",
            value: function(e) {
                var t = e._index;
                return !(t >= this._length) && 0 != (this._mask[t] & e._value);
            }
        }, {
            key: "clear",
            value: function() {
                this._length = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e, n = t._mask, r = this._mask, i = this._length;
                n.length = i;
                for (var a = 0; a < i; a++) n[a] = r[a];
                t._length = i;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new DefineDatas();
                return this.cloneTo(e), e;
            }
        } ]), DefineDatas;
    }(), oe = function ShaderDefine(e, t) {
        _classCallCheck(this, ShaderDefine), this._index = e, this._value = t;
    }, se = function() {
        function ShaderVariant(e, t, n, r) {
            _classCallCheck(this, ShaderVariant), this._subShaderIndex = 0, this._passIndex = 0, 
            this.setValue(e, t, n, r);
        }
        return _createClass(ShaderVariant, [ {
            key: "setValue",
            value: function(e, t, n, r) {
                if (!e) throw "ShaderVariantInfo:Shader can't be null.";
                var i = e.getSubShaderAt(t);
                if (!i) throw "ShaderVariantInfo:Shader don't have subShaderIndex of ".concat(t, ".");
                var a = i._passes[n];
                if (!a) throw "ShaderVariantInfo:Shader don't have passIndex of ".concat(n, ".");
                for (var o = a._validDefine, s = 0, u = r.length; s < u; s++) {
                    var c = r[s];
                    if (!o.has(l.Shader3D.getDefineByName(c))) throw "ShaderVariantInfo:Invalid defineName ".concat(c, " in ").concat(e._name, " subShaderIndex of ").concat(t, " passIndex of ").concat(n, ".");
                }
                this._shader = e, this._subShaderIndex = t, this._passIndex = n, this._defineNames = r;
            }
        }, {
            key: "equal",
            value: function(e) {
                if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex || this._passIndex !== e._passIndex) return !1;
                var t = this._defineNames, n = e._defineNames;
                if (t.length !== n.length) return !1;
                for (var r = 0, i = this._defineNames.length; r < i; r++) if (t[r] !== n[r]) return !1;
                return !0;
            }
        }, {
            key: "clone",
            value: function() {
                return new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
            }
        }, {
            key: "shader",
            get: function() {
                return this._shader;
            }
        }, {
            key: "subShaderIndex",
            get: function() {
                return this._subShaderIndex;
            }
        }, {
            key: "passIndex",
            get: function() {
                return this._passIndex;
            }
        }, {
            key: "defineNames",
            get: function() {
                return this._defineNames;
            }
        } ]), ShaderVariant;
    }(), le = function() {
        function ShaderVariantCollection() {
            _classCallCheck(this, ShaderVariantCollection), this._allCompiled = !1, this._variants = [];
        }
        return _createClass(ShaderVariantCollection, [ {
            key: "add",
            value: function(e) {
                for (var t = 0, n = this._variants.length; t < n; t++) if (this._variants[t].equal(e)) return !1;
                return this._variants.push(e.clone()), this._allCompiled = !1, !0;
            }
        }, {
            key: "remove",
            value: function(e) {
                for (var t = 0, n = this._variants.length; t < n; t++) if (this._variants[t].equal(e)) return this._variants.splice(t, 1), 
                !0;
                return !1;
            }
        }, {
            key: "contatins",
            value: function(e) {
                for (var t = 0, n = this._variants.length; t < n; t++) if (this._variants[t].equal(e)) return !0;
                return !1;
            }
        }, {
            key: "getByIndex",
            value: function(e) {
                return this._variants[e];
            }
        }, {
            key: "clear",
            value: function() {
                this._variants.length = 0;
            }
        }, {
            key: "compile",
            value: function() {
                if (!this._allCompiled) {
                    for (var e = this._variants, t = 0, n = e.length; t < n; t++) {
                        var r = e[t];
                        l.Shader3D.compileShaderByDefineNames(r._shader._name, r._subShaderIndex, r._passIndex, r._defineNames);
                    }
                    this._allCompiled = !0;
                }
            }
        }, {
            key: "allCompiled",
            get: function() {
                return this._allCompiled;
            }
        }, {
            key: "variantCount",
            get: function() {
                return this._variants.length;
            }
        } ]), ShaderVariantCollection;
    }(), ue = function() {
        function Shader3D(e, t, n, r) {
            _classCallCheck(this, Shader3D), this._attributeMap = null, this._uniformMap = null, 
            this._enableInstancing = !1, this._subShaders = [], this._name = e, this._attributeMap = t, 
            this._uniformMap = n, this._enableInstancing = r;
        }
        return _createClass(Shader3D, [ {
            key: "addSubShader",
            value: function(e) {
                this._subShaders.push(e), e._owner = this;
            }
        }, {
            key: "getSubShaderAt",
            value: function(e) {
                return this._subShaders[e];
            }
        }, {
            key: "name",
            get: function() {
                return this._name;
            }
        } ], [ {
            key: "_getNamesByDefineData",
            value: function(e, t) {
                var n = Shader3D._maskMap, r = e._mask;
                t.length = 0;
                for (var i = 0, a = e._length; i < a; i++) for (var o = n[i], s = r[i], l = 0; l < 32; l++) {
                    var u = 1 << l;
                    if (s > 0 && u > s) break;
                    s & u && t.push(o[u]);
                }
            }
        }, {
            key: "getDefineByName",
            value: function(e) {
                var t = Shader3D._defineMap[e];
                if (!t) {
                    var n = Shader3D._maskMap, r = Shader3D._defineCounter, i = Math.floor(r / 32), a = 1 << r % 32;
                    t = new oe(i, a), Shader3D._defineMap[e] = t, i == n.length && (n.length++, n[i] = {}), 
                    n[i][a] = e, Shader3D._defineCounter++;
                }
                return t;
            }
        }, {
            key: "propertyNameToID",
            value: function(e) {
                if (null != Shader3D._propertyNameMap[e]) return Shader3D._propertyNameMap[e];
                var t = Shader3D._propertyNameCounter++;
                return Shader3D._propertyNameMap[e] = t, t;
            }
        }, {
            key: "addInclude",
            value: function(e, n) {
                n = n.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, n);
            }
        }, {
            key: "compileShaderByDefineNames",
            value: function(e, t, n, r) {
                var i = Shader3D.find(e);
                if (i) {
                    var a = i.getSubShaderAt(t);
                    if (a) {
                        var o = a._passes[n];
                        if (o) {
                            var s = Shader3D._compileDefineDatas;
                            s.clear();
                            for (var l = 0, u = r.length; l < u; l++) s.add(Shader3D.getDefineByName(r[l]));
                            o.withCompile(s);
                        } else console.warn("Shader3D: unknown passIndex.");
                    } else console.warn("Shader3D: unknown subShaderIndex.");
                } else console.warn("Shader3D: unknown shader name.");
            }
        }, {
            key: "add",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                return Shader3D._preCompileShader[e] = new Shader3D(e, t, n, r);
            }
        }, {
            key: "find",
            value: function(e) {
                return Shader3D._preCompileShader[e];
            }
        }, {
            key: "compileShader",
            value: function(e, t, n) {
                var r = Shader3D.find(e);
                if (r) {
                    var i = r.getSubShaderAt(t);
                    if (i) {
                        var a = i._passes[n];
                        if (a) {
                            var o = Shader3D._compileDefineDatas, s = o._mask;
                            s.length = 0;
                            for (var l = 0, u = arguments.length <= 3 ? 0 : arguments.length - 3; l < u; l++) s.push(l + 3 < 3 || arguments.length <= l + 3 ? void 0 : arguments[l + 3]);
                            o._length = arguments.length <= 3 ? 0 : arguments.length - 3, a.withCompile(o);
                        } else console.warn("Shader3D: unknown passIndex.");
                    } else console.warn("Shader3D: unknown subShaderIndex.");
                } else console.warn("Shader3D: unknown shader name.");
            }
        } ]), Shader3D;
    }();
    ue._compileDefineDatas = new ae(), ue.RENDER_STATE_CULL = 0, ue.RENDER_STATE_BLEND = 1, 
    ue.RENDER_STATE_BLEND_SRC = 2, ue.RENDER_STATE_BLEND_DST = 3, ue.RENDER_STATE_BLEND_SRC_RGB = 4, 
    ue.RENDER_STATE_BLEND_DST_RGB = 5, ue.RENDER_STATE_BLEND_SRC_ALPHA = 6, ue.RENDER_STATE_BLEND_DST_ALPHA = 7, 
    ue.RENDER_STATE_BLEND_CONST_COLOR = 8, ue.RENDER_STATE_BLEND_EQUATION = 9, ue.RENDER_STATE_BLEND_EQUATION_RGB = 10, 
    ue.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, ue.RENDER_STATE_DEPTH_TEST = 12, ue.RENDER_STATE_DEPTH_WRITE = 13, 
    ue.PERIOD_CUSTOM = 0, ue.PERIOD_MATERIAL = 1, ue.PERIOD_SPRITE = 2, ue.PERIOD_CAMERA = 3, 
    ue.PERIOD_SCENE = 4, ue._propertyNameCounter = 0, ue._propertyNameMap = {}, ue._defineCounter = 0, 
    ue._defineMap = {}, ue._preCompileShader = {}, ue._maskMap = [], ue.debugMode = !1, 
    ue.debugShaderVariantCollection = new le();
    var ce = function() {
        function ShaderData() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            _classCallCheck(this, ShaderData), this._ownerResource = null, this._data = null, 
            this._defineDatas = new ae(), this._runtimeCopyValues = [], this._ownerResource = e, 
            this._initData();
        }
        return _createClass(ShaderData, [ {
            key: "_initData",
            value: function() {
                this._data = new Object();
            }
        }, {
            key: "getData",
            value: function() {
                return this._data;
            }
        }, {
            key: "addDefine",
            value: function(e) {
                this._defineDatas.add(e);
            }
        }, {
            key: "removeDefine",
            value: function(e) {
                this._defineDatas.remove(e);
            }
        }, {
            key: "hasDefine",
            value: function(e) {
                return this._defineDatas.has(e);
            }
        }, {
            key: "clearDefine",
            value: function() {
                this._defineDatas.clear();
            }
        }, {
            key: "getBool",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBool",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getInt",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setInt",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getNumber",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setNumber",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector2",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector2",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector3",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector3",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getQuaternion",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setQuaternion",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getMatrix4x4",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setMatrix4x4",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getBuffer",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBuffer",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "setTexture",
            value: function(e, t) {
                var n = this._data[e];
                this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (n && n._removeReference(), 
                t && t._addReference());
            }
        }, {
            key: "getTexture",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setAttribute",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getAttribute",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "getLength",
            value: function() {
                return this._data.length;
            }
        }, {
            key: "setLength",
            value: function(e) {
                this._data.length = e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var n = e, a = n._data;
                for (var s in this._data) {
                    var l = this._data[s];
                    if (null != l) if ("number" == typeof l) a[s] = l; else if ("number" == typeof l) a[s] = l; else if ("boolean" == typeof l) a[s] = l; else if (l instanceof r) {
                        var u = a[s] || (a[s] = new r());
                        l.cloneTo(u), a[s] = u;
                    } else if (l instanceof o) {
                        var h = a[s] || (a[s] = new o());
                        l.cloneTo(h), a[s] = h;
                    } else if (l instanceof i) {
                        var _ = a[s] || (a[s] = new i());
                        l.cloneTo(_), a[s] = _;
                    } else if (l instanceof c) {
                        var d = a[s] || (a[s] = new c());
                        l.cloneTo(d), a[s] = d;
                    } else l instanceof t.BaseTexture && (a[s] = l);
                }
                this._defineDatas.cloneTo(n._defineDatas);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShaderData();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneToForNative",
            value: function(e) {
                var n = e;
                this._int32Data.length - n._int32Data.length > 0 && n.needRenewArrayBufferForNative(this._int32Data.length), 
                n._int32Data.set(this._int32Data, 0);
                var a = n._nativeArray, s = this._nativeArray.length;
                a.length = s;
                for (var l = 0; l < s; l++) {
                    var u = this._nativeArray[l];
                    if (u) if ("number" == typeof u) a[l] = u, n.setNumber(l, u); else if ("number" == typeof u) a[l] = u, 
                    n.setInt(l, u); else if ("boolean" == typeof u) a[l] = u, n.setBool(l, u); else if (u instanceof r) {
                        var h = a[l] || (a[l] = new r());
                        u.cloneTo(h), a[l] = h, n.setVector2(l, h);
                    } else if (u instanceof o) {
                        var _ = a[l] || (a[l] = new o());
                        u.cloneTo(_), a[l] = _, n.setVector3(l, _);
                    } else if (u instanceof i) {
                        var d = a[l] || (a[l] = new i());
                        u.cloneTo(d), a[l] = d, n.setVector(l, d);
                    } else if (u instanceof c) {
                        var f = a[l] || (a[l] = new c());
                        u.cloneTo(f), a[l] = f, n.setMatrix4x4(l, f);
                    } else u instanceof t.BaseTexture && (a[l] = u, n.setTexture(l, u));
                }
                this._defineDatas.cloneTo(n._defineDatas);
            }
        }, {
            key: "_initDataForNative",
            value: function() {
                this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [], 
                this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data), 
                this._float32Data = new Float32Array(this._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
            }
        }, {
            key: "needRenewArrayBufferForNative",
            value: function(e) {
                if (e >= this._int32Data.length) {
                    var n = 4 * (e + 1), r = this._int32Data, i = this._data.conchRef, a = this._data._ptrID;
                    this._data = new ArrayBuffer(n), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data), 
                    this._data.conchRef = i, this._data._ptrID = a, r && this._int32Data.set(r, 0);
                    var o = t.LayaGL.instance;
                    o.updateArrayBufferRef ? o.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
                }
            }
        }, {
            key: "getDataForNative",
            value: function() {
                return this._nativeArray;
            }
        }, {
            key: "getIntForNative",
            value: function(e) {
                return this._int32Data[e];
            }
        }, {
            key: "setIntForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getBoolForNative",
            value: function(e) {
                return 1 == this._int32Data[e];
            }
        }, {
            key: "setBoolForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this._nativeArray[e] = t;
            }
        }, {
            key: "getNumberForNative",
            value: function(e) {
                return this._float32Data[e];
            }
        }, {
            key: "setNumberForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getMatrix4x4ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setMatrix4x4ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var n = this.setReferenceForNative(t.elements);
                this._int32Data[e] = n;
            }
        }, {
            key: "getVectorForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVectorForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var n = this.setReferenceForNative(t.elements);
                this._int32Data[e] = n;
            }
        }, {
            key: "getVector2ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector2ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var n = this.setReferenceForNative(t.elements);
                this._int32Data[e] = n;
            }
        }, {
            key: "getVector3ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector3ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var n = this.setReferenceForNative(t.elements);
                this._int32Data[e] = n;
            }
        }, {
            key: "getQuaternionForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setQuaternionForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var n = this.setReferenceForNative(t.elements);
                this._int32Data[e] = n;
            }
        }, {
            key: "getBufferForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setBufferForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var n = this.setReferenceForNative(t);
                this._int32Data[e] = n;
            }
        }, {
            key: "getAttributeForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setAttributeForNative",
            value: function(e, n) {
                this._nativeArray[e] = n, n._ptrID || t.LayaGL.instance.createArrayBufferRef(n, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0), 
                t.LayaGL.instance.syncBufferToRenderThread(n), this._int32Data[e] = n._ptrID;
            }
        }, {
            key: "getTextureForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setTextureForNative",
            value: function(e, t) {
                if (t) {
                    this.needRenewArrayBufferForNative(e);
                    var n = this._nativeArray[e];
                    this._nativeArray[e] = t;
                    var r = t._getSource() || t.defaulteTexture._getSource();
                    this._int32Data[e] = r.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (n && n._removeReference(), 
                    t && t._addReference());
                }
            }
        }, {
            key: "setReferenceForNative",
            value: function(e) {
                this.clearRuntimeCopyArray();
                var n = 0, r = 0;
                return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE), 
                n = 0, r = e.getPtrID(n)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY), 
                n = e.getRefNum() - 1, r = e.getPtrID(n), this._runtimeCopyValues.push({
                    obj: e,
                    refID: n,
                    ptrID: r
                })), t.LayaGL.instance.syncBufferToRenderThread(e, n), r;
            }
        }, {
            key: "clearRuntimeCopyArray",
            value: function() {
                var e = t.Stat.loopCount;
                if (this._frameCount != e) {
                    this._frameCount = e;
                    for (var n = 0, r = this._runtimeCopyValues.length; n < r; n++) {
                        this._runtimeCopyValues[n].obj.clearRefNum();
                    }
                    this._runtimeCopyValues.length = 0;
                }
            }
        } ], [ {
            key: "setRuntimeValueMode",
            value: function(e) {
                ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
            }
        } ]), ShaderData;
    }();
    ce._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    var he = function() {
        function PostProcess() {
            _classCallCheck(this, PostProcess), this._compositeShader = ue.find("PostProcessComposite"), 
            this._compositeShaderData = new ce(), this._effects = [], this._context = null, 
            this._context = new ne(), this._context.compositeShaderData = this._compositeShaderData;
        }
        return _createClass(PostProcess, [ {
            key: "_init",
            value: function(e, t) {
                this._context.camera = e, this._context.command = t;
            }
        }, {
            key: "_render",
            value: function() {
                var e = ce._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && ce.setRuntimeValueMode(!1);
                var n = this._context.camera, r = n.viewport, i = ie.createFromPool(re.clientWidth, re.clientHeight, n._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE), a = n._internalRenderTexture;
                this._context.command.clear(), this._context.source = i, this._context.destination = a, 
                this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(a, i), 
                this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                for (var o = 0, s = this._effects.length; o < s; o++) this._effects[o].render(this._context);
                this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
                var l = n._offScreenRenderTexture, u = l || null;
                this._context.destination = u;
                var c = n._getCanvasWidth(), h = n._getCanvasHeight();
                n._screenOffsetScale.setValue(r.x / c, r.y / h, r.width / c, r.height / h), this._context.command.blitScreenTriangle(this._context.source, u, n._screenOffsetScale, this._compositeShader, this._compositeShaderData), 
                ie.recoverToPool(i);
                var _ = this._context.deferredReleaseTextures;
                for (o = 0, s = _.length; o < s; o++) ie.recoverToPool(_[o]);
                _.length = 0, t.ILaya.Render.supportWebGLPlusRendering && ce.setRuntimeValueMode(e);
            }
        }, {
            key: "addEffect",
            value: function(e) {
                this._effects.push(e);
            }
        }, {
            key: "removeEffect",
            value: function(e) {
                var t = this._effects.indexOf(e);
                -1 !== t && this._effects.splice(t, 1);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                PostProcess.SHADERDEFINE_BLOOM_LOW = ue.getDefineByName("BLOOM_LOW"), PostProcess.SHADERDEFINE_BLOOM = ue.getDefineByName("BLOOM"), 
                PostProcess.SHADERDEFINE_FINALPASS = ue.getDefineByName("FINALPASS");
            }
        } ]), PostProcess;
    }();
    he.SHADERVALUE_MAINTEX = ue.propertyNameToID("u_MainTex"), he.SHADERVALUE_BLOOMTEX = ue.propertyNameToID("u_BloomTex"), 
    he.SHADERVALUE_AUTOEXPOSURETEX = ue.propertyNameToID("u_AutoExposureTex"), he.SHADERVALUE_BLOOM_DIRTTEX = ue.propertyNameToID("u_Bloom_DirtTex"), 
    he.SHADERVALUE_BLOOMTEX_TEXELSIZE = ue.propertyNameToID("u_BloomTex_TexelSize"), 
    he.SHADERVALUE_BLOOM_DIRTTILEOFFSET = ue.propertyNameToID("u_Bloom_DirtTileOffset"), 
    he.SHADERVALUE_BLOOM_SETTINGS = ue.propertyNameToID("u_Bloom_Settings"), he.SHADERVALUE_BLOOM_COLOR = ue.propertyNameToID("u_Bloom_Color");
    var _e = function(e) {
        function AnimationTransform3D(e) {
            var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            return _classCallCheck(this, AnimationTransform3D), (n = _possibleConstructorReturn(this, _getPrototypeOf(AnimationTransform3D).call(this)))._owner = e, 
            n._children = [], n._localMatrix = new Float32Array(16), t.Render.supportWebGLPlusAnimation ? (n._localPosition = new K(0, 0, 0, r), 
            n._localRotation = new J(0, 0, 0, 1, i), n._localScale = new K(0, 0, 0, a), n._worldMatrix = s) : (n._localPosition = new o(), 
            n._localRotation = new u(), n._localScale = new o(), n._worldMatrix = new Float32Array(16)), 
            n._localQuaternionUpdate = !1, n._locaEulerlUpdate = !1, n._localUpdate = !1, n._worldUpdate = !0, 
            n;
        }
        return _inherits(AnimationTransform3D, t.EventDispatcher), _createClass(AnimationTransform3D, [ {
            key: "_getlocalMatrix",
            value: function() {
                return this._localUpdate && (O._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix), 
                this._localUpdate = !1), this._localMatrix;
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
                    for (var e = 0, n = this._children.length; e < n; e++) this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "getWorldMatrix",
            value: function() {
                if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent) O.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix); else {
                        var e = this._worldMatrix;
                        e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
                        e[0] = e[5] = e[10] = e[15] = 1;
                    }
                    this._worldUpdate = !1;
                }
                return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1), 
                this._worldMatrix;
            }
        }, {
            key: "setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children, n = t.indexOf(this);
                        t.splice(n, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._localQuaternionUpdate) {
                    var e = this._localRotationEuler;
                    u.createFromYawPitchRoll(e.y / AnimationTransform3D._angleToRandin, e.x / AnimationTransform3D._angleToRandin, e.z / AnimationTransform3D._angleToRandin, this._localRotation), 
                    this._localQuaternionUpdate = !1;
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1, 
                this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                    var e = AnimationTransform3D._tempVector3, t = this._localRotationEuler;
                    t.x = e.y * AnimationTransform3D._angleToRandin, t.y = e.x * AnimationTransform3D._angleToRandin, 
                    t.z = e.z * AnimationTransform3D._angleToRandin, this._locaEulerlUpdate = !1;
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0, 
                this._localUpdate = !0, this._onWorldTransform();
            }
        } ]), AnimationTransform3D;
    }();
    _e._tempVector3 = new o(), _e._angleToRandin = 180 / Math.PI;
    var de = function() {
        function AnimationNode() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            _classCallCheck(this, AnimationNode), this._children = [], this.transform = new _e(this, e, t, n, r);
        }
        return _createClass(AnimationNode, [ {
            key: "addChild",
            value: function(e) {
                e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
            }
        }, {
            key: "removeChild",
            value: function(e) {
                var t = this._children.indexOf(e);
                -1 !== t && this._children.splice(t, 1);
            }
        }, {
            key: "getChildByName",
            value: function(e) {
                for (var t = 0, n = this._children.length; t < n; t++) {
                    var r = this._children[t];
                    if (r.name === e) return r;
                }
                return null;
            }
        }, {
            key: "getChildByIndex",
            value: function(e) {
                return this._children[e];
            }
        }, {
            key: "getChildCount",
            value: function() {
                return this._children.length;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name;
                for (var n = 0, r = this._children.length; n < r; n++) {
                    var i = this._children[n], a = i.clone();
                    t.addChild(a);
                    var o = i.transform, s = a.transform, l = s.localPosition, u = s.localRotation, c = s.localScale;
                    o.localPosition.cloneTo(l), o.localRotation.cloneTo(u), o.localScale.cloneTo(c), 
                    s.localPosition = l, s.localRotation = u, s.localScale = c;
                }
            }
        }, {
            key: "clone",
            value: function() {
                var e = new AnimationNode();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_cloneNative",
            value: function(e, t, n, r, i, a, o) {
                var s = o._nativeCurCloneCount;
                i[s] = a;
                var l = new AnimationNode(new Float32Array(e.buffer, 3 * s * 4, 3), new Float32Array(t.buffer, 4 * s * 4, 4), new Float32Array(n.buffer, 3 * s * 4, 3), new Float32Array(r.buffer, 16 * s * 4, 16));
                return l._worldMatrixIndex = s, this._cloneToNative(l, e, t, n, r, i, s, o), l;
            }
        }, {
            key: "_cloneToNative",
            value: function(e, t, n, r, i, a, o, s) {
                var l = e;
                l.name = this.name;
                for (var u = 0, c = this._children.length; u < c; u++) {
                    var h = this._children[u];
                    s._nativeCurCloneCount++;
                    var _ = h._cloneNative(t, n, r, i, a, o, s);
                    l.addChild(_);
                    var d = h.transform, f = _.transform, m = f.localPosition, T = f.localRotation, p = f.localScale;
                    d.localPosition.cloneTo(m), d.localRotation.cloneTo(T), d.localScale.cloneTo(p), 
                    f.localPosition = m, f.localRotation = T, f.localScale = p;
                }
            }
        } ]), AnimationNode;
    }(), fe = function(e) {
        function Avatar() {
            var e;
            return _classCallCheck(this, Avatar), (e = _possibleConstructorReturn(this, _getPrototypeOf(Avatar).call(this)))._nativeNodeCount = 0, 
            e._nativeCurCloneCount = 0, e;
        }
        return _inherits(Avatar, t.Resource), _createClass(Avatar, [ {
            key: "_initCloneToAnimator",
            value: function(e, t) {
                t._avatarNodeMap[e.name] = e;
                for (var n = 0, r = e.getChildCount(); n < r; n++) this._initCloneToAnimator(e.getChildByIndex(n), t);
            }
        }, {
            key: "_parseNode",
            value: function(e, n) {
                var r = e.props.name;
                n.name = r;
                var i = e.props, a = n.transform, o = a.localPosition, s = a.localRotation, l = a.localScale;
                o.fromArray(i.translate), s.fromArray(i.rotation), l.fromArray(i.scale), a.localPosition = o, 
                a.localRotation = s, a.localScale = l;
                for (var u = e.child, c = 0, h = u.length; c < h; c++) {
                    var _ = u[c], d = new de(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                    n.addChild(d), t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(_, d);
                }
            }
        }, {
            key: "_cloneDatasToAnimator",
            value: function(e) {
                var t;
                t = this._rootNode.clone();
                var n = this._rootNode.transform, r = t.transform, i = r.localPosition, a = r.localRotation, o = r.localScale;
                n.localPosition.cloneTo(i), n.localRotation.cloneTo(a), n.localScale.cloneTo(o), 
                r.localPosition = i, r.localRotation = a, r.localScale = o, e._avatarNodeMap = {}, 
                this._initCloneToAnimator(t, e);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e, n = this._rootNode.clone();
                t._rootNode = n;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Avatar();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_cloneDatasToAnimatorNative",
            value: function(e) {
                var t = new Float32Array(3 * this._nativeNodeCount), n = new Float32Array(4 * this._nativeNodeCount), r = new Float32Array(3 * this._nativeNodeCount), i = new Float32Array(16 * this._nativeNodeCount), a = new Int16Array(this._nativeNodeCount);
                e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = n, e._animationNodeLocalScales = r, 
                e._animationNodeWorldMatrixs = i, e._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
                var o = this._rootNode._cloneNative(t, n, r, i, a, -1, this), s = this._rootNode.transform, l = o.transform, u = l.localPosition, c = l.localRotation, h = l.localScale;
                s.localPosition.cloneTo(u), s.localRotation.cloneTo(c), s.localScale.cloneTo(h), 
                l.localPosition = u, l.localRotation = c, l.localScale = h, e._avatarNodeMap = {}, 
                this._initCloneToAnimator(o, e);
            }
        } ], [ {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var n = new Avatar();
                if (n._rootNode = new de(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)), 
                t.Render.supportWebGLPlusAnimation && n._nativeNodeCount++, e.version) {
                    var r = e.rootNode;
                    r && n._parseNode(r, n._rootNode);
                }
                return n;
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.ILaya.loader.create(e, n, null, Avatar.AVATAR);
            }
        } ]), Avatar;
    }();
    fe.AVATAR = "AVATAR";
    var me = function(e) {
        function Material() {
            var e;
            return _classCallCheck(this, Material), (e = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)))._shaderValues = null, 
            e._shaderValues = new ce(_assertThisInitialized(e)), e.renderQueue = Material.RENDERQUEUE_OPAQUE, 
            e._alphaTest = !1, e;
        }
        return _inherits(Material, t.Resource), _createClass(Material, [ {
            key: "_removeTetxureReference",
            value: function() {
                var e = this._shaderValues.getData();
                for (var n in e) {
                    var r = e[n];
                    r && r instanceof t.BaseTexture && r._removeReference();
                }
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
            }
        }, {
            key: "_addReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_addReference", this).call(this, e);
                var n = this._shaderValues.getData();
                for (var r in n) {
                    var i = n[r];
                    i && i instanceof t.BaseTexture && i._addReference();
                }
            }
        }, {
            key: "_removeReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_removeReference", this).call(this, e), 
                this._removeTetxureReference();
            }
        }, {
            key: "setShaderName",
            value: function(e) {
                if (this._shader = ue.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name, t.renderQueue = this.renderQueue, this._shaderValues.cloneTo(t._shaderValues);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Material();
                return this.cloneTo(e), e;
            }
        }, {
            key: "shaderData",
            get: function() {
                return this._shaderValues;
            }
        }, {
            key: "alphaTestValue",
            get: function() {
                return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Material.ALPHATESTVALUE, e);
            }
        }, {
            key: "alphaTest",
            get: function() {
                return this._alphaTest;
            },
            set: function(e) {
                this._alphaTest = e, e ? this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
            }
        }, {
            key: "_defineDatas",
            get: function() {
                return this._shaderValues._defineDatas;
            }
        } ], [ {
            key: "load",
            value: function(e, n) {
                t.Laya.loader.create(e, n, null, Material.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                Material.SHADERDEFINE_ALPHATEST = ue.getDefineByName("ALPHATEST");
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var n, a = e, s = a.props, l = s.type, u = t.ClassUtils.getRegClass(l);
                if (!u) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
                switch (n = new u(), a.version) {
                  case "LAYAMATERIAL:01":
                  case "LAYAMATERIAL:02":
                    var c, h;
                    for (var _ in s) switch (_) {
                      case "type":
                        break;

                      case "vectors":
                        var d = s[_];
                        for (c = 0, h = d.length; c < h; c++) {
                            var f = d[c], m = f.value;
                            switch (m.length) {
                              case 2:
                                n[f.name] = new r(m[0], m[1]);
                                break;

                              case 3:
                                n[f.name] = new o(m[0], m[1], m[2]);
                                break;

                              case 4:
                                n[f.name] = new i(m[0], m[1], m[2], m[3]);
                                break;

                              default:
                                throw new Error("BaseMaterial:unkonwn color length.");
                            }
                        }
                        break;

                      case "textures":
                        var T = s[_];
                        for (c = 0, h = T.length; c < h; c++) {
                            var p = T[c], g = p.path;
                            g && (n[p.name] = t.Loader.getRes(g));
                        }
                        break;

                      case "defines":
                        var E = s[_];
                        for (c = 0, h = E.length; c < h; c++) {
                            var y = ue.getDefineByName(E[c]);
                            n._shaderValues.addDefine(y);
                        }
                        break;

                      case "renderStates":
                        var v = s[_][0], S = n;
                        S.blend = v.blend, S.cull = v.cull, S.depthTest = v.depthTest, S.depthWrite = v.depthWrite, 
                        S.blendSrc = v.srcBlend, S.blendDst = v.dstBlend;
                        break;

                      case "cull":
                        n.cull = s[_];
                        break;

                      case "blend":
                        n.blend = s[_];
                        break;

                      case "depthWrite":
                        n.depthWrite = s[_];
                        break;

                      case "srcBlend":
                        n.blendSrc = s[_];
                        break;

                      case "dstBlend":
                        n.blendDst = s[_];
                        break;

                      default:
                        n[_] = s[_];
                    }
                    break;

                  default:
                    throw new Error("BaseMaterial:unkonwn version.");
                }
                return n;
            }
        } ]), Material;
    }();
    me.MATERIAL = "MATERIAL", me.RENDERQUEUE_OPAQUE = 2e3, me.RENDERQUEUE_ALPHATEST = 2450, 
    me.RENDERQUEUE_TRANSPARENT = 3e3, me.ALPHATESTVALUE = ue.propertyNameToID("u_AlphaTestValue"), 
    me.SHADERDEFINE_ALPHATEST = null;
    var Te = function() {
        function BaseMaterial() {
            _classCallCheck(this, BaseMaterial);
        }
        return _createClass(BaseMaterial, null, [ {
            key: "load",
            value: function(e, n) {
                t.Laya.loader.create(e, n, null, me.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                BaseMaterial.SHADERDEFINE_ALPHATEST = me.SHADERDEFINE_ALPHATEST;
            }
        } ]), BaseMaterial;
    }();
    Te.MATERIAL = "MATERIAL", Te.RENDERQUEUE_OPAQUE = 2e3, Te.RENDERQUEUE_ALPHATEST = 2450, 
    Te.RENDERQUEUE_TRANSPARENT = 3e3, Te.ALPHATESTVALUE = ue.propertyNameToID("u_AlphaTestValue"), 
    Te.SHADERDEFINE_ALPHATEST = null;
    var pe = function() {
        function RenderState() {
            _classCallCheck(this, RenderState), this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE, 
            this.srcBlend = RenderState.BLENDPARAM_ONE, this.dstBlend = RenderState.BLENDPARAM_ZERO, 
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE, this.dstBlendRGB = RenderState.BLENDPARAM_ZERO, 
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE, this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO, 
            this.blendConstColor = new i(1, 1, 1, 1), this.blendEquation = RenderState.BLENDEQUATION_ADD, 
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD, this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD, 
            this.depthTest = RenderState.DEPTHTEST_LEQUAL, this.depthWrite = !0;
        }
        return _createClass(RenderState, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend, 
                t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha, 
                t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor), 
                t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB, 
                t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new RenderState();
                return this.cloneTo(e), e;
            }
        } ]), RenderState;
    }();
    pe.CULL_NONE = 0, pe.CULL_FRONT = 1, pe.CULL_BACK = 2, pe.BLEND_DISABLE = 0, pe.BLEND_ENABLE_ALL = 1, 
    pe.BLEND_ENABLE_SEPERATE = 2, pe.BLENDPARAM_ZERO = 0, pe.BLENDPARAM_ONE = 1, pe.BLENDPARAM_SRC_COLOR = 768, 
    pe.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, pe.BLENDPARAM_DST_COLOR = 774, pe.BLENDPARAM_ONE_MINUS_DST_COLOR = 775, 
    pe.BLENDPARAM_SRC_ALPHA = 770, pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, pe.BLENDPARAM_DST_ALPHA = 772, 
    pe.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, pe.BLENDPARAM_SRC_ALPHA_SATURATE = 776, 
    pe.BLENDEQUATION_ADD = 32774, pe.BLENDEQUATION_SUBTRACT = 32778, pe.BLENDEQUATION_REVERSE_SUBTRACT = 32779, 
    pe.DEPTHTEST_OFF = 0, pe.DEPTHTEST_NEVER = 512, pe.DEPTHTEST_LESS = 513, pe.DEPTHTEST_EQUAL = 514, 
    pe.DEPTHTEST_LEQUAL = 515, pe.DEPTHTEST_GREATER = 516, pe.DEPTHTEST_NOTEQUAL = 517, 
    pe.DEPTHTEST_GEQUAL = 518, pe.DEPTHTEST_ALWAYS = 519;
    var ge = function(e) {
        function BlinnPhongMaterial() {
            var e;
            _classCallCheck(this, BlinnPhongMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(BlinnPhongMaterial).call(this)))._enableVertexColor = !1, 
            e.setShaderName("BLINNPHONG"), e._albedoIntensity = 1, e._albedoColor = new i(1, 1, 1, 1);
            var t = e._shaderValues;
            return t.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), t.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new i(1, 1, 1, 1)), 
            t.setNumber(BlinnPhongMaterial.SHININESS, .078125), t.setNumber(me.ALPHATESTVALUE, .5), 
            t.setVector(BlinnPhongMaterial.TILINGOFFSET, new i(1, 1, 0, 0)), e._enableLighting = !0, 
            e.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE, e;
        }
        return _inherits(BlinnPhongMaterial, me), _createClass(BlinnPhongMaterial, [ {
            key: "clone",
            value: function() {
                var e = new BlinnPhongMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t._enableLighting = this._enableLighting, t._albedoIntensity = this._albedoIntensity, 
                t._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(t._albedoColor);
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_Color",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
            },
            set: function(e) {
                this.albedoColor = e;
            }
        }, {
            key: "_SpecColorR",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = e;
            }
        }, {
            key: "_SpecColorG",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = e;
            }
        }, {
            key: "_SpecColorB",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = e;
            }
        }, {
            key: "_SpecColorA",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = e;
            }
        }, {
            key: "_SpecColor",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
            },
            set: function(e) {
                this.specularColor = e;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_Shininess",
            get: function() {
                return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
            },
            set: function(e) {
                e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, e);
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_ST",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            },
            set: function(e) {
                this.tilingOffset = e;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = me.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = me.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  default:
                    throw new Error("Material:renderMode value error.");
                }
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "specularColorR",
            get: function() {
                return this._SpecColorR;
            },
            set: function(e) {
                this._SpecColorR = e;
            }
        }, {
            key: "specularColorG",
            get: function() {
                return this._SpecColorG;
            },
            set: function(e) {
                this._SpecColorG = e;
            }
        }, {
            key: "specularColorB",
            get: function() {
                return this._SpecColorB;
            },
            set: function(e) {
                this._SpecColorB = e;
            }
        }, {
            key: "specularColorA",
            get: function() {
                return this._SpecColorA;
            },
            set: function(e) {
                this._SpecColorA = e;
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
            },
            set: function(e) {
                this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, e);
            }
        }, {
            key: "shininess",
            get: function() {
                return this._Shininess;
            },
            set: function(e) {
                this._Shininess = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP), 
                this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP), 
                this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP), 
                this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = ue.getDefineByName("DIFFUSEMAP"), BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = ue.getDefineByName("NORMALMAP"), 
                BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = ue.getDefineByName("SPECULARMAP"), 
                BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET"), 
                BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = ue.getDefineByName("ENABLEVERTEXCOLOR");
            }
        } ]), BlinnPhongMaterial;
    }();
    ge.RENDERMODE_OPAQUE = 0, ge.RENDERMODE_CUTOUT = 1, ge.RENDERMODE_TRANSPARENT = 2, 
    ge.ALBEDOTEXTURE = ue.propertyNameToID("u_DiffuseTexture"), ge.NORMALTEXTURE = ue.propertyNameToID("u_NormalTexture"), 
    ge.SPECULARTEXTURE = ue.propertyNameToID("u_SpecularTexture"), ge.ALBEDOCOLOR = ue.propertyNameToID("u_DiffuseColor"), 
    ge.MATERIALSPECULAR = ue.propertyNameToID("u_MaterialSpecular"), ge.SHININESS = ue.propertyNameToID("u_Shininess"), 
    ge.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), ge.CULL = ue.propertyNameToID("s_Cull"), 
    ge.BLEND = ue.propertyNameToID("s_Blend"), ge.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), 
    ge.BLEND_DST = ue.propertyNameToID("s_BlendDst"), ge.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), 
    ge.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var Ee = function(e) {
        function EffectMaterial() {
            var e;
            return _classCallCheck(this, EffectMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(EffectMaterial).call(this))).setShaderName("Effect"), 
            e._color = new i(1, 1, 1, 1), e._shaderValues.setVector(EffectMaterial.TINTCOLOR, new i(1, 1, 1, 1)), 
            e.renderMode = EffectMaterial.RENDERMODE_ADDTIVE, e;
        }
        return _inherits(EffectMaterial, me), _createClass(EffectMaterial, [ {
            key: "clone",
            value: function() {
                var e = new EffectMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case EffectMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_NONE, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE, this.depthTest = pe.DEPTHTEST_LESS, this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  case EffectMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_NONE, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  default:
                    throw new Error("MeshEffectMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(EffectMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE), 
                this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                EffectMaterial.SHADERDEFINE_MAINTEXTURE = ue.getDefineByName("MAINTEXTURE"), EffectMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET"), 
                EffectMaterial.SHADERDEFINE_ADDTIVEFOG = ue.getDefineByName("ADDTIVEFOG");
            }
        } ]), EffectMaterial;
    }();
    Ee.RENDERMODE_ADDTIVE = 0, Ee.RENDERMODE_ALPHABLENDED = 1, Ee.MAINTEXTURE = ue.propertyNameToID("u_AlbedoTexture"), 
    Ee.TINTCOLOR = ue.propertyNameToID("u_AlbedoColor"), Ee.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), 
    Ee.CULL = ue.propertyNameToID("s_Cull"), Ee.BLEND = ue.propertyNameToID("s_Blend"), 
    Ee.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), Ee.BLEND_DST = ue.propertyNameToID("s_BlendDst"), 
    Ee.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), Ee.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var ye, ve = function(e) {
        function ExtendTerrainMaterial() {
            var e;
            return _classCallCheck(this, ExtendTerrainMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(ExtendTerrainMaterial).call(this)))._enableLighting = !0, 
            e.setShaderName("ExtendTerrain"), e.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE, 
            e;
        }
        return _inherits(ExtendTerrainMaterial, me), _createClass(ExtendTerrainMaterial, [ {
            key: "_setDetailNum",
            value: function(e) {
                switch (e) {
                  case 1:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;

                  case 2:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;

                  case 3:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;

                  case 4:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;

                  case 5:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                }
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ExtendTerrainMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "splatAlphaTexture",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, e);
            }
        }, {
            key: "diffuseTexture1",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, e), this._setDetailNum(1);
            }
        }, {
            key: "diffuseTexture2",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, e), this._setDetailNum(2);
            }
        }, {
            key: "diffuseTexture3",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, e), this._setDetailNum(3);
            }
        }, {
            key: "diffuseTexture4",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, e), this._setDetailNum(4);
            }
        }, {
            key: "diffuseTexture5",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, e), this._setDetailNum(5);
            }
        }, {
            key: "diffuseScaleOffset1",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, e);
            }
        }, {
            key: "diffuseScaleOffset2",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, e);
            }
        }, {
            key: "diffuseScaleOffset3",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, e);
            }
        }, {
            key: "diffuseScaleOffset4",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, e);
            }
        }, {
            key: "diffuseScaleOffset5",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, e);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                    this.renderQueue = me.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = pe.CULL_BACK, 
                    this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = me.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = pe.CULL_BACK, 
                    this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, 
                    this.depthTest = pe.DEPTHTEST_LEQUAL;
                    break;

                  default:
                    throw new Error("ExtendTerrainMaterial:renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = ue.getDefineByName("ExtendTerrain_DETAIL_NUM1"), 
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = ue.getDefineByName("ExtendTerrain_DETAIL_NUM2"), 
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = ue.getDefineByName("ExtendTerrain_DETAIL_NUM3"), 
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = ue.getDefineByName("ExtendTerrain_DETAIL_NUM4"), 
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = ue.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            }
        } ]), ExtendTerrainMaterial;
    }();
    ve.RENDERMODE_OPAQUE = 1, ve.RENDERMODE_TRANSPARENT = 2, ve.SPLATALPHATEXTURE = ue.propertyNameToID("u_SplatAlphaTexture"), 
    ve.DIFFUSETEXTURE1 = ue.propertyNameToID("u_DiffuseTexture1"), ve.DIFFUSETEXTURE2 = ue.propertyNameToID("u_DiffuseTexture2"), 
    ve.DIFFUSETEXTURE3 = ue.propertyNameToID("u_DiffuseTexture3"), ve.DIFFUSETEXTURE4 = ue.propertyNameToID("u_DiffuseTexture4"), 
    ve.DIFFUSETEXTURE5 = ue.propertyNameToID("u_DiffuseTexture5"), ve.DIFFUSESCALEOFFSET1 = ue.propertyNameToID("u_DiffuseScaleOffset1"), 
    ve.DIFFUSESCALEOFFSET2 = ue.propertyNameToID("u_DiffuseScaleOffset2"), ve.DIFFUSESCALEOFFSET3 = ue.propertyNameToID("u_DiffuseScaleOffset3"), 
    ve.DIFFUSESCALEOFFSET4 = ue.propertyNameToID("u_DiffuseScaleOffset4"), ve.DIFFUSESCALEOFFSET5 = ue.propertyNameToID("u_DiffuseScaleOffset5"), 
    ve.CULL = ue.propertyNameToID("s_Cull"), ve.BLEND = ue.propertyNameToID("s_Blend"), 
    ve.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), ve.BLEND_DST = ue.propertyNameToID("s_BlendDst"), 
    ve.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), ve.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite"), 
    (ye = e.PBRRenderMode || (e.PBRRenderMode = {}))[ye.Opaque = 0] = "Opaque", ye[ye.Cutout = 1] = "Cutout", 
    ye[ye.Fade = 2] = "Fade", ye[ye.Transparent = 3] = "Transparent";
    var Se = function(t) {
        function PBRMaterial() {
            var t;
            return _classCallCheck(this, PBRMaterial), (t = _possibleConstructorReturn(this, _getPrototypeOf(PBRMaterial).call(this)))._enableEmission = !1, 
            t._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), t._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, new i(1, 1, 1, 1)), 
            t._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, .5), t._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, 1), 
            t._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, 1), t._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1), 
            t._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, .001), t._shaderValues.setNumber(me.ALPHATESTVALUE, .5), 
            t.renderMode = e.PBRRenderMode.Opaque, t;
        }
        return _inherits(PBRMaterial, me), _createClass(PBRMaterial, [ {
            key: "albedoColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.ALBEDOCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, e);
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE), 
                this._shaderValues.setTexture(PBRMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE), 
                this._shaderValues.setTexture(PBRMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "normalTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, e);
            }
        }, {
            key: "parallaxTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE), 
                this._shaderValues.setTexture(PBRMaterial.PARALLAXTEXTURE, e);
            }
        }, {
            key: "parallaxTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(.005, Math.min(.08, e)));
            }
        }, {
            key: "occlusionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE), 
                this._shaderValues.setTexture(PBRMaterial.OCCLUSIONTEXTURE, e);
            }
        }, {
            key: "occlusionTextureStrength",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothness",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESSSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "enableEmission",
            get: function() {
                return this._enableEmission;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSION), 
                this._enableEmission = e;
            }
        }, {
            key: "emissionColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.EMISSIONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, e);
            }
        }, {
            key: "emissionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE), 
                this._shaderValues.setTexture(PBRMaterial.EMISSIONTEXTURE, e);
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(PBRMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(PBRMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.DEPTH_TEST, e);
            }
        }, {
            key: "renderMode",
            set: function(t) {
                switch (t) {
                  case e.PBRRenderMode.Opaque:
                    this.alphaTest = !1, this.renderQueue = me.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;

                  case e.PBRRenderMode.Cutout:
                    this.renderQueue = me.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;

                  case e.PBRRenderMode.Fade:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;

                  case e.PBRRenderMode.Transparent:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_ONE, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;

                  default:
                    throw new Error("PBRMaterial:unknown renderMode value.");
                }
            }
        }, {
            key: "enableReflection",
            get: function() {
                return !0;
            },
            set: function(e) {}
        } ], [ {
            key: "__init__",
            value: function() {
                PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = ue.getDefineByName("ALBEDOTEXTURE"), PBRMaterial.SHADERDEFINE_NORMALTEXTURE = ue.getDefineByName("NORMALTEXTURE"), 
                PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = ue.getDefineByName("PARALLAXTEXTURE"), 
                PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = ue.getDefineByName("OCCLUSIONTEXTURE"), 
                PBRMaterial.SHADERDEFINE_EMISSION = ue.getDefineByName("EMISSION"), PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = ue.getDefineByName("EMISSIONTEXTURE"), 
                PBRMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET"), PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND = ue.getDefineByName("TRANSPARENTBLEND"), 
                PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = ue.getDefineByName("LAYA_PBR_BRDF_HIGH"), 
                PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = ue.getDefineByName("LAYA_PBR_BRDF_LOW");
            }
        } ]), PBRMaterial;
    }();
    Se.ALBEDOTEXTURE = ue.propertyNameToID("u_AlbedoTexture"), Se.ALBEDOCOLOR = ue.propertyNameToID("u_AlbedoColor"), 
    Se.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), Se.NORMALTEXTURE = ue.propertyNameToID("u_NormalTexture"), 
    Se.NORMALSCALE = ue.propertyNameToID("u_NormalScale"), Se.SMOOTHNESS = ue.propertyNameToID("u_Smoothness"), 
    Se.SMOOTHNESSSCALE = ue.propertyNameToID("u_SmoothnessScale"), Se.OCCLUSIONTEXTURE = ue.propertyNameToID("u_OcclusionTexture"), 
    Se.OCCLUSIONSTRENGTH = ue.propertyNameToID("u_occlusionStrength"), Se.PARALLAXTEXTURE = ue.propertyNameToID("u_ParallaxTexture"), 
    Se.PARALLAXSCALE = ue.propertyNameToID("u_ParallaxScale"), Se.EMISSIONTEXTURE = ue.propertyNameToID("u_EmissionTexture"), 
    Se.EMISSIONCOLOR = ue.propertyNameToID("u_EmissionColor"), Se.CULL = ue.propertyNameToID("s_Cull"), 
    Se.BLEND = ue.propertyNameToID("s_Blend"), Se.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), 
    Se.BLEND_DST = ue.propertyNameToID("s_BlendDst"), Se.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), 
    Se.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite"), Se.renderQuality = e.PBRRenderQuality.High;
    var Ce = function ShaderVariable() {
        _classCallCheck(this, ShaderVariable), this.textureID = -1;
    }, Re = function(e) {
        function ShaderInstance(e, t, n, r, i) {
            var a;
            return _classCallCheck(this, ShaderInstance), (a = _possibleConstructorReturn(this, _getPrototypeOf(ShaderInstance).call(this)))._stateParamsMap = [], 
            a._uploadMark = -1, a._uploadRenderType = -1, a._vs = e, a._ps = t, a._attributeMap = n, 
            a._uniformMap = r, a._shaderPass = i, a._create(), a.lock = !0, a;
        }
        return _inherits(ShaderInstance, t.Resource), _createClass(ShaderInstance, [ {
            key: "_create",
            value: function() {
                var e = t.LayaGL.instance;
                for (var n in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER), 
                this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this._program, this._vshader), 
                e.attachShader(this._program, this._pshader), this._attributeMap) e.bindAttribLocation(this._program, this._attributeMap[n], n);
                if (e.linkProgram(this._program), !t.Render.isConchApp && ue.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS)) throw e.getProgramInfoLog(this._program);
                var r = [], i = [], a = [], o = [], s = [];
                this._customUniformParamsMap = [];
                var l, u, c, h = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
                for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, u = 0; u < h; u++) {
                    var _ = e.getActiveUniform(this._program, u), d = _.name;
                    (l = new Ce()).location = e.getUniformLocation(this._program, d), d.indexOf("[0]") > 0 ? (l.name = d = d.substr(0, d.length - 3), 
                    l.isArray = !0) : (l.name = d, l.isArray = !1), l.type = _.type, this._addShaderUnifiormFun(l);
                    var f = this._uniformMap[d];
                    if (null != f) switch (l.dataOffset = ue.propertyNameToID(d), f) {
                      case ue.PERIOD_CUSTOM:
                        s.push(l);
                        break;

                      case ue.PERIOD_MATERIAL:
                        o.push(l);
                        break;

                      case ue.PERIOD_SPRITE:
                        a.push(l);
                        break;

                      case ue.PERIOD_CAMERA:
                        i.push(l);
                        break;

                      case ue.PERIOD_SCENE:
                        r.push(l);
                        break;

                      default:
                        throw new Error("Shader3D: period is unkonw.");
                    }
                }
                for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * r.length * 5 + 4, 64, !0), 
                u = 0, c = r.length; u < c; u++) this._sceneUniformParamsMap.addShaderUniform(r[u]);
                for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0), 
                u = 0, c = i.length; u < c; u++) this._cameraUniformParamsMap.addShaderUniform(i[u]);
                for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0), 
                u = 0, c = a.length; u < c; u++) this._spriteUniformParamsMap.addShaderUniform(a[u]);
                for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * o.length * 5 + 4, 64, !0), 
                u = 0, c = o.length; u < c; u++) this._materialUniformParamsMap.addShaderUniform(o[u]);
                for (this._customUniformParamsMap.length = s.length, u = 0, c = s.length; u < c; u++) {
                    var m = s[u];
                    this._customUniformParamsMap[m.dataOffset] = m;
                }
                var T = this._shaderPass._stateMap;
                for (var p in T) this._stateParamsMap[T[p]] = ue.propertyNameToID(p);
            }
        }, {
            key: "_getRenderState",
            value: function(e, t) {
                var n = this._stateParamsMap[t];
                return null == n ? null : e[n];
            }
        }, {
            key: "_disposeResource",
            value: function() {
                t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(this._pshader), 
                t.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null, 
                this._setGPUMemory(0), this._curActTexIndex = 0;
            }
        }, {
            key: "_addShaderUnifiormFun",
            value: function(e) {
                var n = t.LayaGL.instance;
                e.caller = this;
                var r = e.isArray;
                switch (e.type) {
                  case n.BOOL:
                    e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                    break;

                  case n.INT:
                    e.fun = r ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                    break;

                  case n.FLOAT:
                    e.fun = r ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                    break;

                  case n.FLOAT_VEC2:
                    e.fun = r ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                    break;

                  case n.FLOAT_VEC3:
                    e.fun = r ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                    break;

                  case n.FLOAT_VEC4:
                    e.fun = r ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                    break;

                  case n.FLOAT_MAT2:
                    e.fun = this._uniformMatrix2fv;
                    break;

                  case n.FLOAT_MAT3:
                    e.fun = this._uniformMatrix3fv;
                    break;

                  case n.FLOAT_MAT4:
                    e.fun = r ? this._uniformMatrix4fv : this._uniformMatrix4f;
                    break;

                  case n.SAMPLER_2D:
                  case n.SAMPLER_2D_SHADOW:
                    n.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                    e.fun = this._uniform_sampler2D;
                    break;

                  case 35679:
                    n.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                    e.fun = this._uniform_sampler3D;
                    break;

                  case n.SAMPLER_CUBE:
                    n.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                    e.fun = this._uniform_samplerCube;
                    break;

                  default:
                    throw new Error("compile shader err!");
                }
            }
        }, {
            key: "_createShader",
            value: function(e, t, n) {
                var r = e.createShader(n);
                if (e.shaderSource(r, t), e.compileShader(r), ue.debugMode && !e.getShaderParameter(r, e.COMPILE_STATUS)) throw e.getShaderInfoLog(r);
                return r;
            }
        }, {
            key: "_uniform1f",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n ? (t.LayaGL.instance.uniform1f(e.location, r[0] = n), 1) : 0;
            }
        }, {
            key: "_uniform1fv",
            value: function(e, n) {
                if (n.length < 4) {
                    var r = e.uploadedValue;
                    return r[0] !== n[0] || r[1] !== n[1] || r[2] !== n[2] || r[3] !== n[3] ? (t.LayaGL.instance.uniform1fv(e.location, n), 
                    r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = n[3], 1) : 0;
                }
                return t.LayaGL.instance.uniform1fv(e.location, n), 1;
            }
        }, {
            key: "_uniform_vec2",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n.x || r[1] !== n.y ? (t.LayaGL.instance.uniform2f(e.location, r[0] = n.x, r[1] = n.y), 
                1) : 0;
            }
        }, {
            key: "_uniform_vec2v",
            value: function(e, n) {
                if (n.length < 2) {
                    var r = e.uploadedValue;
                    return r[0] !== n[0] || r[1] !== n[1] || r[2] !== n[2] || r[3] !== n[3] ? (t.LayaGL.instance.uniform2fv(e.location, n), 
                    r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = n[3], 1) : 0;
                }
                return t.LayaGL.instance.uniform2fv(e.location, n), 1;
            }
        }, {
            key: "_uniform_vec3",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n.x || r[1] !== n.y || r[2] !== n.z ? (t.LayaGL.instance.uniform3f(e.location, r[0] = n.x, r[1] = n.y, r[2] = n.z), 
                1) : 0;
            }
        }, {
            key: "_uniform_vec3v",
            value: function(e, n) {
                return t.LayaGL.instance.uniform3fv(e.location, n), 1;
            }
        }, {
            key: "_uniform_vec4",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n.x || r[1] !== n.y || r[2] !== n.z || r[3] !== n.w ? (t.LayaGL.instance.uniform4f(e.location, r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = n.w), 
                1) : 0;
            }
        }, {
            key: "_uniform_vec4v",
            value: function(e, n) {
                return t.LayaGL.instance.uniform4fv(e.location, n), 1;
            }
        }, {
            key: "_uniformMatrix2fv",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, n), 1;
            }
        }, {
            key: "_uniformMatrix3fv",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, n), 1;
            }
        }, {
            key: "_uniformMatrix4f",
            value: function(e, n) {
                var r = n.elements;
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1;
            }
        }, {
            key: "_uniformMatrix4fv",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, n), 1;
            }
        }, {
            key: "_uniform1i",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n ? (t.LayaGL.instance.uniform1i(e.location, r[0] = n), 1) : 0;
            }
        }, {
            key: "_uniform1iv",
            value: function(e, n) {
                return t.LayaGL.instance.uniform1iv(e.location, n), 1;
            }
        }, {
            key: "_uniform_ivec2",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n[0] || r[1] !== n[1] ? (t.LayaGL.instance.uniform2i(e.location, r[0] = n[0], r[1] = n[1]), 
                1) : 0;
            }
        }, {
            key: "_uniform_ivec2v",
            value: function(e, n) {
                return t.LayaGL.instance.uniform2iv(e.location, n), 1;
            }
        }, {
            key: "_uniform_vec3i",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n[0] || r[1] !== n[1] || r[2] !== n[2] ? (t.LayaGL.instance.uniform3i(e.location, r[0] = n[0], r[1] = n[1], r[2] = n[2]), 
                1) : 0;
            }
        }, {
            key: "_uniform_vec3vi",
            value: function(e, n) {
                return t.LayaGL.instance.uniform3iv(e.location, n), 1;
            }
        }, {
            key: "_uniform_vec4i",
            value: function(e, n) {
                var r = e.uploadedValue;
                return r[0] !== n[0] || r[1] !== n[1] || r[2] !== n[2] || r[3] !== n[3] ? (t.LayaGL.instance.uniform4i(e.location, r[0] = n[0], r[1] = n[1], r[2] = n[2], r[3] = n[3]), 
                1) : 0;
            }
        }, {
            key: "_uniform_vec4vi",
            value: function(e, n) {
                return t.LayaGL.instance.uniform4iv(e.location, n), 1;
            }
        }, {
            key: "_uniform_sampler2D",
            value: function(e, n) {
                var r = n._getSource() || n.defaulteTexture._getSource(), i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, i.TEXTURE_2D, r), 
                0;
            }
        }, {
            key: "_uniform_sampler3D",
            value: function(e, n) {
                var r = n._getSource() || n.defaulteTexture._getSource(), i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, WebGL2RenderingContext.TEXTURE_3D, r), 
                0;
            }
        }, {
            key: "_uniform_samplerCube",
            value: function(e, n) {
                var r = n._getSource() || n.defaulteTexture._getSource(), i = t.LayaGL.instance;
                return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, i.TEXTURE_CUBE_MAP, r), 
                0;
            }
        }, {
            key: "bind",
            value: function() {
                return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
            }
        }, {
            key: "uploadUniforms",
            value: function(e, n, r) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, n, r);
            }
        }, {
            key: "uploadRenderStateBlendDepth",
            value: function(e) {
                var n = t.LayaGL.instance, r = this._shaderPass.renderState, i = e.getData(), a = this._getRenderState(i, ue.RENDER_STATE_DEPTH_WRITE), o = this._getRenderState(i, ue.RENDER_STATE_DEPTH_TEST), s = this._getRenderState(i, ue.RENDER_STATE_BLEND);
                switch (null == a && (a = r.depthWrite), null == o && (o = r.depthTest), null == s && (s = r.blend), 
                t.WebGLContext.setDepthMask(n, a), o === pe.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(n, !1) : (t.WebGLContext.setDepthTest(n, !0), 
                t.WebGLContext.setDepthFunc(n, o)), s) {
                  case pe.BLEND_DISABLE:
                    t.WebGLContext.setBlend(n, !1);
                    break;

                  case pe.BLEND_ENABLE_ALL:
                    var l = this._getRenderState(i, ue.RENDER_STATE_BLEND_EQUATION), u = this._getRenderState(i, ue.RENDER_STATE_BLEND_SRC), c = this._getRenderState(i, ue.RENDER_STATE_BLEND_DST);
                    null == l && (l = r.blendEquation), null == u && (u = r.srcBlend), null == c && (c = r.dstBlend), 
                    t.WebGLContext.setBlend(n, !0), t.WebGLContext.setBlendEquation(n, l), t.WebGLContext.setBlendFunc(n, u, c);
                    break;

                  case pe.BLEND_ENABLE_SEPERATE:
                    var h = this._getRenderState(i, ue.RENDER_STATE_BLEND_EQUATION_RGB), _ = this._getRenderState(i, ue.RENDER_STATE_BLEND_EQUATION_ALPHA), d = this._getRenderState(i, ue.RENDER_STATE_BLEND_SRC_RGB), f = this._getRenderState(i, ue.RENDER_STATE_BLEND_DST_RGB), m = this._getRenderState(i, ue.RENDER_STATE_BLEND_SRC_ALPHA), T = this._getRenderState(i, ue.RENDER_STATE_BLEND_DST_ALPHA);
                    null == h && (h = r.blendEquationRGB), null == _ && (_ = r.blendEquationAlpha), 
                    null == d && (d = r.srcBlendRGB), null == f && (f = r.dstBlendRGB), null == m && (m = r.srcBlendAlpha), 
                    null == T && (T = r.dstBlendAlpha), t.WebGLContext.setBlend(n, !0), t.WebGLContext.setBlendEquationSeparate(n, h, _), 
                    t.WebGLContext.setBlendFuncSeperate(n, d, f, m, T);
                }
            }
        }, {
            key: "uploadRenderStateFrontFace",
            value: function(e, n, r) {
                var i, a = t.LayaGL.instance, o = this._shaderPass.renderState, s = e.getData(), l = this._getRenderState(s, ue.RENDER_STATE_CULL);
                switch (null == l && (l = o.cull), l) {
                  case pe.CULL_NONE:
                    t.WebGLContext.setCullFace(a, !1);
                    break;

                  case pe.CULL_FRONT:
                    t.WebGLContext.setCullFace(a, !0), i = n ? r ? a.CCW : a.CW : r ? a.CW : a.CCW, 
                    t.WebGLContext.setFrontFace(a, i);
                    break;

                  case pe.CULL_BACK:
                    t.WebGLContext.setCullFace(a, !0), i = n ? r ? a.CW : a.CCW : r ? a.CCW : a.CW, 
                    t.WebGLContext.setFrontFace(a, i);
                }
            }
        }, {
            key: "uploadCustomUniform",
            value: function(e, n) {
                t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, n);
            }
        }, {
            key: "_uniformMatrix2fvForNative",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, n), 1;
            }
        }, {
            key: "_uniformMatrix3fvForNative",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, n), 1;
            }
        }, {
            key: "_uniformMatrix4fvForNative",
            value: function(e, n) {
                return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, n), 1;
            }
        } ]), ShaderInstance;
    }(), De = function(e) {
        function SimpleSingletonList() {
            return _classCallCheck(this, SimpleSingletonList), _possibleConstructorReturn(this, _getPrototypeOf(SimpleSingletonList).call(this));
        }
        return _inherits(SimpleSingletonList, C), _createClass(SimpleSingletonList, [ {
            key: "add",
            value: function(e) {
                if (-1 !== e._getIndexInList()) throw "SimpleSingletonList:" + e + " has  in  SingletonList.";
                this._add(e), e._setIndexInList(this.length++);
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getIndexInList();
                if (this.length--, t !== this.length) {
                    var n = this.elements[this.length];
                    this.elements[t] = n, n._setIndexInList(t);
                }
                e._setIndexInList(-1);
            }
        }, {
            key: "clear",
            value: function() {
                for (var e = this.elements, t = 0, n = this.length; t < n; t++) e[t]._setIndexInList(-1);
                this.length = 0;
            }
        } ]), SimpleSingletonList;
    }(), Me = function() {
        function Color() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            _classCallCheck(this, Color), this.r = e, this.g = t, this.b = n, this.a = r;
        }
        return _createClass(Color, [ {
            key: "toLinear",
            value: function(e) {
                e.r = Color.gammaToLinearSpace(this.r), e.g = Color.gammaToLinearSpace(this.g), 
                e.b = Color.gammaToLinearSpace(this.b);
            }
        }, {
            key: "toGamma",
            value: function(e) {
                e.r = Color.linearToGammaSpace(this.r), e.g = Color.linearToGammaSpace(this.g), 
                e.b = Color.linearToGammaSpace(this.b);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Color();
                return this.cloneTo(e), e;
            }
        }, {
            key: "forNativeElement",
            value: function() {}
        } ], [ {
            key: "gammaToLinearSpace",
            value: function(e) {
                return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
            }
        }, {
            key: "linearToGammaSpace",
            value: function(e) {
                return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
            }
        } ]), Color;
    }();
    Me.RED = new Me(1, 0, 0, 1), Me.GREEN = new Me(0, 1, 0, 1), Me.BLUE = new Me(0, 0, 1, 1), 
    Me.CYAN = new Me(0, 1, 1, 1), Me.YELLOW = new Me(1, .92, .016, 1), Me.MAGENTA = new Me(1, 0, 1, 1), 
    Me.GRAY = new Me(.5, .5, .5, 1), Me.WHITE = new Me(1, 1, 1, 1), Me.BLACK = new Me(0, 0, 0, 1);
    var Ae = function CameraCullInfo() {
        _classCallCheck(this, CameraCullInfo);
    }, xe = function ShadowCullInfo() {
        _classCallCheck(this, ShadowCullInfo);
    }, Le = function() {
        function FrustumCulling() {
            _classCallCheck(this, FrustumCulling);
        }
        return _createClass(FrustumCulling, null, [ {
            key: "__init__",
            value: function() {
                t.Render.supportWebGLPlusCulling && (FrustumCulling._cullingBufferLength = 0, FrustumCulling._cullingBuffer = new Float32Array(4096));
            }
        }, {
            key: "_drawTraversalCullingBound",
            value: function(e, t) {
                for (var n = e.elements, r = 0, i = e.length; r < i; r++) {
                    var a = FrustumCulling._tempColor0;
                    a.r = 0, a.g = 1, a.b = 0, a.a = 1, O._drawBound(t, n[r].bounds._getBoundBox(), a);
                }
            }
        }, {
            key: "_traversalCulling",
            value: function(e, n, r, i, a, s, l) {
                for (var u = i.elements, c = e.boundFrustum, h = e.position, _ = e.cullingMask, d = t.Stat.loopCount, f = 0, m = i.length; f < m; f++) {
                    var T = u[f];
                    if ((l ? T._castShadow && T._enable : 0 != (Math.pow(2, T._owner._layer) & _) && T._enable) && (t.Stat.frustumCulling++, 
                    !e.useOcclusionCulling || T._needRender(c, r))) {
                        T._renderMark = d, T._distanceForSort = o.distance(T.bounds.getCenter(), h);
                        for (var p = T._renderElements, g = 0, E = p.length; g < E; g++) p[g]._update(n, r, a, s);
                    }
                }
            }
        }, {
            key: "renderObjectCulling",
            value: function(e, t, n, r, i, a) {
                var o = t._opaqueQueue, s = t._transparentQueue, l = t._renders;
                t._clearRenderQueue();
                var u = t._octree;
                if (u && (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(e, n, r, i, a)), 
                FrustumCulling._traversalCulling(e, t, n, l, r, i, a), FrustumCulling.debugFrustumCulling) {
                    var c = t._debugTool;
                    c.clear(), u && (u.drawAllBounds(c), u.drawAllObjects(c)), FrustumCulling._drawTraversalCullingBound(l, c);
                }
                var h = o.elements.length;
                h > 0 && o._quickSort(0, h - 1), (h = s.elements.length) > 0 && s._quickSort(0, h - 1);
            }
        }, {
            key: "cullingShadow",
            value: function(e, n, r) {
                var i = n._renders;
                n._clearRenderQueue();
                for (var a = n._opaqueQueue, s = e.position, l = e.cullPlaneCount, u = e.cullPlanes, c = (e.cullSphere, 
                e.direction, i.elements), h = t.Stat.loopCount, _ = 0, d = i.length; _ < d; _++) {
                    var f = c[_];
                    if (f._castShadow && f._enable) {
                        t.Stat.frustumCulling++;
                        for (var m = f.bounds, T = m.getMin(), p = m.getMax(), g = T.x, E = T.y, y = T.z, v = p.x, S = p.y, C = p.z, R = !0, D = 0; D < l; D++) {
                            var M = u[D], A = M.normal;
                            if (M.distance + A.x * (A.x < 0 ? g : v) + A.y * (A.y < 0 ? E : S) + A.z * (A.z < 0 ? y : C) < 0) {
                                R = !1;
                                break;
                            }
                        }
                        if (R) {
                            f._renderMark = h, f._distanceForSort = o.distance(m.getCenter(), s);
                            for (var x = f._renderElements, L = (D = 0, x.length); D < L; D++) x[D]._update(n, r, null, null);
                        }
                    }
                }
                return a.elements.length > 0;
            }
        }, {
            key: "cullingSpotShadow",
            value: function(e, n, r) {
                var i = n._renders;
                n._clearRenderQueue();
                for (var a = n._opaqueQueue, s = i.elements, l = t.Stat.loopCount, u = 0, c = i.length; u < c; u++) {
                    var h = s[u];
                    if (h._castShadow && h._enable && h._needRender(e.boundFrustum, r)) {
                        var _ = h.bounds;
                        h._renderMark = l, h._distanceForSort = o.distance(_.getCenter(), e.position);
                        for (var d = h._renderElements, f = 0, m = d.length; f < m; f++) d[f]._update(n, r, null, null);
                    }
                }
                return a.elements.length > 0;
            }
        }, {
            key: "renderObjectCullingNative",
            value: function(e, n, r, i, a, s) {
                var l, u, c, h = n._opaqueQueue, _ = n._transparentQueue;
                n._clearRenderQueue();
                var d = i.length, f = i.elements;
                for (l = 0; l < d; l++) f[l].bounds, f[l]._updateForNative && f[l]._updateForNative(r);
                e.boundFrustum;
                FrustumCulling.cullingNative(e._boundFrustumBuffer, FrustumCulling._cullingBuffer, n._cullingBufferIndices, d, n._cullingBufferResult);
                var m = t.Stat.loopCount, T = r.camera._transform.position;
                for (l = 0; l < d; l++) {
                    var p = f[l];
                    if (!e.useOcclusionCulling || e._isLayerVisible(p._owner._layer) && p._enable && n._cullingBufferResult[l]) {
                        p._renderMark = m, p._distanceForSort = o.distance(p.bounds.getCenter(), T);
                        var g = p._renderElements;
                        for (u = 0, c = g.length; u < c; u++) {
                            g[u]._update(n, r, a, s);
                        }
                    }
                }
                var E = h.elements.length;
                E > 0 && h._quickSort(0, E - 1), (E = _.elements.length) > 0 && _._quickSort(0, E - 1);
            }
        }, {
            key: "cullingNative",
            value: function(e, n, r, i, a) {
                return t.LayaGL.instance.culling(e, n, r, i, a);
            }
        } ]), FrustumCulling;
    }();
    Le._tempColor0 = new Me(), Le._tempVector0 = new o(), Le._cameraCullInfo = new Ae(), 
    Le._shadowCullInfo = new xe(), Le.debugFrustumCulling = !1;
    var Ie = function ClusterData() {
        _classCallCheck(this, ClusterData), this.updateMark = -1, this.pointLightCount = 0, 
        this.spotLightCount = 0, this.indices = [];
    }, Oe = function() {
        function Cluster(e, t, n, i) {
            _classCallCheck(this, Cluster), this._updateMark = 0, this._depthSliceParam = new r(), 
            this._xSlices = e, this._ySlices = t, this._zSlices = n;
            var a = e * t, o = n * (1 + Math.ceil(i / 4));
            this._clusterTexture = O._createFloatTextureBuffer(a, o), this._clusterTexture.lock = !0, 
            this._clusterPixels = new Float32Array(a * o * 4);
            for (var s = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
                s[l] = new Array(this._ySlices);
                for (var u = 0; u < this._ySlices; u++) {
                    s[l][u] = new Array(this._xSlices);
                    for (var c = 0; c < this._xSlices; c++) s[l][u][c] = new Ie();
                }
            }
            this._clusterDatas = s;
        }
        return _createClass(Cluster, [ {
            key: "_insertSpotLightSphere",
            value: function(e, t, n, r, i) {
                var a = Cluster._tempVector35;
                a.x = i.x - e.x, a.y = i.y - e.y, a.z = i.z - e.z;
                var s = o.dot(a, a), l = i.w;
                if (!(s > l * l)) return !1;
                var u = o.dot(a, t);
                return !(Math.cos(r) * Math.sqrt(s - u * u) - u * Math.sin(r) > l || u > l + n || u < -l);
            }
        }, {
            key: "_placePointLightToClusters",
            value: function(e, t) {
                for (var n = this._clusterDatas, r = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++) for (var o = t.yMin, s = t.yMax; o < s; o++) for (var l = t.xMin, u = t.xMax; l < u; l++) {
                    var c = n[i][o][l];
                    c.updateMark != r && (c.pointLightCount = 0, c.spotLightCount = 0, c.updateMark = r);
                    var h = c.indices, _ = c.pointLightCount++;
                    _ < h.length ? h[_] = e : h.push(e);
                }
            }
        }, {
            key: "_placeSpotLightToClusters",
            value: function(e, t) {
                for (var n = this._clusterDatas, r = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++) for (var o = t.yMin, s = t.yMax; o < s; o++) for (var l = t.xMin, u = t.xMax; l < u; l++) {
                    var c = n[i][o][l];
                    c.updateMark != r && (c.pointLightCount = 0, c.spotLightCount = 0, c.updateMark = r);
                    var h = c.indices, _ = c.pointLightCount + c.spotLightCount++;
                    _ < h.length ? h[_] = e : h.push(e);
                }
            }
        }, {
            key: "_insertConePlane",
            value: function(e, t, n, r, i) {
                var a = Cluster._tempVector36, s = Cluster._tempVector37;
                o.cross(i, t, a), o.cross(a, t, s), o.normalize(s, s);
                var l = n * Math.tan(r), u = e.x + n * t.x + l * s.x, c = e.y + n * t.y + l * s.y, h = e.z + n * t.z + l * s.z;
                return u * i.x + c * i.y + h * i.z <= 0 || e.x * i.x + e.y * i.y + e.z * i.z <= 0;
            }
        }, {
            key: "_shrinkSphereLightZPerspective",
            value: function(e, t, n, r, i) {
                var a = n.z, o = a - r, s = a + r;
                if (o > t || s <= e) return !1;
                var l = this._depthSliceParam;
                return i.zMin = Math.floor(Math.log2(Math.max(o, e)) * l.x - l.y), i.zMax = Math.min(Math.ceil(Math.log2(s) * l.x - l.y), this._zSlices), 
                !0;
            }
        }, {
            key: "_shrinkSpotLightZPerspective",
            value: function(e, t, n, r, i, a, o) {
                var s = r.x, l = r.y, u = r.z, c = Math.tan(a) * i, h = n.x, _ = n.y, d = n.z, f = s - h, m = l - _, T = u - d, p = f * f + m * m + T * T, g = Math.sqrt(1 - T * T / p), E = Math.max(Math.min(d, u - g * c), n.z - i), y = Math.min(Math.max(d, u + g * c), n.z + i);
                if (E > t || y <= e) return !1;
                var v = this._depthSliceParam;
                return o.zMin = Math.floor(Math.log2(Math.max(E, e)) * v.x - v.y), o.zMax = Math.min(Math.ceil(Math.log2(y) * v.x - v.y), this._zSlices), 
                !0;
            }
        }, {
            key: "_shrinkSphereLightByBoundOrth",
            value: function(e, t, n, r, i, a, o) {
                var s = i.z, l = s - a, u = s + a;
                if (l > r || u <= n) return !1;
                var c = i.x, h = c - a, _ = c + a;
                if (h > e || _ <= -e) return !1;
                var d = i.y, f = d - a, m = d + a;
                if (f > t || m <= -t) return !1;
                var T = this._xSlices, p = this._ySlices, g = this._depthSliceParam, E = 2 * e / T, y = 2 * t / p;
                return o.xMin = Math.max(Math.floor((h + e) / E), 0), o.xMax = Math.min(Math.ceil((_ + e) / E), T), 
                o.yMin = Math.max(Math.floor((t - m) / y), 0), o.yMax = Math.min(Math.ceil((t - f) / y), p), 
                o.zMin = Math.floor(Math.log2(Math.max(l, n)) * g.x - g.y), o.zMax = Math.min(Math.ceil(Math.log2(u) * g.x - g.y), this._zSlices), 
                !0;
            }
        }, {
            key: "_shrinkSpotLightByBoundOrth",
            value: function(e, t, n, r, i, a, o, s, l) {
                var u = a.x, c = a.y, h = a.z, _ = Math.tan(s) * o, d = i.x, f = i.y, m = i.z, T = u - d, p = c - f, g = h - m, E = T * T + p * p + g * g, y = Math.sqrt(1 - g * g / E), v = Math.max(Math.min(m, h - y * _), i.z - o), S = Math.min(Math.max(m, h + y * _), i.z + o);
                if (v > r || S <= n) return !1;
                var C = Math.sqrt(1 - T * T / E), R = Math.max(Math.min(d, u - C * _), i.x - o), D = Math.min(Math.max(d, u + C * _), i.x + o);
                if (R > e || D <= -e) return !1;
                var M = Math.sqrt(1 - p * p / E), A = Math.max(Math.min(f, c - M * _), i.y - o), x = Math.min(Math.max(f, c + M * _), i.y + o);
                if (A > t || x <= -t) return !1;
                var L = this._xSlices, I = this._ySlices, O = this._depthSliceParam, P = 2 * e / L, N = 2 * t / I;
                return l.xMin = Math.max(Math.floor((R + e) / P), 0), l.xMax = Math.min(Math.ceil((D + e) / P), L), 
                l.yMin = Math.max(Math.floor((t - x) / N), 0), l.yMax = Math.min(Math.ceil((t - A) / N), I), 
                l.zMin = Math.floor(Math.log2(Math.max(v, n)) * O.x - O.y), l.zMax = Math.min(Math.ceil(Math.log2(S) * O.x - O.y), this._zSlices), 
                !0;
            }
        }, {
            key: "_shrinkXYByRadiusPerspective",
            value: function(e, t, n, r, i) {
                var a, o, s, l, u, c = e.x, h = e.y, _ = e.z, d = this._ySlices + 1;
                for (u = 0; u < d; u++) {
                    if (h * (f = i[u]).y + _ * f.z < t) {
                        o = Math.max(0, u - 1);
                        break;
                    }
                }
                if (u == d) return !1;
                for (l = this._ySlices, u = o + 1; u < d; u++) {
                    if (h * (f = i[u]).y + _ * f.z <= -t) {
                        l = Math.max(0, u);
                        break;
                    }
                }
                for (d = this._xSlices + 1, u = 0; u < d; u++) {
                    if (c * (f = r[u]).x + _ * f.z < t) {
                        a = Math.max(0, u - 1);
                        break;
                    }
                }
                for (s = this._xSlices, u = a + 1; u < d; u++) {
                    var f;
                    if (c * (f = r[u]).x + _ * f.z <= -t) {
                        s = Math.max(0, u);
                        break;
                    }
                }
                return n.xMin = a, n.xMax = s, n.yMin = o, n.yMax = l, !0;
            }
        }, {
            key: "_shrinkSpotXYByConePerspective",
            value: function(e, t, n, r, i, a, o) {
                for (var s, l, u, c, h = Cluster._tempVector32, _ = i.yMax + 1, d = i.yMin + 1; d < _; d++) if (this._insertConePlane(e, t, n, r, o[d])) {
                    l = Math.max(0, d - 1);
                    break;
                }
                c = i.yMax;
                for (d = l + 1; d < _; d++) {
                    var f = o[d];
                    if (h.setValue(0, -f.y, -f.z), !this._insertConePlane(e, t, n, r, h)) {
                        c = Math.max(0, d);
                        break;
                    }
                }
                _ = i.xMax + 1;
                for (d = i.xMin + 1; d < _; d++) if (this._insertConePlane(e, t, n, r, a[d])) {
                    s = Math.max(0, d - 1);
                    break;
                }
                u = i.xMax;
                for (d = s + 1; d < _; d++) {
                    f = a[d];
                    if (h.setValue(-f.x, 0, -f.z), !this._insertConePlane(e, t, n, r, h)) {
                        u = Math.max(0, d);
                        break;
                    }
                }
                i.xMin = s, i.xMax = u, i.yMin = l, i.yMax = c;
            }
        }, {
            key: "_updatePointLightPerspective",
            value: function(e, t, n, r, i, a, s) {
                var l = Cluster._tempLightBound, u = Cluster._tempVector30;
                o.transformV3ToV3(r._transform.position, n, u), u.z *= -1, this._shrinkSphereLightZPerspective(e, t, u, r.range, l) && this._shrinkXYByRadiusPerspective(u, r.range, l, a, s) && this._placePointLightToClusters(i, l);
            }
        }, {
            key: "_updateSpotLightPerspective",
            value: function(e, t, n, r, i, a, s) {
                var l = Cluster._tempLightBound, u = Cluster._tempVector30, c = Cluster._tempVector31, h = Cluster._tempVector34, _ = r._transform.position, d = r.range;
                r._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o.add(_, h, h), 
                o.transformV3ToV3(_, n, u), o.transformV3ToV3(h, n, h), u.z *= -1, h.z *= -1;
                var f = r.spotAngle / 2 * Math.PI / 180;
                if (this._shrinkSpotLightZPerspective(e, t, u, h, d, f, l) && this._shrinkXYByRadiusPerspective(u, d, l, a, s)) {
                    var m = Cluster._tempVector33;
                    m.x = h.x - u.x, m.y = h.y - u.y, m.z = h.z - u.z, o.normalize(m, m), this._shrinkSpotXYByConePerspective(u, m, d, f, l, a, s), 
                    this._placeSpotLightToClusters(i, l);
                }
            }
        }, {
            key: "_updatePointLightOrth",
            value: function(e, t, n, r, i, a, s) {
                var l = Cluster._tempLightBound, u = Cluster._tempVector30;
                o.transformV3ToV3(a._transform.position, i, u), u.z *= -1, this._shrinkSphereLightByBoundOrth(e, t, n, r, u, a.range, l) && this._placePointLightToClusters(s, l);
            }
        }, {
            key: "_updateSpotLightOrth",
            value: function(e, t, n, r, i, a, s) {
                var l = Cluster._tempLightBound, u = Cluster._tempVector30, c = Cluster._tempVector31, h = Cluster._tempVector34, _ = a._transform.position, d = a.range;
                a._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o.add(_, h, h), 
                o.transformV3ToV3(_, i, u), o.transformV3ToV3(h, i, h), u.z *= -1, h.z *= -1;
                var f = a.spotAngle / 2 * Math.PI / 180;
                this._shrinkSpotLightByBoundOrth(e, t, n, r, u, h, d, f, l) && this._placeSpotLightToClusters(s, l);
            }
        }, {
            key: "update",
            value: function(e, t) {
                this._updateMark++;
                var n = e.nearPlane;
                this._depthSliceParam.x = w._config.lightClusterCount.z / Math.log2(e.farPlane / n), 
                this._depthSliceParam.y = Math.log2(n) * this._depthSliceParam.x;
                var r = e.nearPlane, i = e.farPlane, a = e.viewMatrix, o = t._directionLights._length, s = t._pointLights, l = s._length, u = s._elements, c = t._spotLights, h = c._length, _ = c._elements;
                if (e.orthographic) {
                    for (var d = e.orthographicVerticalSize / 2, f = d * e.aspectRatio, m = 0; m < l; m++, 
                    o++) this._updatePointLightOrth(f, d, r, i, a, u[m], o);
                    for (m = 0; m < h; m++, o++) this._updateSpotLightOrth(f, d, r, i, a, _[m], o);
                } else {
                    e._updateClusterPlaneXY();
                    var T = e._clusterXPlanes, p = e._clusterYPlanes;
                    for (m = 0; m < l; m++, o++) this._updatePointLightPerspective(r, i, a, u[m], o, T, p);
                    for (m = 0; m < h; m++, o++) this._updateSpotLightPerspective(r, i, a, _[m], o, T, p);
                }
                if (l + h > 0) {
                    for (var g = this._xSlices, E = this._ySlices, y = this._zSlices, v = g * E * 4, S = v * y, C = this._clusterPixels, R = C.length, D = this._clusterDatas, M = this._updateMark, A = !0, x = 0; x < y; x++) for (var L = 0; L < E; L++) for (var I = 0; I < g; I++) {
                        var O = D[x][L][I], P = 4 * (I + L * g + x * g * E);
                        if (O.updateMark !== M) C[P] = 0, C[P + 1] = 0; else if (A) {
                            var N = O.indices, b = O.pointLightCount, k = O.spotLightCount, B = b + k;
                            if (S + B < R) {
                                C[P] = b, C[P + 1] = k, C[P + 2] = Math.floor(S / v), C[P + 3] = S % v;
                                for (m = 0; m < B; m++) C[S++] = N[m];
                            } else {
                                B = R - (S + B), b = Math.min(b, B), C[P] = b, C[P + 1] = Math.min(k, B - b), C[P + 2] = Math.floor(S / v), 
                                C[P + 3] = S % v;
                                for (m = 0; m < B; m++) C[S++] = N[m];
                                A = !1;
                            }
                        }
                    }
                    var V = this._clusterTexture.width;
                    this._clusterTexture.setSubPixels(0, 0, V, Math.ceil(S / (4 * V)), C);
                }
            }
        } ]), Cluster;
    }();
    Oe._tempVector30 = new o(), Oe._tempVector31 = new o(), Oe._tempVector32 = new o(), 
    Oe._tempVector33 = new o(), Oe._tempVector34 = new o(), Oe._tempVector35 = new o(), 
    Oe._tempVector36 = new o(), Oe._tempVector37 = new o(), Oe._tempLightBound = new function LightBound() {
        _classCallCheck(this, LightBound);
    }();
    var Pe = function() {
        function SphericalHarmonicsL2() {
            _classCallCheck(this, SphericalHarmonicsL2), this._coefficients = new Float32Array(27);
        }
        return _createClass(SphericalHarmonicsL2, [ {
            key: "getCoefficient",
            value: function(e, t) {
                return this._coefficients[9 * e + t];
            }
        }, {
            key: "setCoefficient",
            value: function(e, t, n) {
                this._coefficients[9 * e + t] = n;
            }
        }, {
            key: "setCoefficients",
            value: function(e, t, n, r, i, a, o, s, l, u) {
                var c = 9 * e;
                this._coefficients[c] = t, this._coefficients[++c] = n, this._coefficients[++c] = r, 
                this._coefficients[++c] = i, this._coefficients[++c] = a, this._coefficients[++c] = o, 
                this._coefficients[++c] = s, this._coefficients[++c] = l, this._coefficients[++c] = u;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                if (this !== e) for (var t = this._coefficients, n = e._coefficients, r = 0; r < 27; r++) n[r] = t[r];
            }
        } ]), SphericalHarmonicsL2;
    }();
    Pe._default = new Pe();
    var Ne = function MouseTouch() {
        _classCallCheck(this, MouseTouch), this._pressedSprite = null, this._pressedLoopCount = -1, 
        this.sprite = null, this.mousePositionX = 0, this.mousePositionY = 0;
    }, be = function() {
        function Touch() {
            _classCallCheck(this, Touch), this._indexInList = -1, this._identifier = -1, this._position = new r();
        }
        return _createClass(Touch, [ {
            key: "_getIndexInList",
            value: function() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function(e) {
                this._indexInList = e;
            }
        }, {
            key: "identifier",
            get: function() {
                return this._identifier;
            }
        }, {
            key: "position",
            get: function() {
                return this._position;
            }
        } ]), Touch;
    }(), ke = function() {
        function Plane(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, Plane), this.normal = e, this.distance = t;
        }
        return _createClass(Plane, [ {
            key: "normalize",
            value: function() {
                var e = this.normal.x, t = this.normal.y, n = this.normal.z, r = 1 / Math.sqrt(e * e + t * t + n * n);
                this.normal.x = e * r, this.normal.y = t * r, this.normal.z = n * r, this.distance *= r;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.normal.cloneTo(t.normal), t.distance = this.distance;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Plane(new o());
                return this.cloneTo(e), e;
            }
        } ], [ {
            key: "createPlaneBy3P",
            value: function(e, t, n, r) {
                var i = t.x - e.x, a = t.y - e.y, o = t.z - e.z, s = n.x - e.x, l = n.y - e.y, u = n.z - e.z, c = a * u - o * l, h = o * s - i * u, _ = i * l - a * s, d = 1 / Math.sqrt(c * c + h * h + _ * _), f = c * d, m = h * d, T = _ * d, p = r.normal;
                p.x = f, p.y = m, p.z = T, r.distance = -(f * e.x + m * e.y + T * e.z);
            }
        } ]), Plane;
    }();
    ke.PlaneIntersectionType_Back = 0, ke.PlaneIntersectionType_Front = 1, ke.PlaneIntersectionType_Intersecting = 2;
    var we = function Ray(e, t) {
        _classCallCheck(this, Ray), this.origin = e, this.direction = t;
    }, Be = function ContainmentType() {
        _classCallCheck(this, ContainmentType);
    };
    Be.Disjoint = 0, Be.Contains = 1, Be.Intersects = 2;
    var Ve, Fe = function() {
        function CollisionUtils() {
            _classCallCheck(this, CollisionUtils);
        }
        return _createClass(CollisionUtils, null, [ {
            key: "distancePlaneToPoint",
            value: function(e, t) {
                return o.dot(e.normal, t) - e.distance;
            }
        }, {
            key: "distanceBoxToPoint",
            value: function(e, t) {
                var n = e.min, r = n.x, i = n.y, a = n.z, o = e.max, s = o.x, l = o.y, u = o.z, c = t.x, h = t.y, _ = t.z, d = 0;
                return c < r && (d += (r - c) * (r - c)), c > s && (d += (s - c) * (s - c)), h < i && (d += (i - h) * (i - h)), 
                h > l && (d += (l - h) * (l - h)), _ < a && (d += (a - _) * (a - _)), _ > u && (d += (u - _) * (u - _)), 
                Math.sqrt(d);
            }
        }, {
            key: "distanceBoxToBox",
            value: function(e, t) {
                var n, r = e.min, i = r.x, a = r.y, o = r.z, s = e.max, l = s.x, u = s.y, c = s.z, h = t.min, _ = h.x, d = h.y, f = h.z, m = t.max, T = m.x, p = m.y, g = m.z, E = 0;
                return i > T ? E += (n = i - T) * n : _ > l && (E += (n = _ - l) * n), a > p ? E += (n = a - p) * n : d > u && (E += (n = d - u) * n), 
                o > g ? E += (n = o - g) * n : f > c && (E += (n = f - c) * n), Math.sqrt(E);
            }
        }, {
            key: "distanceSphereToPoint",
            value: function(e, t) {
                var n = Math.sqrt(o.distanceSquared(e.center, t));
                return n -= e.radius, Math.max(n, 0);
            }
        }, {
            key: "distanceSphereToSphere",
            value: function(e, t) {
                var n = Math.sqrt(o.distanceSquared(e.center, t.center));
                return n -= e.radius + t.radius, Math.max(n, 0);
            }
        }, {
            key: "intersectsRayAndTriangleRD",
            value: function(e, t, r, i, a) {
                var o = e.origin, s = o.x, l = o.y, u = o.z, c = e.direction, h = c.x, _ = c.y, d = c.z, f = t.x, m = t.y, T = t.z, p = r.x, g = r.y, E = r.z, y = i.x, v = i.y, S = i.z, C = CollisionUtils._tempV30.x, R = CollisionUtils._tempV30.y, D = CollisionUtils._tempV30.z;
                C = p - f, R = g - m, D = E - T;
                var M = CollisionUtils._tempV31.x, A = CollisionUtils._tempV31.y, x = CollisionUtils._tempV31.z;
                M = y - f, A = v - m, x = S - T;
                var L = CollisionUtils._tempV32.x, I = CollisionUtils._tempV32.y, O = CollisionUtils._tempV32.z, P = C * (L = _ * x - d * A) + R * (I = d * M - h * x) + D * (O = h * A - _ * M);
                if (n.isZero(P)) return !1;
                var N = 1 / P, b = CollisionUtils._tempV33.x, k = CollisionUtils._tempV33.y, w = CollisionUtils._tempV33.z, B = (b = s - f) * L + (k = l - m) * I + (w = u - T) * O;
                if ((B *= N) < 0 || B > 1) return !1;
                var V = CollisionUtils._tempV34.x, F = CollisionUtils._tempV34.y, U = CollisionUtils._tempV34.z, G = h * (V = k * D - w * R) + _ * (F = w * C - b * D) + d * (U = b * R - k * C);
                if ((G *= N) < 0 || B + G > 1) return !1;
                var H = M * V + A * F + x * U;
                return !((H *= N) < 0);
            }
        }, {
            key: "intersectsRayAndTriangleRP",
            value: function(e, t, n, r, i) {
                return CollisionUtils.intersectsRayAndTriangleRD(e, t, n, r, void 0) ? (o.scale(e.direction, void 0, CollisionUtils._tempV30), 
                o.add(e.origin, CollisionUtils._tempV30, i), !0) : (i = o._ZERO, !1);
            }
        }, {
            key: "intersectsRayAndPoint",
            value: function(e, t) {
                o.subtract(e.origin, t, CollisionUtils._tempV30);
                var r = o.dot(CollisionUtils._tempV30, e.direction), i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - n.zeroTolerance;
                return !(i > 0 && r > 0) && !(r * r - i < 0);
            }
        }, {
            key: "intersectsRayAndRay",
            value: function(e, t, r) {
                var i = e.origin, a = i.x, s = i.y, l = i.z, u = e.direction, c = u.x, h = u.y, _ = u.z, d = t.origin, f = d.x, m = d.y, T = d.z, p = t.direction, g = p.x, E = p.y, y = p.z;
                o.cross(u, p, CollisionUtils._tempV30);
                var v = CollisionUtils._tempV30, S = o.scalarLength(CollisionUtils._tempV30);
                if (n.isZero(S) && n.nearEqual(f, a) && n.nearEqual(m, s) && n.nearEqual(T, l)) return !0;
                S *= S;
                var C = f - a, R = m - s, D = T - l, M = g, A = E, x = y, L = v.x, I = v.y, O = v.z, P = C * A * O + R * x * L + D * M * I - C * x * I - R * M * O - D * A * L;
                M = c, A = h, x = _;
                var N = P / S;
                o.scale(u, N, CollisionUtils._tempV30), o.scale(p, N, CollisionUtils._tempV31), 
                o.add(i, CollisionUtils._tempV30, CollisionUtils._tempV32), o.add(d, CollisionUtils._tempV31, CollisionUtils._tempV33);
                var b = CollisionUtils._tempV32, k = CollisionUtils._tempV33;
                return !!(n.nearEqual(k.x, b.x) && n.nearEqual(k.y, b.y) && n.nearEqual(k.z, b.z));
            }
        }, {
            key: "intersectsPlaneAndTriangle",
            value: function(e, t, n, r) {
                var i = CollisionUtils.intersectsPlaneAndPoint(e, t), a = CollisionUtils.intersectsPlaneAndPoint(e, n), o = CollisionUtils.intersectsPlaneAndPoint(e, r);
                return i == ke.PlaneIntersectionType_Front && a == ke.PlaneIntersectionType_Front && o == ke.PlaneIntersectionType_Front ? ke.PlaneIntersectionType_Front : i == ke.PlaneIntersectionType_Back && a == ke.PlaneIntersectionType_Back && o == ke.PlaneIntersectionType_Back ? ke.PlaneIntersectionType_Back : ke.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsRayAndPlaneRD",
            value: function(e, t) {
                var r = t.normal, i = o.dot(r, e.direction);
                if (Math.abs(i) < n.zeroTolerance) return -1;
                var a = o.dot(r, e.origin), s = (-t.distance - a) / i;
                if (s < 0) {
                    if (s < -n.zeroTolerance) return -1;
                    s = 0;
                }
                return s;
            }
        }, {
            key: "intersectsRayAndPlaneRP",
            value: function(e, t, n) {
                var r = CollisionUtils.intersectsRayAndPlaneRD(e, t);
                if (-1 == r) return n.setValue(0, 0, 0), !1;
                var i = CollisionUtils._tempV30;
                return o.scale(e.direction, r, i), o.add(e.origin, i, n), !0;
            }
        }, {
            key: "intersectsRayAndBoxRD",
            value: function(e, t) {
                var r = e.origin, i = r.x, a = r.y, o = r.z, s = e.direction, l = s.x, u = s.y, c = s.z, h = t.min, _ = h.x, d = h.y, f = h.z, m = t.max, T = m.x, p = m.y, g = m.z, E = 0, y = n.MaxValue;
                if (n.isZero(l)) {
                    if (i < _ || i > T) return -1;
                } else {
                    var v = 1 / l, S = (_ - i) * v, C = (T - i) * v;
                    if (S > C) {
                        var R = S;
                        S = C, C = R;
                    }
                    if ((E = Math.max(S, E)) > (y = Math.min(C, y))) return -1;
                }
                if (n.isZero(u)) {
                    if (a < d || a > p) return -1;
                } else {
                    var D = 1 / u, M = (d - a) * D, A = (p - a) * D;
                    if (M > A) {
                        var x = M;
                        M = A, A = x;
                    }
                    if ((E = Math.max(M, E)) > (y = Math.min(A, y))) return -1;
                }
                if (n.isZero(c)) {
                    if (o < f || o > g) return -1;
                } else {
                    var L = 1 / c, I = (f - o) * L, O = (g - o) * L;
                    if (I > O) {
                        var P = I;
                        I = O, O = P;
                    }
                    if ((E = Math.max(I, E)) > (y = Math.min(O, y))) return -1;
                }
                return E;
            }
        }, {
            key: "intersectsRayAndBoxRP",
            value: function(e, t, n) {
                var r = CollisionUtils.intersectsRayAndBoxRD(e, t);
                return -1 === r ? (o._ZERO.cloneTo(n), r) : (o.scale(e.direction, r, CollisionUtils._tempV30), 
                o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(n), 
                r);
            }
        }, {
            key: "intersectsRayAndSphereRD",
            value: function(e, t) {
                var n = t.radius;
                o.subtract(e.origin, t.center, CollisionUtils._tempV30);
                var r = o.dot(CollisionUtils._tempV30, e.direction), i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - n * n;
                if (i > 0 && r > 0) return -1;
                var a = r * r - i;
                if (a < 0) return -1;
                var s = -r - Math.sqrt(a);
                return s < 0 && (s = 0), s;
            }
        }, {
            key: "intersectsRayAndSphereRP",
            value: function(e, t, n) {
                var r = CollisionUtils.intersectsRayAndSphereRD(e, t);
                return -1 === r ? (o._ZERO.cloneTo(n), r) : (o.scale(e.direction, r, CollisionUtils._tempV30), 
                o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(n), 
                r);
            }
        }, {
            key: "intersectsSphereAndTriangle",
            value: function(e, t, n, r) {
                var i = e.center, a = e.radius;
                return CollisionUtils.closestPointPointTriangle(i, t, n, r, CollisionUtils._tempV30), 
                o.subtract(CollisionUtils._tempV30, i, CollisionUtils._tempV31), o.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <= a * a;
            }
        }, {
            key: "intersectsPlaneAndPoint",
            value: function(e, t) {
                var n = o.dot(e.normal, t) + e.distance;
                return n > 0 ? ke.PlaneIntersectionType_Front : n < 0 ? ke.PlaneIntersectionType_Back : ke.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndPlane",
            value: function(e, t) {
                o.cross(e.normal, t.normal, CollisionUtils._tempV30);
                var r = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
                return !n.isZero(r);
            }
        }, {
            key: "intersectsPlaneAndPlaneRL",
            value: function(e, t, r) {
                var i = e.normal, a = t.normal;
                o.cross(i, a, CollisionUtils._tempV34);
                var s = o.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
                return !n.isZero(s) && (o.scale(a, e.distance, CollisionUtils._tempV30), o.scale(i, t.distance, CollisionUtils._tempV31), 
                o.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32), 
                o.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33), 
                o.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34), !0);
            }
        }, {
            key: "intersectsPlaneAndBox",
            value: function(e, t) {
                var n = e.distance, r = e.normal, i = r.x, a = r.y, s = r.z, l = t.min, u = l.x, c = l.y, h = l.z, _ = t.max, d = _.x, f = _.y, m = _.z;
                CollisionUtils._tempV30.x = i > 0 ? u : d, CollisionUtils._tempV30.y = a > 0 ? c : f, 
                CollisionUtils._tempV30.z = s > 0 ? h : m, CollisionUtils._tempV31.x = i > 0 ? d : u, 
                CollisionUtils._tempV31.y = a > 0 ? f : c, CollisionUtils._tempV31.z = s > 0 ? m : h;
                var T = o.dot(r, CollisionUtils._tempV30);
                return T + n > 0 ? ke.PlaneIntersectionType_Front : (T = o.dot(r, CollisionUtils._tempV31)) + n < 0 ? ke.PlaneIntersectionType_Back : ke.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndSphere",
            value: function(e, t) {
                var n = t.radius, r = o.dot(e.normal, t.center) + e.distance;
                return r > n ? ke.PlaneIntersectionType_Front : r < -n ? ke.PlaneIntersectionType_Back : ke.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsBoxAndBox",
            value: function(e, t) {
                var n = e.min, r = e.max, i = t.min, a = t.max;
                return !(n.x > a.x || i.x > r.x) && (!(n.y > a.y || i.y > r.y) && !(n.z > a.z || i.z > r.z));
            }
        }, {
            key: "intersectsBoxAndSphere",
            value: function(e, t) {
                var n = t.center, r = t.radius, i = CollisionUtils._tempV30;
                return o.Clamp(n, e.min, e.max, i), o.distanceSquared(n, i) <= r * r;
            }
        }, {
            key: "intersectsSphereAndSphere",
            value: function(e, t) {
                var n = e.radius + t.radius;
                return o.distanceSquared(e.center, t.center) <= n * n;
            }
        }, {
            key: "boxContainsPoint",
            value: function(e, t) {
                var n = e.min, r = e.max;
                return n.x <= t.x && r.x >= t.x && n.y <= t.y && r.y >= t.y && n.z <= t.z && r.z >= t.z ? Be.Contains : Be.Disjoint;
            }
        }, {
            key: "boxContainsBox",
            value: function(e, t) {
                var n = e.min, r = n.x, i = n.y, a = n.z, o = e.max, s = o.x, l = o.y, u = o.z, c = t.min, h = c.x, _ = c.y, d = c.z, f = t.max, m = f.x, T = f.y, p = f.z;
                return s < h || r > m ? Be.Disjoint : l < _ || i > T ? Be.Disjoint : u < d || a > p ? Be.Disjoint : r <= h && m <= s && i <= _ && T <= l && a <= d && p <= u ? Be.Contains : Be.Intersects;
            }
        }, {
            key: "boxContainsSphere",
            value: function(e, t) {
                var n = e.min, r = n.x, i = n.y, a = n.z, s = e.max, l = s.x, u = s.y, c = s.z, h = t.center, _ = h.x, d = h.y, f = h.z, m = t.radius;
                return o.Clamp(h, n, s, CollisionUtils._tempV30), o.distanceSquared(h, CollisionUtils._tempV30) > m * m ? Be.Disjoint : r + m <= _ && _ <= l - m && l - r > m && i + m <= d && d <= u - m && u - i > m && a + m <= f && f <= c - m && c - a > m ? Be.Contains : Be.Intersects;
            }
        }, {
            key: "sphereContainsPoint",
            value: function(e, t) {
                return o.distanceSquared(t, e.center) <= e.radius * e.radius ? Be.Contains : Be.Disjoint;
            }
        }, {
            key: "sphereContainsTriangle",
            value: function(e, t, n, r) {
                var i = CollisionUtils.sphereContainsPoint(e, t), a = CollisionUtils.sphereContainsPoint(e, n), o = CollisionUtils.sphereContainsPoint(e, r);
                return i == Be.Contains && a == Be.Contains && o == Be.Contains ? Be.Contains : CollisionUtils.intersectsSphereAndTriangle(e, t, n, r) ? Be.Intersects : Be.Disjoint;
            }
        }, {
            key: "sphereContainsBox",
            value: function(e, t) {
                var n = e.center, r = n.x, i = n.y, a = n.z, s = e.radius, l = t.min, u = l.x, c = l.y, h = l.z, _ = t.max, d = _.x, f = _.y, m = _.z, T = CollisionUtils._tempV30;
                T.x, T.y, T.z;
                if (!CollisionUtils.intersectsBoxAndSphere(t, e)) return Be.Disjoint;
                var p = s * s;
                return r - u, i - f, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - d, 
                i - f, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - d, 
                i - c, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - u, 
                i - c, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - u, 
                i - f, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - d, 
                i - f, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - d, 
                i - c, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : (r - u, 
                i - c, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? Be.Intersects : Be.Contains)))))));
            }
        }, {
            key: "sphereContainsSphere",
            value: function(e, t) {
                var n = e.radius, r = t.radius, i = o.distance(e.center, t.center);
                return n + r < i ? Be.Disjoint : n - r < i ? Be.Intersects : Be.Contains;
            }
        }, {
            key: "closestPointPointTriangle",
            value: function(e, t, n, r, i) {
                o.subtract(n, t, CollisionUtils._tempV30), o.subtract(r, t, CollisionUtils._tempV31), 
                o.subtract(e, t, CollisionUtils._tempV32), o.subtract(e, n, CollisionUtils._tempV33), 
                o.subtract(e, r, CollisionUtils._tempV34);
                var a = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV32), s = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV32), l = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV33), u = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV33), c = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV34), h = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
                if (a <= 0 && s <= 0) t.cloneTo(i); else if (l >= 0 && u <= l) n.cloneTo(i); else {
                    var _ = a * u - l * s;
                    if (_ <= 0 && a >= 0 && l <= 0) {
                        var d = a / (a - l);
                        return o.scale(CollisionUtils._tempV30, d, i), void o.add(t, i, i);
                    }
                    if (h >= 0 && c <= h) r.cloneTo(i); else {
                        var f = c * s - a * h;
                        if (f <= 0 && s >= 0 && h <= 0) {
                            var m = s / (s - h);
                            return o.scale(CollisionUtils._tempV31, m, i), void o.add(t, i, i);
                        }
                        var T = l * h - c * u;
                        if (T <= 0 && u - l >= 0 && c - h >= 0) {
                            var p = (u - l) / (u - l + (c - h));
                            return o.subtract(r, n, i), o.scale(i, p, i), void o.add(n, i, i);
                        }
                        var g = 1 / (T + f + _), E = f * g, y = _ * g;
                        o.scale(CollisionUtils._tempV30, E, CollisionUtils._tempV35), o.scale(CollisionUtils._tempV31, y, CollisionUtils._tempV36), 
                        o.add(CollisionUtils._tempV35, CollisionUtils._tempV36, i), o.add(t, i, i);
                    }
                }
            }
        }, {
            key: "closestPointPlanePoint",
            value: function(e, t, n) {
                var r = e.normal, i = o.dot(r, t) - e.distance;
                o.scale(r, i, CollisionUtils._tempV30), o.subtract(t, CollisionUtils._tempV30, n);
            }
        }, {
            key: "closestPointBoxPoint",
            value: function(e, t, n) {
                o.max(t, e.min, CollisionUtils._tempV30), o.min(CollisionUtils._tempV30, e.max, n);
            }
        }, {
            key: "closestPointSpherePoint",
            value: function(e, t, n) {
                var r = e.center;
                o.subtract(t, r, n), o.normalize(n, n), o.scale(n, e.radius, n), o.add(n, r, n);
            }
        }, {
            key: "closestPointSphereSphere",
            value: function(e, t, n) {
                var r = e.center;
                o.subtract(t.center, r, n), o.normalize(n, n), o.scale(n, e.radius, n), o.add(n, r, n);
            }
        } ]), CollisionUtils;
    }();
    Fe._tempV30 = new o(), Fe._tempV31 = new o(), Fe._tempV32 = new o(), Fe._tempV33 = new o(), 
    Fe._tempV34 = new o(), Fe._tempV35 = new o(), Fe._tempV36 = new o(), (Ve = e.FrustumCorner || (e.FrustumCorner = {}))[Ve.FarBottomLeft = 0] = "FarBottomLeft", 
    Ve[Ve.FarTopLeft = 1] = "FarTopLeft", Ve[Ve.FarTopRight = 2] = "FarTopRight", Ve[Ve.FarBottomRight = 3] = "FarBottomRight", 
    Ve[Ve.nearBottomLeft = 4] = "nearBottomLeft", Ve[Ve.nearTopLeft = 5] = "nearTopLeft", 
    Ve[Ve.nearTopRight = 6] = "nearTopRight", Ve[Ve.nearBottomRight = 7] = "nearBottomRight", 
    Ve[Ve.unknown = 8] = "unknown";
    var Ue = function() {
        function BoundFrustum(e) {
            _classCallCheck(this, BoundFrustum), this._matrix = e, this._near = new ke(new o()), 
            this._far = new ke(new o()), this._left = new ke(new o()), this._right = new ke(new o()), 
            this._top = new ke(new o()), this._bottom = new ke(new o()), BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        return _createClass(BoundFrustum, [ {
            key: "equalsBoundFrustum",
            value: function(e) {
                return this._matrix.equalsOtherMatrix(e.matrix);
            }
        }, {
            key: "equalsObj",
            value: function(e) {
                if (e instanceof BoundFrustum) {
                    var t = e;
                    return this.equalsBoundFrustum(t);
                }
                return !1;
            }
        }, {
            key: "getPlane",
            value: function(e) {
                switch (e) {
                  case 0:
                    return this._near;

                  case 1:
                    return this._far;

                  case 2:
                    return this._left;

                  case 3:
                    return this._right;

                  case 4:
                    return this._top;

                  case 5:
                    return this._bottom;

                  default:
                    return null;
                }
            }
        }, {
            key: "getCorners",
            value: function(t) {
                BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._right, t[e.FrustumCorner.nearBottomRight]), 
                BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._right, t[e.FrustumCorner.nearTopRight]), 
                BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._left, t[e.FrustumCorner.nearTopLeft]), 
                BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._left, t[e.FrustumCorner.nearBottomLeft]), 
                BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._right, t[e.FrustumCorner.FarBottomRight]), 
                BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._right, t[e.FrustumCorner.FarTopRight]), 
                BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._left, t[e.FrustumCorner.FarTopLeft]), 
                BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._left, t[e.FrustumCorner.FarBottomLeft]);
            }
        }, {
            key: "containsPoint",
            value: function(e) {
                for (var t = ke.PlaneIntersectionType_Front, n = ke.PlaneIntersectionType_Front, r = 0; r < 6; r++) {
                    switch (r) {
                      case 0:
                        n = Fe.intersectsPlaneAndPoint(this._near, e);
                        break;

                      case 1:
                        n = Fe.intersectsPlaneAndPoint(this._far, e);
                        break;

                      case 2:
                        n = Fe.intersectsPlaneAndPoint(this._left, e);
                        break;

                      case 3:
                        n = Fe.intersectsPlaneAndPoint(this._right, e);
                        break;

                      case 4:
                        n = Fe.intersectsPlaneAndPoint(this._top, e);
                        break;

                      case 5:
                        n = Fe.intersectsPlaneAndPoint(this._bottom, e);
                    }
                    switch (n) {
                      case ke.PlaneIntersectionType_Back:
                        return Be.Disjoint;

                      case ke.PlaneIntersectionType_Intersecting:
                        t = ke.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                  case ke.PlaneIntersectionType_Intersecting:
                    return Be.Intersects;

                  default:
                    return Be.Contains;
                }
            }
        }, {
            key: "intersects",
            value: function(e) {
                var t = e.min, n = e.max, r = t.x, i = t.y, a = t.z, o = n.x, s = n.y, l = n.z, u = this._near.normal;
                if (this._near.distance + u.x * (u.x < 0 ? r : o) + u.y * (u.y < 0 ? i : s) + u.z * (u.z < 0 ? a : l) < 0) return !1;
                var c = this._left.normal;
                if (this._left.distance + c.x * (c.x < 0 ? r : o) + c.y * (c.y < 0 ? i : s) + c.z * (c.z < 0 ? a : l) < 0) return !1;
                var h = this._right.normal;
                if (this._right.distance + h.x * (h.x < 0 ? r : o) + h.y * (h.y < 0 ? i : s) + h.z * (h.z < 0 ? a : l) < 0) return !1;
                var _ = this._bottom.normal;
                if (this._bottom.distance + _.x * (_.x < 0 ? r : o) + _.y * (_.y < 0 ? i : s) + _.z * (_.z < 0 ? a : l) < 0) return !1;
                var d = this._top.normal;
                if (this._top.distance + d.x * (d.x < 0 ? r : o) + d.y * (d.y < 0 ? i : s) + d.z * (d.z < 0 ? a : l) < 0) return !1;
                var f = this._far.normal;
                return !(this._far.distance + f.x * (f.x < 0 ? r : o) + f.y * (f.y < 0 ? i : s) + f.z * (f.z < 0 ? a : l) < 0);
            }
        }, {
            key: "containsBoundBox",
            value: function(e) {
                for (var t = BoundFrustum._tempV30, n = BoundFrustum._tempV31, r = e.min, i = e.max, a = Be.Contains, o = 0; o < 6; o++) {
                    var s = this.getPlane(o), l = s.normal;
                    if (l.x >= 0 ? (t.x = i.x, n.x = r.x) : (t.x = r.x, n.x = i.x), l.y >= 0 ? (t.y = i.y, 
                    n.y = r.y) : (t.y = r.y, n.y = i.y), l.z >= 0 ? (t.z = i.z, n.z = r.z) : (t.z = r.z, 
                    n.z = i.z), Fe.intersectsPlaneAndPoint(s, t) === ke.PlaneIntersectionType_Back) return Be.Disjoint;
                    Fe.intersectsPlaneAndPoint(s, n) === ke.PlaneIntersectionType_Back && (a = Be.Intersects);
                }
                return a;
            }
        }, {
            key: "containsBoundSphere",
            value: function(e) {
                for (var t = ke.PlaneIntersectionType_Front, n = ke.PlaneIntersectionType_Front, r = 0; r < 6; r++) {
                    switch (r) {
                      case 0:
                        n = Fe.intersectsPlaneAndSphere(this._near, e);
                        break;

                      case 1:
                        n = Fe.intersectsPlaneAndSphere(this._far, e);
                        break;

                      case 2:
                        n = Fe.intersectsPlaneAndSphere(this._left, e);
                        break;

                      case 3:
                        n = Fe.intersectsPlaneAndSphere(this._right, e);
                        break;

                      case 4:
                        n = Fe.intersectsPlaneAndSphere(this._top, e);
                        break;

                      case 5:
                        n = Fe.intersectsPlaneAndSphere(this._bottom, e);
                    }
                    switch (n) {
                      case ke.PlaneIntersectionType_Back:
                        return Be.Disjoint;

                      case ke.PlaneIntersectionType_Intersecting:
                        t = ke.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                  case ke.PlaneIntersectionType_Intersecting:
                    return Be.Intersects;

                  default:
                    return Be.Contains;
                }
            }
        }, {
            key: "matrix",
            get: function() {
                return this._matrix;
            },
            set: function(e) {
                e.cloneTo(this._matrix), BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }
        }, {
            key: "near",
            get: function() {
                return this._near;
            }
        }, {
            key: "far",
            get: function() {
                return this._far;
            }
        }, {
            key: "left",
            get: function() {
                return this._left;
            }
        }, {
            key: "right",
            get: function() {
                return this._right;
            }
        }, {
            key: "top",
            get: function() {
                return this._top;
            }
        }, {
            key: "bottom",
            get: function() {
                return this._bottom;
            }
        } ], [ {
            key: "getPlanesFromMatrix",
            value: function(e, t, n, r, i, a, o) {
                var s = e.elements, l = s[0], u = s[1], c = s[2], h = s[3], _ = s[4], d = s[5], f = s[6], m = s[7], T = s[8], p = s[9], g = s[10], E = s[11], y = s[12], v = s[13], S = s[14], C = s[15], R = t.normal;
                R.x = c, R.y = f, R.z = g, t.distance = S, t.normalize();
                var D = n.normal;
                D.x = h - c, D.y = m - f, D.z = E - g, n.distance = C - S, n.normalize();
                var M = r.normal;
                M.x = h + l, M.y = m + _, M.z = E + T, r.distance = C + y, r.normalize();
                var A = i.normal;
                A.x = h - l, A.y = m - _, A.z = E - T, i.distance = C - y, i.normalize();
                var x = a.normal;
                x.x = h - u, x.y = m - d, x.z = E - p, a.distance = C - v, a.normalize();
                var L = o.normal;
                L.x = h + u, L.y = m + d, L.z = E + p, o.distance = C + v, o.normalize();
            }
        }, {
            key: "get3PlaneInterPoint",
            value: function(e, t, n, r) {
                var i = e.normal, a = t.normal, s = n.normal;
                o.cross(a, s, BoundFrustum._tempV30), o.cross(s, i, BoundFrustum._tempV31), o.cross(i, a, BoundFrustum._tempV32);
                var l = o.dot(i, BoundFrustum._tempV30), u = o.dot(a, BoundFrustum._tempV31), c = o.dot(s, BoundFrustum._tempV32);
                o.scale(BoundFrustum._tempV30, -e.distance / l, BoundFrustum._tempV33), o.scale(BoundFrustum._tempV31, -t.distance / u, BoundFrustum._tempV34), 
                o.scale(BoundFrustum._tempV32, -n.distance / c, BoundFrustum._tempV35), o.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36), 
                o.add(BoundFrustum._tempV35, BoundFrustum._tempV36, r);
            }
        } ]), BoundFrustum;
    }();
    Ue._tempV30 = new o(), Ue._tempV31 = new o(), Ue._tempV32 = new o(), Ue._tempV33 = new o(), 
    Ue._tempV34 = new o(), Ue._tempV35 = new o(), Ue._tempV36 = new o();
    var Ge = function() {
        function Viewport(e, t, n, r) {
            _classCallCheck(this, Viewport), this.minDepth = 0, this.maxDepth = 1, this.x = e, 
            this.y = t, this.width = n, this.height = r;
        }
        return _createClass(Viewport, [ {
            key: "project",
            value: function(e, t, n) {
                o.transformV3ToV4(e, t, n);
                var r = n.x, i = n.y, a = n.z, s = n.w;
                1 !== s && (r /= s, i /= s, a /= s), n.x = .5 * (r + 1) * this.width + this.x, n.y = .5 * (1 - i) * this.height + this.y, 
                n.z = a * (this.maxDepth - this.minDepth) + this.minDepth;
            }
        }, {
            key: "unprojectFromMat",
            value: function(e, t, n) {
                var r = t.elements;
                n.x = (e.x - this.x) / this.width * 2 - 1, n.y = -((e.y - this.y) / this.height * 2 - 1), 
                n.z = (e.z - this.minDepth) / (this.maxDepth - this.minDepth);
                var i = n.x * r[3] + n.y * r[7] + n.z * r[11] + r[15];
                o.transformV3ToV3(n, t, n), 1 !== i && (n.x = n.x / i, n.y = n.y / i, n.z = n.z / i);
            }
        }, {
            key: "unprojectFromWVP",
            value: function(e, t, n, r, i) {
                c.multiply(t, n, Viewport._tempMatrix4x4), r && c.multiply(Viewport._tempMatrix4x4, r, Viewport._tempMatrix4x4), 
                Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4), this.unprojectFromMat(e, Viewport._tempMatrix4x4, i);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth, 
                e.maxDepth = this.maxDepth;
            }
        } ]), Viewport;
    }();
    Ge._tempMatrix4x4 = new c();
    var He = function() {
        function Picker() {
            _classCallCheck(this, Picker);
        }
        return _createClass(Picker, null, [ {
            key: "calculateCursorRay",
            value: function(e, t, n, r, i, a) {
                var s = e.x, l = e.y, u = Picker._tempVector30, c = u;
                c.x = s, c.y = l, c.z = t.minDepth;
                var h = Picker._tempVector31, _ = h;
                _.x = s, _.y = l, _.z = t.maxDepth;
                var d = a.origin, f = Picker._tempVector32;
                t.unprojectFromWVP(u, n, r, i, d), t.unprojectFromWVP(h, n, r, i, f);
                var m = a.direction;
                m.x = f.x - d.x, m.y = f.y - d.y, m.z = f.z - d.z, o.normalize(a.direction, a.direction);
            }
        }, {
            key: "rayIntersectsTriangle",
            value: function(e, t, n, r) {
                var i = Picker._tempVector30, a = Picker._tempVector31;
                o.subtract(n, t, i), o.subtract(r, t, a);
                var s, l = Picker._tempVector32;
                if (o.cross(e.direction, a, l), (s = o.dot(i, l)) > -Number.MIN_VALUE && s < Number.MIN_VALUE) return Number.NaN;
                var u, c = 1 / s, h = Picker._tempVector33;
                if (o.subtract(e.origin, t, h), u = o.dot(h, l), (u *= c) < 0 || u > 1) return Number.NaN;
                var _, d, f = Picker._tempVector34;
                return o.cross(h, i, f), _ = o.dot(e.direction, f), (_ *= c) < 0 || u + _ > 1 ? Number.NaN : (d = o.dot(a, f), 
                (d *= c) < 0 ? Number.NaN : d);
            }
        } ]), Picker;
    }();
    He._tempVector30 = new o(), He._tempVector31 = new o(), He._tempVector32 = new o(), 
    He._tempVector33 = new o(), He._tempVector34 = new o();
    var ze, We = function(e) {
        function BufferState() {
            return _classCallCheck(this, BufferState), _possibleConstructorReturn(this, _getPrototypeOf(BufferState).call(this));
        }
        return _inherits(BufferState, t.BufferStateBase), _createClass(BufferState, [ {
            key: "applyVertexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var n = t.LayaGL.instance, r = e.vertexDeclaration, i = r._shaderValues.getData();
                for (var a in this.vertexDeclaration = r, e.bind(), i) {
                    var o = parseInt(a), s = i[a];
                    n.enableVertexAttribArray(o), n.vertexAttribPointer(o, s[0], s[1], !!s[2], s[3], s[4]);
                }
            }
        }, {
            key: "applyVertexBuffers",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                for (var n = t.LayaGL.instance, r = 0, i = e.length; r < i; r++) {
                    var a = e[r], o = a.vertexDeclaration._shaderValues.getData();
                    for (var s in a.bind(), o) {
                        var l = parseInt(s), u = o[s];
                        n.enableVertexAttribArray(l), n.vertexAttribPointer(l, u[0], u[1], !!u[2], u[3], u[4]);
                    }
                }
            }
        }, {
            key: "applyInstanceVertexBuffer",
            value: function(e) {
                if (t.LayaGL.layaGPUInstance.supportInstance()) {
                    if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                    var n = t.LayaGL.instance, r = e.vertexDeclaration._shaderValues.getData();
                    for (var i in e.bind(), r) {
                        var a = parseInt(i), o = r[i];
                        n.enableVertexAttribArray(a), n.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]), 
                        t.LayaGL.layaGPUInstance.vertexAttribDivisor(a, 1);
                    }
                }
            }
        }, {
            key: "applyIndexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
            }
        } ]), BufferState;
    }();
    (ze = e.IndexFormat || (e.IndexFormat = {}))[ze.UInt8 = 0] = "UInt8", ze[ze.UInt16 = 1] = "UInt16", 
    ze[ze.UInt32 = 2] = "UInt32";
    var Xe = function(n) {
        function IndexBuffer3D(n, r) {
            var i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 35044, o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            switch (_classCallCheck(this, IndexBuffer3D), (i = _possibleConstructorReturn(this, _getPrototypeOf(IndexBuffer3D).call(this)))._indexType = n, 
            i._indexCount = r, i._bufferUsage = a, i._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER, 
            i._canRead = o, n) {
              case e.IndexFormat.UInt32:
                i._indexTypeByteCount = 4;
                break;

              case e.IndexFormat.UInt16:
                i._indexTypeByteCount = 2;
                break;

              case e.IndexFormat.UInt8:
                i._indexTypeByteCount = 1;
                break;

              default:
                throw new Error("unidentification index type.");
            }
            var s = i._indexTypeByteCount * r, l = t.BufferStateBase._curBindedBufferState;
            if (i._byteLength = s, l ? l._bindedIndexBuffer === _assertThisInitialized(i) ? t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage) : (l.unBind(), 
            i.bind(), t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage), l.bind()) : (i.bind(), 
            t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage)), o) switch (n) {
              case e.IndexFormat.UInt32:
                i._buffer = new Uint32Array(r);
                break;

              case e.IndexFormat.UInt16:
                i._buffer = new Uint16Array(r);
                break;

              case e.IndexFormat.UInt8:
                i._buffer = new Uint8Array(r);
            }
            return i;
        }
        return _inherits(IndexBuffer3D, t.Buffer), _createClass(IndexBuffer3D, [ {
            key: "_bindForVAO",
            value: function() {
                if (!t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
                var e = t.LayaGL.instance;
                e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
            }
        }, {
            key: "bind",
            value: function() {
                if (t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
                if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedIndexBuffer = this._glBuffer, 
                    !0;
                }
                return !1;
            }
        }, {
            key: "setData",
            value: function(n) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 4294967295, o = this._indexTypeByteCount;
                if (0 !== i || 4294967295 !== a) switch (this._indexType) {
                  case e.IndexFormat.UInt32:
                    n = new Uint32Array(n.buffer, i * o, a);
                    break;

                  case e.IndexFormat.UInt16:
                    n = new Uint16Array(n.buffer, i * o, a);
                    break;

                  case e.IndexFormat.UInt8:
                    n = new Uint8Array(n.buffer, i * o, a);
                }
                var s = t.BufferStateBase._curBindedBufferState;
                if (s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, r * o, n) : (s.unBind(), 
                this.bind(), t.LayaGL.instance.bufferSubData(this._bufferType, r * o, n), s.bind()) : (this.bind(), 
                t.LayaGL.instance.bufferSubData(this._bufferType, r * o, n)), this._canRead) if (0 !== r || 0 !== i || 4294967295 !== a) {
                    var l = this._buffer.length - r;
                    a > l && (a = l);
                    for (var u = 0; u < a; u++) this._buffer[r + u] = n[u];
                } else this._buffer = n;
            }
        }, {
            key: "getData",
            value: function() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(IndexBuffer3D.prototype), "destroy", this).call(this), this._buffer = null;
            }
        }, {
            key: "indexType",
            get: function() {
                return this._indexType;
            }
        }, {
            key: "indexTypeByteCount",
            get: function() {
                return this._indexTypeByteCount;
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexCount;
            }
        }, {
            key: "canRead",
            get: function() {
                return this._canRead;
            }
        } ]), IndexBuffer3D;
    }(), Ye = function() {
        function VertexElementFormat() {
            _classCallCheck(this, VertexElementFormat);
        }
        return _createClass(VertexElementFormat, null, [ {
            key: "__init__",
            value: function() {
                var e = t.LayaGL.instance;
                VertexElementFormat._elementInfos = {
                    single: [ 1, e.FLOAT, 0 ],
                    vector2: [ 2, e.FLOAT, 0 ],
                    vector3: [ 3, e.FLOAT, 0 ],
                    vector4: [ 4, e.FLOAT, 0 ],
                    color: [ 4, e.FLOAT, 0 ],
                    byte4: [ 4, e.UNSIGNED_BYTE, 0 ],
                    short2: [ 2, e.FLOAT, 0 ],
                    short4: [ 4, e.FLOAT, 0 ],
                    normalizedshort2: [ 2, e.FLOAT, 0 ],
                    normalizedshort4: [ 4, e.FLOAT, 0 ],
                    halfvector2: [ 2, e.FLOAT, 0 ],
                    halfvector4: [ 4, e.FLOAT, 0 ]
                };
            }
        }, {
            key: "getElementInfos",
            value: function(e) {
                var t = VertexElementFormat._elementInfos[e];
                if (t) return t;
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
            }
        } ]), VertexElementFormat;
    }();
    Ye.Single = "single", Ye.Vector2 = "vector2", Ye.Vector3 = "vector3", Ye.Vector4 = "vector4", 
    Ye.Color = "color", Ye.Byte4 = "byte4", Ye.Short2 = "short2", Ye.Short4 = "short4", 
    Ye.NormalizedShort2 = "normalizedshort2", Ye.NormalizedShort4 = "normalizedshort4", 
    Ye.HalfVector2 = "halfvector2", Ye.HalfVector4 = "halfvector4";
    var je = function() {
        function VertexDeclaration(e, t) {
            _classCallCheck(this, VertexDeclaration), this._id = ++VertexDeclaration._uniqueIDCounter, 
            this._vertexElementsDic = {}, this._vertexStride = e, this._vertexElements = t;
            var n = t.length;
            this._shaderValues = new ce(null);
            for (var r = 0; r < n; r++) {
                var i = t[r], a = i._elementUsage;
                this._vertexElementsDic[a] = i;
                var o = new Int32Array(5), s = Ye.getElementInfos(i._elementFormat);
                o[0] = s[0], o[1] = s[1], o[2] = s[2], o[3] = this._vertexStride, o[4] = i._offset, 
                this._shaderValues.setAttribute(a, o);
            }
        }
        return _createClass(VertexDeclaration, [ {
            key: "getVertexElementByIndex",
            value: function(e) {
                return this._vertexElements[e];
            }
        }, {
            key: "getVertexElementByUsage",
            value: function(e) {
                return this._vertexElementsDic[e];
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "vertexStride",
            get: function() {
                return this._vertexStride;
            }
        }, {
            key: "vertexElementCount",
            get: function() {
                return this._vertexElements.length;
            }
        } ]), VertexDeclaration;
    }();
    je._uniqueIDCounter = 1;
    var Ze = function() {
        function VertexElement(e, t, n) {
            _classCallCheck(this, VertexElement), this._offset = e, this._elementFormat = t, 
            this._elementUsage = n;
        }
        return _createClass(VertexElement, [ {
            key: "offset",
            get: function() {
                return this._offset;
            }
        }, {
            key: "elementFormat",
            get: function() {
                return this._elementFormat;
            }
        }, {
            key: "elementUsage",
            get: function() {
                return this._elementUsage;
            }
        } ]), VertexElement;
    }(), Qe = function() {
        function VertexMesh() {
            _classCallCheck(this, VertexMesh);
        }
        return _createClass(VertexMesh, null, [ {
            key: "__init__",
            value: function() {
                VertexMesh.instanceWorldMatrixDeclaration = new je(64, [ new Ze(0, Ye.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0), new Ze(16, Ye.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1), new Ze(32, Ye.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2), new Ze(48, Ye.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3) ]), 
                VertexMesh.instanceMVPMatrixDeclaration = new je(64, [ new Ze(0, Ye.Vector4, VertexMesh.MESH_MVPMATRIX_ROW0), new Ze(16, Ye.Vector4, VertexMesh.MESH_MVPMATRIX_ROW1), new Ze(32, Ye.Vector4, VertexMesh.MESH_MVPMATRIX_ROW2), new Ze(48, Ye.Vector4, VertexMesh.MESH_MVPMATRIX_ROW3) ]);
            }
        }, {
            key: "getVertexDeclaration",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")];
                if (!n) {
                    for (var r = e.split(","), i = 0, a = [], o = 0, s = r.length; o < s; o++) {
                        var l;
                        switch (r[o]) {
                          case "POSITION":
                            l = new Ze(i, Ye.Vector3, VertexMesh.MESH_POSITION0), i += 12;
                            break;

                          case "NORMAL":
                            l = new Ze(i, Ye.Vector3, VertexMesh.MESH_NORMAL0), i += 12;
                            break;

                          case "COLOR":
                            l = new Ze(i, Ye.Vector4, VertexMesh.MESH_COLOR0), i += 16;
                            break;

                          case "UV":
                            l = new Ze(i, Ye.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0), i += 8;
                            break;

                          case "UV1":
                            l = new Ze(i, Ye.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1), i += 8;
                            break;

                          case "BLENDWEIGHT":
                            l = new Ze(i, Ye.Vector4, VertexMesh.MESH_BLENDWEIGHT0), i += 16;
                            break;

                          case "BLENDINDICES":
                            t ? (l = new Ze(i, Ye.Vector4, VertexMesh.MESH_BLENDINDICES0), i += 16) : (l = new Ze(i, Ye.Byte4, VertexMesh.MESH_BLENDINDICES0), 
                            i += 4);
                            break;

                          case "TANGENT":
                            l = new Ze(i, Ye.Vector4, VertexMesh.MESH_TANGENT0), i += 16;
                            break;

                          default:
                            throw "VertexMesh: unknown vertex flag.";
                        }
                        a.push(l);
                    }
                    n = new je(i, a), VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")] = n;
                }
                return n;
            }
        } ]), VertexMesh;
    }();
    Qe.MESH_POSITION0 = 0, Qe.MESH_COLOR0 = 1, Qe.MESH_TEXTURECOORDINATE0 = 2, Qe.MESH_NORMAL0 = 3, 
    Qe.MESH_TANGENT0 = 4, Qe.MESH_BLENDINDICES0 = 5, Qe.MESH_BLENDWEIGHT0 = 6, Qe.MESH_TEXTURECOORDINATE1 = 7, 
    Qe.MESH_WORLDMATRIX_ROW0 = 8, Qe.MESH_WORLDMATRIX_ROW1 = 9, Qe.MESH_WORLDMATRIX_ROW2 = 10, 
    Qe.MESH_WORLDMATRIX_ROW3 = 11, Qe.MESH_MVPMATRIX_ROW0 = 12, Qe.MESH_MVPMATRIX_ROW1 = 13, 
    Qe.MESH_MVPMATRIX_ROW2 = 14, Qe.MESH_MVPMATRIX_ROW3 = 15, Qe._vertexDeclarationMap = {};
    var qe = function(e) {
        function VertexBuffer3D(e, n) {
            var r, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, VertexBuffer3D), (r = _possibleConstructorReturn(this, _getPrototypeOf(VertexBuffer3D).call(this)))._vertexDeclaration = null, 
            r._float32Reader = null;
            var a = t.LayaGL.instance;
            return r._bufferUsage = n, r._bufferType = a.ARRAY_BUFFER, r._canRead = i, r._byteLength = e, 
            r.bind(), a.bufferData(r._bufferType, r._byteLength, r._bufferUsage), i && (r._buffer = new Uint8Array(e), 
            r._float32Reader = new Float32Array(r._buffer.buffer)), r;
        }
        return _inherits(VertexBuffer3D, t.Buffer), _createClass(VertexBuffer3D, [ {
            key: "bind",
            value: function() {
                if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedVertexBuffer = this._glBuffer, 
                    !0;
                }
                return !1;
            }
        }, {
            key: "orphanStorage",
            value: function() {
                this.bind(), t.LayaGL.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage);
            }
        }, {
            key: "setData",
            value: function(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.MAX_SAFE_INTEGER;
                if (this.bind(), 0 !== r || i !== Number.MAX_SAFE_INTEGER) {
                    var a = new Uint8Array(e, r, i);
                    t.LayaGL.instance.bufferSubData(this._bufferType, n, a), this._canRead && this._buffer.set(a, n);
                } else t.LayaGL.instance.bufferSubData(this._bufferType, n, e), this._canRead && this._buffer.set(new Uint8Array(e), n);
            }
        }, {
            key: "getUint8Data",
            value: function() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "getFloat32Data",
            value: function() {
                if (this._canRead) return this._float32Reader;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "markAsUnreadbale",
            value: function() {
                this._canRead = !1, this._buffer = null, this._float32Reader = null;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(VertexBuffer3D.prototype), "destroy", this).call(this), this._buffer = null, 
                this._float32Reader = null, this._vertexDeclaration = null;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return this._vertexDeclaration;
            },
            set: function(e) {
                this._vertexDeclaration = e;
            }
        }, {
            key: "canRead",
            get: function() {
                return this._canRead;
            }
        } ]), VertexBuffer3D;
    }();
    qe.DATATYPE_FLOAT32ARRAY = 0, qe.DATATYPE_UINT8ARRAY = 1;
    var Ke = function() {
        function SkyMesh() {
            _classCallCheck(this, SkyMesh);
        }
        return _createClass(SkyMesh, [ {
            key: "_render",
            value: function(e) {}
        } ]), SkyMesh;
    }(), Je = function(n) {
        function SkyBox() {
            var n;
            _classCallCheck(this, SkyBox), n = _possibleConstructorReturn(this, _getPrototypeOf(SkyBox).call(this));
            var r = t.LayaGL.instance, i = new Float32Array([ -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1 ]), a = new Uint8Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0 ]), o = Qe.getVertexDeclaration("POSITION");
            n._vertexBuffer = new qe(8 * o.vertexStride, r.STATIC_DRAW, !1), n._vertexBuffer.vertexDeclaration = o, 
            n._indexBuffer = new Xe(e.IndexFormat.UInt8, 36, r.STATIC_DRAW, !1), n._vertexBuffer.setData(i.buffer), 
            n._indexBuffer.setData(a);
            var s = new We();
            return s.bind(), s.applyVertexBuffer(n._vertexBuffer), s.applyIndexBuffer(n._indexBuffer), 
            s.unBind(), n._bufferState = s, n;
        }
        return _inherits(SkyBox, Ke), _createClass(SkyBox, [ {
            key: "_render",
            value: function(e) {
                var n = t.LayaGL.instance;
                n.drawElements(n.TRIANGLES, 36, n.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces += 12, 
                t.Stat.renderBatches++;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                SkyBox.instance = new SkyBox();
            }
        } ]), SkyBox;
    }(), $e = function() {
        function SkyRenderer() {
            _classCallCheck(this, SkyRenderer), this._mesh = Je.instance;
        }
        return _createClass(SkyRenderer, [ {
            key: "_isAvailable",
            value: function() {
                return !(!this._material || !this._mesh);
            }
        }, {
            key: "_render",
            value: function(e) {
                if (this._material && this._mesh) {
                    var n = t.LayaGL.instance, r = e.scene, i = e.cameraShaderValue, a = e.camera, s = ce._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                    t.ILaya.Render.supportWebGLPlusRendering && ce.setRuntimeValueMode(!1), t.WebGLContext.setCullFace(n, !1), 
                    t.WebGLContext.setDepthFunc(n, n.LEQUAL), t.WebGLContext.setDepthMask(n, !1);
                    var l = SkyRenderer._compileDefine;
                    this._material._shaderValues._defineDatas.cloneTo(l);
                    var u = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(l), h = u.bind(), _ = t.Stat.loopCount !== u._uploadMark, d = u._uploadScene !== r || _;
                    (d || h) && (u.uploadUniforms(u._sceneUniformParamsMap, r._shaderValues, d), u._uploadScene = r);
                    a._getRenderTexture();
                    var f = u._uploadCameraShaderValue !== i || _;
                    if (f || h) {
                        var m = SkyRenderer._tempMatrix0, T = SkyRenderer._tempMatrix1;
                        a.viewMatrix.cloneTo(m), a.projectionMatrix.cloneTo(T), m.setTranslationVector(o._ZERO), 
                        a.orthographic && c.createPerspective(a.fieldOfView, a.aspectRatio, a.nearPlane, a.farPlane, T);
                        var p = 1 / Math.tan(3.1416 * a.fieldOfView / 180 * .5);
                        T.elements[0] = p / a.aspectRatio, T.elements[5] = p, T.elements[10] = 1e-6 - 1, 
                        T.elements[11] = -1, T.elements[14] = -0, a._applyViewProject(e, m, T), u.uploadUniforms(u._cameraUniformParamsMap, i, f), 
                        u._uploadCameraShaderValue = i;
                    }
                    var g = u._uploadMaterial !== this._material || _;
                    (g || h) && (u.uploadUniforms(u._materialUniformParamsMap, this._material._shaderValues, g), 
                    u._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e), 
                    t.ILaya.Render.supportWebGLPlusRendering && ce.setRuntimeValueMode(s), t.WebGLContext.setDepthFunc(n, n.LESS), 
                    t.WebGLContext.setDepthMask(n, !0), a._applyViewProject(e, a.viewMatrix, a.projectionMatrix);
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this._material && (this._material._removeReference(), this._material = null);
            }
        }, {
            key: "material",
            get: function() {
                return this._material;
            },
            set: function(e) {
                this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(), 
                this._material = e);
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                this._mesh !== e && (this._mesh = e);
            }
        } ]), SkyRenderer;
    }();
    $e._tempMatrix0 = new c(), $e._tempMatrix1 = new c(), $e._compileDefine = new ae();
    var et = function(e) {
        function Sprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return _classCallCheck(this, Sprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Sprite3D).call(this)))._needProcessCollisions = !1, 
            e._needProcessTriggers = !1, e._id = ++Sprite3D._uniqueIDCounter, e._transform = new f(_assertThisInitialized(e)), 
            e._isStatic = n, e.layer = 0, e.name = t || "New Sprite3D", e;
        }
        return _inherits(Sprite3D, t.Node), _createClass(Sprite3D, [ {
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_changeAnimatorsToLinkSprite3D",
            value: function(e, t, n) {
                var r = this.getComponent(te);
                if (r && (r.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(r, t, n)), this._parent && this._parent instanceof Sprite3D) {
                    n.unshift(this._parent.name);
                    var i = this._parent;
                    i._hierarchyAnimator && i._changeAnimatorsToLinkSprite3D(e, t, n);
                }
            }
        }, {
            key: "_setHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
                for (var n = 0, r = this._children.length; n < r; n++) {
                    var i = this._children[n];
                    i._hierarchyAnimator == t && i._setHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_clearHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
                for (var n = 0, r = this._children.length; n < r; n++) {
                    var i = this._children[n];
                    i._hierarchyAnimator == e && i._clearHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_changeHierarchyAnimatorAvatar",
            value: function(e, t) {
                this._changeAnimatorAvatar(t);
                for (var n = 0, r = this._children.length; n < r; n++) {
                    var i = this._children[n];
                    i._hierarchyAnimator == e && i._changeHierarchyAnimatorAvatar(e, t);
                }
            }
        }, {
            key: "_changeAnimatorToLinkSprite3DNoAvatar",
            value: function(e, t, n) {
                e._handleSpriteOwnersBySprite(t, n, this);
                for (var r = 0, i = this._children.length; r < i; r++) {
                    var a = this._children[r], o = n.length;
                    n.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(e, t, n), n.splice(o, 1);
                }
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                this._hierarchyAnimator = e;
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {}
        }, {
            key: "_onAdded",
            value: function() {
                if (this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(e.transform), e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null), 
                    e._changeAnimatorsToLinkSprite3D(this, !0, [ this.name ]));
                }
                _get(_getPrototypeOf(Sprite3D.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onRemoved",
            value: function() {
                if (_get(_getPrototypeOf(Sprite3D.prototype), "_onRemoved", this).call(this), this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(null), e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null), 
                    e._changeAnimatorsToLinkSprite3D(this, !1, [ this.name ]));
                }
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active), 
                null != e.name && (this.name = e.name), void 0 !== e.position) {
                    var n = this.transform.localPosition;
                    n.fromArray(e.position), this.transform.localPosition = n;
                }
                if (void 0 !== e.rotationEuler) {
                    var r = this.transform.localRotationEuler;
                    r.fromArray(e.rotationEuler), this.transform.localRotationEuler = r;
                }
                if (void 0 !== e.rotation) {
                    var i = this.transform.localRotation;
                    i.fromArray(e.rotation), this.transform.localRotation = i;
                }
                if (void 0 !== e.scale) {
                    var a = this.transform.localScale;
                    a.fromArray(e.scale), this.transform.localScale = a;
                }
                null != e.layer && (this.layer = e.layer);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, n) {
                if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                var r = e, i = this._transform, a = r._transform;
                r.name = this.name, r.destroyed = this.destroyed, r.active = this.active, a.localPosition = i.localPosition, 
                a.localRotation = i.localRotation, a.localScale = i.localScale, r._isStatic = this._isStatic, 
                r.layer = this.layer, _get(_getPrototypeOf(Sprite3D.prototype), "_cloneTo", this).call(this, r, t, n);
            }
        }, {
            key: "clone",
            value: function() {
                var e = Sprite3D._createSprite3DInstance(this);
                return Sprite3D._parseSprite3DInstance(this, e, this, e), e;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Sprite3D.prototype), "destroy", this).call(this, e), 
                this._transform = null, this._scripts = null, this._url && t.Loader.clearRes(this._url));
            }
        }, {
            key: "_create",
            value: function() {
                return new Sprite3D();
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "layer",
            get: function() {
                return this._layer;
            },
            set: function(e) {
                if (this._layer !== e) {
                    if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                    this._layer = e;
                }
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "isStatic",
            get: function() {
                return this._isStatic;
            }
        }, {
            key: "transform",
            get: function() {
                return this._transform;
            }
        } ], [ {
            key: "__init__",
            value: function() {}
        }, {
            key: "instantiate",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, a = e.clone();
                t && t.addChild(a);
                var o = a.transform;
                if (n) {
                    var s = o.worldMatrix;
                    e.transform.worldMatrix.cloneTo(s), o.worldMatrix = s;
                } else r && (o.position = r), i && (o.rotation = i);
                return a;
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.Laya.loader.create(e, n, null, Sprite3D.HIERARCHY);
            }
        }, {
            key: "_createSprite3DInstance",
            value: function(e) {
                for (var t = e._create(), n = e._children, r = 0, i = n.length; r < i; r++) {
                    var a = Sprite3D._createSprite3DInstance(n[r]);
                    t.addChild(a);
                }
                return t;
            }
        }, {
            key: "_parseSprite3DInstance",
            value: function(e, t, n, r) {
                for (var i = n._children, a = r._children, o = 0, s = i.length; o < s; o++) Sprite3D._parseSprite3DInstance(e, t, i[o], a[o]);
                n._cloneTo(r, e, t);
            }
        } ]), Sprite3D;
    }();
    et.HIERARCHY = "HIERARCHY", et.WORLDMATRIX = ue.propertyNameToID("u_WorldMat"), 
    et.MVPMATRIX = ue.propertyNameToID("u_MvpMatrix"), et._uniqueIDCounter = 0;
    var tt, nt = function(e) {
        function BaseCamera() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .3, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
            return _classCallCheck(this, BaseCamera), (e = _possibleConstructorReturn(this, _getPrototypeOf(BaseCamera).call(this)))._skyRenderer = new $e(), 
            e._forward = new o(), e._up = new o(), e.clearColor = new i(100 / 255, 149 / 255, 237 / 255, 1), 
            e._shaderValues = new ce(null), e._fieldOfView = 60, e._useUserProjectionMatrix = !1, 
            e._orthographic = !1, e._orthographicVerticalSize = 10, e.renderingOrder = 0, e._nearPlane = t, 
            e._farPlane = n, e.cullingMask = 2147483647, e.useOcclusionCulling = !0, e;
        }
        return _inherits(BaseCamera, et), _createClass(BaseCamera, [ {
            key: "_sortCamerasByRenderingOrder",
            value: function() {
                if (this.displayedInStage) for (var e = this.scene._cameraPool, t = e.length - 1, n = 0; n < t; n++) if (e[n].renderingOrder > e[t].renderingOrder) {
                    var r = e[n];
                    e[n] = e[t], e[t] = r;
                }
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {}
        }, {
            key: "_onScreenSizeChanged",
            value: function() {
                this._calculateProjectionMatrix();
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                var e = this._shaderValues;
                this.transform.getForward(this._forward), this.transform.getUp(this._up), e.setVector3(BaseCamera.CAMERAPOS, this.transform.position), 
                e.setVector3(BaseCamera.CAMERADIRECTION, this._forward), e.setVector3(BaseCamera.CAMERAUP, this._up);
            }
        }, {
            key: "render",
            value: function() {
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            }
        }, {
            key: "addLayer",
            value: function(e) {
                this.cullingMask |= Math.pow(2, e);
            }
        }, {
            key: "removeLayer",
            value: function(e) {
                this.cullingMask &= ~Math.pow(2, e);
            }
        }, {
            key: "addAllLayers",
            value: function() {
                this.cullingMask = 2147483647;
            }
        }, {
            key: "removeAllLayers",
            value: function() {
                this.cullingMask = 0;
            }
        }, {
            key: "resetProjectionMatrix",
            value: function() {
                this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
            }
        }, {
            key: "_onActive",
            value: function() {
                this._scene._addCamera(this), _get(_getPrototypeOf(BaseCamera.prototype), "_onActive", this).call(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                this._scene._removeCamera(this), _get(_getPrototypeOf(BaseCamera.prototype), "_onInActive", this).call(this);
            }
        }, {
            key: "_parse",
            value: function(e, n) {
                _get(_getPrototypeOf(BaseCamera.prototype), "_parse", this).call(this, e, n), this.orthographic = e.orthographic, 
                void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize), 
                void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e.nearPlane, 
                this.farPlane = e.farPlane;
                var r = e.clearColor;
                this.clearColor = new i(r[0], r[1], r[2], r[3]);
                var a = e.skyboxMaterial;
                a && (this._skyRenderer.material = t.Loader.getRes(a.path));
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged), 
                _get(_getPrototypeOf(BaseCamera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "_create",
            value: function() {
                return new BaseCamera();
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "fieldOfView",
            get: function() {
                return this._fieldOfView;
            },
            set: function(e) {
                this._fieldOfView = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "nearPlane",
            get: function() {
                return this._nearPlane;
            },
            set: function(e) {
                this._nearPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "farPlane",
            get: function() {
                return this._farPlane;
            },
            set: function(e) {
                this._farPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographic",
            get: function() {
                return this._orthographic;
            },
            set: function(e) {
                this._orthographic = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographicVerticalSize",
            get: function() {
                return this._orthographicVerticalSize;
            },
            set: function(e) {
                this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "renderingOrder",
            get: function() {
                return this._renderingOrder;
            },
            set: function(e) {
                this._renderingOrder = e, this._sortCamerasByRenderingOrder();
            }
        } ]), BaseCamera;
    }();
    nt._tempMatrix4x40 = new c(), nt.CAMERAPOS = ue.propertyNameToID("u_CameraPos"), 
    nt.VIEWMATRIX = ue.propertyNameToID("u_View"), nt.PROJECTMATRIX = ue.propertyNameToID("u_Projection"), 
    nt.VIEWPROJECTMATRIX = ue.propertyNameToID("u_ViewProjection"), nt.CAMERADIRECTION = ue.propertyNameToID("u_CameraDirection"), 
    nt.CAMERAUP = ue.propertyNameToID("u_CameraUp"), nt.VIEWPORT = ue.propertyNameToID("u_Viewport"), 
    nt.PROJECTION_PARAMS = ue.propertyNameToID("u_ProjectionParams"), nt.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", 
    nt.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", nt._invertYScaleMatrix = new c(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
    nt._invertYProjectionMatrix = new c(), nt._invertYProjectionViewMatrix = new c(), 
    nt.CLEARFLAG_SOLIDCOLOR = 0, nt.CLEARFLAG_SKY = 1, nt.CLEARFLAG_DEPTHONLY = 2, nt.CLEARFLAG_NONE = 3, 
    (tt = e.ShadowMode || (e.ShadowMode = {}))[tt.None = 0] = "None", tt[tt.Hard = 1] = "Hard", 
    tt[tt.SoftLow = 2] = "SoftLow", tt[tt.SoftHigh = 3] = "SoftHigh";
    var rt = function(e) {
        function ScreenQuad() {
            var e;
            _classCallCheck(this, ScreenQuad), (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenQuad).call(this)))._bufferState = new We(), 
            e._bufferStateInvertUV = new We();
            var n = t.LayaGL.instance;
            return e._vertexBuffer = new qe(64, n.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration, 
            e._vertexBuffer.setData(ScreenQuad._vertices.buffer), e._bufferState.bind(), e._bufferState.applyVertexBuffer(e._vertexBuffer), 
            e._bufferState.unBind(), e._vertexBufferInvertUV = new qe(64, n.STATIC_DRAW, !1), 
            e._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration, e._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer), 
            e._bufferStateInvertUV.bind(), e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV), 
            e._bufferStateInvertUV.unBind(), e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength), 
            e;
        }
        return _inherits(ScreenQuad, t.Resource), _createClass(ScreenQuad, [ {
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenQuad.prototype), "destroy", this).call(this), this._bufferState.destroy(), 
                this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), 
                this._setGPUMemory(0);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                ScreenQuad._vertexDeclaration = new je(16, [ new Ze(0, Ye.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV) ]), 
                ScreenQuad.instance = new ScreenQuad(), ScreenQuad.instance.lock = !0;
            }
        } ]), ScreenQuad;
    }();
    rt.SCREENQUAD_POSITION_UV = 0, rt._vertices = new Float32Array([ 1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0 ]), 
    rt._verticesInvertUV = new Float32Array([ 1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1 ]);
    var it = function(e) {
        function ScreenTriangle() {
            var e;
            _classCallCheck(this, ScreenTriangle), (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenTriangle).call(this)))._bufferState = new We(), 
            e._bufferStateInvertUV = new We();
            var n = t.LayaGL.instance;
            return e._vertexBuffer = new qe(48, n.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration = ScreenTriangle._vertexDeclaration, 
            e._vertexBuffer.setData(ScreenTriangle._vertices.buffer), e._bufferState.bind(), 
            e._bufferState.applyVertexBuffer(e._vertexBuffer), e._bufferState.unBind(), e._vertexBufferInvertUV = new qe(48, n.STATIC_DRAW, !1), 
            e._vertexBufferInvertUV.vertexDeclaration = ScreenTriangle._vertexDeclaration, e._vertexBufferInvertUV.setData(ScreenTriangle._verticesInvertUV.buffer), 
            e._bufferStateInvertUV.bind(), e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV), 
            e._bufferStateInvertUV.unBind(), e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength), 
            e;
        }
        return _inherits(ScreenTriangle, t.Resource), _createClass(ScreenTriangle, [ {
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenTriangle.prototype), "destroy", this).call(this), this._bufferState.destroy(), 
                this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), 
                this._setGPUMemory(0);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                ScreenTriangle._vertexDeclaration = new je(16, [ new Ze(0, Ye.Vector4, ScreenTriangle.SCREENTRIANGLE_POSITION_UV) ]), 
                ScreenTriangle.instance = new ScreenTriangle(), ScreenTriangle.instance.lock = !0;
            }
        } ]), ScreenTriangle;
    }();
    it.SCREENTRIANGLE_POSITION_UV = 0, it._vertices = new Float32Array([ -1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0 ]), 
    it._verticesInvertUV = new Float32Array([ -1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1 ]);
    var at = function() {
        function Command() {
            _classCallCheck(this, Command), this._commandBuffer = null;
        }
        return _createClass(Command, [ {
            key: "run",
            value: function() {}
        }, {
            key: "recover",
            value: function() {
                this._commandBuffer = null;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                Command._screenShaderData = new ce(), Command._screenShader = ue.find("BlitScreen");
            }
        } ]), Command;
    }();
    at.SCREENTEXTURE_NAME = "u_MainTex", at.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale", 
    at.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", at.SCREENTEXTURE_ID = ue.propertyNameToID(at.SCREENTEXTURE_NAME), 
    at.SCREENTEXTUREOFFSETSCALE_ID = ue.propertyNameToID(at.SCREENTEXTUREOFFSETSCALE_NAME), 
    at.MAINTEXTURE_TEXELSIZE_ID = ue.propertyNameToID(at.MAINTEXTURE_TEXELSIZE_NAME);
    var ot = function(e) {
        function BlitScreenQuadCMD() {
            var e;
            return _classCallCheck(this, BlitScreenQuadCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(BlitScreenQuadCMD).apply(this, arguments)))._source = null, 
            e._dest = null, e._offsetScale = null, e._shader = null, e._shaderData = null, e._subShader = 0, 
            e._sourceTexelSize = new i(), e._screenType = 0, e;
        }
        return _inherits(BlitScreenQuadCMD, at), _createClass(BlitScreenQuadCMD, [ {
            key: "run",
            value: function() {
                var e = this._shader || at._screenShader, n = this._shaderData || at._screenShaderData, r = this._dest;
                t.LayaGL.instance.viewport(0, 0, r ? r.width : re.clientWidth, r ? r.height : re.clientHeight), 
                n.setTexture(at.SCREENTEXTURE_ID, this._source), n.setVector(at.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitScreenQuadCMD._defaultOffsetScale), 
                this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height), 
                n.setVector(at.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), r && r._start();
                for (var i = e.getSubShaderAt(this._subShader)._passes, a = 0, o = i.length; a < o; a++) {
                    var s = BlitScreenQuadCMD._compileDefine;
                    n._defineDatas.cloneTo(s);
                    var l = i[a].withCompile(s);
                    switch (l.bind(), l.uploadUniforms(l._materialUniformParamsMap, n, !0), l.uploadRenderStateBlendDepth(n), 
                    l.uploadRenderStateFrontFace(n, !1, null), this._screenType) {
                      case BlitScreenQuadCMD._SCREENTYPE_QUAD:
                        re._instance.invertY ? rt.instance.renderInvertUV() : rt.instance.render();
                        break;

                      case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
                        re._instance.invertY ? it.instance.renderInvertUV() : it.instance.render();
                        break;

                      default:
                        throw "BlitScreenQuadCMD:unknown screen Type.";
                    }
                }
                r && r._end();
            }
        }, {
            key: "recover",
            value: function() {
                BlitScreenQuadCMD._pool.push(this), this._source = null, this._dest = null, this._offsetScale = null, 
                this._shader = null, this._shaderData = null, _get(_getPrototypeOf(BlitScreenQuadCMD.prototype), "recover", this).call(this);
            }
        } ], [ {
            key: "create",
            value: function(e, t) {
                var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : BlitScreenQuadCMD._SCREENTYPE_QUAD;
                return (n = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD())._source = e, 
                n._dest = t, n._offsetScale = r, n._shader = i, n._shaderData = a, n._subShader = o, 
                n._screenType = s, n;
            }
        } ]), BlitScreenQuadCMD;
    }();
    ot._SCREENTYPE_QUAD = 0, ot._SCREENTYPE_TRIANGLE = 1, ot._compileDefine = new ae(), 
    ot._pool = [], ot._defaultOffsetScale = new i(0, 0, 1, 1);
    var st = function(e) {
        function SetRenderTargetCMD() {
            var e;
            return _classCallCheck(this, SetRenderTargetCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(SetRenderTargetCMD).apply(this, arguments)))._renderTexture = null, 
            e;
        }
        return _inherits(SetRenderTargetCMD, at), _createClass(SetRenderTargetCMD, [ {
            key: "run",
            value: function() {
                this._renderTexture._start();
            }
        }, {
            key: "recover",
            value: function() {
                SetRenderTargetCMD._pool.push(this), this._renderTexture = null;
            }
        } ], [ {
            key: "create",
            value: function(e) {
                var t;
                return (t = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD())._renderTexture = e, 
                t;
            }
        } ]), SetRenderTargetCMD;
    }();
    st._pool = [];
    var lt = function(e) {
        function SetShaderDataTextureCMD() {
            var e;
            return _classCallCheck(this, SetShaderDataTextureCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(SetShaderDataTextureCMD).apply(this, arguments)))._shaderData = null, 
            e._nameID = 0, e._texture = null, e;
        }
        return _inherits(SetShaderDataTextureCMD, at), _createClass(SetShaderDataTextureCMD, [ {
            key: "run",
            value: function() {
                this._shaderData.setTexture(this._nameID, this._texture);
            }
        }, {
            key: "recover",
            value: function() {
                SetShaderDataTextureCMD._pool.push(this), this._shaderData = null, this._nameID = 0, 
                this._texture = null;
            }
        } ], [ {
            key: "create",
            value: function(e, t, n) {
                var r;
                return (r = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD())._shaderData = e, 
                r._nameID = t, r._texture = n, r;
            }
        } ]), SetShaderDataTextureCMD;
    }();
    lt._pool = [];
    var ut, ct = function() {
        function CommandBuffer() {
            _classCallCheck(this, CommandBuffer), this._camera = null, this._commands = [];
        }
        return _createClass(CommandBuffer, [ {
            key: "_apply",
            value: function() {
                for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run();
            }
        }, {
            key: "setShaderDataTexture",
            value: function(e, t, n) {
                this._commands.push(lt.create(e, t, n));
            }
        }, {
            key: "blitScreenQuad",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                this._commands.push(ot.create(e, t, n, r, i, a, ot._SCREENTYPE_QUAD));
            }
        }, {
            key: "blitScreenTriangle",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null, a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                this._commands.push(ot.create(e, t, n, r, i, a, ot._SCREENTYPE_TRIANGLE));
            }
        }, {
            key: "setRenderTarget",
            value: function(e) {
                this._commands.push(st.create(e));
            }
        }, {
            key: "clear",
            value: function() {
                for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].recover();
                this._commands.length = 0;
            }
        } ]), CommandBuffer;
    }(), ht = function Scene3DShaderDeclaration() {
        _classCallCheck(this, Scene3DShaderDeclaration);
    };
    (ut = e.LightType || (e.LightType = {}))[ut.Directional = 0] = "Directional", ut[ut.Spot = 1] = "Spot", 
    ut[ut.Point = 2] = "Point";
    var _t, dt, ft = function(t) {
        function LightSprite() {
            var t;
            return _classCallCheck(this, LightSprite), (t = _possibleConstructorReturn(this, _getPrototypeOf(LightSprite).call(this)))._shadowMode = e.ShadowMode.None, 
            t._isAlternate = !1, t._shadowResolution = 2048, t._shadowDistance = 50, t._shadowDepthBias = 1, 
            t._shadowNormalBias = 1, t._shadowNearPlane = .1, t._shadowStrength = 1, t._intensity = 1, 
            t._intensityColor = new o(), t.color = new o(1, 1, 1), t._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME, 
            t;
        }
        return _inherits(LightSprite, et), _createClass(LightSprite, [ {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(LightSprite.prototype), "_parse", this).call(this, e, t);
                var n = e.color;
                this.color.fromArray(n), this.intensity = e.intensity, this.lightmapBakedType = e.lightmapBakedType;
            }
        }, {
            key: "_addToScene",
            value: function() {
                var e = this._scene, t = w._config.maxLightCount;
                e._lightCount < t ? (e._lightCount++, this._addToLightQueue(), this._isAlternate = !1) : (e._alternateLights.add(this), 
                this._isAlternate = !0, console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore."));
            }
        }, {
            key: "_removeFromScene",
            value: function() {
                var e = this._scene;
                if (this._isAlternate) e._alternateLights.remove(this); else if (e._lightCount--, 
                this._removeFromLightQueue(), e._alternateLights._length > 0) {
                    var t = e._alternateLights.shift();
                    t._addToLightQueue(), t._isAlternate = !1, e._lightCount++;
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function() {}
        }, {
            key: "_removeFromLightQueue",
            value: function() {}
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onActive", this).call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._addToScene();
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onInActive", this).call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._removeFromScene();
            }
        }, {
            key: "_create",
            value: function() {
                return new LightSprite();
            }
        }, {
            key: "intensity",
            get: function() {
                return this._intensity;
            },
            set: function(e) {
                this._intensity = e;
            }
        }, {
            key: "shadowMode",
            get: function() {
                return this._shadowMode;
            },
            set: function(e) {
                this._shadowMode = e;
            }
        }, {
            key: "shadowDistance",
            get: function() {
                return this._shadowDistance;
            },
            set: function(e) {
                this._shadowDistance = e;
            }
        }, {
            key: "shadowResolution",
            get: function() {
                return this._shadowResolution;
            },
            set: function(e) {
                this._shadowResolution = e;
            }
        }, {
            key: "shadowDepthBias",
            get: function() {
                return this._shadowDepthBias;
            },
            set: function(e) {
                this._shadowDepthBias = e;
            }
        }, {
            key: "shadowNormalBias",
            get: function() {
                return this._shadowNormalBias;
            },
            set: function(e) {
                this._shadowNormalBias = e;
            }
        }, {
            key: "shadowStrength",
            get: function() {
                return this._shadowStrength;
            },
            set: function(e) {
                this._shadowStrength = e;
            }
        }, {
            key: "shadowNearPlane",
            get: function() {
                return this._shadowNearPlane;
            },
            set: function(e) {
                this._shadowNearPlane = e;
            }
        }, {
            key: "lightmapBakedType",
            get: function() {
                return this._lightmapBakedType;
            },
            set: function(e) {
                this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this._addToScene() : this._removeFromScene()));
            }
        }, {
            key: "diffuseColor",
            get: function() {
                return console.log("LightSprite: discard property,please use color property instead."), 
                this.color;
            },
            set: function(e) {
                console.log("LightSprite: discard property,please use color property instead."), 
                this.color = e;
            }
        } ]), LightSprite;
    }();
    ft.LIGHTMAPBAKEDTYPE_REALTIME = 0, ft.LIGHTMAPBAKEDTYPE_MIXED = 1, ft.LIGHTMAPBAKEDTYPE_BAKED = 2, 
    (_t = e.ShadowCascadesMode || (e.ShadowCascadesMode = {}))[_t.NoCascades = 0] = "NoCascades", 
    _t[_t.TwoCascades = 1] = "TwoCascades", _t[_t.FourCascades = 2] = "FourCascades", 
    function(e) {
        e[e.Near = 0] = "Near", e[e.Far = 1] = "Far", e[e.Left = 2] = "Left", e[e.Right = 3] = "Right", 
        e[e.Bottom = 4] = "Bottom", e[e.Top = 5] = "Top";
    }(dt || (dt = {}));
    var mt, Tt = function() {
        function ShadowUtils() {
            _classCallCheck(this, ShadowUtils);
        }
        return _createClass(ShadowUtils, null, [ {
            key: "supportShadow",
            value: function() {
                return t.LayaGL.layaGPUInstance._isWebGL2 || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.Depth);
            }
        }, {
            key: "init",
            value: function() {
                t.LayaGL.layaGPUInstance._isWebGL2 ? ShadowUtils._shadowTextureFormat = t.RenderTextureFormat.ShadowMap : ShadowUtils._shadowTextureFormat = t.RenderTextureFormat.Depth;
            }
        }, {
            key: "getTemporaryShadowTexture",
            value: function(e, n, r) {
                var i = ie.createFromPool(e, n, ShadowUtils._shadowTextureFormat, r);
                return i.filterMode = t.FilterMode.Bilinear, i.wrapModeU = t.WarpMode.Clamp, i.wrapModeV = t.WarpMode.Clamp, 
                i;
            }
        }, {
            key: "getShadowBias",
            value: function(t, r, i, a) {
                var o;
                t._lightType == e.LightType.Directional ? o = 2 / r.elements[0] : t._lightType == e.LightType.Spot ? o = Math.tan(.5 * t.spotAngle * n.Deg2Rad) * t.range : (console.warn("ShadowUtils:Only spot and directional shadow casters are supported now."), 
                o = 0);
                var s = o / i, l = -t._shadowDepthBias * s, u = -t._shadowNormalBias * s;
                if (t.shadowMode == e.ShadowMode.SoftHigh) {
                    l *= 2.5, u *= 2.5;
                }
                a.setValue(l, u, 0, 0);
            }
        }, {
            key: "getCameraFrustumPlanes",
            value: function(e, t) {
                Ue.getPlanesFromMatrix(e, t[dt.Near], t[dt.Far], t[dt.Left], t[dt.Right], t[dt.Top], t[dt.Bottom]);
            }
        }, {
            key: "getFarWithRadius",
            value: function(e, t) {
                return Math.sqrt(e * e / t);
            }
        }, {
            key: "getCascadesSplitDistance",
            value: function(t, n, r, i, a, o, s, l) {
                l[0] = r;
                var u = i - r, c = Math.tan(.5 * a), h = 1 + c * c * (o * o + 1);
                switch (s) {
                  case e.ShadowCascadesMode.NoCascades:
                    l[1] = ShadowUtils.getFarWithRadius(i, h);
                    break;

                  case e.ShadowCascadesMode.TwoCascades:
                    l[1] = ShadowUtils.getFarWithRadius(r + u * t, h), l[2] = ShadowUtils.getFarWithRadius(i, h);
                    break;

                  case e.ShadowCascadesMode.FourCascades:
                    l[1] = ShadowUtils.getFarWithRadius(r + u * n.x, h), l[2] = ShadowUtils.getFarWithRadius(r + u * n.y, h), 
                    l[3] = ShadowUtils.getFarWithRadius(r + u * n.z, h), l[4] = ShadowUtils.getFarWithRadius(i, h);
                }
            }
        }, {
            key: "applySliceTransform",
            value: function(e, t, n, r, i) {
                var a = ShadowUtils._tempMatrix0.elements, o = 1 / t, s = 1 / n;
                a[0] = e.resolution * o, a[5] = e.resolution * s, a[12] = e.offsetX * o, a[13] = e.offsetY * s, 
                a[1] = a[2] = a[2] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[14] = 0, a[10] = a[15] = 1;
                var l = 16 * r;
                O._mulMatrixArray(a, i, l, i, l);
            }
        }, {
            key: "getDirectionLightShadowCullPlanes",
            value: function(t, n, r, i, a, s) {
                var l = ShadowUtils._frustumCorners, u = ShadowUtils._backPlaneFaces, c = ShadowUtils._frustumPlaneNeighbors, h = ShadowUtils._frustumTwoPlaneCorners, _ = ShadowUtils._edgePlanePoint2, d = s.cullPlanes, f = t[dt.Near], m = t[dt.Far], T = t[dt.Left], p = t[dt.Right], g = t[dt.Bottom], E = t[dt.Top], y = r[n] - i, v = ShadowUtils._adjustNearPlane, S = ShadowUtils._adjustFarPlane;
                f.normal.cloneTo(v.normal), m.normal.cloneTo(S.normal), v.distance = f.distance - y, 
                S.distance = Math.min(-f.distance + s.sphereCenterZ + s.splitBoundSphere.radius, m.distance), 
                Ue.get3PlaneInterPoint(v, g, p, l[e.FrustumCorner.nearBottomRight]), Ue.get3PlaneInterPoint(v, E, p, l[e.FrustumCorner.nearTopRight]), 
                Ue.get3PlaneInterPoint(v, E, T, l[e.FrustumCorner.nearTopLeft]), Ue.get3PlaneInterPoint(v, g, T, l[e.FrustumCorner.nearBottomLeft]), 
                Ue.get3PlaneInterPoint(S, g, p, l[e.FrustumCorner.FarBottomRight]), Ue.get3PlaneInterPoint(S, E, p, l[e.FrustumCorner.FarTopRight]), 
                Ue.get3PlaneInterPoint(S, E, T, l[e.FrustumCorner.FarTopLeft]), Ue.get3PlaneInterPoint(S, g, T, l[e.FrustumCorner.FarBottomLeft]);
                for (var C = 0, R = 0; R < 6; R++) {
                    var D;
                    switch (R) {
                      case dt.Near:
                        D = v;
                        break;

                      case dt.Far:
                        D = S;
                        break;

                      default:
                        D = t[R];
                    }
                    o.dot(D.normal, a) < 0 && (D.cloneTo(d[C]), u[C] = R, C++);
                }
                var M = C;
                for (R = 0; R < C; R++) for (var A = u[R], x = c[A], L = 0; L < 4; L++) {
                    for (var I = x[L], O = !0, P = 0; P < C; P++) if (I == u[P]) {
                        O = !1;
                        break;
                    }
                    if (O) {
                        var N = h[A][I], b = l[N[0]], k = l[N[1]];
                        o.add(b, a, _), ke.createPlaneBy3P(b, k, _, d[M++]);
                    }
                }
                s.cullPlaneCount = M;
            }
        }, {
            key: "getBoundSphereByFrustum",
            value: function(e, t, n, r, i, a, s) {
                var l, u, c = Math.sqrt(1 + r * r) * Math.tan(n / 2), h = c * c, _ = t - e, d = t + e;
                h > _ / d ? (l = t, u = t * c) : (l = .5 * d * (1 + h), u = .5 * Math.sqrt(_ * _ + 2 * (t * t + e * e) * h + d * d * h * h));
                var f = s.center;
                return s.radius = u, o.scale(a, l, f), o.add(i, f, f), l;
            }
        }, {
            key: "getMaxTileResolutionInAtlas",
            value: function(e, t, n) {
                for (var r = Math.min(e, t), i = Math.floor(e / r) * Math.floor(t / r); i < n; ) r = Math.floor(r >> 1), 
                i = Math.floor(e / r) * Math.floor(t / r);
                return r;
            }
        }, {
            key: "getDirectionalLightMatrices",
            value: function(e, t, n, r, i, a, s, l) {
                var u = s.splitBoundSphere, h = u.center, _ = u.radius, d = a / 2, f = _ * d / (d - ShadowUtils.atlasBorderSize), m = 2 * f, T = a / m, p = m / a, g = Math.ceil(o.dot(h, e) * T) * p, E = Math.ceil(o.dot(h, t) * T) * p, y = o.dot(h, n);
                h.x = e.x * g + t.x * E + n.x * y, h.y = e.y * g + t.y * E + n.y * y, h.z = e.z * g + t.z * E + n.z * y;
                var v = s.position, S = s.viewMatrix, C = s.projectionMatrix, R = s.viewProjectMatrix;
                s.resolution = a, s.offsetX = r % 2 * a, s.offsetY = Math.floor(r / 2) * a, o.scale(n, _ + i, v), 
                o.subtract(h, v, v), c.createLookAt(v, h, e, S), c.createOrthoOffCenter(-f, f, -f, f, 0, 2 * _ + i, C), 
                c.multiply(C, S, R), O._mulMatrixArray(ShadowUtils._shadowMapScaleOffsetMatrix.elements, R.elements, 0, l, 16 * r);
            }
        }, {
            key: "getSpotLightShadowData",
            value: function(e, t, n, r, i, a) {
                var o = e.position = t.transform.position;
                e.resolution = n, a.setValue(1 / n, 1 / n, n, n), e.offsetX = 0, e.offsetY = 0;
                var s = t.transform.worldMatrix, l = e.viewMatrix, u = e.projectionMatrix, h = e.viewProjectMatrix, _ = e.cameraCullInfo.boundFrustum;
                s.invert(l), c.createPerspective(3.1416 * t.spotAngle / 180, 1, .1, t.range, u), 
                r.y = t.shadowStrength, c.multiply(u, l, h), _.matrix = h, h.cloneTo(i), e.cameraCullInfo.position = o;
            }
        }, {
            key: "prepareShadowReceiverShaderValues",
            value: function(e, t, n, r, i, a, o, s, l) {
                if (a.setValue(1 / t, 1 / n, t, n), o.setValue(e._shadowStrength, 0, 0, 0), i > 1) {
                    for (var u = 16 * i, c = 64; u < c; u++) s[u] = 0;
                    for (u = 0; u < i; u++) {
                        var h = r[u].splitBoundSphere, _ = h.center, d = h.radius, f = 4 * u;
                        l[f] = _.x, l[f + 1] = _.y, l[f + 2] = _.z, l[f + 3] = d * d;
                    }
                    for (u = 4 * i, c = 16; u < c; u++) l[u] = 0;
                }
            }
        } ]), ShadowUtils;
    }();
    Tt._tempMatrix0 = new c(), Tt._shadowMapScaleOffsetMatrix = new c(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, 1, 0, .5, .5, 0, 1), 
    Tt._frustumCorners = [ new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o() ], 
    Tt._adjustNearPlane = new ke(new o()), Tt._adjustFarPlane = new ke(new o()), Tt._backPlaneFaces = new Array(5), 
    Tt._edgePlanePoint2 = new o(), Tt._frustumPlaneNeighbors = [ [ dt.Left, dt.Right, dt.Top, dt.Bottom ], [ dt.Left, dt.Right, dt.Top, dt.Bottom ], [ dt.Near, dt.Far, dt.Top, dt.Bottom ], [ dt.Near, dt.Far, dt.Top, dt.Bottom ], [ dt.Near, dt.Far, dt.Left, dt.Right ], [ dt.Near, dt.Far, dt.Left, dt.Right ] ], 
    Tt._frustumTwoPlaneCorners = [ [ [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearTopLeft ], [ e.FrustumCorner.nearTopRight, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearTopRight ] ], [ [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarTopRight ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.FarTopLeft ] ], [ [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarTopLeft ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.nearTopLeft ] ], [ [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearTopRight ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.nearTopRight, e.FrustumCorner.FarTopRight ] ], [ [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ] ], [ [ e.FrustumCorner.nearTopRight, e.FrustumCorner.nearTopLeft ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarTopRight ], [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.FarTopLeft ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.nearTopRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ] ] ], 
    Tt.atlasBorderSize = 4, (mt = e.CameraClearFlags || (e.CameraClearFlags = {}))[mt.SolidColor = 0] = "SolidColor", 
    mt[mt.Sky = 1] = "Sky", mt[mt.DepthOnly = 2] = "DepthOnly", mt[mt.Nothing = 3] = "Nothing";
    var pt = function(n) {
        function Camera() {
            var n, a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
            return _classCallCheck(this, Camera), (n = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this, o, s)))._updateViewMatrix = !0, 
            n._postProcess = null, n._enableHDR = !1, n._viewportParams = new i(), n._projectionParams = new i(), 
            n._offScreenRenderTexture = null, n._internalRenderTexture = null, n._postProcessCommandBuffers = [], 
            n._clusterPlaneCacheFlag = new r(-1, -1), n._screenOffsetScale = new i(), n.enableRender = !0, 
            n.clearFlag = e.CameraClearFlags.SolidColor, n._viewMatrix = new c(), n._projectionMatrix = new c(), 
            n._projectionViewMatrix = new c(), n._viewport = new Ge(0, 0, 0, 0), n._normalizedViewport = new Ge(0, 0, 1, 1), 
            n._aspectRatio = a, n._boundFrustum = new Ue(new c()), t.Render.supportWebGLPlusCulling && (n._boundFrustumBuffer = new Float32Array(24)), 
            n._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE, _assertThisInitialized(n), n._onScreenSizeChanged), 
            n.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(n), n._onTransformChanged), 
            n;
        }
        return _inherits(Camera, nt), _createClass(Camera, [ {
            key: "_calculationViewport",
            value: function(e, t, n) {
                var r = e.x * t, i = e.y * n, a = r + Math.max(e.width * t, 0), o = i + Math.max(e.height * n, 0), s = Math.ceil(r), l = Math.ceil(i), u = Math.floor(a), c = Math.floor(o), h = s - r >= .5 ? Math.floor(r) : s, _ = l - i >= .5 ? Math.floor(i) : l, d = a - u >= .5 ? Math.ceil(a) : u, f = o - c >= .5 ? Math.ceil(o) : c;
                this._viewport.x = h, this._viewport.y = _, this._viewport.width = d - h, this._viewport.height = f - _;
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {
                if (!this._useUserProjectionMatrix) if (this._orthographic) {
                    var e = .5 * this.orthographicVerticalSize, t = e * this.aspectRatio;
                    c.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
                } else c.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
            }
        }, {
            key: "_isLayerVisible",
            value: function(e) {
                return 0 != (Math.pow(2, e) & this.cullingMask);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                (e &= f.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(Camera.prototype), "_parse", this).call(this, e, t);
                var n = e.clearFlag;
                void 0 !== n && (this.clearFlag = n);
                var r = e.viewport;
                this.normalizedViewport = new Ge(r[0], r[1], r[2], r[3]);
                var i = e.enableHDR;
                void 0 !== i && (this.enableHDR = i);
            }
        }, {
            key: "_getCanvasWidth",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : re.clientWidth;
            }
        }, {
            key: "_getCanvasHeight",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : re.clientHeight;
            }
        }, {
            key: "_getRenderTexture",
            value: function() {
                return this._internalRenderTexture || this._offScreenRenderTexture;
            }
        }, {
            key: "_needInternalRenderTexture",
            value: function() {
                return !(!this._postProcess && !this._enableHDR);
            }
        }, {
            key: "_applyPostProcessCommandBuffers",
            value: function() {
                for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) this._postProcessCommandBuffers[e]._apply();
            }
        }, {
            key: "_getRenderTextureFormat",
            value: function() {
                return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t.RenderTextureFormat.R8G8B8;
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                _get(_getPrototypeOf(Camera.prototype), "_prepareCameraToRender", this).call(this);
                var e = this.viewport;
                this._viewportParams.setValue(e.x, e.y, e.width, e.height), this._projectionParams.setValue(this._nearPlane, this._farPlane, re._instance.invertY ? -1 : 1, 0), 
                this._shaderValues.setVector(nt.VIEWPORT, this._viewportParams), this._shaderValues.setVector(nt.PROJECTION_PARAMS, this._projectionParams);
            }
        }, {
            key: "_applyViewProject",
            value: function(e, t, n) {
                var r, i = this._shaderValues;
                e.invertY ? (c.multiply(nt._invertYScaleMatrix, n, nt._invertYProjectionMatrix), 
                c.multiply(nt._invertYProjectionMatrix, t, nt._invertYProjectionViewMatrix), n = nt._invertYProjectionMatrix, 
                r = nt._invertYProjectionViewMatrix) : (c.multiply(n, t, this._projectionViewMatrix), 
                r = this._projectionViewMatrix), e.viewMatrix = t, e.projectionMatrix = n, e.projectionViewMatrix = r, 
                i.setMatrix4x4(nt.VIEWMATRIX, t), i.setMatrix4x4(nt.PROJECTMATRIX, n), i.setMatrix4x4(nt.VIEWPROJECTMATRIX, r);
            }
        }, {
            key: "_updateClusterPlaneXY",
            value: function() {
                var e = this.fieldOfView, t = this.aspectRatio;
                if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !== t) {
                    var n = w._config.lightClusterCount, r = n.x, i = n.y, a = r + 1, s = i + 1, l = this._clusterXPlanes, u = this._clusterYPlanes;
                    if (!l) {
                        l = this._clusterXPlanes = new Array(a), u = this._clusterYPlanes = new Array(s);
                        for (var c = 0; c < a; c++) l[c] = new o();
                        for (c = 0; c < s; c++) u[c] = new o();
                    }
                    var h = Math.tan(this.fieldOfView / 2 * Math.PI / 180), _ = this.aspectRatio * h, d = 2 * h / r, f = 2 * _ / i;
                    for (c = 0; c < a; c++) {
                        var m = f * c - _, T = 1 / Math.sqrt(1 + m * m);
                        l[c].setValue(T, 0, -m * T);
                    }
                    for (c = 0; c < s; c++) {
                        m = h - d * c;
                        var p = -1 / Math.sqrt(1 + m * m);
                        u[c].setValue(0, p, -m * p);
                    }
                    this._clusterPlaneCacheFlag.x = e, this._clusterPlaneCacheFlag.y = t;
                }
            }
        }, {
            key: "render",
            value: function() {
                var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (this.activeInHierarchy) {
                    var i, a = this.viewport, o = this._needInternalRenderTexture(), s = t.LayaGL.instance, u = re._instance, c = u.scene = this._scene;
                    u.pipelineMode = "Forward", o ? (this._internalRenderTexture = ie.createFromPool(a.width, a.height, this._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTH_16), 
                    this._internalRenderTexture.filterMode = t.FilterMode.Bilinear) : this._internalRenderTexture = null;
                    var h = c._mainDirectionLight, _ = h && h.shadowMode !== e.ShadowMode.None && Tt.supportShadow();
                    _ ? (c._shaderValues.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT), c._shaderValues.addDefine(ht.SHADERDEFINE_SHADOW), 
                    (i = l.Scene3D._shadowCasterPass).update(this, h, l.ShadowLightType.DirectionLight), 
                    i.render(u, c, l.ShadowLightType.DirectionLight)) : c._shaderValues.removeDefine(ht.SHADERDEFINE_SHADOW);
                    var d = c._mainSpotLight, f = d && d.shadowMode !== e.ShadowMode.None && Tt.supportShadow();
                    if (f ? (c._shaderValues.removeDefine(ht.SHADERDEFINE_SHADOW), c._shaderValues.addDefine(ht.SHADERDEFINE_SHADOW_SPOT), 
                    (i = l.Scene3D._shadowCasterPass).update(this, d, l.ShadowLightType.SpotLight), 
                    i.render(u, c, l.ShadowLightType.SpotLight)) : c._shaderValues.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT), 
                    _ && c._shaderValues.addDefine(ht.SHADERDEFINE_SHADOW), f && c._shaderValues.addDefine(ht.SHADERDEFINE_SHADOW_SPOT), 
                    u.camera = this, u.cameraShaderValue = this._shaderValues, Camera._updateMark++, 
                    c._preRenderScript(), o && !this._offScreenRenderTexture && (this.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e.CameraClearFlags.Nothing)) if (this._enableHDR) {
                        var m = ie.createFromPool(a.width, a.height, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16);
                        m.filterMode = t.FilterMode.Bilinear, t.WebGLContext.bindTexture(s, s.TEXTURE_2D, m._getSource()), 
                        s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, a.x, re.clientHeight - (a.y + a.height), a.width, a.height), 
                        (p = ot.create(m, this._internalRenderTexture)).run(), p.recover(), ie.recoverToPool(m);
                    } else t.WebGLContext.bindTexture(s, s.TEXTURE_2D, this._internalRenderTexture._getSource()), 
                    s.copyTexSubImage2D(s.TEXTURE_2D, 0, 0, 0, a.x, re.clientHeight - (a.y + a.height), a.width, a.height);
                    var T = this._getRenderTexture();
                    if (T && T._start(), u.viewport = a, this._prepareCameraToRender(), w._config._multiLighting && Oe.instance.update(this, this._scene), 
                    this._applyViewProject(u, this.viewMatrix, this._projectionMatrix), c._preCulling(u, this, n, r), 
                    c._clear(s, u), c._renderScene(u), c._postRenderScript(), T && T._end(), o) {
                        if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers(); else if (this._enableHDR) {
                            var p, g = this._getCanvasWidth(), E = this._getCanvasHeight();
                            this._screenOffsetScale.setValue(a.x / g, a.y / E, a.width / g, a.height / E), (p = ot.create(this._internalRenderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null, this._screenOffsetScale)).run(), 
                            p.recover();
                        }
                        ie.recoverToPool(this._internalRenderTexture);
                    }
                    (_ || f) && i.cleanUp();
                }
            }
        }, {
            key: "viewportPointToRay",
            value: function(e, t) {
                He.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "normalizedViewportPointToRay",
            value: function(e, t) {
                var n = Camera._tempVector20, r = this.viewport;
                n.x = e.x * r.width, n.y = e.y * r.height, He.calculateCursorRay(n, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "worldToViewportPoint",
            value: function(e, n) {
                c.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
                this.viewport.project(e, this._projectionViewMatrix, n), n.x = n.x / t.Laya.stage.clientScaleX, 
                n.y = n.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "worldToNormalizedViewportPoint",
            value: function(e, n) {
                c.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
                this.normalizedViewport.project(e, this._projectionViewMatrix, n), n.x = n.x / t.Laya.stage.clientScaleX, 
                n.y = n.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "convertScreenCoordToOrthographicCoord",
            value: function(e, n) {
                if (this._orthographic) {
                    var r = re.clientWidth, i = re.clientHeight, a = this.orthographicVerticalSize * this.aspectRatio / r, s = this.orthographicVerticalSize / i;
                    return n.x = (-r / 2 + e.x * t.Laya.stage.clientScaleX) * a, n.y = (i / 2 - e.y * t.Laya.stage.clientScaleY) * s, 
                    n.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane, o.transformCoordinate(n, this.transform.worldMatrix, n), 
                    !0;
                }
                return !1;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._offScreenRenderTexture = null, this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged), 
                _get(_getPrototypeOf(Camera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "addCommandBuffer",
            value: function(e, t) {
                switch (e) {
                  case Camera.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.push(t), t._camera = this;
                    break;

                  default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffer",
            value: function(e, t) {
                switch (e) {
                  case Camera.CAMERAEVENT_POSTPROCESS:
                    var n = this._postProcessCommandBuffers.indexOf(t);
                    -1 !== n && this._postProcessCommandBuffers.splice(n, 1);
                    break;

                  default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffers",
            value: function(e) {
                switch (e) {
                  case Camera.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.length = 0;
                    break;

                  default:
                    throw "Camera:unknown event.";
                }
            }
        }, {
            key: "_create",
            value: function() {
                return new Camera();
            }
        }, {
            key: "aspectRatio",
            get: function() {
                if (0 === this._aspectRatio) {
                    var e = this.viewport;
                    return e.width / e.height;
                }
                return this._aspectRatio;
            },
            set: function(e) {
                if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "viewport",
            get: function() {
                return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, re.clientWidth, re.clientHeight), 
                this._viewport;
            },
            set: function(e) {
                var t, n;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, n = this._offScreenRenderTexture.height) : (t = re.clientWidth, 
                n = re.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / n, 
                this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / n, 
                this._calculationViewport(this._normalizedViewport, t, n), this._calculateProjectionMatrix();
            }
        }, {
            key: "normalizedViewport",
            get: function() {
                return this._normalizedViewport;
            },
            set: function(e) {
                var t, n;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, n = this._offScreenRenderTexture.height) : (t = re.clientWidth, 
                n = re.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport), 
                this._calculationViewport(e, t, n), this._calculateProjectionMatrix();
            }
        }, {
            key: "viewMatrix",
            get: function() {
                if (this._updateViewMatrix) {
                    var e = this.transform.getWorldLossyScale(), t = e.x, n = e.y, r = e.z, i = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix), i[0] /= t, i[1] /= t, i[2] /= t, 
                    i[4] /= n, i[5] /= n, i[6] /= n, i[8] /= r, i[9] /= r, i[10] /= r, this._viewMatrix.invert(this._viewMatrix), 
                    this._updateViewMatrix = !1;
                }
                return this._viewMatrix;
            }
        }, {
            key: "projectionMatrix",
            get: function() {
                return this._projectionMatrix;
            },
            set: function(e) {
                this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
            }
        }, {
            key: "projectionViewMatrix",
            get: function() {
                return c.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix), 
                this._projectionViewMatrix;
            }
        }, {
            key: "boundFrustum",
            get: function() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix, t.Render.supportWebGLPlusCulling) {
                    var e = this._boundFrustum.near, n = this._boundFrustum.far, r = this._boundFrustum.left, i = this._boundFrustum.right, a = this._boundFrustum.top, o = this._boundFrustum.bottom, s = e.normal, l = n.normal, u = r.normal, c = i.normal, h = a.normal, _ = o.normal, d = this._boundFrustumBuffer;
                    d[0] = s.x, d[1] = s.y, d[2] = s.z, d[3] = e.distance, d[4] = l.x, d[5] = l.y, d[6] = l.z, 
                    d[7] = n.distance, d[8] = u.x, d[9] = u.y, d[10] = u.z, d[11] = r.distance, d[12] = c.x, 
                    d[13] = c.y, d[14] = c.z, d[15] = i.distance, d[16] = h.x, d[17] = h.y, d[18] = h.z, 
                    d[19] = a.distance, d[20] = _.x, d[21] = _.y, d[22] = _.z, d[23] = o.distance;
                }
                return this._boundFrustum;
            }
        }, {
            key: "renderTarget",
            get: function() {
                return this._offScreenRenderTexture;
            },
            set: function(e) {
                var t = this._offScreenRenderTexture;
                t !== e && (t && (t._isCameraTarget = !1), e && (e._isCameraTarget = !0), this._offScreenRenderTexture = e, 
                this._calculateProjectionMatrix());
            }
        }, {
            key: "postProcess",
            get: function() {
                return this._postProcess;
            },
            set: function(e) {
                this._postProcess = e;
                var t = new ct();
                this.addCommandBuffer(Camera.CAMERAEVENT_POSTPROCESS, t), e._init(this, t);
            }
        }, {
            key: "enableHDR",
            get: function() {
                return this._enableHDR;
            },
            set: function(e) {
                !e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.R16G16B16A16) ? this._enableHDR = e : console.warn("Camera:can't enable HDR in this device.");
            }
        } ]), Camera;
    }();
    pt.CAMERAEVENT_POSTPROCESS = 0, pt._tempVector20 = new r(), pt._updateMark = 0;
    var gt = function() {
        function Input3D() {
            var e = this;
            _classCallCheck(this, Input3D), this._eventList = [], this._mouseTouch = new Ne(), 
            this._touchPool = [], this._touches = new De(), this._multiTouchEnabled = !0, this._pushEventList = function(t) {
                t.cancelable && t.preventDefault(), e._eventList.push(t);
            }.bind(this);
        }
        return _createClass(Input3D, [ {
            key: "__init__",
            value: function(e, t) {
                this._scene = t, e.oncontextmenu = function(e) {
                    return !1;
                };
            }
        }, {
            key: "_onCanvasEvent",
            value: function(e) {
                e.addEventListener("mousedown", this._pushEventList), e.addEventListener("mouseup", this._pushEventList, !0), 
                e.addEventListener("mousemove", this._pushEventList, !0), e.addEventListener("touchstart", this._pushEventList), 
                e.addEventListener("touchend", this._pushEventList, !0), e.addEventListener("touchmove", this._pushEventList, !0), 
                e.addEventListener("touchcancel", this._pushEventList, !0);
            }
        }, {
            key: "_offCanvasEvent",
            value: function(e) {
                e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener("mouseup", this._pushEventList, !0), 
                e.removeEventListener("mousemove", this._pushEventList, !0), e.removeEventListener("touchstart", this._pushEventList), 
                e.removeEventListener("touchend", this._pushEventList, !0), e.removeEventListener("touchmove", this._pushEventList, !0), 
                e.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0, 
                this._touches.clear();
            }
        }, {
            key: "touchCount",
            value: function() {
                return this._touches.length;
            }
        }, {
            key: "_getTouch",
            value: function(e, t) {
                var n = this._touchPool[e];
                return 0 == t && n && -1 != n._getIndexInList() ? null : 1 == t && n && -1 == n._getIndexInList() ? null : (n || (n = new be(), 
                this._touchPool[e] = n, n._identifier = e), n);
            }
        }, {
            key: "_mouseTouchDown",
            value: function() {
                var e = this._mouseTouch, n = e.sprite;
                if (e._pressedSprite = n, e._pressedLoopCount = t.Stat.loopCount, n) {
                    var r = n._scripts;
                    if (r) for (var i = 0, a = r.length; i < a; i++) r[i].onMouseDown();
                }
            }
        }, {
            key: "_mouseTouchUp",
            value: function() {
                var e, t, n = this._mouseTouch, r = n._pressedSprite;
                n._pressedSprite = null, n._pressedLoopCount = -1;
                var i = n.sprite;
                if (i && i === r) {
                    var a = i._scripts;
                    if (a) for (e = 0, t = a.length; e < t; e++) a[e].onMouseClick();
                }
                if (r) {
                    var o = r._scripts;
                    if (o) for (e = 0, t = o.length; e < t; e++) o[e].onMouseUp();
                }
            }
        }, {
            key: "_mouseTouchRayCast",
            value: function(t) {
                var n = Input3D._tempHitResult0, r = Input3D._tempVector20, i = Input3D._tempRay0;
                n.succeeded = !1;
                var a = this._mouseTouch.mousePositionX, o = this._mouseTouch.mousePositionY;
                r.x = a, r.y = o;
                for (var s = t.length - 1; s >= 0; s--) {
                    var l = t[s], u = l.viewport;
                    if (r.x >= u.x && r.y >= u.y && r.x <= u.width && r.y <= u.height) if (l.viewportPointToRay(r, i), 
                    this._scene._physicsSimulation.rayCast(i, n) || l.clearFlag === e.CameraClearFlags.SolidColor || l.clearFlag === e.CameraClearFlags.Sky) break;
                }
                var c = this._mouseTouch, h = c.sprite;
                if (n.succeeded) {
                    var _ = n.collider.owner;
                    c.sprite = _;
                    var d = _._scripts;
                    if (h !== _ && d) for (var f = 0, m = d.length; f < m; f++) d[f].onMouseEnter();
                } else c.sprite = null;
                if (h && h !== _) {
                    var T = h._scripts;
                    if (T) for (f = 0, m = T.length; f < m; f++) T[f].onMouseOut();
                }
            }
        }, {
            key: "_changeTouches",
            value: function(e, n) {
                for (var r = 0, i = 0, a = this._touches.length, o = 0, s = e.length; o < s; o++) {
                    var l = e[o], u = l.identifier;
                    if (this._multiTouchEnabled || 0 === u) {
                        var c = this._getTouch(u, n), h = this._touchPool[u]._position, _ = Input3D._tempPoint;
                        _.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(_);
                        var d = _.x, f = _.y;
                        switch (n) {
                          case 0:
                            c && this._touches.add(c), r += d, i += f;
                            break;

                          case 1:
                            c && this._touches.remove(c), r -= d, i -= f;
                            break;

                          case 2:
                            r = d - h.x, i = f - h.y;
                        }
                        h.x = d, h.y = f;
                    }
                }
                var m = this._touches.length;
                0 === m ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * a + r) / m, 
                this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * a + i) / m);
            }
        }, {
            key: "_update",
            value: function() {
                var e, n, r, i, a = k._enablePhysics && !L.disableSimulation;
                n = this._eventList.length;
                var o = this._scene._cameraPool;
                if (n > 0) {
                    var s = !1;
                    for (e = 0; e < n; e++) {
                        var l = this._eventList[e];
                        switch (l.type) {
                          case "mousedown":
                            a && this._mouseTouchDown();
                            break;

                          case "mouseup":
                            a && this._mouseTouchUp();
                            break;

                          case "mousemove":
                            var u = Input3D._tempPoint;
                            u.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(u), 
                            this._mouseTouch.mousePositionX = u.x, this._mouseTouch.mousePositionY = u.y, a && (s = !0);
                            break;

                          case "touchstart":
                            var c = this._touches.length;
                            this._changeTouches(l.changedTouches, 0), a && (!w._config.isUseCannonPhysicsEngine && this._mouseTouchRayCast(o), 
                            0 === c && this._mouseTouchDown());
                            break;

                          case "touchend":
                          case "touchcancel":
                            this._changeTouches(l.changedTouches, 1), a && 0 === this._touches.length && this._mouseTouchUp();
                            break;

                          case "touchmove":
                            this._changeTouches(l.changedTouches, 2), a && (s = !0);
                            break;

                          default:
                            throw "Input3D:unkonwn event type.";
                        }
                    }
                    s && !w._config.isUseCannonPhysicsEngine && this._mouseTouchRayCast(o), this._eventList.length = 0;
                }
                if (a) {
                    var h = this._mouseTouch, _ = h._pressedSprite;
                    if (_ && t.Stat.loopCount > h._pressedLoopCount) {
                        var d = _._scripts;
                        if (d) for (r = 0, i = d.length; r < i; r++) d[r].onMouseDrag();
                    }
                    var f = h.sprite;
                    if (f) {
                        var m = f._scripts;
                        if (m) for (r = 0, i = m.length; r < i; r++) m[r].onMouseOver();
                    }
                }
            }
        }, {
            key: "getTouch",
            value: function(e) {
                return e < this._touches.length ? this._touches.elements[e] : null;
            }
        }, {
            key: "multiTouchEnabled",
            get: function() {
                return this._multiTouchEnabled;
            },
            set: function(e) {
                this._multiTouchEnabled = e;
            }
        } ]), Input3D;
    }();
    gt._tempPoint = new t.Point(), gt._tempVector20 = new r(), gt._tempRay0 = new we(new o(), new o()), 
    gt._tempHitResult0 = new M();
    var Et, yt = function PhysicsSettings() {
        _classCallCheck(this, PhysicsSettings), this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
    }, vt = function() {
        function VertexPositionTexture0(e, t) {
            _classCallCheck(this, VertexPositionTexture0), this._position = e, this._textureCoordinate0 = t;
        }
        return _createClass(VertexPositionTexture0, [ {
            key: "position",
            get: function() {
                return this._position;
            }
        }, {
            key: "textureCoordinate0",
            get: function() {
                return this._textureCoordinate0;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTexture0._vertexDeclaration;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                VertexPositionTexture0._vertexDeclaration = new je(20, [ new Ze(0, Ye.Vector3, Qe.MESH_POSITION0), new Ze(12, Ye.Vector2, Qe.MESH_TEXTURECOORDINATE0) ]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTexture0._vertexDeclaration;
            }
        } ]), VertexPositionTexture0;
    }(), St = function(n) {
        function SkyDome() {
            var n, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 48, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48;
            _classCallCheck(this, SkyDome), n = _possibleConstructorReturn(this, _getPrototypeOf(SkyDome).call(this));
            var a = t.LayaGL.instance;
            n._stacks = r, n._slices = i;
            for (var o = vt.vertexDeclaration, s = o.vertexStride / 4, l = (n._stacks + 1) * (n._slices + 1), u = 3 * n._stacks * (n._slices + 1) * 2, c = new Float32Array(l * s), h = new Uint16Array(u), _ = Math.PI / n._stacks, d = 2 * Math.PI / n._slices, f = 0, m = 0, T = 0, p = 0; p < n._stacks + 1; p++) for (var g = Math.sin(p * _), E = Math.cos(p * _), y = 0; y < n._slices + 1; y++) {
                var v = g * Math.sin(y * d), S = g * Math.cos(y * d);
                c[m + 0] = v * SkyDome._radius, c[m + 1] = E * SkyDome._radius, c[m + 2] = S * SkyDome._radius, 
                c[m + 3] = -y / n._slices + .75, c[m + 4] = p / n._stacks, m += s, p != n._stacks - 1 && (h[T++] = f + 1, 
                h[T++] = f, h[T++] = f + (n._slices + 1), h[T++] = f + (n._slices + 1), h[T++] = f, 
                h[T++] = f + n._slices, f++);
            }
            n._vertexBuffer = new qe(4 * c.length, a.STATIC_DRAW, !1), n._vertexBuffer.vertexDeclaration = o, 
            n._indexBuffer = new Xe(e.IndexFormat.UInt16, h.length, a.STATIC_DRAW, !1), n._vertexBuffer.setData(c.buffer), 
            n._indexBuffer.setData(h);
            var C = new We();
            return C.bind(), C.applyVertexBuffer(n._vertexBuffer), C.applyIndexBuffer(n._indexBuffer), 
            C.unBind(), n._bufferState = C, n;
        }
        return _inherits(SkyDome, Ke), _createClass(SkyDome, [ {
            key: "_render",
            value: function(e) {
                var n = t.LayaGL.instance, r = this._indexBuffer.indexCount;
                n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3, 
                t.Stat.renderBatches++;
            }
        }, {
            key: "stacks",
            get: function() {
                return this._stacks;
            }
        }, {
            key: "slices",
            get: function() {
                return this._slices;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                SkyDome.instance = new SkyDome();
            }
        } ]), SkyDome;
    }();
    St._radius = 1, (Et = e.TextureCubeFace || (e.TextureCubeFace = {}))[Et.PositiveX = 0] = "PositiveX", 
    Et[Et.NegativeX = 1] = "NegativeX", Et[Et.PositiveY = 2] = "PositiveY", Et[Et.NegativeY = 3] = "NegativeY", 
    Et[Et.PositiveZ = 4] = "PositiveZ", Et[Et.NegativeZ = 5] = "NegativeZ";
    var Ct = function(n) {
        function TextureCube(e) {
            var n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.TextureFormat.R8G8B8, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, TextureCube), (n = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this, r, i)))._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP, 
            n._width = e, n._height = e;
            var a = t.LayaGL.instance;
            if (n._setWarpMode(a.TEXTURE_WRAP_S, n._wrapModeU), n._setWarpMode(a.TEXTURE_WRAP_T, n._wrapModeV), 
            n._setFilterMode(n._filterMode), n._setAnisotropy(n._anisoLevel), n._mipmap) {
                n._mipmapCount = Math.ceil(Math.log2(e)) + 1;
                for (var o = 0; o < n._mipmapCount; o++) n._setPixels([], o, Math.max(e >> o, 1), Math.max(e >> o, 1));
                n._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else n._mipmapCount = 1, n._setGPUMemory(e * e * 4 * 6);
            return n;
        }
        return _inherits(TextureCube, t.BaseTexture), _createClass(TextureCube, [ {
            key: "_setPixels",
            value: function(e, n, r, i) {
                var a = t.LayaGL.instance, o = this._getGLFormat();
                t.WebGLContext.bindTexture(a, this._glTextureType, this._glTexture), this.format === t.TextureFormat.R8G8B8 ? (a.pixelStorei(a.UNPACK_ALIGNMENT, 1), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[0]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[1]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[2]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[3]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[4]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[5]), 
                a.pixelStorei(a.UNPACK_ALIGNMENT, 4)) : (a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[0]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[1]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[2]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[3]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[4]), 
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, n, o, r, i, 0, o, a.UNSIGNED_BYTE, e[5]));
            }
        }, {
            key: "setSixSideImageSources",
            value: function(e) {
                for (var n, r, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a = 0; a < 6; a++) {
                    var o = e[a];
                    if (!o) return void console.log("TextureCube: image Source can't be null.");
                    var s = o.width, l = o.height;
                    if (a > 0 && n !== s) return void console.log("TextureCube: each side image's width and height must same.");
                    if ((n = s) !== (r = l)) return void console.log("TextureCube: each side image's width and height must same.");
                }
                this._width = n, this._height = r;
                var u = t.LayaGL.instance;
                t.WebGLContext.bindTexture(u, this._glTextureType, this._glTexture);
                var c = this._getGLFormat();
                if (t.Render.isConchApp) {
                    if (1 == i) for (var h = 0; h < 6; h++) e[h].setPremultiplyAlpha(i);
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[0]), 
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[1]), 
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[2]), 
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[3]), 
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[4]), 
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[5]);
                } else i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[0]), 
                u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[1]), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[2]), 
                u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[3]), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[4]), 
                u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[5]), i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
                this._mipmap && this._isPot(n) && this._isPot(r) ? (u.generateMipmap(this._glTextureType), 
                this._setGPUMemory(n * r * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(n * r * 4 * 6), 
                this._setWarpMode(u.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(u.TEXTURE_WRAP_T, this._wrapModeV), 
                this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
            }
        }, {
            key: "setSixSidePixels",
            value: function(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!e) throw new Error("TextureCube:pixels can't be null.");
                var r = Math.max(this._width >> n, 1), i = Math.max(this._height >> n, 1), a = r * i * this._getFormatByteCount();
                if (e[0].length < a) throw "TextureCube:pixels length should at least " + a + ".";
                if (this._setPixels(e, n, r, i), 0 === n) {
                    var o = t.LayaGL.instance;
                    this._setWarpMode(o.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(o.TEXTURE_WRAP_T, this._wrapModeV);
                }
                this._readyed = !0, this._activeResource();
            }
        }, {
            key: "setImageSource",
            value: function(n, r) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a = this._width, o = this._height;
                if (!r || a === r.width && o === r.height) {
                    var s = t.LayaGL.instance;
                    t.WebGLContext.bindTexture(s, this._glTextureType, this._glTexture);
                    var l = this._getGLFormat();
                    switch (n) {
                      case e.TextureCubeFace.NegativeX:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_X, i, l, l, s.UNSIGNED_BYTE, r);
                        break;

                      case e.TextureCubeFace.PositiveX:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X, i, l, l, s.UNSIGNED_BYTE, r);
                        break;

                      case e.TextureCubeFace.NegativeY:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Y, i, l, l, s.UNSIGNED_BYTE, r);
                        break;

                      case e.TextureCubeFace.PositiveY:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Y, i, l, l, s.UNSIGNED_BYTE, r);
                        break;

                      case e.TextureCubeFace.NegativeZ:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Z, i, l, l, s.UNSIGNED_BYTE, r);
                        break;

                      case e.TextureCubeFace.PositiveZ:
                        s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Z, i, l, l, s.UNSIGNED_BYTE, r);
                    }
                    this._mipmap && this._isPot(a) && this._isPot(o) ? (s.generateMipmap(this._glTextureType), 
                    this._setGPUMemory(a * o * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(a * o * 4 * 6), 
                    this._setWarpMode(s.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s.TEXTURE_WRAP_T, this._wrapModeV), 
                    this._setFilterMode(this._filterMode), this._readyed = !0;
                } else console.log("TextureCube: imageSource's width and height must same.");
            }
        }, {
            key: "defaulteTexture",
            get: function() {
                return TextureCube.grayTexture;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = new TextureCube(1, t.TextureFormat.R8G8B8, !1), n = new TextureCube(1, t.TextureFormat.R8G8B8, !1), r = new Uint8Array(3);
                r[0] = 0, r[1] = 0, r[2] = 0, e.setSixSidePixels([ r, r, r, r, r, r ]), e.lock = !0, 
                r[0] = 128, r[1] = 128, r[2] = 128, n.setSixSidePixels([ r, r, r, r, r, r ]), n.lock = !0, 
                TextureCube._grayTexture = n, TextureCube._blackTexture = e;
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
                return n.setSixSideImageSources(e), n;
            }
        }, {
            key: "_parseBin",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, n = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
                return n.setSixSideImageSources(e), n;
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.ILaya.loader.create(e, n, null, TextureCube.TEXTURECUBE);
            }
        }, {
            key: "blackTexture",
            get: function() {
                return TextureCube._blackTexture;
            }
        }, {
            key: "grayTexture",
            get: function() {
                return TextureCube._grayTexture;
            }
        } ]), TextureCube;
    }();
    Ct.TEXTURECUBE = "TEXTURECUBE";
    var Rt = function() {
        function LightQueue() {
            _classCallCheck(this, LightQueue), this._length = 0, this._elements = [];
        }
        return _createClass(LightQueue, [ {
            key: "add",
            value: function(e) {
                this._length === this._elements.length ? this._elements.push(e) : this._elements[this._length] = e, 
                this._length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = this._elements.indexOf(e);
                if (this._length--, t !== this._length) {
                    var n = this._elements[this._length];
                    this._elements[t] = n;
                }
            }
        }, {
            key: "shift",
            value: function() {
                return this._length--, this._elements.shift();
            }
        }, {
            key: "getBrightestLight",
            value: function() {
                for (var e, t = -1, n = this._elements, r = 0; r < this._length; r++) {
                    var i = n[r]._intensity;
                    t < i && (t = i, e = r);
                }
                return e;
            }
        }, {
            key: "normalLightOrdering",
            value: function(e) {
                this._elements;
                var t = this._elements[0];
                this._elements[0] = this._elements[e], this._elements[e] = t;
            }
        } ]), LightQueue;
    }(), Dt = function(e) {
        function AlternateLightQueue() {
            return _classCallCheck(this, AlternateLightQueue), _possibleConstructorReturn(this, _getPrototypeOf(AlternateLightQueue).apply(this, arguments));
        }
        return _inherits(AlternateLightQueue, Rt), _createClass(AlternateLightQueue, [ {
            key: "remove",
            value: function(e) {
                var t = this._elements.indexOf(e);
                this._elements.splice(t, 1), this._length--;
            }
        } ]), AlternateLightQueue;
    }(), Mt = function(e) {
        function PixelLineMaterial() {
            var e;
            return _classCallCheck(this, PixelLineMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineMaterial).call(this))).setShaderName("LineShader"), 
            e._shaderValues.setVector(PixelLineMaterial.COLOR, new i(1, 1, 1, 1)), e;
        }
        return _inherits(PixelLineMaterial, me), _createClass(PixelLineMaterial, [ {
            key: "clone",
            value: function() {
                var e = new PixelLineMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(PixelLineMaterial.COLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PixelLineMaterial.COLOR, e);
            }
        }, {
            key: "depthWrite",
            set: function(e) {
                this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, e);
            },
            get: function() {
                return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.CULL, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.CULL);
            }
        }, {
            key: "blend",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function(e) {
                this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, e);
            },
            get: function() {
                return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {}
        } ]), PixelLineMaterial;
    }();
    Mt.COLOR = ue.propertyNameToID("u_Color"), Mt.CULL = ue.propertyNameToID("s_Cull"), 
    Mt.BLEND = ue.propertyNameToID("s_Blend"), Mt.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), 
    Mt.BLEND_DST = ue.propertyNameToID("s_BlendDst"), Mt.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), 
    Mt.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var At = function() {
        function BoundBox(e, t) {
            _classCallCheck(this, BoundBox), this.min = e, this.max = t;
        }
        return _createClass(BoundBox, [ {
            key: "_rotateExtents",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.elements;
                n.x = Math.abs(o[0] * r) + Math.abs(o[4] * i) + Math.abs(o[8] * a), n.y = Math.abs(o[1] * r) + Math.abs(o[5] * i) + Math.abs(o[9] * a), 
                n.z = Math.abs(o[2] * r) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "getCorners",
            value: function(e) {
                e.length = 8;
                var t = this.min.x, n = this.min.y, r = this.min.z, i = this.max.x, a = this.max.y, s = this.max.z;
                e[0] = new o(t, a, s), e[1] = new o(i, a, s), e[2] = new o(i, n, s), e[3] = new o(t, n, s), 
                e[4] = new o(t, a, r), e[5] = new o(i, a, r), e[6] = new o(i, n, r), e[7] = new o(t, n, r);
            }
        }, {
            key: "getCenter",
            value: function(e) {
                o.add(this.min, this.max, e), o.scale(e, .5, e);
            }
        }, {
            key: "getExtent",
            value: function(e) {
                o.subtract(this.max, this.min, e), o.scale(e, .5, e);
            }
        }, {
            key: "setCenterAndExtent",
            value: function(e, t) {
                o.subtract(e, t, this.min), o.add(e, t, this.max);
            }
        }, {
            key: "tranform",
            value: function(e, t) {
                var n = BoundBox._tempVector30, r = BoundBox._tempVector31;
                this.getCenter(n), this.getExtent(r), o.transformCoordinate(n, e, n), this._rotateExtents(r, e, r), 
                t.setCenterAndExtent(n, r);
            }
        }, {
            key: "toDefault",
            value: function() {
                this.min.toDefault(), this.max.toDefault();
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.min.cloneTo(t.min), this.max.cloneTo(t.max);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoundBox(new o(), new o());
                return this.cloneTo(e), e;
            }
        } ], [ {
            key: "createfromPoints",
            value: function(e, t) {
                if (null == e) throw new Error("points");
                var n = t.min, r = t.max;
                n.x = Number.MAX_VALUE, n.y = Number.MAX_VALUE, n.z = Number.MAX_VALUE, r.x = -Number.MAX_VALUE, 
                r.y = -Number.MAX_VALUE, r.z = -Number.MAX_VALUE;
                for (var i = 0, a = e.length; i < a; ++i) o.min(n, e[i], n), o.max(r, e[i], r);
            }
        }, {
            key: "merge",
            value: function(e, t, n) {
                o.min(e.min, t.min, n.min), o.max(e.max, t.max, n.max);
            }
        } ]), BoundBox;
    }();
    At._tempVector30 = new o(), At._tempVector31 = new o();
    var xt = function() {
        function Bounds(e, t) {
            _classCallCheck(this, Bounds), this._updateFlag = 0, this._center = new o(), this._extent = new o(), 
            this._boundBox = new At(new o(), new o()), e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max), 
            this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0);
        }
        return _createClass(Bounds, [ {
            key: "setMin",
            value: function(e) {
                var t = this._boundBox.min;
                e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0), 
                this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
            }
        }, {
            key: "getMin",
            value: function() {
                var e = this._boundBox.min;
                return this._getUpdateFlag(Bounds._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e), 
                this._setUpdateFlag(Bounds._UPDATE_MIN, !1)), e;
            }
        }, {
            key: "setMax",
            value: function(e) {
                var t = this._boundBox.max;
                e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0), 
                this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
            }
        }, {
            key: "getMax",
            value: function() {
                var e = this._boundBox.max;
                return this._getUpdateFlag(Bounds._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e), 
                this._setUpdateFlag(Bounds._UPDATE_MAX, !1)), e;
            }
        }, {
            key: "setCenter",
            value: function(e) {
                e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0), 
                this._setUpdateFlag(Bounds._UPDATE_CENTER, !1);
            }
        }, {
            key: "getCenter",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center), 
                this._setUpdateFlag(Bounds._UPDATE_CENTER, !1)), this._center;
            }
        }, {
            key: "setExtent",
            value: function(e) {
                e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0), 
                this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1);
            }
        }, {
            key: "getExtent",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent), 
                this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1)), this._extent;
            }
        }, {
            key: "_getUpdateFlag",
            value: function(e) {
                return 0 != (this._updateFlag & e);
            }
        }, {
            key: "_setUpdateFlag",
            value: function(e, t) {
                t ? this._updateFlag |= e : this._updateFlag &= ~e;
            }
        }, {
            key: "_getCenter",
            value: function(e, t, n) {
                o.add(e, t, n), o.scale(n, .5, n);
            }
        }, {
            key: "_getExtent",
            value: function(e, t, n) {
                o.subtract(t, e, n), o.scale(n, .5, n);
            }
        }, {
            key: "_getMin",
            value: function(e, t, n) {
                o.subtract(e, t, n);
            }
        }, {
            key: "_getMax",
            value: function(e, t, n) {
                o.add(e, t, n);
            }
        }, {
            key: "_rotateExtents",
            value: function(e, t, n) {
                var r = e.x, i = e.y, a = e.z, o = t.elements;
                n.x = Math.abs(o[0] * r) + Math.abs(o[4] * i) + Math.abs(o[8] * a), n.y = Math.abs(o[1] * r) + Math.abs(o[5] * i) + Math.abs(o[9] * a), 
                n.z = Math.abs(o[2] * r) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "_tranform",
            value: function(e, t) {
                var n = t._center, r = t._extent;
                o.transformCoordinate(this.getCenter(), e, n), this._rotateExtents(this.getExtent(), e, r), 
                t._boundBox.setCenterAndExtent(n, r), t._updateFlag = 0;
            }
        }, {
            key: "_getBoundBox",
            value: function() {
                if (this._updateFlag & Bounds._UPDATE_MIN) {
                    var e = this._boundBox.min;
                    this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
                }
                if (this._updateFlag & Bounds._UPDATE_MAX) {
                    var t = this._boundBox.max;
                    this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
                }
                return this._boundBox;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max), 
                this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Bounds(new o(), new o());
                return this.cloneTo(e), e;
            }
        } ]), Bounds;
    }();
    xt._UPDATE_MIN = 1, xt._UPDATE_MAX = 2, xt._UPDATE_CENTER = 4, xt._UPDATE_EXTENT = 8;
    var Lt = function() {
        function GeometryElement() {
            _classCallCheck(this, GeometryElement), this._destroyed = !1;
        }
        return _createClass(GeometryElement, [ {
            key: "_getType",
            value: function() {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (this._destroyed = !0);
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        } ]), GeometryElement;
    }();
    Lt._typeCounter = 0;
    var It = function() {
        function PixelLineVertex() {
            _classCallCheck(this, PixelLineVertex);
        }
        return _createClass(PixelLineVertex, [ {
            key: "vertexDeclaration",
            get: function() {
                return PixelLineVertex._vertexDeclaration;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                PixelLineVertex._vertexDeclaration = new je(28, [ new Ze(0, Ye.Vector3, Qe.MESH_POSITION0), new Ze(12, Ye.Vector4, Qe.MESH_COLOR0) ]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return PixelLineVertex._vertexDeclaration;
            }
        } ]), PixelLineVertex;
    }(), Ot = function(e) {
        function PixelLineFilter(e, n) {
            var r;
            _classCallCheck(this, PixelLineFilter), (r = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineFilter).call(this)))._floatCountPerVertices = 7, 
            r._minUpdate = Number.MAX_VALUE, r._maxUpdate = Number.MIN_VALUE, r._bufferState = new We(), 
            r._floatBound = new Float32Array(6), r._calculateBound = !1, r._maxLineCount = 0, 
            r._lineCount = 0;
            var i = 2 * n;
            r._owner = e, r._maxLineCount = n, r._vertices = new Float32Array(i * r._floatCountPerVertices), 
            r._vertexBuffer = new qe(It.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !1), 
            r._vertexBuffer.vertexDeclaration = It.vertexDeclaration, r._bufferState.bind(), 
            r._bufferState.applyVertexBuffer(r._vertexBuffer), r._bufferState.unBind();
            var a = PixelLineFilter._tempVector0, o = PixelLineFilter._tempVector1;
            return a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), 
            r._bounds = new xt(a, o), r;
        }
        return _inherits(PixelLineFilter, Lt), _createClass(PixelLineFilter, [ {
            key: "_getType",
            value: function() {
                return PixelLineFilter._type;
            }
        }, {
            key: "_resizeLineData",
            value: function(e) {
                var n = 2 * e, r = this._vertices;
                this._vertexBuffer.destroy(), this._maxLineCount = e;
                var i = n * this._floatCountPerVertices;
                this._vertices = new Float32Array(i), this._vertexBuffer = new qe(It.vertexDeclaration.vertexStride * n, t.LayaGL.instance.STATIC_DRAW, !1), 
                this._vertexBuffer.vertexDeclaration = It.vertexDeclaration, i < r.length ? (this._vertices.set(new Float32Array(r.buffer, 0, i)), 
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i)) : (this._vertices.set(r), 
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * r.length)), this._bufferState.bind(), 
                this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
            }
        }, {
            key: "_updateLineVertices",
            value: function(e, t, n, r, i) {
                t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z), 
                r && (this._vertices[e + 3] = r.r, this._vertices[e + 4] = r.g, this._vertices[e + 5] = r.b, 
                this._vertices[e + 6] = r.a), n && (this._vertices[e + 7] = n.x, this._vertices[e + 8] = n.y, 
                this._vertices[e + 9] = n.z), i && (this._vertices[e + 10] = i.r, this._vertices[e + 11] = i.g, 
                this._vertices[e + 12] = i.b, this._vertices[e + 13] = i.a), this._minUpdate = Math.min(this._minUpdate, e), 
                this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
                var a = this._bounds, s = this._floatBound, l = a.getMin(), u = a.getMax();
                o.min(l, t, l), o.min(l, n, l), o.max(u, t, u), o.max(u, n, u), a.setMin(l), a.setMax(u), 
                s[0] = l.x, s[1] = l.y, s[2] = l.z, s[3] = u.x, s[4] = u.y, s[5] = u.z;
            }
        }, {
            key: "_reCalculateBound",
            value: function() {
                if (this._calculateBound) {
                    var e = this._vertices, t = PixelLineFilter._tempVector0, n = PixelLineFilter._tempVector1;
                    t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    for (var r = 0; r < 2 * this._lineCount; ++r) {
                        var i = this._floatCountPerVertices * r, a = e[i + 0], o = e[i + 1], s = e[i + 2];
                        t.x = Math.min(a, t.x), t.y = Math.min(o, t.y), t.z = Math.min(s, t.z), n.x = Math.max(a, n.x), 
                        n.y = Math.max(o, n.y), n.z = Math.max(s, n.z);
                    }
                    this._bounds.setMin(t), this._bounds.setMax(n);
                    var l = this._floatBound;
                    l[0] = t.x, l[1] = t.y, l[2] = t.z, l[3] = n.x, l[4] = n.y, l[5] = n.z, this._calculateBound = !1;
                }
            }
        }, {
            key: "_removeLineData",
            value: function(e) {
                var t = 2 * this._floatCountPerVertices, n = e + 1, r = e * t, i = this._vertices, a = new Float32Array(i.buffer, n * t * 4, (this._lineCount - n) * t);
                i.set(a, r), this._minUpdate = Math.min(this._minUpdate, r), this._maxUpdate = Math.max(this._maxUpdate, r + a.length), 
                this._lineCount--;
                var o = this._floatBound, s = i[r], l = i[r + 1], u = i[r + 2], c = i[r + 7], h = i[r + 8], _ = i[r + 9], d = o[0], f = o[1], m = o[2], T = o[3], p = o[4], g = o[5];
                s !== d && s !== T && l !== f && l !== p && u !== m && u !== g && c !== d && c !== T && h !== f && h !== p && _ !== m && _ !== g || (this._calculateBound = !0);
            }
        }, {
            key: "_updateLineData",
            value: function(e, t, n, r, i) {
                var a = 2 * this._floatCountPerVertices;
                this._updateLineVertices(e * a, t, n, r, i);
            }
        }, {
            key: "_updateLineDatas",
            value: function(e, t) {
                for (var n = 2 * this._floatCountPerVertices, r = t.length, i = 0; i < r; i++) {
                    var a = t[i];
                    this._updateLineVertices((e + i) * n, a.startPosition, a.endPosition, a.startColor, a.endColor);
                }
            }
        }, {
            key: "_getLineData",
            value: function(e, t) {
                var n = t.startPosition, r = t.startColor, i = t.endPosition, a = t.endColor, o = this._vertices, s = e * this._floatCountPerVertices * 2;
                n.x = o[s + 0], n.y = o[s + 1], n.z = o[s + 2], r.r = o[s + 3], r.g = o[s + 4], 
                r.b = o[s + 5], r.a = o[s + 6], i.x = o[s + 7], i.y = o[s + 8], i.z = o[s + 9], 
                a.r = o[s + 10], a.g = o[s + 11], a.b = o[s + 12], a.a = o[s + 13];
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)), 
                this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                    this._bufferState.bind();
                    var n = t.LayaGL.instance;
                    n.drawArrays(n.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++;
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (_get(_getPrototypeOf(PixelLineFilter.prototype), "destroy", this).call(this), 
                this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferState = null, 
                this._vertexBuffer = null, this._vertices = null);
            }
        } ]), PixelLineFilter;
    }();
    Ot._tempVector0 = new o(), Ot._tempVector1 = new o(), Ot._type = Lt._typeCounter++;
    var Pt = function(e) {
        function RenderableSprite3D(e) {
            return _classCallCheck(this, RenderableSprite3D), _possibleConstructorReturn(this, _getPrototypeOf(RenderableSprite3D).call(this, e));
        }
        return _inherits(RenderableSprite3D, et), _createClass(RenderableSprite3D, [ {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onInActive", this).call(this), 
                this._scene._removeRenderObject(this._render);
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActive", this).call(this), 
                this._scene._addRenderObject(this._render);
            }
        }, {
            key: "_onActiveInScene",
            value: function() {
                if (_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActiveInScene", this).call(this), 
                l.Laya3D._editerEnvironment) {
                    var e = this._scene, t = new i();
                    e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, t);
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function() {}
        }, {
            key: "_setBelongScene",
            value: function(e) {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setBelongScene", this).call(this, e), 
                this._render._setBelongScene(e);
            }
        }, {
            key: "_setUnBelongScene",
            value: function() {
                this._render._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP), 
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setUnBelongScene", this).call(this);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                if (this._hierarchyAnimator) {
                    var t = this._hierarchyAnimator._renderableSprites;
                    t.splice(t.indexOf(this), 1);
                }
                e && e._renderableSprites.push(this), _get(_getPrototypeOf(RenderableSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "destroy", this).call(this, e), 
                this._render._destroy(), this._render = null;
            }
        }, {
            key: "_create",
            value: function() {
                return new RenderableSprite3D(this.name);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = ue.getDefineByName("RECEIVESHADOW"), 
                RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = ue.getDefineByName("LIGHTMAP"), RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = ue.getDefineByName("LIGHTMAP_DIRECTIONAL");
            }
        } ]), RenderableSprite3D;
    }();
    Pt.LIGHTMAPSCALEOFFSET = ue.propertyNameToID("u_LightmapScaleOffset"), Pt.LIGHTMAP = ue.propertyNameToID("u_LightMap"), 
    Pt.LIGHTMAP_DIRECTION = ue.propertyNameToID("u_LightMapDirection"), Pt.PICKCOLOR = ue.propertyNameToID("u_PickColor");
    var Nt = function BatchMark() {
        _classCallCheck(this, BatchMark), this.updateMark = -1, this.indexInList = -1, this.batched = !1;
    }, bt = function(e) {
        function SubMeshInstanceBatch() {
            var e;
            _classCallCheck(this, SubMeshInstanceBatch), (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshInstanceBatch).call(this))).maxInstanceCount = 1024, 
            e.instanceWorldMatrixData = new Float32Array(16 * e.maxInstanceCount), e.instanceMVPMatrixData = new Float32Array(16 * e.maxInstanceCount);
            var n = t.LayaGL.instance;
            return e.instanceWorldMatrixBuffer = new qe(4 * e.instanceWorldMatrixData.length, n.DYNAMIC_DRAW), 
            e.instanceMVPMatrixBuffer = new qe(4 * e.instanceMVPMatrixData.length, n.DYNAMIC_DRAW), 
            e.instanceWorldMatrixBuffer.vertexDeclaration = Qe.instanceWorldMatrixDeclaration, 
            e.instanceMVPMatrixBuffer.vertexDeclaration = Qe.instanceMVPMatrixDeclaration, e;
        }
        return _inherits(SubMeshInstanceBatch, Lt), _createClass(SubMeshInstanceBatch, [ {
            key: "_render",
            value: function(e) {
                var n = t.LayaGL.instance, r = e.renderElement, i = r.instanceSubMesh, a = r.instanceBatchElementList.length, o = i._indexCount;
                i._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance.drawElementsInstanced(n.TRIANGLES, o, n.UNSIGNED_SHORT, 2 * i._indexStart, a), 
                t.Stat.renderBatches++, t.Stat.savedRenderBatches += a - 1, t.Stat.trianglesFaces += o * a / 3;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
            }
        } ]), SubMeshInstanceBatch;
    }(), kt = function() {
        function RenderElement() {
            _classCallCheck(this, RenderElement), this.renderSubShader = null, this.renderType = RenderElement.RENDERTYPE_NORMAL;
        }
        return _createClass(RenderElement, [ {
            key: "getInvertFront",
            value: function() {
                return this._transform._isFrontFaceInvert;
            }
        }, {
            key: "setTransform",
            value: function(e) {
                this._transform = e;
            }
        }, {
            key: "setGeometry",
            value: function(e) {
                this._geometry = e;
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function(e, t) {
                t.elements.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function(e, t) {
                t.elements.add(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
            }
        }, {
            key: "_update",
            value: function(e, t, n, r) {
                if (this.material) {
                    var i = this.material._shader.getSubShaderAt(0);
                    if (this.renderSubShader = null, n) if (r) {
                        var a = i.getFlag(r);
                        if (!a) return;
                        for (var o = n._subShaders, s = 0, l = o.length; s < l; s++) {
                            var u = o[s];
                            if (a === u.getFlag(r)) {
                                this.renderSubShader = u;
                                break;
                            }
                        }
                        if (!this.renderSubShader) return;
                    } else this.renderSubShader = n.getSubShaderAt(0); else this.renderSubShader = i;
                    var c = e._getRenderQueue(this.material.renderQueue);
                    c.isTransparent ? this.addToTransparentRenderQueue(t, c) : this.addToOpaqueRenderQueue(t, c);
                }
            }
        }, {
            key: "_render",
            value: function(e) {
                var t, n, r, i = e.invertY, a = pt._updateMark, o = e.scene, s = e.cameraShaderValue, l = this._transform, u = this._geometry;
                e.renderElement = this, a !== this.render._updateMark || this.renderType !== this.render._updateRenderType ? (this.render._renderUpdate(e, l), 
                this.render._renderUpdateWithCamera(e, l), this.render._updateMark = a, this.render._updateRenderType = this.renderType) : this.renderType == RenderElement.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l), 
                this.render._renderUpdateWithCamera(e, l));
                var c = e.pipelineMode;
                if (u._prepareRender(e)) for (var h = this.renderSubShader._passes, _ = 0, d = h.length; _ < d; _++) {
                    var f = h[_];
                    if (f._pipelineMode === c) {
                        var m = RenderElement._compileDefine;
                        o._shaderValues._defineDatas.cloneTo(m), m.addDefineDatas(this.render._shaderValues._defineDatas), 
                        m.addDefineDatas(this.material._shaderValues._defineDatas);
                        var T = e.shader = f.withCompile(m), p = T.bind(), g = a !== T._uploadMark, E = T._uploadScene !== o || g;
                        (E || p) && (T.uploadUniforms(T._sceneUniformParamsMap, o._shaderValues, E), T._uploadScene = o);
                        var y = T._uploadRender !== this.render || T._uploadRenderType !== this.renderType || g;
                        (y || p) && (T.uploadUniforms(T._spriteUniformParamsMap, this.render._shaderValues, y), 
                        T._uploadRender = this.render, T._uploadRenderType = this.renderType);
                        var v = T._uploadCameraShaderValue !== s || g;
                        (v || p) && (T.uploadUniforms(T._cameraUniformParamsMap, s, v), T._uploadCameraShaderValue = s);
                        var S = T._uploadMaterial !== this.material || g;
                        (S || p) && (T.uploadUniforms(T._materialUniformParamsMap, this.material._shaderValues, S), 
                        T._uploadMaterial = this.material);
                        var C = this.material._shaderValues;
                        t !== this.material || n !== T ? (T.uploadRenderStateBlendDepth(C), T.uploadRenderStateFrontFace(C, i, this.getInvertFront()), 
                        t = this.material, n = T, r = this.render) : r !== this.render && (T.uploadRenderStateFrontFace(C, i, this.getInvertFront()), 
                        r = this.render), u._render(e), T._uploadMark = a;
                    }
                }
                this.renderType !== RenderElement.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e);
            }
        }, {
            key: "destroy",
            value: function() {
                this._transform = null, this._geometry = null, this.material = null, this.render = null;
            }
        } ]), RenderElement;
    }();
    kt.RENDERTYPE_NORMAL = 0, kt.RENDERTYPE_STATICBATCH = 1, kt.RENDERTYPE_INSTANCEBATCH = 2, 
    kt.RENDERTYPE_VERTEXBATCH = 3, kt._compileDefine = new ae();
    var wt = function(e) {
        function SubMeshRenderElement() {
            var e;
            return _classCallCheck(this, SubMeshRenderElement), (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshRenderElement).call(this)))._dynamicWorldPositionNormalNeedUpdate = !0, 
            e;
        }
        return _inherits(SubMeshRenderElement, kt), _createClass(SubMeshRenderElement, [ {
            key: "_onWorldMatrixChanged",
            value: function() {
                this._dynamicWorldPositionNormalNeedUpdate = !0;
            }
        }, {
            key: "_computeWorldPositionsAndNormals",
            value: function(e, t, n, r) {
                if (this._dynamicWorldPositionNormalNeedUpdate) {
                    for (var i = this._geometry, a = i._vertexBuffer, o = a.vertexDeclaration.vertexStride / 4, s = a.getFloat32Data(), l = this._transform.worldMatrix, u = this._transform.rotation, c = i._indices, h = 0; h < r; h++) {
                        var _ = (n ? c[h] : h) * o, d = 3 * h;
                        O.transformVector3ArrayToVector3ArrayCoordinate(s, _ + e, l, this._dynamicWorldPositions, d), 
                        -1 !== t && O.transformVector3ArrayByQuat(s, _ + t, u, this._dynamicWorldNormals, d);
                    }
                    this._dynamicWorldPositionNormalNeedUpdate = !1;
                }
            }
        }, {
            key: "setTransform",
            value: function(e) {
                this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), 
                e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0, 
                this._transform = e);
            }
        }, {
            key: "setGeometry",
            value: function(e) {
                if (this._geometry !== e) {
                    var t = e, n = t._mesh;
                    if (n) {
                        var r = n._subMeshes.length > 1, i = r ? t._indexCount : n._vertexCount;
                        if (i <= l.SubMeshDynamicBatch.maxAllowVertexCount) {
                            var a = 3 * i;
                            this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(a), 
                            this._dynamicWorldNormals = new Float32Array(a), this._dynamicVertexCount = i, this._dynamicMultiSubMesh = r;
                        } else this._dynamicVertexBatch = !1;
                    }
                    this._geometry = e;
                }
            }
        }, {
            key: "addToOpaqueRenderQueue",
            value: function(e, n) {
                var r = this.staticBatch, i = n.elements, a = i.elements;
                if (r) {
                    var o = l.MeshRenderStaticBatchManager.instance, s = o.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, r._batchID);
                    if (o._updateCountMark === s.updateMark) {
                        var u = s.indexInList;
                        if (s.batched) a[u].staticBatchElementList.add(this); else {
                            var c = a[u], h = c.render, _ = o._getBatchRenderElementFromPool();
                            _.renderType = kt.RENDERTYPE_STATICBATCH, _.setGeometry(r), _.material = c.material;
                            var d = r.batchOwner, f = d ? d._transform : null;
                            _.setTransform(f), _.render = h, _.renderSubShader = c.renderSubShader;
                            var m = _.staticBatchElementList;
                            m.length = 0, m.add(c), m.add(this), a[u] = _, s.batched = !0;
                        }
                    } else s.updateMark = o._updateCountMark, s.indexInList = i.length, s.batched = !1, 
                    i.add(this);
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var T = this._geometry, p = l.MeshRenderDynamicBatchManager.instance, g = p.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, T._id, this._transform._isFrontFaceInvert);
                    if (p._updateCountMark === g.updateMark) {
                        var E = g.indexInList;
                        if (g.batched) {
                            var y = a[E].instanceBatchElementList;
                            y.length === bt.instance.maxInstanceCount ? (g.updateMark = p._updateCountMark, 
                            g.indexInList = i.length, g.batched = !1, i.add(this)) : y.add(this);
                        } else {
                            var v = a[E], S = v.render, C = p._getBatchRenderElementFromPool();
                            C.renderType = kt.RENDERTYPE_INSTANCEBATCH, C.setGeometry(bt.instance), C.material = v.material, 
                            C.setTransform(null), C.render = S, C.instanceSubMesh = T, C.renderSubShader = v.renderSubShader;
                            var R = C.instanceBatchElementList;
                            R.length = 0, R.add(v), R.add(this), a[E] = C, g.batched = !0;
                        }
                    } else g.updateMark = p._updateCountMark, g.indexInList = i.length, g.batched = !1, 
                    i.add(this);
                } else if (this._dynamicVertexBatch) {
                    var D = this._geometry._vertexBuffer.vertexDeclaration, M = l.MeshRenderDynamicBatchManager.instance, A = M.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, D.id);
                    if (M._updateCountMark === A.updateMark) {
                        var x = A.indexInList;
                        if (A.batched) a[x].vertexBatchElementList.add(this); else {
                            var L = a[x], I = L.render, O = M._getBatchRenderElementFromPool();
                            O.renderType = kt.RENDERTYPE_VERTEXBATCH, O.setGeometry(l.SubMeshDynamicBatch.instance), 
                            O.material = L.material, O.setTransform(null), O.render = I, O.vertexBatchVertexDeclaration = D, 
                            O.renderSubShader = L.renderSubShader;
                            var P = O.vertexBatchElementList;
                            P.length = 0, P.add(L), P.add(this), a[x] = O, A.batched = !0;
                        }
                    } else A.updateMark = M._updateCountMark, A.indexInList = i.length, A.batched = !1, 
                    i.add(this);
                } else i.add(this);
            }
        }, {
            key: "addToTransparentRenderQueue",
            value: function(e, n) {
                var r = this.staticBatch, i = n.elements, a = i.elements;
                if (r) {
                    var o = l.MeshRenderStaticBatchManager.instance, s = n.lastTransparentRenderElement;
                    if (s) {
                        var u = s.render;
                        if (s._geometry._getType() !== this._geometry._getType() || s.staticBatch !== r || s.material !== this.material || u.receiveShadow !== this.render.receiveShadow || u.lightmapIndex !== this.render.lightmapIndex) i.add(this), 
                        n.lastTransparentBatched = !1; else {
                            if (n.lastTransparentBatched) a[i.length - 1].staticBatchElementList.add(this); else {
                                var c = o._getBatchRenderElementFromPool();
                                c.renderType = kt.RENDERTYPE_STATICBATCH, c.setGeometry(r), c.material = s.material;
                                var h = r.batchOwner, _ = h ? h._transform : null;
                                c.setTransform(_), c.render = this.render, c.renderSubShader = s.renderSubShader;
                                var d = c.staticBatchElementList;
                                d.length = 0, d.add(s), d.add(this), a[i.length - 1] = c;
                            }
                            n.lastTransparentBatched = !0;
                        }
                    } else i.add(this), n.lastTransparentBatched = !1;
                } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                    var f = this._geometry, m = l.MeshRenderDynamicBatchManager.instance, T = n.lastTransparentRenderElement;
                    if (T) {
                        var p = T.render;
                        if (T._geometry._getType() !== this._geometry._getType() || T._geometry !== f || T.material !== this.material || p.receiveShadow !== this.render.receiveShadow) i.add(this), 
                        n.lastTransparentBatched = !1; else if (n.lastTransparentBatched) {
                            var g = a[i.length - 1].instanceBatchElementList;
                            g.length === bt.instance.maxInstanceCount ? (i.add(this), n.lastTransparentBatched = !1) : (g.add(this), 
                            n.lastTransparentBatched = !0);
                        } else {
                            var E = m._getBatchRenderElementFromPool();
                            E.renderType = kt.RENDERTYPE_INSTANCEBATCH, E.setGeometry(bt.instance), E.material = T.material, 
                            E.setTransform(null), E.render = this.render, E.instanceSubMesh = f, E.renderSubShader = T.renderSubShader;
                            var y = E.instanceBatchElementList;
                            y.length = 0, y.add(T), y.add(this), a[i.length - 1] = E, n.lastTransparentBatched = !0;
                        }
                    } else i.add(this), n.lastTransparentBatched = !1;
                } else if (this._dynamicVertexBatch) {
                    var v = this._geometry._vertexBuffer.vertexDeclaration, S = l.MeshRenderDynamicBatchManager.instance, C = n.lastTransparentRenderElement;
                    if (C) {
                        var R = C.render;
                        if (C._dynamicVertexBatch && C._geometry._getType() === this._geometry._getType() && C._geometry._vertexBuffer._vertexDeclaration === v && C.material === this.material && R.receiveShadow === this.render.receiveShadow && R.lightmapIndex === this.render.lightmapIndex) {
                            if (n.lastTransparentBatched) a[i.length - 1].vertexBatchElementList.add(this); else {
                                var D = S._getBatchRenderElementFromPool();
                                D.renderType = kt.RENDERTYPE_VERTEXBATCH, D.setGeometry(l.SubMeshDynamicBatch.instance), 
                                D.material = C.material, D.setTransform(null), D.render = this.render, D.vertexBatchVertexDeclaration = v, 
                                D.renderSubShader = C.renderSubShader;
                                var M = D.vertexBatchElementList;
                                M.length = 0, M.add(C), M.add(this), a[i.length - 1] = D;
                            }
                            n.lastTransparentBatched = !0;
                        } else i.add(this), n.lastTransparentBatched = !1;
                    } else i.add(this), n.lastTransparentBatched = !1;
                } else i.add(this);
                n.lastTransparentRenderElement = this;
            }
        }, {
            key: "getInvertFront",
            value: function() {
                switch (this.renderType) {
                  case kt.RENDERTYPE_NORMAL:
                    return this._transform._isFrontFaceInvert;

                  case kt.RENDERTYPE_STATICBATCH:
                  case kt.RENDERTYPE_VERTEXBATCH:
                    return !1;

                  case kt.RENDERTYPE_INSTANCEBATCH:
                    return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;

                  default:
                    throw "SubMeshRenderElement: unknown renderType";
                }
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(SubMeshRenderElement.prototype), "destroy", this).call(this), 
                this._dynamicWorldPositions = null, this._dynamicWorldNormals = null, this.staticBatch = null, 
                this.staticBatchElementList = null, this.vertexBatchElementList = null, this.vertexBatchVertexDeclaration = null;
            }
        } ]), SubMeshRenderElement;
    }(), Bt = function() {
        function StaticBatchManager() {
            _classCallCheck(this, StaticBatchManager), this._initBatchSprites = [], this._staticBatches = {}, 
            this._batchRenderElementPoolIndex = 0, this._batchRenderElementPool = [];
        }
        return _createClass(StaticBatchManager, [ {
            key: "_partition",
            value: function(e, t, n) {
                for (var r = e[Math.floor((n + t) / 2)]; t <= n; ) {
                    for (;this._compare(e[t], r) < 0; ) t++;
                    for (;this._compare(e[n], r) > 0; ) n--;
                    if (t < n) {
                        var i = e[t];
                        e[t] = e[n], e[n] = i, t++, n--;
                    } else if (t === n) {
                        t++;
                        break;
                    }
                }
                return t;
            }
        }, {
            key: "_quickSort",
            value: function(e, t, n) {
                if (e.length > 1) {
                    var r = this._partition(e, t, n), i = r - 1;
                    t < i && this._quickSort(e, t, i), r < n && this._quickSort(e, r, n);
                }
            }
        }, {
            key: "_compare",
            value: function(e, t) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_addBatchSprite",
            value: function(e) {
                this._initBatchSprites.push(e);
            }
        }, {
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                throw "StaticBatchManager: must override it.";
            }
        }, {
            key: "dispose",
            value: function() {
                this._staticBatches = null;
            }
        } ], [ {
            key: "_addToStaticBatchQueue",
            value: function(e, t) {
                e instanceof Pt && t.push(e);
                for (var n = 0, r = e.numChildren; n < r; n++) StaticBatchManager._addToStaticBatchQueue(e._children[n], t);
            }
        }, {
            key: "_registerManager",
            value: function(e) {
                StaticBatchManager._managers.push(e);
            }
        }, {
            key: "combine",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t || (t = [], e && StaticBatchManager._addToStaticBatchQueue(e, t));
                var n = t.length;
                if (n > 0) {
                    for (var r = 0; r < n; r++) {
                        var i = t[r];
                        i.destroyed || (i._render._isPartOfStaticBatch ? console.warn("StaticBatchManager: Sprite " + i.name + " has a part of Static Batch,it will be ignore.") : i._addToInitStaticBatchManager());
                    }
                    for (var a = 0, o = StaticBatchManager._managers.length; a < o; a++) {
                        StaticBatchManager._managers[a]._initStaticBatchs(e);
                    }
                }
            }
        } ]), StaticBatchManager;
    }();
    Bt._managers = [];
    var Vt = function(n) {
        function SubMeshStaticBatch(e, t) {
            var n;
            return _classCallCheck(this, SubMeshStaticBatch), (n = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshStaticBatch).call(this)))._bufferState = new We(), 
            n._batchID = SubMeshStaticBatch._batchIDCounter++, n._batchElements = [], n._currentBatchVertexCount = 0, 
            n._currentBatchIndexCount = 0, n._vertexDeclaration = t, n.batchOwner = e, n;
        }
        return _inherits(SubMeshStaticBatch, Lt), _createClass(SubMeshStaticBatch, [ {
            key: "_getStaticBatchBakedVertexs",
            value: function(e, t, n, r, i, a) {
                var o, s = a._vertexBuffer, l = s.vertexDeclaration, u = l.getVertexElementByUsage(Qe.MESH_POSITION0)._offset / 4, h = l.getVertexElementByUsage(Qe.MESH_NORMAL0), _ = h ? h._offset / 4 : -1, d = l.getVertexElementByUsage(Qe.MESH_COLOR0), f = d ? d._offset / 4 : -1, m = l.getVertexElementByUsage(Qe.MESH_TEXTURECOORDINATE0), T = m ? m._offset / 4 : -1, p = l.getVertexElementByUsage(Qe.MESH_TEXTURECOORDINATE1), g = p ? p._offset / 4 : -1, E = l.getVertexElementByUsage(Qe.MESH_TANGENT0), y = E ? E._offset / 4 : -1, v = l.vertexStride / 4, S = s.getFloat32Data();
                n ? (n.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40), o = SubMeshStaticBatch._tempMatrix4x41, 
                c.multiply(SubMeshStaticBatch._tempMatrix4x40, r.worldMatrix, o)) : o = r.worldMatrix;
                var C = SubMeshStaticBatch._tempMatrix4x42;
                o.invert(C), C.transpose();
                var R = SubMeshStaticBatch._tempQuaternion0;
                o.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, R, SubMeshStaticBatch._tempVector31);
                for (var D = i.lightmapScaleOffset, M = a.vertexCount, A = 0; A < M; A++) {
                    var x, L, I = A * v, P = 18 * (A + t);
                    O.transformVector3ArrayToVector3ArrayCoordinate(S, I + u, o, e, P + 0), -1 !== _ && O.transformVector3ArrayToVector3ArrayNormal(S, I + _, C, e, P + 3);
                    var N = P + 6;
                    if (-1 !== f) {
                        var b = I + f;
                        for (x = 0, L = 4; x < L; x++) e[N + x] = S[b + x];
                    } else for (x = 0, L = 4; x < L; x++) e[N + x] = 1;
                    if (-1 !== T) {
                        var k = I + T;
                        e[P + 10] = S[k], e[P + 11] = S[k + 1];
                    }
                    if (D && (-1 !== g ? O.transformLightingMapTexcoordArray(S, I + g, D, e, P + 12) : O.transformLightingMapTexcoordArray(S, I + T, D, e, P + 12)), 
                    -1 !== y) {
                        var w = I + y;
                        e[P + 14] = S[w], e[P + 15] = S[w + 1], e[P + 16] = S[w + 2], e[P + 17] = S[w + 3];
                    }
                }
                return M;
            }
        }, {
            key: "addTest",
            value: function(e) {
                var t = e.meshFilter.sharedMesh.vertexCount;
                return !(this._currentBatchVertexCount + t > SubMeshStaticBatch.maxBatchVertexCount);
            }
        }, {
            key: "add",
            value: function(e) {
                var t = e.meshFilter.sharedMesh, n = t.vertexCount;
                this._batchElements.push(e);
                var r = e._render;
                r._isPartOfStaticBatch = !0, r._staticBatch = this;
                for (var i = r._renderElements, a = 0, o = i.length; a < o; a++) i[a].staticBatch = this;
                this._currentBatchIndexCount += t._indexBuffer.indexCount, this._currentBatchVertexCount += n;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e.meshFilter.sharedMesh, n = this._batchElements.indexOf(e);
                if (-1 !== n) {
                    this._batchElements.splice(n, 1);
                    for (var r = e._render._renderElements, i = 0, a = r.length; i < a; i++) r[i].staticBatch = null;
                    this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount, 
                    this._currentBatchVertexCount = this._currentBatchVertexCount - t.vertexCount, e._render._isPartOfStaticBatch = !1;
                }
            }
        }, {
            key: "finishInit",
            value: function() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(), 
                t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
                var n = t.LayaGL.instance, r = 0, i = 0, a = this.batchOwner, o = this._vertexDeclaration.vertexStride / 4, s = new Float32Array(o * this._currentBatchVertexCount), l = new Uint16Array(this._currentBatchIndexCount);
                this._vertexBuffer = new qe(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, n.STATIC_DRAW), 
                this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new Xe(e.IndexFormat.UInt16, this._currentBatchIndexCount, n.STATIC_DRAW);
                for (var u = 0, c = this._batchElements.length; u < c; u++) {
                    for (var h, _ = this._batchElements[u], d = _.meshFilter.sharedMesh, f = this._getStaticBatchBakedVertexs(s, r, a ? a._transform : null, _._transform, _._render, d), m = d._indexBuffer.getData(), T = r, p = i + m.length, g = _._render._renderElements, E = 0, y = d.subMeshCount; E < y; E++) {
                        var v = d._subMeshes[E], S = i + v._indexStart, C = g[E];
                        C.staticBatchIndexStart = S, C.staticBatchIndexEnd = S + v._indexCount;
                    }
                    if (l.set(m, i), a ? _._transform._isFrontFaceInvert !== a.transform._isFrontFaceInvert : _._transform._isFrontFaceInvert) for (h = i; h < p; h += 3) {
                        l[h] = T + l[h];
                        var R = l[h + 1], D = l[h + 2];
                        l[h + 1] = T + D, l[h + 2] = T + R;
                    } else for (h = i; h < p; h += 3) l[h] = T + l[h], l[h + 1] = T + l[h + 1], l[h + 2] = T + l[h + 2];
                    i += m.length, r += f;
                }
                this._vertexBuffer.setData(s.buffer), this._indexBuffer.setData(l);
                var M = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(M), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
                this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                for (var n = t.LayaGL.instance, r = e.renderElement.staticBatchElementList, i = r.elements, a = 0, o = 0, s = r.length, l = 1; l < s; l++) {
                    if (i[l - 1].staticBatchIndexEnd !== i[l].staticBatchIndexStart) {
                        var u = i[a].staticBatchIndexStart, c = i[o].staticBatchIndexEnd - u;
                        n.drawElements(n.TRIANGLES, c, n.UNSIGNED_SHORT, 2 * u), a = ++o, t.Stat.trianglesFaces += c / 3;
                    } else o++;
                }
                u = i[a].staticBatchIndexStart, c = i[o].staticBatchIndexEnd - u, n.drawElements(n.TRIANGLES, c, n.UNSIGNED_SHORT, 2 * u), 
                t.Stat.renderBatches++, t.Stat.savedRenderBatches += s - 1, t.Stat.trianglesFaces += c / 3;
            }
        }, {
            key: "dispose",
            value: function() {
                var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null, 
                this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(), 
                this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null, 
                this._bufferState = null;
            }
        } ]), SubMeshStaticBatch;
    }();
    Vt._tempVector30 = new o(), Vt._tempVector31 = new o(), Vt._tempQuaternion0 = new u(), 
    Vt._tempMatrix4x40 = new c(), Vt._tempMatrix4x41 = new c(), Vt._tempMatrix4x42 = new c(), 
    Vt.maxBatchVertexCount = 65535, Vt._batchIDCounter = 0;
    var Ft = function(e) {
        function MeshRenderStaticBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderStaticBatchManager), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderStaticBatchManager).call(this)))._opaqueBatchMarks = [], 
            e._updateCountMark = 0, e;
        }
        return _inherits(MeshRenderStaticBatchManager, Bt), _createClass(MeshRenderStaticBatchManager, [ {
            key: "_compare",
            value: function(e, t) {
                var n = e._render, r = t._render, i = e.meshFilter.sharedMesh, a = t.meshFilter.sharedMesh, o = n.lightmapIndex - r.lightmapIndex;
                if (0 === o) {
                    var s = (n.receiveShadow ? 1 : 0) - (r.receiveShadow ? 1 : 0);
                    if (0 === s) {
                        var l = n.sharedMaterial && r.sharedMaterial ? n.sharedMaterial.id - r.sharedMaterial.id : 0;
                        if (0 === l) {
                            var u = i._vertexBuffer.vertexDeclaration.id - a._vertexBuffer.vertexDeclaration.id;
                            return 0 === u ? a._indexBuffer.indexCount - i._indexBuffer.indexCount : u;
                        }
                        return l;
                    }
                    return s;
                }
                return o;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new wt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
                e.staticBatchElementList = new C()), e;
            }
        }, {
            key: "_getStaticBatch",
            value: function(e, t, n) {
                var r = e[n];
                return r || (r = e[n] = new Vt(t, MeshRenderStaticBatchManager._verDec), this._staticBatches[r._batchID] = r), 
                r;
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                var t = this._initBatchSprites;
                this._quickSort(t, 0, t.length - 1);
                for (var n, r = [], i = !1, a = 0, o = 0, s = t.length; o < s; o++) {
                    var l = t[o];
                    if (i) n.addTest(l) ? n.add(l) : (i = !1, a++); else o !== s - 1 && ((n = this._getStaticBatch(r, e, a)).add(l), 
                    i = !0);
                }
                for (o = 0, s = r.length; o < s; o++) {
                    var u = r[o];
                    u && u.finishInit();
                }
                this._initBatchSprites.length = 0;
            }
        }, {
            key: "_removeRenderSprite",
            value: function(e) {
                var t = e._render, n = t._staticBatch, r = n._batchElements, i = r.indexOf(e);
                if (-1 !== i) {
                    r.splice(i, 1), t._staticBatch = null;
                    for (var a = t._renderElements, o = 0, s = a.length; o < s; o++) a[o].staticBatch = null;
                }
                0 === r.length && (delete this._staticBatches[n._batchID], n.dispose());
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderStaticBatchManager.prototype), "_clear", this).call(this), 
                this._updateCountMark++;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                for (var e in this._staticBatches) {
                    var t = this._staticBatches[e];
                    0 === t._batchElements.length && (t.dispose(), delete this._staticBatches[e]);
                }
            }
        }, {
            key: "getBatchOpaquaMark",
            value: function(e, t, n, r) {
                var i = t ? 1 : 0, a = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []), o = a[i] || (a[i] = []), s = o[n] || (o[n] = []);
                return s[r] || (s[r] = new Nt());
            }
        } ], [ {
            key: "__init__",
            value: function() {
                MeshRenderStaticBatchManager._verDec = Qe.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
            }
        } ]), MeshRenderStaticBatchManager;
    }();
    Ft.instance = new Ft();
    var Ut = function(e) {
        function BaseRender(e) {
            var n;
            if (_classCallCheck(this, BaseRender), (n = _possibleConstructorReturn(this, _getPrototypeOf(BaseRender).call(this)))._lightmapScaleOffset = new i(1, 1, 0, 0), 
            n._indexInList = -1, n._indexInCastShadowList = -1, n._boundsChange = !0, n._castShadow = !1, 
            n._supportOctree = !0, n._sharedMaterials = [], n._renderMark = -1, n._indexInOctreeMotionList = -1, 
            n._updateMark = -1, n._updateRenderType = -1, n._isPartOfStaticBatch = !1, n._staticBatch = null, 
            n._id = ++BaseRender._uniqueIDCounter, n._indexInCastShadowList = -1, n._bounds = new xt(o._ZERO, o._ZERO), 
            t.Render.supportWebGLPlusCulling) {
                var r = Le._cullingBufferLength;
                n._cullingBufferIndex = r;
                var a = Le._cullingBuffer, s = r + 7;
                if (s >= a.length) {
                    var l = a;
                    (a = Le._cullingBuffer = new Float32Array(a.length + 4096)).set(l, 0);
                }
                a[r] = 2, Le._cullingBufferLength = s;
            }
            return n._renderElements = [], n._owner = e, n._enable = !0, n._materialsInstance = [], 
            n._shaderValues = new ce(null), n.lightmapIndex = -1, n.receiveShadow = !1, n.sortingFudge = 0, 
            e && n._owner.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(n), n._onWorldMatNeedChange), 
            n;
        }
        return _inherits(BaseRender, t.EventDispatcher), _createClass(BaseRender, [ {
            key: "_getOctreeNode",
            value: function() {
                return this._octreeNode;
            }
        }, {
            key: "_setOctreeNode",
            value: function(e) {
                this._octreeNode = e;
            }
        }, {
            key: "_getIndexInMotionList",
            value: function() {
                return this._indexInOctreeMotionList;
            }
        }, {
            key: "_setIndexInMotionList",
            value: function(e) {
                this._indexInOctreeMotionList = e;
            }
        }, {
            key: "_changeMaterialReference",
            value: function(e, t) {
                e && e._removeReference(), t._addReference();
            }
        }, {
            key: "_getInstanceMaterial",
            value: function(e, t) {
                var n = e.clone();
                return n.name = n.name + "(Instance)", this._materialsInstance[t] = !0, this._changeMaterialReference(this._sharedMaterials[t], n), 
                this._sharedMaterials[t] = n, n;
            }
        }, {
            key: "_applyLightMapParams",
            value: function() {
                var e = this._scene.lightmaps, t = this._shaderValues, n = this._lightmapIndex;
                if (n >= 0 && n < e.length) {
                    var r = e[n];
                    t.setTexture(Pt.LIGHTMAP, r.lightmapColor), t.addDefine(Pt.SAHDERDEFINE_LIGHTMAP), 
                    r.lightmapDirection ? (t.setTexture(Pt.LIGHTMAP_DIRECTION, r.lightmapDirection), 
                    t.addDefine(Pt.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)) : t.removeDefine(Pt.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                } else t.removeDefine(Pt.SAHDERDEFINE_LIGHTMAP), t.removeDefine(Pt.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function(e) {
                this._boundsChange = !0, this._octreeNode && (e &= f.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                throw "BaseRender: must override it.";
            }
        }, {
            key: "_getIndexInList",
            value: function() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function(e) {
                this._indexInList = e;
            }
        }, {
            key: "_setBelongScene",
            value: function(e) {
                this._scene = e;
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !0;
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {}
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {}
        }, {
            key: "_revertBatchRenderUpdate",
            value: function(e) {}
        }, {
            key: "_destroy",
            value: function() {
                -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this), 
                this.offAll();
                var e = 0, t = 0;
                for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e].destroy();
                for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
                this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null, 
                this._lightmapScaleOffset = null;
            }
        }, {
            key: "markAsUnStatic",
            value: function() {
                this._isPartOfStaticBatch && (Ft.instance._removeRenderSprite(this._owner), this._isPartOfStaticBatch = !1);
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "lightmapIndex",
            get: function() {
                return this._lightmapIndex;
            },
            set: function(e) {
                this._lightmapIndex = e;
            }
        }, {
            key: "lightmapScaleOffset",
            get: function() {
                return this._lightmapScaleOffset;
            },
            set: function(e) {
                if (!e) throw "BaseRender: lightmapScaleOffset can't be null.";
                this._lightmapScaleOffset = e, this._shaderValues.setVector(Pt.LIGHTMAPSCALEOFFSET, e);
            }
        }, {
            key: "enable",
            get: function() {
                return this._enable;
            },
            set: function(e) {
                this._enable = !!e;
            }
        }, {
            key: "material",
            get: function() {
                var e = this._sharedMaterials[0];
                if (e && !this._materialsInstance[0]) {
                    var t = this._getInstanceMaterial(e, 0), n = this._renderElements[0];
                    n && (n.material = t);
                }
                return this._sharedMaterials[0];
            },
            set: function(e) {
                this.sharedMaterial = e;
            }
        }, {
            key: "materials",
            get: function() {
                for (var e = 0, t = this._sharedMaterials.length; e < t; e++) if (!this._materialsInstance[e]) {
                    var n = this._getInstanceMaterial(this._sharedMaterials[e], e), r = this._renderElements[e];
                    r && (r.material = n);
                }
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                this.sharedMaterials = e;
            }
        }, {
            key: "sharedMaterial",
            get: function() {
                return this._sharedMaterials[0];
            },
            set: function(e) {
                var t = this._sharedMaterials[0];
                if (t !== e) {
                    this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                    var n = this._renderElements[0];
                    n && (n.material = e);
                }
            }
        }, {
            key: "sharedMaterials",
            get: function() {
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                for (var t = this._materialsInstance, n = this._sharedMaterials, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    a && a._removeReference();
                }
                if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
                var o = e.length;
                for (t.length = o, n.length = o, r = 0; r < o; r++) {
                    a = n[r];
                    var s = e[r];
                    if (a !== s) {
                        t[r] = !1;
                        var l = this._renderElements[r];
                        l && (l.material = s);
                    }
                    s && s._addReference(), n[r] = s;
                }
            }
        }, {
            key: "bounds",
            get: function() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
                this._bounds;
            }
        }, {
            key: "receiveShadow",
            set: function(e) {
                this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues.addDefine(Pt.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(Pt.SHADERDEFINE_RECEIVE_SHADOW));
            },
            get: function() {
                return this._receiveShadow;
            }
        }, {
            key: "castShadow",
            get: function() {
                return this._castShadow;
            },
            set: function(e) {
                this._castShadow = e;
            }
        }, {
            key: "isPartOfStaticBatch",
            get: function() {
                return this._isPartOfStaticBatch;
            }
        }, {
            key: "isRender",
            get: function() {
                return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1;
            }
        } ]), BaseRender;
    }();
    Ut._tempBoundBoxCorners = [ new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o() ], 
    Ut._uniqueIDCounter = 0, Ut._defaultLightmapScaleOffset = new i(1, 1, 0, 0);
    var Gt = function(e) {
        function PixelLineRenderer(e) {
            var t;
            return _classCallCheck(this, PixelLineRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineRenderer).call(this, e)))._projectionViewWorldMatrix = new c(), 
            t;
        }
        return _inherits(PixelLineRenderer, Ut), _createClass(PixelLineRenderer, [ {
            key: "_calculateBoundingBox",
            value: function() {
                var e = this._owner.transform.worldMatrix, n = this._owner._geometryFilter;
                if (n._reCalculateBound(), n._bounds._tranform(e, this._bounds), t.Render.supportWebGLPlusCulling) {
                    var r = this._bounds.getMin(), i = this._bounds.getMax(), a = Le._cullingBuffer;
                    a[this._cullingBufferIndex + 1] = r.x, a[this._cullingBufferIndex + 2] = r.y, a[this._cullingBufferIndex + 3] = r.z, 
                    a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var n = e.projectionViewMatrix, r = this._shaderValues;
                if (t) {
                    var i = t.worldMatrix;
                    r.setMatrix4x4(et.WORLDMATRIX, i), c.multiply(n, i, this._projectionViewWorldMatrix), 
                    r.setMatrix4x4(et.MVPMATRIX, this._projectionViewWorldMatrix);
                } else r.setMatrix4x4(et.WORLDMATRIX, c.DEFAULT), r.setMatrix4x4(et.MVPMATRIX, n);
            }
        } ]), PixelLineRenderer;
    }(), Ht = function(e) {
        function PixelLineSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, PixelLineSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineSprite3D).call(this, n)))._geometryFilter = new Ot(_assertThisInitialized(e), t), 
            e._render = new Gt(_assertThisInitialized(e)), e._changeRenderObjects(e._render, 0, Mt.defaultMaterial), 
            e;
        }
        return _inherits(PixelLineSprite3D, Pt), _createClass(PixelLineSprite3D, [ {
            key: "_changeRenderObjects",
            value: function(e, t, n) {
                var r = this._render._renderElements;
                n || (n = Mt.defaultMaterial);
                var i = r[t];
                i || (i = r[t] = new kt()), i.setTransform(this._transform), i.setGeometry(this._geometryFilter), 
                i.render = this._render, i.material = n;
            }
        }, {
            key: "addLine",
            value: function(e, t, n, r) {
                if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
                this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, n, r);
            }
        }, {
            key: "addLines",
            value: function(e) {
                var t = this._geometryFilter._lineCount, n = e.length;
                if (t + n > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += n;
            }
        }, {
            key: "removeLine",
            value: function(e) {
                if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._removeLineData(e);
            }
        }, {
            key: "setLine",
            value: function(e, t, n, r, i) {
                if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._updateLineData(e, t, n, r, i);
            }
        }, {
            key: "getLine",
            value: function(e, t) {
                if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._getLineData(e, t);
            }
        }, {
            key: "clear",
            value: function() {
                this._geometryFilter._lineCount = 0;
            }
        }, {
            key: "_create",
            value: function() {
                return new PixelLineSprite3D();
            }
        }, {
            key: "maxLineCount",
            get: function() {
                return this._geometryFilter._maxLineCount;
            },
            set: function(e) {
                this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
            }
        }, {
            key: "lineCount",
            get: function() {
                return this._geometryFilter._lineCount;
            },
            set: function(e) {
                if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
                this._geometryFilter._lineCount = e;
            }
        }, {
            key: "pixelLineRenderer",
            get: function() {
                return this._render;
            }
        } ]), PixelLineSprite3D;
    }(), zt = function() {
        function RenderQueue() {
            var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            _classCallCheck(this, RenderQueue), this.isTransparent = !1, this.elements = new C(), 
            this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1, this.isTransparent = e;
        }
        return _createClass(RenderQueue, [ {
            key: "_compare",
            value: function(e, t) {
                var n = e.material.renderQueue - t.material.renderQueue;
                return 0 === n ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : n;
            }
        }, {
            key: "_partitionRenderObject",
            value: function(e, t) {
                for (var n = this.elements.elements, r = n[Math.floor((t + e) / 2)]; e <= t; ) {
                    for (;this._compare(n[e], r) < 0; ) e++;
                    for (;this._compare(n[t], r) > 0; ) t--;
                    if (e < t) {
                        var i = n[e];
                        n[e] = n[t], n[t] = i, e++, t--;
                    } else if (e === t) {
                        e++;
                        break;
                    }
                }
                return e;
            }
        }, {
            key: "_quickSort",
            value: function(e, t) {
                if (this.elements.length > 1) {
                    var n = this._partitionRenderObject(e, t), r = n - 1;
                    e < r && this._quickSort(e, r), n < t && this._quickSort(n, t);
                }
            }
        }, {
            key: "_render",
            value: function(e) {
                for (var t = this.elements.elements, n = 0, r = this.elements.length; n < r; n++) t[n]._render(e);
            }
        }, {
            key: "clear",
            value: function() {
                this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
            }
        } ]), RenderQueue;
    }(), Wt = function() {
        function BoundsOctreeNode(e, t, n, r) {
            _classCallCheck(this, BoundsOctreeNode), this._bounds = new At(new o(), new o()), 
            this._objects = [], this._isContaion = !1, this.center = new o(), this.baseLength = 0, 
            this._setValues(e, t, n, r);
        }
        return _createClass(BoundsOctreeNode, [ {
            key: "_setValues",
            value: function(e, t, n, r) {
                this._octree = e, this._parent = t, this.baseLength = n, r.cloneTo(this.center);
                var i = this._bounds.min, a = this._bounds.max, o = e._looseness * n / 2;
                i.setValue(r.x - o, r.y - o, r.z - o), a.setValue(r.x + o, r.y + o, r.z + o);
            }
        }, {
            key: "_getChildBound",
            value: function(e) {
                if (null != this._children && this._children[e]) return this._children[e]._bounds;
                var t = this.baseLength / 4, n = this.baseLength / 2 * this._octree._looseness / 2, r = BoundsOctreeNode._tempBoundBox, i = r.min, a = r.max;
                switch (e) {
                  case 0:
                    i.x = this.center.x - t - n, i.y = this.center.y + t - n, i.z = this.center.z - t - n, 
                    a.x = this.center.x - t + n, a.y = this.center.y + t + n, a.z = this.center.z - t + n;
                    break;

                  case 1:
                    i.x = this.center.x + t - n, i.y = this.center.y + t - n, i.z = this.center.z - t - n, 
                    a.x = this.center.x + t + n, a.y = this.center.y + t + n, a.z = this.center.z - t + n;
                    break;

                  case 2:
                    i.x = this.center.x - t - n, i.y = this.center.y + t - n, i.z = this.center.z + t - n, 
                    a.x = this.center.x - t + n, a.y = this.center.y + t + n, a.z = this.center.z + t + n;
                    break;

                  case 3:
                    i.x = this.center.x + t - n, i.y = this.center.y + t - n, i.z = this.center.z + t - n, 
                    a.x = this.center.x + t + n, a.y = this.center.y + t + n, a.z = this.center.z + t + n;
                    break;

                  case 4:
                    i.x = this.center.x - t - n, i.y = this.center.y - t - n, i.z = this.center.z - t - n, 
                    a.x = this.center.x - t + n, a.y = this.center.y - t + n, a.z = this.center.z - t + n;
                    break;

                  case 5:
                    i.x = this.center.x + t - n, i.y = this.center.y - t - n, i.z = this.center.z - t - n, 
                    a.x = this.center.x + t + n, a.y = this.center.y - t + n, a.z = this.center.z - t + n;
                    break;

                  case 6:
                    i.x = this.center.x - t - n, i.y = this.center.y - t - n, i.z = this.center.z + t - n, 
                    a.x = this.center.x - t + n, a.y = this.center.y - t + n, a.z = this.center.z + t + n;
                    break;

                  case 7:
                    i.x = this.center.x + t - n, i.y = this.center.y - t - n, i.z = this.center.z + t - n, 
                    a.x = this.center.x + t + n, a.y = this.center.y - t + n, a.z = this.center.z + t + n;
                }
                return r;
            }
        }, {
            key: "_getChildCenter",
            value: function(e) {
                if (null != this._children) return this._children[e].center;
                var t = this.baseLength / 4, n = BoundsOctreeNode._tempVector30;
                switch (e) {
                  case 0:
                    n.x = this.center.x - t, n.y = this.center.y + t, n.z = this.center.z - t;
                    break;

                  case 1:
                    n.x = this.center.x + t, n.y = this.center.y + t, n.z = this.center.z - t;
                    break;

                  case 2:
                    n.x = this.center.x - t, n.y = this.center.y + t, n.z = this.center.z + t;
                    break;

                  case 3:
                    n.x = this.center.x + t, n.y = this.center.y + t, n.z = this.center.z + t;
                    break;

                  case 4:
                    n.x = this.center.x - t, n.y = this.center.y - t, n.z = this.center.z - t;
                    break;

                  case 5:
                    n.x = this.center.x + t, n.y = this.center.y - t, n.z = this.center.z - t;
                    break;

                  case 6:
                    n.x = this.center.x - t, n.y = this.center.y - t, n.z = this.center.z + t;
                    break;

                  case 7:
                    n.x = this.center.x + t, n.y = this.center.y - t, n.z = this.center.z + t;
                }
                return n;
            }
        }, {
            key: "_getChild",
            value: function(e) {
                var t = this.baseLength / 4;
                switch (this._children || (this._children = []), e) {
                  case 0:
                    return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + -t, this.center.y + t, this.center.z - t)));

                  case 1:
                    return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y + t, this.center.z - t)));

                  case 2:
                    return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y + t, this.center.z + t)));

                  case 3:
                    return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y + t, this.center.z + t)));

                  case 4:
                    return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y - t, this.center.z - t)));

                  case 5:
                    return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y - t, this.center.z - t)));

                  case 6:
                    return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y - t, this.center.z + t)));

                  case 7:
                    return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y - t, this.center.z + t)));

                  default:
                    throw "BoundsOctreeNode: unknown index.";
                }
            }
        }, {
            key: "_shouldMerge",
            value: function() {
                for (var e = this._objects.length, t = 0; t < 8; t++) {
                    var n = this._children[t];
                    if (n) {
                        if (null != n._children) return !1;
                        e += n._objects.length;
                    }
                }
                return e <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED;
            }
        }, {
            key: "_mergeChildren",
            value: function() {
                for (var e = 0; e < 8; e++) {
                    var t = this._children[e];
                    if (t) {
                        t._parent = null;
                        for (var n = t._objects, r = n.length - 1; r >= 0; r--) {
                            var i = n[r];
                            this._objects.push(i), i._setOctreeNode(this);
                        }
                    }
                }
                this._children = null;
            }
        }, {
            key: "_merge",
            value: function() {
                if (null === this._children) {
                    var e = this._parent;
                    e && e._shouldMerge() && (e._mergeChildren(), e._merge());
                }
            }
        }, {
            key: "_checkAddNode",
            value: function(e) {
                if (null == this._children) {
                    if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                    for (var t = this._objects.length - 1; t >= 0; t--) {
                        var n = this._objects[t], r = this._bestFitChild(n.bounds.getCenter());
                        BoundsOctreeNode._encapsulates(this._getChildBound(r), n.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(n), 1), 
                        this._getChild(r)._add(n));
                    }
                }
                var i = this._bestFitChild(e.bounds.getCenter());
                return BoundsOctreeNode._encapsulates(this._getChildBound(i), e.bounds._getBoundBox()) ? this._getChild(i)._checkAddNode(e) : this;
            }
        }, {
            key: "_add",
            value: function(e) {
                var t = this._checkAddNode(e);
                t._objects.push(e), e._setOctreeNode(t);
            }
        }, {
            key: "_remove",
            value: function(e) {
                var t = this._objects.indexOf(e);
                this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
            }
        }, {
            key: "_addUp",
            value: function(e) {
                return Fe.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Be.Contains ? (this._add(e), 
                !0) : !!this._parent && this._parent._addUp(e);
            }
        }, {
            key: "_getCollidingWithFrustum",
            value: function(e, n, r, i, a, s) {
                var l = e.boundFrustum, u = e.position, c = e.cullingMask;
                if (r) {
                    var h = l.containsBoundBox(this._bounds);
                    if (t.Stat.octreeNodeCulling++, h === Be.Disjoint) return;
                    r = h === Be.Intersects;
                }
                this._isContaion = !r;
                for (var _ = n.scene, d = t.Stat.loopCount, f = 0, m = this._objects.length; f < m; f++) {
                    var T = this._objects[f];
                    if (s ? T._castShadow && T._enable : 0 != (Math.pow(2, T._owner._layer) & c) && T._enable) {
                        if (r && (t.Stat.frustumCulling++, !T._needRender(l, n))) continue;
                        T._renderMark = d, T._distanceForSort = o.distance(T.bounds.getCenter(), u);
                        for (var p = T._renderElements, g = 0, E = p.length; g < E; g++) {
                            p[g]._update(_, n, i, a);
                        }
                    }
                }
                if (null != this._children) for (f = 0; f < 8; f++) {
                    var y = this._children[f];
                    y && y._getCollidingWithFrustum(e, n, r, i, a, s);
                }
            }
        }, {
            key: "_getCollidingWithBoundBox",
            value: function(e, t, n) {
                if (t) {
                    var r = Fe.boxContainsBox(this._bounds, e);
                    if (r === Be.Disjoint) return;
                    t = r === Be.Intersects;
                }
                if (t) for (var i = 0, a = this._objects.length; i < a; i++) {
                    var o = this._objects[i];
                    Fe.intersectsBoxAndBox(o.bounds._getBoundBox(), e) && n.push(o);
                }
                if (null != this._children) for (i = 0; i < 8; i++) {
                    this._children[i]._getCollidingWithBoundBox(e, t, n);
                }
            }
        }, {
            key: "_bestFitChild",
            value: function(e) {
                return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
            }
        }, {
            key: "_update",
            value: function(e) {
                if (Fe.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Be.Contains) {
                    var t = this._checkAddNode(e);
                    if (t !== e._getOctreeNode()) {
                        t._objects.push(e), e._setOctreeNode(t);
                        var n = this._objects.indexOf(e);
                        this._objects.splice(n, 1), this._merge();
                    }
                    return !0;
                }
                if (this._parent) {
                    var r = this._parent._addUp(e);
                    return r && (n = this._objects.indexOf(e), this._objects.splice(n, 1), this._merge()), 
                    r;
                }
                return !1;
            }
        }, {
            key: "add",
            value: function(e) {
                return !!BoundsOctreeNode._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), 
                !0);
            }
        }, {
            key: "remove",
            value: function(e) {
                return e._getOctreeNode() === this && (this._remove(e), !0);
            }
        }, {
            key: "update",
            value: function(e) {
                return e._getOctreeNode() === this && this._update(e);
            }
        }, {
            key: "shrinkIfPossible",
            value: function(e) {
                if (this.baseLength < 2 * e) return this;
                for (var t = -1, n = 0, r = this._objects.length; n < r; n++) {
                    var i = this._objects[n], a = this._bestFitChild(i.bounds.getCenter());
                    if (0 != n && a != t) return this;
                    var o = this._getChildBound(a);
                    if (!BoundsOctreeNode._encapsulates(o, i.bounds._getBoundBox())) return this;
                    0 == n && (t = a);
                }
                if (null == this._children) {
                    if (-1 != t) {
                        var s = this._getChildCenter(t);
                        this._setValues(this._octree, null, this.baseLength / 2, s);
                    }
                    return this;
                }
                var l = !1;
                for (n = 0, r = this._children.length; n < r; n++) {
                    var u = this._children[n];
                    if (u && u.hasAnyObjects()) {
                        if (l) return this;
                        if (t >= 0 && t != n) return this;
                        l = !0, t = n;
                    }
                }
                if (-1 != t) {
                    var c = this._children[t];
                    return c._parent = null, c;
                }
                return this;
            }
        }, {
            key: "hasAnyObjects",
            value: function() {
                if (this._objects.length > 0) return !0;
                if (null != this._children) for (var e = 0; e < 8; e++) {
                    var t = this._children[e];
                    if (t && t.hasAnyObjects()) return !0;
                }
                return !1;
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function(e, t) {
                this._getCollidingWithBoundBox(e, !0, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE, r = Fe.intersectsRayAndBoxRD(e, this._bounds);
                if (!(-1 == r || r > n)) {
                    for (var i = 0, a = this._objects.length; i < a; i++) {
                        var o = this._objects[i];
                        -1 !== (r = Fe.intersectsRayAndBoxRD(e, o.bounds._getBoundBox())) && r <= n && t.push(o);
                    }
                    if (null != this._children) for (i = 0; i < 8; i++) {
                        this._children[i].getCollidingWithRay(e, t, n);
                    }
                }
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function(e, t, n, r, i) {
                this._getCollidingWithFrustum(e, t, !0, n, r, i);
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function(e) {
                if (!Fe.intersectsBoxAndBox(this._bounds, e)) return !1;
                for (var t = 0, n = this._objects.length; t < n; t++) {
                    var r = this._objects[t];
                    if (Fe.intersectsBoxAndBox(r.bounds._getBoundBox(), e)) return !0;
                }
                if (null != this._children) for (t = 0; t < 8; t++) {
                    if (this._children[t].isCollidingWithBoundBox(e)) return !0;
                }
                return !1;
            }
        }, {
            key: "isCollidingWithRay",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, n = Fe.intersectsRayAndBoxRD(e, this._bounds);
                if (-1 == n || n > t) return !1;
                for (var r = 0, i = this._objects.length; r < i; r++) {
                    var a = this._objects[r];
                    if (-1 !== (n = Fe.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) && n <= t) return !0;
                }
                if (null != this._children) for (r = 0; r < 8; r++) {
                    if (this._children[r].isCollidingWithRay(e, t)) return !0;
                }
                return !1;
            }
        }, {
            key: "getBound",
            value: function() {
                return this._bounds;
            }
        }, {
            key: "drawAllBounds",
            value: function(e, t, n) {
                if (null !== this._children || 0 != this._objects.length) {
                    t++;
                    var r = BoundsOctreeNode._tempColor0;
                    if (this._isContaion) r.r = 0, r.g = 0, r.b = 1; else {
                        var i = n ? t / n : 0;
                        r.r = 1 - i, r.g = i, r.b = 0;
                    }
                    if (r.a = .3, O._drawBound(e, this._bounds, r), null != this._children) for (var a = 0; a < 8; a++) {
                        var o = this._children[a];
                        o && o.drawAllBounds(e, t, n);
                    }
                }
            }
        }, {
            key: "drawAllObjects",
            value: function(e, t, n) {
                t++;
                var r = BoundsOctreeNode._tempColor0;
                if (this._isContaion) r.r = 0, r.g = 0, r.b = 1; else {
                    var i = n ? t / n : 0;
                    r.r = 1 - i, r.g = i, r.b = 0;
                }
                r.a = 1;
                for (var a = 0, o = this._objects.length; a < o; a++) O._drawBound(e, this._objects[a].bounds._getBoundBox(), r);
                if (null != this._children) for (a = 0; a < 8; a++) {
                    var s = this._children[a];
                    s && s.drawAllObjects(e, t, n);
                }
            }
        } ], [ {
            key: "_encapsulates",
            value: function(e, t) {
                return Fe.boxContainsBox(e, t) == Be.Contains;
            }
        } ]), BoundsOctreeNode;
    }();
    Wt._tempVector3 = new o(), Wt._tempVector30 = new o(), Wt._tempVector31 = new o(), 
    Wt._tempColor0 = new Me(), Wt._tempBoundBox = new At(new o(), new o()), Wt._NUM_OBJECTS_ALLOWED = 8;
    var Xt = function(e) {
        function OctreeMotionList() {
            return _classCallCheck(this, OctreeMotionList), _possibleConstructorReturn(this, _getPrototypeOf(OctreeMotionList).call(this));
        }
        return _inherits(OctreeMotionList, C), _createClass(OctreeMotionList, [ {
            key: "add",
            value: function(e) {
                if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
                this._add(e), e._setIndexInMotionList(this.length++);
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getIndexInMotionList();
                if (this.length--, t !== this.length) {
                    var n = this.elements[this.length];
                    this.elements[t] = n, n._setIndexInMotionList(t);
                }
                e._setIndexInMotionList(-1);
            }
        } ]), OctreeMotionList;
    }(), Yt = function() {
        function BoundsOctree(e, t, n, r) {
            _classCallCheck(this, BoundsOctree), this._motionObjects = new Xt(), this.count = 0, 
            n > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + n + " Adjusted to: " + e), 
            n = e), this._initialSize = e, this._minSize = n, this._looseness = Math.min(Math.max(r, 1), 2), 
            this._rootNode = new Wt(this, null, e, t);
        }
        return _createClass(BoundsOctree, [ {
            key: "_getMaxDepth",
            value: function(e, t) {
                t++;
                var n = e._children;
                if (null != n) for (var r = t, i = 0, a = n.length; i < a; i++) {
                    var o = n[i];
                    o && (t = Math.max(this._getMaxDepth(o, r), t));
                }
                return t;
            }
        }, {
            key: "_grow",
            value: function(e) {
                var t = e.x >= 0 ? 1 : -1, n = e.y >= 0 ? 1 : -1, r = e.z >= 0 ? 1 : -1, i = this._rootNode, a = this._rootNode.baseLength / 2, s = 2 * this._rootNode.baseLength, l = this._rootNode.center, u = new o(l.x + t * a, l.y + n * a, l.z + r * a);
                if (this._rootNode = new Wt(this, null, s, u), i.hasAnyObjects()) {
                    for (var c = this._rootNode._bestFitChild(i.center), h = [], _ = 0; _ < 8; _++) _ == c && (i._parent = this._rootNode, 
                    h[_] = i);
                    this._rootNode._children = h;
                }
            }
        }, {
            key: "add",
            value: function(e) {
                for (var t = 0; !this._rootNode.add(e); ) {
                    var n = BoundsOctree._tempVector30;
                    if (o.subtract(e.bounds.getCenter(), this._rootNode.center, n), this._grow(n), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                }
                this.count++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._getOctreeNode().remove(e);
                return t && this.count--, t;
            }
        }, {
            key: "update",
            value: function(e) {
                var t = 0, n = e._getOctreeNode();
                if (n) {
                    for (;!n._update(e); ) {
                        var r = BoundsOctree._tempVector30;
                        if (o.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(r), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "shrinkRootIfPossible",
            value: function() {
                this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
            }
        }, {
            key: "addMotionObject",
            value: function(e) {
                this._motionObjects.add(e);
            }
        }, {
            key: "removeMotionObject",
            value: function(e) {
                this._motionObjects.remove(e);
            }
        }, {
            key: "updateMotionObjects",
            value: function() {
                for (var e = this._motionObjects.elements, t = 0, n = this._motionObjects.length; t < n; t++) {
                    var r = e[t];
                    this.update(r), r._setIndexInMotionList(-1);
                }
                this._motionObjects.length = 0;
            }
        }, {
            key: "isCollidingWithBoundBox",
            value: function(e) {
                return this._rootNode.isCollidingWithBoundBox(e);
            }
        }, {
            key: "isCollidingWithRay",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
                return this._rootNode.isCollidingWithRay(e, t);
            }
        }, {
            key: "getCollidingWithBoundBox",
            value: function(e, t) {
                this._rootNode.getCollidingWithBoundBox(e, t);
            }
        }, {
            key: "getCollidingWithRay",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE;
                this._rootNode.getCollidingWithRay(e, t, n);
            }
        }, {
            key: "getCollidingWithFrustum",
            value: function(e, t, n, r, i) {
                this._rootNode.getCollidingWithFrustum(e, t, n, r, i);
            }
        }, {
            key: "getMaxBounds",
            value: function() {
                return this._rootNode.getBound();
            }
        }, {
            key: "drawAllBounds",
            value: function(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllBounds(e, -1, t);
            }
        }, {
            key: "drawAllObjects",
            value: function(e) {
                var t = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllObjects(e, -1, t);
            }
        } ]), BoundsOctree;
    }();
    Yt._tempVector30 = new o();
    var jt = function Lightmap() {
        _classCallCheck(this, Lightmap);
    }, Zt = function() {
        function BoundSphere(e, t) {
            _classCallCheck(this, BoundSphere), this.center = e, this.radius = t;
        }
        return _createClass(BoundSphere, [ {
            key: "toDefault",
            value: function() {
                this.center.toDefault(), this.radius = 0;
            }
        }, {
            key: "intersectsRayDistance",
            value: function(e) {
                return Fe.intersectsRayAndSphereRD(e, this);
            }
        }, {
            key: "intersectsRayPoint",
            value: function(e, t) {
                return Fe.intersectsRayAndSphereRP(e, this, t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.center.cloneTo(t.center), t.radius = this.radius;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoundSphere(new o(), 0);
                return this.cloneTo(e), e;
            }
        } ], [ {
            key: "createFromSubPoints",
            value: function(e, t, n, r) {
                if (null == e) throw new Error("points");
                if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
                if (n < 0 || t + n > e.length) throw new Error("count" + n + "Must be in the range <= " + e.length + "}");
                var i = t + n, a = BoundSphere._tempVector3;
                a.x = 0, a.y = 0, a.z = 0;
                for (var s = t; s < i; ++s) o.add(e[s], a, a);
                var l = r.center;
                o.scale(a, 1 / n, l);
                var u = 0;
                for (s = t; s < i; ++s) {
                    var c = o.distanceSquared(l, e[s]);
                    c > u && (u = c);
                }
                r.radius = Math.sqrt(u);
            }
        }, {
            key: "createfromPoints",
            value: function(e, t) {
                if (null == e) throw new Error("points");
                BoundSphere.createFromSubPoints(e, 0, e.length, t);
            }
        } ]), BoundSphere;
    }();
    Zt._tempVector3 = new o();
    var Qt, qt = function ShadowSliceData() {
        _classCallCheck(this, ShadowSliceData), this.cameraShaderValue = new ce(), this.position = new o(), 
        this.viewMatrix = new c(), this.projectionMatrix = new c(), this.viewProjectMatrix = new c(), 
        this.cullPlanes = [ new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()) ], 
        this.splitBoundSphere = new Zt(new o(), 0);
    }, Kt = function ShadowSpotData() {
        _classCallCheck(this, ShadowSpotData), this.cameraShaderValue = new ce(), this.position = new o(), 
        this.viewMatrix = new c(), this.projectionMatrix = new c(), this.viewProjectMatrix = new c(), 
        this.cameraCullInfo = new Ae();
    };
    (Qt = e.ShadowLightType || (e.ShadowLightType = {}))[Qt.DirectionLight = 0] = "DirectionLight", 
    Qt[Qt.SpotLight = 1] = "SpotLight", Qt[Qt.PointLight = 2] = "PointLight";
    var Jt = function() {
        function ShadowCasterPass() {
            _classCallCheck(this, ShadowCasterPass), this._shadowBias = new i(), this._shadowParams = new i(), 
            this._shadowMapSize = new i(), this._shadowMatrices = new Float32Array(16 * ShadowCasterPass._maxCascades), 
            this._shadowSpotMatrices = new c(), this._splitBoundSpheres = new Float32Array(4 * ShadowCasterPass._maxCascades), 
            this._cascadeCount = 0, this._shadowMapWidth = 0, this._shadowMapHeight = 0, this._shadowSliceDatas = [ new qt(), new qt(), new qt(), new qt() ], 
            this._shadowSpotData = new Kt(), this._lightUp = new o(), this._lightSide = new o(), 
            this._lightForward = new o(), this._shadowSpotData.cameraCullInfo.boundFrustum = new Ue(new c());
        }
        return _createClass(ShadowCasterPass, [ {
            key: "_setupShadowCasterShaderValues",
            value: function(t, n, r, i, a, o, s) {
                switch (n.setVector(ShadowCasterPass.SHADOW_BIAS, o), s) {
                  case e.LightType.Directional:
                    n.setVector3(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, i);
                    break;

                  case e.LightType.Spot:
                    n.setVector(ShadowCasterPass.SHADOW_PARAMS, a);
                    break;

                  case e.LightType.Point:
                }
                var l = r.cameraShaderValue;
                l.setMatrix4x4(nt.VIEWMATRIX, r.viewMatrix), l.setMatrix4x4(nt.PROJECTMATRIX, r.projectionMatrix), 
                l.setMatrix4x4(nt.VIEWPROJECTMATRIX, r.viewProjectMatrix), t.viewMatrix = r.viewMatrix, 
                t.projectionMatrix = r.projectionMatrix, t.projectionViewMatrix = r.viewProjectMatrix;
            }
        }, {
            key: "_setupShadowReceiverShaderValues",
            value: function(t) {
                var n = this._light;
                switch (n.shadowCascadesMode !== e.ShadowCascadesMode.NoCascades ? t.addDefine(ht.SHADERDEFINE_SHADOW_CASCADE) : t.removeDefine(ht.SHADERDEFINE_SHADOW_CASCADE), 
                n.shadowMode) {
                  case e.ShadowMode.Hard:
                    t.removeDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                    break;

                  case e.ShadowMode.SoftLow:
                    t.addDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                    break;

                  case e.ShadowMode.SoftHigh:
                    t.addDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH), t.removeDefine(ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
                }
                t.setTexture(ShadowCasterPass.SHADOW_MAP, this._shadowDirectLightMap), t.setBuffer(ShadowCasterPass.SHADOW_MATRICES, this._shadowMatrices), 
                t.setVector(ShadowCasterPass.SHADOW_MAP_SIZE, this._shadowMapSize), t.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams), 
                t.setBuffer(ShadowCasterPass.SHADOW_SPLIT_SPHERES, this._splitBoundSpheres);
            }
        }, {
            key: "_setupSpotShadowReceiverShaderValues",
            value: function(t) {
                switch (this._light.shadowMode) {
                  case e.ShadowMode.Hard:
                    t.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH), t.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
                    break;

                  case e.ShadowMode.SoftLow:
                    t.addDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW), t.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH);
                    break;

                  case e.ShadowMode.SoftHigh:
                    t.addDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH), t.removeDefine(ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
                }
                t.setTexture(ShadowCasterPass.SHADOW_SPOTMAP, this._shadowSpotLightMap), t.setMatrix4x4(ShadowCasterPass.SHADOW_SPOTMATRICES, this._shadowSpotMatrices), 
                t.setVector(ShadowCasterPass.SHADOW_MAP_SIZE, this._shadowMapSize), t.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams);
            }
        }, {
            key: "update",
            value: function(t, r, i) {
                switch (i) {
                  case e.ShadowLightType.DirectionLight:
                    this._light = r;
                    var a = (M = ShadowCasterPass._tempMatrix0).elements, s = this._lightUp, l = this._lightSide, u = this._lightForward;
                    c.createFromQuaternion(r._transform.rotation, M), l.setValue(a[0], a[1], a[2]), 
                    s.setValue(a[4], a[5], a[6]), u.setValue(-a[8], -a[9], -a[10]);
                    var h, _, d, f, m = r._shadowResolution, T = r._shadowCascadesMode;
                    T == e.ShadowCascadesMode.NoCascades ? (h = 1, _ = m, d = m, f = m) : (h = T == e.ShadowCascadesMode.TwoCascades ? 2 : 4, 
                    d = 2 * (_ = Tt.getMaxTileResolutionInAtlas(m, m, h)), f = T == e.ShadowCascadesMode.TwoCascades ? _ : 2 * _), 
                    this._cascadeCount = h, this._shadowMapWidth = d, this._shadowMapHeight = f;
                    var p = ShadowCasterPass._cascadesSplitDistance, g = ShadowCasterPass._frustumPlanes, E = t.nearPlane, y = Math.min(t.farPlane, r._shadowDistance), v = this._shadowMatrices, S = this._splitBoundSpheres;
                    Tt.getCascadesSplitDistance(r._shadowTwoCascadeSplits, r._shadowFourCascadeSplits, E, y, t.fieldOfView * n.Deg2Rad, t.aspectRatio, T, p), 
                    Tt.getCameraFrustumPlanes(t.projectionViewMatrix, g);
                    var C = ShadowCasterPass._tempVector30;
                    t._transform.getForward(C), o.normalize(C, C);
                    for (var R = 0; R < h; R++) {
                        var D = this._shadowSliceDatas[R];
                        D.sphereCenterZ = Tt.getBoundSphereByFrustum(p[R], p[R + 1], t.fieldOfView * n.Deg2Rad, t.aspectRatio, t._transform.position, C, D.splitBoundSphere), 
                        Tt.getDirectionLightShadowCullPlanes(g, R, p, E, u, D), Tt.getDirectionalLightMatrices(s, l, u, R, r._shadowNearPlane, _, D, v), 
                        h > 1 && Tt.applySliceTransform(D, d, f, R, v);
                    }
                    Tt.prepareShadowReceiverShaderValues(r, d, f, this._shadowSliceDatas, h, this._shadowMapSize, this._shadowParams, v, S);
                    break;

                  case e.ShadowLightType.SpotLight:
                    this._light = r;
                    var M = ShadowCasterPass._tempMatrix0, A = (u = this._lightForward, this._light._shadowResolution);
                    this._shadowMapWidth = A, this._shadowMapHeight = A;
                    var x = this._shadowSpotData;
                    Tt.getSpotLightShadowData(x, this._light, A, this._shadowParams, this._shadowSpotMatrices, this._shadowMapSize);
                    break;

                  case e.ShadowLightType.PointLight:
                    break;

                  default:
                    throw "There is no shadow of this type";
                }
            }
        }, {
            key: "render",
            value: function(n, r, i) {
                switch (i) {
                  case e.ShadowLightType.DirectionLight:
                    var a = r._shaderValues;
                    n.pipelineMode = "ShadowCaster", ce.setRuntimeValueMode(!1), (T = this._shadowDirectLightMap = Tt.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, t.RenderTextureDepthFormat.DEPTH_16))._start();
                    for (var o = this._light, s = 0, l = this._cascadeCount; s < l; s++) {
                        var u = this._shadowSliceDatas[s];
                        Tt.getShadowBias(o, u.projectionMatrix, u.resolution, this._shadowBias), this._setupShadowCasterShaderValues(n, a, u, this._lightForward, this._shadowParams, this._shadowBias, e.LightType.Directional);
                        var c = Le._shadowCullInfo;
                        c.position = u.position, c.cullPlanes = u.cullPlanes, c.cullPlaneCount = u.cullPlaneCount, 
                        c.cullSphere = u.splitBoundSphere, c.direction = this._lightForward;
                        var h = Le.cullingShadow(c, r, n);
                        n.cameraShaderValue = u.cameraShaderValue, pt._updateMark++;
                        var _ = t.LayaGL.instance, d = u.resolution, f = u.offsetX, m = u.offsetY;
                        _.enable(_.SCISSOR_TEST), _.viewport(f, m, d, d), _.scissor(f, m, d, d), _.clear(_.DEPTH_BUFFER_BIT), 
                        h && (_.scissor(f + 1, m + 1, d - 2, d - 2), r._opaqueQueue._render(n));
                    }
                    T._end(), this._setupShadowReceiverShaderValues(a), ce.setRuntimeValueMode(!0), 
                    n.pipelineMode = "Forward";
                    break;

                  case e.ShadowLightType.SpotLight:
                    a = r._shaderValues;
                    n.pipelineMode = "ShadowCaster", ce.setRuntimeValueMode(!1);
                    var T, p = this._light;
                    (T = this._shadowSpotLightMap = Tt.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, t.RenderTextureDepthFormat.DEPTH_16))._start();
                    var g = this._shadowSpotData;
                    Tt.getShadowBias(p, g.projectionMatrix, g.resolution, this._shadowBias), this._setupShadowCasterShaderValues(n, a, g, this._light.transform.position, this._shadowParams, this._shadowBias, e.LightType.Spot);
                    h = Le.cullingSpotShadow(g.cameraCullInfo, r, n);
                    n.cameraShaderValue = g.cameraShaderValue, pt._updateMark++, (_ = t.LayaGL.instance).enable(_.SCISSOR_TEST), 
                    _.viewport(g.offsetX, g.offsetY, g.resolution, g.resolution), _.scissor(g.offsetX, g.offsetY, g.resolution, g.resolution), 
                    _.clear(_.DEPTH_BUFFER_BIT), h && (_.scissor(g.offsetX, g.offsetY, g.resolution, g.resolution), 
                    r._opaqueQueue._render(n)), T._end(), this._setupSpotShadowReceiverShaderValues(a), 
                    ce.setRuntimeValueMode(!0), n.pipelineMode = "Forward";
                    break;

                  case e.ShadowLightType.PointLight:
                    break;

                  default:
                    throw "There is no shadow of this type";
                }
            }
        }, {
            key: "cleanUp",
            value: function() {
                this._shadowDirectLightMap && ie.recoverToPool(this._shadowDirectLightMap), this._shadowSpotLightMap && ie.recoverToPool(this._shadowSpotLightMap), 
                this._shadowDirectLightMap = null, this._shadowSpotLightMap = null, this._light = null;
            }
        } ]), ShadowCasterPass;
    }();
    Jt._tempVector30 = new o(), Jt._tempMatrix0 = new c(), Jt.SHADOW_BIAS = ue.propertyNameToID("u_ShadowBias"), 
    Jt.SHADOW_LIGHT_DIRECTION = ue.propertyNameToID("u_ShadowLightDirection"), Jt.SHADOW_SPLIT_SPHERES = ue.propertyNameToID("u_ShadowSplitSpheres"), 
    Jt.SHADOW_MATRICES = ue.propertyNameToID("u_ShadowMatrices"), Jt.SHADOW_MAP_SIZE = ue.propertyNameToID("u_ShadowMapSize"), 
    Jt.SHADOW_MAP = ue.propertyNameToID("u_ShadowMap"), Jt.SHADOW_PARAMS = ue.propertyNameToID("u_ShadowParams"), 
    Jt.SHADOW_SPOTMAP = ue.propertyNameToID("u_SpotShadowMap"), Jt.SHADOW_SPOTMATRICES = ue.propertyNameToID("u_SpotViewProjectMatrix"), 
    Jt._maxCascades = 4, Jt._cascadesSplitDistance = new Array(Jt._maxCascades + 1), 
    Jt._frustumPlanes = new Array(new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()), new ke(new o()));
    var $t, en = function() {
        function DynamicBatchManager() {
            _classCallCheck(this, DynamicBatchManager), this._batchRenderElementPool = [];
        }
        return _createClass(DynamicBatchManager, [ {
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "dispose",
            value: function() {}
        } ], [ {
            key: "_registerManager",
            value: function(e) {
                DynamicBatchManager._managers.push(e);
            }
        } ]), DynamicBatchManager;
    }();
    en._managers = [], ($t = e.AmbientMode || (e.AmbientMode = {}))[$t.SolidColor = 0] = "SolidColor", 
    $t[$t.SphericalHarmonics = 1] = "SphericalHarmonics";
    var tn = function(n) {
        function Scene3D() {
            var n;
            _classCallCheck(this, Scene3D), (n = _possibleConstructorReturn(this, _getPrototypeOf(Scene3D).call(this)))._lightCount = 0, 
            n._pointLights = new Rt(), n._spotLights = new Rt(), n._directionLights = new Rt(), 
            n._alternateLights = new Dt(), n._lightmaps = [], n._skyRenderer = new $e(), n._input = new gt(), 
            n._timer = t.ILaya.timer, n._time = 0, n._shCoefficients = new Array(7), n._ambientMode = e.AmbientMode.SolidColor, 
            n._ambientSphericalHarmonics = new Pe(), n._ambientSphericalHarmonicsIntensity = 1, 
            n._reflectionDecodeFormat = t.TextureDecodeFormat.Normal, n._reflectionIntensity = 1, 
            n._collsionTestList = [], n._renders = new De(), n._opaqueQueue = new zt(!1), n._transparentQueue = new zt(!0), 
            n._cameraPool = [], n._animatorPool = new De(), n._scriptPool = new Array(), n._tempScriptPool = new Array(), 
            n._needClearScriptPool = !1, n._reflectionCubeHDRParams = new i(), n.currentCreationLayer = Math.pow(2, 0), 
            n.enableLight = !0, n._key = new t.SubmitKey(), n._pickIdToSprite = new Object(), 
            n._reflectionMode = 0, !w._config.isUseCannonPhysicsEngine && k._bullet ? n._physicsSimulation = new L(Scene3D.physicsSettings) : k._cannon && (n._cannonPhysicsSimulation = new t.CannonPhysicsSimulation(Scene3D.cannonPhysicsSettings)), 
            n._shaderValues = new ce(null), n.enableFog = !1, n.fogStart = 300, n.fogRange = 1e3, 
            n.fogColor = new o(.7, .7, .7), n.ambientColor = new o(.212, .227, .259), n.reflectionIntensity = 1, 
            n.reflection = Ct.blackTexture;
            for (var r = 0; r < 7; r++) n._shCoefficients[r] = new i();
            if (n._shaderValues.setVector(Scene3D.REFLECTIONCUBE_HDR_PARAMS, n._reflectionCubeHDRParams), 
            t.Render.supportWebGLPlusCulling && (n._cullingBufferIndices = new Int32Array(1024), 
            n._cullingBufferResult = new Int32Array(1024)), n._scene = _assertThisInitialized(n), 
            n._input.__init__(t.Render.canvas, _assertThisInitialized(n)), Scene3D.octreeCulling && (n._octree = new Yt(Scene3D.octreeInitialSize, Scene3D.octreeInitialCenter, Scene3D.octreeMinNodeSize, Scene3D.octreeLooseness)), 
            Le.debugFrustumCulling) {
                n._debugTool = new Ht();
                var a = new Mt();
                a.renderQueue = me.RENDERQUEUE_TRANSPARENT, a.alphaTest = !1, a.depthWrite = !1, 
                a.cull = pe.CULL_BACK, a.blend = pe.BLEND_ENABLE_ALL, a.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                a.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, a.depthTest = pe.DEPTHTEST_LESS, 
                n._debugTool.pixelLineRenderer.sharedMaterial = a;
            }
            return n;
        }
        return _inherits(Scene3D, t.Sprite), _createClass(Scene3D, [ {
            key: "_applySHCoefficients",
            value: function(e, t) {
                for (var n = this._shCoefficients, r = 0; r < 3; r++) {
                    var i = n[r], a = n[r + 3];
                    i.setValue(e.getCoefficient(r, 3) * t, e.getCoefficient(r, 1) * t, e.getCoefficient(r, 2) * t, (e.getCoefficient(r, 0) - e.getCoefficient(r, 6)) * t), 
                    a.setValue(e.getCoefficient(r, 4) * t, e.getCoefficient(r, 5) * t, 3 * e.getCoefficient(r, 6) * t, e.getCoefficient(r, 7) * t);
                }
                n[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e.getCoefficient(2, 8) * t, 1);
                var o = this._shaderValues;
                o.setVector(Scene3D.AMBIENTSHAR, n[0]), o.setVector(Scene3D.AMBIENTSHAG, n[1]), 
                o.setVector(Scene3D.AMBIENTSHAB, n[2]), o.setVector(Scene3D.AMBIENTSHBR, n[3]), 
                o.setVector(Scene3D.AMBIENTSHBG, n[4]), o.setVector(Scene3D.AMBIENTSHBB, n[5]), 
                o.setVector(Scene3D.AMBIENTSHC, n[6]);
            }
        }, {
            key: "_update",
            value: function() {
                var e = this.timer._delta / 1e3;
                this._time += e, this._shaderValues.setNumber(Scene3D.TIME, this._time);
                var n = this._physicsSimulation;
                if (!k._enablePhysics || L.disableSimulation || w._config.isUseCannonPhysicsEngine || (n._updatePhysicsTransformFromRender(), 
                S._addUpdateList = !1, n._simulate(e), n._updateCharacters(), S._addUpdateList = !0, 
                n._updateCollisions(), n._eventScripts()), k._cannon && w._config.isUseCannonPhysicsEngine) {
                    var r = this._cannonPhysicsSimulation;
                    r._updatePhysicsTransformFromRender(), t.CannonPhysicsComponent._addUpdateList = !1, 
                    r._simulate(e), t.CannonPhysicsComponent._addUpdateList = !0, r._updateCollisions(), 
                    r._eventScripts();
                }
                this._input._update(), this._clearScript(), this._updateScript(), te._update(this), 
                this._lateUpdateScript();
            }
        }, {
            key: "_binarySearchIndexInCameraPool",
            value: function(e) {
                for (var t, n = 0, r = this._cameraPool.length - 1; n <= r; ) {
                    t = Math.floor((n + r) / 2);
                    var i = this._cameraPool[t]._renderingOrder;
                    if (i == e._renderingOrder) return t;
                    i > e._renderingOrder ? r = t - 1 : n = t + 1;
                }
                return n;
            }
        }, {
            key: "_allotPickColorByID",
            value: function(e, t) {
                var n = Math.floor(e / 65025);
                e -= 255 * n * 255;
                var r = Math.floor(e / 255), i = e -= 255 * r;
                t.x = n / 255, t.y = r / 255, t.z = i / 255, t.w = 1;
            }
        }, {
            key: "_searchIDByPickColor",
            value: function(e) {
                return 255 * e.x * 255 + 255 * e.y + e.z;
            }
        }, {
            key: "onEnable",
            value: function() {
                this._input._onCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "onDisable",
            value: function() {
                this._input._offCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_getGroup",
            value: function() {
                return this._group;
            }
        }, {
            key: "_setGroup",
            value: function(e) {
                this._group = e;
            }
        }, {
            key: "_clearScript",
            value: function() {
                if (this._needClearScriptPool) {
                    for (var e = this._scriptPool, t = 0, n = e.length; t < n; t++) {
                        var r = e[t];
                        r && (r._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(r));
                    }
                    this._scriptPool = this._tempScriptPool, e.length = 0, this._tempScriptPool = e, 
                    this._needClearScriptPool = !1;
                }
            }
        }, {
            key: "_updateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    r && r.enabled && r.onUpdate();
                }
            }
        }, {
            key: "_lateUpdateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    r && r.enabled && r.onLateUpdate();
                }
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onActive", this).call(this), t.ILaya.stage._scene3Ds.push(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onInActive", this).call(this);
                var e = t.ILaya.stage._scene3Ds;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_prepareSceneToRender",
            value: function() {
                var e = this._shaderValues;
                if (w._config._multiLighting) {
                    var t = Scene3D._lightTexture, n = Scene3D._lightPixles, r = t.width, i = 4 * r, a = 0, s = this._directionLights._length, l = this._directionLights._elements;
                    if (s > 0) {
                        var u = this._directionLights.getBrightestLight();
                        this._mainDirectionLight = l[u], this._directionLights.normalLightOrdering(u);
                        for (var c = 0; c < s; c++, a++) {
                            var h = (S = l[c])._direction, _ = S._intensityColor, d = i * a;
                            o.scale(S.color, S._intensity, _), S.transform.worldMatrix.getForward(h), o.normalize(h, h), 
                            n[d] = _.x, n[d + 1] = _.y, n[d + 2] = _.z, n[d + 4] = h.x, n[d + 5] = h.y, n[d + 6] = h.z, 
                            0 == c && (e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, _), e.setVector3(Scene3D.SUNLIGHTDIRECTION, h));
                        }
                        e.addDefine(ht.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_DIRECTIONLIGHT);
                    var f = this._pointLights._length;
                    if (f > 0) {
                        var m = this._pointLights._elements, T = this._pointLights.getBrightestLight();
                        this._mainPointLight = m[T], this._pointLights.normalLightOrdering(T);
                        for (c = 0; c < f; c++, a++) {
                            var p = (C = m[c]).transform.position;
                            _ = C._intensityColor, d = i * a;
                            o.scale(C.color, C._intensity, _), n[d] = _.x, n[d + 1] = _.y, n[d + 2] = _.z, n[d + 3] = C.range, 
                            n[d + 4] = p.x, n[d + 5] = p.y, n[d + 6] = p.z;
                        }
                        e.addDefine(ht.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_POINTLIGHT);
                    var g = this._spotLights._length;
                    if (g > 0) {
                        var E = this._spotLights._elements, y = this._spotLights.getBrightestLight();
                        this._mainSpotLight = E[y], this._spotLights.normalLightOrdering(y);
                        for (c = 0; c < g; c++, a++) {
                            var v = E[c];
                            h = v._direction, p = v.transform.position, _ = v._intensityColor, d = i * a;
                            o.scale(v.color, v._intensity, _), v.transform.worldMatrix.getForward(h), o.normalize(h, h), 
                            n[d] = _.x, n[d + 1] = _.y, n[d + 2] = _.z, n[d + 3] = v.range, n[d + 4] = p.x, 
                            n[d + 5] = p.y, n[d + 6] = p.z, n[d + 7] = v.spotAngle * Math.PI / 180, n[d + 8] = h.x, 
                            n[d + 9] = h.y, n[d + 10] = h.z;
                        }
                        e.addDefine(ht.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_SPOTLIGHT);
                    a > 0 && t.setSubPixels(0, 0, r, a, n, 0), e.setTexture(Scene3D.LIGHTBUFFER, t), 
                    e.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights._length), e.setTexture(Scene3D.CLUSTERBUFFER, Oe.instance._clusterTexture);
                } else {
                    if (this._directionLights._length > 0) {
                        var S = this._directionLights._elements[0];
                        this._mainDirectionLight = S, o.scale(S.color, S._intensity, S._intensityColor), 
                        S.transform.worldMatrix.getForward(S._direction), o.normalize(S._direction, S._direction), 
                        e.setVector3(Scene3D.LIGHTDIRCOLOR, S._intensityColor), e.setVector3(Scene3D.LIGHTDIRECTION, S._direction), 
                        e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, S._intensityColor), e.setVector3(Scene3D.SUNLIGHTDIRECTION, S._direction), 
                        e.addDefine(ht.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_DIRECTIONLIGHT);
                    if (this._pointLights._length > 0) {
                        var C = this._pointLights._elements[0];
                        o.scale(C.color, C._intensity, C._intensityColor), e.setVector3(Scene3D.POINTLIGHTCOLOR, C._intensityColor), 
                        e.setVector3(Scene3D.POINTLIGHTPOS, C.transform.position), e.setNumber(Scene3D.POINTLIGHTRANGE, C.range), 
                        e.addDefine(ht.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_POINTLIGHT);
                    if (this._spotLights._length > 0) {
                        var R = this._spotLights._elements[0];
                        o.scale(R.color, R._intensity, R._intensityColor), e.setVector3(Scene3D.SPOTLIGHTCOLOR, R._intensityColor), 
                        e.setVector3(Scene3D.SPOTLIGHTPOS, R.transform.position), R.transform.worldMatrix.getForward(R._direction), 
                        o.normalize(R._direction, R._direction), e.setVector3(Scene3D.SPOTLIGHTDIRECTION, R._direction), 
                        e.setNumber(Scene3D.SPOTLIGHTRANGE, R.range), e.setNumber(Scene3D.SPOTLIGHTSPOTANGLE, R.spotAngle * Math.PI / 180), 
                        e.addDefine(ht.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(ht.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }, {
            key: "_addScript",
            value: function(e) {
                var t = this._scriptPool;
                e._indexInPool = t.length, t.push(e);
            }
        }, {
            key: "_removeScript",
            value: function(e) {
                this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this._needClearScriptPool = !0;
            }
        }, {
            key: "_preRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    r && r.enabled && r.onPreRender();
                }
            }
        }, {
            key: "_postRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, n = e.length; t < n; t++) {
                    var r = e[t];
                    r && r.enabled && r.onPostRender();
                }
            }
        }, {
            key: "_addCamera",
            value: function(e) {
                for (var t = this._binarySearchIndexInCameraPool(e), n = e._renderingOrder, r = this._cameraPool.length; t < r && this._cameraPool[t]._renderingOrder <= n; ) t++;
                this._cameraPool.splice(t, 0, e);
            }
        }, {
            key: "_removeCamera",
            value: function(e) {
                this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
            }
        }, {
            key: "_preCulling",
            value: function(e, t, n, r) {
                var i = Le._cameraCullInfo;
                i.position = t._transform.position, i.cullingMask = t.cullingMask, i.boundFrustum = t.boundFrustum, 
                i.useOcclusionCulling = t.useOcclusionCulling, Le.renderObjectCulling(i, this, e, n, r, !1);
            }
        }, {
            key: "_clear",
            value: function(n, r) {
                var i, a, o, s = r.viewport, l = r.camera, u = l._getRenderTexture(), c = s.width, h = s.height;
                l._needInternalRenderTexture() ? (i = 0, a = 0) : (i = s.x, a = l._getCanvasHeight() - s.y - h), 
                n.viewport(i, a, c, h);
                var _ = l.clearFlag;
                switch (_ !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (_ = e.CameraClearFlags.SolidColor), 
                _) {
                  case e.CameraClearFlags.SolidColor:
                    var d = l.clearColor;
                    if (n.enable(n.SCISSOR_TEST), n.scissor(i, a, c, h), d ? n.clearColor(d.x, d.y, d.z, d.w) : n.clearColor(0, 0, 0, 0), 
                    u) switch (o = n.COLOR_BUFFER_BIT, u.depthStencilFormat) {
                      case t.RenderTextureDepthFormat.DEPTH_16:
                        o |= n.DEPTH_BUFFER_BIT;
                        break;

                      case t.RenderTextureDepthFormat.STENCIL_8:
                        o |= n.STENCIL_BUFFER_BIT;
                        break;

                      case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                        o |= n.DEPTH_BUFFER_BIT, o |= n.STENCIL_BUFFER_BIT;
                    } else o = n.COLOR_BUFFER_BIT | n.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(n, !0), n.clear(o), n.disable(n.SCISSOR_TEST);
                    break;

                  case e.CameraClearFlags.Sky:
                  case e.CameraClearFlags.DepthOnly:
                    if (n.enable(n.SCISSOR_TEST), n.scissor(i, a, c, h), u) switch (u.depthStencilFormat) {
                      case t.RenderTextureDepthFormat.DEPTH_16:
                        o = n.DEPTH_BUFFER_BIT;
                        break;

                      case t.RenderTextureDepthFormat.STENCIL_8:
                        o = n.STENCIL_BUFFER_BIT;
                        break;

                      case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                        o = n.DEPTH_BUFFER_BIT | n.STENCIL_BUFFER_BIT;
                    } else o = n.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(n, !0), n.clear(o), n.disable(n.SCISSOR_TEST);
                    break;

                  case e.CameraClearFlags.Nothing:
                    break;

                  default:
                    throw new Error("Scene3D:camera clearFlag invalid.");
                }
            }
        }, {
            key: "_renderScene",
            value: function(t) {
                var n = t.camera;
                if (this._opaqueQueue._render(t), n.clearFlag === e.CameraClearFlags.Sky && (n.skyRenderer._isAvailable() ? n.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)), 
                this._transparentQueue._render(t), Le.debugFrustumCulling) for (var r = this._debugTool._render._renderElements, i = 0, a = r.length; i < a; i++) r[i]._update(this, t, null, null), 
                r[i]._render(t);
            }
        }, {
            key: "_parse",
            value: function(e, n) {
                var r = e.lightmaps;
                if (r) {
                    for (var i = r.length, a = new Array(i), o = 0; o < i; o++) {
                        var s = new jt(), l = r[o];
                        l.path ? s.lightmapColor = t.Loader.getRes(l.path) : (s.lightmapColor = t.Loader.getRes(l.color.path), 
                        l.direction && (s.lightmapDirection = t.Loader.getRes(l.direction.path))), a[o] = s;
                    }
                    this.lightmaps = a;
                }
                var u = e.ambientColor;
                if (u) {
                    var c = this.ambientColor;
                    c.fromArray(u), this.ambientColor = c;
                }
                var h = e.sky;
                if (h) switch (this._skyRenderer.material = t.Loader.getRes(h.material.path), h.mesh) {
                  case "SkyBox":
                    this._skyRenderer.mesh = Je.instance;
                    break;

                  case "SkyDome":
                    this._skyRenderer.mesh = St.instance;
                    break;

                  default:
                    this.skyRenderer.mesh = Je.instance;
                }
                this.enableFog = e.enableFog, this.fogStart = e.fogStart, this.fogRange = e.fogRange;
                var _ = e.fogColor;
                if (_) {
                    var d = this.fogColor;
                    d.fromArray(_), this.fogColor = d;
                }
                var f = e.ambientSphericalHarmonics;
                if (f) {
                    var m = this.ambientSphericalHarmonics;
                    for (o = 0; o < 3; o++) {
                        var T = 9 * o;
                        m.setCoefficients(o, f[T], f[T + 1], f[T + 2], f[T + 3], f[T + 4], f[T + 5], f[T + 6], f[T + 7], f[T + 8]);
                    }
                    this.ambientSphericalHarmonics = m;
                }
                var p = e.reflection;
                null != p && (this.reflection = t.Loader.getRes(p));
                var g = e.reflectionDecodingFormat;
                null != g && (this.reflectionDecodingFormat = g);
                var E = e.ambientMode;
                null != E && (this.ambientMode = E);
                var y = e.ambientSphericalHarmonicsIntensity;
                null != y && (this.ambientSphericalHarmonicsIntensity = y);
                var v = e.reflectionIntensity;
                null != v && (this.reflectionIntensity = v);
            }
        }, {
            key: "_addRenderObject",
            value: function(e) {
                if (this._octree && e._supportOctree) this._octree.add(e); else if (this._renders.add(e), 
                t.Render.supportWebGLPlusCulling) {
                    var n = e._getIndexInList(), r = this._cullingBufferIndices.length;
                    if (n >= r) {
                        var i = this._cullingBufferIndices, a = this._cullingBufferResult;
                        this._cullingBufferIndices = new Int32Array(r + 1024), this._cullingBufferResult = new Int32Array(r + 1024), 
                        this._cullingBufferIndices.set(i, 0), this._cullingBufferResult.set(a, 0);
                    }
                    this._cullingBufferIndices[n] = e._cullingBufferIndex;
                }
            }
        }, {
            key: "_removeRenderObject",
            value: function(e) {
                var n;
                this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (n = this._renders.elements[this._renders.length - 1]), 
                this._renders.remove(e), t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[n._getIndexInList()] = n._cullingBufferIndex));
            }
        }, {
            key: "_getRenderQueue",
            value: function(e) {
                return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
            }
        }, {
            key: "_clearRenderQueue",
            value: function() {
                this._opaqueQueue.clear(), this._transparentQueue.clear();
                for (var e = Bt._managers, t = 0, n = e.length; t < n; t++) e[t]._clear();
                var r = en._managers;
                for (t = 0, n = r.length; t < n; t++) r[t]._clear();
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Scene3D.prototype), "destroy", this).call(this, e), 
                this._skyRenderer.destroy(), this._skyRenderer = null, this._directionLights = null, 
                this._pointLights = null, this._spotLights = null, this._alternateLights = null, 
                this._lightmaps = null, this._shaderValues = null, this._renders = null, this._cameraPool = null, 
                this._octree = null, this._physicsSimulation && this._physicsSimulation._destroy(), 
                t.Loader.clearRes(this.url));
            }
        }, {
            key: "render",
            value: function(e, n, r) {
                e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
            }
        }, {
            key: "renderSubmit",
            value: function() {
                var e, n, r;
                t.LayaGL.instance;
                for (this._prepareSceneToRender(), e = 0, r = (n = this._cameraPool.length) - 1; e < n; e++) {
                    t.Render.supportWebGLPlusRendering && ce.setRuntimeValueMode(e == r);
                    var i = this._cameraPool[e];
                    i.enableRender && i.render();
                }
                return t.Context.set2DRenderConfig(), 1;
            }
        }, {
            key: "getRenderType",
            value: function() {
                return 0;
            }
        }, {
            key: "releaseRender",
            value: function() {}
        }, {
            key: "reUse",
            value: function(e, t) {
                return 0;
            }
        }, {
            key: "setlightmaps",
            value: function(e) {
                for (var t = this._lightmaps, n = 0, r = t.length; n < r; n++) t[n].lightmapColor._removeReference();
                if (!e) throw new Error("Scene3D: value value can't be null.");
                var i = e.length;
                for (t.length = i, n = 0; n < i; n++) {
                    var a = e[n];
                    a._addReference(), t[n] || (t[n] = new jt()), t[n].lightmapColor = a;
                }
            }
        }, {
            key: "getlightmaps",
            value: function() {
                for (var e = new Array(this._lightmaps.length), t = 0; t < this._lightmaps.length; t++) e[t] = this._lightmaps[t].lightmapColor;
                return e;
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "enableFog",
            get: function() {
                return this._enableFog;
            },
            set: function(e) {
                this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(ht.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(ht.SHADERDEFINE_FOG));
            }
        }, {
            key: "fogColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.FOGCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.FOGCOLOR, e);
            }
        }, {
            key: "fogStart",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGSTART);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGSTART, e);
            }
        }, {
            key: "fogRange",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGRANGE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGRANGE, e);
            }
        }, {
            key: "ambientMode",
            get: function() {
                return this._ambientMode;
            },
            set: function(t) {
                if (this._ambientMode !== t) {
                    switch (t) {
                      case e.AmbientMode.SolidColor:
                        this._shaderValues.removeDefine(ht.SHADERDEFINE_GI_AMBIENT_SH);
                        break;

                      case e.AmbientMode.SphericalHarmonics:
                        this._shaderValues.addDefine(ht.SHADERDEFINE_GI_AMBIENT_SH);
                        break;

                      default:
                        throw "Scene3D: unknown ambientMode.";
                    }
                    this._ambientMode = t;
                }
            }
        }, {
            key: "ambientColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, e);
            }
        }, {
            key: "ambientSphericalHarmonics",
            get: function() {
                return this._ambientSphericalHarmonics;
            },
            set: function(e) {
                var t = e || Pe._default;
                this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity, 2.2)), 
                this._ambientSphericalHarmonics != e && e.cloneTo(this._ambientSphericalHarmonics);
            }
        }, {
            key: "ambientSphericalHarmonicsIntensity",
            get: function() {
                return this._ambientSphericalHarmonicsIntensity;
            },
            set: function(e) {
                if (e = Math.max(Math.min(e, 8), 0), this._ambientSphericalHarmonicsIntensity !== e) {
                    var t = this._ambientSphericalHarmonics || Pe._default;
                    this._applySHCoefficients(t, Math.pow(e, 2.2)), this._ambientSphericalHarmonicsIntensity = e;
                }
            }
        }, {
            key: "reflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || Ct.blackTexture), 
                this._reflection = e);
            }
        }, {
            key: "reflectionDecodingFormat",
            get: function() {
                return this._reflectionDecodeFormat;
            },
            set: function(e) {
                this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this._reflectionIntensity, 
                this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5), 
                this._reflectionDecodeFormat = e);
            }
        }, {
            key: "reflectionIntensity",
            get: function() {
                return this._reflectionIntensity;
            },
            set: function(e) {
                e = Math.max(Math.min(e, 1), 0), this._reflectionCubeHDRParams.x = e, this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5), 
                this._reflectionIntensity = e;
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "physicsSimulation",
            get: function() {
                return this._physicsSimulation;
            }
        }, {
            key: "cannonPhysicsSimulation",
            get: function() {
                return this._cannonPhysicsSimulation;
            }
        }, {
            key: "timer",
            get: function() {
                return this._timer;
            },
            set: function(e) {
                this._timer = e;
            }
        }, {
            key: "input",
            get: function() {
                return this._input;
            }
        }, {
            key: "lightmaps",
            get: function() {
                return this._lightmaps.slice();
            },
            set: function(e) {
                var t = this._lightmaps;
                if (t) for (var n = 0, r = t.length; n < r; n++) {
                    (a = t[n]).lightmapColor._removeReference(), a.lightmapDirection._removeReference();
                }
                if (e) {
                    var i = e.length;
                    for (t.length = i, n = 0; n < i; n++) {
                        var a;
                        (a = e[n]).lightmapColor && a.lightmapColor._addReference(), a.lightmapDirection && a.lightmapDirection._addReference(), 
                        t[n] = a;
                    }
                } else t.length = 0;
            }
        }, {
            key: "customReflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || Ct.blackTexture), 
                this._reflection = e);
            }
        }, {
            key: "reflectionMode",
            get: function() {
                return this._reflectionMode;
            },
            set: function(e) {
                this._reflectionMode = e;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var n = w._config;
                if (n._multiLighting) {
                    var r = n.maxLightCount, i = n.lightClusterCount;
                    Oe.instance = new Oe(i.x, i.y, i.z, Math.min(n.maxLightCount, n._maxAreaLightCountPerClusterAverage)), 
                    Scene3D._lightTexture = O._createFloatTextureBuffer(4, r), Scene3D._lightTexture.lock = !0, 
                    Scene3D._lightPixles = new Float32Array(4 * r * 4);
                }
                ht.SHADERDEFINE_FOG = ue.getDefineByName("FOG"), ht.SHADERDEFINE_DIRECTIONLIGHT = ue.getDefineByName("DIRECTIONLIGHT"), 
                ht.SHADERDEFINE_POINTLIGHT = ue.getDefineByName("POINTLIGHT"), ht.SHADERDEFINE_SPOTLIGHT = ue.getDefineByName("SPOTLIGHT"), 
                ht.SHADERDEFINE_SHADOW = ue.getDefineByName("SHADOW"), ht.SHADERDEFINE_SHADOW_CASCADE = ue.getDefineByName("SHADOW_CASCADE"), 
                ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = ue.getDefineByName("SHADOW_SOFT_SHADOW_LOW"), 
                ht.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = ue.getDefineByName("SHADOW_SOFT_SHADOW_HIGH"), 
                ht.SHADERDEFINE_GI_AMBIENT_SH = ue.getDefineByName("GI_AMBIENT_SH"), ht.SHADERDEFINE_SHADOW_SPOT = ue.getDefineByName("SHADOW_SPOT"), 
                ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW = ue.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_LOW"), 
                ht.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH = ue.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_HIGH");
                var a = w._config, o = Scene3D._configDefineValues;
                switch (a._multiLighting || o.add(ue.SHADERDEFINE_LEGACYSINGALLIGHTING), t.LayaGL.layaGPUInstance._isWebGL2 ? o.add(ue.SHADERDEFINE_GRAPHICS_API_GLES3) : o.add(ue.SHADERDEFINE_GRAPHICS_API_GLES2), 
                a.pbrRenderQuality) {
                  case e.PBRRenderQuality.High:
                    o.add(Se.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
                    break;

                  case e.PBRRenderQuality.Low:
                    o.add(Se.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
                    break;

                  default:
                    throw "Scene3D:unknown shader quality.";
                }
                a.isUseCannonPhysicsEngine ? Scene3D.cannonPhysicsSettings = new t.CannonPhysicsSettings() : Scene3D.physicsSettings = new yt();
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.ILaya.loader.create(e, n, null, Scene3D.HIERARCHY);
            }
        } ]), Scene3D;
    }();
    tn._shadowCasterPass = new Jt(), tn.HIERARCHY = "HIERARCHY", tn.octreeCulling = !1, 
    tn.octreeInitialSize = 64, tn.octreeInitialCenter = new o(0, 0, 0), tn.octreeMinNodeSize = 2, 
    tn.octreeLooseness = 1.25, tn.REFLECTIONMODE_SKYBOX = 0, tn.REFLECTIONMODE_CUSTOM = 1, 
    tn.FOGCOLOR = ue.propertyNameToID("u_FogColor"), tn.FOGSTART = ue.propertyNameToID("u_FogStart"), 
    tn.FOGRANGE = ue.propertyNameToID("u_FogRange"), tn.DIRECTIONLIGHTCOUNT = ue.propertyNameToID("u_DirationLightCount"), 
    tn.LIGHTBUFFER = ue.propertyNameToID("u_LightBuffer"), tn.CLUSTERBUFFER = ue.propertyNameToID("u_LightClusterBuffer"), 
    tn.SUNLIGHTDIRECTION = ue.propertyNameToID("u_SunLight.direction"), tn.SUNLIGHTDIRCOLOR = ue.propertyNameToID("u_SunLight.color"), 
    tn.AMBIENTSHAR = ue.propertyNameToID("u_AmbientSHAr"), tn.AMBIENTSHAG = ue.propertyNameToID("u_AmbientSHAg"), 
    tn.AMBIENTSHAB = ue.propertyNameToID("u_AmbientSHAb"), tn.AMBIENTSHBR = ue.propertyNameToID("u_AmbientSHBr"), 
    tn.AMBIENTSHBG = ue.propertyNameToID("u_AmbientSHBg"), tn.AMBIENTSHBB = ue.propertyNameToID("u_AmbientSHBb"), 
    tn.AMBIENTSHC = ue.propertyNameToID("u_AmbientSHC"), tn.REFLECTIONPROBE = ue.propertyNameToID("u_ReflectionProbe"), 
    tn.REFLECTIONCUBE_HDR_PARAMS = ue.propertyNameToID("u_ReflectCubeHDRParams"), tn.LIGHTDIRECTION = ue.propertyNameToID("u_DirectionLight.direction"), 
    tn.LIGHTDIRCOLOR = ue.propertyNameToID("u_DirectionLight.color"), tn.POINTLIGHTPOS = ue.propertyNameToID("u_PointLight.position"), 
    tn.POINTLIGHTRANGE = ue.propertyNameToID("u_PointLight.range"), tn.POINTLIGHTATTENUATION = ue.propertyNameToID("u_PointLight.attenuation"), 
    tn.POINTLIGHTCOLOR = ue.propertyNameToID("u_PointLight.color"), tn.SPOTLIGHTPOS = ue.propertyNameToID("u_SpotLight.position"), 
    tn.SPOTLIGHTDIRECTION = ue.propertyNameToID("u_SpotLight.direction"), tn.SPOTLIGHTSPOTANGLE = ue.propertyNameToID("u_SpotLight.spot"), 
    tn.SPOTLIGHTRANGE = ue.propertyNameToID("u_SpotLight.range"), tn.SPOTLIGHTCOLOR = ue.propertyNameToID("u_SpotLight.color"), 
    tn.AMBIENTCOLOR = ue.propertyNameToID("u_AmbientColor"), tn.REFLECTIONTEXTURE = ue.propertyNameToID("u_ReflectTexture"), 
    tn.TIME = ue.propertyNameToID("u_Time"), tn._configDefineValues = new ae();
    var nn = function(e) {
        function ShaderPass(e, t, n, r) {
            var i;
            for (var a in _classCallCheck(this, ShaderPass), (i = _possibleConstructorReturn(this, _getPrototypeOf(ShaderPass).call(this, t, n, null)))._cacheSharders = {}, 
            i._cacheShaderHierarchy = 1, i._renderState = new pe(), i._validDefine = new ae(), 
            i._tags = {}, i._owner = e, i._stateMap = r, i.defs) i._validDefine.add(ue.getDefineByName(a));
            return i;
        }
        return _inherits(ShaderPass, t.ShaderCompile), _createClass(ShaderPass, [ {
            key: "_compileToTree",
            value: function(e, n, r, i, a) {
                var o, s, l, u, c, h, _, d, f, m, T;
                for (f = r; f < n.length; f++) if (!((l = n[f]).length < 1) && 0 !== (h = l.indexOf("//"))) {
                    if (h >= 0 && (l = l.substr(0, h)), o = d || new t.ShaderNode(i), d = null, o.text = l, 
                    (h = l.indexOf("#")) >= 0) {
                        for (u = "#", T = h + 1, m = l.length; T < m; T++) {
                            var p = l.charAt(T);
                            if (" " === p || "\t" === p || "?" === p) break;
                            u += p;
                        }
                        switch (o.name = u, u) {
                          case "#ifdef":
                          case "#ifndef":
                            if (o.setParent(e), e = o, a) for (_ = l.substr(T).split(t.ShaderCompile._splitToWordExps3), 
                            T = 0; T < _.length; T++) (l = _[T]).length && (a[l] = !0);
                            continue;

                          case "#if":
                          case "#elif":
                            if (o.setParent(e), e = o, a) for (_ = l.substr(T).split(t.ShaderCompile._splitToWordExps3), 
                            T = 0; T < _.length; T++) (l = _[T]).length && "defined" != l && (a[l] = !0);
                            continue;

                          case "#else":
                            s = (e = e.parent).childs[e.childs.length - 1], o.setParent(e), e = o;
                            continue;

                          case "#endif":
                            s = (e = e.parent).childs[e.childs.length - 1], o.setParent(e);
                            continue;

                          case "#include":
                            _ = t.ShaderCompile.splitToWords(l, null);
                            var g = t.ShaderCompile.includes[_[1]];
                            if (!g) throw "ShaderCompile error no this include file:" + _[1];
                            if ((h = _[0].indexOf("?")) < 0) {
                                o.setParent(e), l = g.getWith("with" == _[2] ? _[3] : null), this._compileToTree(o, l.split("\n"), 0, i, a), 
                                o.text = "";
                                continue;
                            }
                            o.setCondition(_[0].substr(h + 1), t.ShaderCompile.IFDEF_YES), o.text = g.getWith("with" == _[2] ? _[3] : null);
                            break;

                          case "#import":
                            c = (_ = t.ShaderCompile.splitToWords(l, null))[1], i.push({
                                node: o,
                                file: t.ShaderCompile.includes[c],
                                ofs: o.text.length
                            });
                            continue;
                        }
                    } else {
                        if ((s = e.childs[e.childs.length - 1]) && !s.name) {
                            i.length > 0 && t.ShaderCompile.splitToWords(l, s), d = o, s.text += "\n" + l;
                            continue;
                        }
                        i.length > 0 && t.ShaderCompile.splitToWords(l, o);
                    }
                    o.setParent(e);
                }
            }
        }, {
            key: "_resizeCacheShaderMap",
            value: function(e, t, n) {
                var r = this._cacheShaderHierarchy - 1;
                if (t == r) {
                    for (var i in e) for (var a = e[i], o = 0, s = n - r; o < s; o++) o == s - 1 ? e[0] = a : e = e[0 == o ? i : 0] = {};
                    this._cacheShaderHierarchy = n;
                } else for (var i in e) this._resizeCacheShaderMap(e[i], ++t, n);
            }
        }, {
            key: "_addDebugShaderVariantCollection",
            value: function(e, t, n) {
                var r = ue._debugShaderVariantInfo, i = this._owner, a = i._owner, o = e._mask;
                ue._getNamesByDefineData(e, t), n.length = o.length;
                for (var s = 0, l = o.length; s < l; s++) n[s] = o[s];
                r ? r.setValue(a, a._subShaders.indexOf(i), i._passes.indexOf(this), t) : ue._debugShaderVariantInfo = r = new se(a, a._subShaders.indexOf(i), i._passes.indexOf(this), t), 
                ue.debugShaderVariantCollection.add(r);
            }
        }, {
            key: "withCompile",
            value: function(e) {
                var n, r = ShaderPass._debugDefineString, i = ShaderPass._debugDefineMask;
                e._intersectionDefineDatas(this._validDefine), ue.debugMode && (n = e._length, this._addDebugShaderVariantCollection(e, r, i)), 
                e.addDefineDatas(tn._configDefineValues);
                var a = this._cacheSharders, o = e._length;
                o > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(a, 0, o), this._cacheShaderHierarchy = o);
                for (var s = e._mask, l = e._length - 1, u = this._cacheShaderHierarchy - 1, c = 0; c < u; c++) {
                    var h = l < c ? 0 : s[c], _ = a[h];
                    _ || (a[h] = _ = {}), a = _;
                }
                var d = l < u ? 0 : s[u], f = a[d];
                if (f) return f;
                var m = ShaderPass._defineString;
                ue._getNamesByDefineData(e, m);
                var T, p, g = w._config, E = g.lightClusterCount, y = {}, v = "";
                t.WebGL._isWebGL2 ? (T = "#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n", 
                p = "#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n") : (T = "", 
                p = "#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"), 
                v += "#define MAX_LIGHT_COUNT " + g.maxLightCount + "\n", v += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + g._maxAreaLightCountPerClusterAverage + "\n", 
                v += "#define CLUSTER_X_COUNT " + E.x + "\n", v += "#define CLUSTER_Y_COUNT " + E.y + "\n", 
                v += "#define CLUSTER_Z_COUNT " + E.z + "\n", v += "#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel + "\n";
                c = 0;
                for (var S = m.length; c < S; c++) {
                    var C = m[c];
                    v += "#define " + C + "\n", y[C] = !0;
                }
                var R = this._VS.toscript(y, []), D = "";
                0 == R[0].indexOf("#version") && (D = R[0] + "\n", R.shift());
                var M = this._PS.toscript(y, []), A = "";
                if (0 == M[0].indexOf("#version") && (A = M[0] + "\n", M.shift()), f = new Re(D + T + v + R.join("\n"), A + p + v + M.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this), 
                a[d] = f, ue.debugMode) {
                    var x = "", L = "";
                    for (c = 0, S = n; c < S; c++) L += c == S - 1 ? i[c] : i[c] + ",";
                    for (c = 0, S = r.length; c < S; c++) x += c == S - 1 ? r[c] : r[c] + ",";
                    console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + L + "] DefineNames:[" + x + "]", "color:green");
                }
                return f;
            }
        }, {
            key: "setTag",
            value: function(e, t) {
                t ? this._tags[e] = t : delete this._tags[e];
            }
        }, {
            key: "getTag",
            value: function(e) {
                return this._tags[e];
            }
        }, {
            key: "renderState",
            get: function() {
                return this._renderState;
            }
        } ]), ShaderPass;
    }();
    nn._defineString = [], nn._debugDefineString = [], nn._debugDefineMask = [];
    var rn, an = function() {
        function SubShader(e, t) {
            _classCallCheck(this, SubShader), this._flags = {}, this._passes = [], this._attributeMap = e, 
            this._uniformMap = t;
        }
        return _createClass(SubShader, [ {
            key: "setFlag",
            value: function(e, t) {
                t ? this._flags[e] = t : delete this._flags[e];
            }
        }, {
            key: "getFlag",
            value: function(e) {
                return this._flags[e];
            }
        }, {
            key: "addShaderPass",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "Forward", i = new nn(this, e, t, n);
                return i._pipelineMode = r, this._passes.push(i), i;
            }
        } ]), SubShader;
    }();
    (rn = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[rn.SpecularTextureAlpha = 0] = "SpecularTextureAlpha", 
    rn[rn.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var on = function(e) {
        function PBRSpecularMaterial() {
            var e;
            return _classCallCheck(this, PBRSpecularMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRSpecularMaterial).call(this))).setShaderName("PBRSpecular"), 
            e._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new i(.2, .2, .2, 1)), 
            e;
        }
        return _inherits(PBRSpecularMaterial, Se), _createClass(PBRSpecularMaterial, [ {
            key: "clone",
            value: function() {
                var e = new PBRSpecularMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE), 
                this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, e);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE = ue.getDefineByName("SPECULARGLOSSTEXTURE"), 
                PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = ue.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Normal: Qe.MESH_NORMAL0,
                    a_Tangent0: Qe.MESH_TANGENT0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: Qe.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: Qe.MESH_BLENDWEIGHT0,
                    a_BoneIndices: Qe.MESH_BLENDINDICES0,
                    a_MvpMatrix: Qe.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: Qe.MESH_WORLDMATRIX_ROW0
                }, t = {
                    u_Bones: ue.PERIOD_CUSTOM,
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_WorldMat: ue.PERIOD_SPRITE,
                    u_LightmapScaleOffset: ue.PERIOD_SPRITE,
                    u_LightMap: ue.PERIOD_SPRITE,
                    u_LightMapDirection: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorTexture: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorParams: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorTextureSize: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_View: ue.PERIOD_CAMERA,
                    u_ProjectionParams: ue.PERIOD_CAMERA,
                    u_Viewport: ue.PERIOD_CAMERA,
                    u_ViewProjection: ue.PERIOD_CAMERA,
                    u_AlphaTestValue: ue.PERIOD_MATERIAL,
                    u_AlbedoColor: ue.PERIOD_MATERIAL,
                    u_EmissionColor: ue.PERIOD_MATERIAL,
                    u_AlbedoTexture: ue.PERIOD_MATERIAL,
                    u_NormalTexture: ue.PERIOD_MATERIAL,
                    u_ParallaxTexture: ue.PERIOD_MATERIAL,
                    u_OcclusionTexture: ue.PERIOD_MATERIAL,
                    u_EmissionTexture: ue.PERIOD_MATERIAL,
                    u_Smoothness: ue.PERIOD_MATERIAL,
                    u_SmoothnessScale: ue.PERIOD_MATERIAL,
                    u_occlusionStrength: ue.PERIOD_MATERIAL,
                    u_NormalScale: ue.PERIOD_MATERIAL,
                    u_ParallaxScale: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_SpecGlossTexture: ue.PERIOD_MATERIAL,
                    u_SpecularColor: ue.PERIOD_MATERIAL,
                    u_ReflectTexture: ue.PERIOD_SCENE,
                    u_ReflectIntensity: ue.PERIOD_SCENE,
                    u_AmbientColor: ue.PERIOD_SCENE,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE,
                    u_DirationLightCount: ue.PERIOD_SCENE,
                    u_LightBuffer: ue.PERIOD_SCENE,
                    u_LightClusterBuffer: ue.PERIOD_SCENE,
                    u_ShadowBias: ue.PERIOD_SCENE,
                    u_ShadowLightDirection: ue.PERIOD_SCENE,
                    u_ShadowMap: ue.PERIOD_SCENE,
                    u_ShadowParams: ue.PERIOD_SCENE,
                    u_ShadowSplitSpheres: ue.PERIOD_SCENE,
                    u_ShadowMatrices: ue.PERIOD_SCENE,
                    u_ShadowMapSize: ue.PERIOD_SCENE,
                    u_SpotShadowMap: ue.PERIOD_SCENE,
                    u_SpotViewProjectMatrix: ue.PERIOD_SCENE,
                    u_ShadowLightPosition: ue.PERIOD_SCENE,
                    u_AmbientSHAr: ue.PERIOD_SCENE,
                    u_AmbientSHAg: ue.PERIOD_SCENE,
                    u_AmbientSHAb: ue.PERIOD_SCENE,
                    u_AmbientSHBr: ue.PERIOD_SCENE,
                    u_AmbientSHBg: ue.PERIOD_SCENE,
                    u_AmbientSHBb: ue.PERIOD_SCENE,
                    u_AmbientSHC: ue.PERIOD_SCENE,
                    u_ReflectionProbe: ue.PERIOD_SCENE,
                    u_ReflectCubeHDRParams: ue.PERIOD_SCENE,
                    "u_DirectionLight.direction": ue.PERIOD_SCENE,
                    "u_DirectionLight.color": ue.PERIOD_SCENE,
                    "u_PointLight.position": ue.PERIOD_SCENE,
                    "u_PointLight.range": ue.PERIOD_SCENE,
                    "u_PointLight.color": ue.PERIOD_SCENE,
                    "u_SpotLight.position": ue.PERIOD_SCENE,
                    "u_SpotLight.direction": ue.PERIOD_SCENE,
                    "u_SpotLight.range": ue.PERIOD_SCENE,
                    "u_SpotLight.spot": ue.PERIOD_SCENE,
                    "u_SpotLight.color": ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("PBRSpecular", e, t, !0), i = new an(e, t);
                r.addSubShader(i), i.addShaderPass('#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', n, "Forward"), 
                i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', n, "ShadowCaster");
            }
        } ]), PBRSpecularMaterial;
    }();
    on.SPECULARTEXTURE = ue.propertyNameToID("u_SpecGlossTexture"), on.SPECULARCOLOR = ue.propertyNameToID("u_SpecularColor");
    var sn;
    (sn = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[sn.MetallicGlossTextureAlpha = 0] = "MetallicGlossTextureAlpha", 
    sn[sn.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var ln = function(e) {
        function PBRStandardMaterial() {
            var e;
            return _classCallCheck(this, PBRStandardMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRStandardMaterial).call(this)))._smoothnessSource = 0, 
            e.setShaderName("PBR"), e._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0), 
            e;
        }
        return _inherits(PBRStandardMaterial, Se), _createClass(PBRStandardMaterial, [ {
            key: "clone",
            value: function() {
                var e = new PBRStandardMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "metallicGlossTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE), 
                this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, e);
            }
        }, {
            key: "metallic",
            get: function() {
                return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessSource",
            get: function() {
                return this._smoothnessSource;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
                this._smoothnessSource = e;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = ue.getDefineByName("METALLICGLOSSTEXTURE"), 
                PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = ue.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Normal: Qe.MESH_NORMAL0,
                    a_Tangent0: Qe.MESH_TANGENT0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: Qe.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: Qe.MESH_BLENDWEIGHT0,
                    a_BoneIndices: Qe.MESH_BLENDINDICES0,
                    a_MvpMatrix: Qe.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: Qe.MESH_WORLDMATRIX_ROW0
                }, t = {
                    u_Bones: ue.PERIOD_CUSTOM,
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_WorldMat: ue.PERIOD_SPRITE,
                    u_LightmapScaleOffset: ue.PERIOD_SPRITE,
                    u_LightMap: ue.PERIOD_SPRITE,
                    u_LightMapDirection: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorTexture: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorParams: ue.PERIOD_SPRITE,
                    u_SimpleAnimatorTextureSize: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_View: ue.PERIOD_CAMERA,
                    u_ProjectionParams: ue.PERIOD_CAMERA,
                    u_Viewport: ue.PERIOD_CAMERA,
                    u_ViewProjection: ue.PERIOD_CAMERA,
                    u_AlphaTestValue: ue.PERIOD_MATERIAL,
                    u_AlbedoColor: ue.PERIOD_MATERIAL,
                    u_EmissionColor: ue.PERIOD_MATERIAL,
                    u_AlbedoTexture: ue.PERIOD_MATERIAL,
                    u_NormalTexture: ue.PERIOD_MATERIAL,
                    u_ParallaxTexture: ue.PERIOD_MATERIAL,
                    u_OcclusionTexture: ue.PERIOD_MATERIAL,
                    u_EmissionTexture: ue.PERIOD_MATERIAL,
                    u_Smoothness: ue.PERIOD_MATERIAL,
                    u_SmoothnessScale: ue.PERIOD_MATERIAL,
                    u_occlusionStrength: ue.PERIOD_MATERIAL,
                    u_NormalScale: ue.PERIOD_MATERIAL,
                    u_ParallaxScale: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_MetallicGlossTexture: ue.PERIOD_MATERIAL,
                    u_Metallic: ue.PERIOD_MATERIAL,
                    u_ReflectTexture: ue.PERIOD_SCENE,
                    u_ReflectIntensity: ue.PERIOD_SCENE,
                    u_AmbientColor: ue.PERIOD_SCENE,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE,
                    u_DirationLightCount: ue.PERIOD_SCENE,
                    u_LightBuffer: ue.PERIOD_SCENE,
                    u_LightClusterBuffer: ue.PERIOD_SCENE,
                    u_ShadowBias: ue.PERIOD_SCENE,
                    u_ShadowLightDirection: ue.PERIOD_SCENE,
                    u_ShadowMap: ue.PERIOD_SCENE,
                    u_ShadowParams: ue.PERIOD_SCENE,
                    u_ShadowSplitSpheres: ue.PERIOD_SCENE,
                    u_ShadowMatrices: ue.PERIOD_SCENE,
                    u_ShadowMapSize: ue.PERIOD_SCENE,
                    u_SpotShadowMap: ue.PERIOD_SCENE,
                    u_SpotViewProjectMatrix: ue.PERIOD_SCENE,
                    u_ShadowLightPosition: ue.PERIOD_SCENE,
                    u_AmbientSHAr: ue.PERIOD_SCENE,
                    u_AmbientSHAg: ue.PERIOD_SCENE,
                    u_AmbientSHAb: ue.PERIOD_SCENE,
                    u_AmbientSHBr: ue.PERIOD_SCENE,
                    u_AmbientSHBg: ue.PERIOD_SCENE,
                    u_AmbientSHBb: ue.PERIOD_SCENE,
                    u_AmbientSHC: ue.PERIOD_SCENE,
                    u_ReflectionProbe: ue.PERIOD_SCENE,
                    u_ReflectCubeHDRParams: ue.PERIOD_SCENE,
                    "u_DirectionLight.direction": ue.PERIOD_SCENE,
                    "u_DirectionLight.color": ue.PERIOD_SCENE,
                    "u_PointLight.position": ue.PERIOD_SCENE,
                    "u_PointLight.range": ue.PERIOD_SCENE,
                    "u_PointLight.color": ue.PERIOD_SCENE,
                    "u_SpotLight.position": ue.PERIOD_SCENE,
                    "u_SpotLight.direction": ue.PERIOD_SCENE,
                    "u_SpotLight.range": ue.PERIOD_SCENE,
                    "u_SpotLight.spot": ue.PERIOD_SCENE,
                    "u_SpotLight.color": ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("PBR", e, t, !0), i = new an(e, t);
                r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRVSInput.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', n, "Forward"), 
                i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', n, "ShadowCaster");
            }
        } ]), PBRStandardMaterial;
    }();
    ln.METALLICGLOSSTEXTURE = ue.propertyNameToID("u_MetallicGlossTexture"), ln.METALLIC = ue.propertyNameToID("u_Metallic");
    var un = function(e) {
        function SkyBoxMaterial() {
            var e;
            return _classCallCheck(this, SkyBoxMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyBoxMaterial).call(this))).setShaderName("SkyBox"), 
            e.tintColor = new i(.5, .5, .5, .5), e.exposure = 1, e.rotation = 0, e;
        }
        return _inherits(SkyBoxMaterial, me), _createClass(SkyBoxMaterial, [ {
            key: "clone",
            value: function() {
                var e = new SkyBoxMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "tintColor",
            get: function() {
                return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, e);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, e);
            }
        }, {
            key: "textureCube",
            get: function() {
                return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
            },
            set: function(e) {
                this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {}
        } ]), SkyBoxMaterial;
    }();
    un.TINTCOLOR = ue.propertyNameToID("u_TintColor"), un.EXPOSURE = ue.propertyNameToID("u_Exposure"), 
    un.ROTATION = ue.propertyNameToID("u_Rotation"), un.TEXTURECUBE = ue.propertyNameToID("u_CubeTexture");
    var cn = function(e) {
        function SkyProceduralMaterial() {
            var e;
            return _classCallCheck(this, SkyProceduralMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyProceduralMaterial).call(this))).setShaderName("SkyBoxProcedural"), 
            e.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY, e.sunSize = .04, e.sunSizeConvergence = 5, 
            e.atmosphereThickness = 1, e.skyTint = new i(.5, .5, .5, 1), e.groundTint = new i(.369, .349, .341, 1), 
            e.exposure = 1.3, e;
        }
        return _inherits(SkyProceduralMaterial, me), _createClass(SkyProceduralMaterial, [ {
            key: "clone",
            value: function() {
                var e = new SkyProceduralMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "sunDisk",
            get: function() {
                return this._sunDisk;
            },
            set: function(e) {
                switch (e) {
                  case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE), 
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    break;

                  case SkyProceduralMaterial.SUN_SIMPLE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), 
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;

                  case SkyProceduralMaterial.SUN_NODE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), 
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;

                  default:
                    throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = e;
            }
        }, {
            key: "sunSize",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, e);
            }
        }, {
            key: "sunSizeConvergence",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, e);
            }
        }, {
            key: "atmosphereThickness",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, e);
            }
        }, {
            key: "skyTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, e);
            }
        }, {
            key: "groundTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = ue.getDefineByName("SUN_HIGH_QUALITY"), 
                SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = ue.getDefineByName("SUN_SIMPLE");
            }
        } ]), SkyProceduralMaterial;
    }();
    cn.SUN_NODE = 0, cn.SUN_SIMPLE = 1, cn.SUN_HIGH_QUALITY = 2, cn.SUNSIZE = ue.propertyNameToID("u_SunSize"), 
    cn.SUNSIZECONVERGENCE = ue.propertyNameToID("u_SunSizeConvergence"), cn.ATMOSPHERETHICKNESS = ue.propertyNameToID("u_AtmosphereThickness"), 
    cn.SKYTINT = ue.propertyNameToID("u_SkyTint"), cn.GROUNDTINT = ue.propertyNameToID("u_GroundTint"), 
    cn.EXPOSURE = ue.propertyNameToID("u_Exposure");
    var hn = function(e) {
        function UnlitMaterial() {
            var e;
            return _classCallCheck(this, UnlitMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(UnlitMaterial).call(this)))._albedoColor = new i(1, 1, 1, 1), 
            e._albedoIntensity = 1, e._enableVertexColor = !1, e.setShaderName("Unlit"), e._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), 
            e.renderMode = UnlitMaterial.RENDERMODE_OPAQUE, e;
        }
        return _inherits(UnlitMaterial, me), _createClass(UnlitMaterial, [ {
            key: "clone",
            value: function() {
                var e = new UnlitMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE), 
                this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case UnlitMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = me.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  case UnlitMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = me.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_DISABLE, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  case UnlitMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_BACK, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS;
                    break;

                  default:
                    throw new Error("UnlitMaterial : renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = ue.getDefineByName("ALBEDOTEXTURE"), 
                UnlitMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET"), UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = ue.getDefineByName("ENABLEVERTEXCOLOR");
            }
        } ]), UnlitMaterial;
    }();
    hn.RENDERMODE_OPAQUE = 0, hn.RENDERMODE_CUTOUT = 1, hn.RENDERMODE_TRANSPARENT = 2, 
    hn.RENDERMODE_ADDTIVE = 3, hn.ALBEDOTEXTURE = ue.propertyNameToID("u_AlbedoTexture"), 
    hn.ALBEDOCOLOR = ue.propertyNameToID("u_AlbedoColor"), hn.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), 
    hn.CULL = ue.propertyNameToID("s_Cull"), hn.BLEND = ue.propertyNameToID("s_Blend"), 
    hn.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), hn.BLEND_DST = ue.propertyNameToID("s_BlendDst"), 
    hn.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), hn.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var _n = function(e) {
        function WaterPrimaryMaterial() {
            var e;
            return _classCallCheck(this, WaterPrimaryMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(WaterPrimaryMaterial).call(this))).setShaderName("WaterPrimary"), 
            e._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new i(.172, .463, .435, 0)), 
            e._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15), e._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new i(19, 9, -16, -7)), 
            e;
        }
        return _inherits(WaterPrimaryMaterial, me), _createClass(WaterPrimaryMaterial, [ {
            key: "clone",
            value: function() {
                var e = new WaterPrimaryMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "horizonColor",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, e);
            }
        }, {
            key: "mainTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE), 
                this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE), 
                this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "waveScale",
            get: function() {
                return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, e);
            }
        }, {
            key: "waveSpeed",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = ue.getDefineByName("MAINTEXTURE"), 
                WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = ue.getDefineByName("NORMALTEXTURE");
            }
        } ]), WaterPrimaryMaterial;
    }();
    _n.HORIZONCOLOR = ue.propertyNameToID("u_HorizonColor"), _n.MAINTEXTURE = ue.propertyNameToID("u_MainTexture"), 
    _n.NORMALTEXTURE = ue.propertyNameToID("u_NormalTexture"), _n.WAVESCALE = ue.propertyNameToID("u_WaveScale"), 
    _n.WAVESPEED = ue.propertyNameToID("u_WaveSpeed");
    var dn = function MeshSprite3DShaderDeclaration() {
        _classCallCheck(this, MeshSprite3DShaderDeclaration);
    }, fn = function(e) {
        function MeshRenderer(e) {
            var t;
            return _classCallCheck(this, MeshRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderer).call(this, e)))._revertStaticBatchDefineUV1 = !1, 
            t._projectionViewWorldMatrix = new c(), t;
        }
        return _inherits(MeshRenderer, Ut), _createClass(MeshRenderer, [ {
            key: "_createRenderElement",
            value: function() {
                return new wt();
            }
        }, {
            key: "_onMeshChange",
            value: function(e) {
                if (e) {
                    var t = e.subMeshCount;
                    this._renderElements.length = t;
                    for (var n = 0; n < t; n++) {
                        var r = this._renderElements[n];
                        if (!r) {
                            var i = this.sharedMaterials[n];
                            (r = this._renderElements[n] = this._createRenderElement()).setTransform(this._owner._transform), 
                            r.render = this, r.material = i || ge.defaultMaterial;
                        }
                        r.setGeometry(e.getSubMesh(n));
                    }
                } else this._renderElements.length = 0;
                this._boundsChange = !0;
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                var e = this._owner.meshFilter.sharedMesh;
                if (e) {
                    var n = this._owner.transform.worldMatrix;
                    e.bounds._tranform(n, this._bounds);
                }
                if (t.Render.supportWebGLPlusCulling) {
                    var r = this._bounds.getMin(), i = this._bounds.getMax(), a = Le._cullingBuffer;
                    a[this._cullingBufferIndex + 1] = r.x, a[this._cullingBufferIndex + 2] = r.y, a[this._cullingBufferIndex + 3] = r.z, 
                    a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
                }
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                this._applyLightMapParams();
                var n = e.renderElement;
                switch (n.renderType) {
                  case kt.RENDERTYPE_NORMAL:
                    this._shaderValues.setMatrix4x4(et.WORLDMATRIX, t.worldMatrix);
                    break;

                  case kt.RENDERTYPE_STATICBATCH:
                    t ? this._shaderValues.setMatrix4x4(et.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(et.WORLDMATRIX, c.DEFAULT), 
                    this._shaderValues.hasDefine(dn.SHADERDEFINE_UV1) ? this._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(dn.SHADERDEFINE_UV1), 
                    this._revertStaticBatchDefineUV1 = !0), this._shaderValues.setVector(Pt.LIGHTMAPSCALEOFFSET, Ut._defaultLightmapScaleOffset);
                    break;

                  case kt.RENDERTYPE_VERTEXBATCH:
                    this._shaderValues.setMatrix4x4(et.WORLDMATRIX, c.DEFAULT);
                    break;

                  case kt.RENDERTYPE_INSTANCEBATCH:
                    for (var r = bt.instance.instanceWorldMatrixData, i = n.instanceBatchElementList, a = i.elements, o = i.length, s = 0; s < o; s++) r.set(a[s]._transform.worldMatrix.elements, 16 * s);
                    var l = bt.instance.instanceWorldMatrixBuffer;
                    l.orphanStorage(), l.setData(r.buffer, 0, 0, 16 * o * 4), this._shaderValues.addDefine(dn.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var n = e.projectionViewMatrix;
                if (n) {
                    var r = e.renderElement;
                    switch (r.renderType) {
                      case kt.RENDERTYPE_NORMAL:
                      case kt.RENDERTYPE_STATICBATCH:
                      case kt.RENDERTYPE_VERTEXBATCH:
                        t ? (c.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(et.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(et.MVPMATRIX, n);
                        break;

                      case kt.RENDERTYPE_INSTANCEBATCH:
                        for (var i = bt.instance.instanceMVPMatrixData, a = r.instanceBatchElementList, o = a.elements, s = a.length, l = 0; l < s; l++) {
                            var u = o[l]._transform.worldMatrix;
                            O.mulMatrixByArray(n.elements, 0, u.elements, 0, i, 16 * l);
                        }
                        var h = bt.instance.instanceMVPMatrixBuffer;
                        h.orphanStorage(), h.setData(i.buffer, 0, 0, 16 * s * 4);
                    }
                }
            }
        }, {
            key: "_revertBatchRenderUpdate",
            value: function(e) {
                switch (e.renderElement.renderType) {
                  case kt.RENDERTYPE_STATICBATCH:
                    this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(dn.SHADERDEFINE_UV1), 
                    this._shaderValues.setVector(Pt.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                    break;

                  case kt.RENDERTYPE_INSTANCEBATCH:
                    this._shaderValues.removeDefine(dn.SHADERDEFINE_GPU_INSTANCE);
                }
            }
        }, {
            key: "_destroy",
            value: function() {
                this._isPartOfStaticBatch && Ft.instance._removeRenderSprite(this._owner), _get(_getPrototypeOf(MeshRenderer.prototype), "_destroy", this).call(this);
            }
        } ]), MeshRenderer;
    }(), mn = function() {
        function MeshFilter(e) {
            _classCallCheck(this, MeshFilter), this._owner = e;
        }
        return _createClass(MeshFilter, [ {
            key: "_getMeshDefine",
            value: function(e, t) {
                t.length = 0;
                for (var n = 0, r = e._subMeshes.length; n < r; n++) for (var i = e.getSubMesh(n)._vertexBuffer._vertexDeclaration._vertexElements, a = 0, o = i.length; a < o; a++) {
                    switch (i[a]._elementUsage) {
                      case Qe.MESH_COLOR0:
                        t.push(dn.SHADERDEFINE_COLOR);
                        break;

                      case Qe.MESH_TEXTURECOORDINATE0:
                        t.push(dn.SHADERDEFINE_UV0);
                        break;

                      case Qe.MESH_TEXTURECOORDINATE1:
                        t.push(dn.SHADERDEFINE_UV1);
                    }
                }
            }
        }, {
            key: "destroy",
            value: function() {
                this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
            }
        }, {
            key: "sharedMesh",
            get: function() {
                return this._sharedMesh;
            },
            set: function(e) {
                if (this._sharedMesh !== e) {
                    var t = this._owner._render._shaderValues, n = this._sharedMesh;
                    if (n) {
                        n._removeReference(), this._getMeshDefine(n, MeshFilter._meshVerticeDefine);
                        for (var r = 0, i = MeshFilter._meshVerticeDefine.length; r < i; r++) t.removeDefine(MeshFilter._meshVerticeDefine[r]);
                    }
                    if (e) {
                        e._addReference(), this._getMeshDefine(e, MeshFilter._meshVerticeDefine);
                        for (r = 0, i = MeshFilter._meshVerticeDefine.length; r < i; r++) t.addDefine(MeshFilter._meshVerticeDefine[r]);
                    }
                    this._owner._render._onMeshChange(e), this._sharedMesh = e;
                }
            }
        } ]), MeshFilter;
    }();
    mn._meshVerticeDefine = [];
    var Tn = function(n) {
        function SubMeshDynamicBatch() {
            var n;
            _classCallCheck(this, SubMeshDynamicBatch), (n = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshDynamicBatch).call(this)))._bufferState = new We();
            var r = t.LayaGL.instance, i = Qe.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * SubMeshDynamicBatch.maxIndicesCount;
            n._vertices = new Float32Array(i / 4), n._vertexBuffer = new qe(i, r.DYNAMIC_DRAW), 
            n._indices = new Int16Array(SubMeshDynamicBatch.maxIndicesCount), n._indexBuffer = new Xe(e.IndexFormat.UInt16, n._indices.length, r.DYNAMIC_DRAW);
            var a = n._vertexBuffer._byteLength + n._indexBuffer._byteLength;
            return t.Resource._addMemory(a, a), n;
        }
        return _inherits(SubMeshDynamicBatch, Lt), _createClass(SubMeshDynamicBatch, [ {
            key: "_getBatchVertices",
            value: function(e, t, n, r, i, a) {
                var o = e.vertexStride / 4, s = a._vertexBuffer.getFloat32Data(), l = (i.render.lightmapScaleOffset, 
                i._dynamicMultiSubMesh), u = i._dynamicVertexCount;
                i._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, u);
                for (var c = i._dynamicWorldPositions, h = i._dynamicWorldNormals, _ = a._indices, d = 0; d < u; d++) {
                    var f = (l ? _[d] : d) * o, m = (d + n) * o, T = 3 * d, p = m + this._positionOffset;
                    t[p] = c[T], t[p + 1] = c[T + 1], t[p + 2] = c[T + 2], -1 !== this._normalOffset && (t[p = m + this._normalOffset] = h[T], 
                    t[p + 1] = h[T + 1], t[p + 2] = h[T + 2]), -1 !== this._colorOffset && (p = m + this._colorOffset, 
                    T = f + this._colorOffset, t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2], 
                    t[p + 3] = s[T + 3]), -1 !== this._uv0Offset && (p = m + this._uv0Offset, T = f + this._uv0Offset, 
                    t[p] = s[T], t[p + 1] = s[T + 1]), -1 !== this._sTangentOffset && (p = m + this._sTangentOffset, 
                    T = f + this._sTangentOffset, t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2], 
                    t[p + 3] = s[T + 3], p = m + this._sTangentOffset, T = f + this._sTangentOffset, 
                    t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2], t[p + 3] = s[T + 3]);
                }
            }
        }, {
            key: "_getBatchIndices",
            value: function(e, t, n, r, i, a) {
                var o, s, l, u = i._indices, c = r._isFrontFaceInvert;
                if (a) if (c) for (o = 0, s = u.length; o < s; o += 3) {
                    var h = n + o;
                    e[l = t + o] = h, e[l + 1] = h + 2, e[l + 2] = h + 1;
                } else for (o = 0, s = u.length; o < s; o += 3) h = n + o, e[l = t + o] = h, e[l + 1] = h + 1, 
                e[l + 2] = h + 2; else if (c) for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = n + u[o], 
                e[l + 1] = n + u[o + 2], e[l + 2] = n + u[o + 1]; else for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = n + u[o], 
                e[l + 1] = n + u[o + 1], e[l + 2] = n + u[o + 2];
            }
        }, {
            key: "_flush",
            value: function(e, n) {
                var r = t.LayaGL.instance;
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState.vertexDeclaration.vertexStride), 
                this._indexBuffer.setData(this._indices, 0, 0, n), r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 0);
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                var t = e.renderElement.vertexBatchVertexDeclaration;
                this._bufferState = l.MeshRenderDynamicBatchManager.instance._getBufferState(t), 
                this._positionOffset = t.getVertexElementByUsage(Qe.MESH_POSITION0)._offset / 4;
                var n = t.getVertexElementByUsage(Qe.MESH_NORMAL0);
                this._normalOffset = n ? n._offset / 4 : -1;
                var r = t.getVertexElementByUsage(Qe.MESH_COLOR0);
                this._colorOffset = r ? r._offset / 4 : -1;
                var i = t.getVertexElementByUsage(Qe.MESH_TEXTURECOORDINATE0);
                this._uv0Offset = i ? i._offset / 4 : -1;
                var a = t.getVertexElementByUsage(Qe.MESH_TEXTURECOORDINATE1);
                this._uv1Offset = a ? a._offset / 4 : -1;
                var o = t.getVertexElementByUsage(Qe.MESH_TANGENT0);
                return this._sTangentOffset = o ? o._offset / 4 : -1, !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                for (var n = e.renderElement, r = n.vertexBatchVertexDeclaration, i = n.vertexBatchElementList, a = 0, o = 0, s = (r.vertexStride, 
                0), l = i.length, u = i.elements, c = 0; c < l; c++) {
                    var h = u[c], _ = h._geometry, d = _._indexCount;
                    o + d > SubMeshDynamicBatch.maxIndicesCount && (this._flush(a, o), s++, t.Stat.trianglesFaces += o / 3, 
                    a = o = 0);
                    var f = h._transform;
                    this._getBatchVertices(r, this._vertices, a, f, h, _), this._getBatchIndices(this._indices, o, a, f, _, h._dynamicMultiSubMesh), 
                    a += h._dynamicVertexCount, o += d;
                }
                this._flush(a, o), s++, t.Stat.renderBatches += s, t.Stat.savedRenderBatches += l - s, 
                t.Stat.trianglesFaces += o / 3;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                SubMeshDynamicBatch.instance = new SubMeshDynamicBatch();
            }
        } ]), SubMeshDynamicBatch;
    }();
    Tn.maxAllowVertexCount = 10, Tn.maxAllowAttribueCount = 900, Tn.maxIndicesCount = 32e3;
    var pn = function(e) {
        function MeshRenderDynamicBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderDynamicBatchManager), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderDynamicBatchManager).call(this)))._instanceBatchOpaqueMarks = [], 
            e._vertexBatchOpaqueMarks = [], e._cacheBufferStates = [], e._updateCountMark = 0, 
            e;
        }
        return _inherits(MeshRenderDynamicBatchManager, en), _createClass(MeshRenderDynamicBatchManager, [ {
            key: "getInstanceBatchOpaquaMark",
            value: function(e, t, n, r) {
                var i = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = []), a = i[t] || (i[t] = []), o = a[n] || (a[n] = []);
                return o[r ? 1 : 0] || (o[r ? 1 : 0] = new Nt());
            }
        }, {
            key: "getVertexBatchOpaquaMark",
            value: function(e, t, n, r) {
                var i = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []), a = i[t ? 0 : 1] || (i[t ? 0 : 1] = []), o = a[n] || (a[n] = []);
                return o[r] || (o[r] = new Nt());
            }
        }, {
            key: "_getBufferState",
            value: function(e) {
                var t = this._cacheBufferStates[e.id];
                if (!t) {
                    var n = Tn.instance;
                    (t = new We()).bind();
                    var r = n._vertexBuffer;
                    r.vertexDeclaration = e, t.applyVertexBuffer(r), t.applyIndexBuffer(n._indexBuffer), 
                    t.unBind(), this._cacheBufferStates[e.id] = t;
                }
                return t;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new wt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
                e.vertexBatchElementList = new C(), e.instanceBatchElementList = new C()), e;
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderDynamicBatchManager.prototype), "_clear", this).call(this), 
                this._updateCountMark++;
            }
        } ]), MeshRenderDynamicBatchManager;
    }();
    pn.instance = new pn();
    var gn = function(e) {
        function MeshSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, MeshSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshSprite3D).call(this, n)))._meshFilter = new mn(_assertThisInitialized(e)), 
            e._render = new fn(_assertThisInitialized(e)), t && (e._meshFilter.sharedMesh = t), 
            e;
        }
        return _inherits(MeshSprite3D, Pt), _createClass(MeshSprite3D, [ {
            key: "_parse",
            value: function(e, n) {
                _get(_getPrototypeOf(MeshSprite3D.prototype), "_parse", this).call(this, e, n);
                var r = this.meshRenderer, a = e.lightmapIndex;
                null != a && (r.lightmapIndex = a);
                var o = e.lightmapScaleOffset;
                o && (r.lightmapScaleOffset = new i(o[0], o[1], o[2], o[3])), null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)), 
                null != e.enableRender && (r.enable = e.enableRender), null != e.receiveShadows && (r.receiveShadow = e.receiveShadows), 
                null != e.castShadow && (r.castShadow = e.castShadow);
                var s = e.materials;
                if (s) {
                    var l = r.sharedMaterials, u = s.length;
                    l.length = u;
                    for (var c = 0; c < u; c++) l[c] = t.Loader.getRes(s[c].path);
                    r.sharedMaterials = l;
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function() {
                this.meshFilter.sharedMesh && Ft.instance._addBatchSprite(this);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, n) {
                var r = e;
                r._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                var i = this._render, a = r._render;
                a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i.castShadow;
                var o = i.lightmapScaleOffset;
                o && (a.lightmapScaleOffset = o.clone()), a.lightmapIndex = i.lightmapIndex, a.receiveShadow = i.receiveShadow, 
                a.sortingFudge = i.sortingFudge, _get(_getPrototypeOf(MeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, n);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(MeshSprite3D.prototype), "destroy", this).call(this, e), 
                this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function() {
                return new MeshSprite3D();
            }
        }, {
            key: "meshFilter",
            get: function() {
                return this._meshFilter;
            }
        }, {
            key: "meshRenderer",
            get: function() {
                return this._render;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                dn.SHADERDEFINE_UV0 = ue.getDefineByName("UV"), dn.SHADERDEFINE_COLOR = ue.getDefineByName("COLOR"), 
                dn.SHADERDEFINE_UV1 = ue.getDefineByName("UV1"), dn.SHADERDEFINE_GPU_INSTANCE = ue.getDefineByName("GPU_INSTANCE"), 
                Bt._registerManager(Ft.instance), en._registerManager(pn.instance);
            }
        } ]), MeshSprite3D;
    }(), En = function GradientMode() {
        _classCallCheck(this, GradientMode);
    };
    En.Blend = 0, En.Fixed = 1;
    var yn = function() {
        function Gradient(e, t) {
            _classCallCheck(this, Gradient), this._mode = 0, this._maxColorRGBKeysCount = 0, 
            this._maxColorAlphaKeysCount = 0, this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, 
            this._alphaElements = null, this._rgbElements = null, this._maxColorRGBKeysCount = e, 
            this._maxColorAlphaKeysCount = t, this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
        }
        return _createClass(Gradient, [ {
            key: "addColorRGB",
            value: function(e, t) {
                if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                    var n = 4 * this._colorRGBKeysCount;
                    this._rgbElements[n] = e, this._rgbElements[n + 1] = t.r, this._rgbElements[n + 2] = t.g, 
                    this._rgbElements[n + 3] = t.b, this._colorRGBKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
            }
        }, {
            key: "addColorAlpha",
            value: function(e, t) {
                if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                    var n = 2 * this._colorAlphaKeysCount;
                    this._alphaElements[n] = e, this._alphaElements[n + 1] = t, this._colorAlphaKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
            }
        }, {
            key: "updateColorRGB",
            value: function(e, t, n) {
                if (e < this._colorRGBKeysCount) {
                    var r = 4 * e;
                    this._rgbElements[r] = t, this._rgbElements[r + 1] = n.r, this._rgbElements[r + 2] = n.g, 
                    this._rgbElements[r + 3] = n.b;
                } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }, {
            key: "updateColorAlpha",
            value: function(e, t, n) {
                if (e < this._colorAlphaKeysCount) {
                    var r = 2 * e;
                    this._alphaElements[r] = t, this._alphaElements[r + 1] = n;
                } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }, {
            key: "evaluateColorRGB",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                e = Math.min(Math.max(e, 0), 1);
                var i = this._rgbElements, a = n;
                if (r) for (var o = a; o >= 0; o--) {
                    var s = 4 * o;
                    if (e === (d = i[s])) return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], a;
                    switch (this._mode) {
                      case En.Blend:
                        if (e > d) {
                            if (e > (_ = i[s + 4])) throw "Gradient:wrong startSearchIndex.";
                            var l = _ - d, u = _ - e, c = e - d;
                            return t.r = (u * i[s + 1] + c * i[s + 5]) / l, t.g = (u * i[s + 2] + c * i[s + 6]) / l, 
                            t.b = (u * i[s + 3] + c * i[s + 7]) / l, a;
                        }
                        a--;
                        continue;

                      case En.Fixed:
                        if (e > d) {
                            if (e > i[s + 4]) throw "Gradient:wrong startSearchIndex.";
                            return t.r = i[s + 5], t.g = i[s + 6], t.b = i[s + 7], a;
                        }
                        a--;
                        continue;

                      default:
                        throw "Gradient:unknown mode.";
                    }
                } else {
                    o = 0;
                    for (var h = this._rgbElements.length; o < h; o++) {
                        var _;
                        if (e === (_ = i[s = 4 * o])) return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], 
                        a;
                        switch (this._mode) {
                          case En.Blend:
                            if (e < _) {
                                var d;
                                if (e < (d = i[s - 4])) throw "Gradient:wrong startSearchIndex.";
                                l = _ - d, u = _ - e, c = e - d;
                                return t.r = (u * i[s - 3] + c * i[s + 1]) / l, t.g = (u * i[s - 2] + c * i[s + 2]) / l, 
                                t.b = (u * i[s - 1] + c * i[s + 3]) / l, a;
                            }
                            a++;
                            continue;

                          case En.Fixed:
                            if (e < _) {
                                if (e < i[s - 4]) throw "Gradient:wrong startSearchIndex.";
                                return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], a;
                            }
                            a++;
                            continue;

                          default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                }
                return a;
            }
        }, {
            key: "evaluateColorAlpha",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                e = Math.min(Math.max(e, 0), 1);
                var i = this._alphaElements, a = n;
                if (r) for (var o = a; o >= 0; o--) {
                    if (e === (d = i[h = 2 * o])) return t.a = i[h + 1], a;
                    switch (this._mode) {
                      case En.Blend:
                        if (e > d) {
                            if (e > (_ = i[h + 2])) throw "Gradient:wrong startSearchIndex.";
                            var s = _ - d, l = _ - e, u = e - d;
                            return t.a = (l * i[h + 1] + u * i[h + 3]) / s, a;
                        }
                        a--;
                        continue;

                      case En.Fixed:
                        if (e > d) {
                            if (e > i[h + 2]) throw "Gradient:wrong startSearchIndex.";
                            return t.a = i[h + 3], a;
                        }
                        a--;
                        continue;

                      default:
                        throw "Gradient:unknown mode.";
                    }
                } else {
                    o = a;
                    for (var c = this._alphaElements.length; o < c; o++) {
                        var h, _;
                        if (e === (_ = i[h = 2 * o])) return t.a = i[h + 1], a;
                        switch (this._mode) {
                          case En.Blend:
                            if (e < _) {
                                var d;
                                if (e < (d = i[h - 2])) throw "Gradient:wrong startSearchIndex.";
                                s = _ - d, l = _ - e, u = e - d;
                                return t.a = (l * i[h - 1] + u * i[h + 1]) / s, a;
                            }
                            a++;
                            continue;

                          case En.Fixed:
                            if (e < _) {
                                if (e < i[h - 2]) throw "Gradient:wrong startSearchIndex.";
                                return t.a = i[h + 1], a;
                            }
                            a++;
                            continue;

                          default:
                            throw "Gradient:unknown mode.";
                        }
                    }
                }
                return a;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, n, r = e;
                r._colorAlphaKeysCount = this._colorAlphaKeysCount;
                var i = r._alphaElements;
                for (t = 0, n = this._alphaElements.length; t < n; t++) i[t] = this._alphaElements[t];
                r._colorRGBKeysCount = this._colorRGBKeysCount;
                var a = r._rgbElements;
                for (t = 0, n = this._rgbElements.length; t < n; t++) a[t] = this._rgbElements[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
                return this.cloneTo(e), e;
            }
        }, {
            key: "mode",
            get: function() {
                return this._mode;
            },
            set: function(e) {
                this._mode = e;
            }
        }, {
            key: "colorRGBKeysCount",
            get: function() {
                return this._colorRGBKeysCount;
            }
        }, {
            key: "colorAlphaKeysCount",
            get: function() {
                return this._colorAlphaKeysCount;
            }
        }, {
            key: "maxColorRGBKeysCount",
            get: function() {
                return this._maxColorRGBKeysCount;
            }
        }, {
            key: "maxColorAlphaKeysCount",
            get: function() {
                return this._maxColorAlphaKeysCount;
            }
        } ]), Gradient;
    }(), vn = function() {
        function Burst(e, t, n) {
            _classCallCheck(this, Burst), this._time = e, this._minCount = t, this._maxCount = n;
        }
        return _createClass(Burst, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Burst(this._time, this._minCount, this._maxCount);
                return this.cloneTo(e), e;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "minCount",
            get: function() {
                return this._minCount;
            }
        }, {
            key: "maxCount",
            get: function() {
                return this._maxCount;
            }
        } ]), Burst;
    }(), Sn = function() {
        function GradientColor() {
            _classCallCheck(this, GradientColor), this._type = 0, this._constant = null, this._constantMin = null, 
            this._constantMax = null, this._gradient = null, this._gradientMin = null, this._gradientMax = null;
        }
        return _createClass(GradientColor, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin), 
                this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient), 
                this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientColor();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        } ], [ {
            key: "createByConstant",
            value: function(e) {
                var t = new GradientColor();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByGradient",
            value: function(e) {
                var t = new GradientColor();
                return t._type = 1, t._gradient = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var n = new GradientColor();
                return n._type = 2, n._constantMin = e, n._constantMax = t, n;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var n = new GradientColor();
                return n._type = 3, n._gradientMin = e, n._gradientMax = t, n;
            }
        } ]), GradientColor;
    }(), Cn = function() {
        function ColorOverLifetime(e) {
            _classCallCheck(this, ColorOverLifetime), this._color = e;
        }
        return _createClass(ColorOverLifetime, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._color.cloneTo(t._color), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._color.type) {
                  case 0:
                    e = Sn.createByConstant(this._color.constant.clone());
                    break;

                  case 1:
                    e = Sn.createByGradient(this._color.gradient.clone());
                    break;

                  case 2:
                    e = Sn.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                    break;

                  case 3:
                    e = Sn.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                }
                var t = new ColorOverLifetime(e);
                return t.enable = this.enable, t;
            }
        }, {
            key: "color",
            get: function() {
                return this._color;
            }
        } ]), ColorOverLifetime;
    }(), Rn = function() {
        function FrameOverTime() {
            _classCallCheck(this, FrameOverTime), this._type = 0, this._constant = 0, this._overTime = null, 
            this._constantMin = 0, this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
        }
        return _createClass(FrameOverTime, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, t._constant = this._constant, this._overTime && this._overTime.cloneTo(t._overTime), 
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin), 
                this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new FrameOverTime();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "frameOverTimeData",
            get: function() {
                return this._overTime;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "frameOverTimeDataMin",
            get: function() {
                return this._overTimeMin;
            }
        }, {
            key: "frameOverTimeDataMax",
            get: function() {
                return this._overTimeMax;
            }
        } ], [ {
            key: "createByConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = new FrameOverTime();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByOverTime",
            value: function(e) {
                var t = new FrameOverTime();
                return t._type = 1, t._overTime = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = new FrameOverTime();
                return n._type = 2, n._constantMin = e, n._constantMax = t, n;
            }
        }, {
            key: "createByRandomTwoOverTime",
            value: function(e, t) {
                var n = new FrameOverTime();
                return n._type = 3, n._overTimeMin = e, n._overTimeMax = t, n;
            }
        } ]), FrameOverTime;
    }(), Dn = function() {
        function GradientAngularVelocity() {
            _classCallCheck(this, GradientAngularVelocity), this._type = 0, this._separateAxes = !1, 
            this._constant = 0, this._constantSeparate = null, this._gradient = null, this._gradientX = null, 
            this._gradientY = null, this._gradientZ = null, this._gradientW = null, this._constantMin = 0, 
            this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, 
            this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, 
            this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, 
            this._gradientZMax = null, this._gradientWMin = null, this._gradientWMax = null;
        }
        return _createClass(GradientAngularVelocity, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant, 
                this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient), 
                this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
                this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientAngularVelocity();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function() {
                return this._separateAxes;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantSeparate",
            get: function() {
                return this._constantSeparate;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "gradientW",
            get: function() {
                return this._gradientW;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        }, {
            key: "gradientWMin",
            get: function() {
                return this._gradientWMin;
            }
        }, {
            key: "gradientWMax",
            get: function() {
                return this._gradientWMax;
            }
        } ], [ {
            key: "createByConstant",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 0, t._separateAxes = !1, t._constant = e, t;
            }
        }, {
            key: "createByConstantSeparate",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
            }
        }, {
            key: "createByGradient",
            value: function(e) {
                var t = new GradientAngularVelocity();
                return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function(e, t, n) {
                var r = new GradientAngularVelocity();
                return r._type = 1, r._separateAxes = !0, r._gradientX = e, r._gradientY = t, r._gradientZ = n, 
                r;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var n = new GradientAngularVelocity();
                return n._type = 2, n._separateAxes = !1, n._constantMin = e, n._constantMax = t, 
                n;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function(e, t) {
                var n = new GradientAngularVelocity();
                return n._type = 2, n._separateAxes = !0, n._constantMinSeparate = e, n._constantMaxSeparate = t, 
                n;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var n = new GradientAngularVelocity();
                return n._type = 3, n._separateAxes = !1, n._gradientMin = e, n._gradientMax = t, 
                n;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function(e, t, n, r, i, a, o, s) {
                var l = new GradientAngularVelocity();
                return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t, 
                l._gradientYMin = n, l._gradientYMax = r, l._gradientZMin = i, l._gradientZMax = a, 
                l._gradientWMin = o, l._gradientWMax = s, l;
            }
        } ]), GradientAngularVelocity;
    }(), Mn = function() {
        function GradientDataInt() {
            _classCallCheck(this, GradientDataInt), this._currentLength = 0, this._elements = new Float32Array(8);
        }
        return _createClass(GradientDataInt, [ {
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")), 
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var n = t._elements, r = 0, i = this._elements.length; r < i; r++) n[r] = this._elements[r];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataInt();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 2;
            }
        } ]), GradientDataInt;
    }(), An = function() {
        function GradientDataNumber() {
            _classCallCheck(this, GradientDataNumber), this._currentLength = 0, this._elements = new Float32Array(8);
        }
        return _createClass(GradientDataNumber, [ {
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")), 
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
            }
        }, {
            key: "getKeyByIndex",
            value: function(e) {
                return this._elements[2 * e];
            }
        }, {
            key: "getValueByIndex",
            value: function(e) {
                return this._elements[2 * e + 1];
            }
        }, {
            key: "getAverageValue",
            value: function() {
                for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                    this._elements[e + 1];
                    this._elements[e + 3], this._elements[e + 2] - this._elements[e];
                }
                return 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var n = t._elements, r = 0, i = this._elements.length; r < i; r++) n[r] = this._elements[r];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataNumber();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 2;
            }
        } ]), GradientDataNumber;
    }(), xn = function() {
        function GradientSize() {
            _classCallCheck(this, GradientSize), this._type = 0, this._separateAxes = !1, this._gradient = null, 
            this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = 0, 
            this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, 
            this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, 
            this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, 
            this._gradientZMax = null;
        }
        return _createClass(GradientSize, [ {
            key: "getMaxSizeInGradient",
            value: function() {
                var e, t, n = -Number.MAX_VALUE;
                switch (this._type) {
                  case 0:
                    if (this._separateAxes) {
                        for (e = 0, t = this._gradientX.gradientCount; e < t; e++) n = Math.max(n, this._gradientX.getValueByIndex(e));
                        for (e = 0, t = this._gradientY.gradientCount; e < t; e++) n = Math.max(n, this._gradientY.getValueByIndex(e));
                    } else for (e = 0, t = this._gradient.gradientCount; e < t; e++) n = Math.max(n, this._gradient.getValueByIndex(e));
                    break;

                  case 1:
                    this._separateAxes ? (n = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x), 
                    n = Math.max(n, this._constantMinSeparate.y), n = Math.max(n, this._constantMaxSeparate.y)) : n = Math.max(this._constantMin, this._constantMax);
                    break;

                  case 2:
                    if (this._separateAxes) {
                        for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientXMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientXMax.getValueByIndex(e));
                        for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientYMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientZMax.getValueByIndex(e));
                    } else {
                        for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientMax.getValueByIndex(e));
                    }
                }
                return n;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient), 
                this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
                this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientSize();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "separateAxes",
            get: function() {
                return this._separateAxes;
            }
        }, {
            key: "gradient",
            get: function() {
                return this._gradient;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "constantMinSeparate",
            get: function() {
                return this._constantMinSeparate;
            }
        }, {
            key: "constantMaxSeparate",
            get: function() {
                return this._constantMaxSeparate;
            }
        }, {
            key: "gradientMin",
            get: function() {
                return this._gradientMin;
            }
        }, {
            key: "gradientMax",
            get: function() {
                return this._gradientMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        } ], [ {
            key: "createByGradient",
            value: function(e) {
                var t = new GradientSize();
                return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
            }
        }, {
            key: "createByGradientSeparate",
            value: function(e, t, n) {
                var r = new GradientSize();
                return r._type = 0, r._separateAxes = !0, r._gradientX = e, r._gradientY = t, r._gradientZ = n, 
                r;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var n = new GradientSize();
                return n._type = 1, n._separateAxes = !1, n._constantMin = e, n._constantMax = t, 
                n;
            }
        }, {
            key: "createByRandomTwoConstantSeparate",
            value: function(e, t) {
                var n = new GradientSize();
                return n._type = 1, n._separateAxes = !0, n._constantMinSeparate = e, n._constantMaxSeparate = t, 
                n;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t) {
                var n = new GradientSize();
                return n._type = 2, n._separateAxes = !1, n._gradientMin = e, n._gradientMax = t, 
                n;
            }
        }, {
            key: "createByRandomTwoGradientSeparate",
            value: function(e, t, n, r, i, a) {
                var o = new GradientSize();
                return o._type = 2, o._separateAxes = !0, o._gradientXMin = e, o._gradientXMax = t, 
                o._gradientYMin = n, o._gradientYMax = r, o._gradientZMin = i, o._gradientZMax = a, 
                o;
            }
        } ]), GradientSize;
    }(), Ln = function() {
        function GradientVelocity() {
            _classCallCheck(this, GradientVelocity), this._type = 0, this._constant = null, 
            this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = null, 
            this._constantMax = null, this._gradientXMin = null, this._gradientXMax = null, 
            this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, 
            this._gradientZMax = null;
        }
        return _createClass(GradientVelocity, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX), 
                this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin), 
                this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin), 
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
                this._gradientZMax.cloneTo(t._gradientZMax);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientVelocity();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "gradientX",
            get: function() {
                return this._gradientX;
            }
        }, {
            key: "gradientY",
            get: function() {
                return this._gradientY;
            }
        }, {
            key: "gradientZ",
            get: function() {
                return this._gradientZ;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        }, {
            key: "gradientXMin",
            get: function() {
                return this._gradientXMin;
            }
        }, {
            key: "gradientXMax",
            get: function() {
                return this._gradientXMax;
            }
        }, {
            key: "gradientYMin",
            get: function() {
                return this._gradientYMin;
            }
        }, {
            key: "gradientYMax",
            get: function() {
                return this._gradientYMax;
            }
        }, {
            key: "gradientZMin",
            get: function() {
                return this._gradientZMin;
            }
        }, {
            key: "gradientZMax",
            get: function() {
                return this._gradientZMax;
            }
        } ], [ {
            key: "createByConstant",
            value: function(e) {
                var t = new GradientVelocity();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByGradient",
            value: function(e, t, n) {
                var r = new GradientVelocity();
                return r._type = 1, r._gradientX = e, r._gradientY = t, r._gradientZ = n, r;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function(e, t) {
                var n = new GradientVelocity();
                return n._type = 2, n._constantMin = e, n._constantMax = t, n;
            }
        }, {
            key: "createByRandomTwoGradient",
            value: function(e, t, n, r, i, a) {
                var o = new GradientVelocity();
                return o._type = 3, o._gradientXMin = e, o._gradientXMax = t, o._gradientYMin = n, 
                o._gradientYMax = r, o._gradientZMin = i, o._gradientZMax = a, o;
            }
        } ]), GradientVelocity;
    }(), In = function() {
        function RotationOverLifetime(e) {
            _classCallCheck(this, RotationOverLifetime), this._angularVelocity = e;
        }
        return _createClass(RotationOverLifetime, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._angularVelocity.cloneTo(t._angularVelocity), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._angularVelocity.type) {
                  case 0:
                    e = this._angularVelocity.separateAxes ? Dn.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : Dn.createByConstant(this._angularVelocity.constant);
                    break;

                  case 1:
                    e = this._angularVelocity.separateAxes ? Dn.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : Dn.createByGradient(this._angularVelocity.gradient.clone());
                    break;

                  case 2:
                    e = this._angularVelocity.separateAxes ? Dn.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : Dn.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                    break;

                  case 3:
                    e = this._angularVelocity.separateAxes ? Dn.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : Dn.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                }
                var t = new RotationOverLifetime(e);
                return t.enable = this.enable, t;
            }
        }, {
            key: "angularVelocity",
            get: function() {
                return this._angularVelocity;
            }
        } ]), RotationOverLifetime;
    }(), On = function() {
        function BaseShape() {
            _classCallCheck(this, BaseShape), this.enable = !0, this.randomDirection = 0;
        }
        return _createClass(BaseShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                throw new Error("BaseShape: must override it.");
            }
        }, {
            key: "_calculateProceduralBounds",
            value: function(e, t, n) {
                this._getShapeBoundBox(e);
                var r = e.min, i = e.max;
                o.multiply(r, t, r), o.multiply(i, t, i);
                var a = new At(new o(), new o());
                this.randomDirection ? (a.min = new o(-1, -1, -1), a.max = new o(1, 1, 1)) : this._getSpeedBoundBox(a);
                var s = new At(new o(), new o()), l = s.min, u = s.max;
                o.scale(a.min, n.y, l), o.scale(a.max, n.y, u), o.add(e.min, l, l), o.add(e.max, u, u), 
                o.min(e.min, l, e.min), o.max(e.max, l, e.max);
                var c = new At(new o(), new o()), h = c.min, _ = c.max;
                o.scale(a.min, n.x, h), o.scale(a.max, n.x, _), o.min(c.min, _, l), o.max(c.min, _, u), 
                o.min(e.min, l, e.min), o.max(e.max, l, e.max);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                e.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BaseShape();
                return this.cloneTo(e), e;
            }
        } ]), BaseShape;
    }(), Pn = function() {
        function ShapeUtils() {
            _classCallCheck(this, ShapeUtils);
        }
        return _createClass(ShapeUtils, null, [ {
            key: "_randomPointUnitArcCircle",
            value: function(e, t) {
                var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                n = r ? r.getFloat() * e : Math.random() * e, t.x = Math.cos(n), t.y = Math.sin(n);
            }
        }, {
            key: "_randomPointInsideUnitArcCircle",
            value: function(e, t) {
                var n, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                ShapeUtils._randomPointUnitArcCircle(e, t, r), n = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5), 
                t.x = t.x * n, t.y = t.y * n;
            }
        }, {
            key: "_randomPointUnitCircle",
            value: function(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t = n ? n.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(t), 
                e.y = Math.sin(t);
            }
        }, {
            key: "_randomPointInsideUnitCircle",
            value: function(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                ShapeUtils._randomPointUnitCircle(e), t = n ? Math.pow(n.getFloat(), .5) : Math.pow(Math.random(), .5), 
                e.x = e.x * t, e.y = e.y * t;
            }
        }, {
            key: "_randomPointUnitSphere",
            value: function(e) {
                var t, n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                r ? (t = e.z = 2 * r.getFloat() - 1, n = r.getFloat() * Math.PI * 2) : (t = e.z = 2 * Math.random() - 1, 
                n = Math.random() * Math.PI * 2);
                var i = Math.sqrt(1 - t * t);
                e.x = i * Math.cos(n), e.y = i * Math.sin(n);
            }
        }, {
            key: "_randomPointInsideUnitSphere",
            value: function(e) {
                var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                ShapeUtils._randomPointUnitSphere(e), t = n ? Math.pow(n.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3), 
                e.x = e.x * t, e.y = e.y * t, e.z = e.z * t;
            }
        }, {
            key: "_randomPointInsideHalfUnitBox",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5, 
                e.y = Math.random() - .5, e.z = Math.random() - .5);
            }
        } ]), ShapeUtils;
    }(), Nn = function(e) {
        function BoxShape() {
            var e;
            return _classCallCheck(this, BoxShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxShape).call(this))).x = 1, 
            e.y = 1, e.z = 1, e;
        }
        return _inherits(BoxShape, On), _createClass(BoxShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
                var n = e.max;
                n.x = .5 * this.x, n.y = .5 * this.y, n.z = .5 * this.z;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = 0, t.y = 0, t.z = 0;
                var n = e.max;
                n.x = 0, n.y = 1, n.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                n ? (n.seed = r[16], Pn._randomPointInsideHalfUnitBox(e, n), r[16] = n.seed) : Pn._randomPointInsideHalfUnitBox(e), 
                e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? n ? (n.seed = r[17], 
                Pn._randomPointUnitSphere(t, n), r[17] = n.seed) : Pn._randomPointUnitSphere(t) : (t.x = 0, 
                t.y = 0, t.z = 1);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(BoxShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoxShape();
                return this.cloneTo(e), e;
            }
        } ]), BoxShape;
    }(), bn = function(e) {
        function CircleShape() {
            var e;
            return _classCallCheck(this, CircleShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CircleShape).call(this))).radius = 1, 
            e.arc = 2 * Math.PI, e.emitFromEdge = !1, e;
        }
        return _inherits(CircleShape, On), _createClass(CircleShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.z = -this.radius, t.y = 0;
                var n = e.max;
                n.x = n.z = this.radius, n.y = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = -1, t.z = 0;
                var n = e.max;
                n.x = n.y = 1, n.z = 0;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = CircleShape._tempPositionPoint;
                n ? (n.seed = r[16], this.emitFromEdge ? Pn._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, n) : Pn._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, n), 
                r[16] = n.seed) : this.emitFromEdge ? Pn._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : Pn._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint), 
                e.x = -i.x, e.y = i.y, e.z = 0, o.scale(e, this.radius, e), this.randomDirection ? n ? (n.seed = r[17], 
                Pn._randomPointUnitSphere(t, n), r[17] = n.seed) : Pn._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(CircleShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new CircleShape();
                return this.cloneTo(e), e;
            }
        } ]), CircleShape;
    }();
    bn._tempPositionPoint = new r();
    var kn = function(e) {
        function ConeShape() {
            var e;
            return _classCallCheck(this, ConeShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeShape).call(this))).angle = 25 / 180 * Math.PI, 
            e.radius = 1, e.length = 5, e.emitType = 0, e;
        }
        return _inherits(ConeShape, On), _createClass(ConeShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = this.radius + this.length * Math.sin(this.angle), n = this.length * Math.cos(this.angle), r = e.min;
                r.x = r.y = -t, r.z = 0;
                var i = e.max;
                i.x = i.y = t, i.z = n;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = Math.sin(this.angle), n = e.min;
                n.x = n.y = -t, n.z = 0;
                var r = e.max;
                r.x = r.y = t, r.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var n, r, i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, l = ConeShape._tempPositionPoint, u = Math.cos(this.angle), c = Math.sin(this.angle);
                switch (this.emitType) {
                  case 0:
                    a ? (a.seed = s[16], Pn._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a), 
                    s[16] = a.seed) : Pn._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), 
                    n = l.x, r = l.y, e.x = n * this.radius, e.y = r * this.radius, e.z = 0, this.randomDirection ? (a ? (a.seed = s[17], 
                    Pn._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a), s[17] = a.seed) : Pn._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), 
                    i = ConeShape._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = n * c, 
                    t.y = r * c), t.z = u;
                    break;

                  case 1:
                    a ? (a.seed = s[16], Pn._randomPointUnitCircle(ConeShape._tempPositionPoint, a), 
                    s[16] = a.seed) : Pn._randomPointUnitCircle(ConeShape._tempPositionPoint), n = l.x, 
                    r = l.y, e.x = n * this.radius, e.y = r * this.radius, e.z = 0, this.randomDirection ? (a ? (a.seed = s[17], 
                    Pn._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a), s[17] = a.seed) : Pn._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), 
                    i = ConeShape._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = n * c, 
                    t.y = r * c), t.z = u;
                    break;

                  case 2:
                    a ? (a.seed = s[16], Pn._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a)) : Pn._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), 
                    n = l.x, r = l.y, e.x = n * this.radius, e.y = r * this.radius, e.z = 0, t.x = n * c, 
                    t.y = r * c, t.z = u, o.normalize(t, t), a ? (o.scale(t, this.length * a.getFloat(), t), 
                    s[16] = a.seed) : o.scale(t, this.length * Math.random(), t), o.add(e, t, e), this.randomDirection && (a ? (a.seed = s[17], 
                    Pn._randomPointUnitSphere(t, a), s[17] = a.seed) : Pn._randomPointUnitSphere(t));
                    break;

                  case 3:
                    a ? (a.seed = s[16], Pn._randomPointUnitCircle(ConeShape._tempPositionPoint, a)) : Pn._randomPointUnitCircle(ConeShape._tempPositionPoint), 
                    n = l.x, r = l.y, e.x = n * this.radius, e.y = r * this.radius, e.z = 0, t.x = n * c, 
                    t.y = r * c, t.z = u, o.normalize(t, t), a ? (o.scale(t, this.length * a.getFloat(), t), 
                    s[16] = a.seed) : o.scale(t, this.length * Math.random(), t), o.add(e, t, e), this.randomDirection && (a ? (a.seed = s[17], 
                    Pn._randomPointUnitSphere(t, a), s[17] = a.seed) : Pn._randomPointUnitSphere(t));
                    break;

                  default:
                    throw new Error("ConeShape:emitType is invalid.");
                }
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(ConeShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.angle = this.angle, t.radius = this.radius, t.length = this.length, t.emitType = this.emitType, 
                t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConeShape();
                return this.cloneTo(e), e;
            }
        } ]), ConeShape;
    }();
    kn._tempPositionPoint = new r(), kn._tempDirectionPoint = new r();
    var wn = function(e) {
        function HemisphereShape() {
            var e;
            return _classCallCheck(this, HemisphereShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(HemisphereShape).call(this))).radius = 1, 
            e.emitFromShell = !1, e;
        }
        return _inherits(HemisphereShape, On), _createClass(HemisphereShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var n = e.max;
                n.x = n.y = this.radius, n.z = 0;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = -1, t.z = 0;
                var n = e.max;
                n.x = n.y = n.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                n ? (n.seed = r[16], this.emitFromShell ? Pn._randomPointUnitSphere(e, n) : Pn._randomPointInsideUnitSphere(e, n), 
                r[16] = n.seed) : this.emitFromShell ? Pn._randomPointUnitSphere(e) : Pn._randomPointInsideUnitSphere(e), 
                o.scale(e, this.radius, e);
                var i = e.z;
                i < 0 && (e.z = -1 * i), this.randomDirection ? n ? (n.seed = r[17], Pn._randomPointUnitSphere(t, n), 
                r[17] = n.seed) : Pn._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(HemisphereShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new HemisphereShape();
                return this.cloneTo(e), e;
            }
        } ]), HemisphereShape;
    }(), Bn = function(e) {
        function SphereShape() {
            var e;
            return _classCallCheck(this, SphereShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereShape).call(this))).radius = 1, 
            e.emitFromShell = !1, e;
        }
        return _inherits(SphereShape, On), _createClass(SphereShape, [ {
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -this.radius;
                var n = e.max;
                n.x = n.y = n.z = this.radius;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = e.min;
                t.x = t.y = t.z = -1;
                var n = e.max;
                n.x = n.y = n.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                n ? (n.seed = r[16], this.emitFromShell ? Pn._randomPointUnitSphere(e, n) : Pn._randomPointInsideUnitSphere(e, n), 
                r[16] = n.seed) : this.emitFromShell ? Pn._randomPointUnitSphere(e) : Pn._randomPointInsideUnitSphere(e), 
                o.scale(e, this.radius, e), this.randomDirection ? n ? (n.seed = r[17], Pn._randomPointUnitSphere(t, n), 
                r[17] = n.seed) : Pn._randomPointUnitSphere(t) : e.cloneTo(t);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(SphereShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new SphereShape();
                return this.cloneTo(e), e;
            }
        } ]), SphereShape;
    }(), Vn = function() {
        function SizeOverLifetime(e) {
            _classCallCheck(this, SizeOverLifetime), this._size = e;
        }
        return _createClass(SizeOverLifetime, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._size.cloneTo(t._size), t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._size.type) {
                  case 0:
                    e = this._size.separateAxes ? xn.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : xn.createByGradient(this._size.gradient.clone());
                    break;

                  case 1:
                    e = this._size.separateAxes ? xn.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : xn.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                    break;

                  case 2:
                    e = this._size.separateAxes ? xn.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : xn.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                }
                var t = new SizeOverLifetime(e);
                return t.enable = this.enable, t;
            }
        }, {
            key: "size",
            get: function() {
                return this._size;
            }
        } ]), SizeOverLifetime;
    }(), Fn = function() {
        function StartFrame() {
            _classCallCheck(this, StartFrame), this._type = 0, this._constant = 0, this._constantMin = 0, 
            this._constantMax = 0;
        }
        return _createClass(StartFrame, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin, 
                t._constantMax = this._constantMax;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new StartFrame();
                return this.cloneTo(e), e;
            }
        }, {
            key: "type",
            get: function() {
                return this._type;
            }
        }, {
            key: "constant",
            get: function() {
                return this._constant;
            }
        }, {
            key: "constantMin",
            get: function() {
                return this._constantMin;
            }
        }, {
            key: "constantMax",
            get: function() {
                return this._constantMax;
            }
        } ], [ {
            key: "createByConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = new StartFrame();
                return t._type = 0, t._constant = e, t;
            }
        }, {
            key: "createByRandomTwoConstant",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = new StartFrame();
                return n._type = 1, n._constantMin = e, n._constantMax = t, n;
            }
        } ]), StartFrame;
    }(), Un = function() {
        function TextureSheetAnimation(e, t) {
            _classCallCheck(this, TextureSheetAnimation), this.type = 0, this.randomRow = !1, 
            this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, this.enable = !1, 
            this.tiles = new r(1, 1), this.type = 0, this.randomRow = !0, this.rowIndex = 0, 
            this.cycles = 1, this.enableUVChannels = 1, this._frame = e, this._startFrame = t;
        }
        return _createClass(TextureSheetAnimation, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t.rowIndex = this.rowIndex, 
                t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, t.enable = this.enable, 
                this._frame.cloneTo(t._frame), this._startFrame.cloneTo(t._startFrame);
            }
        }, {
            key: "clone",
            value: function() {
                var e, t;
                switch (this._frame.type) {
                  case 0:
                    e = Rn.createByConstant(this._frame.constant);
                    break;

                  case 1:
                    e = Rn.createByOverTime(this._frame.frameOverTimeData.clone());
                    break;

                  case 2:
                    e = Rn.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                    break;

                  case 3:
                    e = Rn.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                }
                switch (this._startFrame.type) {
                  case 0:
                    t = Fn.createByConstant(this._startFrame.constant);
                    break;

                  case 1:
                    t = Fn.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                }
                var n = new TextureSheetAnimation(e, t);
                return this.cloneTo(n), n;
            }
        }, {
            key: "frame",
            get: function() {
                return this._frame;
            }
        }, {
            key: "startFrame",
            get: function() {
                return this._startFrame;
            }
        } ]), TextureSheetAnimation;
    }(), Gn = function() {
        function VelocityOverLifetime(e) {
            _classCallCheck(this, VelocityOverLifetime), this.enable = !1, this.space = 0, this._velocity = e;
        }
        return _createClass(VelocityOverLifetime, [ {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this._velocity.cloneTo(t._velocity), t.enable = this.enable, t.space = this.space;
            }
        }, {
            key: "clone",
            value: function() {
                var e;
                switch (this._velocity.type) {
                  case 0:
                    e = Ln.createByConstant(this._velocity.constant.clone());
                    break;

                  case 1:
                    e = Ln.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                    break;

                  case 2:
                    e = Ln.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                    break;

                  case 3:
                    e = Ln.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                }
                var t = new VelocityOverLifetime(e);
                return t.enable = this.enable, t.space = this.space, t;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        } ]), VelocityOverLifetime;
    }(), Hn = function ShuriKenParticle3DShaderDeclaration() {
        _classCallCheck(this, ShuriKenParticle3DShaderDeclaration);
    };
    Hn.WORLDPOSITION = ue.propertyNameToID("u_WorldPosition"), Hn.WORLDROTATION = ue.propertyNameToID("u_WorldRotation"), 
    Hn.POSITIONSCALE = ue.propertyNameToID("u_PositionScale"), Hn.SIZESCALE = ue.propertyNameToID("u_SizeScale"), 
    Hn.SCALINGMODE = ue.propertyNameToID("u_ScalingMode"), Hn.GRAVITY = ue.propertyNameToID("u_Gravity"), 
    Hn.THREEDSTARTROTATION = ue.propertyNameToID("u_ThreeDStartRotation"), Hn.STRETCHEDBILLBOARDLENGTHSCALE = ue.propertyNameToID("u_StretchedBillboardLengthScale"), 
    Hn.STRETCHEDBILLBOARDSPEEDSCALE = ue.propertyNameToID("u_StretchedBillboardSpeedScale"), 
    Hn.SIMULATIONSPACE = ue.propertyNameToID("u_SimulationSpace"), Hn.CURRENTTIME = ue.propertyNameToID("u_CurrentTime"), 
    Hn.VOLVELOCITYCONST = ue.propertyNameToID("u_VOLVelocityConst"), Hn.VOLVELOCITYGRADIENTX = ue.propertyNameToID("u_VOLVelocityGradientX"), 
    Hn.VOLVELOCITYGRADIENTY = ue.propertyNameToID("u_VOLVelocityGradientY"), Hn.VOLVELOCITYGRADIENTZ = ue.propertyNameToID("u_VOLVelocityGradientZ"), 
    Hn.VOLVELOCITYCONSTMAX = ue.propertyNameToID("u_VOLVelocityConstMax"), Hn.VOLVELOCITYGRADIENTXMAX = ue.propertyNameToID("u_VOLVelocityGradientMaxX"), 
    Hn.VOLVELOCITYGRADIENTYMAX = ue.propertyNameToID("u_VOLVelocityGradientMaxY"), Hn.VOLVELOCITYGRADIENTZMAX = ue.propertyNameToID("u_VOLVelocityGradientMaxZ"), 
    Hn.VOLSPACETYPE = ue.propertyNameToID("u_VOLSpaceType"), Hn.COLOROVERLIFEGRADIENTALPHAS = ue.propertyNameToID("u_ColorOverLifeGradientAlphas"), 
    Hn.COLOROVERLIFEGRADIENTCOLORS = ue.propertyNameToID("u_ColorOverLifeGradientColors"), 
    Hn.MAXCOLOROVERLIFEGRADIENTALPHAS = ue.propertyNameToID("u_MaxColorOverLifeGradientAlphas"), 
    Hn.MAXCOLOROVERLIFEGRADIENTCOLORS = ue.propertyNameToID("u_MaxColorOverLifeGradientColors"), 
    Hn.SOLSIZEGRADIENT = ue.propertyNameToID("u_SOLSizeGradient"), Hn.SOLSIZEGRADIENTX = ue.propertyNameToID("u_SOLSizeGradientX"), 
    Hn.SOLSIZEGRADIENTY = ue.propertyNameToID("u_SOLSizeGradientY"), Hn.SOLSizeGradientZ = ue.propertyNameToID("u_SOLSizeGradientZ"), 
    Hn.SOLSizeGradientMax = ue.propertyNameToID("u_SOLSizeGradientMax"), Hn.SOLSIZEGRADIENTXMAX = ue.propertyNameToID("u_SOLSizeGradientMaxX"), 
    Hn.SOLSIZEGRADIENTYMAX = ue.propertyNameToID("u_SOLSizeGradientMaxY"), Hn.SOLSizeGradientZMAX = ue.propertyNameToID("u_SOLSizeGradientMaxZ"), 
    Hn.ROLANGULARVELOCITYCONST = ue.propertyNameToID("u_ROLAngularVelocityConst"), Hn.ROLANGULARVELOCITYCONSTSEPRARATE = ue.propertyNameToID("u_ROLAngularVelocityConstSeprarate"), 
    Hn.ROLANGULARVELOCITYGRADIENT = ue.propertyNameToID("u_ROLAngularVelocityGradient"), 
    Hn.ROLANGULARVELOCITYGRADIENTX = ue.propertyNameToID("u_ROLAngularVelocityGradientX"), 
    Hn.ROLANGULARVELOCITYGRADIENTY = ue.propertyNameToID("u_ROLAngularVelocityGradientY"), 
    Hn.ROLANGULARVELOCITYGRADIENTZ = ue.propertyNameToID("u_ROLAngularVelocityGradientZ"), 
    Hn.ROLANGULARVELOCITYCONSTMAX = ue.propertyNameToID("u_ROLAngularVelocityConstMax"), 
    Hn.ROLANGULARVELOCITYCONSTMAXSEPRARATE = ue.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"), 
    Hn.ROLANGULARVELOCITYGRADIENTMAX = ue.propertyNameToID("u_ROLAngularVelocityGradientMax"), 
    Hn.ROLANGULARVELOCITYGRADIENTXMAX = ue.propertyNameToID("u_ROLAngularVelocityGradientMaxX"), 
    Hn.ROLANGULARVELOCITYGRADIENTYMAX = ue.propertyNameToID("u_ROLAngularVelocityGradientMaxY"), 
    Hn.ROLANGULARVELOCITYGRADIENTZMAX = ue.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"), 
    Hn.ROLANGULARVELOCITYGRADIENTWMAX = ue.propertyNameToID("u_ROLAngularVelocityGradientMaxW"), 
    Hn.TEXTURESHEETANIMATIONCYCLES = ue.propertyNameToID("u_TSACycles"), Hn.TEXTURESHEETANIMATIONSUBUVLENGTH = ue.propertyNameToID("u_TSASubUVLength"), 
    Hn.TEXTURESHEETANIMATIONGRADIENTUVS = ue.propertyNameToID("u_TSAGradientUVs"), Hn.TEXTURESHEETANIMATIONGRADIENTMAXUVS = ue.propertyNameToID("u_TSAMaxGradientUVs");
    var zn = function(e) {
        function ShurikenParticleMaterial() {
            var e;
            return _classCallCheck(this, ShurikenParticleMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleMaterial).call(this))).setShaderName("PARTICLESHURIKEN"), 
            e._color = new i(1, 1, 1, 1), e.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED, 
            e;
        }
        return _inherits(ShurikenParticleMaterial, me), _createClass(ShurikenParticleMaterial, [ {
            key: "clone",
            value: function() {
                var e = new ShurikenParticleMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = pe.CULL_NONE, 
                    this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, this.blendDst = pe.BLENDPARAM_ONE, 
                    this.alphaTest = !1, this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = pe.CULL_NONE, 
                    this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, 
                    this.alphaTest = !1, this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  default:
                    throw new Error("ShurikenParticleMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR), 
                this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP), 
                this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, e);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = ue.getDefineByName("DIFFUSEMAP"), 
                ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = ue.getDefineByName("TINTCOLOR"), 
                ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = ue.getDefineByName("ADDTIVEFOG"), 
                ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET");
            }
        } ]), ShurikenParticleMaterial;
    }();
    zn.RENDERMODE_ALPHABLENDED = 0, zn.RENDERMODE_ADDTIVE = 1, zn.DIFFUSETEXTURE = ue.propertyNameToID("u_texture"), 
    zn.TINTCOLOR = ue.propertyNameToID("u_Tintcolor"), zn.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), 
    zn.CULL = ue.propertyNameToID("s_Cull"), zn.BLEND = ue.propertyNameToID("s_Blend"), 
    zn.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), zn.BLEND_DST = ue.propertyNameToID("s_BlendDst"), 
    zn.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), zn.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var Wn = function(e) {
        function ShurikenParticleRenderer(e) {
            var t;
            return _classCallCheck(this, ShurikenParticleRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleRenderer).call(this, e)))._finalGravity = new o(), 
            t._tempRotationMatrix = new c(), t._mesh = null, t.stretchedBillboardCameraSpeedScale = 0, 
            t.stretchedBillboardSpeedScale = 0, t.stretchedBillboardLengthScale = 2, t._defaultBoundBox = new At(new o(), new o()), 
            t.renderMode = 0, t._supportOctree = !1, t;
        }
        return _inherits(ShurikenParticleRenderer, Ut), _createClass(ShurikenParticleRenderer, [ {
            key: "_calculateBoundingBox",
            value: function() {
                if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE, 
                e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (n = this._bounds.getMax()).x = Number.MAX_VALUE, 
                n.y = Number.MAX_VALUE, n.z = Number.MAX_VALUE, this._bounds.setMax(n), t.Render.supportWebGLPlusCulling) {
                    var e = this._bounds.getMin(), n = this._bounds.getMax(), r = Le._cullingBuffer;
                    r[this._cullingBufferIndex + 1] = e.x, r[this._cullingBufferIndex + 2] = e.y, r[this._cullingBufferIndex + 3] = e.z, 
                    r[this._cullingBufferIndex + 4] = n.x, r[this._cullingBufferIndex + 5] = n.y, r[this._cullingBufferIndex + 6] = n.z;
                }
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                var n = this._owner.particleSystem, r = this._shaderValues, i = this._owner.transform;
                switch (n.simulationSpace) {
                  case 0:
                    break;

                  case 1:
                    r.setVector3(Hn.WORLDPOSITION, i.position), r.setQuaternion(Hn.WORLDROTATION, i.rotation);
                    break;

                  default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
                switch (n.scaleMode) {
                  case 0:
                    var a = i.getWorldLossyScale();
                    r.setVector3(Hn.POSITIONSCALE, a), r.setVector3(Hn.SIZESCALE, a);
                    break;

                  case 1:
                    var s = i.localScale;
                    r.setVector3(Hn.POSITIONSCALE, s), r.setVector3(Hn.SIZESCALE, s);
                    break;

                  case 2:
                    r.setVector3(Hn.POSITIONSCALE, i.getWorldLossyScale()), r.setVector3(Hn.SIZESCALE, o._ONE);
                }
                o.scale(m.gravity, n.gravityModifier, this._finalGravity), r.setVector3(Hn.GRAVITY, this._finalGravity), 
                r.setInt(Hn.SIMULATIONSPACE, n.simulationSpace), r.setBool(Hn.THREEDSTARTROTATION, n.threeDStartRotation), 
                r.setInt(Hn.SCALINGMODE, n.scaleMode), r.setNumber(Hn.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale), 
                r.setNumber(Hn.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale), 
                r.setNumber(Hn.CURRENTTIME, n._currentTime);
            }
        }, {
            key: "_destroy",
            value: function() {
                _get(_getPrototypeOf(ShurikenParticleRenderer.prototype), "_destroy", this).call(this), 
                this._mesh && (this._mesh._removeReference(), this._mesh = null);
            }
        }, {
            key: "renderMode",
            get: function() {
                return this._renderMode;
            },
            set: function(e) {
                if (this._renderMode !== e) {
                    var t = this._shaderValues;
                    switch (this._renderMode) {
                      case 0:
                        t.removeDefine(Hn.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;

                      case 1:
                        t.removeDefine(Hn.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;

                      case 2:
                        t.removeDefine(Hn.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;

                      case 3:
                        t.removeDefine(Hn.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;

                      case 4:
                        t.removeDefine(Hn.SHADERDEFINE_RENDERMODE_MESH);
                    }
                    switch (this._renderMode = e, e) {
                      case 0:
                        t.addDefine(Hn.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;

                      case 1:
                        t.addDefine(Hn.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;

                      case 2:
                        t.addDefine(Hn.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;

                      case 3:
                        t.addDefine(Hn.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;

                      case 4:
                        t.addDefine(Hn.SHADERDEFINE_RENDERMODE_MESH);
                        break;

                      default:
                        throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                    }
                    var n = this._owner.particleSystem;
                    n && n._initBufferDatas();
                }
            }
        }, {
            key: "mesh",
            get: function() {
                return this._mesh;
            },
            set: function(e) {
                this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e, 
                e && e._addReference(), this._owner.particleSystem._initBufferDatas());
            }
        }, {
            key: "bounds",
            get: function() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
                this._bounds;
            }
        } ]), ShurikenParticleRenderer;
    }(), Xn = function VertexShuriKenParticle() {
        _classCallCheck(this, VertexShuriKenParticle);
    };
    Xn.PARTICLE_CORNERTEXTURECOORDINATE0 = 5, Xn.PARTICLE_POSITION0 = 1, Xn.PARTICLE_COLOR0 = 2, 
    Xn.PARTICLE_TEXTURECOORDINATE0 = 3, Xn.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, 
    Xn.PARTICLE_DIRECTIONTIME = 0, Xn.PARTICLE_STARTCOLOR0 = 6, Xn.PARTICLE_ENDCOLOR0 = 7, 
    Xn.PARTICLE_STARTSIZE = 8, Xn.PARTICLE_STARTROTATION = 9, Xn.PARTICLE_STARTSPEED = 10, 
    Xn.PARTICLE_RANDOM0 = 11, Xn.PARTICLE_RANDOM1 = 12, Xn.PARTICLE_SIMULATIONWORLDPOSTION = 13, 
    Xn.PARTICLE_SIMULATIONWORLDROTATION = 14;
    var Yn = function(e) {
        function VertexShurikenParticleBillboard(e, t, n, r, i, a, o, s, l, u, c, h, _, d) {
            var f;
            return _classCallCheck(this, VertexShurikenParticleBillboard), (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleBillboard).call(this)))._cornerTextureCoordinate = e, 
            f._positionStartLifeTime = t, f._velocity = n, f._startColor = r, f._startSize = i, 
            f._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l, 
            f._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1, 
            f._simulationWorldPostion = d, f;
        }
        return _inherits(VertexShurikenParticleBillboard, Xn), _createClass(VertexShurikenParticleBillboard, [ {
            key: "cornerTextureCoordinate",
            get: function() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "positionStartLifeTime",
            get: function() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function() {
                return this._simulationWorldPostion;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                VertexShurikenParticleBillboard._vertexDeclaration = new je(152, [ new Ze(0, Ye.Vector4, Xn.PARTICLE_CORNERTEXTURECOORDINATE0), new Ze(16, Ye.Vector4, Xn.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new Ze(32, Ye.Vector4, Xn.PARTICLE_DIRECTIONTIME), new Ze(48, Ye.Vector4, Xn.PARTICLE_STARTCOLOR0), new Ze(64, Ye.Vector3, Xn.PARTICLE_STARTSIZE), new Ze(76, Ye.Vector3, Xn.PARTICLE_STARTROTATION), new Ze(88, Ye.Single, Xn.PARTICLE_STARTSPEED), new Ze(92, Ye.Vector4, Xn.PARTICLE_RANDOM0), new Ze(108, Ye.Vector4, Xn.PARTICLE_RANDOM1), new Ze(124, Ye.Vector3, Xn.PARTICLE_SIMULATIONWORLDPOSTION), new Ze(136, Ye.Vector4, Xn.PARTICLE_SIMULATIONWORLDROTATION) ]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexShurikenParticleBillboard._vertexDeclaration;
            }
        } ]), VertexShurikenParticleBillboard;
    }(), jn = function(e) {
        function VertexShurikenParticleMesh(e, t, n, r, i, a, o, s, l, u, c, h, _, d) {
            var f;
            return _classCallCheck(this, VertexShurikenParticleMesh), (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleMesh).call(this)))._cornerTextureCoordinate = e, 
            f._positionStartLifeTime = t, f._velocity = n, f._startColor = r, f._startSize = i, 
            f._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l, 
            f._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1, 
            f._simulationWorldPostion = d, f;
        }
        return _inherits(VertexShurikenParticleMesh, Xn), _createClass(VertexShurikenParticleMesh, [ {
            key: "cornerTextureCoordinate",
            get: function() {
                return this._cornerTextureCoordinate;
            }
        }, {
            key: "position",
            get: function() {
                return this._positionStartLifeTime;
            }
        }, {
            key: "velocity",
            get: function() {
                return this._velocity;
            }
        }, {
            key: "startColor",
            get: function() {
                return this._startColor;
            }
        }, {
            key: "startSize",
            get: function() {
                return this._startSize;
            }
        }, {
            key: "startRotation0",
            get: function() {
                return this._startRotation0;
            }
        }, {
            key: "startRotation1",
            get: function() {
                return this._startRotation1;
            }
        }, {
            key: "startRotation2",
            get: function() {
                return this._startRotation2;
            }
        }, {
            key: "startLifeTime",
            get: function() {
                return this._startLifeTime;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            }
        }, {
            key: "startSpeed",
            get: function() {
                return this._startSpeed;
            }
        }, {
            key: "random0",
            get: function() {
                return this._randoms0;
            }
        }, {
            key: "random1",
            get: function() {
                return this._randoms1;
            }
        }, {
            key: "simulationWorldPostion",
            get: function() {
                return this._simulationWorldPostion;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                VertexShurikenParticleMesh._vertexDeclaration = new je(172, [ new Ze(0, Ye.Vector3, Xn.PARTICLE_POSITION0), new Ze(12, Ye.Vector4, Xn.PARTICLE_COLOR0), new Ze(28, Ye.Vector2, Xn.PARTICLE_TEXTURECOORDINATE0), new Ze(36, Ye.Vector4, Xn.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new Ze(52, Ye.Vector4, Xn.PARTICLE_DIRECTIONTIME), new Ze(68, Ye.Vector4, Xn.PARTICLE_STARTCOLOR0), new Ze(84, Ye.Vector3, Xn.PARTICLE_STARTSIZE), new Ze(96, Ye.Vector3, Xn.PARTICLE_STARTROTATION), new Ze(108, Ye.Single, Xn.PARTICLE_STARTSPEED), new Ze(112, Ye.Vector4, Xn.PARTICLE_RANDOM0), new Ze(128, Ye.Vector4, Xn.PARTICLE_RANDOM1), new Ze(144, Ye.Vector3, Xn.PARTICLE_SIMULATIONWORLDPOSTION), new Ze(156, Ye.Vector4, Xn.PARTICLE_SIMULATIONWORLDROTATION) ]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexShurikenParticleMesh._vertexDeclaration;
            }
        } ]), VertexShurikenParticleMesh;
    }(), Zn = function() {
        function Rand(e) {
            _classCallCheck(this, Rand), this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), 
            this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        return _createClass(Rand, [ {
            key: "getUint",
            value: function() {
                return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1], 
                this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8, 
                this.seeds[3];
            }
        }, {
            key: "getFloat",
            value: function() {
                return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
            }
        }, {
            key: "getSignedFloat",
            value: function() {
                return 2 * this.getFloat() - 1;
            }
        }, {
            key: "seed",
            get: function() {
                return this.seeds[0];
            },
            set: function(e) {
                this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
                this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }
        } ], [ {
            key: "getFloatFromInt",
            value: function(e) {
                return 1 / 8388607 * (8388607 & e);
            }
        }, {
            key: "getByteFromInt",
            value: function(e) {
                return (8388607 & e) >>> 15;
            }
        } ]), Rand;
    }(), Qn = function() {
        function Emission() {
            _classCallCheck(this, Emission), this._emissionRate = 10, this._destroyed = !1, 
            this._bursts = [];
        }
        return _createClass(Emission, [ {
            key: "destroy",
            value: function() {
                this._bursts = null, this._destroyed = !0;
            }
        }, {
            key: "getBurstsCount",
            value: function() {
                return this._bursts.length;
            }
        }, {
            key: "getBurstByIndex",
            value: function(e) {
                return this._bursts[e];
            }
        }, {
            key: "addBurst",
            value: function(e) {
                var t = this._bursts.length;
                if (t > 0) for (var n = 0; n < t; n++) this._bursts[n].time > e.time && this._bursts.splice(n, 0, e);
                this._bursts.push(e);
            }
        }, {
            key: "removeBurst",
            value: function(e) {
                var t = this._bursts.indexOf(e);
                -1 !== t && this._bursts.splice(t, 1);
            }
        }, {
            key: "removeBurstByIndex",
            value: function(e) {
                this._bursts.splice(e, 1);
            }
        }, {
            key: "clearBurst",
            value: function() {
                this._bursts.length = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e, n = t._bursts;
                n.length = this._bursts.length;
                for (var r = 0, i = this._bursts.length; r < i; r++) {
                    var a = n[r];
                    a ? this._bursts[r].cloneTo(a) : n[r] = this._bursts[r].clone();
                }
                t._emissionRate = this._emissionRate, t.enable = this.enable;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Emission();
                return this.cloneTo(e), e;
            }
        }, {
            key: "emissionRate",
            set: function(e) {
                if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                this._emissionRate = e;
            },
            get: function() {
                return this._emissionRate;
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        } ]), Emission;
    }(), qn = function() {
        function ShurikenParticleData() {
            _classCallCheck(this, ShurikenParticleData);
        }
        return _createClass(ShurikenParticleData, null, [ {
            key: "_getStartLifetimeFromGradient",
            value: function(e, n) {
                for (var r = 1, i = e.gradientCount; r < i; r++) {
                    var a = e.getKeyByIndex(r);
                    if (a >= n) {
                        var o = e.getKeyByIndex(r - 1), s = (n - o) / (a - o);
                        return t.MathUtil.lerp(e.getValueByIndex(r - 1), e.getValueByIndex(r), s);
                    }
                }
                throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
            }
        }, {
            key: "_randomInvertRoationArray",
            value: function(e, t, n, r, i) {
                var a;
                r ? (r.seed = i[6], a = r.getFloat(), i[6] = r.seed) : a = Math.random(), a < n ? (t.x = -e.x, 
                t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
            }
        }, {
            key: "_randomInvertRoation",
            value: function(e, t, n, r) {
                var i;
                return n ? (n.seed = r[6], i = n.getFloat(), r[6] = n.seed) : i = Math.random(), 
                i < t && (e = -e), e;
            }
        }, {
            key: "create",
            value: function(e, n, r) {
                var a = e.autoRandomSeed, o = e._rand, s = e._randomSeeds;
                switch (e.startColorType) {
                  case 0:
                    var l = e.startColorConstant;
                    ShurikenParticleData.startColor.x = l.x, ShurikenParticleData.startColor.y = l.y, 
                    ShurikenParticleData.startColor.z = l.z, ShurikenParticleData.startColor.w = l.w;
                    break;

                  case 2:
                    a ? i.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), ShurikenParticleData.startColor) : (o.seed = s[3], 
                    i.lerp(e.startColorConstantMin, e.startColorConstantMax, o.getFloat(), ShurikenParticleData.startColor), 
                    s[3] = o.seed);
                }
                var u = e.colorOverLifetime;
                if (u && u.enable) {
                    var c = u.color;
                    switch (c.type) {
                      case 0:
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * c.constant.x, 
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * c.constant.y, 
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * c.constant.z, 
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * c.constant.w;
                        break;

                      case 2:
                        var h;
                        a ? h = Math.random() : (o.seed = s[10], h = o.getFloat(), s[10] = o.seed);
                        var _ = c.constantMin, d = c.constantMax;
                        ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * t.MathUtil.lerp(_.x, d.x, h), 
                        ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * t.MathUtil.lerp(_.y, d.y, h), 
                        ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * t.MathUtil.lerp(_.z, d.z, h), 
                        ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * t.MathUtil.lerp(_.w, d.w, h);
                    }
                }
                var f = ShurikenParticleData.startSize;
                switch (e.startSizeType) {
                  case 0:
                    if (e.threeDStartSize) {
                        var m = e.startSizeConstantSeparate;
                        f[0] = m.x, f[1] = m.y, f[2] = m.z;
                    } else f[0] = f[1] = f[2] = e.startSizeConstant;
                    break;

                  case 2:
                    if (e.threeDStartSize) {
                        var T = e.startSizeConstantMinSeparate, p = e.startSizeConstantMaxSeparate;
                        a ? (f[0] = t.MathUtil.lerp(T.x, p.x, Math.random()), f[1] = t.MathUtil.lerp(T.y, p.y, Math.random()), 
                        f[2] = t.MathUtil.lerp(T.z, p.z, Math.random())) : (o.seed = s[4], f[0] = t.MathUtil.lerp(T.x, p.x, o.getFloat()), 
                        f[1] = t.MathUtil.lerp(T.y, p.y, o.getFloat()), f[2] = t.MathUtil.lerp(T.z, p.z, o.getFloat()), 
                        s[4] = o.seed);
                    } else a ? f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (o.seed = s[4], 
                    f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, o.getFloat()), 
                    s[4] = o.seed);
                }
                var g = e.sizeOverLifetime;
                if (g && g.enable && 1 === g.size.type) {
                    var E, y = g.size;
                    if (y.separateAxes) a ? (f[0] = f[0] * t.MathUtil.lerp(y.constantMinSeparate.x, y.constantMaxSeparate.x, Math.random()), 
                    f[1] = f[1] * t.MathUtil.lerp(y.constantMinSeparate.y, y.constantMaxSeparate.y, Math.random()), 
                    f[2] = f[2] * t.MathUtil.lerp(y.constantMinSeparate.z, y.constantMaxSeparate.z, Math.random())) : (o.seed = s[11], 
                    f[0] = f[0] * t.MathUtil.lerp(y.constantMinSeparate.x, y.constantMaxSeparate.x, o.getFloat()), 
                    f[1] = f[1] * t.MathUtil.lerp(y.constantMinSeparate.y, y.constantMaxSeparate.y, o.getFloat()), 
                    f[2] = f[2] * t.MathUtil.lerp(y.constantMinSeparate.z, y.constantMaxSeparate.z, o.getFloat()), 
                    s[11] = o.seed); else a ? E = t.MathUtil.lerp(y.constantMin, y.constantMax, Math.random()) : (o.seed = s[11], 
                    E = t.MathUtil.lerp(y.constantMin, y.constantMax, o.getFloat()), s[11] = o.seed), 
                    f[0] = f[0] * E, f[1] = f[1] * E, f[2] = f[2] * E;
                }
                var v = n.renderMode;
                if (1 !== v) switch (e.startRotationType) {
                  case 0:
                    if (e.threeDStartRotation) {
                        var S = e.startRotationConstantSeparate, C = ShurikenParticleData._tempVector30;
                        ShurikenParticleData._randomInvertRoationArray(S, C, e.randomizeRotationDirection, a ? null : o, s), 
                        ShurikenParticleData.startRotation[0] = C.x, ShurikenParticleData.startRotation[1] = C.y, 
                        ShurikenParticleData.startRotation[2] = 4 !== v ? -C.z : C.z;
                    } else ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, a ? null : o, s), 
                    ShurikenParticleData.startRotation[1] = 0, ShurikenParticleData.startRotation[2] = 0;
                    break;

                  case 2:
                    if (e.threeDStartRotation) {
                        var R = e.startRotationConstantMinSeparate, D = e.startRotationConstantMaxSeparate, M = ShurikenParticleData._tempVector30;
                        a ? (M.x = t.MathUtil.lerp(R.x, D.x, Math.random()), M.y = t.MathUtil.lerp(R.y, D.y, Math.random()), 
                        M.z = t.MathUtil.lerp(R.z, D.z, Math.random())) : (o.seed = s[5], M.x = t.MathUtil.lerp(R.x, D.x, o.getFloat()), 
                        M.y = t.MathUtil.lerp(R.y, D.y, o.getFloat()), M.z = t.MathUtil.lerp(R.z, D.z, o.getFloat()), 
                        s[5] = o.seed), ShurikenParticleData._randomInvertRoationArray(M, M, e.randomizeRotationDirection, a ? null : o, s), 
                        ShurikenParticleData.startRotation[0] = M.x, ShurikenParticleData.startRotation[1] = M.y, 
                        ShurikenParticleData.startRotation[2] = 4 !== v ? -M.z : M.z;
                    } else a ? ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, a ? null : o, s) : (o.seed = s[5], 
                    ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, o.getFloat()), e.randomizeRotationDirection, a ? null : o, s), 
                    s[5] = o.seed);
                }
                switch (e.startLifetimeType) {
                  case 0:
                    ShurikenParticleData.startLifeTime = e.startLifetimeConstant;
                    break;

                  case 1:
                    ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                    break;

                  case 2:
                    a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (o.seed = s[7], 
                    ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, o.getFloat()), 
                    s[7] = o.seed);
                    break;

                  case 3:
                    var A = e.emissionTime;
                    a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, A), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, A), Math.random()) : (o.seed = s[7], 
                    ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, A), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, A), o.getFloat()), 
                    s[7] = o.seed);
                }
                var x = e.textureSheetAnimation;
                if (x && x.enable) {
                    var L, I = x.tiles, O = I.x, P = I.y, N = 1 / O, b = 1 / P, k = x.startFrame;
                    switch (k.type) {
                      case 0:
                        L = k.constant;
                        break;

                      case 1:
                        a ? L = t.MathUtil.lerp(k.constantMin, k.constantMax, Math.random()) : (o.seed = s[14], 
                        L = t.MathUtil.lerp(k.constantMin, k.constantMax, o.getFloat()), s[14] = o.seed);
                    }
                    var w = x.frame, B = x.cycles;
                    switch (w.type) {
                      case 0:
                        L += w.constant * B;
                        break;

                      case 2:
                        a ? L += t.MathUtil.lerp(w.constantMin, w.constantMax, Math.random()) * B : (o.seed = s[15], 
                        L += t.MathUtil.lerp(w.constantMin, w.constantMax, o.getFloat()) * B, s[15] = o.seed);
                    }
                    var V = 0;
                    switch (x.type) {
                      case 0:
                        V = Math.floor(L / O);
                        break;

                      case 1:
                        x.randomRow ? a ? V = Math.floor(Math.random() * P) : (o.seed = s[13], V = Math.floor(o.getFloat() * P), 
                        s[13] = o.seed) : V = x.rowIndex;
                    }
                    var F = Math.floor(L % O);
                    ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = N, 
                    ShurikenParticleData.startUVInfo[1] = b, ShurikenParticleData.startUVInfo[2] = F * N, 
                    ShurikenParticleData.startUVInfo[3] = V * b;
                } else ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = 1, 
                ShurikenParticleData.startUVInfo[1] = 1, ShurikenParticleData.startUVInfo[2] = 0, 
                ShurikenParticleData.startUVInfo[3] = 0;
            }
        } ]), ShurikenParticleData;
    }();
    qn._tempVector30 = new o(), qn.startColor = new i(), qn.startSize = new Float32Array(3), 
    qn.startRotation = new Float32Array(3), qn.startUVInfo = new Float32Array(4);
    var Kn = function(n) {
        function ShurikenParticleSystem(e) {
            var t;
            return _classCallCheck(this, ShurikenParticleSystem), (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleSystem).call(this)))._boundingSphere = null, 
            t._boundingBox = null, t._boundingBoxCorners = null, t._owner = null, t._ownerRender = null, 
            t._vertices = null, t._floatCountPerVertex = 0, t._startLifeTimeIndex = 0, t._timeIndex = 0, 
            t._simulateUpdate = !1, t._firstActiveElement = 0, t._firstNewElement = 0, t._firstFreeElement = 0, 
            t._firstRetiredElement = 0, t._drawCounter = 0, t._bufferMaxParticles = 0, t._emission = null, 
            t._shape = null, t._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t._playStartDelay = 0, 
            t._frameRateTime = 0, t._emissionTime = 0, t._totalDelayTime = 0, t._burstsIndex = 0, 
            t._velocityOverLifetime = null, t._colorOverLifetime = null, t._sizeOverLifetime = null, 
            t._rotationOverLifetime = null, t._textureSheetAnimation = null, t._startLifetimeType = 0, 
            t._startLifetimeConstant = 0, t._startLifeTimeGradient = null, t._startLifetimeConstantMin = 0, 
            t._startLifetimeConstantMax = 0, t._startLifeTimeGradientMin = null, t._startLifeTimeGradientMax = null, 
            t._maxStartLifetime = 0, t._uvLength = new r(), t._vertexStride = 0, t._indexStride = 0, 
            t._vertexBuffer = null, t._indexBuffer = null, t._bufferState = new We(), t._currentTime = 0, 
            t._startUpdateLoopCount = 0, t._rand = null, t._randomSeeds = null, t.duration = 0, 
            t.looping = !1, t.prewarm = !1, t.startDelayType = 0, t.startDelay = 0, t.startDelayMin = 0, 
            t.startDelayMax = 0, t.startSpeedType = 0, t.startSpeedConstant = 0, t.startSpeedConstantMin = 0, 
            t.startSpeedConstantMax = 0, t.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant = 0, 
            t.startSizeConstantSeparate = null, t.startSizeConstantMin = 0, t.startSizeConstantMax = 0, 
            t.startSizeConstantMinSeparate = null, t.startSizeConstantMaxSeparate = null, t.threeDStartRotation = !1, 
            t.startRotationType = 0, t.startRotationConstant = 0, t.startRotationConstantSeparate = null, 
            t.startRotationConstantMin = 0, t.startRotationConstantMax = 0, t.startRotationConstantMinSeparate = null, 
            t.startRotationConstantMaxSeparate = null, t.randomizeRotationDirection = 0, t.startColorType = 0, 
            t.startColorConstant = new i(1, 1, 1, 1), t.startColorConstantMin = new i(0, 0, 0, 0), 
            t.startColorConstantMax = new i(1, 1, 1, 1), t.gravityModifier = 0, t.simulationSpace = 0, 
            t.simulationSpeed = 1, t.scaleMode = 1, t.playOnAwake = !1, t.randomSeed = null, 
            t.autoRandomSeed = !1, t.isPerformanceMode = !1, t._firstActiveElement = 0, t._firstNewElement = 0, 
            t._firstFreeElement = 0, t._firstRetiredElement = 0, t._owner = e, t._ownerRender = e.particleRenderer, 
            t._boundingBoxCorners = [], t._boundingSphere = new Zt(new o(), Number.MAX_VALUE), 
            t._boundingBox = new At(new o(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new o(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)), 
            t._currentTime = 0, t._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t._burstsIndex = 0, 
            t._frameRateTime = 0, t._emissionTime = 0, t._totalDelayTime = 0, t._simulateUpdate = !1, 
            t._bufferMaxParticles = 1, t.duration = 5, t.looping = !0, t.prewarm = !1, t.startDelayType = 0, 
            t.startDelay = 0, t.startDelayMin = 0, t.startDelayMax = 0, t._startLifetimeType = 0, 
            t._startLifetimeConstant = 5, t._startLifeTimeGradient = new An(), t._startLifetimeConstantMin = 0, 
            t._startLifetimeConstantMax = 5, t._startLifeTimeGradientMin = new An(), t._startLifeTimeGradientMax = new An(), 
            t._maxStartLifetime = 5, t.startSpeedType = 0, t.startSpeedConstant = 5, t.startSpeedConstantMin = 0, 
            t.startSpeedConstantMax = 5, t.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant = 1, 
            t.startSizeConstantSeparate = new o(1, 1, 1), t.startSizeConstantMin = 0, t.startSizeConstantMax = 1, 
            t.startSizeConstantMinSeparate = new o(0, 0, 0), t.startSizeConstantMaxSeparate = new o(1, 1, 1), 
            t.threeDStartRotation = !1, t.startRotationType = 0, t.startRotationConstant = 0, 
            t.startRotationConstantSeparate = new o(0, 0, 0), t.startRotationConstantMin = 0, 
            t.startRotationConstantMax = 0, t.startRotationConstantMinSeparate = new o(0, 0, 0), 
            t.startRotationConstantMaxSeparate = new o(0, 0, 0), t.gravityModifier = 0, t.simulationSpace = 1, 
            t.scaleMode = 1, t.playOnAwake = !0, t._rand = new Zn(0), t.autoRandomSeed = !0, 
            t.randomSeed = new Uint32Array(1), t._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length), 
            t.isPerformanceMode = !0, t._emission = new Qn(), t._emission.enable = !0, t;
        }
        return _inherits(ShurikenParticleSystem, Lt), _createClass(ShurikenParticleSystem, [ {
            key: "_getVertexBuffer",
            value: function() {
                return 0 === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) ? this._vertexBuffer : null;
            }
        }, {
            key: "_getIndexBuffer",
            value: function() {
                return this._indexBuffer;
            }
        }, {
            key: "_generateBoundingSphere",
            value: function() {
                var e = this._boundingSphere.center;
                e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
            }
        }, {
            key: "_generateBoundingBox",
            value: function() {
                var e, t, n, r, i, a, s, l, u, c = this._owner.particleRenderer, h = this._boundingBox.min, _ = this._boundingBox.max;
                switch (this.startLifetimeType) {
                  case 0:
                    n = this.startLifetimeConstant;
                    break;

                  case 1:
                    n = -Number.MAX_VALUE;
                    var d = d;
                    for (e = 0, t = d.gradientCount; e < t; e++) n = Math.max(n, d.getValueByIndex(e));
                    break;

                  case 2:
                    n = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;

                  case 3:
                    n = -Number.MAX_VALUE;
                    var f = f;
                    for (e = 0, t = f.gradientCount; e < t; e++) n = Math.max(n, f.getValueByIndex(e));
                    var m = m;
                    for (e = 0, t = m.gradientCount; e < t; e++) n = Math.max(n, m.getValueByIndex(e));
                }
                switch (this.startSpeedType) {
                  case 0:
                    r = i = this.startSpeedConstant;
                    break;

                  case 1:
                    break;

                  case 2:
                    r = this.startLifetimeConstantMin, i = this.startLifetimeConstantMax;
                }
                this._shape && this._shape.enable || (a = s = o._ZERO, l = o._ZERO, u = o._UnitZ);
                var T, p, g = new o(l.x * r, l.y * r, l.z * r), E = new o(u.x * i, u.y * i, u.z * i);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
                    var y = this._velocityOverLifetime.velocity;
                    switch (y.type) {
                      case 0:
                        y.constant;
                        break;

                      case 1:
                        new o(y.gradientX.getAverageValue(), y.gradientY.getAverageValue(), y.gradientZ.getAverageValue());
                        break;

                      case 2:
                        y.constantMin, y.constantMax;
                        break;

                      case 3:
                        new o(y.gradientXMin.getAverageValue(), y.gradientYMin.getAverageValue(), y.gradientZMin.getAverageValue()), 
                        new o(y.gradientXMax.getAverageValue(), y.gradientYMax.getAverageValue(), y.gradientZMax.getAverageValue());
                    }
                }
                var v, S, C, R, D = this._owner.transform, M = D.position, A = ShurikenParticleSystem._tempVector39, x = c.renderMode;
                switch (this.scaleMode) {
                  case 0:
                    var L = D.getWorldLossyScale();
                    T = L, A.x = L.x, A.y = L.z, A.z = L.y, 1 === x && (p = L);
                    break;

                  case 1:
                    var I = D.localScale;
                    T = I, A.x = I.x, A.y = I.z, A.z = I.y, 1 === x && (p = I);
                    break;

                  case 2:
                    T = D.getWorldLossyScale(), A.x = A.y = A.z = 1, 1 === x && (p = o._ONE);
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (v = new o(g.x * n, g.y * n, g.z * n), 
                S = new o(E.x * n, E.y * n, E.z * n), 2 != this.scaleMode ? (o.add(a, v, h), o.multiply(T, h, h), 
                o.add(s, S, _), o.multiply(T, _, _)) : (o.multiply(T, a, h), o.add(h, v, h), o.multiply(T, s, _), 
                o.add(_, S, _))), this.simulationSpace) {
                  case 0:
                    break;

                  case 1:
                    o.add(h, M, h), o.add(_, M, _);
                }
                switch (this.startSizeType) {
                  case 0:
                    if (this.threeDStartSize) {
                        var O = O;
                        C = Math.max(O.x, O.y), 1 === x && (R = O.y);
                    } else C = this.startSizeConstant, 1 === x && (R = this.startSizeConstant);
                    break;

                  case 1:
                    break;

                  case 2:
                    if (this.threeDStartSize) {
                        var P = P;
                        C = Math.max(P.x, P.y), 1 === x && (R = P.y);
                    } else C = this.startSizeConstantMax, 1 === x && (R = this.startSizeConstantMax);
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
                    this._sizeOverLifetime.size;
                    C *= this._sizeOverLifetime.size.getMaxSizeInGradient();
                }
                var N, b, k = ShurikenParticleSystem._tempVector30;
                switch (x) {
                  case 0:
                    N = C * ShurikenParticleSystem.halfKSqrtOf2, o.scale(A, C, k), o.subtract(h, k, h), 
                    o.add(_, k, _);
                    break;

                  case 1:
                    var w = ShurikenParticleSystem._tempVector31, B = ShurikenParticleSystem._tempVector32, V = ShurikenParticleSystem._tempVector33, F = ShurikenParticleSystem._tempVector34;
                    this._velocityOverLifetime && this._velocityOverLifetime.enable || (o.multiply(p, E, B), 
                    o.multiply(p, g, V));
                    var U = R * c.stretchedBillboardLengthScale, G = o.scalarLength(B) * c.stretchedBillboardSpeedScale + U, H = o.scalarLength(V) * c.stretchedBillboardSpeedScale + U, z = ShurikenParticleSystem._tempVector35, W = ShurikenParticleSystem._tempVector36;
                    o.normalize(B, z), o.scale(z, G, F), o.subtract(S, F, F), o.normalize(V, W), o.scale(W, H, w), 
                    o.add(v, w, w), N = C * ShurikenParticleSystem.halfKSqrtOf2, o.scale(A, N, k);
                    var X = ShurikenParticleSystem._tempVector37, Y = ShurikenParticleSystem._tempVector38;
                    o.scale(z, .5, X), o.scale(W, .5, Y), o.multiply(X, A, X), o.multiply(Y, A, Y), 
                    o.add(h, Y, h), o.min(h, F, h), o.subtract(h, k, h), o.subtract(_, X, _), o.max(_, w, _), 
                    o.add(_, k, _);
                    break;

                  case 2:
                    b = .5 * (C *= Math.cos(.7853981633974483)), k.x = A.x * b, k.y = A.z * b, o.subtract(h, k, h), 
                    o.add(_, k, _);
                    break;

                  case 3:
                    b = .5 * (C *= Math.cos(.7853981633974483)), o.scale(A, b, k), o.subtract(h, k, h), 
                    o.add(_, k, _);
                }
                this._boundingBox.getCorners(this._boundingBoxCorners);
            }
        }, {
            key: "_updateEmission",
            value: function() {
                if (this.isAlive) if (this._simulateUpdate) this._simulateUpdate = !1; else {
                    var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                    e = Math.min(ShurikenParticleSystem._maxElapsedTime, e * this.simulationSpeed), 
                    this._updateParticles(e);
                }
            }
        }, {
            key: "_updateParticles",
            value: function(e) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e, 
                this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e, 
                this._totalDelayTime < this._playStartDelay || this._emission.enable && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
            }
        }, {
            key: "_updateParticlesSimulationRestart",
            value: function(e) {
                this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, 
                this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0, 
                this._totalDelayTime = 0, this._currentTime = e;
                var t = e;
                t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable && this._advanceTime(e, e);
            }
        }, {
            key: "_retireActiveParticles",
            value: function() {
                for (;this._firstActiveElement != this._firstNewElement; ) {
                    var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride, t = e + this._timeIndex;
                    if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                    this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
                }
            }
        }, {
            key: "_freeRetiredParticles",
            value: function() {
                for (;this._firstRetiredElement != this._firstActiveElement; ) {
                    var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && e < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
                }
            }
        }, {
            key: "_burst",
            value: function(e, n) {
                for (var r = 0, i = this._emission._bursts, a = i.length; this._burstsIndex < a; this._burstsIndex++) {
                    var o, s = i[this._burstsIndex], l = s.time;
                    if (!(e <= l && l < n)) break;
                    this.autoRandomSeed ? o = t.MathUtil.lerp(s.minCount, s.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0], 
                    o = t.MathUtil.lerp(s.minCount, s.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed), 
                    r += o;
                }
                return r;
            }
        }, {
            key: "_advanceTime",
            value: function(e, t) {
                var n, r = this._emissionTime;
                this._emissionTime += e;
                var i = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), n = 0; n < i; n++) this.emit(t);
                        return this._isPlaying = !1, void this.stop();
                    }
                    i += this._burst(r, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0, 
                    i += this._burst(0, this._emissionTime);
                } else i += this._burst(r, this._emissionTime);
                for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), n = 0; n < i; n++) this.emit(t);
                var a = this.emission.emissionRate;
                if (a > 0) {
                    var o = 1 / a;
                    for (this._frameRateTime += o, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime); ) this._frameRateTime += o;
                    this._frameRateTime = Math.floor(t / o) * o;
                }
            }
        }, {
            key: "_initBufferDatas",
            value: function() {
                if (this._vertexBuffer) {
                    this._vertexBuffer.destroy(), this._indexBuffer.destroy();
                    var n = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                    t.Resource._addMemory(-n, -n);
                }
                var r = t.LayaGL.instance, i = this._ownerRender, a = i.renderMode;
                if (-1 !== a && this.maxParticles > 0) {
                    var o, s, l, u, c, h, _, d = 0, f = (n = 0, i.mesh);
                    if (4 === a) {
                        if (f) {
                            _ = jn.vertexDeclaration, this._floatCountPerVertex = _.vertexStride / 4, this._startLifeTimeIndex = 12, 
                            this._timeIndex = 16, this._vertexStride = f._vertexCount;
                            var m = this._bufferMaxParticles * this._vertexStride, T = m % 65535;
                            if (Math.floor(m / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            d = _.vertexStride * T, this._vertexBuffer = new qe(d, r.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _, 
                            this._vertices = new Float32Array(this._floatCountPerVertex * T), this._indexStride = f._indexBuffer.indexCount;
                            var p = f._indexBuffer.getData(), g = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new Xe(e.IndexFormat.UInt16, g, r.STATIC_DRAW), o = new Uint16Array(g), 
                            n = d + 2 * g, c = 0, s = 0; s < this._bufferMaxParticles; s++) {
                                var E = s * this._vertexStride;
                                for (l = 0, u = p.length; l < u; l++) o[c++] = E + p[l];
                            }
                            this._indexBuffer.setData(o), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
                            this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                        }
                    } else {
                        for (_ = Yn.vertexDeclaration, this._floatCountPerVertex = _.vertexStride / 4, this._startLifeTimeIndex = 7, 
                        this._timeIndex = 11, this._vertexStride = 4, d = _.vertexStride * this._bufferMaxParticles * this._vertexStride, 
                        this._vertexBuffer = new qe(d, r.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _, 
                        this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride), 
                        s = 0; s < this._bufferMaxParticles; s++) h = s * this._floatCountPerVertex * this._vertexStride, 
                        this._vertices[h] = -.5, this._vertices[h + 1] = -.5, this._vertices[h + 2] = 0, 
                        this._vertices[h + 3] = 1, h += this._floatCountPerVertex, this._vertices[h] = .5, 
                        this._vertices[h + 1] = -.5, this._vertices[h + 2] = 1, this._vertices[h + 3] = 1, 
                        h += this._floatCountPerVertex, this._vertices[h] = .5, this._vertices[h + 1] = .5, 
                        this._vertices[h + 2] = 1, this._vertices[h + 3] = 0, h += this._floatCountPerVertex, 
                        this._vertices[h] = -.5, this._vertices[h + 1] = .5, this._vertices[h + 2] = 0, 
                        this._vertices[h + 3] = 0;
                        for (this._indexStride = 6, this._indexBuffer = new Xe(e.IndexFormat.UInt16, 6 * this._bufferMaxParticles, r.STATIC_DRAW), 
                        o = new Uint16Array(6 * this._bufferMaxParticles), s = 0; s < this._bufferMaxParticles; s++) {
                            c = 6 * s;
                            var y = s * this._vertexStride, v = y + 2;
                            o[c++] = y, o[c++] = v, o[c++] = y + 1, o[c++] = y, o[c++] = y + 3, o[c++] = v;
                        }
                        this._indexBuffer.setData(o), n = d + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(), 
                        this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), 
                        this._bufferState.unBind();
                    }
                    t.Resource._addMemory(n, n);
                }
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ShurikenParticleSystem.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer.destroy(), 
                this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null, 
                this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null, 
                this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null, 
                this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null, 
                this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null, 
                this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null, 
                this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null, 
                this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null, 
                this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
            }
        }, {
            key: "emit",
            value: function(e) {
                var t = ShurikenParticleSystem._tempPosition, n = ShurikenParticleSystem._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, n) : this._shape.generatePositionAndDirection(t, n, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0, 
                n.x = n.y = 0, n.z = 1), this.addParticle(t, n, e);
            }
        }, {
            key: "addParticle",
            value: function(e, n, r) {
                o.normalize(n, n);
                var i = this._firstFreeElement + 1;
                if (i >= this._bufferMaxParticles && (i = 0), i === this._firstRetiredElement) return !1;
                var a, s, l, u, c, h, _, d, f, m, T = this._owner.transform;
                if (qn.create(this, this._ownerRender, T), this._currentTime - r >= qn.startLifeTime) return !0;
                switch (0 == this.simulationSpace && (a = T.position, s = T.rotation), this.startSpeedType) {
                  case 0:
                    l = this.startSpeedConstant;
                    break;

                  case 2:
                    this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random()) : (this._rand.seed = this._randomSeeds[8], 
                    l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat()), 
                    this._randomSeeds[8] = this._rand.seed);
                }
                var p = this._velocityOverLifetime && this._velocityOverLifetime.enable;
                if (p) {
                    var g = this._velocityOverLifetime.velocity.type;
                    2 === g || 3 === g ? this.autoRandomSeed ? (u = Math.random(), c = Math.random(), 
                    h = Math.random()) : (this._rand.seed = this._randomSeeds[9], u = this._rand.getFloat(), 
                    c = this._rand.getFloat(), h = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : p = !1;
                } else p = !1;
                var E = this._colorOverLifetime && this._colorOverLifetime.enable;
                E ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? _ = Math.random() : (this._rand.seed = this._randomSeeds[10], 
                _ = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : E = !1 : E = !1;
                var y = this._sizeOverLifetime && this._sizeOverLifetime.enable;
                y ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? d = Math.random() : (this._rand.seed = this._randomSeeds[11], 
                d = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : y = !1 : y = !1;
                var v = this._rotationOverLifetime && this._rotationOverLifetime.enable;
                if (v) {
                    var S = this._rotationOverLifetime.angularVelocity.type;
                    2 === S || 3 === S ? this.autoRandomSeed ? f = Math.random() : (this._rand.seed = this._randomSeeds[12], 
                    f = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : v = !1;
                } else v = !1;
                var C = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                C ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? m = Math.random() : (this._rand.seed = this._randomSeeds[15], 
                m = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : C = !1 : C = !1;
                var R, D, M, A, x, L, I = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride, O = qn.startUVInfo[0], P = qn.startUVInfo[1], N = qn.startUVInfo[2], b = qn.startUVInfo[3], k = this._ownerRender;
                if (4 === k.renderMode) {
                    var w = k.mesh._vertexBuffer;
                    R = w.getFloat32Data();
                    var B = w.vertexDeclaration;
                    M = B.getVertexElementByUsage(Qe.MESH_POSITION0)._offset / 4;
                    var V = B.getVertexElementByUsage(Qe.MESH_COLOR0);
                    A = V ? V._offset / 4 : -1;
                    var F = B.getVertexElementByUsage(Qe.MESH_TEXTURECOORDINATE0);
                    x = F ? F._offset / 4 : -1, D = B.vertexStride / 4, L = 0;
                } else {
                    this._vertices[I + 2] = N, this._vertices[I + 3] = b + P;
                    var U = I + this._floatCountPerVertex;
                    this._vertices[U + 2] = N + O, this._vertices[U + 3] = b + P;
                    var G = U + this._floatCountPerVertex;
                    this._vertices[G + 2] = N + O, this._vertices[G + 3] = b;
                    var H = G + this._floatCountPerVertex;
                    this._vertices[H + 2] = N, this._vertices[H + 3] = b;
                }
                for (var z = I, W = I + this._floatCountPerVertex * this._vertexStride; z < W; z += this._floatCountPerVertex) {
                    var X;
                    if (4 === k.renderMode) {
                        X = z;
                        var Y = D * L++, j = Y + M;
                        this._vertices[X++] = R[j++], this._vertices[X++] = R[j++], this._vertices[X++] = R[j], 
                        -1 === A ? (this._vertices[X++] = 1, this._vertices[X++] = 1, this._vertices[X++] = 1, 
                        this._vertices[X++] = 1) : (j = Y + A, this._vertices[X++] = R[j++], this._vertices[X++] = R[j++], 
                        this._vertices[X++] = R[j++], this._vertices[X++] = R[j]), -1 === x ? (this._vertices[X++] = 0, 
                        this._vertices[X++] = 0) : (j = Y + x, this._vertices[X++] = N + R[j++] * O, this._vertices[X++] = b + R[j] * P);
                    } else X = z + 4;
                    switch (this._vertices[X++] = e.x, this._vertices[X++] = e.y, this._vertices[X++] = e.z, 
                    this._vertices[X++] = qn.startLifeTime, this._vertices[X++] = n.x, this._vertices[X++] = n.y, 
                    this._vertices[X++] = n.z, this._vertices[X++] = r, this._vertices[X++] = qn.startColor.x, 
                    this._vertices[X++] = qn.startColor.y, this._vertices[X++] = qn.startColor.z, this._vertices[X++] = qn.startColor.w, 
                    this._vertices[X++] = qn.startSize[0], this._vertices[X++] = qn.startSize[1], this._vertices[X++] = qn.startSize[2], 
                    this._vertices[X++] = qn.startRotation[0], this._vertices[X++] = qn.startRotation[1], 
                    this._vertices[X++] = qn.startRotation[2], this._vertices[X++] = l, E && (this._vertices[X + 1] = _), 
                    y && (this._vertices[X + 2] = d), v && (this._vertices[X + 3] = f), C && (this._vertices[X + 4] = m), 
                    p && (this._vertices[X + 5] = u, this._vertices[X + 6] = c, this._vertices[X + 7] = h), 
                    this.simulationSpace) {
                      case 0:
                        X += 8, this._vertices[X++] = a.x, this._vertices[X++] = a.y, this._vertices[X++] = a.z, 
                        this._vertices[X++] = s.x, this._vertices[X++] = s.y, this._vertices[X++] = s.z, 
                        this._vertices[X++] = s.w;
                        break;

                      case 1:
                        break;

                      default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                }
                return this._firstFreeElement = i, !0;
            }
        }, {
            key: "addNewParticlesToVertexBuffer",
            value: function() {
                var e, t = this._vertexStride * this._floatCountPerVertex * 4;
                this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t, 
                this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t, 
                this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t), 
                this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)), 
                this._firstNewElement = this._firstFreeElement;
            }
        }, {
            key: "_getType",
            value: function() {
                return ShurikenParticleSystem._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(), 
                this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
            }
        }, {
            key: "_render",
            value: function(e) {
                var n;
                this._bufferState.bind();
                var r = t.LayaGL.instance;
                this._firstActiveElement < this._firstFreeElement ? (n = (this._firstFreeElement - this._firstActiveElement) * this._indexStride, 
                r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), 
                t.Stat.trianglesFaces += n / 3, t.Stat.renderBatches++) : (n = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride, 
                r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), 
                t.Stat.trianglesFaces += n / 3, t.Stat.renderBatches++, this._firstFreeElement > 0 && (n = this._firstFreeElement * this._indexStride, 
                r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += n / 3, 
                t.Stat.renderBatches++));
            }
        }, {
            key: "play",
            value: function() {
                if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1, 
                this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed) for (var e = 0, n = this._randomSeeds.length; e < n; e++) this._randomSeeds[e] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[e];
                switch (this.startDelayType) {
                  case 0:
                    this._playStartDelay = this.startDelay;
                    break;

                  case 1:
                    this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2], 
                    this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()), 
                    this._randomSeeds[2] = this._rand.seed);
                    break;

                  default:
                    throw new Error("Utils3D: startDelayType is invalid.");
                }
                this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = t.Stat.loopCount;
            }
        }, {
            key: "pause",
            value: function() {
                this._isPaused = !0;
            }
        }, {
            key: "simulate",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1, 
                this._updateParticles(e)), this.pause();
            }
        }, {
            key: "stop",
            value: function() {
                this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm, 
                t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin, 
                t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime, 
                t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant, 
                this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin, 
                t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin), 
                this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType, 
                t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin, 
                t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize, 
                t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant, 
                this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin, 
                t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate), 
                this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation, 
                t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant, 
                this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin, 
                t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate), 
                this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate), 
                t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType, 
                this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin), 
                this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier, 
                t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake, 
                t.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0], t.maxParticles = this.maxParticles, 
                this._emission && (t._emission = this._emission.clone()), this.shape && (t.shape = this.shape.clone()), 
                this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()), 
                this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()), 
                this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()), 
                this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()), 
                t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting, 
                t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay, 
                t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime, 
                t._burstsIndex = this._burstsIndex;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShurikenParticleSystem(null);
                return this.cloneTo(e), e;
            }
        }, {
            key: "maxParticles",
            get: function() {
                return this._bufferMaxParticles - 1;
            },
            set: function(e) {
                var t = e + 1;
                t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
            }
        }, {
            key: "emission",
            get: function() {
                return this._emission;
            }
        }, {
            key: "aliveParticleCount",
            get: function() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
            }
        }, {
            key: "emissionTime",
            get: function() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime;
            }
        }, {
            key: "shape",
            get: function() {
                return this._shape;
            },
            set: function(e) {
                this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(Hn.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(Hn.SHADERDEFINE_SHAPE), 
                this._shape = e);
            }
        }, {
            key: "isAlive",
            get: function() {
                return !!(this._isPlaying || this.aliveParticleCount > 0);
            }
        }, {
            key: "isEmitting",
            get: function() {
                return this._isEmitting;
            }
        }, {
            key: "isPlaying",
            get: function() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function() {
                return this._isPaused;
            }
        }, {
            key: "startLifetimeType",
            get: function() {
                return this._startLifetimeType;
            },
            set: function(e) {
                var t, n;
                switch (this.startLifetimeType) {
                  case 0:
                    this._maxStartLifetime = this.startLifetimeConstant;
                    break;

                  case 1:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var r = r;
                    for (t = 0, n = r.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, r.getValueByIndex(t));
                    break;

                  case 2:
                    this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;

                  case 3:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var i = i;
                    for (t = 0, n = i.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                    var a = a;
                    for (t = 0, n = a.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
                }
                this._startLifetimeType = e;
            }
        }, {
            key: "startLifetimeConstant",
            get: function() {
                return this._startLifetimeConstant;
            },
            set: function(e) {
                0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
            }
        }, {
            key: "startLifeTimeGradient",
            get: function() {
                return this._startLifeTimeGradient;
            },
            set: function(e) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradient = e;
            }
        }, {
            key: "startLifetimeConstantMin",
            get: function() {
                return this._startLifetimeConstantMin;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)), 
                this._startLifetimeConstantMin = e;
            }
        }, {
            key: "startLifetimeConstantMax",
            get: function() {
                return this._startLifetimeConstantMax;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)), 
                this._startLifetimeConstantMax = e;
            }
        }, {
            key: "startLifeTimeGradientMin",
            get: function() {
                return this._startLifeTimeGradientMin;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, n;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    for (t = 0, n = this._startLifeTimeGradientMax.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
                }
                this._startLifeTimeGradientMin = e;
            }
        }, {
            key: "startLifeTimeGradientMax",
            get: function() {
                return this._startLifeTimeGradientMax;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, n;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, n = this._startLifeTimeGradientMin.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                    for (t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradientMax = e;
            }
        }, {
            key: "velocityOverLifetime",
            get: function() {
                return this._velocityOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var n = e.velocity, r = n.type;
                    if (e.enable) switch (r) {
                      case 0:
                        t.addDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                        break;

                      case 1:
                        t.addDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                        break;

                      case 2:
                        t.addDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                        break;

                      case 3:
                        t.addDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    } else t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
                    t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (r) {
                      case 0:
                        t.setVector3(Hn.VOLVELOCITYCONST, n.constant);
                        break;

                      case 1:
                        t.setBuffer(Hn.VOLVELOCITYGRADIENTX, n.gradientX._elements), t.setBuffer(Hn.VOLVELOCITYGRADIENTY, n.gradientY._elements), 
                        t.setBuffer(Hn.VOLVELOCITYGRADIENTZ, n.gradientZ._elements);
                        break;

                      case 2:
                        t.setVector3(Hn.VOLVELOCITYCONST, n.constantMin), t.setVector3(Hn.VOLVELOCITYCONSTMAX, n.constantMax);
                        break;

                      case 3:
                        t.setBuffer(Hn.VOLVELOCITYGRADIENTX, n.gradientXMin._elements), t.setBuffer(Hn.VOLVELOCITYGRADIENTXMAX, n.gradientXMax._elements), 
                        t.setBuffer(Hn.VOLVELOCITYGRADIENTY, n.gradientYMin._elements), t.setBuffer(Hn.VOLVELOCITYGRADIENTYMAX, n.gradientYMax._elements), 
                        t.setBuffer(Hn.VOLVELOCITYGRADIENTZ, n.gradientZMin._elements), t.setBuffer(Hn.VOLVELOCITYGRADIENTZMAX, n.gradientZMax._elements);
                    }
                    t.setInt(Hn.VOLSPACETYPE, e.space);
                } else t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
                t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                this._velocityOverLifetime = e;
            }
        }, {
            key: "colorOverLifetime",
            get: function() {
                return this._colorOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var n = e.color;
                    if (e.enable) switch (n.type) {
                      case 1:
                        t.addDefine(Hn.SHADERDEFINE_COLOROVERLIFETIME);
                        break;

                      case 3:
                        t.addDefine(Hn.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    } else t.removeDefine(Hn.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Hn.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (n.type) {
                      case 1:
                        var r = n.gradient;
                        t.setBuffer(Hn.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), t.setBuffer(Hn.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements);
                        break;

                      case 3:
                        var i = n.gradientMin, a = n.gradientMax;
                        t.setBuffer(Hn.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Hn.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements), 
                        t.setBuffer(Hn.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Hn.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                    }
                } else t.removeDefine(Hn.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Hn.SHADERDEFINE_RANDOMCOLOROVERLIFETIME), 
                t.setBuffer(Hn.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), t.setBuffer(Hn.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements), 
                t.setBuffer(Hn.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Hn.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements), 
                t.setBuffer(Hn.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Hn.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                this._colorOverLifetime = e;
            }
        }, {
            key: "sizeOverLifetime",
            get: function() {
                return this._sizeOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var n = e.size, r = n.separateAxes, i = n.type;
                    if (e.enable) switch (i) {
                      case 0:
                        r ? t.addDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                        break;

                      case 2:
                        r ? t.addDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
                    t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (i) {
                      case 0:
                        r ? (t.setBuffer(Hn.SOLSIZEGRADIENTX, n.gradientX._elements), t.setBuffer(Hn.SOLSIZEGRADIENTY, n.gradientY._elements), 
                        t.setBuffer(Hn.SOLSizeGradientZ, n.gradientZ._elements)) : t.setBuffer(Hn.SOLSIZEGRADIENT, n.gradient._elements);
                        break;

                      case 2:
                        r ? (t.setBuffer(Hn.SOLSIZEGRADIENTX, n.gradientXMin._elements), t.setBuffer(Hn.SOLSIZEGRADIENTXMAX, n.gradientXMax._elements), 
                        t.setBuffer(Hn.SOLSIZEGRADIENTY, n.gradientYMin._elements), t.setBuffer(Hn.SOLSIZEGRADIENTYMAX, n.gradientYMax._elements), 
                        t.setBuffer(Hn.SOLSizeGradientZ, n.gradientZMin._elements), t.setBuffer(Hn.SOLSizeGradientZMAX, n.gradientZMax._elements)) : (t.setBuffer(Hn.SOLSIZEGRADIENT, n.gradientMin._elements), 
                        t.setBuffer(Hn.SOLSizeGradientMax, n.gradientMax._elements));
                    }
                } else t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
                t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                this._sizeOverLifetime = e;
            }
        }, {
            key: "rotationOverLifetime",
            get: function() {
                return this._rotationOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var n = e.angularVelocity;
                    if (!n) return;
                    var r = n.separateAxes, i = n.type;
                    if (e.enable) switch (r ? t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIME), 
                    i) {
                      case 0:
                        t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                        break;

                      case 1:
                        t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                        break;

                      case 2:
                        t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                        break;

                      case 3:
                        t.addDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
                    t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
                    t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (i) {
                      case 0:
                        r ? t.setVector3(Hn.ROLANGULARVELOCITYCONSTSEPRARATE, n.constantSeparate) : t.setNumber(Hn.ROLANGULARVELOCITYCONST, n.constant);
                        break;

                      case 1:
                        r ? (t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTX, n.gradientX._elements), t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTY, n.gradientY._elements), 
                        t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTZ, n.gradientZ._elements)) : t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENT, n.gradient._elements);
                        break;

                      case 2:
                        r ? (t.setVector3(Hn.ROLANGULARVELOCITYCONSTSEPRARATE, n.constantMinSeparate), t.setVector3(Hn.ROLANGULARVELOCITYCONSTMAXSEPRARATE, n.constantMaxSeparate)) : (t.setNumber(Hn.ROLANGULARVELOCITYCONST, n.constantMin), 
                        t.setNumber(Hn.ROLANGULARVELOCITYCONSTMAX, n.constantMax));
                        break;

                      case 3:
                        r ? (t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTX, n.gradientXMin._elements), t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTXMAX, n.gradientXMax._elements), 
                        t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTY, n.gradientYMin._elements), t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTYMAX, n.gradientYMax._elements), 
                        t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTZ, n.gradientZMin._elements), t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTZMAX, n.gradientZMax._elements)) : (t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENT, n.gradientMin._elements), 
                        t.setBuffer(Hn.ROLANGULARVELOCITYGRADIENTMAX, n.gradientMax._elements));
                    }
                } else t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
                t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
                t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                this._rotationOverLifetime = e;
            }
        }, {
            key: "textureSheetAnimation",
            get: function() {
                return this._textureSheetAnimation;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var n = e.frame, r = n.type;
                    if (e.enable) switch (r) {
                      case 1:
                        t.addDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                        break;

                      case 3:
                        t.addDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    } else t.removeDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === r || 3 === r) {
                        t.setNumber(Hn.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                        var i = e.tiles, a = this._uvLength;
                        a.x = 1 / i.x, a.y = 1 / i.y, t.setVector2(Hn.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                    }
                    switch (r) {
                      case 1:
                        t.setBuffer(Hn.TEXTURESHEETANIMATIONGRADIENTUVS, n.frameOverTimeData._elements);
                        break;

                      case 3:
                        t.setBuffer(Hn.TEXTURESHEETANIMATIONGRADIENTUVS, n.frameOverTimeDataMin._elements), 
                        t.setBuffer(Hn.TEXTURESHEETANIMATIONGRADIENTMAXUVS, n.frameOverTimeDataMax._elements);
                    }
                } else t.removeDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Hn.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                this._textureSheetAnimation = e;
            }
        } ]), ShurikenParticleSystem;
    }();
    Kn._RANDOMOFFSET = new Uint32Array([ 592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447 ]), 
    Kn.halfKSqrtOf2 = .71, Kn._maxElapsedTime = 1 / 3, Kn._tempVector30 = new o(), Kn._tempVector31 = new o(), 
    Kn._tempVector32 = new o(), Kn._tempVector33 = new o(), Kn._tempVector34 = new o(), 
    Kn._tempVector35 = new o(), Kn._tempVector36 = new o(), Kn._tempVector37 = new o(), 
    Kn._tempVector38 = new o(), Kn._tempVector39 = new o(), Kn._tempPosition = new o(), 
    Kn._tempDirection = new o(), Kn._type = Lt._typeCounter++;
    var Jn = function(e) {
        function ShuriKenParticle3D() {
            var e;
            _classCallCheck(this, ShuriKenParticle3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(ShuriKenParticle3D).call(this, null)))._render = new Wn(_assertThisInitialized(e)), 
            e._particleSystem = new Kn(_assertThisInitialized(e));
            var t = e._render._renderElements[0] = new kt();
            return t.setTransform(e._transform), t.render = e._render, t.setGeometry(e._particleSystem), 
            t.material = zn.defaultMaterial, e;
        }
        return _inherits(ShuriKenParticle3D, Pt), _createClass(ShuriKenParticle3D, [ {
            key: "_parseModule",
            value: function(e, n) {
                for (var r in n) switch (r) {
                  case "bases":
                    var i = n.bases;
                    for (var a in i) e[a] = i[a];
                    break;

                  case "vector2s":
                    var o = n.vector2s;
                    for (var a in o) {
                        var s = e[a], l = o[a];
                        s.setValue(l[0], l[1]), e[a] = s;
                    }
                    break;

                  case "vector3s":
                    var u = n.vector3s;
                    for (var a in u) {
                        var c = e[a], h = u[a];
                        c.setValue(h[0], h[1], h[2]), e[a] = c;
                    }
                    break;

                  case "vector4s":
                    var _ = n.vector4s;
                    for (var a in _) {
                        var d = e[a], f = _[a];
                        d.setValue(f[0], f[1], f[2], f[3]), e[a] = d;
                    }
                    break;

                  case "gradientDataNumbers":
                    var m = n.gradientDataNumbers;
                    for (var a in m) {
                        for (var T = e[a], p = n[a], g = 0, E = p.length; g < E; g++) {
                            var y = p[g];
                            T.add(y.key, y.value);
                        }
                        e[a] = T;
                    }
                    break;

                  case "resources":
                    var v = n.resources;
                    for (var a in v) e[a] = t.Loader.getRes(v[a]);
                    break;

                  case "bursts":
                    var S = n.bursts;
                    for (g = 0, E = S.length; g < E; g++) {
                        var C = S[g];
                        e.addBurst(new vn(C.time, C.min, C.max));
                    }
                    break;

                  case "randomSeed":
                    e.randomSeed[0] = n.randomSeed;
                    break;

                  case "shapeType":
                  case "type":
                  case "color":
                  case "size":
                  case "frame":
                  case "startFrame":
                  case "angularVelocity":
                  case "velocity":
                    break;

                  default:
                    throw "ShurikenParticle3D:unknown type.";
                }
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                if (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_parse", this).call(this, e, t), 
                e.main) {
                    var n = this.particleSystem, r = this.particleRenderer;
                    this._parseModule(r, e.renderer), this._parseModule(n, e.main), this._parseModule(n.emission, e.emission);
                    var a = e.shape;
                    if (a) {
                        var s;
                        switch (a.shapeType) {
                          case 0:
                            s = new Bn();
                            break;

                          case 1:
                            s = new wn();
                            break;

                          case 2:
                            s = new kn();
                            break;

                          case 3:
                            s = new Nn();
                            break;

                          case 7:
                            s = new bn();
                            break;

                          default:
                            throw "ShuriKenParticle3D:unknown shape type.";
                        }
                        this._parseModule(s, a), n.shape = s;
                    }
                    var l = e.velocityOverLifetime;
                    if (l) {
                        var u, c = l.velocity;
                        switch (c.type) {
                          case 0:
                            var h = c.constant;
                            u = Ln.createByConstant(h ? new o(h[0], h[1], h[2]) : new o(0, 0, 0));
                            break;

                          case 1:
                            u = Ln.createByGradient(this._initParticleVelocity(c.gradientX), this._initParticleVelocity(c.gradientY), this._initParticleVelocity(c.gradientZ));
                            break;

                          case 2:
                            var _ = c.constantMin, d = c.constantMax;
                            u = Ln.createByRandomTwoConstant(_ ? new o(_[0], _[1], _[2]) : new o(0, 0, 0), d ? new o(d[0], d[1], d[2]) : new o(0, 0, 0));
                            break;

                          case 3:
                            u = Ln.createByRandomTwoGradient(this._initParticleVelocity(c.gradientXMin), this._initParticleVelocity(c.gradientXMax), this._initParticleVelocity(c.gradientYMin), this._initParticleVelocity(c.gradientYMax), this._initParticleVelocity(c.gradientZMin), this._initParticleVelocity(c.gradientZMax));
                        }
                        var f = new Gn(u);
                        this._parseModule(f, l), n.velocityOverLifetime = f;
                    }
                    var m = e.colorOverLifetime;
                    if (m) {
                        var T, p = m.color;
                        switch (p.type) {
                          case 0:
                            var g = p.constant;
                            T = Sn.createByConstant(g ? new i(g[0], g[1], g[2], g[3]) : new i(0, 0, 0, 0));
                            break;

                          case 1:
                            T = Sn.createByGradient(this._initParticleColor(p.gradient));
                            break;

                          case 2:
                            var E = p.constantMin, y = p.constantMax;
                            T = Sn.createByRandomTwoConstant(E ? new i(E[0], E[1], E[2], E[3]) : new i(0, 0, 0, 0), E ? new i(y[0], y[1], y[2], y[3]) : new i(0, 0, 0, 0));
                            break;

                          case 3:
                            T = Sn.createByRandomTwoGradient(this._initParticleColor(p.gradientMin), this._initParticleColor(p.gradientMax));
                        }
                        var v = new Cn(T);
                        this._parseModule(v, m), n.colorOverLifetime = v;
                    }
                    var S = e.sizeOverLifetime;
                    if (S) {
                        var C, R = S.size;
                        switch (R.type) {
                          case 0:
                            C = R.separateAxes ? xn.createByGradientSeparate(this._initParticleSize(R.gradientX), this._initParticleSize(R.gradientY), this._initParticleSize(R.gradientZ)) : xn.createByGradient(this._initParticleSize(R.gradient));
                            break;

                          case 1:
                            if (R.separateAxes) {
                                var D = R.constantMinSeparate, M = R.constantMaxSeparate;
                                C = xn.createByRandomTwoConstantSeparate(D ? new o(D[0], D[1], D[2]) : new o(0, 0, 0), M ? new o(M[0], M[1], M[2]) : new o(0, 0, 0));
                            } else C = xn.createByRandomTwoConstant(R.constantMin || 0, R.constantMax || 0);
                            break;

                          case 2:
                            C = R.separateAxes ? xn.createByRandomTwoGradientSeparate(this._initParticleSize(R.gradientXMin), this._initParticleSize(R.gradientYMin), this._initParticleSize(R.gradientZMin), this._initParticleSize(R.gradientXMax), this._initParticleSize(R.gradientYMax), this._initParticleSize(R.gradientZMax)) : xn.createByRandomTwoGradient(this._initParticleSize(R.gradientMin), this._initParticleSize(R.gradientMax));
                        }
                        var A = new Vn(C);
                        this._parseModule(A, S), n.sizeOverLifetime = A;
                    }
                    var x = e.rotationOverLifetime;
                    if (x) {
                        var L, I = x.angularVelocity;
                        switch (I.type) {
                          case 0:
                            if (I.separateAxes) {
                                var O = I.constantSeparate;
                                L = Dn.createByConstantSeparate(O ? new o(O[0], O[1], O[2]) : new o(0, 0, Math.PI / 4));
                            } else L = Dn.createByConstant(I.constant || Math.PI / 4);
                            break;

                          case 1:
                            L = I.separateAxes ? Dn.createByGradientSeparate(this._initParticleRotation(I.gradientX), this._initParticleRotation(I.gradientY), this._initParticleRotation(I.gradientZ)) : Dn.createByGradient(this._initParticleRotation(I.gradient));
                            break;

                          case 2:
                            if (I.separateAxes) {
                                var P = I.constantMinSeparate, N = I.constantMaxSeparate;
                                L = Dn.createByRandomTwoConstantSeparate(P ? new o(P[0], P[1], P[2]) : new o(0, 0, 0), N ? new o(N[0], N[1], N[2]) : new o(0, 0, Math.PI / 4));
                            } else L = Dn.createByRandomTwoConstant(I.constantMin || 0, I.constantMax || Math.PI / 4);
                            break;

                          case 3:
                            I.separateAxes || (L = Dn.createByRandomTwoGradient(this._initParticleRotation(I.gradientMin), this._initParticleRotation(I.gradientMax)));
                        }
                        var b = new In(L);
                        this._parseModule(b, x), n.rotationOverLifetime = b;
                    }
                    var k = e.textureSheetAnimation;
                    if (k) {
                        var w, B = k.frame;
                        switch (B.type) {
                          case 0:
                            w = Rn.createByConstant(B.constant);
                            break;

                          case 1:
                            w = Rn.createByOverTime(this._initParticleFrame(B.overTime));
                            break;

                          case 2:
                            w = Rn.createByRandomTwoConstant(B.constantMin, B.constantMax);
                            break;

                          case 3:
                            w = Rn.createByRandomTwoOverTime(this._initParticleFrame(B.overTimeMin), this._initParticleFrame(B.overTimeMax));
                        }
                        var V, F = k.startFrame;
                        switch (F.type) {
                          case 0:
                            V = Fn.createByConstant(F.constant);
                            break;

                          case 1:
                            V = Fn.createByRandomTwoConstant(F.constantMin, F.constantMax);
                        }
                        var U = new Un(w, V);
                        this._parseModule(U, k), n.textureSheetAnimation = U;
                    }
                } else this._parseOld(e);
            }
        }, {
            key: "_activeHierarchy",
            value: function(e) {
                _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_activeHierarchy", this).call(this, e), 
                this.particleSystem.playOnAwake && this.particleSystem.play();
            }
        }, {
            key: "_inActiveHierarchy",
            value: function(e) {
                _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_inActiveHierarchy", this).call(this, e), 
                this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, n) {
                var r = e, i = r._particleSystem;
                this._particleSystem.cloneTo(i);
                var a = r._render, o = this._render;
                a.sharedMaterials = o.sharedMaterials, a.enable = o.enable, a.renderMode = o.renderMode, 
                a.mesh = o.mesh, a.stretchedBillboardCameraSpeedScale = o.stretchedBillboardCameraSpeedScale, 
                a.stretchedBillboardSpeedScale = o.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = o.stretchedBillboardLengthScale, 
                a.sortingFudge = o.sortingFudge, _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_cloneTo", this).call(this, e, t, n);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "destroy", this).call(this, e), 
                this._particleSystem.destroy(), this._particleSystem = null);
            }
        }, {
            key: "_create",
            value: function() {
                return new ShuriKenParticle3D();
            }
        }, {
            key: "_parseOld",
            value: function(e) {
                var n, a, s, l = Math.PI / 180, u = this.particleRenderer, c = e.material;
                c && (s = t.Loader.getRes(c.path)), u.sharedMaterial = s;
                var h = e.meshPath;
                h && (u.mesh = t.Loader.getRes(h)), u.renderMode = e.renderMode, u.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale, 
                u.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, u.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale, 
                u.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
                var _ = this.particleSystem;
                _.isPerformanceMode = e.isPerformanceMode, _.duration = e.duration, _.looping = e.looping, 
                _.prewarm = e.prewarm, _.startDelayType = e.startDelayType, _.startDelay = e.startDelay, 
                _.startDelayMin = e.startDelayMin, _.startDelayMax = e.startDelayMax, _.startLifetimeType = e.startLifetimeType, 
                _.startLifetimeConstant = e.startLifetimeConstant, _.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(e.startLifetimeGradient), 
                _.startLifetimeConstantMin = e.startLifetimeConstantMin, _.startLifetimeConstantMax = e.startLifetimeConstantMax, 
                _.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMin), 
                _.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMax), 
                _.startSpeedType = e.startSpeedType, _.startSpeedConstant = e.startSpeedConstant, 
                _.startSpeedConstantMin = e.startSpeedConstantMin, _.startSpeedConstantMax = e.startSpeedConstantMax, 
                _.threeDStartSize = e.threeDStartSize, _.startSizeType = e.startSizeType, _.startSizeConstant = e.startSizeConstant;
                var d = e.startSizeConstantSeparate, f = _.startSizeConstantSeparate;
                f.x = d[0], f.y = d[1], f.z = d[2], _.startSizeConstantMin = e.startSizeConstantMin, 
                _.startSizeConstantMax = e.startSizeConstantMax;
                var m = e.startSizeConstantMinSeparate, T = _.startSizeConstantMinSeparate;
                T.x = m[0], T.y = m[1], T.z = m[2];
                var p = e.startSizeConstantMaxSeparate, g = _.startSizeConstantMaxSeparate;
                g.x = p[0], g.y = p[1], g.z = p[2], _.threeDStartRotation = e.threeDStartRotation, 
                _.startRotationType = e.startRotationType, _.startRotationConstant = e.startRotationConstant * l;
                var E = e.startRotationConstantSeparate, y = _.startRotationConstantSeparate;
                y.x = E[0] * l, y.y = E[1] * l, y.z = E[2] * l, _.startRotationConstantMin = e.startRotationConstantMin * l, 
                _.startRotationConstantMax = e.startRotationConstantMax * l;
                var v = e.startRotationConstantMinSeparate, S = _.startRotationConstantMinSeparate;
                S.x = v[0] * l, S.y = v[1] * l, S.z = v[2] * l;
                var C = e.startRotationConstantMaxSeparate, R = _.startRotationConstantMaxSeparate;
                R.x = C[0] * l, R.y = C[1] * l, R.z = C[2] * l, _.randomizeRotationDirection = e.randomizeRotationDirection, 
                _.startColorType = e.startColorType;
                var D = e.startColorConstant, M = _.startColorConstant;
                M.x = D[0], M.y = D[1], M.z = D[2], M.w = D[3];
                var A = e.startColorConstantMin, x = _.startColorConstantMin;
                x.x = A[0], x.y = A[1], x.z = A[2], x.w = A[3];
                var L = e.startColorConstantMax, I = _.startColorConstantMax;
                I.x = L[0], I.y = L[1], I.z = L[2], I.w = L[3], _.gravityModifier = e.gravityModifier, 
                _.simulationSpace = e.simulationSpace, void 0 !== e.simulationSpeed && (_.simulationSpeed = e.simulationSpeed), 
                _.scaleMode = e.scaleMode, _.playOnAwake = e.playOnAwake, _.maxParticles = e.maxParticles;
                var O = e.autoRandomSeed;
                null != O && (_.autoRandomSeed = O);
                var P = e.randomSeed;
                null != P && (_.randomSeed[0] = P);
                var N = e.emission, b = _.emission;
                if (N) {
                    b.emissionRate = N.emissionRate;
                    var k = N.bursts;
                    if (k) for (n = 0, a = k.length; n < a; n++) {
                        var w = k[n];
                        b.addBurst(new vn(w.time, w.min, w.max));
                    }
                    b.enable = N.enable;
                } else b.enable = !1;
                var B = e.shape;
                if (B) {
                    var V;
                    switch (B.shapeType) {
                      case 0:
                        var F;
                        V = F = new Bn(), F.radius = B.sphereRadius, F.emitFromShell = B.sphereEmitFromShell, 
                        F.randomDirection = B.sphereRandomDirection;
                        break;

                      case 1:
                        var U;
                        V = U = new wn(), U.radius = B.hemiSphereRadius, U.emitFromShell = B.hemiSphereEmitFromShell, 
                        U.randomDirection = B.hemiSphereRandomDirection;
                        break;

                      case 2:
                        var G;
                        V = G = new kn(), G.angle = B.coneAngle * l, G.radius = B.coneRadius, G.length = B.coneLength, 
                        G.emitType = B.coneEmitType, G.randomDirection = B.coneRandomDirection;
                        break;

                      case 3:
                        var H;
                        V = H = new Nn(), H.x = B.boxX, H.y = B.boxY, H.z = B.boxZ, H.randomDirection = B.boxRandomDirection;
                        break;

                      case 7:
                        var z;
                        V = z = new bn(), z.radius = B.circleRadius, z.arc = B.circleArc * l, z.emitFromEdge = B.circleEmitFromEdge, 
                        z.randomDirection = B.circleRandomDirection;
                        break;

                      default:
                        var W;
                        V = W = new bn(), W.radius = B.circleRadius, W.arc = B.circleArc * l, W.emitFromEdge = B.circleEmitFromEdge, 
                        W.randomDirection = B.circleRandomDirection;
                    }
                    V.enable = B.enable, _.shape = V;
                }
                var X = e.velocityOverLifetime;
                if (X) {
                    var Y, j = X.velocity;
                    switch (j.type) {
                      case 0:
                        var Z = j.constant;
                        Y = Ln.createByConstant(new o(Z[0], Z[1], Z[2]));
                        break;

                      case 1:
                        Y = Ln.createByGradient(this._initParticleVelocity(j.gradientX), this._initParticleVelocity(j.gradientY), this._initParticleVelocity(j.gradientZ));
                        break;

                      case 2:
                        var Q = j.constantMin, q = j.constantMax;
                        Y = Ln.createByRandomTwoConstant(new o(Q[0], Q[1], Q[2]), new o(q[0], q[1], q[2]));
                        break;

                      case 3:
                        Y = Ln.createByRandomTwoGradient(this._initParticleVelocity(j.gradientXMin), this._initParticleVelocity(j.gradientXMax), this._initParticleVelocity(j.gradientYMin), this._initParticleVelocity(j.gradientYMax), this._initParticleVelocity(j.gradientZMin), this._initParticleVelocity(j.gradientZMax));
                    }
                    var K = new Gn(Y);
                    K.space = X.space, K.enable = X.enable, _.velocityOverLifetime = K;
                }
                var J = e.colorOverLifetime;
                if (J) {
                    var $, ee = J.color;
                    switch (ee.type) {
                      case 0:
                        var te = ee.constant;
                        $ = Sn.createByConstant(new i(te[0], te[1], te[2], te[3]));
                        break;

                      case 1:
                        $ = Sn.createByGradient(this._initParticleColor(ee.gradient));
                        break;

                      case 2:
                        var ne = ee.constantMin, re = ee.constantMax;
                        $ = Sn.createByRandomTwoConstant(new i(ne[0], ne[1], ne[2], ne[3]), new i(re[0], re[1], re[2], re[3]));
                        break;

                      case 3:
                        $ = Sn.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                    }
                    var ie = new Cn($);
                    ie.enable = J.enable, _.colorOverLifetime = ie;
                }
                var ae = e.sizeOverLifetime;
                if (ae) {
                    var oe, se = ae.size;
                    switch (se.type) {
                      case 0:
                        oe = se.separateAxes ? xn.createByGradientSeparate(this._initParticleSize(se.gradientX), this._initParticleSize(se.gradientY), this._initParticleSize(se.gradientZ)) : xn.createByGradient(this._initParticleSize(se.gradient));
                        break;

                      case 1:
                        if (se.separateAxes) {
                            var le = se.constantMinSeparate, ue = se.constantMaxSeparate;
                            oe = xn.createByRandomTwoConstantSeparate(new o(le[0], le[1], le[2]), new o(ue[0], ue[1], ue[2]));
                        } else oe = xn.createByRandomTwoConstant(se.constantMin, se.constantMax);
                        break;

                      case 2:
                        oe = se.separateAxes ? xn.createByRandomTwoGradientSeparate(this._initParticleSize(se.gradientXMin), this._initParticleSize(se.gradientYMin), this._initParticleSize(se.gradientZMin), this._initParticleSize(se.gradientXMax), this._initParticleSize(se.gradientYMax), this._initParticleSize(se.gradientZMax)) : xn.createByRandomTwoGradient(this._initParticleSize(se.gradientMin), this._initParticleSize(se.gradientMax));
                    }
                    var ce = new Vn(oe);
                    ce.enable = ae.enable, _.sizeOverLifetime = ce;
                }
                var he = e.rotationOverLifetime;
                if (he) {
                    var _e, de = he.angularVelocity;
                    switch (de.type) {
                      case 0:
                        if (de.separateAxes) {
                            var fe = de.constantSeparate;
                            _e = Dn.createByConstantSeparate(new o(fe[0] * l, fe[1] * l, fe[2] * l));
                        } else _e = Dn.createByConstant(de.constant * l);
                        break;

                      case 1:
                        _e = de.separateAxes ? Dn.createByGradientSeparate(this._initParticleRotation(de.gradientX), this._initParticleRotation(de.gradientY), this._initParticleRotation(de.gradientZ)) : Dn.createByGradient(this._initParticleRotation(de.gradient));
                        break;

                      case 2:
                        if (de.separateAxes) {
                            var me = de.constantMinSeparate, Te = de.constantMaxSeparate;
                            _e = Dn.createByRandomTwoConstantSeparate(new o(me[0] * l, me[1] * l, me[2] * l), new o(Te[0] * l, Te[1] * l, Te[2] * l));
                        } else _e = Dn.createByRandomTwoConstant(de.constantMin * l, de.constantMax * l);
                        break;

                      case 3:
                        de.separateAxes || (_e = Dn.createByRandomTwoGradient(this._initParticleRotation(de.gradientMin), this._initParticleRotation(de.gradientMax)));
                    }
                    var pe = new In(_e);
                    pe.enable = he.enable, _.rotationOverLifetime = pe;
                }
                var ge = e.textureSheetAnimation;
                if (ge) {
                    var Ee, ye = ge.frame;
                    switch (ye.type) {
                      case 0:
                        Ee = Rn.createByConstant(ye.constant);
                        break;

                      case 1:
                        Ee = Rn.createByOverTime(this._initParticleFrame(ye.overTime));
                        break;

                      case 2:
                        Ee = Rn.createByRandomTwoConstant(ye.constantMin, ye.constantMax);
                        break;

                      case 3:
                        Ee = Rn.createByRandomTwoOverTime(this._initParticleFrame(ye.overTimeMin), this._initParticleFrame(ye.overTimeMax));
                    }
                    var ve, Se = ge.startFrame;
                    switch (Se.type) {
                      case 0:
                        ve = Fn.createByConstant(Se.constant);
                        break;

                      case 1:
                        ve = Fn.createByRandomTwoConstant(Se.constantMin, Se.constantMax);
                    }
                    var Ce = new Un(Ee, ve);
                    Ce.enable = ge.enable;
                    var Re = ge.tiles;
                    Ce.tiles = new r(Re[0], Re[1]), Ce.type = ge.type, Ce.randomRow = ge.randomRow;
                    var De = ge.rowIndex;
                    void 0 !== De && (Ce.rowIndex = De), Ce.cycles = ge.cycles, _.textureSheetAnimation = Ce;
                }
            }
        }, {
            key: "_initParticleColor",
            value: function(e) {
                var t = new yn(4, 4);
                if (e) {
                    var n, r, i = e.alphas;
                    if (i) for (n = 0, r = i.length; n < r; n++) {
                        3 == n && r > 4 && (n = r - 1, console.warn("GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."));
                        var a = i[n];
                        t.addColorAlpha(a.key, a.value);
                    } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1);
                    var o = e.rgbs;
                    if (o) for (n = 0, r = o.length; n < r; n++) {
                        3 == n && r > 4 && (n = r - 1, console.warn("GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."));
                        var s = o[n], l = s.value;
                        t.addColorRGB(s.key, new Me(l[0], l[1], l[2], 1));
                    } else t.addColorRGB(0, new Me(1, 1, 1, 1)), t.addColorRGB(1, new Me(1, 1, 1, 1));
                } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1), t.addColorRGB(0, new Me(1, 1, 1, 1)), 
                t.addColorRGB(1, new Me(1, 1, 1, 1));
                return t;
            }
        }, {
            key: "_initParticleFrame",
            value: function(e) {
                var t = new Mn();
                if (e) for (var n = e.frames, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.add(a.key, a.value);
                } else t.add(0, 0), t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleVelocity",
            value: function(e) {
                for (var t = new An(), n = e.velocitys, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.add(a.key, a.value);
                }
                return t;
            }
        }, {
            key: "_initParticleSize",
            value: function(e) {
                var t = new An();
                if (e) for (var n = e.sizes, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.add(a.key, a.value);
                } else t.add(0, 0), t.add(1, 1);
                return t;
            }
        }, {
            key: "_initParticleRotation",
            value: function(e) {
                for (var t = new An(), n = e.angularVelocitys, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.add(a.key, a.value / 180 * Math.PI);
                }
                return t;
            }
        }, {
            key: "particleSystem",
            get: function() {
                return this._particleSystem;
            }
        }, {
            key: "particleRenderer",
            get: function() {
                return this._render;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                Hn.SHADERDEFINE_RENDERMODE_BILLBOARD = ue.getDefineByName("SPHERHBILLBOARD"), Hn.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = ue.getDefineByName("STRETCHEDBILLBOARD"), 
                Hn.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = ue.getDefineByName("HORIZONTALBILLBOARD"), 
                Hn.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = ue.getDefineByName("VERTICALBILLBOARD"), 
                Hn.SHADERDEFINE_COLOROVERLIFETIME = ue.getDefineByName("COLOROVERLIFETIME"), Hn.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = ue.getDefineByName("RANDOMCOLOROVERLIFETIME"), 
                Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = ue.getDefineByName("VELOCITYOVERLIFETIMECONSTANT"), 
                Hn.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = ue.getDefineByName("VELOCITYOVERLIFETIMECURVE"), 
                Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = ue.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT"), 
                Hn.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = ue.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE"), 
                Hn.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = ue.getDefineByName("TEXTURESHEETANIMATIONCURVE"), 
                Hn.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = ue.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIME = ue.getDefineByName("ROTATIONOVERLIFETIME"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = ue.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = ue.getDefineByName("ROTATIONOVERLIFETIMECONSTANT"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = ue.getDefineByName("ROTATIONOVERLIFETIMECURVE"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = ue.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS"), 
                Hn.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = ue.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES"), 
                Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVE = ue.getDefineByName("SIZEOVERLIFETIMECURVE"), 
                Hn.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = ue.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE"), 
                Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = ue.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES"), 
                Hn.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = ue.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"), 
                Hn.SHADERDEFINE_RENDERMODE_MESH = ue.getDefineByName("RENDERMODE_MESH"), Hn.SHADERDEFINE_SHAPE = ue.getDefineByName("SHAPE");
            }
        }, {
            key: "_initStartLife",
            value: function(e) {
                for (var t = new An(), n = e.startLifetimes, r = 0, i = n.length; r < i; r++) {
                    var a = n[r];
                    t.add(a.key, a.value);
                }
                return t;
            }
        } ]), ShuriKenParticle3D;
    }(), $n = function SkinnedMeshSprite3DShaderDeclaration() {
        _classCallCheck(this, SkinnedMeshSprite3DShaderDeclaration);
    }, er = function(e) {
        function SkinnedMeshRenderer(e) {
            var t;
            return _classCallCheck(this, SkinnedMeshRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshRenderer).call(this, e)))._bones = [], 
            t._skinnedDataLoopMarks = [], t._localBounds = new xt(o._ZERO, o._ZERO), t._cacheAnimationNode = [], 
            t;
        }
        return _inherits(SkinnedMeshRenderer, fn), _createClass(SkinnedMeshRenderer, [ {
            key: "_computeSkinnedData",
            value: function() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._skinnedMatrixCaches, n = 0, r = this._cacheMesh.subMeshCount; n < r; n++) for (var i = this._cacheMesh.getSubMesh(n)._boneIndicesList, a = this._skinnedData[n], o = 0, s = i.length; o < s; o++) {
                    var l = i[o];
                    this._computeSubSkinnedData(e, l, a[o], t);
                }
            }
        }, {
            key: "_computeSubSkinnedData",
            value: function(e, n, r, i) {
                for (var a = 0, o = n.length; a < o; a++) {
                    var s = n[a];
                    if (this._skinnedDataLoopMarks[s] === t.Stat.loopCount) for (var l = i[s], u = this._skinnedData[l.subMeshIndex][l.batchIndex], c = 16 * l.batchBoneIndex, h = 16 * a, _ = 0; _ < 16; _++) r[h + _] = u[c + _]; else this._cacheAvatar ? O._mulMatrixArray(this._cacheAnimationNode[s].transform.getWorldMatrix(), e[s].elements, 0, r, 16 * a) : O._mulMatrixArray(this._bones[s].transform.worldMatrix.elements, e[s].elements, 0, r, 16 * a), 
                    this._skinnedDataLoopMarks[s] = t.Stat.loopCount;
                }
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function(e) {
                this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= f.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
            }
        }, {
            key: "_createRenderElement",
            value: function() {
                return new kt();
            }
        }, {
            key: "_onMeshChange",
            value: function(e) {
                _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_onMeshChange", this).call(this, e), 
                this._cacheMesh = e;
                var t = e.subMeshCount;
                this._skinnedData = [], this._skinnedDataLoopMarks.length = e._inverseBindPoses.length;
                for (var n = 0; n < t; n++) for (var r = e.getSubMesh(n)._boneIndicesList, i = r.length, a = this._skinnedData[n] = [], o = 0; o < i; o++) a[o] = new Float32Array(16 * r[o].length);
                this._cacheAvatar && e && this._getCacheAnimationNodes();
            }
        }, {
            key: "_setCacheAnimator",
            value: function(e) {
                this._cacheAnimator = e, this._shaderValues.addDefine($n.SHADERDEFINE_BONE), this._setRootNode();
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                if (this._cacheAvatar) if (this._cacheAnimator && this._rootBone) {
                    var e = SkinnedMeshRenderer._tempMatrix4x4;
                    O.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e), 
                    this._localBounds._tranform(e, this._bounds);
                } else _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_calculateBoundingBox", this).call(this); else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
                if (t.Render.supportWebGLPlusCulling) {
                    var n = this._bounds.getMin(), r = this._bounds.getMax(), i = Le._cullingBuffer;
                    i[this._cullingBufferIndex + 1] = n.x, i[this._cullingBufferIndex + 2] = n.y, i[this._cullingBufferIndex + 3] = n.z, 
                    i[this._cullingBufferIndex + 4] = r.x, i[this._cullingBufferIndex + 5] = r.y, i[this._cullingBufferIndex + 6] = r.z;
                }
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                if (this._cacheAnimator) if (this._computeSkinnedData(), this._cacheAvatar) {
                    var n = this._cacheAnimator.owner._transform;
                    this._shaderValues.setMatrix4x4(et.WORLDMATRIX, n.worldMatrix);
                } else this._shaderValues.setMatrix4x4(et.WORLDMATRIX, c.DEFAULT); else this._shaderValues.setMatrix4x4(et.WORLDMATRIX, t.worldMatrix);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var n = e.projectionViewMatrix;
                if (this._cacheAnimator) if (this._cacheAvatar) {
                    var r = this._cacheAnimator.owner._transform;
                    c.multiply(n, r.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(et.MVPMATRIX, this._projectionViewWorldMatrix);
                } else this._shaderValues.setMatrix4x4(et.MVPMATRIX, n); else c.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), 
                this._shaderValues.setMatrix4x4(et.MVPMATRIX, this._projectionViewWorldMatrix);
            }
        }, {
            key: "_destroy",
            value: function() {
                _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_destroy", this).call(this), 
                this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
            }
        }, {
            key: "_setRootBone",
            value: function(e) {
                this._rootBone = e, this._setRootNode();
            }
        }, {
            key: "_setRootNode",
            value: function() {
                var e;
                e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null, 
                this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(f.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE), 
                this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
                this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
                e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
                this._cacheRootAnimationNode = e);
            }
        }, {
            key: "_getCacheAnimationNodes",
            value: function() {
                var e = this._cacheMesh._boneNames, n = this._cacheMesh._inverseBindPoses.length;
                if (t.Render.supportWebGLPlusAnimation) {
                    this._cacheAnimationNodeIndices = new Uint16Array(n);
                    var r = this._cacheAnimator._avatarNodeMap;
                    for (o = 0; o < n; o++) {
                        var i = r[e[o]];
                        this._cacheAnimationNodeIndices[o] = i ? i._worldMatrixIndex : 0;
                    }
                } else {
                    this._cacheAnimationNode.length = n;
                    for (var a = this._cacheAnimator._avatarNodeMap, o = 0; o < n; o++) {
                        var s = a[e[o]];
                        this._cacheAnimationNode[o] = s;
                    }
                }
            }
        }, {
            key: "_setCacheAvatar",
            value: function(e) {
                this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._shaderValues.addDefine($n.SHADERDEFINE_BONE), 
                this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
            }
        }, {
            key: "_computeSubSkinnedDataNative",
            value: function(e, n, r, i, a) {
                t.LayaGL.instance.computeSubSkinnedData(e, n, r, i, a);
            }
        }, {
            key: "_computeSkinnedDataForNative",
            value: function() {
                if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var e = this._cacheMesh._inverseBindPoses, n = this._cacheMesh._skinnedMatrixCaches, r = 0, i = this._cacheMesh.subMeshCount; r < i; r++) for (var a = this._cacheMesh.getSubMesh(r)._boneIndicesList, o = this._skinnedData[r], s = 0, l = a.length; s < l; s++) {
                    var u = a[s];
                    this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, u, o[s]) : this._computeSubSkinnedData(e, u, o[s], n);
                }
            }
        }, {
            key: "localBounds",
            get: function() {
                return this._localBounds;
            },
            set: function(e) {
                this._localBounds = e;
            }
        }, {
            key: "rootBone",
            get: function() {
                return this._cacheRootBone;
            },
            set: function(e) {
                this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
                e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
                this._cacheRootBone = e, this._onWorldMatNeedChange(f.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE));
            }
        }, {
            key: "bones",
            get: function() {
                return this._bones;
            }
        }, {
            key: "bounds",
            get: function() {
                return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(), 
                this._boundsChange = !1), this._bounds;
            }
        } ]), SkinnedMeshRenderer;
    }();
    er._tempMatrix4x4 = new c();
    var tr = function(e) {
        function SkinnedMeshSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, SkinnedMeshSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshSprite3D).call(this, n)))._meshFilter = new mn(_assertThisInitialized(e)), 
            e._render = new er(_assertThisInitialized(e)), t && (e._meshFilter.sharedMesh = t), 
            e;
        }
        return _inherits(SkinnedMeshSprite3D, Pt), _createClass(SkinnedMeshSprite3D, [ {
            key: "_parse",
            value: function(e, n) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_parse", this).call(this, e, n);
                var r = this.skinnedMeshRenderer, a = e.lightmapIndex;
                null != a && (r.lightmapIndex = a);
                var s, l = e.lightmapScaleOffset;
                if (l && (r.lightmapScaleOffset = new i(l[0], l[1], l[2], l[3])), null != e.enableRender && (r.enable = e.enableRender), 
                null != e.receiveShadows && (r.receiveShadow = e.receiveShadows), null != e.castShadow && (r.castShadow = e.castShadow), 
                s = e.meshPath) {
                    var u = t.Loader.getRes(s);
                    u && (this.meshFilter.sharedMesh = u);
                }
                var c = e.materials;
                if (c) {
                    var h = r.sharedMaterials, _ = c.length;
                    h.length = _;
                    for (var d = 0; d < _; d++) h[d] = t.Loader.getRes(c[d].path);
                    r.sharedMaterials = h;
                }
                var f = e.boundBox, m = f.min, T = f.max;
                if (r.localBounds.setMin(new o(m[0], m[1], m[2])), r.localBounds.setMax(new o(T[0], T[1], T[2])), 
                n) {
                    var p = e.rootBone;
                    r.rootBone = n[p];
                    var g, E = e.bones;
                    for (d = 0, g = E.length; d < g; d++) r.bones.push(n[E[d]]);
                } else e.rootBone && r._setRootBone(e.rootBone);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e), 
                this.skinnedMeshRenderer._setCacheAnimator(e);
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {
                this.skinnedMeshRenderer._setCacheAvatar(e);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, n) {
                var r = e;
                r.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var i = this._render, a = r._render;
                a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i.castShadow;
                var o = i.lightmapScaleOffset;
                o && (a.lightmapScaleOffset = o.clone()), a.receiveShadow = i.receiveShadow, a.sortingFudge = i.sortingFudge, 
                a._rootBone = i._rootBone;
                var s = i.bones, l = a.bones, u = s.length;
                l.length = u;
                var c = i.rootBone;
                if (c) {
                    var h = O._getHierarchyPath(t, c, SkinnedMeshSprite3D._tempArray0);
                    a.rootBone = h ? O._getNodeByHierarchyPath(n, h) : c;
                }
                for (var _ = 0; _ < s.length; _++) h = O._getHierarchyPath(t, s[_], SkinnedMeshSprite3D._tempArray0), 
                l[_] = h ? O._getNodeByHierarchyPath(n, h) : s[_];
                var d = i.localBounds;
                d && d.cloneTo(a.localBounds), _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, n);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "destroy", this).call(this, e), 
                this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function() {
                return new SkinnedMeshSprite3D();
            }
        }, {
            key: "meshFilter",
            get: function() {
                return this._meshFilter;
            }
        }, {
            key: "skinnedMeshRenderer",
            get: function() {
                return this._render;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                $n.SHADERDEFINE_BONE = ue.getDefineByName("BONE");
            }
        } ]), SkinnedMeshSprite3D;
    }();
    tr._tempArray0 = [], tr.BONES = ue.propertyNameToID("u_Bones");
    var nr = function(e) {
        function TrailMaterial() {
            var e;
            return _classCallCheck(this, TrailMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailMaterial).call(this))).setShaderName("Trail"), 
            e._color = new i(1, 1, 1, 1), e._shaderValues.setVector(TrailMaterial.TINTCOLOR, new i(1, 1, 1, 1)), 
            e.renderMode = TrailMaterial.RENDERMODE_ALPHABLENDED, e;
        }
        return _inherits(TrailMaterial, me), _createClass(TrailMaterial, [ {
            key: "clone",
            value: function() {
                var e = new TrailMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                  case TrailMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_NONE, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE, this.depthTest = pe.DEPTHTEST_LESS, this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  case TrailMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = me.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                    this.cull = pe.CULL_NONE, this.blend = pe.BLEND_ENABLE_ALL, this.blendSrc = pe.BLENDPARAM_SRC_ALPHA, 
                    this.blendDst = pe.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = pe.DEPTHTEST_LESS, 
                    this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                    break;

                  default:
                    throw new Error("TrailMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(TrailMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE), 
                this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET), 
                this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            set: function(e) {
                this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, e);
            },
            get: function() {
                return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.CULL, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.CULL);
            }
        }, {
            key: "blend",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_SRC, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_DST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST);
            }
        } ], [ {
            key: "__initDefine__",
            value: function() {
                TrailMaterial.SHADERDEFINE_MAINTEXTURE = ue.getDefineByName("MAINTEXTURE"), TrailMaterial.SHADERDEFINE_TILINGOFFSET = ue.getDefineByName("TILINGOFFSET"), 
                TrailMaterial.SHADERDEFINE_ADDTIVEFOG = ue.getDefineByName("ADDTIVEFOG");
            }
        } ]), TrailMaterial;
    }();
    nr.RENDERMODE_ALPHABLENDED = 0, nr.RENDERMODE_ADDTIVE = 1, nr.MAINTEXTURE = ue.propertyNameToID("u_MainTexture"), 
    nr.TINTCOLOR = ue.propertyNameToID("u_MainColor"), nr.TILINGOFFSET = ue.propertyNameToID("u_TilingOffset"), 
    nr.CULL = ue.propertyNameToID("s_Cull"), nr.BLEND = ue.propertyNameToID("s_Blend"), 
    nr.BLEND_SRC = ue.propertyNameToID("s_BlendSrc"), nr.BLEND_DST = ue.propertyNameToID("s_BlendDst"), 
    nr.DEPTH_TEST = ue.propertyNameToID("s_DepthTest"), nr.DEPTH_WRITE = ue.propertyNameToID("s_DepthWrite");
    var rr, ir = function TextureMode() {
        _classCallCheck(this, TextureMode);
    };
    ir.Stretch = 0, ir.Tile = 1, (rr = e.TrailAlignment || (e.TrailAlignment = {}))[rr.View = 0] = "View", 
    rr[rr.TransformZ = 1] = "TransformZ";
    var ar = function() {
        function VertexTrail() {
            _classCallCheck(this, VertexTrail);
        }
        return _createClass(VertexTrail, [ {
            key: "vertexDeclaration",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                VertexTrail._vertexDeclaration1 = new je(32, [ new Ze(0, Ye.Vector3, VertexTrail.TRAIL_POSITION0), new Ze(12, Ye.Vector3, VertexTrail.TRAIL_OFFSETVECTOR), new Ze(24, Ye.Single, VertexTrail.TRAIL_TIME0), new Ze(28, Ye.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0Y) ]), 
                VertexTrail._vertexDeclaration2 = new je(20, [ new Ze(0, Ye.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X), new Ze(4, Ye.Color, VertexTrail.TRAIL_COLOR) ]);
            }
        }, {
            key: "vertexDeclaration1",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        }, {
            key: "vertexDeclaration2",
            get: function() {
                return VertexTrail._vertexDeclaration2;
            }
        } ]), VertexTrail;
    }();
    ar.TRAIL_POSITION0 = 0, ar.TRAIL_OFFSETVECTOR = 1, ar.TRAIL_TIME0 = 2, ar.TRAIL_TEXTURECOORDINATE0Y = 3, 
    ar.TRAIL_TEXTURECOORDINATE0X = 4, ar.TRAIL_COLOR = 5;
    var or = function(r) {
        function TrailGeometry(e) {
            var n;
            _classCallCheck(this, TrailGeometry), (n = _possibleConstructorReturn(this, _getPrototypeOf(TrailGeometry).call(this)))._floatCountPerVertices1 = 8, 
            n._floatCountPerVertices2 = 5, n._increaseSegementCount = 16, n._activeIndex = 0, 
            n._endIndex = 0, n._needAddFirstVertex = !1, n._isTempEndVertex = !1, n._vertices1 = null, 
            n._vertices2 = null, n._lastFixedVertexPosition = new o(), n._bufferState = new We(), 
            n.tmpColor = new Me(), n._disappearBoundsMode = !1, n._owner = e, n._segementCount = n._increaseSegementCount, 
            n._resizeData(n._segementCount, n._bufferState);
            var r = n._owner._owner.trailRenderer.bounds, i = n._owner._owner.transform.position;
            return r.setMin(i), r.setMax(i), t.Render.supportWebGLPlusCulling && n._calculateBoundingBoxForNative(), 
            n;
        }
        return _inherits(TrailGeometry, Lt), _createClass(TrailGeometry, [ {
            key: "_resizeData",
            value: function(e, n) {
                this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(e);
                var r = t.LayaGL.instance, i = 2 * e, a = ar.vertexDeclaration1, o = ar.vertexDeclaration2, s = [], l = i * a.vertexStride, u = i * o.vertexStride, c = l + u;
                this._vertices1 = new Float32Array(i * this._floatCountPerVertices1), this._vertices2 = new Float32Array(i * this._floatCountPerVertices2), 
                this._vertexBuffer1 = new qe(l, r.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = a, 
                this._vertexBuffer2 = new qe(u, r.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = o, 
                s.push(this._vertexBuffer1), s.push(this._vertexBuffer2), n.bind(), n.applyVertexBuffers(s), 
                n.unBind(), t.Resource._addMemory(c, c);
            }
        }, {
            key: "_resetData",
            value: function() {
                var e = this._endIndex - this._activeIndex, n = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e), r = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e), i = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e), a = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
                if (e === this._segementCount) {
                    this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy();
                    var o = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                    t.Resource._addMemory(-o, -o), this._segementCount += this._increaseSegementCount, 
                    this._resizeData(this._segementCount, this._bufferState);
                }
                this._vertices1.set(n, 0), this._vertices2.set(r, 0), this._subDistance.set(i, 0), 
                this._subBirthTime.set(a, 0), this._endIndex = e, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4), 
                this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
            }
        }, {
            key: "_updateTrail",
            value: function(e, t, n) {
                o.equals(t, n) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, n) : this._addTrailByNextPosition(e, n));
            }
        }, {
            key: "_addTrailByFirstPosition",
            value: function(e, t) {
                this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0, 
                this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition), 
                this._needAddFirstVertex = !0;
            }
        }, {
            key: "_addTrailByNextPosition",
            value: function(t, r) {
                var i = TrailGeometry._tempVector30, a = TrailGeometry._tempVector31;
                switch (this._owner.alignment) {
                  case e.TrailAlignment.View:
                    var s = t.viewMatrix;
                    o.transformCoordinate(r, s, TrailGeometry._tempVector33), o.transformCoordinate(this._lastFixedVertexPosition, s, TrailGeometry._tempVector34), 
                    o.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, i), o.cross(TrailGeometry._tempVector33, i, a);
                    break;

                  case e.TrailAlignment.TransformZ:
                    o.subtract(r, this._lastFixedVertexPosition, i);
                    var l = TrailGeometry._tempVector32;
                    this._owner._owner.transform.getForward(l), o.cross(i, l, a);
                }
                o.normalize(a, a), o.scale(a, this._owner.widthMultiplier / 2, a);
                var u, c, h = o.scalarLength(i);
                this._needAddFirstVertex && (this._updateVerticesByPositionData(r, a, this._endIndex - 1), 
                this._needAddFirstVertex = !1), h - this._owner.minVertexDistance >= n.zeroTolerance ? (this._isTempEndVertex ? (u = this._endIndex - 1, 
                c = h - this._subDistance[u], this._updateVerticesByPosition(r, a, h, u), this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(), 
                this._updateVerticesByPosition(r, a, h, this._endIndex), this._owner._totalLength += h, 
                this._endIndex++), r.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (u = this._endIndex - 1, 
                c = h - this._subDistance[u], this._updateVerticesByPosition(r, a, h, u), this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(), 
                this._updateVerticesByPosition(r, a, h, this._endIndex), this._owner._totalLength += h, 
                this._endIndex++), this._isTempEndVertex = !0);
            }
        }, {
            key: "_updateVerticesByPositionData",
            value: function(e, n, r) {
                var i = 2 * this._floatCountPerVertices1 * r, a = this._owner._curtime;
                this._vertices1[i] = e.x, this._vertices1[i + 1] = e.y, this._vertices1[i + 2] = e.z, 
                this._vertices1[i + 3] = -n.x, this._vertices1[i + 4] = -n.y, this._vertices1[i + 5] = -n.z, 
                this._vertices1[i + 6] = a, this._vertices1[i + 7] = 1, this._vertices1[i + 8] = e.x, 
                this._vertices1[i + 9] = e.y, this._vertices1[i + 10] = e.z, this._vertices1[i + 11] = n.x, 
                this._vertices1[i + 12] = n.y, this._vertices1[i + 13] = n.z, this._vertices1[i + 14] = a, 
                this._vertices1[i + 15] = 0;
                var s = this._owner._owner.trailRenderer.bounds, l = s.getMin(), u = s.getMax(), c = TrailGeometry._tempVector35, h = TrailGeometry._tempVector36, _ = TrailGeometry._tempVector32;
                o.add(e, n, c), o.subtract(e, n, h), o.min(h, c, _), o.min(l, _, l), s.setMin(l), 
                o.max(c, h, _), o.max(u, _, u), s.setMax(u), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                var d = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1.buffer, 4 * i, 4 * i, 4 * d);
            }
        }, {
            key: "_updateVerticesByPosition",
            value: function(e, t, n, r) {
                this._updateVerticesByPositionData(e, t, r), this._subDistance[r] = n, this._subBirthTime[r] = this._owner._curtime;
            }
        }, {
            key: "_updateVertexBufferUV",
            value: function() {
                var e, n, r;
                if (this._disappearBoundsMode) {
                    e = this._owner._owner.trailRenderer.bounds;
                    var i = this._owner._owner.transform.position;
                    e.setMin(i), e.setMax(i), n = e.getMin(), r = e.getMax(), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                }
                for (var a = this._endIndex, s = 0, l = this._owner.colorGradient, u = l.colorAlphaKeysCount - 1, c = l.colorRGBKeysCount - 1, h = this._owner._totalLength, _ = 2 * this._floatCountPerVertices2, d = this._activeIndex; d < a; d++) {
                    var f, m;
                    d !== this._activeIndex && (s += this._subDistance[d]), this._owner.textureMode == ir.Stretch ? m = f = 1 - s / h : (m = 1 - s / h, 
                    f = 1 - (h - s)), c = l.evaluateColorRGB(m, this.tmpColor, c, !0), u = l.evaluateColorAlpha(m, this.tmpColor, u, !0);
                    var T = d * _;
                    if (this._vertices2[T + 0] = f, this._vertices2[T + 1] = this.tmpColor.r, this._vertices2[T + 2] = this.tmpColor.g, 
                    this._vertices2[T + 3] = this.tmpColor.b, this._vertices2[T + 4] = this.tmpColor.a, 
                    this._vertices2[T + 5] = f, this._vertices2[T + 6] = this.tmpColor.r, this._vertices2[T + 7] = this.tmpColor.g, 
                    this._vertices2[T + 8] = this.tmpColor.b, this._vertices2[T + 9] = this.tmpColor.a, 
                    this._disappearBoundsMode) {
                        var p = 2 * this._floatCountPerVertices1 * d, g = TrailGeometry._tempVector32, E = TrailGeometry._tempVector33, y = TrailGeometry._tempVector34;
                        g.setValue(this._vertices1[p + 0], this._vertices1[p + 1], this._vertices1[p + 2]), 
                        E.setValue(this._vertices1[p + 3], this._vertices1[p + 4], this._vertices1[p + 5]), 
                        o.add(g, E, y), o.min(y, n, n), o.max(y, r, r), o.subtract(g, E, y), o.min(y, n, n), 
                        o.max(y, r, r);
                    }
                }
                this._disappearBoundsMode && (e.setMin(n), e.setMax(r), this._disappearBoundsMode = !1, 
                t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                var v = this._activeIndex * _;
                this._vertexBuffer2.setData(this._vertices2.buffer, 4 * v, 4 * v, 4 * (a * _ - v));
            }
        }, {
            key: "_updateDisappear",
            value: function() {
                for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + n.zeroTolerance; t++) {
                    var r = t + 1;
                    if (r !== e && (this._owner._totalLength -= this._subDistance[r]), this._isTempEndVertex && r === e - 1) {
                        this._floatCountPerVertices1;
                        var i = this._lastFixedVertexPosition;
                        i.x = this._vertices1[0], i.y = this._vertices1[1], i.z = this._vertices1[2], this._isTempEndVertex = !1;
                    }
                    this._activeIndex++, this._disappearBoundsMode = !0;
                }
            }
        }, {
            key: "_getType",
            value: function() {
                return TrailGeometry._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._endIndex - this._activeIndex > 1;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                var n = t.LayaGL.instance, r = 2 * this._activeIndex, i = 2 * this._endIndex - r;
                n.drawArrays(n.TRIANGLE_STRIP, r, i), t.Stat.renderBatches++, t.Stat.trianglesFaces += i - 2;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(TrailGeometry.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1.destroy(), 
                this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null, 
                this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null, 
                this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null, 
                this._disappearBoundsMode = !1;
            }
        }, {
            key: "_calculateBoundingBoxForNative",
            value: function() {
                var e = this._owner._owner.trailRenderer, t = e.bounds, n = t.getMin(), r = t.getMax(), i = Le._cullingBuffer;
                i[e._cullingBufferIndex + 1] = n.x, i[e._cullingBufferIndex + 2] = n.y, i[e._cullingBufferIndex + 3] = n.z, 
                i[e._cullingBufferIndex + 4] = r.x, i[e._cullingBufferIndex + 5] = r.y, i[e._cullingBufferIndex + 6] = r.z;
            }
        }, {
            key: "clear",
            value: function() {
                this._activeIndex = 0, this._endIndex = 0, this._disappearBoundsMode = !1, this._subBirthTime.fill(0), 
                this._subDistance.fill(0), this._segementCount = 0, this._isTempEndVertex = !1, 
                this._needAddFirstVertex = !1, this._lastFixedVertexPosition.setValue(0, 0, 0);
            }
        } ]), TrailGeometry;
    }();
    or.ALIGNMENT_VIEW = 0, or.ALIGNMENT_TRANSFORM_Z = 1, or._tempVector30 = new o(), 
    or._tempVector31 = new o(), or._tempVector32 = new o(), or._tempVector33 = new o(), 
    or._tempVector34 = new o(), or._tempVector35 = new o(), or._tempVector36 = new o(), 
    or._type = Lt._typeCounter++;
    var sr = function() {
        function TrailFilter(e) {
            _classCallCheck(this, TrailFilter), this._totalLength = 0, this._lastPosition = new o(), 
            this._curtime = 0, this.alignment = TrailFilter.ALIGNMENT_VIEW, this._owner = e, 
            this._initDefaultData(), this.addRenderElement();
        }
        return _createClass(TrailFilter, [ {
            key: "addRenderElement",
            value: function() {
                var e = this._owner._render, t = e._renderElements, n = e.sharedMaterials[0];
                n || (n = nr.defaultMaterial);
                var r = new kt();
                r.setTransform(this._owner._transform), r.render = e, r.material = n, this._trialGeometry = new or(this), 
                r.setGeometry(this._trialGeometry), t.push(r);
            }
        }, {
            key: "_update",
            value: function(e) {
                var t = this._owner._render;
                this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
                var n = this._owner.transform.position, r = t._renderElements[0]._geometry;
                r._updateDisappear(), r._updateTrail(e.camera, this._lastPosition, n), r._updateVertexBufferUV(), 
                n.cloneTo(this._lastPosition);
            }
        }, {
            key: "_initDefaultData",
            value: function() {
                this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = ir.Stretch;
                var e = [], t = new U();
                t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
                var n = new U();
                n.time = 1, n.inTangent = 0, n.outTangent = 0, n.value = 1, e.push(n), this.widthCurve = e;
                var r = new yn(2, 2);
                r.mode = En.Blend, r.addColorRGB(0, Me.WHITE), r.addColorRGB(1, Me.WHITE), r.addColorAlpha(0, 1), 
                r.addColorAlpha(1, 1), this.colorGradient = r;
            }
        }, {
            key: "destroy",
            value: function() {
                this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null, 
                this._colorGradient = null;
            }
        }, {
            key: "clear",
            value: function() {
                this._trialGeometry.clear(), this._lastPosition.setValue(0, 0, 0), this._curtime = 0, 
                this._totalLength = 0;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            },
            set: function(e) {
                this._time = e, this._owner._render._shaderValues.setNumber(TrailFilter.LIFETIME, e);
            }
        }, {
            key: "minVertexDistance",
            get: function() {
                return this._minVertexDistance;
            },
            set: function(e) {
                this._minVertexDistance = e;
            }
        }, {
            key: "widthMultiplier",
            get: function() {
                return this._widthMultiplier;
            },
            set: function(e) {
                this._widthMultiplier = e;
            }
        }, {
            key: "widthCurve",
            get: function() {
                return this._widthCurve;
            },
            set: function(e) {
                this._widthCurve = e;
                var t, n, r = new Float32Array(4 * e.length), i = 0;
                for (t = 0, n = e.length; t < n; t++) r[i++] = e[t].time, r[i++] = e[t].inTangent, 
                r[i++] = e[t].outTangent, r[i++] = e[t].value;
                this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, r), this._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, e.length);
            }
        }, {
            key: "colorGradient",
            get: function() {
                return this._colorGradient;
            },
            set: function(e) {
                this._colorGradient = e;
            }
        }, {
            key: "textureMode",
            get: function() {
                return this._textureMode;
            },
            set: function(e) {
                this._textureMode = e;
            }
        } ]), TrailFilter;
    }();
    sr.CURTIME = ue.propertyNameToID("u_CurTime"), sr.LIFETIME = ue.propertyNameToID("u_LifeTime"), 
    sr.WIDTHCURVE = ue.propertyNameToID("u_WidthCurve"), sr.WIDTHCURVEKEYLENGTH = ue.propertyNameToID("u_WidthCurveKeyLength"), 
    sr.ALIGNMENT_VIEW = 0, sr.ALIGNMENT_TRANSFORM_Z = 1;
    var lr = function(e) {
        function TrailRenderer(e) {
            var t;
            return _classCallCheck(this, TrailRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(TrailRenderer).call(this, e)))._projectionViewWorldMatrix = new c(), 
            t;
        }
        return _inherits(TrailRenderer, Ut), _createClass(TrailRenderer, [ {
            key: "_calculateBoundingBox",
            value: function() {}
        }, {
            key: "_needRender",
            value: function(e, t) {
                return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds._getBoundBox());
            }
        }, {
            key: "_updateForNative",
            value: function(e) {
                this._owner.trailFilter._update(e);
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {
                _get(_getPrototypeOf(TrailRenderer.prototype), "_renderUpdate", this).call(this, e, t);
            }
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {
                var n = e.projectionViewMatrix;
                t ? (c.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(et.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(et.MVPMATRIX, n);
            }
        } ]), TrailRenderer;
    }(), ur = function(e) {
        function TrailSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            return _classCallCheck(this, TrailSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailSprite3D).call(this, t)))._render = new lr(_assertThisInitialized(e)), 
            e._geometryFilter = new sr(_assertThisInitialized(e)), e;
        }
        return _inherits(TrailSprite3D, Pt), _createClass(TrailSprite3D, [ {
            key: "_parse",
            value: function(e, n) {
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_parse", this).call(this, e, n);
                var r, i, a = this._render, o = this._geometryFilter, s = e.materials;
                if (s) {
                    var l = a.sharedMaterials, u = s.length;
                    for (l.length = u, r = 0; r < u; r++) l[r] = t.Loader.getRes(s[r].path);
                    a.sharedMaterials = l;
                }
                o.time = e.time, o.minVertexDistance = e.minVertexDistance, o.widthMultiplier = e.widthMultiplier, 
                o.textureMode = e.textureMode, null != e.alignment && (o.alignment = e.alignment);
                var c = [], h = e.widthCurve;
                for (r = 0, i = h.length; r < i; r++) {
                    var _ = new U();
                    _.time = h[r].time, _.inTangent = h[r].inTangent, _.outTangent = h[r].outTangent, 
                    _.value = h[r].value, c.push(_);
                }
                o.widthCurve = c;
                var d = e.colorGradient, f = d.colorKeys, m = d.alphaKeys, T = new yn(f.length, m.length);
                for (T.mode = d.mode, r = 0, i = f.length; r < i; r++) {
                    var p = f[r];
                    T.addColorRGB(p.time, new Me(p.value[0], p.value[1], p.value[2], 1));
                }
                for (r = 0, i = m.length; r < i; r++) {
                    var g = m[r];
                    T.addColorAlpha(g.time, g.value);
                }
                o.colorGradient = T;
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_onActive", this).call(this), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, n) {
                var r, i;
                _get(_getPrototypeOf(TrailSprite3D.prototype), "_cloneTo", this).call(this, e, t, n);
                var a = e, o = a.trailFilter;
                o.time = this.trailFilter.time, o.minVertexDistance = this.trailFilter.minVertexDistance, 
                o.widthMultiplier = this.trailFilter.widthMultiplier, o.textureMode = this.trailFilter.textureMode, 
                o.alignment = this.trailFilter.alignment;
                var s = this.trailFilter.widthCurve, l = [];
                for (r = 0, i = s.length; r < i; r++) {
                    var u = new U();
                    s[r].cloneTo(u), l.push(u);
                }
                o.widthCurve = l;
                var c = new yn(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                this.trailFilter.colorGradient.cloneTo(c), o.colorGradient = c, a.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(TrailSprite3D.prototype), "destroy", this).call(this, e), 
                this._geometryFilter.destroy(), this._geometryFilter = null);
            }
        }, {
            key: "clear",
            value: function() {
                this._geometryFilter.clear();
            }
        }, {
            key: "_create",
            value: function() {
                return new TrailSprite3D();
            }
        }, {
            key: "trailFilter",
            get: function() {
                return this._geometryFilter;
            }
        }, {
            key: "trailRenderer",
            get: function() {
                return this._render;
            }
        } ], [ {
            key: "__init__",
            value: function() {}
        } ]), TrailSprite3D;
    }(), cr = function() {
        function VertexPositionTerrain(e, t, n, r) {
            _classCallCheck(this, VertexPositionTerrain), this._position = e, this._normal = t, 
            this._textureCoord0 = n, this._textureCoord1 = r;
        }
        return _createClass(VertexPositionTerrain, [ {
            key: "position",
            get: function() {
                return this._position;
            }
        }, {
            key: "normal",
            get: function() {
                return this._normal;
            }
        }, {
            key: "textureCoord0",
            get: function() {
                return this._textureCoord0;
            }
        }, {
            key: "textureCoord1",
            get: function() {
                return this._textureCoord1;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTerrain._vertexDeclaration;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                VertexPositionTerrain._vertexDeclaration = new je(40, [ new Ze(0, Ye.Vector3, VertexPositionTerrain.TERRAIN_POSITION0), new Ze(12, Ye.Vector3, VertexPositionTerrain.TERRAIN_NORMAL0), new Ze(24, Ye.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0), new Ze(32, Ye.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1) ]);
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return VertexPositionTerrain._vertexDeclaration;
            }
        } ]), VertexPositionTerrain;
    }();
    cr.TERRAIN_POSITION0 = 0, cr.TERRAIN_NORMAL0 = 1, cr.TERRAIN_TEXTURECOORDINATE0 = 2, 
    cr.TERRAIN_TEXTURECOORDINATE1 = 3;
    var hr = function BulletInteractive() {
        _classCallCheck(this, BulletInteractive);
    };
    hr._interactive = {
        getWorldTransform: function(e, t) {},
        setWorldTransform: function(e, t) {
            var n = S._physicObjectsMap[e];
            n._simulation._updatedRigidbodies++, n._updateTransformComponent(t);
        }
    };
    var _r = function(e) {
        function PhysicsCollider() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m.COLLISIONFILTERGROUP_DEFAULTFILTER, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, PhysicsCollider), (e = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsCollider).call(this, t, n)))._enableProcessCollisions = !1, 
            e;
        }
        return _inherits(PhysicsCollider, N), _createClass(PhysicsCollider, [ {
            key: "_addToSimulation",
            value: function() {
                this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removePhysicsCollider(this);
            }
        }, {
            key: "_parse",
            value: function(e) {
                null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
                null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
                _get(_getPrototypeOf(PhysicsCollider.prototype), "_parse", this).call(this, e), 
                this._parseShape(e.shapes);
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = k._bullet, t = e.btCollisionObject_create();
                e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_forceActivationState(t, S.ACTIVATIONSTATE_DISABLE_SIMULATION);
                var n = e.btCollisionObject_getCollisionFlags(t);
                this.owner.isStatic ? ((n & S.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (n ^= S.COLLISIONFLAGS_KINEMATIC_OBJECT), 
                n |= S.COLLISIONFLAGS_STATIC_OBJECT) : ((n & S.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (n ^= S.COLLISIONFLAGS_STATIC_OBJECT), 
                n |= S.COLLISIONFLAGS_KINEMATIC_OBJECT), e.btCollisionObject_setCollisionFlags(t, n), 
                this._btColliderObject = t, _get(_getPrototypeOf(PhysicsCollider.prototype), "_onAdded", this).call(this);
            }
        } ]), PhysicsCollider;
    }(), dr = function(n) {
        function SubMesh(e) {
            var t;
            return _classCallCheck(this, SubMesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(SubMesh).call(this)))._id = ++SubMesh._uniqueIDCounter, 
            t._mesh = e, t._boneIndicesList = [], t._subIndexBufferStart = [], t._subIndexBufferCount = [], 
            t;
        }
        return _inherits(SubMesh, Lt), _createClass(SubMesh, [ {
            key: "_setIndexRange",
            value: function(e, t) {
                this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * e, t);
            }
        }, {
            key: "_getType",
            value: function() {
                return SubMesh._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._mesh._uploadVerticesData(), !0;
            }
        }, {
            key: "_render",
            value: function(n) {
                var r = this._mesh;
                if (r.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance.supportElementIndexUint32()) {
                    var i, a, o = t.LayaGL.instance, s = n.renderElement.render._skinnedData;
                    switch (r.indexFormat) {
                      case e.IndexFormat.UInt32:
                        i = o.UNSIGNED_INT, a = 4;
                        break;

                      case e.IndexFormat.UInt16:
                        i = o.UNSIGNED_SHORT, a = 2;
                        break;

                      case e.IndexFormat.UInt8:
                        i = o.UNSIGNED_BYTE, a = 1;
                    }
                    if (r._bufferState.bind(), s) for (var l = s[this._indexInMesh], u = 0, c = this._boneIndicesList.length; u < c; u++) n.shader.uploadCustomUniform(tr.BONES, l[u]), 
                    o.drawElements(o.TRIANGLES, this._subIndexBufferCount[u], i, this._subIndexBufferStart[u] * a); else o.drawElements(o.TRIANGLES, this._indexCount, i, this._indexStart * a);
                    t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++;
                } else console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
            }
        }, {
            key: "getIndices",
            value: function() {
                if (this._mesh._isReadable) return this._indices.slice();
                throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function(e) {
                this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (_get(_getPrototypeOf(SubMesh.prototype), "destroy", this).call(this), 
                this._indexBuffer.destroy(), this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null, 
                this._subIndexBufferStart = null, this._subIndexBufferCount = null, this._skinAnimationDatas = null);
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexCount;
            }
        } ]), SubMesh;
    }();
    dr._uniqueIDCounter = 0, dr._type = Lt._typeCounter++;
    var fr = function skinnedMatrixCache(e, t, n) {
        _classCallCheck(this, skinnedMatrixCache), this.subMeshIndex = e, this.batchIndex = t, 
        this.batchBoneIndex = n;
    }, mr = function(n) {
        function Mesh() {
            var t, n = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            return _classCallCheck(this, Mesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)))._tempVector30 = new o(), 
            t._tempVector31 = new o(), t._tempVector32 = new o(), t._minVerticesUpdate = -1, 
            t._maxVerticesUpdate = -1, t._needUpdateBounds = !0, t._bounds = new xt(new o(), new o()), 
            t._bufferState = new We(), t._instanceBufferState = new We(), t._vertexBuffer = null, 
            t._indexBuffer = null, t._skinnedMatrixCaches = [], t._vertexCount = 0, t._indexFormat = e.IndexFormat.UInt16, 
            t._isReadable = n, t._subMeshes = [], t;
        }
        return _inherits(Mesh, t.Resource), _createClass(Mesh, [ {
            key: "_getPositionElement",
            value: function(e) {
                for (var t = e.vertexDeclaration._vertexElements, n = 0, r = t.length; n < r; n++) {
                    var i = t[n];
                    if (i._elementFormat === Ye.Vector3 && i._elementUsage === Qe.MESH_POSITION0) return i;
                }
                return null;
            }
        }, {
            key: "_getVerticeElementData",
            value: function(e, t) {
                e.length = this._vertexCount;
                var n = this._vertexBuffer.vertexDeclaration, a = n.getVertexElementByUsage(t);
                if (a) {
                    var s = this._vertexBuffer.getUint8Data(), l = this._vertexBuffer.getFloat32Data(), u = n.vertexStride, c = u / 4, h = a._offset, _ = h / 4;
                    switch (t) {
                      case Qe.MESH_TEXTURECOORDINATE0:
                      case Qe.MESH_TEXTURECOORDINATE1:
                        for (var d = 0; d < this._vertexCount; d++) {
                            var f = c * d + _;
                            e[d] = new r(l[f], l[f + 1]);
                        }
                        break;

                      case Qe.MESH_POSITION0:
                      case Qe.MESH_NORMAL0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new o(l[f], l[f + 1], l[f + 2]);
                        }
                        break;

                      case Qe.MESH_TANGENT0:
                      case Qe.MESH_BLENDWEIGHT0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new i(l[f], l[f + 1], l[f + 2], l[f + 3]);
                        }
                        break;

                      case Qe.MESH_COLOR0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = c * d + _;
                            e[d] = new Me(l[f], l[f + 1], l[f + 2], l[f + 3]);
                        }
                        break;

                      case Qe.MESH_BLENDINDICES0:
                        for (d = 0; d < this._vertexCount; d++) {
                            f = u * d + h;
                            e[d] = new i(s[f], s[f + 1], s[f + 2], s[f + 3]);
                        }
                        break;

                      default:
                        throw "Mesh:Unknown elementUsage.";
                    }
                }
            }
        }, {
            key: "_setVerticeElementData",
            value: function(e, t) {
                var n = this._vertexBuffer.vertexDeclaration, r = n.getVertexElementByUsage(t);
                if (r) {
                    var i = this._vertexBuffer.getUint8Data(), a = this._vertexBuffer.getFloat32Data(), o = n.vertexStride, s = o / 4, l = r._offset, u = l / 4;
                    switch (t) {
                      case Qe.MESH_TEXTURECOORDINATE0:
                      case Qe.MESH_TEXTURECOORDINATE1:
                        for (var c = 0, h = e.length; c < h; c++) {
                            var _ = s * c + u, d = e[c];
                            a[_] = d.x, a[_ + 1] = d.y;
                        }
                        break;

                      case Qe.MESH_POSITION0:
                      case Qe.MESH_NORMAL0:
                        for (c = 0, h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var f = e[c];
                            a[_] = f.x, a[_ + 1] = f.y, a[_ + 2] = f.z;
                        }
                        break;

                      case Qe.MESH_TANGENT0:
                      case Qe.MESH_BLENDWEIGHT0:
                        for (c = 0, h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var m = e[c];
                            a[_] = m.x, a[_ + 1] = m.y, a[_ + 2] = m.z, a[_ + 3] = m.w;
                        }
                        break;

                      case Qe.MESH_COLOR0:
                        for (c = 0, h = e.length; c < h; c++) {
                            _ = s * c + u;
                            var T = e[c];
                            a[_] = T.r, a[_ + 1] = T.g, a[_ + 2] = T.b, a[_ + 3] = T.a;
                        }
                        break;

                      case Qe.MESH_BLENDINDICES0:
                        for (c = 0, h = e.length; c < h; c++) {
                            _ = o * c + l, m = e[c];
                            i[_] = m.x, i[_ + 1] = m.y, i[_ + 2] = m.z, i[_ + 3] = m.w;
                        }
                        break;

                      default:
                        throw "Mesh:Unknown elementUsage.";
                    }
                    this._minVerticesUpdate = 0, this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
                } else console.warn("Mesh: the mesh don't have  this VertexElement.");
            }
        }, {
            key: "_disposeResource",
            value: function() {
                for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e].destroy();
                this._btTriangleMesh && k._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh), 
                this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._bufferState.destroy(), 
                this._instanceBufferState.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), 
                this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null, 
                this._indexBuffer = null, this._subMeshes = null, this._btTriangleMesh = null, this._indexBuffer = null, 
                this._boneNames = null, this._inverseBindPoses = null;
            }
        }, {
            key: "_setSubMeshes",
            value: function(e) {
                this._subMeshes = e;
                for (var t = 0, n = e.length; t < n; t++) e[t]._indexInMesh = t;
            }
        }, {
            key: "_setBuffer",
            value: function(e, t) {
                var n = this._bufferState;
                n.bind(), n.applyVertexBuffer(e), n.applyIndexBuffer(t), n.unBind();
                var r = this._instanceBufferState;
                r.bind(), r.applyVertexBuffer(e), r.applyInstanceVertexBuffer(bt.instance.instanceWorldMatrixBuffer), 
                r.applyInstanceVertexBuffer(bt.instance.instanceMVPMatrixBuffer), r.applyIndexBuffer(t), 
                r.unBind();
            }
        }, {
            key: "_getPhysicMesh",
            value: function() {
                if (!this._btTriangleMesh) {
                    for (var e = k._bullet, t = e.btTriangleMesh_create(), n = Mesh._nativeTempVector30, r = Mesh._nativeTempVector31, i = Mesh._nativeTempVector32, a = this._tempVector30, o = this._tempVector31, s = this._tempVector32, l = this._vertexBuffer, u = this._getPositionElement(l), c = l.getFloat32Data(), h = l.vertexDeclaration.vertexStride / 4, _ = u._offset / 4, d = this._indexBuffer.getData(), f = 0, m = d.length; f < m; f += 3) {
                        var T = d[f] * h + _, p = d[f + 1] * h + _, g = d[f + 2] * h + _;
                        a.setValue(c[T], c[T + 1], c[T + 2]), o.setValue(c[p], c[p + 1], c[p + 2]), s.setValue(c[g], c[g + 1], c[g + 2]), 
                        O._convertToBulletVec3(a, n, !0), O._convertToBulletVec3(o, r, !0), O._convertToBulletVec3(s, i, !0), 
                        e.btTriangleMesh_addTriangle(t, n, r, i, !0);
                    }
                    this._btTriangleMesh = t;
                }
                return this._btTriangleMesh;
            }
        }, {
            key: "_uploadVerticesData",
            value: function() {
                var e = this._minVerticesUpdate, t = this._maxVerticesUpdate;
                if (-1 !== e && -1 !== t) {
                    var n = e;
                    this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, n, n, t - e), 
                    this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1;
                }
            }
        }, {
            key: "getSubMesh",
            value: function(e) {
                return this._subMeshes[e];
            }
        }, {
            key: "getPositions",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get positions on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_POSITION0);
            }
        }, {
            key: "setPositions",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_POSITION0), this._needUpdateBounds = !0;
            }
        }, {
            key: "getColors",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_COLOR0);
            }
        }, {
            key: "setColors",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setColors() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_COLOR0);
            }
        }, {
            key: "getUVs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!this._isReadable) throw "Mesh:can't get uvs on mesh,isReadable must be true.";
                switch (t) {
                  case 0:
                    this._getVerticeElementData(e, Qe.MESH_TEXTURECOORDINATE0);
                    break;

                  case 1:
                    this._getVerticeElementData(e, Qe.MESH_TEXTURECOORDINATE1);
                    break;

                  default:
                    throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "setUVs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!this._isReadable) throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
                switch (t) {
                  case 0:
                    this._setVerticeElementData(e, Qe.MESH_TEXTURECOORDINATE0);
                    break;

                  case 1:
                    this._setVerticeElementData(e, Qe.MESH_TEXTURECOORDINATE1);
                    break;

                  default:
                    throw "Mesh:Invalid channel.";
                }
            }
        }, {
            key: "getNormals",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_NORMAL0);
            }
        }, {
            key: "setNormals",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setNormals() need must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_NORMAL0);
            }
        }, {
            key: "getTangents",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_TANGENT0);
            }
        }, {
            key: "setTangents",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_TANGENT0);
            }
        }, {
            key: "getBoneWeights",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "setBoneWeights",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_BLENDWEIGHT0);
            }
        }, {
            key: "getBoneIndices",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
                this._getVerticeElementData(e, Qe.MESH_BLENDINDICES0);
            }
        }, {
            key: "setBoneIndices",
            value: function(e) {
                if (!this._isReadable) throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
                this._setVerticeElementData(e, Qe.MESH_BLENDINDICES0);
            }
        }, {
            key: "markAsUnreadbale",
            value: function() {
                this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1;
            }
        }, {
            key: "getVertexDeclaration",
            value: function() {
                return this._vertexBuffer._vertexDeclaration;
            }
        }, {
            key: "getVertices",
            value: function() {
                if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
                throw "Mesh:can't get vertices on mesh,isReadable must be true.";
            }
        }, {
            key: "setVertices",
            value: function(e) {
                this._vertexBuffer.setData(e), this._needUpdateBounds = !0;
            }
        }, {
            key: "getIndices",
            value: function() {
                if (this._isReadable) return this._indexBuffer.getData().slice();
                throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
            }
        }, {
            key: "setIndices",
            value: function(n) {
                var r;
                n instanceof Uint32Array ? r = e.IndexFormat.UInt32 : n instanceof Uint16Array ? r = e.IndexFormat.UInt16 : n instanceof Uint8Array && (r = e.IndexFormat.UInt8);
                var i = this._indexBuffer;
                this._indexFormat === r && i.indexCount === n.length || (i.destroy(), this._indexBuffer = i = new Xe(r, n.length, t.LayaGL.instance.STATIC_DRAW, this._isReadable)), 
                i.setData(n), this._indexFormat = r;
            }
        }, {
            key: "calculateBounds",
            value: function() {
                if (!this._isReadable) throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
                if (this._needUpdateBounds) {
                    var e = this._tempVector30, t = this._tempVector31;
                    e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
                    for (var n = this._vertexBuffer, r = this._getPositionElement(n), i = n.getFloat32Data(), a = n.vertexDeclaration.vertexStride / 4, o = r._offset / 4, s = 0, l = i.length; s < l; s += a) {
                        var u = s + o, c = i[u], h = i[u + 1], _ = i[u + 2];
                        e.x = Math.min(e.x, c), e.y = Math.min(e.y, h), e.z = Math.min(e.z, _), t.x = Math.max(t.x, c), 
                        t.y = Math.max(t.y, h), t.z = Math.max(t.z, _);
                    }
                    this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1;
                }
            }
        }, {
            key: "cloneTo",
            value: function(t) {
                var n = t, r = this._vertexBuffer, i = new qe(r._byteLength, r.bufferUsage, r.canRead);
                i.vertexDeclaration = r.vertexDeclaration, i.setData(r.getUint8Data().slice().buffer), 
                n._vertexBuffer = i, n._vertexCount = this._vertexCount;
                var a, o = this._indexBuffer, s = new Xe(e.IndexFormat.UInt16, o.indexCount, o.bufferUsage, o.canRead);
                s.setData(o.getData().slice()), n._indexBuffer = s, n._setBuffer(n._vertexBuffer, s), 
                n._setCPUMemory(this.cpuMemory), n._setGPUMemory(this.gpuMemory);
                var l = this._boneNames;
                if (l) {
                    var u = n._boneNames = [];
                    for (a = 0; a < l.length; a++) u[a] = l[a];
                }
                var c = this._inverseBindPoses;
                if (c) {
                    var h = n._inverseBindPoses = [];
                    for (a = 0; a < c.length; a++) h[a] = c[a];
                }
                var _ = this._skinnedMatrixCaches.length;
                for (n._skinnedMatrixCaches.length = _, a = 0; a < _; a++) {
                    var d = this._skinnedMatrixCaches[a];
                    n._skinnedMatrixCaches[a] = new fr(d.subMeshIndex, d.batchIndex, d.batchBoneIndex);
                }
                for (a = 0; a < this.subMeshCount; a++) {
                    var f = this._subMeshes[a], m = f._subIndexBufferStart, T = f._subIndexBufferCount, p = f._boneIndicesList, g = new dr(n);
                    g._subIndexBufferStart.length = m.length, g._subIndexBufferCount.length = T.length, 
                    g._boneIndicesList.length = p.length;
                    for (var E = 0; E < m.length; E++) g._subIndexBufferStart[E] = m[E];
                    for (E = 0; E < T.length; E++) g._subIndexBufferCount[E] = T[E];
                    for (E = 0; E < p.length; E++) g._boneIndicesList[E] = new Uint16Array(p[E]);
                    g._indexBuffer = s, g._indexStart = f._indexStart, g._indexCount = f._indexCount, 
                    g._indices = new Uint16Array(s.getData().buffer, 2 * f._indexStart, f._indexCount);
                    var y = n._vertexBuffer;
                    g._vertexBuffer = y, n._subMeshes.push(g);
                }
                n._setSubMeshes(n._subMeshes);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Mesh();
                return this.cloneTo(e), e;
            }
        }, {
            key: "inverseAbsoluteBindPoses",
            get: function() {
                return this._inverseBindPoses;
            }
        }, {
            key: "vertexCount",
            get: function() {
                return this._vertexCount;
            }
        }, {
            key: "indexCount",
            get: function() {
                return this._indexBuffer.indexCount;
            }
        }, {
            key: "subMeshCount",
            get: function() {
                return this._subMeshes.length;
            }
        }, {
            key: "bounds",
            get: function() {
                return this._bounds;
            },
            set: function(e) {
                this._bounds !== e && e.cloneTo(this._bounds);
            }
        }, {
            key: "indexFormat",
            get: function() {
                return this._indexFormat;
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = k._bullet;
                e && (Mesh._nativeTempVector30 = e.btVector3_create(0, 0, 0), Mesh._nativeTempVector31 = e.btVector3_create(0, 0, 0), 
                Mesh._nativeTempVector32 = e.btVector3_create(0, 0, 0));
            }
        }, {
            key: "load",
            value: function(e, n) {
                t.ILaya.loader.create(e, n, null, Mesh.MESH);
            }
        } ]), Mesh;
    }();
    mr.MESH = "MESH";
    var Tr = function() {
        function PrimitiveMesh() {
            _classCallCheck(this, PrimitiveMesh);
        }
        return _createClass(PrimitiveMesh, null, [ {
            key: "__init__",
            value: function() {}
        }, {
            key: "_createMesh",
            value: function(n, r, i) {
                var a = t.LayaGL.instance, o = new mr(), s = new dr(o), l = new qe(4 * r.length, a.STATIC_DRAW, !0);
                l.vertexDeclaration = n, l.setData(r.buffer), o._vertexBuffer = l, o._vertexCount = l._byteLength / n.vertexStride;
                var u = new Xe(e.IndexFormat.UInt16, i.length, a.STATIC_DRAW, !0);
                u.setData(i), o._indexBuffer = u, o._setBuffer(l, u), s._vertexBuffer = l, s._indexBuffer = u, 
                s._setIndexRange(0, u.indexCount);
                var c = s._subIndexBufferStart, h = s._subIndexBufferCount, _ = s._boneIndicesList;
                c.length = 1, h.length = 1, _.length = 1, c[0] = 0, h[0] = u.indexCount;
                var d = [];
                d.push(s), o._setSubMeshes(d), o.calculateBounds();
                var f = l._byteLength + u._byteLength;
                return o._setCPUMemory(f), o._setGPUMemory(f), o;
            }
        }, {
            key: "createBox",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, r = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), i = e / 2, a = t / 2, o = n / 2, s = new Float32Array([ -i, a, -o, 0, 1, 0, 0, 0, i, a, -o, 0, 1, 0, 1, 0, i, a, o, 0, 1, 0, 1, 1, -i, a, o, 0, 1, 0, 0, 1, -i, -a, -o, 0, -1, 0, 0, 1, i, -a, -o, 0, -1, 0, 1, 1, i, -a, o, 0, -1, 0, 1, 0, -i, -a, o, 0, -1, 0, 0, 0, -i, a, -o, -1, 0, 0, 0, 0, -i, a, o, -1, 0, 0, 1, 0, -i, -a, o, -1, 0, 0, 1, 1, -i, -a, -o, -1, 0, 0, 0, 1, i, a, -o, 1, 0, 0, 1, 0, i, a, o, 1, 0, 0, 0, 0, i, -a, o, 1, 0, 0, 0, 1, i, -a, -o, 1, 0, 0, 1, 1, -i, a, o, 0, 0, 1, 0, 0, i, a, o, 0, 0, 1, 1, 0, i, -a, o, 0, 0, 1, 1, 1, -i, -a, o, 0, 0, 1, 0, 1, -i, a, -o, 0, 0, -1, 1, 0, i, a, -o, 0, 0, -1, 0, 0, i, -a, -o, 0, 0, -1, 0, 1, -i, -a, -o, 0, 0, -1, 1, 1 ]), l = new Uint16Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20 ]);
                return PrimitiveMesh._createMesh(r, s, l);
            }
        }, {
            key: "createCapsule",
            value: function() {
                var e, t, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32, o = (i + 1) * (a + 1) * 2 + 2 * (a + 1), s = 3 * i * (a + 1) * 2 * 2 + 2 * a * 3, l = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), u = l.vertexStride / 4, c = new Float32Array(o * u), h = new Uint16Array(s), _ = Math.PI / 2 / i, d = 2 * Math.PI / a, f = r / 2 - n, m = 0, T = 0, p = 0, g = 0, E = 0, y = 0;
                for (e = 0; e <= i; e++) for (t = 0; t <= a; t++) m = n * Math.cos(e * _) * Math.cos(t * d + Math.PI), 
                T = n * Math.sin(e * _), p = n * Math.cos(e * _) * Math.sin(t * d + Math.PI), c[g++] = m, 
                c[g++] = T + f, c[g++] = p, c[g++] = m, c[g++] = T, c[g++] = p, c[g++] = 1 - t / a, 
                c[g++] = (1 - e / i) * (Math.PI * n / 2 / (r + Math.PI * n)), e < i && (h[E++] = e * (a + 1) + t + (a + 1), 
                h[E++] = e * (a + 1) + t, h[E++] = e * (a + 1) + t + 1, h[E++] = e * (a + 1) + t + a, 
                h[E++] = e * (a + 1) + t, h[E++] = e * (a + 1) + t + (a + 1));
                for (y += (i + 1) * (a + 1), e = 0; e <= i; e++) for (t = 0; t <= a; t++) m = n * Math.cos(e * _) * Math.cos(t * d + Math.PI), 
                T = n * Math.sin(-e * _), p = n * Math.cos(e * _) * Math.sin(t * d + Math.PI), c[g++] = m, 
                c[g++] = T - f, c[g++] = p, c[g++] = m, c[g++] = T, c[g++] = p, c[g++] = 1 - t / a, 
                c[g++] = (e / i * (Math.PI * n / 2) + (r + Math.PI * n / 2)) / (r + Math.PI * n), 
                e < i && (h[E++] = y + e * (a + 1) + t, h[E++] = y + e * (a + 1) + t + (a + 1), 
                h[E++] = y + e * (a + 1) + t + 1, h[E++] = y + e * (a + 1) + t, h[E++] = y + e * (a + 1) + t + a, 
                h[E++] = y + e * (a + 1) + t + (a + 1));
                for (y += (i + 1) * (a + 1), t = 0; t <= a; t++) m = n * Math.cos(t * d + Math.PI), 
                T = f, p = n * Math.sin(t * d + Math.PI), c[g++] = m, c[g + 8 * (a + 1) - 1] = m, 
                c[g++] = T, c[g + 8 * (a + 1) - 1] = -T, c[g++] = p, c[g + 8 * (a + 1) - 1] = p, 
                c[g++] = m, c[g + 8 * (a + 1) - 1] = m, c[g++] = 0, c[g + 8 * (a + 1) - 1] = 0, 
                c[g++] = p, c[g + 8 * (a + 1) - 1] = p, c[g++] = 1 - 1 * t / a, c[g + 8 * (a + 1) - 1] = 1 - 1 * t / a, 
                c[g++] = Math.PI * n / 2 / (r + Math.PI * n), c[g + 8 * (a + 1) - 1] = (Math.PI * n / 2 + r) / (r + Math.PI * n);
                for (t = 0; t < a; t++) h[E++] = t + y + (a + 1), h[E++] = t + y + 1, h[E++] = t + y, 
                h[E++] = t + y + (a + 1), h[E++] = t + y + (a + 1) + 1, h[E++] = t + y + 1;
                return y += 2 * (a + 1), PrimitiveMesh._createMesh(l, c, h);
            }
        }, {
            key: "createCone",
            value: function() {
                for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, i = r + 1 + 1 + 2 * (r + 1), a = 6 * r + 3 * r, s = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), l = s.vertexStride / 4, c = new Float32Array(i * l), h = new Uint16Array(a), _ = 2 * Math.PI / r, d = n / 2, f = 0, m = 0, T = 0, p = 0, g = 0, E = new o(), y = new o(0, -1, 0), v = new o(0, d, 0), S = new o(), C = new o(), R = new u(), D = new o(), M = 0, A = 0, x = 0; x <= r; x++) f = x * _, 
                T = Math.cos(f + Math.PI) * t, p = d, g = Math.sin(f + Math.PI) * t, c[M++] = 0, 
                c[M + 8 * (r + 1) - 1] = T, c[M++] = p, c[M + 8 * (r + 1) - 1] = -p, c[M++] = 0, 
                c[M + 8 * (r + 1) - 1] = g, E.x = T, E.y = 0, E.z = g, S.x = T, S.y = -p, S.z = g, 
                o.subtract(S, v, C), o.normalize(C, C), e = Math.acos(o.dot(y, C)), o.cross(y, C, D), 
                o.normalize(D, D), u.createFromAxisAngle(D, e, R), o.normalize(E, E), o.transformQuat(E, R, E), 
                o.normalize(E, E), c[M++] = E.x, c[M + 8 * (r + 1) - 1] = E.x, c[M++] = E.y, c[M + 8 * (r + 1) - 1] = E.y, 
                c[M++] = E.z, c[M + 8 * (r + 1) - 1] = E.z, c[M++] = 1 - 1 * x / r, c[M + 8 * (r + 1) - 1] = 1 - 1 * x / r, 
                c[M++] = 0, c[M + 8 * (r + 1) - 1] = 1;
                M += 8 * (r + 1);
                for (var L = 0; L < r; L++) h[A++] = L + m + (r + 1), h[A++] = L + m + 1, h[A++] = L + m, 
                h[A++] = L + m + (r + 1), h[A++] = L + m + (r + 1) + 1, h[A++] = L + m + 1;
                m += 2 * (r + 1);
                for (var I = 0; I <= r; I++) 0 === I && (c[M++] = 0, c[M++] = -d, c[M++] = 0, c[M++] = 0, 
                c[M++] = -1, c[M++] = 0, c[M++] = .5, c[M++] = .5), f = I * _, T = Math.cos(f + Math.PI) * t, 
                p = -d, g = Math.sin(f + Math.PI) * t, c[M++] = T, c[M++] = p, c[M++] = g, c[M++] = 0, 
                c[M++] = -1, c[M++] = 0, c[M++] = .5 + .5 * Math.cos(f), c[M++] = .5 + .5 * Math.sin(f);
                for (var O = 0; O < r; O++) h[A++] = 0 + m, h[A++] = O + 2 + m, h[A++] = O + 1 + m;
                return m += r + 1 + 1, PrimitiveMesh._createMesh(s, c, h);
            }
        }, {
            key: "createCylinder",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, r = n + 1 + 1 + 2 * (n + 1) + (n + 1 + 1), i = 3 * n + 6 * n + 3 * n, a = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(r * o), l = new Uint16Array(i), u = 2 * Math.PI / n, c = t / 2, h = 0, _ = 0, d = 0, f = 0, m = 0, T = 0, p = 0, g = 0; g <= n; g++) 0 === g && (s[T++] = 0, 
                s[T++] = c, s[T++] = 0, s[T++] = 0, s[T++] = 1, s[T++] = 0, s[T++] = .5, s[T++] = .5), 
                h = g * u, d = Math.cos(h) * e, f = c, m = Math.sin(h) * e, s[T++] = d, s[T++] = f, 
                s[T++] = m, s[T++] = 0, s[T++] = 1, s[T++] = 0, s[T++] = .5 + .5 * Math.cos(h), 
                s[T++] = .5 + .5 * Math.sin(h);
                for (var E = 0; E < n; E++) l[p++] = 0, l[p++] = E + 1, l[p++] = E + 2;
                _ += n + 1 + 1;
                for (var y = 0; y <= n; y++) h = y * u, d = Math.cos(h + Math.PI) * e, f = c, m = Math.sin(h + Math.PI) * e, 
                s[T++] = d, s[T + 8 * (n + 1) - 1] = d, s[T++] = f, s[T + 8 * (n + 1) - 1] = -f, 
                s[T++] = m, s[T + 8 * (n + 1) - 1] = m, s[T++] = d, s[T + 8 * (n + 1) - 1] = d, 
                s[T++] = 0, s[T + 8 * (n + 1) - 1] = 0, s[T++] = m, s[T + 8 * (n + 1) - 1] = m, 
                s[T++] = 1 - 1 * y / n, s[T + 8 * (n + 1) - 1] = 1 - 1 * y / n, s[T++] = 0, s[T + 8 * (n + 1) - 1] = 1;
                T += 8 * (n + 1);
                for (var v = 0; v < n; v++) l[p++] = v + _ + (n + 1), l[p++] = v + _ + 1, l[p++] = v + _, 
                l[p++] = v + _ + (n + 1), l[p++] = v + _ + (n + 1) + 1, l[p++] = v + _ + 1;
                _ += 2 * (n + 1);
                for (var S = 0; S <= n; S++) 0 === S && (s[T++] = 0, s[T++] = -c, s[T++] = 0, s[T++] = 0, 
                s[T++] = -1, s[T++] = 0, s[T++] = .5, s[T++] = .5), h = S * u, d = Math.cos(h + Math.PI) * e, 
                f = -c, m = Math.sin(h + Math.PI) * e, s[T++] = d, s[T++] = f, s[T++] = m, s[T++] = 0, 
                s[T++] = -1, s[T++] = 0, s[T++] = .5 + .5 * Math.cos(h), s[T++] = .5 + .5 * Math.sin(h);
                for (var C = 0; C < n; C++) l[p++] = 0 + _, l[p++] = C + 2 + _, l[p++] = C + 1 + _;
                return _ += n + 1 + 1, PrimitiveMesh._createMesh(a, s, l);
            }
        }, {
            key: "createPlane",
            value: function() {
                for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10, i = (n + 1) * (r + 1), a = new Uint16Array(n * r * 2 * 3), o = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(i * s), u = e / 2, c = t / 2, h = e / n, _ = t / r, d = 0, f = 0; f <= r; f++) for (var m = 0; m <= n; m++) l[d++] = m * h - u, 
                l[d++] = 0, l[d++] = f * _ - c, l[d++] = 0, l[d++] = 1, l[d++] = 0, l[d++] = 1 * m / n, 
                l[d++] = 1 * f / r;
                var T = 0;
                for (f = 0; f < r; f++) for (m = 0; m < n; m++) a[T++] = (f + 1) * (n + 1) + m, 
                a[T++] = f * (n + 1) + m, a[T++] = (f + 1) * (n + 1) + m + 1, a[T++] = f * (n + 1) + m, 
                a[T++] = f * (n + 1) + m + 1, a[T++] = (f + 1) * (n + 1) + m + 1;
                return PrimitiveMesh._createMesh(o, l, a);
            }
        }, {
            key: "createQuad",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), r = e / 2, i = t / 2, a = new Float32Array([ -r, i, 0, 0, 0, 1, 0, 0, r, i, 0, 0, 0, 1, 1, 0, -r, -i, 0, 0, 0, 1, 0, 1, r, -i, 0, 0, 0, 1, 1, 1 ]), o = new Uint16Array([ 0, 1, 2, 3, 2, 1 ]);
                return PrimitiveMesh._createMesh(n, a, o);
            }
        }, {
            key: "createSphere",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, r = (t + 1) * (n + 1), i = 3 * t * (n + 1) * 2, a = new Uint16Array(i), o = Qe.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(r * s), u = Math.PI / t, c = 2 * Math.PI / n, h = 0;
                r = 0, i = 0;
                for (var _ = 0; _ < t + 1; _++) for (var d = Math.sin(_ * u), f = Math.cos(_ * u), m = 0; m < n + 1; m++) {
                    var T = d * Math.sin(m * c + 1 * Math.PI / 2), p = d * Math.cos(m * c + 1 * Math.PI / 2);
                    l[r + 0] = T * e, l[r + 1] = f * e, l[r + 2] = p * e, l[r + 3] = T, l[r + 4] = f, 
                    l[r + 5] = p, l[r + 6] = m / n, l[r + 7] = _ / t, r += s, _ != t - 1 && (a[i++] = h + (n + 1), 
                    a[i++] = h, a[i++] = h + 1, a[i++] = h + n, a[i++] = h, a[i++] = h + (n + 1), h++);
                }
                return PrimitiveMesh._createMesh(o, l, a);
            }
        } ]), PrimitiveMesh;
    }(), pr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', gr = function() {
        function ShaderInit3D() {
            _classCallCheck(this, ShaderInit3D);
        }
        return _createClass(ShaderInit3D, null, [ {
            key: "__init__",
            value: function() {
                ue.SHADERDEFINE_LEGACYSINGALLIGHTING = ue.getDefineByName("LEGACYSINGLELIGHTING"), 
                ue.SHADERDEFINE_GRAPHICS_API_GLES2 = ue.getDefineByName("GRAPHICS_API_GLES2"), ue.SHADERDEFINE_GRAPHICS_API_GLES3 = ue.getDefineByName("GRAPHICS_API_GLES3"), 
                ue.addInclude("Lighting.glsl", "#ifdef GRAPHICS_API_GLES3\r\n\t#define INVERSE_MAT(mat) inverse(mat)\r\n#else\r\n\t#define INVERSE_MAT(mat) inverseMat(mat)\r\n#endif\r\n\r\nstruct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\n#ifndef GRAPHICS_API_GLES3\r\n\tmat3 inverseMat(mat3 m) {\r\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n\t\tfloat b01 = a22 * a11 - a12 * a21;\r\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\r\n\t\tfloat b21 = a21 * a10 - a11 * a20;\r\n\r\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n\t}\r\n#endif\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else //pixelComponent==3\r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = lightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n"), 
                ue.addInclude("ShadowSampleTent.glsl", '// ------------------------------------------------------------------\r\n//  PCF Filtering Tent Functions\r\n// ------------------------------------------------------------------\r\n\r\n// Assuming a isoceles right angled triangle of height "triangleHeight" (as drawn below).\r\n// This function return the area of the triangle above the first texel(in Y the first texel).\r\n//\r\n// |\\      <-- 45 degree slop isosceles right angled triangle\r\n// | \\\r\n// ----    <-- length of this side is "triangleHeight"\r\n// _ _ _ _ <-- texels\r\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight)\r\n{\r\n    return triangleHeight - 0.5;\r\n}\r\n\r\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\r\n// This function return the area of the triangle above each of those texels.\r\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\r\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\r\n//  /   \\\r\n// _ _ _ _ <-- texels\r\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut)\r\n{\r\n    // Compute the exterior areas,a and h is same.\r\n    float a = offset + 0.5;\r\n    float offsetSquaredHalved = a * a * 0.5;\r\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\r\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\r\n\r\n    // Compute the middle areas\r\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\r\n    // intersect the axis between Y and Z (ie where offset = 0).\r\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\r\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\r\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\r\n    float clampedOffsetLeft = min(offset,0.0);\r\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\r\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\r\n\r\n    // We do the same for the Z but with the right part of the isoceles triangle\r\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\r\n    float clampedOffsetRight = max(offset,0.0);\r\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\r\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\r\n}\r\n\r\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\r\n// This function return the weight of each texels area relative to the full triangle area.\r\n//  /       \\\r\n// _ _ _ _ _ _ <-- texels\r\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB)\r\n{\r\n    vec4 areaFrom3texelTriangle;\r\n    vec4 areaUncutFrom3texelTriangle;\r\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\r\n\r\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\r\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\r\n    // 0.16 is 1/(the triangle area)\r\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\r\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\r\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\r\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\r\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\r\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\r\n}\r\n\r\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\r\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\r\n{\r\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\r\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\r\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\r\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\r\n\r\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\r\n    vec3 texelsWeightsUA, texelsWeightsUB;\r\n    vec3 texelsWeightsVA, texelsWeightsVB;\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\r\n\r\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\r\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\r\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\r\n\r\n    // move the PCF bilinear fetches to respect texels weights\r\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\r\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\r\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\r\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\r\n\r\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\r\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\r\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\r\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\r\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\r\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\r\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\r\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\r\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\r\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\r\n\r\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\r\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\r\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\r\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\r\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\r\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\r\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\r\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\r\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\r\n}'), 
                ue.addInclude("GlobalIllumination.glsl", 'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\nmediump vec3 layaDecodeDirectionalLightmap (mediump vec3 color, lowp vec4 dirTex, mediump vec3 normalWorld)\r\n{\r\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\r\n    // in a way, that using it for half Lambert and then dividing by a "rebalancing coefficient"\r\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\r\n\r\n    // Note that dir is not unit length on purpose. Its length is "directionality", like\r\n    // for the directional specular lightmaps.\r\n\tlowp vec3 directional=dirTex.xyz - 0.5;\r\n\tdirectional.x=-directional.x;//NOTE:because coord System\r\n    mediump float halfLambert = dot(normalWorld,directional) + 0.5;\r\n\r\n    return color * halfLambert / max(1e-4, dirTex.w);\r\n}\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tmediump vec3 bakedColor =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\t\tlowp vec4 bakedDirTex = texture2D (u_LightMapDirection, giInput.lightmapUV);\r\n            indirectDiffuse = layaDecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);\r\n\t\t#else //unDirectional lightmap\r\n\t\t\tindirectDiffuse = bakedColor;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor; //already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n'), 
                ue.addInclude("Shadow.glsl", '#ifndef GRAPHICS_API_GLES3\r\n\t#define NO_NATIVE_SHADOWMAP\r\n#endif\r\n\r\n#ifdef NO_NATIVE_SHADOWMAP\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2D textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName,coord3.xy).r<coord3.z?0.0:1.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\r\n#else\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2DShadow textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName,coord3,0.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW)\r\n    #define CALCULATE_SHADOWS\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW_SPOT)\r\n\t#define CALCULATE_SPOTSHADOWS\r\n#endif\r\n\r\nuniform vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n\r\n#if defined(CALCULATE_SHADOWS)||defined(CALCULATE_SPOTSHADOWS)\r\n\t#include "ShadowSampleTent.glsl"\r\n\tuniform vec4 u_ShadowMapSize;\r\n\tuniform vec4 u_ShadowParams; // x: shadowStrength y: ShadowSpotLightStrength\r\n\r\n\t\r\n\tfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tvec4 attenuation4;\r\n\t\tvec2 offset=shadowMapSize.xy/2.0;\r\n\t\tvec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\r\n\t\tvec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\r\n\t\tvec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\r\n\t\tvec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\r\n\t\tattenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\r\n\t\tattenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\r\n\t\tattenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\r\n\t\tattenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\r\n\t\tattenuation = dot(attenuation4, vec4(0.25));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tfloat fetchesWeights[9];\r\n\t\tvec2 fetchesUV[9];\r\n\t\tsampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\r\n\t\tattenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\r\n\tTEXTURE2D_SHADOW(u_ShadowMap);\r\n\r\n\tuniform mat4 u_ShadowMatrices[4];\r\n\tuniform vec4 u_ShadowSplitSpheres[4];// max cascade is 4\r\n\r\n\tmediump int computeCascadeIndex(vec3 positionWS)\r\n\t{\r\n\t\tvec3 fromCenter0 = positionWS - u_ShadowSplitSpheres[0].xyz;\r\n\t\tvec3 fromCenter1 = positionWS - u_ShadowSplitSpheres[1].xyz;\r\n\t\tvec3 fromCenter2 = positionWS - u_ShadowSplitSpheres[2].xyz;\r\n\t\tvec3 fromCenter3 = positionWS - u_ShadowSplitSpheres[3].xyz;\r\n\r\n\t\tmediump vec4 comparison = vec4(\r\n\t\t\tdot(fromCenter0, fromCenter0)<u_ShadowSplitSpheres[0].w,\r\n\t\t\tdot(fromCenter1, fromCenter1)<u_ShadowSplitSpheres[1].w,\r\n\t\t\tdot(fromCenter2, fromCenter2)<u_ShadowSplitSpheres[2].w,\r\n\t\t\tdot(fromCenter3, fromCenter3)<u_ShadowSplitSpheres[3].w);\r\n\t\tcomparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\r\n\t\tmediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\r\n\t\tmediump int index = 4 - int(dot(comparison, indexCoefficient));\r\n\t\treturn index;\r\n\t}\r\n\r\n\tvec4 getShadowCoord(vec4 positionWS)\r\n\t{\r\n\t\t#ifdef SHADOW_CASCADE\r\n\t\t\tmediump int cascadeIndex = computeCascadeIndex(positionWS.xyz);\r\n\t\t\tif(cascadeIndex > 3)// out of shadow range cascadeIndex is 4.\r\n\t\t\t\treturn vec4(0.0);\r\n\t\t\t\r\n\t\t\t#ifdef GRAPHICS_API_GLES3\r\n\t\t\t\treturn u_ShadowMatrices[cascadeIndex] * positionWS;\r\n\t\t\t#else\r\n\t\t\t\tmat4 shadowMat;\r\n\t\t\t\tif(cascadeIndex == 0)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[0];\r\n\t\t\t\telse if(cascadeIndex == 1)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[1];\r\n\t\t\t\telse if(cascadeIndex == 2)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[2];\r\n\t\t\t\telse\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[3];\r\n\t\t\t\treturn shadowMat * positionWS;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\treturn u_ShadowMatrices[0] * positionWS;\r\n\t\t#endif\r\n\t}\r\n\r\n\tfloat sampleShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.x);//shadowParams.x:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\n#ifdef CALCULATE_SPOTSHADOWS\r\n\tTEXTURE2D_SHADOW(u_SpotShadowMap);\r\n\tuniform mat4 u_SpotViewProjectMatrix;\r\n\tfloat sampleSpotShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tshadowCoord.xy +=1.0;\r\n\t\tshadowCoord.xy/=2.0; \r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SPOT_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_SpotShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SPOT_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_SpotShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_SpotShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.y);//shadowParams.y:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\nvec3 applyShadowBias(vec3 positionWS, vec3 normalWS, vec3 lightDirection)\r\n{\r\n    float invNdotL = 1.0 - clamp(dot(-lightDirection, normalWS),0.0,1.0);\r\n    float scale = invNdotL * u_ShadowBias.y;\r\n\r\n    // normal bias is negative since we want to apply an inset normal offset\r\n    positionWS += -lightDirection * u_ShadowBias.xxx;\r\n    positionWS += normalWS * vec3(scale);\r\n    return positionWS;\r\n}\r\n'), 
                ue.addInclude("ShadowCasterVS.glsl", '#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform mat4 u_ViewProjection;\r\n\r\n#ifdef SHADOW\r\n\tuniform vec3 u_ShadowLightDirection;\r\n#endif\r\n\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nvec4 shadowCasterVertex()\r\n{\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\t\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tworldMat = worldMat * skinTransform;\r\n\t#endif\r\n\r\n\tvec4 positionWS = worldMat * a_Position;\r\n\tvec3 normalWS = normalize(a_Normal*INVERSE_MAT(mat3(worldMat)));//if no normalize will cause precision problem\r\n\r\n\t#ifdef SHADOW\r\n\t\tpositionWS.xyz = applyShadowBias(positionWS.xyz,normalWS,u_ShadowLightDirection);\r\n\t#endif\r\n\r\n\tvec4 positionCS = u_ViewProjection * positionWS;\r\n\t#ifdef SHADOW_SPOT\r\n\t\tpositionCS.z = positionCS.z-u_ShadowBias.x/positionCS.w;\r\n\t#endif\r\n\tpositionCS.z = max(positionCS.z, 0.0);//min ndc z is 0.0\r\n\t\r\n\t// //TODO没考虑UV动画呢\r\n\t// #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tv_Texcoord0=a_Texcoord0;\r\n\t// #endif\r\n    return positionCS;\r\n}\r\n'), 
                ue.addInclude("ShadowCasterFS.glsl", "// #ifdef ALPHATEST\r\n// \tuniform float u_AlphaTestValue;\r\n// #endif\r\n\r\n// #ifdef DIFFUSEMAP\r\n// \tuniform sampler2D u_DiffuseTexture;\r\n// #endif\r\n\r\n// #if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n// \tvarying vec2 v_Texcoord0;\r\n// #endif\r\n\r\nvec4 shadowCasterFragment()\r\n{\r\n    return vec4(0.0);\r\n    // #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t// \tif( alpha < u_AlphaTestValue )\r\n\t// \t{\r\n\t// \t\tdiscard;\r\n\t// \t}\r\n\t// #endif\r\n}\r\n"), 
                ue.addInclude("Colors.glsl", '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}'), 
                ue.addInclude("Sampling.glsl", "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}"), 
                ue.addInclude("StdLib.glsl", "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}"), 
                ue.addInclude("PBRVSInput.glsl", "attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef CALCULATE_SPOTSHADOWS\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif"), 
                ue.addInclude("PBRFSInput.glsl", "#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\tuniform sampler2D u_LightMapDirection;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef CALCULATE_SPOTSHADOWS\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float getAlpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float getOcclusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 getMetallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"), 
                ue.addInclude("LayaPBRBRDF.glsl", '// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------'), 
                ue.addInclude("PBRCore.glsl", "struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#ifndef SETUP_BRDF_INPUT\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = getMetallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = getAlpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = getOcclusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\tfloat shadowAttenuation = 1.0;\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tshadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t#endif\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tshadowAttenuation = 1.0;\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\tshadowAttenuation = sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t#endif\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tshadowAttenuation *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowAttenuation);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\t\t\t\tshadowAttenuation= sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n"), 
                ue.addInclude("PBRVertex.glsl", "vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax=(worldInvMat*u_CameraPos-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t#endif\r\n\r\n\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\tv_SpotShadowCoord = u_SpotViewProjectMatrix*vec4(positionWS,1.0);\r\n\t#endif\r\n}");
                var e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Color: Qe.MESH_COLOR0,
                    a_Normal: Qe.MESH_NORMAL0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: Qe.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: Qe.MESH_BLENDWEIGHT0,
                    a_BoneIndices: Qe.MESH_BLENDINDICES0,
                    a_Tangent0: Qe.MESH_TANGENT0,
                    a_MvpMatrix: Qe.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: Qe.MESH_WORLDMATRIX_ROW0
                }, t = {
                    u_Bones: ue.PERIOD_CUSTOM,
                    u_DiffuseTexture: ue.PERIOD_MATERIAL,
                    u_SpecularTexture: ue.PERIOD_MATERIAL,
                    u_NormalTexture: ue.PERIOD_MATERIAL,
                    u_AlphaTestValue: ue.PERIOD_MATERIAL,
                    u_DiffuseColor: ue.PERIOD_MATERIAL,
                    u_MaterialSpecular: ue.PERIOD_MATERIAL,
                    u_Shininess: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_WorldMat: ue.PERIOD_SPRITE,
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_LightmapScaleOffset: ue.PERIOD_SPRITE,
                    u_LightMap: ue.PERIOD_SPRITE,
                    u_LightMapDirection: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_Viewport: ue.PERIOD_CAMERA,
                    u_ProjectionParams: ue.PERIOD_CAMERA,
                    u_View: ue.PERIOD_CAMERA,
                    u_ViewProjection: ue.PERIOD_CAMERA,
                    u_ReflectTexture: ue.PERIOD_SCENE,
                    u_ReflectIntensity: ue.PERIOD_SCENE,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE,
                    u_DirationLightCount: ue.PERIOD_SCENE,
                    u_LightBuffer: ue.PERIOD_SCENE,
                    u_LightClusterBuffer: ue.PERIOD_SCENE,
                    u_AmbientColor: ue.PERIOD_SCENE,
                    u_ShadowBias: ue.PERIOD_SCENE,
                    u_ShadowLightDirection: ue.PERIOD_SCENE,
                    u_ShadowMap: ue.PERIOD_SCENE,
                    u_ShadowParams: ue.PERIOD_SCENE,
                    u_ShadowSplitSpheres: ue.PERIOD_SCENE,
                    u_ShadowMatrices: ue.PERIOD_SCENE,
                    u_ShadowMapSize: ue.PERIOD_SCENE,
                    u_SpotShadowMap: ue.PERIOD_SCENE,
                    u_SpotViewProjectMatrix: ue.PERIOD_SCENE,
                    u_ShadowLightPosition: ue.PERIOD_SCENE,
                    u_AmbientSHAr: ue.PERIOD_SCENE,
                    u_AmbientSHAg: ue.PERIOD_SCENE,
                    u_AmbientSHAb: ue.PERIOD_SCENE,
                    u_AmbientSHBr: ue.PERIOD_SCENE,
                    u_AmbientSHBg: ue.PERIOD_SCENE,
                    u_AmbientSHBb: ue.PERIOD_SCENE,
                    u_AmbientSHC: ue.PERIOD_SCENE,
                    "u_DirectionLight.color": ue.PERIOD_SCENE,
                    "u_DirectionLight.direction": ue.PERIOD_SCENE,
                    "u_PointLight.position": ue.PERIOD_SCENE,
                    "u_PointLight.range": ue.PERIOD_SCENE,
                    "u_PointLight.color": ue.PERIOD_SCENE,
                    "u_SpotLight.position": ue.PERIOD_SCENE,
                    "u_SpotLight.direction": ue.PERIOD_SCENE,
                    "u_SpotLight.range": ue.PERIOD_SCENE,
                    "u_SpotLight.spot": ue.PERIOD_SCENE,
                    "u_SpotLight.color": ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("BLINNPHONG", null, null, !0), i = new an(e, t);
                r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n#include "Shadow.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef CALCULATE_SPOTSHADOWS\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif  \r\n\tv_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\t\tvec3 positionWS=(worldMat*position).xyz;\r\n\t\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tv_ViewDir = u_CameraPos-positionWS;\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\t\t\tv_PositionWorld = positionWS;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord =getShadowCoord(vec4(positionWS,1.0));\r\n\t#endif\r\n\r\n\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\tv_SpotShadowCoord = u_SpotViewProjectMatrix*vec4(positionWS,1.0);\r\n\t#endif\r\n\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef CALCULATE_SPOTSHADOWS\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tfloat shadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t\tdif *= shadowAttenuation;\r\n\t\t\t\tspe *= shadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\tfloat spotShadowAttenuation = sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\tdif *= shadowAttenuation;\r\n\t\t\t\tspe *= shadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tdirectionLight.color *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\t#ifdef CALCULATE_SPOTSHADOWS\r\n\t\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\t\t\t\tspotLight.color *= sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tgl_FragColor.rgb+=specular;\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\n', n, "Forward");
                i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', n, "ShadowCaster");
                e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Color: Qe.MESH_COLOR0
                }, t = {
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_Color: ue.PERIOD_MATERIAL
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("LineShader"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n", n), 
                e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Color: Qe.MESH_COLOR0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: Qe.MESH_BLENDWEIGHT0,
                    a_BoneIndices: Qe.MESH_BLENDINDICES0,
                    a_MvpMatrix: Qe.MESH_MVPMATRIX_ROW0
                }, t = {
                    u_Bones: ue.PERIOD_CUSTOM,
                    u_AlbedoTexture: ue.PERIOD_MATERIAL,
                    u_AlbedoColor: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_AlphaTestValue: ue.PERIOD_MATERIAL,
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("Unlit", null, null, !0), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n", n), 
                e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: Qe.MESH_BLENDWEIGHT0,
                    a_BoneIndices: Qe.MESH_BLENDINDICES0,
                    a_MvpMatrix: Qe.MESH_MVPMATRIX_ROW0
                }, t = {
                    u_Bones: ue.PERIOD_CUSTOM,
                    u_AlbedoTexture: ue.PERIOD_MATERIAL,
                    u_AlbedoColor: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_AlphaTestValue: ue.PERIOD_MATERIAL,
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("Effect", null, null, !0), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n", n), 
                e = {
                    a_CornerTextureCoordinate: Xn.PARTICLE_CORNERTEXTURECOORDINATE0,
                    a_MeshPosition: Xn.PARTICLE_POSITION0,
                    a_MeshColor: Xn.PARTICLE_COLOR0,
                    a_MeshTextureCoordinate: Xn.PARTICLE_TEXTURECOORDINATE0,
                    a_ShapePositionStartLifeTime: Xn.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                    a_DirectionTime: Xn.PARTICLE_DIRECTIONTIME,
                    a_StartColor: Xn.PARTICLE_STARTCOLOR0,
                    a_EndColor: Xn.PARTICLE_ENDCOLOR0,
                    a_StartSize: Xn.PARTICLE_STARTSIZE,
                    a_StartRotation0: Xn.PARTICLE_STARTROTATION,
                    a_StartSpeed: Xn.PARTICLE_STARTSPEED,
                    a_Random0: Xn.PARTICLE_RANDOM0,
                    a_Random1: Xn.PARTICLE_RANDOM1,
                    a_SimulationWorldPostion: Xn.PARTICLE_SIMULATIONWORLDPOSTION,
                    a_SimulationWorldRotation: Xn.PARTICLE_SIMULATIONWORLDROTATION
                }, t = {
                    u_Tintcolor: ue.PERIOD_MATERIAL,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_texture: ue.PERIOD_MATERIAL,
                    u_WorldPosition: ue.PERIOD_SPRITE,
                    u_WorldRotation: ue.PERIOD_SPRITE,
                    u_PositionScale: ue.PERIOD_SPRITE,
                    u_SizeScale: ue.PERIOD_SPRITE,
                    u_ScalingMode: ue.PERIOD_SPRITE,
                    u_Gravity: ue.PERIOD_SPRITE,
                    u_ThreeDStartRotation: ue.PERIOD_SPRITE,
                    u_StretchedBillboardLengthScale: ue.PERIOD_SPRITE,
                    u_StretchedBillboardSpeedScale: ue.PERIOD_SPRITE,
                    u_SimulationSpace: ue.PERIOD_SPRITE,
                    u_CurrentTime: ue.PERIOD_SPRITE,
                    u_ColorOverLifeGradientAlphas: ue.PERIOD_SPRITE,
                    u_ColorOverLifeGradientColors: ue.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientAlphas: ue.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientColors: ue.PERIOD_SPRITE,
                    u_VOLVelocityConst: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientX: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientY: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientZ: ue.PERIOD_SPRITE,
                    u_VOLVelocityConstMax: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxX: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxY: ue.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxZ: ue.PERIOD_SPRITE,
                    u_VOLSpaceType: ue.PERIOD_SPRITE,
                    u_SOLSizeGradient: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientX: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientY: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientZ: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientMax: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxX: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxY: ue.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxZ: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityConst: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstSeprarate: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradient: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientX: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientY: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientZ: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMax: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMaxSeprarate: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMax: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxX: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxY: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxZ: ue.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxW: ue.PERIOD_SPRITE,
                    u_TSACycles: ue.PERIOD_SPRITE,
                    u_TSASubUVLength: ue.PERIOD_SPRITE,
                    u_TSAGradientUVs: ue.PERIOD_SPRITE,
                    u_TSAMaxGradientUVs: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_CameraDirection: ue.PERIOD_CAMERA,
                    u_CameraUp: ue.PERIOD_CAMERA,
                    u_View: ue.PERIOD_CAMERA,
                    u_Projection: ue.PERIOD_CAMERA,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("PARTICLESHURIKEN"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}", n), 
                e = {
                    a_Position: Qe.MESH_POSITION0
                }, t = {
                    u_TintColor: ue.PERIOD_MATERIAL,
                    u_Exposure: ue.PERIOD_MATERIAL,
                    u_Rotation: ue.PERIOD_MATERIAL,
                    u_CubeTexture: ue.PERIOD_MATERIAL,
                    u_ViewProjection: ue.PERIOD_CAMERA
                }, r = ue.add("SkyBox"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n"), 
                e = {
                    a_Position: Qe.MESH_POSITION0
                }, t = {
                    u_SunSize: ue.PERIOD_MATERIAL,
                    u_SunSizeConvergence: ue.PERIOD_MATERIAL,
                    u_AtmosphereThickness: ue.PERIOD_MATERIAL,
                    u_SkyTint: ue.PERIOD_MATERIAL,
                    u_GroundTint: ue.PERIOD_MATERIAL,
                    u_Exposure: ue.PERIOD_MATERIAL,
                    u_ViewProjection: ue.PERIOD_CAMERA,
                    "u_SunLight.direction": ue.PERIOD_SCENE,
                    "u_SunLight.color": ue.PERIOD_SCENE
                }, r = ue.add("SkyBoxProcedural"), i = new an(e, t), r.addSubShader(i), i.addShaderPass("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n", '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n'), 
                e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Normal: Qe.MESH_NORMAL0,
                    a_Texcoord0: Qe.MESH_TEXTURECOORDINATE0
                }, t = {
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_WorldMat: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_Viewport: ue.PERIOD_CAMERA,
                    u_ProjectionParams: ue.PERIOD_CAMERA,
                    u_View: ue.PERIOD_CAMERA,
                    u_LightmapScaleOffset: ue.PERIOD_SPRITE,
                    u_LightMap: ue.PERIOD_SPRITE,
                    u_SplatAlphaTexture: ue.PERIOD_MATERIAL,
                    u_DiffuseTexture1: ue.PERIOD_MATERIAL,
                    u_DiffuseTexture2: ue.PERIOD_MATERIAL,
                    u_DiffuseTexture3: ue.PERIOD_MATERIAL,
                    u_DiffuseTexture4: ue.PERIOD_MATERIAL,
                    u_DiffuseTexture5: ue.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset1: ue.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset2: ue.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset3: ue.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset4: ue.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset5: ue.PERIOD_MATERIAL,
                    u_FogStart: ue.PERIOD_SCENE,
                    u_FogRange: ue.PERIOD_SCENE,
                    u_FogColor: ue.PERIOD_SCENE,
                    u_DirationLightCount: ue.PERIOD_SCENE,
                    u_LightBuffer: ue.PERIOD_SCENE,
                    u_LightClusterBuffer: ue.PERIOD_SCENE,
                    u_AmbientColor: ue.PERIOD_SCENE,
                    u_ShadowMap: ue.PERIOD_SCENE,
                    u_shadowMap2: ue.PERIOD_SCENE,
                    u_shadowMap3: ue.PERIOD_SCENE,
                    u_ShadowSplitSpheres: ue.PERIOD_SCENE,
                    u_ShadowMatrices: ue.PERIOD_SCENE,
                    u_ShadowMapSize: ue.PERIOD_SCENE,
                    "u_DirectionLight.color": ue.PERIOD_SCENE,
                    "u_DirectionLight.direction": ue.PERIOD_SCENE,
                    "u_PointLight.position": ue.PERIOD_SCENE,
                    "u_PointLight.range": ue.PERIOD_SCENE,
                    "u_PointLight.color": ue.PERIOD_SCENE,
                    "u_SpotLight.position": ue.PERIOD_SCENE,
                    "u_SpotLight.direction": ue.PERIOD_SCENE,
                    "u_SpotLight.range": ue.PERIOD_SCENE,
                    "u_SpotLight.spot": ue.PERIOD_SCENE,
                    "u_SpotLight.color": ue.PERIOD_SCENE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("ExtendTerrain"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "Shadow.glsl"\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tfloat shadowValue = shadowValue = sampleShadowmap(v_ShadowCoord);\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', n), 
                e = {
                    a_Position: ar.TRAIL_POSITION0,
                    a_OffsetVector: ar.TRAIL_OFFSETVECTOR,
                    a_Texcoord0X: ar.TRAIL_TEXTURECOORDINATE0X,
                    a_Texcoord0Y: ar.TRAIL_TEXTURECOORDINATE0Y,
                    a_BirthTime: ar.TRAIL_TIME0,
                    a_Color: ar.TRAIL_COLOR
                }, t = {
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_View: ue.PERIOD_CAMERA,
                    u_Projection: ue.PERIOD_CAMERA,
                    u_TilingOffset: ue.PERIOD_MATERIAL,
                    u_MainTexture: ue.PERIOD_MATERIAL,
                    u_MainColor: ue.PERIOD_MATERIAL,
                    u_CurTime: ue.PERIOD_SPRITE,
                    u_LifeTime: ue.PERIOD_SPRITE,
                    u_WidthCurve: ue.PERIOD_SPRITE,
                    u_WidthCurveKeyLength: ue.PERIOD_SPRITE,
                    u_GradientColorkey: ue.PERIOD_SPRITE,
                    u_GradientAlphakey: ue.PERIOD_SPRITE
                }, n = {
                    s_Cull: ue.RENDER_STATE_CULL,
                    s_Blend: ue.RENDER_STATE_BLEND,
                    s_BlendSrc: ue.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: ue.RENDER_STATE_BLEND_DST,
                    s_DepthTest: ue.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: ue.RENDER_STATE_DEPTH_WRITE
                }, r = ue.add("Trail"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ", n), 
                e = {
                    a_Position: Qe.MESH_POSITION0,
                    a_Normal: Qe.MESH_NORMAL0,
                    a_Tangent0: Qe.MESH_TANGENT0
                }, t = {
                    u_MvpMatrix: ue.PERIOD_SPRITE,
                    u_WorldMat: ue.PERIOD_SPRITE,
                    u_CameraPos: ue.PERIOD_CAMERA,
                    u_Time: ue.PERIOD_SCENE,
                    u_MainTexture: ue.PERIOD_MATERIAL,
                    u_NormalTexture: ue.PERIOD_MATERIAL,
                    u_HorizonColor: ue.PERIOD_MATERIAL,
                    u_WaveScale: ue.PERIOD_MATERIAL,
                    u_WaveSpeed: ue.PERIOD_MATERIAL
                }, r = ue.add("WaterPrimary"), i = new an(e, t), r.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n'), 
                e = {
                    a_PositionTexcoord: Qe.MESH_POSITION0
                }, t = {
                    u_MainTex: ue.PERIOD_MATERIAL,
                    u_OffsetScale: ue.PERIOD_MATERIAL
                }, r = ue.add("BlitScreen"), i = new an(e, t), r.addSubShader(i);
                var a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n").renderState;
                a.depthTest = pe.DEPTHTEST_ALWAYS, a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, 
                e = {
                    a_PositionTexcoord: Qe.MESH_POSITION0
                }, t = {
                    u_MainTex: ue.PERIOD_MATERIAL,
                    u_BloomTex: ue.PERIOD_MATERIAL,
                    u_AutoExposureTex: ue.PERIOD_MATERIAL,
                    u_MainTex_TexelSize: ue.PERIOD_MATERIAL,
                    u_SampleScale: ue.PERIOD_MATERIAL,
                    u_Threshold: ue.PERIOD_MATERIAL,
                    u_Params: ue.PERIOD_MATERIAL
                }, r = ue.add("PostProcessBloom"), i = new an(e, t), r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, i = new an(e, t), 
                r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, i = new an(e, t), 
                r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, i = new an(e, t), 
                r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, i = new an(e, t), 
                r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, i = new an(e, t), 
                r.addSubShader(i), (a = i.addShaderPass(pr, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE, e = {
                    a_PositionTexcoord: Qe.MESH_POSITION0
                }, t = {
                    u_MainTex: ue.PERIOD_MATERIAL,
                    u_BloomTex: ue.PERIOD_MATERIAL,
                    u_AutoExposureTex: ue.PERIOD_MATERIAL,
                    u_Bloom_DirtTileOffset: ue.PERIOD_MATERIAL,
                    u_Bloom_DirtTex: ue.PERIOD_MATERIAL,
                    u_BloomTex_TexelSize: ue.PERIOD_MATERIAL,
                    u_Bloom_Settings: ue.PERIOD_MATERIAL,
                    u_Bloom_Color: ue.PERIOD_MATERIAL
                }, r = ue.add("PostProcessComposite"), i = new an(e, t), r.addSubShader(i), (a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}').renderState).depthTest = pe.DEPTHTEST_ALWAYS, 
                a.depthWrite = !1, a.cull = pe.CULL_NONE, a.blend = pe.BLEND_DISABLE;
            }
        } ]), ShaderInit3D;
    }(), Er = function(t) {
        function DirectionLight() {
            var t;
            return _classCallCheck(this, DirectionLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(DirectionLight).call(this)))._direction = new o(), 
            t._shadowCascadesMode = e.ShadowCascadesMode.NoCascades, t._shadowTwoCascadeSplits = 1 / 3, 
            t._shadowFourCascadeSplits = new o(1 / 15, .2, 7 / 15), t._lightType = e.LightType.Directional, 
            t;
        }
        return _inherits(DirectionLight, ft), _createClass(DirectionLight, [ {
            key: "_addToLightQueue",
            value: function() {
                this._scene._directionLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._directionLights.remove(this);
            }
        }, {
            key: "shadowCascadesMode",
            get: function() {
                return this._shadowCascadesMode;
            },
            set: function(e) {
                this._shadowCascadesMode = e;
            }
        }, {
            key: "shadowTwoCascadeSplits",
            get: function() {
                return this._shadowTwoCascadeSplits;
            },
            set: function(e) {
                this._shadowTwoCascadeSplits = e;
            }
        }, {
            key: "shadowFourCascadeSplits",
            get: function() {
                return this._shadowFourCascadeSplits;
            },
            set: function(e) {
                if (e.x > e.y || e.y > e.z || e.z > 1) throw "DiretionLight:Invalid value.";
                e.cloneTo(this._shadowFourCascadeSplits);
            }
        } ]), DirectionLight;
    }(), yr = function(t) {
        function PointLight() {
            var t;
            return _classCallCheck(this, PointLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(PointLight).call(this)))._range = 6, 
            t._lightType = e.LightType.Point, t;
        }
        return _inherits(PointLight, ft), _createClass(PointLight, [ {
            key: "_addToLightQueue",
            value: function() {
                this._scene._pointLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._pointLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(PointLight.prototype), "_parse", this).call(this, e, t), this.range = e.range;
            }
        }, {
            key: "range",
            get: function() {
                return this._range;
            },
            set: function(e) {
                this._range = e;
            }
        } ]), PointLight;
    }(), vr = function(t) {
        function SpotLight() {
            var t;
            return _classCallCheck(this, SpotLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this)))._spotAngle = 30, 
            t._range = 10, t._direction = new o(), t._lightType = e.LightType.Spot, t;
        }
        return _inherits(SpotLight, ft), _createClass(SpotLight, [ {
            key: "_addToLightQueue",
            value: function() {
                this._scene._spotLights.add(this);
            }
        }, {
            key: "_removeFromLightQueue",
            value: function() {
                this._scene._spotLights.remove(this);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(SpotLight.prototype), "_parse", this).call(this, e, t), this.range = e.range, 
                this.spotAngle = e.spotAngle;
            }
        }, {
            key: "spotAngle",
            get: function() {
                return this._spotAngle;
            },
            set: function(e) {
                this._spotAngle = Math.max(Math.min(e, 179), 0);
            }
        }, {
            key: "range",
            get: function() {
                return this._range;
            },
            set: function(e) {
                this._range = e;
            }
        } ]), SpotLight;
    }(), Sr = function() {
        function Scene3DUtils() {
            _classCallCheck(this, Scene3DUtils);
        }
        return _createClass(Scene3DUtils, null, [ {
            key: "_createSprite3DInstance",
            value: function(e, t, n) {
                var r;
                switch (e.type) {
                  case "Scene3D":
                    r = new tn();
                    break;

                  case "Sprite3D":
                    r = new et();
                    break;

                  case "MeshSprite3D":
                    r = new gn(), n && e.props.isStatic && n.push(r);
                    break;

                  case "SkinnedMeshSprite3D":
                    r = new tr();
                    break;

                  case "ShuriKenParticle3D":
                    r = new Jn();
                    break;

                  case "Camera":
                    r = new pt();
                    break;

                  case "DirectionLight":
                    r = new Er();
                    break;

                  case "PointLight":
                    r = new yr();
                    break;

                  case "SpotLight":
                    r = new vr();
                    break;

                  case "TrailSprite3D":
                    r = new ur();
                    break;

                  default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var i = e.child;
                if (i) for (var a = 0, o = i.length; a < o; a++) {
                    var s = Scene3DUtils._createSprite3DInstance(i[a], t, n);
                    r.addChild(s);
                }
                return t[e.instanceID] = r, r;
            }
        }, {
            key: "_createComponentInstance",
            value: function(e, n, r) {
                var i = n[e.instanceID];
                i._parse(e.props, n);
                var a = e.child;
                if (a) for (var o = 0, s = a.length; o < s; o++) Scene3DUtils._createComponentInstance(a[o], n, r);
                var l = e.components;
                if (l) for (var u = 0, c = l.length; u < c; u++) {
                    var h = l[u], _ = t.ClassUtils.getRegClass(h.type);
                    if (_) i.addComponent(_)._parse(h, r); else console.warn("Unkown component type.");
                }
            }
        }, {
            key: "_createNodeByJson02",
            value: function(e, t) {
                var n = {}, r = {
                    component: [],
                    data: []
                }, i = Scene3DUtils._createSprite3DInstance(e, n, t);
                return Scene3DUtils._createComponentInstance(e, n, r), Scene3DUtils._createInteractInstance(r, n), 
                i;
            }
        }, {
            key: "_createInteractInstance",
            value: function(e, t) {
                for (var n = e.component, r = e.data, i = 0, a = n.length; i < a; i++) n[i]._parseInteractive(r[i], t);
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t, n = e.data, r = [];
                switch (e.version) {
                  case "LAYAHIERARCHY:02":
                    t = Scene3DUtils._createNodeByJson02(n, r);
                    break;

                  default:
                    t = Scene3DUtils._createNodeByJson(n, r);
                }
                return Bt.combine(t, r), t;
            }
        }, {
            key: "_parseScene",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t, n = e.data, r = [];
                switch (e.version) {
                  case "LAYASCENE3D:02":
                    t = Scene3DUtils._createNodeByJson02(n, r);
                    break;

                  default:
                    t = Scene3DUtils._createNodeByJson(n, r);
                }
                return Bt.combine(null, r), t;
            }
        }, {
            key: "_createNodeByJson",
            value: function(e, n) {
                var r;
                switch (e.type) {
                  case "Scene3D":
                    r = new tn();
                    break;

                  case "Sprite3D":
                    r = new et();
                    break;

                  case "MeshSprite3D":
                    r = new gn(), n && e.props.isStatic && n.push(r);
                    break;

                  case "SkinnedMeshSprite3D":
                    r = new tr();
                    break;

                  case "ShuriKenParticle3D":
                    r = new Jn();
                    break;

                  case "Camera":
                    r = new pt();
                    break;

                  case "DirectionLight":
                    r = new Er();
                    break;

                  case "PointLight":
                    r = new yr();
                    break;

                  case "SpotLight":
                    r = new vr();
                    break;

                  case "TrailSprite3D":
                    r = new ur();
                    break;

                  default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
                }
                var i = e.child;
                if (i) for (var a = 0, o = i.length; a < o; a++) {
                    var s = Scene3DUtils._createNodeByJson(i[a], n);
                    r.addChild(s);
                }
                var l = e.components;
                if (l) for (var u = 0, c = l.length; u < c; u++) {
                    var h = l[u], _ = t.ClassUtils.getRegClass(h.type);
                    if (_) r.addComponent(_)._parse(h); else console.warn("Unkown component type.");
                }
                return r._parse(e.props, null), r;
            }
        } ]), Scene3DUtils;
    }(), Cr = function() {
        function LoadModelV04() {
            _classCallCheck(this, LoadModelV04);
        }
        return _createClass(LoadModelV04, null, [ {
            key: "parse",
            value: function(e, t, n, r) {
                LoadModelV04._mesh = n, LoadModelV04._subMeshes = r, LoadModelV04._version = t, 
                LoadModelV04._readData = e, LoadModelV04.READ_DATA(), LoadModelV04.READ_BLOCK(), 
                LoadModelV04.READ_STRINGS();
                for (var i = 0, a = LoadModelV04._BLOCK.count; i < a; i++) {
                    LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                    var o = LoadModelV04._readData.getUint16(), s = LoadModelV04._strings[o], l = LoadModelV04["READ_" + s];
                    if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                    l.call(null);
                }
                LoadModelV04._strings.length = 0, LoadModelV04._readData = null, LoadModelV04._version = null, 
                LoadModelV04._mesh = null, LoadModelV04._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function() {
                return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function() {
                LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(), LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), t = LoadModelV04._BLOCK.blockStarts = [], n = LoadModelV04._BLOCK.blockLengths = [], r = 0; r < e; r++) t.push(LoadModelV04._readData.getUint32()), 
                n.push(LoadModelV04._readData.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = LoadModelV04._readData.getUint32(), t = LoadModelV04._readData.getUint16(), n = LoadModelV04._readData.pos;
                LoadModelV04._readData.pos = e + LoadModelV04._DATA.offset;
                for (var r = 0; r < t; r++) LoadModelV04._strings[r] = LoadModelV04._readData.readUTFString();
                LoadModelV04._readData.pos = n;
            }
        }, {
            key: "READ_MESH",
            value: function() {
                var n, r = t.LayaGL.instance, i = (LoadModelV04._readString(), LoadModelV04._readData.__getBuffer()), a = 0, o = LoadModelV04._readData.getInt16(), s = LoadModelV04._DATA.offset;
                for (n = 0; n < o; n++) {
                    var l, u = s + LoadModelV04._readData.getUint32(), h = LoadModelV04._readData.getUint32(), _ = i.slice(u, u + h), d = new Float32Array(_), f = LoadModelV04._readString();
                    switch (LoadModelV04._version) {
                      case "LAYAMODEL:0301":
                      case "LAYAMODEL:0400":
                        l = Qe.getVertexDeclaration(f);
                        break;

                      case "LAYAMODEL:0401":
                        l = Qe.getVertexDeclaration(f, !1);
                        break;

                      default:
                        throw new Error("LoadModelV03: unknown version.");
                    }
                    if (!l) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                    var m = new qe(4 * d.length, r.STATIC_DRAW, !0);
                    m.vertexDeclaration = l, m.setData(d.buffer), LoadModelV04._mesh._vertexBuffer = m, 
                    LoadModelV04._mesh._vertexCount += m._byteLength / l.vertexStride, a += 4 * d.length;
                }
                var T = s + LoadModelV04._readData.getUint32(), p = LoadModelV04._readData.getUint32(), g = new Uint16Array(i.slice(T, T + p)), E = new Xe(e.IndexFormat.UInt16, p / 2, r.STATIC_DRAW, !0);
                E.setData(g), LoadModelV04._mesh._indexBuffer = E, a += 2 * E.indexCount, LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, E), 
                LoadModelV04._mesh._setCPUMemory(a), LoadModelV04._mesh._setGPUMemory(a);
                var y = LoadModelV04._mesh._boneNames = [], v = LoadModelV04._readData.getUint16();
                for (y.length = v, n = 0; n < v; n++) y[n] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
                LoadModelV04._readData.pos += 8;
                var S = LoadModelV04._readData.getUint32(), C = LoadModelV04._readData.getUint32(), R = new Float32Array(i.slice(s + S, s + S + C)), D = R.length, M = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * D);
                for (LoadModelV04._mesh._inverseBindPoses = [], n = 0; n < D; n += 16) {
                    var A = new c(R[n + 0], R[n + 1], R[n + 2], R[n + 3], R[n + 4], R[n + 5], R[n + 6], R[n + 7], R[n + 8], R[n + 9], R[n + 10], R[n + 11], R[n + 12], R[n + 13], R[n + 14], R[n + 15], new Float32Array(M, 4 * n, 16));
                    LoadModelV04._mesh._inverseBindPoses[n / 16] = A;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function() {
                var e = LoadModelV04._readData.__getBuffer(), t = new dr(LoadModelV04._mesh);
                LoadModelV04._readData.getInt16(), LoadModelV04._readData.getUint32(), LoadModelV04._readData.getUint32();
                var n = LoadModelV04._readData.getUint32(), r = LoadModelV04._readData.getUint32(), i = LoadModelV04._mesh._indexBuffer;
                t._indexBuffer = i, t._setIndexRange(n, r);
                var a = LoadModelV04._mesh._vertexBuffer;
                t._vertexBuffer = a;
                var o = LoadModelV04._DATA.offset, s = t._subIndexBufferStart, l = t._subIndexBufferCount, u = t._boneIndicesList, c = LoadModelV04._readData.getUint16();
                s.length = c, l.length = c, u.length = c;
                var h = LoadModelV04._mesh._skinnedMatrixCaches, _ = LoadModelV04._subMeshes.length;
                h.length = LoadModelV04._mesh._inverseBindPoses.length;
                for (var d = 0; d < c; d++) {
                    s[d] = LoadModelV04._readData.getUint32(), l[d] = LoadModelV04._readData.getUint32();
                    for (var f = LoadModelV04._readData.getUint32(), m = LoadModelV04._readData.getUint32(), T = u[d] = new Uint16Array(e.slice(o + f, o + f + m)), p = T.length, g = 0; g < p; g++) {
                        var E = T[g];
                        h[E] || (h[E] = new fr(_, d, g));
                    }
                }
                return LoadModelV04._subMeshes.push(t), !0;
            }
        } ]), LoadModelV04;
    }();
    Cr._BLOCK = {
        count: 0
    }, Cr._DATA = {
        offset: 0,
        size: 0
    }, Cr._strings = [];
    var Rr = function() {
        function LoadModelV05() {
            _classCallCheck(this, LoadModelV05);
        }
        return _createClass(LoadModelV05, null, [ {
            key: "parse",
            value: function(e, t, n, r) {
                LoadModelV05._mesh = n, LoadModelV05._subMeshes = r, LoadModelV05._version = t, 
                LoadModelV05._readData = e, LoadModelV05.READ_DATA(), LoadModelV05.READ_BLOCK(), 
                LoadModelV05.READ_STRINGS();
                for (var i = 0, a = LoadModelV05._BLOCK.count; i < a; i++) {
                    LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                    var o = LoadModelV05._readData.getUint16(), s = LoadModelV05._strings[o], l = LoadModelV05["READ_" + s];
                    if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                    l.call(null);
                }
                LoadModelV05._strings.length = 0, LoadModelV05._readData = null, LoadModelV05._version = null, 
                LoadModelV05._mesh = null, LoadModelV05._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function() {
                return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function() {
                LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(), LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), t = LoadModelV05._BLOCK.blockStarts = [], n = LoadModelV05._BLOCK.blockLengths = [], r = 0; r < e; r++) t.push(LoadModelV05._readData.getUint32()), 
                n.push(LoadModelV05._readData.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = LoadModelV05._readData.getUint32(), t = LoadModelV05._readData.getUint16(), n = LoadModelV05._readData.pos;
                LoadModelV05._readData.pos = e + LoadModelV05._DATA.offset;
                for (var r = 0; r < t; r++) LoadModelV05._strings[r] = LoadModelV05._readData.readUTFString();
                LoadModelV05._readData.pos = n;
            }
        }, {
            key: "READ_MESH",
            value: function() {
                var n, r = t.LayaGL.instance, i = 0, a = (LoadModelV05._readString(), LoadModelV05._readData), o = a.__getBuffer(), s = a.getInt16(), l = LoadModelV05._DATA.offset;
                for (n = 0; n < s; n++) {
                    var u, h, _, d = l + a.getUint32(), f = a.getUint32(), m = LoadModelV05._readString(), T = Qe.getVertexDeclaration(m, !1), p = T.vertexStride, g = m.split(","), E = g.length, y = LoadModelV05._mesh;
                    switch (LoadModelV05._version) {
                      case "LAYAMODEL:05":
                      case "LAYAMODEL:0501":
                        u = o.slice(d, d + f * p), h = new Float32Array(u), _ = new Uint8Array(u);
                        break;

                      case "LAYAMODEL:COMPRESSION_05":
                      case "LAYAMODEL:COMPRESSION_0501":
                        u = new ArrayBuffer(p * f), h = new Float32Array(u), _ = new Uint8Array(u);
                        var v = a.pos;
                        a.pos = d;
                        for (var S = 0; S < f; S++) for (var C, R = S * p, D = 0; D < E; D++) switch (g[D]) {
                          case "POSITION":
                            h[C = R / 4] = W.convertToNumber(a.getUint16()), h[C + 1] = W.convertToNumber(a.getUint16()), 
                            h[C + 2] = W.convertToNumber(a.getUint16()), R += 12;
                            break;

                          case "NORMAL":
                            h[C = R / 4] = a.getUint8() / 127.5 - 1, h[C + 1] = a.getUint8() / 127.5 - 1, h[C + 2] = a.getUint8() / 127.5 - 1, 
                            R += 12;
                            break;

                          case "COLOR":
                            h[C = R / 4] = a.getUint8() / 255, h[C + 1] = a.getUint8() / 255, h[C + 2] = a.getUint8() / 255, 
                            h[C + 3] = a.getUint8() / 255, R += 16;
                            break;

                          case "UV":
                          case "UV1":
                            h[C = R / 4] = W.convertToNumber(a.getUint16()), h[C + 1] = W.convertToNumber(a.getUint16()), 
                            R += 8;
                            break;

                          case "BLENDWEIGHT":
                            h[C = R / 4] = a.getUint8() / 255, h[C + 1] = a.getUint8() / 255, h[C + 2] = a.getUint8() / 255, 
                            h[C + 3] = a.getUint8() / 255, R += 16;
                            break;

                          case "BLENDINDICES":
                            _[R] = a.getUint8(), _[R + 1] = a.getUint8(), _[R + 2] = a.getUint8(), _[R + 3] = a.getUint8(), 
                            R += 4;
                            break;

                          case "TANGENT":
                            h[C = R / 4] = a.getUint8() / 127.5 - 1, h[C + 1] = a.getUint8() / 127.5 - 1, h[C + 2] = a.getUint8() / 127.5 - 1, 
                            h[C + 3] = a.getUint8() / 127.5 - 1, R += 16;
                        }
                        a.pos = v;
                    }
                    var M = new qe(u.byteLength, r.STATIC_DRAW, !0);
                    M.vertexDeclaration = T, M.setData(u);
                    f = M._byteLength / T.vertexStride;
                    y._indexFormat = f > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16, y._vertexBuffer = M, 
                    y._vertexCount += f, i += 4 * h.length;
                }
                var A, x = l + a.getUint32(), L = a.getUint32();
                A = y.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(o.slice(x, x + L)) : new Uint16Array(o.slice(x, x + L));
                var I = new Xe(y.indexFormat, A.length, r.STATIC_DRAW, !0);
                if (I.setData(A), y._indexBuffer = I, y._setBuffer(y._vertexBuffer, I), i += 2 * I.indexCount, 
                y._setCPUMemory(i), y._setGPUMemory(i), "LAYAMODEL:0501" == LoadModelV05._version || "LAYAMODEL:COMPRESSION_0501" == LoadModelV05._version) {
                    var O = y.bounds, P = O.getMin(), N = O.getMax();
                    P.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()), N.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()), 
                    O.setMin(P), O.setMax(N), y.bounds = O;
                }
                var b = y._boneNames = [], k = a.getUint16();
                for (b.length = k, n = 0; n < k; n++) b[n] = LoadModelV05._strings[a.getUint16()];
                var w = a.getUint32(), B = a.getUint32(), V = new Float32Array(o.slice(l + w, l + w + B)), F = V.length, U = y._inverseBindPosesBuffer = new ArrayBuffer(4 * F);
                for (y._inverseBindPoses = [], n = 0; n < F; n += 16) {
                    var G = new c(V[n + 0], V[n + 1], V[n + 2], V[n + 3], V[n + 4], V[n + 5], V[n + 6], V[n + 7], V[n + 8], V[n + 9], V[n + 10], V[n + 11], V[n + 12], V[n + 13], V[n + 14], V[n + 15], new Float32Array(U, 4 * n, 16));
                    y._inverseBindPoses[n / 16] = G;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function() {
                var e = LoadModelV05._readData, t = e.__getBuffer(), n = new dr(LoadModelV05._mesh);
                e.getInt16();
                var r = e.getUint32(), i = e.getUint32(), a = LoadModelV05._mesh._indexBuffer;
                n._indexBuffer = a, n._setIndexRange(r, i);
                var o = LoadModelV05._mesh._vertexBuffer;
                n._vertexBuffer = o;
                var s = LoadModelV05._DATA.offset, l = n._subIndexBufferStart, u = n._subIndexBufferCount, c = n._boneIndicesList, h = e.getUint16();
                l.length = h, u.length = h, c.length = h;
                var _ = LoadModelV05._mesh._skinnedMatrixCaches, d = LoadModelV05._subMeshes.length;
                _.length = LoadModelV05._mesh._inverseBindPoses.length;
                for (var f = 0; f < h; f++) {
                    l[f] = e.getUint32(), u[f] = e.getUint32();
                    for (var m = e.getUint32(), T = e.getUint32(), p = c[f] = new Uint16Array(t.slice(s + m, s + m + T)), g = 0, E = p.length; g < E; g++) {
                        var y = p[g];
                        _[y] || (_[y] = new fr(d, f, g));
                    }
                }
                return LoadModelV05._subMeshes.push(n), !0;
            }
        } ]), LoadModelV05;
    }();
    Rr._BLOCK = {
        count: 0
    }, Rr._DATA = {
        offset: 0,
        size: 0
    }, Rr._strings = [];
    var Dr = function() {
        function MeshReader() {
            _classCallCheck(this, MeshReader);
        }
        return _createClass(MeshReader, null, [ {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var t = new mr();
                return MeshReader.read(e, t, t._subMeshes), t;
            }
        }, {
            key: "read",
            value: function(e, n, r) {
                var i = new t.Byte(e);
                i.pos = 0;
                var a = i.readUTFString();
                switch (a) {
                  case "LAYAMODEL:0301":
                  case "LAYAMODEL:0400":
                  case "LAYAMODEL:0401":
                    Cr.parse(i, a, n, r);
                    break;

                  case "LAYAMODEL:05":
                  case "LAYAMODEL:COMPRESSION_05":
                  case "LAYAMODEL:0501":
                  case "LAYAMODEL:COMPRESSION_0501":
                    Rr.parse(i, a, n, r);
                    break;

                  default:
                    throw new Error("MeshReader: unknown mesh version.");
                }
                n._setSubMeshes(r), "LAYAMODEL:0501" != a && "LAYAMODEL:COMPRESSION_0501" != a && n.calculateBounds();
            }
        } ]), MeshReader;
    }(), Mr = function(e) {
        function SkyPanoramicMaterial() {
            var e;
            _classCallCheck(this, SkyPanoramicMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyPanoramicMaterial).call(this)))._exposure = 1, 
            e._textureDecodeFormat = t.TextureDecodeFormat.Normal, e._textureHDRParams = new i(1, 0, 0, 1), 
            e.setShaderName("SkyPanoramic");
            var n = e._shaderValues;
            return n.setVector(SkyPanoramicMaterial.TINTCOLOR, new i(.5, .5, .5, .5)), n.setNumber(SkyPanoramicMaterial.ROTATION, 0), 
            n.setVector(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, e._textureHDRParams), e;
        }
        return _inherits(SkyPanoramicMaterial, me), _createClass(SkyPanoramicMaterial, [ {
            key: "tintColor",
            get: function() {
                return this._shaderValues.getVector(SkyPanoramicMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyPanoramicMaterial.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._exposure;
            },
            set: function(e) {
                this._exposure !== e && (this._exposure = e, this._textureDecodeFormat == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture._rgbmRange : this._textureHDRParams.x = e);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._shaderValues.getNumber(SkyPanoramicMaterial.ROTATION);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyPanoramicMaterial.ROTATION, e);
            }
        }, {
            key: "panoramicTexture",
            get: function() {
                return this._shaderValues.getTexture(SkyPanoramicMaterial.TEXTURE);
            },
            set: function(e) {
                this._shaderValues.setTexture(SkyPanoramicMaterial.TEXTURE, e);
            }
        }, {
            key: "panoramicTextureDecodeFormat",
            get: function() {
                return this._textureDecodeFormat;
            },
            set: function(e) {
                this._textureDecodeFormat !== e && (this._textureDecodeFormat = e, e == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure * t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure);
            }
        } ], [ {
            key: "__init__",
            value: function() {
                var e = {
                    a_Position: Qe.MESH_POSITION0
                }, t = {
                    u_TintColor: ue.PERIOD_MATERIAL,
                    u_TextureHDRParams: ue.PERIOD_MATERIAL,
                    u_Rotation: ue.PERIOD_MATERIAL,
                    u_Texture: ue.PERIOD_MATERIAL,
                    u_ViewProjection: ue.PERIOD_CAMERA
                }, n = ue.add("SkyPanoramic"), r = new an(e, t);
                n.addSubShader(r), r.addShaderPass('#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n');
            }
        } ]), SkyPanoramicMaterial;
    }();
    Mr.TINTCOLOR = ue.propertyNameToID("u_TintColor"), Mr.EXPOSURE = ue.propertyNameToID("u_Exposure"), 
    Mr.ROTATION = ue.propertyNameToID("u_Rotation"), Mr.TEXTURE = ue.propertyNameToID("u_Texture"), 
    Mr.TEXTURE_HDR_PARAMS = ue.propertyNameToID("u_TextureHDRParams");
    var Ar = function(e) {
        function ConstraintComponent(e) {
            var t;
            _classCallCheck(this, ConstraintComponent), (t = _possibleConstructorReturn(this, _getPrototypeOf(ConstraintComponent).call(this)))._anchor = new o(), 
            t._connectAnchor = new o(), t._feedbackEnabled = !1, t._getJointFeedBack = !1, t._currentForce = new o(), 
            t._currentTorque = new o(), t._constraintType = e;
            var n = k._bullet;
            return t._btframATrans = n.btTransform_create(), t._btframBTrans = n.btTransform_create(), 
            n.btTransform_setIdentity(t._btframATrans), n.btTransform_setIdentity(t._btframBTrans), 
            t._btframAPos = n.btVector3_create(0, 0, 0), t._btframBPos = n.btVector3_create(0, 0, 0), 
            n.btTransform_setOrigin(t._btframATrans, t._btframAPos), n.btTransform_setOrigin(t._btframBTrans, t._btframBPos), 
            t._breakForce = -1, t._breakTorque = -1, t;
        }
        return _inherits(ConstraintComponent, t.Component), _createClass(ConstraintComponent, [ {
            key: "setOverrideNumSolverIterations",
            value: function(e) {
                k._bullet.btTypedConstraint_setOverrideNumSolverIterations(this._btConstraint, e);
            }
        }, {
            key: "setConstraintEnabled",
            value: function(e) {
                k._bullet.btTypedConstraint_setEnabled(this._btConstraint, e);
            }
        }, {
            key: "_onEnable",
            value: function() {
                _get(_getPrototypeOf(ConstraintComponent.prototype), "_onEnable", this).call(this), 
                this.enabled = !0;
            }
        }, {
            key: "_onDisable",
            value: function() {
                _get(_getPrototypeOf(ConstraintComponent.prototype), "_onDisable", this).call(this), 
                this.enabled = !1;
            }
        }, {
            key: "setFrames",
            value: function() {
                var e = k._bullet;
                e.btVector3_setValue(this._btframAPos, -this._anchor.x, this.anchor.y, this.anchor.z), 
                e.btVector3_setValue(this._btframBPos, -this._connectAnchor.x, this._connectAnchor.y, this._connectAnchor.z), 
                e.btTransform_setOrigin(this._btframATrans, this._btframAPos), e.btTransform_setOrigin(this._btframBTrans, this._btframBPos);
            }
        }, {
            key: "_addToSimulation",
            value: function() {}
        }, {
            key: "_removeFromSimulation",
            value: function() {}
        }, {
            key: "_createConstraint",
            value: function() {}
        }, {
            key: "setConnectRigidBody",
            value: function(e, t) {
                var n = e && !!(e._simulation && e._enabled && e.colliderShape), r = t && !!(t._simulation && t._enabled && t.colliderShape);
                if (!n || !r) throw "ownerRigid or connectRigidBody is not in Simulation";
                e == this._ownBody && t == this._connectedBody || (!(!this.enabled || !this._simulation) && this._removeFromSimulation(), 
                this._ownBody = e, this._connectedBody = t, this._ownBody.constaintRigidbodyA = this, 
                this._connectedBody.constaintRigidbodyB = this, this._createConstraint());
            }
        }, {
            key: "getcurrentForce",
            value: function(e) {
                if (!this._btJointFeedBackObj) throw "this Constraint is not simulation";
                var t = k._bullet, n = t.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj);
                e.setValue(t.btVector3_x(n), t.btVector3_y(n), t.btVector3_z(n));
            }
        }, {
            key: "getcurrentTorque",
            value: function(e) {
                if (!this._btJointFeedBackObj) throw "this Constraint is not simulation";
                var t = k._bullet, n = t.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
                e.setValue(t.btVector3_x(n), t.btVector3_y(n), t.btVector3_z(n));
            }
        }, {
            key: "_onDestroy",
            value: function() {
                var e = k._bullet;
                this._removeFromSimulation(), this._btConstraint && this._btJointFeedBackObj && this._simulation && (e.btTypedConstraint_destroy(this._btConstraint), 
                e.btJointFeedback_destroy(this._btJointFeedBackObj), this._btJointFeedBackObj = null, 
                this._btConstraint = null), _get(_getPrototypeOf(ConstraintComponent.prototype), "_onDisable", this).call(this);
            }
        }, {
            key: "_isBreakConstrained",
            value: function() {
                if (this._getJointFeedBack = !1, -1 == this.breakForce && -1 == this.breakTorque) return !1;
                this._getFeedBackInfo();
                var e = -1 != this._breakForce && o.scalarLength(this._currentForce) > this._breakForce, t = -1 != this._breakTorque && o.scalarLength(this._currentTorque) > this._breakTorque;
                return !(!e && !t) && (this._breakConstrained(), !0);
            }
        }, {
            key: "_parse",
            value: function(e) {
                this._anchor.fromArray(e.anchor), this._connectAnchor.fromArray(e.connectAnchor), 
                this.setFrames();
            }
        }, {
            key: "_getFeedBackInfo",
            value: function() {
                var e = k._bullet, t = e.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj), n = e.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
                this._currentTorque.setValue(e.btVector3_x(n), e.btVector3_y(n), e.btVector3_z(n)), 
                this._currentForce.setValue(e.btVector3_x(t), e.btVector3_y(t), e.btVector3_z(t)), 
                this._getJointFeedBack = !0;
            }
        }, {
            key: "_breakConstrained",
            value: function() {
                this.ownBody.constaintRigidbodyA = null, this.connectedBody.constaintRigidbodyB = null, 
                this.destroy();
            }
        }, {
            key: "enabled",
            get: function() {
                return _get(_getPrototypeOf(ConstraintComponent.prototype), "enabled", this);
            },
            set: function(e) {
                _set(_getPrototypeOf(ConstraintComponent.prototype), "enabled", e, this, !0);
            }
        }, {
            key: "appliedImpulse",
            get: function() {
                return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0), this._feedbackEnabled = !0), 
                this._btConstraint.AppliedImpulse;
            }
        }, {
            key: "connectedBody",
            set: function(e) {
                this._connectedBody = e, e.constaintRigidbodyB = this;
            },
            get: function() {
                return this._connectedBody;
            }
        }, {
            key: "ownBody",
            get: function() {
                return this._ownBody;
            },
            set: function(e) {
                this._ownBody = e, e.constaintRigidbodyA = this;
            }
        }, {
            key: "currentForce",
            get: function() {
                return this._getJointFeedBack || this._getFeedBackInfo(), this._currentForce;
            }
        }, {
            key: "currentTorque",
            get: function() {
                return this._getJointFeedBack || this._getFeedBackInfo(), this._currentTorque;
            }
        }, {
            key: "breakForce",
            get: function() {
                return this._breakForce;
            },
            set: function(e) {
                this._breakForce = e;
            }
        }, {
            key: "breakTorque",
            get: function() {
                return this._breakTorque;
            },
            set: function(e) {
                this._breakTorque = e;
            }
        }, {
            key: "anchor",
            set: function(e) {
                e.cloneTo(this._anchor), this.setFrames();
            },
            get: function() {
                return this._anchor;
            }
        }, {
            key: "connectAnchor",
            set: function(e) {
                e.cloneTo(this._connectAnchor), this.setFrames();
            },
            get: function() {
                return this._connectAnchor;
            }
        } ]), ConstraintComponent;
    }();
    Ar.CONSTRAINT_POINT2POINT_CONSTRAINT_TYPE = 3, Ar.CONSTRAINT_HINGE_CONSTRAINT_TYPE = 4, 
    Ar.CONSTRAINT_CONETWIST_CONSTRAINT_TYPE = 5, Ar.CONSTRAINT_D6_CONSTRAINT_TYPE = 6, 
    Ar.CONSTRAINT_SLIDER_CONSTRAINT_TYPE = 7, Ar.CONSTRAINT_CONTACT_CONSTRAINT_TYPE = 8, 
    Ar.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE = 9, Ar.CONSTRAINT_GEAR_CONSTRAINT_TYPE = 10, 
    Ar.CONSTRAINT_FIXED_CONSTRAINT_TYPE = 11, Ar.CONSTRAINT_MAX_CONSTRAINT_TYPE = 12, 
    Ar.CONSTRAINT_CONSTRAINT_ERP = 1, Ar.CONSTRAINT_CONSTRAINT_STOP_ERP = 2, Ar.CONSTRAINT_CONSTRAINT_CFM = 3, 
    Ar.CONSTRAINT_CONSTRAINT_STOP_CFM = 4, Ar.tempForceV3 = new o();
    var xr = function(e) {
        function FixedConstraint() {
            var e;
            return _classCallCheck(this, FixedConstraint), (e = _possibleConstructorReturn(this, _getPrototypeOf(FixedConstraint).call(this, Ar.CONSTRAINT_FIXED_CONSTRAINT_TYPE))).breakForce = -1, 
            e.breakTorque = -1, e;
        }
        return _inherits(FixedConstraint, Ar), _createClass(FixedConstraint, [ {
            key: "_addToSimulation",
            value: function() {
                this._simulation && this._simulation.addConstraint(this, this.enabled);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation.removeConstraint(this), this._simulation = null;
            }
        }, {
            key: "_createConstraint",
            value: function() {
                if (this.ownBody && this.ownBody._simulation && this.connectedBody && this.connectedBody._simulation) {
                    var e = k._bullet;
                    this._btConstraint = e.btFixedConstraint_create(this.ownBody.btColliderObject, this._btframATrans, this.connectedBody.btColliderObject, this._btframBTrans), 
                    this._btJointFeedBackObj = e.btJointFeedback_create(this._btConstraint), e.btTypedConstraint_setJointFeedback(this._btConstraint, this._btJointFeedBackObj), 
                    this._simulation = this.owner._scene.physicsSimulation, this._addToSimulation(), 
                    k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !0);
                }
            }
        }, {
            key: "_onAdded",
            value: function() {
                _get(_getPrototypeOf(FixedConstraint.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this._btConstraint && (_get(_getPrototypeOf(FixedConstraint.prototype), "_onEnable", this).call(this), 
                this._btConstraint && k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !0));
            }
        }, {
            key: "_onDisable",
            value: function() {
                _get(_getPrototypeOf(FixedConstraint.prototype), "_onDisable", this).call(this), 
                this.connectedBody || this._removeFromSimulation(), this._btConstraint && k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !1);
            }
        }, {
            key: "_onDestroy",
            value: function() {
                _get(_getPrototypeOf(FixedConstraint.prototype), "_onDestroy", this).call(this);
            }
        }, {
            key: "_parse",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                _get(_getPrototypeOf(FixedConstraint.prototype), "_parse", this).call(this, e), 
                -1 != e.rigidbodyID && -1 != e.connectRigidbodyID && (t.component.push(this), t.data.push(e)), 
                null != e.breakForce && (this.breakForce = e.breakForce), null != e.breakTorque && (this.breakTorque = e.breakTorque);
            }
        }, {
            key: "_parseInteractive",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = t[e.rigidbodyID].getComponent(b), r = t[e.connectRigidbodyID].getComponent(b);
                this.ownBody = n, this.connectedBody = r;
            }
        }, {
            key: "_cloneTo",
            value: function(e) {}
        } ]), FixedConstraint;
    }(), Lr = function(e) {
        function ConfigurableConstraint() {
            var e;
            _classCallCheck(this, ConfigurableConstraint), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConfigurableConstraint).call(this, Ar.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE)))._axis = new o(), 
            e._secondaryAxis = new o(), e._minLinearLimit = new o(), e._maxLinearLimit = new o(), 
            e._minAngularLimit = new o(), e._maxAngularLimit = new o(), e._linearLimitSpring = new o(), 
            e._angularLimitSpring = new o(), e._linearBounce = new o(), e._angularBounce = new o(), 
            e._linearDamp = new o(), e._angularDamp = new o(), e._xMotion = 0, e._yMotion = 0, 
            e._zMotion = 0, e._angularXMotion = 0, e._angularYMotion = 0, e._angularZMotion = 0;
            var t = k._bullet;
            return e._btAxis = t.btVector3_create(-1, 0, 0), e._btSecondaryAxis = t.btVector3_create(0, 1, 0), 
            e;
        }
        return _inherits(ConfigurableConstraint, Ar), _createClass(ConfigurableConstraint, [ {
            key: "setAxis",
            value: function(e, t) {
                if (this._btConstraint) {
                    var n = k._bullet;
                    this._axis.setValue(e.x, e.y, e.y), this._secondaryAxis.setValue(t.x, t.y, t.z), 
                    this._btAxis = n.btVector3_setValue(-e.x, e.y, e.z), this._btSecondaryAxis = n.btVector3_setValue(-t.x, t.y, t.z), 
                    n.btGeneric6DofSpring2Constraint_setAxis(this._btConstraint, this._btAxis, this._btSecondaryAxis);
                }
            }
        }, {
            key: "setLimit",
            value: function(e, t, n, r) {
                if (this._btConstraint) {
                    var i = k._bullet;
                    switch (t) {
                      case ConfigurableConstraint.CONFIG_MOTION_TYPE_LOCKED:
                        i.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, e, 0, 0);
                        break;

                      case ConfigurableConstraint.CONFIG_MOTION_TYPE_LIMITED:
                        n < r && i.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, e, n, r);
                        break;

                      case ConfigurableConstraint.CONFIG_MOTION_TYPE_FREE:
                        i.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, e, 1, 0);
                        break;

                      default:
                        throw "No Type of Axis Motion";
                    }
                }
            }
        }, {
            key: "setSpring",
            value: function(e, t) {
                var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                if (this._btConstraint) {
                    var r = k._bullet, i = t > 0;
                    r.btGeneric6DofSpring2Constraint_enableSpring(this._btConstraint, e, i), i && r.btGeneric6DofSpring2Constraint_setStiffness(this._btConstraint, e, t, n);
                }
            }
        }, {
            key: "setBounce",
            value: function(e, t) {
                this._btConstraint && (t = t <= 0 ? 0 : t, k._bullet.btGeneric6DofSpring2Constraint_setBounce(this._btConstraint, e, t));
            }
        }, {
            key: "setDamping",
            value: function(e, t) {
                var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                this._btConstraint && (t = t <= 0 ? 0 : t, k._bullet.btGeneric6DofSpring2Constraint_setDamping(this._btConstraint, e, t, n));
            }
        }, {
            key: "setEquilibriumPoint",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_setEquilibriumPoint(this._btConstraint, e, t);
            }
        }, {
            key: "enableMotor",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_enableMotor(this._btConstraint, e, t);
            }
        }, {
            key: "setServo",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_setServo(this._btConstraint, e, t);
            }
        }, {
            key: "setTargetVelocity",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_setTargetVelocity(this._btConstraint, e, t);
            }
        }, {
            key: "setTargetPosition",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_setServoTarget(this._btConstraint, e, t);
            }
        }, {
            key: "setMaxMotorForce",
            value: function(e, t) {
                k._bullet.btGeneric6DofSpring2Constraint_setMaxMotorForce(this._btConstraint, e, t);
            }
        }, {
            key: "setParam",
            value: function(e, t, n) {
                k._bullet.btTypedConstraint_setParam(this._btConstraint, e, t, n);
            }
        }, {
            key: "setFrames",
            value: function() {
                _get(_getPrototypeOf(ConfigurableConstraint.prototype), "setFrames", this).call(this);
                var e = k._bullet;
                this._btConstraint && e.btGeneric6DofSpring2Constraint_setFrames(this._btConstraint, this._btframATrans, this._btframBTrans);
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation && this._simulation.addConstraint(this, this.enabled);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation.removeConstraint(this), this._simulation = null;
            }
        }, {
            key: "_createConstraint",
            value: function() {
                var e = k._bullet;
                this._btConstraint = e.btGeneric6DofSpring2Constraint_create(this.ownBody.btColliderObject, this._btframAPos, this.connectedBody.btColliderObject, this._btframBPos, ConfigurableConstraint.RO_XYZ), 
                this._btJointFeedBackObj = e.btJointFeedback_create(this._btConstraint), e.btTypedConstraint_setJointFeedback(this._btConstraint, this._btJointFeedBackObj), 
                this._simulation = this.owner._scene.physicsSimulation, this._initAllConstraintInfo(), 
                this._addToSimulation(), k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !0);
            }
        }, {
            key: "_initAllConstraintInfo",
            value: function() {
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._xMotion, -this._maxLinearLimit.x, -this._minLinearLimit.x), 
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._yMotion, this._minLinearLimit.y, this._maxLinearLimit.y), 
                this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._zMotion, this._minLinearLimit.z, this._maxLinearLimit.z), 
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularXMotion, -this._maxAngularLimit.x, -this._minAngularLimit.x), 
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularYMotion, this._minAngularLimit.y, this._maxAngularLimit.y), 
                this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularZMotion, this._minAngularLimit.z, this._maxAngularLimit.z), 
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearLimitSpring.x), 
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearLimitSpring.y), 
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearLimitSpring.z), 
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularLimitSpring.x), 
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularLimitSpring.y), 
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularLimitSpring.z), 
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearBounce.x), 
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearBounce.y), 
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearBounce.z), 
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularBounce.x), 
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularBounce.y), 
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularBounce.z), 
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearDamp.x), 
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearDamp.y), 
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._linearDamp.z), 
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularDamp.x), 
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularDamp.y), 
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularDamp.z), 
                this.setFrames(), this.setEquilibriumPoint(0, 0);
            }
        }, {
            key: "_onAdded",
            value: function() {
                _get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this._btConstraint && (_get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onEnable", this).call(this), 
                this._btConstraint && k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !0));
            }
        }, {
            key: "_onDisable",
            value: function() {
                _get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onDisable", this).call(this), 
                this.connectedBody || this._removeFromSimulation(), this._btConstraint && k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !1);
            }
        }, {
            key: "_parse",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                _get(_getPrototypeOf(ConfigurableConstraint.prototype), "_parse", this).call(this, e), 
                this._axis.fromArray(e.axis), this._secondaryAxis.fromArray(e.secondaryAxis);
                var n = e.linearLimit;
                this._minLinearLimit.setValue(-n, -n, -n), this._maxLinearLimit.setValue(n, n, n);
                var r = e.linearLimitSpring;
                this._linearLimitSpring.setValue(r, r, r);
                var i = e.linearLimitDamper;
                this._linearDamp.setValue(i, i, i);
                var a = e.linearLimitBounciness;
                this._linearBounce.setValue(a, a, a);
                var o = e.lowAngularXLimit, s = e.highAngularXLimit, l = e.angularYLimit, u = e.angularZLimit;
                this._minAngularLimit.setValue(o, -l, -u), this._maxAngularLimit.setValue(s, l, u);
                var c = e.highAngularXLimitBounciness, h = e.angularYLimitBounciness, _ = e.angularZLimitBounciness;
                this._angularBounce.setValue(c, h, _);
                var d = e.angularXLimitSpring, f = e.angularYZLimitSpring;
                this._angularLimitSpring.setValue(d, f, f);
                var m = e.angularXLimitDamper, T = e.angularYZLimitDamper;
                this._angularDamp.setValue(m, T, T), this.XMotion = e.xMotion, this.YMotion = e.yMotion, 
                this.ZMotion = e.zMotion, this.angularXMotion = e.angularXMotion, this.angularYMotion = e.angularYMotion, 
                this.angularZMotion = e.angularZMotion, -1 != e.rigidbodyID && -1 != e.connectRigidbodyID && (t.component.push(this), 
                t.data.push(e)), null != e.breakForce && (this.breakForce = e.breakForce), null != e.breakTorque && (this.breakTorque = e.breakTorque);
            }
        }, {
            key: "_parseInteractive",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = t[e.rigidbodyID].getComponent(b), r = t[e.connectRigidbodyID].getComponent(b);
                this.ownBody = n, this.connectedBody = r;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                _get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onDestroy", this).call(this);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {}
        }, {
            key: "axis",
            get: function() {
                return this._axis;
            }
        }, {
            key: "secondaryAxis",
            get: function() {
                return this._secondaryAxis;
            }
        }, {
            key: "maxAngularLimit",
            set: function(e) {
                e.cloneTo(this._maxAngularLimit);
            },
            get: function() {
                return this._maxAngularLimit;
            }
        }, {
            key: "minAngularLimit",
            set: function(e) {
                e.cloneTo(this._minAngularLimit);
            },
            get: function() {
                return this._minAngularLimit;
            }
        }, {
            key: "maxLinearLimit",
            set: function(e) {
                e.cloneTo(this._maxLinearLimit);
            },
            get: function() {
                return this._maxLinearLimit;
            }
        }, {
            key: "minLinearLimit",
            set: function(e) {
                e.cloneTo(this._minLinearLimit);
            },
            get: function() {
                return this._minLinearLimit;
            }
        }, {
            key: "XMotion",
            set: function(e) {
                this._xMotion != e && (this._xMotion = e, this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e, -this._maxLinearLimit.x, -this._minLinearLimit.x));
            },
            get: function() {
                return this._xMotion;
            }
        }, {
            key: "YMotion",
            set: function(e) {
                this._yMotion != e && (this._yMotion = e, this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e, this._minLinearLimit.y, this._maxLinearLimit.y));
            },
            get: function() {
                return this._yMotion;
            }
        }, {
            key: "ZMotion",
            set: function(e) {
                this._zMotion != e && (this._zMotion = e, this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e, this._minLinearLimit.z, this._maxLinearLimit.z));
            },
            get: function() {
                return this._zMotion;
            }
        }, {
            key: "angularXMotion",
            set: function(e) {
                this._angularXMotion != e && (this._angularXMotion = e, this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e, -this._maxAngularLimit.x, -this._minAngularLimit.x));
            },
            get: function() {
                return this._angularXMotion;
            }
        }, {
            key: "angularYMotion",
            set: function(e) {
                this._angularYMotion != e && (this._angularYMotion = e, this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e, this._minAngularLimit.y, this._maxAngularLimit.y));
            },
            get: function() {
                return this._angularYMotion;
            }
        }, {
            key: "angularZMotion",
            set: function(e) {
                this._angularZMotion != e && (this._angularZMotion = e, this.setLimit(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e, this._minAngularLimit.z, this._maxAngularLimit.z));
            },
            get: function() {
                return this._angularZMotion;
            }
        }, {
            key: "linearLimitSpring",
            set: function(e) {
                o.equals(this._linearLimitSpring, e) || (e.cloneTo(this._linearLimitSpring), this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), 
                this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._linearLimitSpring;
            }
        }, {
            key: "angularLimitSpring",
            set: function(e) {
                o.equals(this._angularLimitSpring, e) || (e.cloneTo(this._angularLimitSpring), this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), 
                this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._angularLimitSpring;
            }
        }, {
            key: "linearBounce",
            set: function(e) {
                o.equals(this._linearBounce, e) || (e.cloneTo(this._linearBounce), this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), 
                this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._linearBounce;
            }
        }, {
            key: "angularBounce",
            set: function(e) {
                o.equals(this._angularBounce, e) || (e.cloneTo(this._angularBounce), this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), 
                this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._angularBounce;
            }
        }, {
            key: "linearDamp",
            set: function(e) {
                o.equals(this._linearDamp, e) || (e.cloneTo(this._linearDamp), this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), 
                this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._linearDamp;
            }
        }, {
            key: "angularDamp",
            set: function(e) {
                o.equals(this._angularDamp, e) || (e.cloneTo(this._angularDamp), this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), 
                this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z));
            },
            get: function() {
                return this._angularDamp;
            }
        }, {
            key: "anchor",
            set: function(e) {
                e.cloneTo(this._anchor), this.setFrames();
            },
            get: function() {
                return this._anchor;
            }
        }, {
            key: "connectAnchor",
            set: function(e) {
                e.cloneTo(this._connectAnchor), this.setFrames();
            },
            get: function() {
                return this._connectAnchor;
            }
        } ]), ConfigurableConstraint;
    }();
    Lr.CONFIG_MOTION_TYPE_LOCKED = 0, Lr.CONFIG_MOTION_TYPE_LIMITED = 1, Lr.CONFIG_MOTION_TYPE_FREE = 2, 
    Lr.MOTION_LINEAR_INDEX_X = 0, Lr.MOTION_LINEAR_INDEX_Y = 1, Lr.MOTION_LINEAR_INDEX_Z = 2, 
    Lr.MOTION_ANGULAR_INDEX_X = 3, Lr.MOTION_ANGULAR_INDEX_Y = 4, Lr.MOTION_ANGULAR_INDEX_Z = 5, 
    Lr.RO_XYZ = 0, Lr.RO_XZY = 1, Lr.RO_YXZ = 2, Lr.RO_YZX = 3, Lr.RO_ZXY = 4, Lr.RO_ZYX = 5;
    var Ir = function() {
        function Laya3D() {
            _classCallCheck(this, Laya3D);
        }
        return _createClass(Laya3D, null, [ {
            key: "_cancelLoadByUrl",
            value: function(e) {
                t.Laya.loader.cancelLoadByUrl(e), Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(e), 
                Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(e), Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(e), 
                Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
            }
        }, {
            key: "_changeWebGLSize",
            value: function(e, n) {
                t.WebGL.onStageResize(e, n), re.clientWidth = e, re.clientHeight = n;
            }
        }, {
            key: "__init__",
            value: function(n, r, i) {
                if (t.Config.isAntialias = i.isAntialias, t.Config.isAlpha = i.isAlpha, t.Config.premultipliedAlpha = i.premultipliedAlpha, 
                t.Config.isStencil = i.isStencil, t.WebGL.enable()) {
                    t.RunDriver.changeWebGLSize = Laya3D._changeWebGLSize, t.Render.is3DMode = !0, t.Laya.init(n, r), 
                    t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext, 
                    t.LayaGL.instance.createCommandEncoder = function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64, r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        return new t.CommandEncoder(this, e, n, r);
                    }), i._multiLighting = i.enableMultiLight && t.SystemUtils.supportTextureFormat(t.TextureFormat.R32G32B32A32), 
                    l.Shader3D = ue, l.Scene3D = tn, l.MeshRenderStaticBatchManager = Ft, l.MeshRenderDynamicBatchManager = pn, 
                    l.SubMeshDynamicBatch = Tn, l.Laya3D = Laya3D, l.Matrix4x4 = c, l.Physics3D = k, 
                    l.ShadowLightType = e.ShadowLightType, Laya3D.enableNative3D(), i.isUseCannonPhysicsEngine && k.__cannoninit__(), 
                    k.__bulletinit__(), Ye.__init__(), Qe.__init__(), Yn.__init__(), jn.__init__(), 
                    vt.__init__(), ar.__init__(), cr.__init__(), It.__init__(), bt.__init__(), Tn.__init__(), 
                    gr.__init__(), Tt.init(), Se.__init__(), ln.__init__(), on.__init__(), Mr.__init__(), 
                    mr.__init__(), Tr.__init__(), et.__init__(), Pt.__init__(), gn.__init__(), tr.__init__(), 
                    Jn.__init__(), ur.__init__(), he.__init__(), tn.__init__(), Ft.__init__(), me.__initDefine__(), 
                    Te.__initDefine__(), ge.__initDefine__(), cn.__initDefine__(), hn.__initDefine__(), 
                    nr.__initDefine__(), Ee.__initDefine__(), _n.__initDefine__(), zn.__initDefine__(), 
                    ve.__initDefine__(), Mt.__initDefine__(), un.__initDefine__(), at.__init__(), t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", Mr), 
                    t.ClassUtils.regClass("Laya.EffectMaterial", Ee), t.ClassUtils.regClass("Laya.UnlitMaterial", hn), 
                    t.ClassUtils.regClass("Laya.BlinnPhongMaterial", ge), t.ClassUtils.regClass("Laya.SkyProceduralMaterial", cn), 
                    t.ClassUtils.regClass("Laya.PBRStandardMaterial", ln), t.ClassUtils.regClass("Laya.PBRSpecularMaterial", on), 
                    t.ClassUtils.regClass("Laya.SkyBoxMaterial", un), t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", _n), 
                    t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", ve), t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", zn), 
                    t.ClassUtils.regClass("Laya.TrailMaterial", nr), t.ClassUtils.regClass("Laya.PhysicsCollider", _r), 
                    t.ClassUtils.regClass("Laya.Rigidbody3D", b), t.ClassUtils.regClass("Laya.CharacterController", P), 
                    t.ClassUtils.regClass("Laya.Animator", te), t.ClassUtils.regClass("PhysicsCollider", _r), 
                    t.ClassUtils.regClass("CharacterController", P), t.ClassUtils.regClass("Animator", te), 
                    t.ClassUtils.regClass("Rigidbody3D", b), t.ClassUtils.regClass("FixedConstraint", xr), 
                    t.ClassUtils.regClass("ConfigurableConstraint", Lr), Mt.defaultMaterial = new Mt(), 
                    ge.defaultMaterial = new ge(), Ee.defaultMaterial = new Ee(), hn.defaultMaterial = new hn(), 
                    zn.defaultMaterial = new zn(), nr.defaultMaterial = new nr(), cn.defaultMaterial = new cn(), 
                    un.defaultMaterial = new un(), _n.defaultMaterial = new _n(), Mt.defaultMaterial.lock = !0, 
                    ge.defaultMaterial.lock = !0, Ee.defaultMaterial.lock = !0, hn.defaultMaterial.lock = !0, 
                    zn.defaultMaterial.lock = !0, nr.defaultMaterial.lock = !0, cn.defaultMaterial.lock = !0, 
                    un.defaultMaterial.lock = !0, _n.defaultMaterial.lock = !0, t.Texture2D.__init__(), 
                    Ct.__init__(), Je.__init__(), St.__init__(), rt.__init__(), it.__init__(), Le.__init__(), 
                    W.__init__();
                    var a = t.LoaderManager.createMap;
                    a.lh = [ Laya3D.HIERARCHY, Sr._parse ], a.ls = [ Laya3D.HIERARCHY, Sr._parseScene ], 
                    a.lm = [ Laya3D.MESH, Dr._parse ], a.lmat = [ Laya3D.MATERIAL, me._parse ], a.jpg = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], 
                    a.jpeg = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], a.bmp = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], 
                    a.gif = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], a.png = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], 
                    a.dds = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], a.ktx = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], 
                    a.pvr = [ Laya3D.TEXTURE2D, t.Texture2D._parse ], a.lani = [ Laya3D.ANIMATIONCLIP, j._parse ], 
                    a.lav = [ Laya3D.AVATAR, fe._parse ], a.ltc = [ Laya3D.TEXTURECUBE, Ct._parse ], 
                    a.ltcb = [ Laya3D.TEXTURECUBEBIN, Ct._parseBin ], a["ltcb.ls"] = [ Laya3D.TEXTURECUBEBIN, Ct._parseBin ];
                    var o = t.Loader.parserMap;
                    o[Laya3D.HIERARCHY] = Laya3D._loadHierarchy, o[Laya3D.MESH] = Laya3D._loadMesh, 
                    o[Laya3D.MATERIAL] = Laya3D._loadMaterial, o[Laya3D.TEXTURECUBE] = Laya3D._loadTextureCube, 
                    o[Laya3D.TEXTURECUBEBIN] = Laya3D._loadTextureCubeBin, o[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D, 
                    o[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip, o[Laya3D.AVATAR] = Laya3D._loadAvatar, 
                    Laya3D._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError), 
                    Laya3D._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError), 
                    Laya3D._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError), 
                    Laya3D._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError);
                } else alert("Laya3D init error,must support webGL!");
            }
        }, {
            key: "enableNative3D",
            value: function() {
                var e = ce, n = Re, r = er, i = fe, a = Le;
                if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative, 
                e.prototype.setBool = e.prototype.setBoolForNative, e.prototype.getBool = e.prototype.getBoolForNative, 
                e.prototype.setInt = e.prototype.setIntForNative, e.prototype.getInt = e.prototype.getIntForNative, 
                e.prototype.setNumber = e.prototype.setNumberForNative, e.prototype.getNumber = e.prototype.getNumberForNative, 
                e.prototype.setVector = e.prototype.setVectorForNative, e.prototype.getVector = e.prototype.getVectorForNative, 
                e.prototype.setVector2 = e.prototype.setVector2ForNative, e.prototype.getVector2 = e.prototype.getVector2ForNative, 
                e.prototype.setVector3 = e.prototype.setVector3ForNative, e.prototype.getVector3 = e.prototype.getVector3ForNative, 
                e.prototype.setQuaternion = e.prototype.setQuaternionForNative, e.prototype.getQuaternion = e.prototype.getQuaternionForNative, 
                e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative, 
                e.prototype.setBuffer = e.prototype.setBufferForNative, e.prototype.getBuffer = e.prototype.getBufferForNative, 
                e.prototype.setTexture = e.prototype.setTextureForNative, e.prototype.getTexture = e.prototype.getTextureForNative, 
                e.prototype.setAttribute = e.prototype.setAttributeForNative, e.prototype.getAttribute = e.prototype.getAttributeForNative, 
                e.prototype.cloneTo = e.prototype.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative, 
                n.prototype._uniformMatrix2fv = n.prototype._uniformMatrix2fvForNative, n.prototype._uniformMatrix3fv = n.prototype._uniformMatrix3fvForNative, 
                n.prototype._uniformMatrix4fv = n.prototype._uniformMatrix4fvForNative, t.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner.uploadShaderUniformsForNative), 
                t.Render.supportWebGLPlusCulling && (a.renderObjectCulling = Le.renderObjectCullingNative), 
                t.Render.supportWebGLPlusAnimation) {
                    i.prototype._cloneDatasToAnimator = i.prototype._cloneDatasToAnimatorNative;
                    var o = j;
                    o.prototype._evaluateClipDatasRealTime = o.prototype._evaluateClipDatasRealTimeForNative, 
                    r.prototype._computeSkinnedData = r.prototype._computeSkinnedDataForNative;
                }
            }
        }, {
            key: "formatRelativePath",
            value: function(e, t) {
                var n;
                if (n = e + t, "." === t.charAt(0)) {
                    for (var r = n.split("/"), i = 0, a = r.length; i < a; i++) if (".." == r[i]) {
                        var o = i - 1;
                        o > 0 && ".." !== r[o] && (r.splice(o, 2), i -= 2);
                    }
                    n = r.join("/");
                }
                return n;
            }
        }, {
            key: "_endLoad",
            value: function(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                if (r) for (var i = 0, a = r.length; i < a; i++) {
                    var o = t.Loader.getRes(r[i]);
                    o && o._removeReference();
                }
                e.endLoad(n);
            }
        }, {
            key: "_eventLoadManagerError",
            value: function(e) {
                t.Laya.loader.event(t.Event.ERROR, e);
            }
        }, {
            key: "_addHierarchyInnerUrls",
            value: function(e, t, n, r, i, a) {
                var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l = Laya3D.formatRelativePath(r, i);
                return n && (l += n), e.push({
                    url: l,
                    type: a,
                    constructParams: o,
                    propertyParams: s
                }), t.push(l), l;
            }
        }, {
            key: "_getSprite3DHierarchyInnerUrls",
            value: function(e, t, n, r, i, a, o, s) {
                var l, u, c = e.props;
                switch (e.type) {
                  case "Scene3D":
                    var h = c.lightmaps;
                    for (l = 0, u = h.length; l < u; l++) {
                        var _ = h[l];
                        if (_.path) _.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, _.path, Laya3D.TEXTURE2D, _.constructParams, _.propertyParams); else {
                            var d = _.color;
                            d.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, d.path, Laya3D.TEXTURE2D, d.constructParams, d.propertyParams);
                            var f = _.direction;
                            f && (f.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, f.path, Laya3D.TEXTURE2D, f.constructParams, f.propertyParams));
                        }
                    }
                    var m = c.reflectionTexture;
                    m && (c.reflection = Laya3D._addHierarchyInnerUrls(r, a, o, s, m, Laya3D.TEXTURECUBE));
                    var T = c.reflection;
                    if (T && (c.reflection = Laya3D._addHierarchyInnerUrls(i, a, o, s, T, Laya3D.TEXTURECUBEBIN)), 
                    c.sky) {
                        var p = c.sky.material;
                        p && (p.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, p.path, Laya3D.MATERIAL));
                    }
                    break;

                  case "Camera":
                    var g = c.skyboxMaterial;
                    g && (g.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, g.path, Laya3D.MATERIAL));
                    break;

                  case "TrailSprite3D":
                  case "MeshSprite3D":
                  case "SkinnedMeshSprite3D":
                    var E = c.meshPath;
                    E && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, E, Laya3D.MESH));
                    var y = c.materials;
                    if (y) for (l = 0, u = y.length; l < u; l++) y[l].path = Laya3D._addHierarchyInnerUrls(n, a, o, s, y[l].path, Laya3D.MATERIAL);
                    break;

                  case "ShuriKenParticle3D":
                    if (c.main) {
                        var v = c.renderer.resources, S = v.mesh, C = v.material;
                        S && (v.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, Laya3D.MESH)), C && (v.material = Laya3D._addHierarchyInnerUrls(n, a, o, s, C, Laya3D.MATERIAL));
                    } else {
                        var R = c.meshPath;
                        R && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, R, Laya3D.MESH)), c.material.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, c.material.path, Laya3D.MATERIAL);
                    }
                    break;

                  case "Terrain":
                    Laya3D._addHierarchyInnerUrls(i, a, o, s, c.dataPath, Laya3D.TERRAINRES);
                }
                var D = e.components;
                if (D) for (var M = 0, A = D.length; M < A; M++) {
                    var x = D[M];
                    switch (x.type) {
                      case "Animator":
                        x.avatarPath;
                        var L = x.avatar;
                        L && (L.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, L.path, Laya3D.AVATAR));
                        var I = x.clipPaths;
                        if (I) for (l = 0, u = I.length; l < u; l++) I[l] = Laya3D._addHierarchyInnerUrls(i, a, o, s, I[l], Laya3D.ANIMATIONCLIP); else {
                            var O = x.layers;
                            for (l = 0; l < O.length; l++) for (var P = O[l].states, N = 0, b = P.length; N < b; N++) {
                                var k = P[N].clipPath;
                                k && (P[N].clipPath = Laya3D._addHierarchyInnerUrls(i, a, o, s, k, Laya3D.ANIMATIONCLIP));
                            }
                        }
                        break;

                      case "PhysicsCollider":
                      case "Rigidbody3D":
                      case "CharacterController":
                        var w = x.shapes;
                        for (l = 0; l < w.length; l++) {
                            var B = w[l];
                            if ("MeshColliderShape" === B.type) (S = B.mesh) && (B.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, Laya3D.MESH));
                        }
                    }
                }
                var V = e.child;
                for (l = 0, u = V.length; l < u; l++) Laya3D._getSprite3DHierarchyInnerUrls(V[l], t, n, r, i, a, o, s);
            }
        }, {
            key: "_loadHierarchy",
            value: function(e) {
                e._originType = e.type, e.on(t.Event.LOADED, null, Laya3D._onHierarchylhLoaded, [ e ]), 
                e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onHierarchylhLoaded",
            value: function(e, n) {
                var r = e.url, i = O.getURLVerion(r), a = t.URL.getPath(r), o = [], s = [], l = [], u = [], c = [];
                Laya3D._getSprite3DHierarchyInnerUrls(n.data, o, s, l, u, c, i, a);
                var h = o.length + s.length + u.length, _ = h + 1, d = 1 / _;
                if (Laya3D._onProcessChange(e, 0, d, 1), u.length > 0) {
                    var f = h / _, m = t.Handler.create(null, Laya3D._onProcessChange, [ e, d, f ], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(u, !1, t.Handler.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [ e, m, n, c, o, s, l, d + f * u.length, f ]), m, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerForthLevResouLoaded(e, null, n, c, o, s, l, d, f);
            }
        }, {
            key: "_onHierarchyInnerForthLevResouLoaded",
            value: function(e, n, r, i, a, o, s, l, u) {
                if (n && n.recover(), s.length > 0) {
                    var c = t.Handler.create(null, Laya3D._onProcessChange, [ e, l, u ], !1);
                    Laya3D._innerThirdLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [ e, c, r, i, a, o, l + u * o.length, u ]), n, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerThirdLevResouLoaded(e, null, r, i, a, o, l, u);
            }
        }, {
            key: "_onHierarchyInnerThirdLevResouLoaded",
            value: function(e, n, r, i, a, o, s, l) {
                if (n && n.recover(), o.length > 0) {
                    var u = t.Handler.create(null, Laya3D._onProcessChange, [ e, s, l ], !1);
                    Laya3D._innerSecondLevelLoaderManager._create(o, !1, t.Handler.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [ e, u, r, i, a, s + l * o.length, l ]), n, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerSecondLevResouLoaded(e, null, r, i, a, s, l);
            }
        }, {
            key: "_onHierarchyInnerSecondLevResouLoaded",
            value: function(e, n, r, i, a, o, s) {
                if (n && n.recover(), a.length > 0) {
                    var l = t.Handler.create(null, Laya3D._onProcessChange, [ e, o, s ], !1);
                    Laya3D._innerFirstLevelLoaderManager._create(a, !1, t.Handler.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [ e, l, r, i ]), n, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerFirstLevResouLoaded(e, null, r, i);
            }
        }, {
            key: "_onHierarchyInnerFirstLevResouLoaded",
            value: function(e, t, n, r) {
                t && t.recover(), e._cache = e._createCache;
                var i = "Scene3D" === n.data.type ? Sr._parseScene(n, e._propertyParams, e._constructParams) : Sr._parse(n, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, r);
            }
        }, {
            key: "_loadMesh",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMeshLmLoaded, [ e ]), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onMeshLmLoaded",
            value: function(e, t) {
                e._cache = e._createCache;
                var n = Dr._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, n);
            }
        }, {
            key: "_loadMaterial",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [ e ]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onMaterilLmatLoaded",
            value: function(e, n) {
                var r, i = e.url, a = O.getURLVerion(i), o = t.URL.getPath(i), s = [], l = [];
                n.customProps;
                switch (n.version) {
                  case "LAYAMATERIAL:01":
                  case "LAYAMATERIAL:02":
                    var u, c, h = n.props.textures;
                    if (h) for (u = 0, c = h.length; u < c; u++) {
                        var _ = h[u], d = _.path;
                        d && (r = Laya3D.formatRelativePath(o, d), a && (r += a), s.push({
                            url: r,
                            constructParams: _.constructParams,
                            propertyParams: _.propertyParams
                        }), l.push(r), _.path = r);
                    }
                    break;

                  default:
                    throw new Error("Laya3D:unkonwn version.");
                }
                var f = s.length, m = f + 1, T = 1 / m;
                if (Laya3D._onProcessChange(e, 0, T, 1), f > 0) {
                    var p = t.Handler.create(null, Laya3D._onProcessChange, [ e, T, f / m ], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onMateialTexturesLoaded, [ e, p, n, l ]), p, null, null, null, 1, !0);
                } else Laya3D._onMateialTexturesLoaded(e, null, n, null);
            }
        }, {
            key: "_onMateialTexturesLoaded",
            value: function(e, t, n, r) {
                e._cache = e._createCache;
                var i = me._parse(n, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, r), t && t.recover();
            }
        }, {
            key: "_loadAvatar",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var n = fe._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, n);
                }), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadAnimationClip",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var n = j._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, n);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_loadTexture2D",
            value: function(e) {
                var n, r = e.url, i = r.lastIndexOf(".") + 1, a = r.indexOf("?"), o = -1 == a ? r.length : a;
                switch (r.substr(i, o - i)) {
                  case "jpg":
                  case "jpeg":
                  case "bmp":
                  case "gif":
                  case "png":
                    n = "nativeimage";
                    break;

                  case "dds":
                  case "ktx":
                  case "pvr":
                    n = t.Loader.BUFFER;
                }
                e.on(t.Event.LOADED, null, function(n) {
                    e._cache = e._createCache;
                    var r = t.Texture2D._parse(n, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, r);
                }), e.load(e.url, n, !1, null, !0);
            }
        }, {
            key: "_loadTextureCube",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [ e ]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadTextureCubeBin",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(n) {
                    e._cache = e._createCache;
                    var r = new t.Byte(n);
                    if ("LAYATEXTURECUBE:0000" !== r.readUTFString()) throw "Laya3D:unknow version.";
                    var i = r.readUint8(), a = r.getUint8(), o = r.readUint16(), s = r.getUint8(), l = r.getUint8(), u = r.getUint8(), c = r.getUint8(), h = new Ct(o, i, a > 1);
                    h.filterMode = s, h.wrapModeU = l, h.wrapModeV = u, h.anisoLevel = c;
                    for (var _ = r.pos, d = o, f = 0; f < a; f++) {
                        for (var m = new Array(6), T = d * d * h._getFormatByteCount(), p = 0; p < 6; p++) m[p] = new Uint8Array(n, _, T), 
                        _ += T;
                        h.setSixSidePixels(m, f), d /= 2;
                    }
                    Laya3D._endLoad(e, h);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onTextureCubeLtcLoaded",
            value: function(e, n) {
                var r = t.URL.getPath(e.url), i = [ Laya3D.formatRelativePath(r, n.front), Laya3D.formatRelativePath(r, n.back), Laya3D.formatRelativePath(r, n.left), Laya3D.formatRelativePath(r, n.right), Laya3D.formatRelativePath(r, n.up), Laya3D.formatRelativePath(r, n.down) ];
                Laya3D._onProcessChange(e, 0, 1 / 7, 1);
                var a = t.Handler.create(null, Laya3D._onProcessChange, [ e, 1 / 7, 6 / 7 ], !1);
                Laya3D._innerFourthLevelLoaderManager.load(i, t.Handler.create(null, Laya3D._onTextureCubeImagesLoaded, [ e, i, a ]), a, "nativeimage");
            }
        }, {
            key: "_onTextureCubeImagesLoaded",
            value: function(e, n, r) {
                for (var i = new Array(6), a = 0; a < 6; a++) i[a] = t.Loader.getRes(n[a]);
                e._cache = e._createCache;
                var o = Ct._parse(i, e._propertyParams, e._constructParams);
                for (r.recover(), a = 0; a < 6; a++) t.Loader.clearRes(n[a]);
                Laya3D._endLoad(e, o);
            }
        }, {
            key: "_onProcessChange",
            value: function(e, n, r, i) {
                (i = n + i * r) < 1 && e.event(t.Event.PROGRESS, 2 * i / 3 + 1 / 3);
            }
        }, {
            key: "init",
            value: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                if (Laya3D._isInit) r && r.run(); else {
                    Laya3D._isInit = !0, n && n.cloneTo(w._config), n = w._config, Le.debugFrustumCulling = n.debugFrustumCulling, 
                    Laya3D._editerEnvironment = n._editerEnvironment, tn.octreeCulling = n.octreeCulling, 
                    tn.octreeInitialSize = n.octreeInitialSize, tn.octreeInitialCenter = n.octreeInitialCenter, 
                    tn.octreeMinNodeSize = n.octreeMinNodeSize, tn.octreeLooseness = n.octreeLooseness;
                    var i = window.Physics3D;
                    null == i || n.isUseCannonPhysicsEngine ? (k._enablePhysics = !1, Laya3D.__init__(e, t, n), 
                    r && r.run()) : (k._enablePhysics = !0, i(16 * n.defaultPhysicsMemory, hr._interactive).then(function() {
                        Laya3D.__init__(e, t, n), r && r.run();
                    }));
                }
            }
        }, {
            key: "enablePhysics",
            get: function() {
                return k._enablePhysics;
            }
        } ]), Laya3D;
    }();
    Ir.HIERARCHY = "HIERARCHY", Ir.MESH = "MESH", Ir.MATERIAL = "MATERIAL", Ir.TEXTURE2D = "TEXTURE2D", 
    Ir.TEXTURECUBE = "TEXTURECUBE", Ir.TEXTURECUBEBIN = "TEXTURECUBEBIN", Ir.ANIMATIONCLIP = "ANIMATIONCLIP", 
    Ir.AVATAR = "AVATAR", Ir.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Ir.TERRAINRES = "TERRAIN", 
    Ir._innerFirstLevelLoaderManager = new t.LoaderManager(), Ir._innerSecondLevelLoaderManager = new t.LoaderManager(), 
    Ir._innerThirdLevelLoaderManager = new t.LoaderManager(), Ir._innerFourthLevelLoaderManager = new t.LoaderManager(), 
    Ir._isInit = !1, Ir._editerEnvironment = !1, Ir.physicsSettings = new yt(), window.Laya3D = Ir;
    var Or = function(e) {
        function CastShadowList() {
            return _classCallCheck(this, CastShadowList), _possibleConstructorReturn(this, _getPrototypeOf(CastShadowList).call(this));
        }
        return _inherits(CastShadowList, C), _createClass(CastShadowList, [ {
            key: "add",
            value: function(e) {
                if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
                this._add(e), e._indexInCastShadowList = this.length++;
            }
        }, {
            key: "remove",
            value: function(e) {
                var t = e._indexInCastShadowList;
                if (this.length--, t !== this.length) {
                    var n = this.elements[this.length];
                    this.elements[t] = n, n._indexInCastShadowList = t;
                }
                e._indexInCastShadowList = -1;
            }
        } ]), CastShadowList;
    }(), Pr = function() {
        function AnimatorStateScript() {
            _classCallCheck(this, AnimatorStateScript);
        }
        return _createClass(AnimatorStateScript, [ {
            key: "onStateEnter",
            value: function() {}
        }, {
            key: "onStateUpdate",
            value: function() {}
        }, {
            key: "onStateExit",
            value: function() {}
        } ]), AnimatorStateScript;
    }(), Nr = function(e) {
        function Script3D() {
            var e;
            return _classCallCheck(this, Script3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Script3D).apply(this, arguments)))._indexInPool = -1, 
            e;
        }
        return _inherits(Script3D, t.Component), _createClass(Script3D, [ {
            key: "_checkProcessTriggers",
            value: function() {
                var e = Script3D.prototype;
                return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
            }
        }, {
            key: "_checkProcessCollisions",
            value: function() {
                var e = Script3D.prototype;
                return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
            }
        }, {
            key: "_onAwake",
            value: function() {
                this.onAwake(), this.onStart !== Script3D.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
            }
        }, {
            key: "_onEnable",
            value: function() {
                this.owner._scene._addScript(this), this.onEnable();
            }
        }, {
            key: "_onDisable",
            value: function() {
                this.owner._scene._removeScript(this), this.owner.offAllCaller(this), this.onDisable();
            }
        }, {
            key: "_onDestroy",
            value: function() {
                var e = this.owner._scripts;
                e.splice(e.indexOf(this), 1);
                var t = this.owner;
                t._needProcessTriggers = !1;
                for (var n = 0, r = e.length; n < r; n++) if (e[n]._checkProcessTriggers()) {
                    t._needProcessTriggers = !0;
                    break;
                }
                for (t._needProcessCollisions = !1, n = 0, r = e.length; n < r; n++) if (e[n]._checkProcessCollisions()) {
                    t._needProcessCollisions = !0;
                    break;
                }
                this.onDestroy();
            }
        }, {
            key: "_isScript",
            value: function() {
                return !0;
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = this.owner, t = e._scripts;
                t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()), 
                e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
            }
        }, {
            key: "onAwake",
            value: function() {}
        }, {
            key: "onEnable",
            value: function() {}
        }, {
            key: "onStart",
            value: function() {}
        }, {
            key: "onTriggerEnter",
            value: function(e) {}
        }, {
            key: "onTriggerStay",
            value: function(e) {}
        }, {
            key: "onTriggerExit",
            value: function(e) {}
        }, {
            key: "onCollisionEnter",
            value: function(e) {}
        }, {
            key: "onCollisionStay",
            value: function(e) {}
        }, {
            key: "onCollisionExit",
            value: function(e) {}
        }, {
            key: "onJointBreak",
            value: function() {}
        }, {
            key: "onMouseDown",
            value: function() {}
        }, {
            key: "onMouseDrag",
            value: function() {}
        }, {
            key: "onMouseClick",
            value: function() {}
        }, {
            key: "onMouseUp",
            value: function() {}
        }, {
            key: "onMouseEnter",
            value: function() {}
        }, {
            key: "onMouseOver",
            value: function() {}
        }, {
            key: "onMouseOut",
            value: function() {}
        }, {
            key: "onUpdate",
            value: function() {}
        }, {
            key: "onLateUpdate",
            value: function() {}
        }, {
            key: "onPreRender",
            value: function() {}
        }, {
            key: "onPostRender",
            value: function() {}
        }, {
            key: "onDisable",
            value: function() {}
        }, {
            key: "onDestroy",
            value: function() {}
        }, {
            key: "isSingleton",
            get: function() {
                return !1;
            }
        } ]), Script3D;
    }(), br = function() {
        function HeightMap(e, t, n, r) {
            _classCallCheck(this, HeightMap), this._datas = [], this._w = e, this._h = t, this._minHeight = n, 
            this._maxHeight = r;
        }
        return _createClass(HeightMap, [ {
            key: "_inBounds",
            value: function(e, t) {
                return e >= 0 && e < this._h && t >= 0 && t < this._w;
            }
        }, {
            key: "getHeight",
            value: function(e, t) {
                return this._inBounds(e, t) ? this._datas[e][t] : NaN;
            }
        }, {
            key: "width",
            get: function() {
                return this._w;
            }
        }, {
            key: "height",
            get: function() {
                return this._h;
            }
        }, {
            key: "maxHeight",
            get: function() {
                return this._maxHeight;
            }
        }, {
            key: "minHeight",
            get: function() {
                return this._minHeight;
            }
        } ], [ {
            key: "creatFromMesh",
            value: function(e, t, n, r) {
                for (var i = [], a = [], s = e.subMeshCount, l = 0; l < s; l++) {
                    for (var u = e.getSubMesh(l), c = u._vertexBuffer, h = c.getFloat32Data(), _ = [], d = 0; d < h.length; d += c.vertexDeclaration.vertexStride / 4) {
                        var f = new o(h[d + 0], h[d + 1], h[d + 2]);
                        _.push(f);
                    }
                    i.push(_);
                    var m = u._indexBuffer;
                    a.push(m.getData());
                }
                var T = e.bounds, p = T.getMin().x, g = T.getMin().z, E = T.getMax().x, y = T.getMax().z, v = T.getMin().y, S = T.getMax().y, C = E - p, R = y - g, D = r.x = C / (t - 1), M = r.y = R / (n - 1), A = new HeightMap(t, n, v, S), x = HeightMap._tempRay, L = x.direction;
                L.x = 0, L.y = -1, L.z = 0;
                var I = S + .1;
                x.origin.y = I;
                for (var O = 0; O < n; O++) {
                    var P = g + O * M;
                    A._datas[O] = [];
                    for (var N = 0; N < t; N++) {
                        var b = p + N * D, k = x.origin;
                        k.x = b, k.z = P;
                        var w = HeightMap._getPosition(x, i, a);
                        A._datas[O][N] = w === Number.MAX_VALUE ? NaN : I - w;
                    }
                }
                return A;
            }
        }, {
            key: "createFromImage",
            value: function(e, t, n) {
                for (var r = e.width, i = e.height, a = new HeightMap(r, i, t, n), o = (n - t) / 254, s = e.getPixels(), l = 0, u = 0; u < i; u++) for (var c = a._datas[u] = [], h = 0; h < r; h++) {
                    var _ = s[l++], d = s[l++], f = s[l++], m = s[l++];
                    c[h] = 255 == _ && 255 == d && 255 == f && 255 == m ? NaN : (_ + d + f) / 3 * o + t;
                }
                return a;
            }
        }, {
            key: "_getPosition",
            value: function(e, t, n) {
                for (var r = Number.MAX_VALUE, i = 0; i < t.length; i++) for (var a = t[i], o = n[i], s = 0; s < o.length; s += 3) {
                    var l = a[o[s + 0]], u = a[o[s + 1]], c = a[o[s + 2]], h = He.rayIntersectsTriangle(e, l, u, c);
                    !isNaN(h) && h < r && (r = h);
                }
                return r;
            }
        } ]), HeightMap;
    }();
    br._tempRay = new we(new o(), new o());
    var kr = function(e) {
        function MeshTerrainSprite3D(e, t) {
            var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            return _classCallCheck(this, MeshTerrainSprite3D), (n = _possibleConstructorReturn(this, _getPrototypeOf(MeshTerrainSprite3D).call(this, e, i)))._heightMap = t, 
            n._cellSize = new r(), n;
        }
        return _inherits(MeshTerrainSprite3D, gn), _createClass(MeshTerrainSprite3D, [ {
            key: "_disableRotation",
            value: function() {
                var e = this.transform.rotation;
                e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
            }
        }, {
            key: "_getScaleX",
            value: function() {
                var e = this.transform.worldMatrix.elements, t = e[0], n = e[1], r = e[2];
                return Math.sqrt(t * t + n * n + r * r);
            }
        }, {
            key: "_getScaleZ",
            value: function() {
                var e = this.transform.worldMatrix.elements, t = e[8], n = e[9], r = e[10];
                return Math.sqrt(t * t + n * n + r * r);
            }
        }, {
            key: "_initCreateFromMesh",
            value: function(e, t) {
                this._heightMap = br.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
                var n = this.meshFilter.sharedMesh.bounds, r = n.getMin();
                n.getMax();
                this._minX = r.x, this._minZ = r.z;
            }
        }, {
            key: "_initCreateFromMeshHeightMap",
            value: function(e, t, n) {
                var r = this.meshFilter.sharedMesh.bounds;
                this._heightMap = br.createFromImage(e, t, n), this._computeCellSize(r);
                var i = r.getMin();
                r.getMax();
                this._minX = i.x, this._minZ = i.z;
            }
        }, {
            key: "_computeCellSize",
            value: function(e) {
                var t = e.getMin(), n = e.getMax(), r = t.x, i = t.z, a = n.x - r, o = n.z - i;
                this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = o / (this._heightMap.height - 1);
            }
        }, {
            key: "_update",
            value: function(e) {
                this._disableRotation();
            }
        }, {
            key: "getHeight",
            value: function(e, t) {
                MeshTerrainSprite3D._tempVector3.x = e, MeshTerrainSprite3D._tempVector3.y = 0, 
                MeshTerrainSprite3D._tempVector3.z = t, this._disableRotation();
                var n = this.transform.worldMatrix;
                n.invert(MeshTerrainSprite3D._tempMatrix4x4), o.transformCoordinate(MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4, MeshTerrainSprite3D._tempVector3), 
                e = MeshTerrainSprite3D._tempVector3.x, t = MeshTerrainSprite3D._tempVector3.z;
                var r = (e - this._minX) / this._cellSize.x, i = (t - this._minZ) / this._cellSize.y, a = Math.floor(i), s = Math.floor(r), l = r - s, u = i - a, c = n.elements, h = c[4], _ = c[5], d = c[6], f = Math.sqrt(h * h + _ * _ + d * d), m = c[13], T = this._heightMap.getHeight(a, s + 1), p = this._heightMap.getHeight(a + 1, s);
                if (isNaN(T) || isNaN(p)) return NaN;
                if (l + u <= 1) {
                    var g = this._heightMap.getHeight(a, s);
                    return isNaN(g) ? NaN : (g + l * (T - g) + u * (p - g)) * f + m;
                }
                var E = this._heightMap.getHeight(a + 1, s + 1);
                return isNaN(E) ? NaN : (E + (1 - l) * (p - E) + (1 - u) * (T - E)) * f + m;
            }
        }, {
            key: "minX",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minX * this._getScaleX() + e[12];
            }
        }, {
            key: "minZ",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minZ * this._getScaleZ() + e[14];
            }
        }, {
            key: "width",
            get: function() {
                return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
            }
        }, {
            key: "depth",
            get: function() {
                return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
            }
        } ], [ {
            key: "createFromMesh",
            value: function(e, t, n) {
                var r = new MeshTerrainSprite3D(e, null, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null);
                return r._initCreateFromMesh(t, n), r;
            }
        }, {
            key: "createFromMeshAndHeightMap",
            value: function(e, t, n, r) {
                var i = new MeshTerrainSprite3D(e, null, arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null);
                return i._initCreateFromMeshHeightMap(t, n, r), i;
            }
        } ]), MeshTerrainSprite3D;
    }();
    kr._tempVector3 = new o(), kr._tempMatrix4x4 = new c();
    var wr = function() {
        function GradientDataVector2() {
            _classCallCheck(this, GradientDataVector2), this._currentLength = 0, this._elements = new Float32Array(12);
        }
        return _createClass(GradientDataVector2, [ {
            key: "add",
            value: function(e, t) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")), 
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x, 
                this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._currentLength = this._currentLength;
                for (var n = t._elements, r = 0, i = this._elements.length; r < i; r++) n[r] = this._elements[r];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new GradientDataVector2();
                return this.cloneTo(e), e;
            }
        }, {
            key: "gradientCount",
            get: function() {
                return this._currentLength / 3;
            }
        } ]), GradientDataVector2;
    }(), Br = function() {
        function PixelLineData() {
            _classCallCheck(this, PixelLineData), this.startPosition = new o(), this.endPosition = new o(), 
            this.startColor = new Me(), this.endColor = new Me();
        }
        return _createClass(PixelLineData, [ {
            key: "cloneTo",
            value: function(e) {
                this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition), 
                this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
            }
        } ]), PixelLineData;
    }(), Vr = function() {
        function PostProcessEffect() {
            _classCallCheck(this, PostProcessEffect);
        }
        return _createClass(PostProcessEffect, [ {
            key: "render",
            value: function(e) {}
        } ]), PostProcessEffect;
    }(), Fr = function(e) {
        function BloomEffect() {
            var e;
            return _classCallCheck(this, BloomEffect), (e = _possibleConstructorReturn(this, _getPrototypeOf(BloomEffect).call(this)))._shader = null, 
            e._shaderData = new ce(), e._linearColor = new Me(), e._bloomTextureTexelSize = new i(), 
            e._shaderThreshold = new i(), e._shaderParams = new i(), e._pyramid = null, e._intensity = 0, 
            e._threshold = 1, e._softKnee = .5, e._diffusion = 7, e._anamorphicRatio = 0, e._dirtIntensity = 0, 
            e._shaderSetting = new i(), e._dirtTileOffset = new i(), e.clamp = 65472, e.color = new Me(1, 1, 1, 1), 
            e.fastMode = !1, e.dirtTexture = null, e._shader = ue.find("PostProcessBloom"), 
            e._pyramid = new Array(2 * BloomEffect.MAXPYRAMIDSIZE), e;
        }
        return _inherits(BloomEffect, Vr), _createClass(BloomEffect, [ {
            key: "render",
            value: function(e) {
                var n = e.command, r = e.camera.viewport;
                this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                var a, o = this._anamorphicRatio, s = o < 0 ? -o : 0, l = o > 0 ? o : 0, u = Math.floor(r.width / (2 - s)), c = Math.floor(r.height / (2 - l)), h = Math.max(u, c);
                a = Math.log2(h) + this._diffusion - 10;
                var _ = Math.floor(a), d = Math.min(Math.max(_, 1), BloomEffect.MAXPYRAMIDSIZE), f = .5 + a - _;
                this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, f);
                var m = Me.gammaToLinearSpace(this.threshold), T = m * this._softKnee + 1e-5;
                this._shaderThreshold.setValue(m, m - T, 2 * T, .25 / T), this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
                var p = Me.gammaToLinearSpace(this.clamp);
                this._shaderParams.setValue(p, 0, 0, 0), this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
                for (var g = this.fastMode ? 1 : 0, E = e.source, y = 0; y < d; y++) {
                    var v = 2 * y, S = v + 1, C = 0 == y ? BloomEffect.SUBSHADER_PREFILTER13 + g : BloomEffect.SUBSHADER_DOWNSAMPLE13 + g, R = ie.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                    if (R.filterMode = t.FilterMode.Bilinear, this._pyramid[v] = R, y !== d - 1) {
                        var D = ie.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                        D.filterMode = t.FilterMode.Bilinear, this._pyramid[S] = D;
                    }
                    n.blitScreenTriangle(E, R, null, this._shader, this._shaderData, C), E = R, u = Math.max(Math.floor(u / 2), 1), 
                    c = Math.max(Math.floor(c / 2), 1);
                }
                var M = this._pyramid[2 * (d - 1)];
                for (y = d - 2; y >= 0; y--) S = (v = 2 * y) + 1, R = this._pyramid[v], D = this._pyramid[S], 
                n.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, R), n.blitScreenTriangle(M, D, null, this._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + g), 
                M = D;
                var A = this._linearColor;
                this.color.toLinear(A);
                var x = Math.pow(2, this._intensity / 10) - 1, L = this._shaderSetting;
                this._shaderSetting.setValue(f, x, this._dirtIntensity, d);
                var I = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture, O = I.width / I.height, P = r.width / r.height, N = this._dirtTileOffset;
                O > P ? N.setValue(P / O, 1, .5 * (1 - N.x), 0) : O < P && N.setValue(1, O / P, 0, .5 * (1 - N.y));
                var b = e.compositeShaderData;
                for (this.fastMode ? b.addDefine(he.SHADERDEFINE_BLOOM_LOW) : b.addDefine(he.SHADERDEFINE_BLOOM), 
                this._bloomTextureTexelSize.setValue(1 / M.width, 1 / M.height, M.width, M.height), 
                b.setVector(he.SHADERVALUE_BLOOM_DIRTTILEOFFSET, N), b.setVector(he.SHADERVALUE_BLOOM_SETTINGS, L), 
                b.setVector(he.SHADERVALUE_BLOOM_COLOR, new i(A.r, A.g, A.b, A.a)), b.setTexture(he.SHADERVALUE_BLOOM_DIRTTEX, I), 
                b.setTexture(he.SHADERVALUE_BLOOMTEX, M), b.setVector(he.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize), 
                y = 0; y < d; y++) S = (v = 2 * y) + 1, ie.recoverToPool(this._pyramid[v]), 0 !== y && y !== d - 1 && ie.recoverToPool(this._pyramid[S]);
                e.deferredReleaseTextures.push(M);
            }
        }, {
            key: "intensity",
            get: function() {
                return this._intensity;
            },
            set: function(e) {
                this._intensity = Math.max(e, 0);
            }
        }, {
            key: "threshold",
            get: function() {
                return this._threshold;
            },
            set: function(e) {
                this._threshold = Math.max(e, 0);
            }
        }, {
            key: "softKnee",
            get: function() {
                return this._softKnee;
            },
            set: function(e) {
                this._softKnee = Math.min(Math.max(e, 0), 1);
            }
        }, {
            key: "diffusion",
            get: function() {
                return this._diffusion;
            },
            set: function(e) {
                this._diffusion = Math.min(Math.max(e, 1), 10);
            }
        }, {
            key: "anamorphicRatio",
            get: function() {
                return this._anamorphicRatio;
            },
            set: function(e) {
                this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
            }
        }, {
            key: "dirtIntensity",
            get: function() {
                return this._dirtIntensity;
            },
            set: function(e) {
                this._dirtIntensity = Math.max(e, 0);
            }
        } ]), BloomEffect;
    }();
    Fr.SHADERVALUE_MAINTEX = ue.propertyNameToID("u_MainTex"), Fr.SHADERVALUE_AUTOEXPOSURETEX = ue.propertyNameToID("u_AutoExposureTex"), 
    Fr.SHADERVALUE_SAMPLESCALE = ue.propertyNameToID("u_SampleScale"), Fr.SHADERVALUE_THRESHOLD = ue.propertyNameToID("u_Threshold"), 
    Fr.SHADERVALUE_PARAMS = ue.propertyNameToID("u_Params"), Fr.SHADERVALUE_BLOOMTEX = ue.propertyNameToID("u_BloomTex"), 
    Fr.SUBSHADER_PREFILTER13 = 0, Fr.SUBSHADER_PREFILTER4 = 1, Fr.SUBSHADER_DOWNSAMPLE13 = 2, 
    Fr.SUBSHADER_DOWNSAMPLE4 = 3, Fr.SUBSHADER_UPSAMPLETENT = 4, Fr.SUBSHADER_UPSAMPLEBOX = 5, 
    Fr.MAXPYRAMIDSIZE = 16;
    var Ur = function() {
        function RandX(e) {
            if (_classCallCheck(this, RandX), !(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        return _createClass(RandX, [ {
            key: "randomint",
            value: function() {
                var e = this._state0U, t = this._state0L, n = this._state1U, r = this._state1L, i = (r >>> 0) + (t >>> 0), a = n + e + (i / 2 >>> 31) >>> 0, o = i >>> 0;
                this._state0U = n, this._state0L = r;
                var s = 0, l = 0;
                s = (e ^= s = e << 23 | (-512 & t) >>> 9) ^ n, l = (t ^= l = t << 23) ^ r;
                s ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
                return s ^= n >>> 5, l ^= r >>> 5 | (31 & n) << 27, this._state1U = s, this._state1L = l, 
                [ a, o ];
            }
        }, {
            key: "random",
            value: function() {
                var e = this.randomint(), t = e[0], n = 1023 << 20 | t >>> 12, r = 0 | (e[1] >>> 12 | (4095 & t) << 20);
                return RandX._CONVERTION_BUFFER.setUint32(0, n, !1), RandX._CONVERTION_BUFFER.setUint32(4, r, !1), 
                RandX._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
            }
        } ]), RandX;
    }();
    Ur._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Ur.defaultRand = new Ur([ 0, Date.now() / 65536, 0, Date.now() % 65536 ]);
    var Gr = function() {
        function Point2PointConstraint() {
            _classCallCheck(this, Point2PointConstraint), this._pivotInA = new o(), this._pivotInB = new o();
        }
        return _createClass(Point2PointConstraint, [ {
            key: "pivotInA",
            get: function() {
                return this._pivotInA;
            },
            set: function(e) {
                this._pivotInA = e;
            }
        }, {
            key: "pivotInB",
            get: function() {
                return this._pivotInB;
            },
            set: function(e) {
                this._pivotInB = e;
            }
        }, {
            key: "damping",
            get: function() {
                return this._damping;
            },
            set: function(e) {
                this._damping = e;
            }
        }, {
            key: "impulseClamp",
            get: function() {
                return this._impulseClamp;
            },
            set: function(e) {
                this._impulseClamp = e;
            }
        }, {
            key: "tau",
            get: function() {
                return this._tau;
            },
            set: function(e) {
                this._tau = e;
            }
        } ]), Point2PointConstraint;
    }(), Hr = function() {
        function TextMesh() {
            _classCallCheck(this, TextMesh);
        }
        return _createClass(TextMesh, [ {
            key: "_createVertexBuffer",
            value: function(e) {}
        }, {
            key: "_resizeVertexBuffer",
            value: function(e) {}
        }, {
            key: "_addChar",
            value: function() {}
        }, {
            key: "text",
            get: function() {
                return this._text;
            },
            set: function(e) {
                this._text = e;
            }
        }, {
            key: "fontSize",
            get: function() {
                return this._fontSize;
            },
            set: function(e) {
                this._fontSize = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._color;
            },
            set: function(e) {
                this._color = e;
            }
        } ]), TextMesh;
    }(), zr = function() {
        function Size(e, t) {
            _classCallCheck(this, Size), this._width = 0, this._height = 0, this._width = e, 
            this._height = t;
        }
        return _createClass(Size, [ {
            key: "width",
            get: function() {
                return -1 === this._width ? re.clientWidth : this._width;
            }
        }, {
            key: "height",
            get: function() {
                return -1 === this._height ? re.clientHeight : this._height;
            }
        } ], [ {
            key: "fullScreen",
            get: function() {
                return new Size(-1, -1);
            }
        } ]), Size;
    }();
    e.AlternateLightQueue = Dt, e.AnimationClip = j, e.AnimationClipParser03 = z, e.AnimationClipParser04 = X, 
    e.AnimationEvent = V, e.AnimationNode = de, e.AnimationTransform3D = _e, e.Animator = te, 
    e.AnimatorControllerLayer = Q, e.AnimatorPlayState = Z, e.AnimatorState = $, e.AnimatorStateScript = Pr, 
    e.Avatar = fe, e.BaseCamera = nt, e.BaseMaterial = Te, e.BaseRender = Ut, e.BaseShape = On, 
    e.BatchMark = Nt, e.BlinnPhongMaterial = ge, e.BlitScreenQuadCMD = ot, e.BloomEffect = Fr, 
    e.BoundBox = At, e.BoundFrustum = Ue, e.BoundSphere = Zt, e.Bounds = xt, e.BoundsOctree = Yt, 
    e.BoundsOctreeNode = Wt, e.BoxColliderShape = T, e.BoxShape = Nn, e.BufferState = We, 
    e.BulletInteractive = hr, e.Burst = vn, e.Camera = pt, e.CameraCullInfo = Ae, e.CapsuleColliderShape = p, 
    e.CastShadowList = Or, e.CharacterController = P, e.CircleShape = bn, e.Cluster = Oe, 
    e.ColliderShape = h, e.Collision = A, e.CollisionTool = x, e.CollisionUtils = Fe, 
    e.Color = Me, e.ColorOverLifetime = Cn, e.Command = at, e.CommandBuffer = ct, e.CompoundColliderShape = d, 
    e.ConchQuaternion = J, e.ConchVector3 = K, e.ConchVector4 = q, e.ConeColliderShape = g, 
    e.ConeShape = kn, e.Config3D = w, e.ConfigurableConstraint = Lr, e.Constraint3D = function Constraint3D() {
        _classCallCheck(this, Constraint3D);
    }, e.ConstraintComponent = Ar, e.ContactPoint = D, e.ContainmentType = Be, e.CylinderColliderShape = E, 
    e.DefineDatas = ae, e.DirectionLight = Er, e.DynamicBatchManager = en, e.EffectMaterial = Ee, 
    e.Emission = Qn, e.ExtendTerrainMaterial = ve, e.FixedConstraint = xr, e.FloatKeyframe = U, 
    e.FrameOverTime = Rn, e.FrustumCulling = Le, e.GeometryElement = Lt, e.Gradient = yn, 
    e.GradientAngularVelocity = Dn, e.GradientColor = Sn, e.GradientDataInt = Mn, e.GradientDataNumber = An, 
    e.GradientDataVector2 = wr, e.GradientMode = En, e.GradientSize = xn, e.GradientVelocity = Ln, 
    e.HalfFloatUtils = W, e.HeightMap = br, e.HeightfieldColliderShape = function HeightfieldColliderShape() {
        _classCallCheck(this, HeightfieldColliderShape);
    }, e.HemisphereShape = wn, e.HitResult = M, e.ILaya3D = l, e.IndexBuffer3D = Xe, 
    e.Input3D = gt, e.Keyframe = F, e.KeyframeNode = B, e.KeyframeNodeList = Y, e.KeyframeNodeOwner = ee, 
    e.Laya3D = Ir, e.LightQueue = Rt, e.LightSprite = ft, e.Lightmap = jt, e.LoadModelV04 = Cr, 
    e.LoadModelV05 = Rr, e.Material = me, e.MathUtils3D = n, e.Matrix3x3 = s, e.Matrix4x4 = c, 
    e.Mesh = mr, e.MeshColliderShape = y, e.MeshFilter = mn, e.MeshReader = Dr, e.MeshRenderDynamicBatchManager = pn, 
    e.MeshRenderStaticBatchManager = Ft, e.MeshRenderer = fn, e.MeshSprite3D = gn, e.MeshSprite3DShaderDeclaration = dn, 
    e.MeshTerrainSprite3D = kr, e.MouseTouch = Ne, e.OctreeMotionList = Xt, e.PBRMaterial = Se, 
    e.PBRSpecularMaterial = on, e.PBRStandardMaterial = ln, e.Physics3D = k, e.Physics3DUtils = m, 
    e.PhysicsCollider = _r, e.PhysicsComponent = S, e.PhysicsSettings = yt, e.PhysicsSimulation = L, 
    e.PhysicsTriggerComponent = N, e.PhysicsUpdateList = R, e.Picker = He, e.PixelLineData = Br, 
    e.PixelLineFilter = Ot, e.PixelLineMaterial = Mt, e.PixelLineRenderer = Gt, e.PixelLineSprite3D = Ht, 
    e.PixelLineVertex = It, e.Plane = ke, e.Point2PointConstraint = Gr, e.PointLight = yr, 
    e.PostProcess = he, e.PostProcessEffect = Vr, e.PostProcessRenderContext = ne, e.PrimitiveMesh = Tr, 
    e.Quaternion = u, e.QuaternionKeyframe = G, e.Rand = Zn, e.RandX = Ur, e.Ray = we, 
    e.RenderContext3D = re, e.RenderElement = kt, e.RenderQueue = zt, e.RenderState = pe, 
    e.RenderTexture = ie, e.RenderableSprite3D = Pt, e.Rigidbody3D = b, e.RotationOverLifetime = In, 
    e.Scene3D = tn, e.Scene3DShaderDeclaration = ht, e.Scene3DUtils = Sr, e.SceneManager = function SceneManager() {
        _classCallCheck(this, SceneManager);
    }, e.ScreenQuad = rt, e.ScreenTriangle = it, e.Script3D = Nr, e.SetRenderTargetCMD = st, 
    e.SetShaderDataTextureCMD = lt, e.Shader3D = ue, e.ShaderData = ce, e.ShaderDefine = oe, 
    e.ShaderInit3D = gr, e.ShaderInstance = Re, e.ShaderPass = nn, e.ShaderVariable = Ce, 
    e.ShaderVariant = se, e.ShaderVariantCollection = le, e.ShadowCasterPass = Jt, e.ShadowCullInfo = xe, 
    e.ShadowSliceData = qt, e.ShadowSpotData = Kt, e.ShadowUtils = Tt, e.ShapeUtils = Pn, 
    e.ShuriKenParticle3D = Jn, e.ShuriKenParticle3DShaderDeclaration = Hn, e.ShurikenParticleData = qn, 
    e.ShurikenParticleMaterial = zn, e.ShurikenParticleRenderer = Wn, e.ShurikenParticleSystem = Kn, 
    e.SimpleSingletonList = De, e.SingletonList = C, e.Size = zr, e.SizeOverLifetime = Vn, 
    e.SkinnedMeshRenderer = er, e.SkinnedMeshSprite3D = tr, e.SkinnedMeshSprite3DShaderDeclaration = $n, 
    e.SkyBox = Je, e.SkyBoxMaterial = un, e.SkyDome = St, e.SkyMesh = Ke, e.SkyPanoramicMaterial = Mr, 
    e.SkyProceduralMaterial = cn, e.SkyRenderer = $e, e.SphereColliderShape = v, e.SphereShape = Bn, 
    e.SphericalHarmonicsL2 = Pe, e.SpotLight = vr, e.Sprite3D = et, e.StartFrame = Fn, 
    e.StaticBatchManager = Bt, e.StaticPlaneColliderShape = _, e.SubMesh = dr, e.SubMeshDynamicBatch = Tn, 
    e.SubMeshInstanceBatch = bt, e.SubMeshRenderElement = wt, e.SubMeshStaticBatch = Vt, 
    e.SubShader = an, e.TextMesh = Hr, e.TextureCube = Ct, e.TextureGenerator = I, e.TextureMode = ir, 
    e.TextureSheetAnimation = Un, e.Touch = be, e.TrailFilter = sr, e.TrailGeometry = or, 
    e.TrailMaterial = nr, e.TrailRenderer = lr, e.TrailSprite3D = ur, e.Transform3D = f, 
    e.UnlitMaterial = hn, e.Utils3D = O, e.Vector2 = r, e.Vector3 = o, e.Vector3Keyframe = H, 
    e.Vector4 = i, e.VelocityOverLifetime = Gn, e.VertexBuffer3D = qe, e.VertexDeclaration = je, 
    e.VertexElement = Ze, e.VertexElementFormat = Ye, e.VertexMesh = Qe, e.VertexPositionTerrain = cr, 
    e.VertexPositionTexture0 = vt, e.VertexShuriKenParticle = Xn, e.VertexShurikenParticleBillboard = Yn, 
    e.VertexShurikenParticleMesh = jn, e.VertexTrail = ar, e.Viewport = Ge, e.WaterPrimaryMaterial = _n, 
    e.skinnedMatrixCache = fr;
}(window.Laya = window.Laya || {}, Laya);