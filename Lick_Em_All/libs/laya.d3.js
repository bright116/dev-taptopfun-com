!function(e, t) {
    "use strict";
    class r {
        constructor() {}
        static isZero(e) {
            return Math.abs(e) < r.zeroTolerance;
        }
        static nearEqual(e, t) {
            return !!r.isZero(e - t);
        }
        static fastInvSqrt(e) {
            return r.isZero(e) ? e : 1 / Math.sqrt(e);
        }
    }
    r.zeroTolerance = 1e-6, r.MaxValue = 3.40282347e38, r.MinValue = -3.40282347e38, 
    r.Deg2Rad = Math.PI / 180;
    class i {
        constructor(e = 0, t = 0) {
            this.x = e, this.y = t;
        }
        setValue(e, t) {
            this.x = e, this.y = t;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y;
        }
        static normalize(e, t) {
            var r = e.x, i = e.y, a = r * r + i * i;
            a > 0 && (a = 1 / Math.sqrt(a), t.x = r * a, t.y = i * a);
        }
        static scalarLength(e) {
            var t = e.x, r = e.y;
            return Math.sqrt(t * t + r * r);
        }
        clone() {
            var e = new i();
            return this.cloneTo(e), e;
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([ this.x, this.y ]), 
            i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1);
        }
        static rewriteNumProperty(e, t, r) {
            Object.defineProperty(e, t, {
                get: function() {
                    return this.elements[r];
                },
                set: function(e) {
                    this.elements[r] = e;
                }
            });
        }
    }
    i.ZERO = new i(0, 0), i.ONE = new i(1, 1);
    class a {
        constructor(e = 0, t = 0, r = 0, i = 0) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        setValue(e, t, r, i) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
        }
        clone() {
            var e = new a();
            return this.cloneTo(e), e;
        }
        static lerp(e, t, r, i) {
            var a = e.x, n = e.y, s = e.z, o = e.w;
            i.x = a + r * (t.x - a), i.y = n + r * (t.y - n), i.z = s + r * (t.z - s), i.w = o + r * (t.w - o);
        }
        static transformByM4x4(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = e.w, o = t.elements;
            r.x = i * o[0] + a * o[4] + n * o[8] + s * o[12], r.y = i * o[1] + a * o[5] + n * o[9] + s * o[13], 
            r.z = i * o[2] + a * o[6] + n * o[10] + s * o[14], r.w = i * o[3] + a * o[7] + n * o[11] + s * o[15];
        }
        static equals(e, t) {
            return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y), Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r.nearEqual(Math.abs(e.w), Math.abs(t.w));
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(e, t) {
            var r = e.length();
            if (r > 0) {
                var i = 1 / r;
                t.x = e.x * i, t.y = e.y * i, t.z = e.z * i, t.w = e.w * i;
            }
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
        }
        static subtract(e, t, r) {
            r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r.w = e.w - t.w;
        }
        static multiply(e, t, r) {
            r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r.w = e.w * t.w;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w * t;
        }
        static Clamp(e, t, r, i) {
            var a = e.x, n = e.y, s = e.z, o = e.w, l = t.x, _ = t.y, h = t.z, c = t.w, d = r.x, u = r.y, m = r.z, f = r.w;
            a = (a = a > d ? d : a) < l ? l : a, n = (n = n > u ? u : n) < _ ? _ : n, s = (s = s > m ? m : s) < h ? h : s, 
            o = (o = o > f ? f : o) < c ? c : o, i.x = a, i.y = n, i.z = s, i.w = o;
        }
        static distanceSquared(e, t) {
            var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z, n = e.w - t.w;
            return r * r + i * i + a * a + n * n;
        }
        static distance(e, t) {
            var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z, n = e.w - t.w;
            return Math.sqrt(r * r + i * i + a * a + n * n);
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }
        static min(e, t, r) {
            r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z), r.w = Math.min(e.w, t.w);
        }
        static max(e, t, r) {
            r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z), r.w = Math.max(e.w, t.w);
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
            this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
            i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2), 
            i.rewriteNumProperty(this, "w", 3);
        }
    }
    a.ZERO = new a(), a.ONE = new a(1, 1, 1, 1), a.UnitX = new a(1, 0, 0, 0), a.UnitY = new a(0, 1, 0, 0), 
    a.UnitZ = new a(0, 0, 1, 0), a.UnitW = new a(0, 0, 0, 1);
    class n {
        constructor(e = 0, t = 0, r = 0, i = null) {
            this.x = e, this.y = t, this.z = r;
        }
        static distanceSquared(e, t) {
            var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z;
            return r * r + i * i + a * a;
        }
        static distance(e, t) {
            var r = e.x - t.x, i = e.y - t.y, a = e.z - t.z;
            return Math.sqrt(r * r + i * i + a * a);
        }
        static min(e, t, r) {
            r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z);
        }
        static max(e, t, r) {
            r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z);
        }
        static transformQuat(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.x, o = t.y, l = t.z, _ = t.w, h = _ * i + o * n - l * a, c = _ * a + l * i - s * n, d = _ * n + s * a - o * i, u = -s * i - o * a - l * n;
            r.x = h * _ + u * -s + c * -l - d * -o, r.y = c * _ + u * -o + d * -s - h * -l, 
            r.z = d * _ + u * -l + h * -o - c * -s;
        }
        static scalarLength(e) {
            var t = e.x, r = e.y, i = e.z;
            return Math.sqrt(t * t + r * r + i * i);
        }
        static scalarLengthSquared(e) {
            var t = e.x, r = e.y, i = e.z;
            return t * t + r * r + i * i;
        }
        static normalize(e, t) {
            var r = e.x, i = e.y, a = e.z, n = r * r + i * i + a * a;
            n > 0 && (n = 1 / Math.sqrt(n), t.x = r * n, t.y = i * n, t.z = a * n);
        }
        static multiply(e, t, r) {
            r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t;
        }
        static lerp(e, t, r, i) {
            var a = e.x, n = e.y, s = e.z;
            i.x = a + r * (t.x - a), i.y = n + r * (t.y - n), i.z = s + r * (t.z - s);
        }
        static transformV3ToV3(e, t, r) {
            var i = n._tempVector4;
            n.transformV3ToV4(e, t, i), r.x = i.x, r.y = i.y, r.z = i.z;
        }
        static transformV3ToV4(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.elements;
            r.x = i * s[0] + a * s[4] + n * s[8] + s[12], r.y = i * s[1] + a * s[5] + n * s[9] + s[13], 
            r.z = i * s[2] + a * s[6] + n * s[10] + s[14], r.w = i * s[3] + a * s[7] + n * s[11] + s[15];
        }
        static TransformNormal(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.elements;
            r.x = i * s[0] + a * s[4] + n * s[8], r.y = i * s[1] + a * s[5] + n * s[9], r.z = i * s[2] + a * s[6] + n * s[10];
        }
        static transformCoordinate(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.elements, o = i * s[3] + a * s[7] + n * s[11] + s[15];
            r.x = (i * s[0] + a * s[4] + n * s[8] + s[12]) / o, r.y = (i * s[1] + a * s[5] + n * s[9] + s[13]) / o, 
            r.z = (i * s[2] + a * s[6] + n * s[10] + s[14]) / o;
        }
        static Clamp(e, t, r, i) {
            var a = e.x, n = e.y, s = e.z, o = t.x, l = t.y, _ = t.z, h = r.x, c = r.y, d = r.z;
            a = (a = a > h ? h : a) < o ? o : a, n = (n = n > c ? c : n) < l ? l : n, s = (s = s > d ? d : s) < _ ? _ : s, 
            i.x = a, i.y = n, i.z = s;
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z;
        }
        static subtract(e, t, r) {
            r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z;
        }
        static cross(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.x, o = t.y, l = t.z;
            r.x = a * l - n * o, r.y = n * s - i * l, r.z = i * o - a * s;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z;
        }
        static equals(e, t) {
            return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z);
        }
        setValue(e, t, r) {
            this.x = e, this.y = t, this.z = r;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z;
        }
        clone() {
            var e = new n();
            return this.cloneTo(e), e;
        }
        toDefault() {
            this.x = 0, this.y = 0, this.z = 0;
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([ this.x, this.y, this.z ]), 
            i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2);
        }
    }
    var s, o;
    n._tempVector4 = new a(), n._ZERO = new n(0, 0, 0), n._ONE = new n(1, 1, 1), n._NegativeUnitX = new n(-1, 0, 0), 
    n._UnitX = new n(1, 0, 0), n._UnitY = new n(0, 1, 0), n._UnitZ = new n(0, 0, 1), 
    n._ForwardRH = new n(0, 0, -1), n._ForwardLH = new n(0, 0, 1), n._Up = new n(0, 1, 0), 
    (s = e.PBRRenderQuality || (e.PBRRenderQuality = {}))[s.High = 0] = "High", s[s.Low = 1] = "Low";
    class l {
        constructor() {
            this._defaultPhysicsMemory = 16, this._maxLightCount = 32, this._lightClusterCount = new n(12, 12, 12), 
            this._editerEnvironment = !1, this.isAntialias = !0, this.isAlpha = !1, this.premultipliedAlpha = !0, 
            this.isStencil = !0, this.enableMultiLight = !0, this.octreeCulling = !1, this.octreeInitialSize = 64, 
            this.octreeInitialCenter = new n(0, 0, 0), this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, 
            this.debugFrustumCulling = !1, this.pbrRenderQuality = e.PBRRenderQuality.High, 
            this._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount.z - 1), this._maxLightCount);
        }
        get defaultPhysicsMemory() {
            return this._defaultPhysicsMemory;
        }
        set defaultPhysicsMemory(e) {
            if (e < 16) throw "defaultPhysicsMemory must large than 16M";
            this._defaultPhysicsMemory = e;
        }
        get maxLightCount() {
            return this._maxLightCount;
        }
        set maxLightCount(e) {
            e > 2048 ? (this._maxLightCount = 2048, console.warn("Config3D: maxLightCount must less equal 2048.")) : this._maxLightCount = e;
        }
        get lightClusterCount() {
            return this._lightClusterCount;
        }
        set lightClusterCount(e) {
            e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)), 
            console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e.cloneTo(this._lightClusterCount);
            var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
            t < this._maxLightCount && console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + t + ",maybe the far away culster will ingonre some light."), 
            this._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount);
        }
        cloneTo(e) {
            var t = e;
            t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment, 
            t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha, 
            t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter), 
            t.octreeInitialSize = this.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize, 
            t.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this.debugFrustumCulling, 
            t.maxLightCount = this.maxLightCount, t.enableMultiLight = this.enableMultiLight;
            var r = t.lightClusterCount;
            this.lightClusterCount.cloneTo(r), t.lightClusterCount = r, t.pbrRenderQuality = this.pbrRenderQuality;
        }
        clone() {
            var e = new l();
            return this.cloneTo(e), e;
        }
    }
    l._config = new l(), window.Config3D = l;
    class _ {}
    _.Shader3D = null, _.Scene3D = null, _.MeshRenderStaticBatchManager = null, _.MeshRenderDynamicBatchManager = null, 
    _.SubMeshDynamicBatch = null, _.Laya3D = null, _.Matrix4x4 = null;
    class h {
        constructor() {
            this._ownerPath = [], this._propertys = [], this._keyFrames = [];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(e) {
            this._ownerPath.length = e;
        }
        _setOwnerPathByIndex(e, t) {
            this._ownerPath[e] = t;
        }
        _joinOwnerPath(e) {
            return this._ownerPath.join(e);
        }
        _setPropertyCount(e) {
            this._propertys.length = e;
        }
        _setPropertyByIndex(e, t) {
            this._propertys[e] = t;
        }
        _joinProperty(e) {
            return this._propertys.join(e);
        }
        _setKeyframeCount(e) {
            this._keyFrames.length = e;
        }
        _setKeyframeByIndex(e, t) {
            this._keyFrames[e] = t;
        }
        getOwnerPathByIndex(e) {
            return this._ownerPath[e];
        }
        getPropertyByIndex(e) {
            return this._propertys[e];
        }
        getKeyframeByIndex(e) {
            return this._keyFrames[e];
        }
    }
    class c {
        constructor() {}
    }
    class d {
        constructor() {}
        cloneTo(e) {
            e.time = this.time;
        }
        clone() {
            var e = new d();
            return this.cloneTo(e), e;
        }
    }
    class u extends d {
        constructor() {
            super();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this.value;
        }
    }
    class m {
        constructor() {
            var e = this.elements = new Float32Array(9);
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
            e[8] = 1;
        }
        static createRotationQuaternion(e, t) {
            var r = e.x, i = e.y, a = e.z, n = e.w, s = r * r, o = i * i, l = a * a, _ = r * i, h = a * n, c = a * r, d = i * n, u = i * a, m = r * n, f = t.elements;
            f[0] = 1 - 2 * (o + l), f[1] = 2 * (_ + h), f[2] = 2 * (c - d), f[3] = 2 * (_ - h), 
            f[4] = 1 - 2 * (l + s), f[5] = 2 * (u + m), f[6] = 2 * (c + d), f[7] = 2 * (u - m), 
            f[8] = 1 - 2 * (o + s);
        }
        static createFromTranslation(e, t) {
            var r = t.elements;
            r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 1, r[5] = 0, r[6] = e.x, r[7] = e.y, 
            r[8] = 1;
        }
        static createFromRotation(e, t) {
            var r = t.elements, i = Math.sin(e), a = Math.cos(e);
            r[0] = a, r[1] = i, r[2] = 0, r[3] = -i, r[4] = a, r[5] = 0, r[6] = 0, r[7] = 0, 
            r[8] = 1;
        }
        static createFromScaling(e, t) {
            var r = t.elements;
            r[0] = e.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = e.y, r[5] = 0, r[6] = 0, r[7] = 0, 
            r[8] = e.z;
        }
        static createFromMatrix4x4(e, t) {
            var r = e.elements, i = t.elements;
            i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[4], i[4] = r[5], i[5] = r[6], i[6] = r[8], 
            i[7] = r[9], i[8] = r[10];
        }
        static multiply(e, t, r) {
            var i = e.elements, a = t.elements, n = r.elements, s = i[0], o = i[1], l = i[2], _ = i[3], h = i[4], c = i[5], d = i[6], u = i[7], m = i[8], f = a[0], E = a[1], T = a[2], p = a[3], g = a[4], S = a[5], R = a[6], v = a[7], x = a[8];
            n[0] = f * s + E * _ + T * d, n[1] = f * o + E * h + T * v, n[2] = f * l + E * c + T * m, 
            n[3] = p * s + g * _ + S * d, n[4] = p * o + g * h + S * u, n[5] = p * l + g * c + S * m, 
            n[6] = R * s + v * _ + x * d, n[7] = R * o + v * h + x * u, n[8] = R * l + v * c + x * m;
        }
        determinant() {
            var e = this.elements, t = e[0], r = e[1], i = e[2], a = e[3], n = e[4], s = e[5], o = e[6], l = e[7], _ = e[8];
            return t * (_ * n - s * l) + r * (-_ * a + s * o) + i * (l * a - n * o);
        }
        translate(e, t) {
            var r = t.elements, i = this.elements, a = i[0], n = i[1], s = i[2], o = i[3], l = i[4], _ = i[5], h = i[6], c = i[7], d = i[8], u = e.x, m = e.y;
            r[0] = a, r[1] = n, r[2] = s, r[3] = o, r[4] = l, r[5] = _, r[6] = u * a + m * o + h, 
            r[7] = u * n + m * l + c, r[8] = u * s + m * _ + d;
        }
        rotate(e, t) {
            var r = t.elements, i = this.elements, a = i[0], n = i[1], s = i[2], o = i[3], l = i[4], _ = i[5], h = i[6], c = i[7], d = i[8], u = Math.sin(e), m = Math.cos(e);
            r[0] = m * a + u * o, r[1] = m * n + u * l, r[2] = m * s + u * _, r[3] = m * o - u * a, 
            r[4] = m * l - u * n, r[5] = m * _ - u * s, r[6] = h, r[7] = c, r[8] = d;
        }
        scale(e, t) {
            var r = t.elements, i = this.elements, a = e.x, n = e.y;
            r[0] = a * i[0], r[1] = a * i[1], r[2] = a * i[2], r[3] = n * i[3], r[4] = n * i[4], 
            r[5] = n * i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8];
        }
        invert(e) {
            var t = e.elements, r = this.elements, i = r[0], a = r[1], n = r[2], s = r[3], o = r[4], l = r[5], _ = r[6], h = r[7], c = r[8], d = c * o - l * h, u = -c * s + l * _, m = h * s - o * _, f = i * d + a * u + n * m;
            f || (e = null), f = 1 / f, t[0] = d * f, t[1] = (-c * a + n * h) * f, t[2] = (l * a - n * o) * f, 
            t[3] = u * f, t[4] = (c * i - n * _) * f, t[5] = (-l * i + n * s) * f, t[6] = m * f, 
            t[7] = (-h * i + a * _) * f, t[8] = (o * i - a * s) * f;
        }
        transpose(e) {
            var t = e.elements, r = this.elements;
            if (e === this) {
                var i = r[1], a = r[2], n = r[5];
                t[1] = r[3], t[2] = r[6], t[3] = i, t[5] = r[7], t[6] = a, t[7] = n;
            } else t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] = r[7], 
            t[6] = r[2], t[7] = r[5], t[8] = r[8];
        }
        identity() {
            var e = this.elements;
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
            e[8] = 1;
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements)) for (t = 0; t < 9; ++t) i[t] = r[t];
        }
        clone() {
            var e = new m();
            return this.cloneTo(e), e;
        }
        static lookAt(e, t, r, i) {
            n.subtract(e, t, m._tempV30), n.normalize(m._tempV30, m._tempV30), n.cross(r, m._tempV30, m._tempV31), 
            n.normalize(m._tempV31, m._tempV31), n.cross(m._tempV30, m._tempV31, m._tempV32);
            var a = m._tempV30, s = m._tempV31, o = m._tempV32, l = i.elements;
            l[0] = s.x, l[3] = s.y, l[6] = s.z, l[1] = o.x, l[4] = o.y, l[7] = o.z, l[2] = a.x, 
            l[5] = a.y, l[8] = a.z;
        }
    }
    m.DEFAULT = new m(), m._tempV30 = new n(), m._tempV31 = new n(), m._tempV32 = new n();
    class f {
        constructor(e = 0, t = 0, r = 0, i = 1, a = null) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        static createFromYawPitchRoll(e, t, r, i) {
            var a = .5 * r, n = .5 * t, s = .5 * e, o = Math.sin(a), l = Math.cos(a), _ = Math.sin(n), h = Math.cos(n), c = Math.sin(s), d = Math.cos(s);
            i.x = d * _ * l + c * h * o, i.y = c * h * l - d * _ * o, i.z = d * h * o - c * _ * l, 
            i.w = d * h * l + c * _ * o;
        }
        static multiply(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = e.w, o = t.x, l = t.y, _ = t.z, h = t.w, c = a * _ - n * l, d = n * o - i * _, u = i * l - a * o, m = i * o + a * l + n * _;
            r.x = i * h + o * s + c, r.y = a * h + l * s + d, r.z = n * h + _ * s + u, r.w = s * h - m;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            n.subtract(t, e, f.TEMPVector30), n.normalize(f.TEMPVector30, f.TEMPVector30), r.x = Math.asin(f.TEMPVector30.y), 
            r.y = f.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
        }
        static createFromAxisAngle(e, t, r) {
            t *= .5;
            var i = Math.sin(t);
            r.x = i * e.x, r.y = i * e.y, r.z = i * e.z, r.w = Math.cos(t);
        }
        static createFromMatrix4x4(e, t) {
            var r, i, a = e.elements, n = a[0] + a[5] + a[10];
            n > 0 ? (r = Math.sqrt(n + 1), t.w = .5 * r, r = .5 / r, t.x = (a[6] - a[9]) * r, 
            t.y = (a[8] - a[2]) * r, t.z = (a[1] - a[4]) * r) : a[0] >= a[5] && a[0] >= a[10] ? (i = .5 / (r = Math.sqrt(1 + a[0] - a[5] - a[10])), 
            t.x = .5 * r, t.y = (a[1] + a[4]) * i, t.z = (a[2] + a[8]) * i, t.w = (a[6] - a[9]) * i) : a[5] > a[10] ? (i = .5 / (r = Math.sqrt(1 + a[5] - a[0] - a[10])), 
            t.x = (a[4] + a[1]) * i, t.y = .5 * r, t.z = (a[9] + a[6]) * i, t.w = (a[8] - a[2]) * i) : (i = .5 / (r = Math.sqrt(1 + a[10] - a[0] - a[5])), 
            t.x = (a[8] + a[2]) * i, t.y = (a[9] + a[6]) * i, t.z = .5 * r, t.w = (a[1] - a[4]) * i);
        }
        static slerp(e, t, r, i) {
            var a, n, s, o, l, _ = e.x, h = e.y, c = e.z, d = e.w, u = t.x, m = t.y, f = t.z, E = t.w;
            return (n = _ * u + h * m + c * f + d * E) < 0 && (n = -n, u = -u, m = -m, f = -f, 
            E = -E), 1 - n > 1e-6 ? (a = Math.acos(n), s = Math.sin(a), o = Math.sin((1 - r) * a) / s, 
            l = Math.sin(r * a) / s) : (o = 1 - r, l = r), i.x = o * _ + l * u, i.y = o * h + l * m, 
            i.z = o * c + l * f, i.w = o * d + l * E, i;
        }
        static lerp(e, t, r, i) {
            var a = 1 - r;
            f.dot(e, t) >= 0 ? (i.x = a * e.x + r * t.x, i.y = a * e.y + r * t.y, i.z = a * e.z + r * t.z, 
            i.w = a * e.w + r * t.w) : (i.x = a * e.x - r * t.x, i.y = a * e.y - r * t.y, i.z = a * e.z - r * t.z, 
            i.w = a * e.w - r * t.w), i.normalize(i);
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }
        scaling(e, t) {
            t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
        }
        normalize(e) {
            var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t, 
            e.w = this.w * t);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(e, t) {
            e *= .5;
            var r = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i + this.w * r, t.y = this.y * i + this.z * r, t.z = this.z * i - this.y * r, 
            t.w = this.w * i - this.x * r;
        }
        rotateY(e, t) {
            e *= .5;
            var r = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i - this.z * r, t.y = this.y * i + this.w * r, t.z = this.z * i + this.x * r, 
            t.w = this.w * i - this.y * r;
        }
        rotateZ(e, t) {
            e *= .5;
            var r = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i + this.y * r, t.y = this.y * i - this.x * r, t.z = this.z * i + this.w * r, 
            t.w = this.w * i - this.z * r;
        }
        getYawPitchRoll(e) {
            n.transformQuat(n._ForwardRH, this, f.TEMPVector31), n.transformQuat(n._Up, this, f.TEMPVector32);
            var t = f.TEMPVector32;
            f.angleTo(n._ZERO, f.TEMPVector31, f.TEMPVector33);
            var r = f.TEMPVector33;
            r.x == Math.PI / 2 ? (r.y = f.arcTanAngle(t.z, t.x), r.z = 0) : r.x == -Math.PI / 2 ? (r.y = f.arcTanAngle(-t.z, -t.x), 
            r.z = 0) : (_.Matrix4x4.createRotationY(-r.y, _.Matrix4x4.TEMPMatrix0), _.Matrix4x4.createRotationX(-r.x, _.Matrix4x4.TEMPMatrix1), 
            n.transformCoordinate(f.TEMPVector32, _.Matrix4x4.TEMPMatrix0, f.TEMPVector32), 
            n.transformCoordinate(f.TEMPVector32, _.Matrix4x4.TEMPMatrix1, f.TEMPVector32), 
            r.z = f.arcTanAngle(t.y, -t.x)), r.y <= -Math.PI && (r.y = Math.PI), r.z <= -Math.PI && (r.z = Math.PI), 
            r.y >= Math.PI && r.z >= Math.PI && (r.y = 0, r.z = 0, r.x = Math.PI - r.x);
            var i = e;
            i.x = r.y, i.y = r.x, i.z = r.z;
        }
        invert(e) {
            var t = this.x, r = this.y, i = this.z, a = this.w, n = t * t + r * r + i * i + a * a, s = n ? 1 / n : 0;
            e.x = -t * s, e.y = -r * s, e.z = -i * s, e.w = a * s;
        }
        identity() {
            this.x = 0, this.y = 0, this.z = 0, this.w = 1;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
        }
        cloneTo(e) {
            this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
        }
        clone() {
            var e = new f();
            return this.cloneTo(e), e;
        }
        equals(e) {
            return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this.z, e.z) && r.nearEqual(this.w, e.w);
        }
        static rotationLookAt(e, t, r) {
            f.lookAt(n._ZERO, e, t, r);
        }
        static lookAt(e, t, r, i) {
            m.lookAt(e, t, r, f._tempMatrix3x3), f.rotationMatrix(f._tempMatrix3x3, i);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static invert(e, t) {
            var i = e.lengthSquared();
            r.isZero(i) || (i = 1 / i, t.x = -e.x * i, t.y = -e.y * i, t.z = -e.z * i, t.w = e.w * i);
        }
        static rotationMatrix(e, t) {
            var r, i, a = e.elements, n = a[0], s = a[1], o = a[2], l = a[3], _ = a[4], h = a[5], c = a[6], d = a[7], u = a[8], m = n + _ + u;
            m > 0 ? (r = Math.sqrt(m + 1), t.w = .5 * r, r = .5 / r, t.x = (h - d) * r, t.y = (c - o) * r, 
            t.z = (s - l) * r) : n >= _ && n >= u ? (i = .5 / (r = Math.sqrt(1 + n - _ - u)), 
            t.x = .5 * r, t.y = (s + l) * i, t.z = (o + c) * i, t.w = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - n - u)), 
            t.x = (l + s) * i, t.y = .5 * r, t.z = (d + h) * i, t.w = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - n - _)), 
            t.x = (c + o) * i, t.y = (d + h) * i, t.z = .5 * r, t.w = (s - l) * i);
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
            this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
            i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2), 
            i.rewriteNumProperty(this, "w", 3);
        }
    }
    f.TEMPVector30 = new n(), f.TEMPVector31 = new n(), f.TEMPVector32 = new n(), f.TEMPVector33 = new n(), 
    f._tempMatrix3x3 = new m(), f.DEFAULT = new f(), f.NAN = new f(NaN, NaN, NaN, NaN);
    class E extends d {
        constructor() {
            super(), this.inTangent = new a(), this.outTangent = new a(), this.value = new f();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
        }
    }
    class T extends d {
        constructor() {
            super(), this.inTangent = new n(), this.outTangent = new n(), this.value = new n();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
        }
    }
    class p {
        static READ_DATA() {
            p._DATA.offset = p._reader.getUint32(), p._DATA.size = p._reader.getUint32();
        }
        static READ_BLOCK() {
            for (var e = p._BLOCK.count = p._reader.getUint16(), t = p._BLOCK.blockStarts = [], r = p._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(p._reader.getUint32()), 
            r.push(p._reader.getUint32());
        }
        static READ_STRINGS() {
            var e = p._reader.getUint32(), t = p._reader.getUint16(), r = p._reader.pos;
            p._reader.pos = e + p._DATA.offset;
            for (var i = 0; i < t; i++) p._strings[i] = p._reader.readUTFString();
            p._reader.pos = r;
        }
        static parse(e, t) {
            p._animationClip = e, p._reader = t;
            t.__getBuffer();
            p.READ_DATA(), p.READ_BLOCK(), p.READ_STRINGS();
            for (var r = 0, i = p._BLOCK.count; r < i; r++) {
                var a = t.getUint16(), n = p._strings[a], s = p["READ_" + n];
                if (null == s) throw new Error("model file err,no this function:" + a + " " + n);
                s.call(null);
            }
        }
        static READ_ANIMATIONS() {
            var e, r, i, a = p._reader, n = (a.__getBuffer(), []), s = a.getUint16();
            for (n.length = s, e = 0; e < s; e++) n[e] = a.getFloat32();
            var o = p._animationClip;
            o.name = p._strings[a.getUint16()];
            var l = o._duration = a.getFloat32();
            o.islooping = !!a.getByte(), o._frameRate = a.getInt16();
            var _ = a.getInt16(), d = o._nodes;
            d.count = _;
            var m = o._nodesMap = {}, f = o._nodesDic = {};
            for (e = 0; e < _; e++) {
                i = new h(), d.setNodeByIndex(e, i), i._indexInList = e;
                var g = i.type = a.getUint8(), S = a.getUint16();
                for (i._setOwnerPathCount(S), r = 0; r < S; r++) i._setOwnerPathByIndex(r, p._strings[a.getUint16()]);
                var R = i._joinOwnerPath("/"), v = m[R];
                v || (m[R] = v = []), v.push(i), i.propertyOwner = p._strings[a.getUint16()];
                var x = a.getUint16();
                for (i._setPropertyCount(x), r = 0; r < x; r++) i._setPropertyByIndex(r, p._strings[a.getUint16()]);
                var I = R + "." + i.propertyOwner + "." + i._joinProperty(".");
                f[I] = i, i.fullPath = I;
                var A = a.getUint16();
                for (i._setKeyframeCount(A), r = 0; r < A; r++) switch (g) {
                  case 0:
                    var L = new u();
                    i._setKeyframeByIndex(r, L), L.time = n[a.getUint16()], L.inTangent = a.getFloat32(), 
                    L.outTangent = a.getFloat32(), L.value = a.getFloat32();
                    break;

                  case 1:
                  case 3:
                  case 4:
                    var C = new T();
                    if (i._setKeyframeByIndex(r, C), C.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                        for (var D = C.data = new Float32Array(9), M = 0; M < 3; M++) D[M] = a.getFloat32();
                        for (M = 0; M < 3; M++) D[3 + M] = a.getFloat32();
                        for (M = 0; M < 3; M++) D[6 + M] = a.getFloat32();
                    } else {
                        var y = C.inTangent, O = C.outTangent, N = C.value;
                        y.x = a.getFloat32(), y.y = a.getFloat32(), y.z = a.getFloat32(), O.x = a.getFloat32(), 
                        O.y = a.getFloat32(), O.z = a.getFloat32(), N.x = a.getFloat32(), N.y = a.getFloat32(), 
                        N.z = a.getFloat32();
                    }
                    break;

                  case 2:
                    var b = new E();
                    if (i._setKeyframeByIndex(r, b), b.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                        for (D = b.data = new Float32Array(12), M = 0; M < 4; M++) D[M] = a.getFloat32();
                        for (M = 0; M < 4; M++) D[4 + M] = a.getFloat32();
                        for (M = 0; M < 4; M++) D[8 + M] = a.getFloat32();
                    } else {
                        var P = b.inTangent, w = b.outTangent, V = b.value;
                        P.x = a.getFloat32(), P.y = a.getFloat32(), P.z = a.getFloat32(), P.w = a.getFloat32(), 
                        w.x = a.getFloat32(), w.y = a.getFloat32(), w.z = a.getFloat32(), w.w = a.getFloat32(), 
                        V.x = a.getFloat32(), V.y = a.getFloat32(), V.z = a.getFloat32(), V.w = a.getFloat32();
                    }
                    break;

                  default:
                    throw "AnimationClipParser03:unknown type.";
                }
            }
            var B = a.getUint16();
            for (e = 0; e < B; e++) {
                var F, U = new c();
                U.time = Math.min(l, a.getFloat32()), U.eventName = p._strings[a.getUint16()];
                var G = a.getUint16();
                for (G > 0 && (U.params = F = []), r = 0; r < G; r++) {
                    switch (a.getByte()) {
                      case 0:
                        F.push(!!a.getByte());
                        break;

                      case 1:
                        F.push(a.getInt32());
                        break;

                      case 2:
                        F.push(a.getFloat32());
                        break;

                      case 3:
                        F.push(p._strings[a.getUint16()]);
                        break;

                      default:
                        throw new Error("unknown type.");
                    }
                }
                o.addEvent(U);
            }
        }
    }
    p._strings = [], p._BLOCK = {
        count: 0
    }, p._DATA = {
        offset: 0,
        size: 0
    };
    class g {
        static __init__() {
            for (var e = 0; e < 256; ++e) {
                var t = e - 127;
                t < -27 ? (g._baseTable[0 | e] = 0, g._baseTable[256 | e] = 32768, g._shiftTable[0 | e] = 24, 
                g._shiftTable[256 | e] = 24) : t < -14 ? (g._baseTable[0 | e] = 1024 >> -t - 14, 
                g._baseTable[256 | e] = 1024 >> -t - 14 | 32768, g._shiftTable[0 | e] = -t - 1, 
                g._shiftTable[256 | e] = -t - 1) : t <= 15 ? (g._baseTable[0 | e] = t + 15 << 10, 
                g._baseTable[256 | e] = t + 15 << 10 | 32768, g._shiftTable[0 | e] = 13, g._shiftTable[256 | e] = 13) : t < 128 ? (g._baseTable[0 | e] = 31744, 
                g._baseTable[256 | e] = 64512, g._shiftTable[0 | e] = 24, g._shiftTable[256 | e] = 24) : (g._baseTable[0 | e] = 31744, 
                g._baseTable[256 | e] = 64512, g._shiftTable[0 | e] = 13, g._shiftTable[256 | e] = 13);
            }
            for (g._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                var r = e << 13;
                for (t = 0; 0 == (8388608 & r); ) t -= 8388608, r <<= 1;
                r &= -8388609, t += 947912704, g._mantissaTable[e] = r | t;
            }
            for (e = 1024; e < 2048; ++e) g._mantissaTable[e] = 939524096 + (e - 1024 << 13);
            for (g._exponentTable[0] = 0, e = 1; e < 31; ++e) g._exponentTable[e] = e << 23;
            for (g._exponentTable[31] = 1199570944, g._exponentTable[32] = 2147483648, e = 33; e < 63; ++e) g._exponentTable[e] = 2147483648 + (e - 32 << 23);
            for (g._exponentTable[63] = 3347054592, g._offsetTable[0] = 0, e = 1; e < 64; ++e) g._offsetTable[e] = 32 === e ? 0 : 1024;
        }
        static roundToFloat16Bits(e) {
            g._floatView[0] = e;
            var t = g._uint32View[0], r = t >> 23 & 511;
            return g._baseTable[r] + ((8388607 & t) >> g._shiftTable[r]);
        }
        static convertToNumber(e) {
            var t = e >> 10;
            return g._uint32View[0] = g._mantissaTable[g._offsetTable[t] + (1023 & e)] + g._exponentTable[t], 
            g._floatView[0];
        }
    }
    g._buffer = new ArrayBuffer(4), g._floatView = new Float32Array(g._buffer), g._uint32View = new Uint32Array(g._buffer), 
    g._baseTable = new Uint32Array(512), g._shiftTable = new Uint32Array(512), g._mantissaTable = new Uint32Array(2048), 
    g._exponentTable = new Uint32Array(64), g._offsetTable = new Uint32Array(64);
    class S {
        static READ_DATA() {
            S._DATA.offset = S._reader.getUint32(), S._DATA.size = S._reader.getUint32();
        }
        static READ_BLOCK() {
            for (var e = S._BLOCK.count = S._reader.getUint16(), t = S._BLOCK.blockStarts = [], r = S._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(S._reader.getUint32()), 
            r.push(S._reader.getUint32());
        }
        static READ_STRINGS() {
            var e = S._reader.getUint32(), t = S._reader.getUint16(), r = S._reader.pos;
            S._reader.pos = e + S._DATA.offset;
            for (var i = 0; i < t; i++) S._strings[i] = S._reader.readUTFString();
            S._reader.pos = r;
        }
        static parse(e, t, r) {
            S._animationClip = e, S._reader = t, S._version = r, S.READ_DATA(), S.READ_BLOCK(), 
            S.READ_STRINGS();
            for (var i = 0, a = S._BLOCK.count; i < a; i++) {
                var n = t.getUint16(), s = S._strings[n], o = S["READ_" + s];
                if (null == o) throw new Error("model file err,no this function:" + n + " " + s);
                o.call(null);
            }
            S._version = null, S._reader = null, S._animationClip = null;
        }
        static READ_ANIMATIONS() {
            var e, r, i, a = S._reader, n = (a.__getBuffer(), []), s = a.getUint16();
            for (n.length = s, e = 0; e < s; e++) n[e] = a.getFloat32();
            var o = S._animationClip;
            o.name = S._strings[a.getUint16()];
            var l = o._duration = a.getFloat32();
            o.islooping = !!a.getByte(), o._frameRate = a.getInt16();
            var _ = a.getInt16(), d = o._nodes;
            d.count = _;
            var m = o._nodesMap = {}, f = o._nodesDic = {};
            for (e = 0; e < _; e++) {
                i = new h(), d.setNodeByIndex(e, i), i._indexInList = e;
                var p = i.type = a.getUint8(), R = a.getUint16();
                for (i._setOwnerPathCount(R), r = 0; r < R; r++) i._setOwnerPathByIndex(r, S._strings[a.getUint16()]);
                var v = i._joinOwnerPath("/"), x = m[v];
                x || (m[v] = x = []), x.push(i), i.propertyOwner = S._strings[a.getUint16()];
                var I = a.getUint16();
                for (i._setPropertyCount(I), r = 0; r < I; r++) i._setPropertyByIndex(r, S._strings[a.getUint16()]);
                var A = v + "." + i.propertyOwner + "." + i._joinProperty(".");
                f[A] = i, i.fullPath = A;
                var L = a.getUint16();
                switch (i._setKeyframeCount(L), S._version) {
                  case "LAYAANIMATION:04":
                    for (r = 0; r < L; r++) switch (p) {
                      case 0:
                        var C = new u();
                        i._setKeyframeByIndex(r, C), C.time = n[a.getUint16()], C.inTangent = a.getFloat32(), 
                        C.outTangent = a.getFloat32(), C.value = a.getFloat32();
                        break;

                      case 1:
                      case 3:
                      case 4:
                        var D = new T();
                        if (i._setKeyframeByIndex(r, D), D.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (var M = D.data = new Float32Array(9), y = 0; y < 3; y++) M[y] = a.getFloat32();
                            for (y = 0; y < 3; y++) M[3 + y] = a.getFloat32();
                            for (y = 0; y < 3; y++) M[6 + y] = a.getFloat32();
                        } else {
                            var O = D.inTangent, N = D.outTangent, b = D.value;
                            O.x = a.getFloat32(), O.y = a.getFloat32(), O.z = a.getFloat32(), N.x = a.getFloat32(), 
                            N.y = a.getFloat32(), N.z = a.getFloat32(), b.x = a.getFloat32(), b.y = a.getFloat32(), 
                            b.z = a.getFloat32();
                        }
                        break;

                      case 2:
                        var P = new E();
                        if (i._setKeyframeByIndex(r, P), P.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (M = P.data = new Float32Array(12), y = 0; y < 4; y++) M[y] = a.getFloat32();
                            for (y = 0; y < 4; y++) M[4 + y] = a.getFloat32();
                            for (y = 0; y < 4; y++) M[8 + y] = a.getFloat32();
                        } else {
                            var w = P.inTangent, V = P.outTangent, B = P.value;
                            w.x = a.getFloat32(), w.y = a.getFloat32(), w.z = a.getFloat32(), w.w = a.getFloat32(), 
                            V.x = a.getFloat32(), V.y = a.getFloat32(), V.z = a.getFloat32(), V.w = a.getFloat32(), 
                            B.x = a.getFloat32(), B.y = a.getFloat32(), B.z = a.getFloat32(), B.w = a.getFloat32();
                        }
                        break;

                      default:
                        throw "AnimationClipParser04:unknown type.";
                    }
                    break;

                  case "LAYAANIMATION:COMPRESSION_04":
                    for (r = 0; r < L; r++) switch (p) {
                      case 0:
                        C = new u(), i._setKeyframeByIndex(r, C), C.time = n[a.getUint16()], C.inTangent = g.convertToNumber(a.getUint16()), 
                        C.outTangent = g.convertToNumber(a.getUint16()), C.value = g.convertToNumber(a.getUint16());
                        break;

                      case 1:
                      case 3:
                      case 4:
                        if (D = new T(), i._setKeyframeByIndex(r, D), D.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (M = D.data = new Float32Array(9), y = 0; y < 3; y++) M[y] = g.convertToNumber(a.getUint16());
                            for (y = 0; y < 3; y++) M[3 + y] = g.convertToNumber(a.getUint16());
                            for (y = 0; y < 3; y++) M[6 + y] = g.convertToNumber(a.getUint16());
                        } else O = D.inTangent, N = D.outTangent, b = D.value, O.x = g.convertToNumber(a.getUint16()), 
                        O.y = g.convertToNumber(a.getUint16()), O.z = g.convertToNumber(a.getUint16()), 
                        N.x = g.convertToNumber(a.getUint16()), N.y = g.convertToNumber(a.getUint16()), 
                        N.z = g.convertToNumber(a.getUint16()), b.x = g.convertToNumber(a.getUint16()), 
                        b.y = g.convertToNumber(a.getUint16()), b.z = g.convertToNumber(a.getUint16());
                        break;

                      case 2:
                        if (P = new E(), i._setKeyframeByIndex(r, P), P.time = n[a.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (M = P.data = new Float32Array(12), y = 0; y < 4; y++) M[y] = g.convertToNumber(a.getUint16());
                            for (y = 0; y < 4; y++) M[4 + y] = g.convertToNumber(a.getUint16());
                            for (y = 0; y < 4; y++) M[8 + y] = g.convertToNumber(a.getUint16());
                        } else w = P.inTangent, V = P.outTangent, B = P.value, w.x = g.convertToNumber(a.getUint16()), 
                        w.y = g.convertToNumber(a.getUint16()), w.z = g.convertToNumber(a.getUint16()), 
                        w.w = g.convertToNumber(a.getUint16()), V.x = g.convertToNumber(a.getUint16()), 
                        V.y = g.convertToNumber(a.getUint16()), V.z = g.convertToNumber(a.getUint16()), 
                        V.w = g.convertToNumber(a.getUint16()), B.x = g.convertToNumber(a.getUint16()), 
                        B.y = g.convertToNumber(a.getUint16()), B.z = g.convertToNumber(a.getUint16()), 
                        B.w = g.convertToNumber(a.getUint16());
                        break;

                      default:
                        throw "AnimationClipParser04:unknown type.";
                    }
                }
            }
            var F = a.getUint16();
            for (e = 0; e < F; e++) {
                var U, G = new c();
                G.time = Math.min(l, a.getFloat32()), G.eventName = S._strings[a.getUint16()];
                var z = a.getUint16();
                for (z > 0 && (G.params = U = []), r = 0; r < z; r++) {
                    switch (a.getByte()) {
                      case 0:
                        U.push(!!a.getByte());
                        break;

                      case 1:
                        U.push(a.getInt32());
                        break;

                      case 2:
                        U.push(a.getFloat32());
                        break;

                      case 3:
                        U.push(S._strings[a.getUint16()]);
                        break;

                      default:
                        throw new Error("unknown type.");
                    }
                }
                o.addEvent(G);
            }
        }
    }
    S._strings = [], S._BLOCK = {
        count: 0
    }, S._DATA = {
        offset: 0,
        size: 0
    };
    class R {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(e) {
            this._nodes.length = e;
        }
        getNodeByIndex(e) {
            return this._nodes[e];
        }
        setNodeByIndex(e, t) {
            this._nodes[e] = t;
        }
    }
    class v {}
    v._bullet = null, v._enablePhysics = !1;
    class x {
        constructor() {}
        static lightAttenTexture(e, t, r, i, a, n) {
            var s = e / r, o = 1 / (1 + 25 * s);
            s >= .64 && (s > 1 ? o = 0 : o *= 1 - (s - .64) / .36), n[a] = Math.floor(255 * o + .5);
        }
        static haloTexture(e, t, r, i, a, n) {
            var s = (e - (r >>= 1)) / r, o = (t - (i >>= 1)) / i, l = s * s + o * o;
            l > 1 && (l = 1), n[a] = Math.floor(255 * (1 - l) + .5);
        }
        static _generateTexture2D(e, r, i, a) {
            var n = 0, s = 0;
            switch (e.format) {
              case t.TextureFormat.R8G8B8:
                s = 3;
                break;

              case t.TextureFormat.R8G8B8A8:
                s = 4;
                break;

              case t.TextureFormat.Alpha8:
                s = 1;
                break;

              default:
                throw "GeneratedTexture._generateTexture: unkonw texture format.";
            }
            for (var o = new Uint8Array(r * i * s), l = 0; l < i; l++) for (var _ = 0; _ < r; _++) a(_, l, r, i, n, o), 
            n += s;
            e.setPixels(o);
        }
    }
    class I {
        static _createFloatTextureBuffer(e, r) {
            var i = new t.Texture2D(e, r, t.TextureFormat.R32G32B32A32, !1, !1);
            return i.filterMode = t.FilterMode.Point, i.wrapModeU = t.WarpMode.Clamp, i.wrapModeV = t.WarpMode.Clamp, 
            i.anisoLevel = 0, i;
        }
        static _convertToLayaVec3(e, t, r) {
            var i = v._bullet;
            t.x = r ? -i.btVector3_x(e) : i.btVector3_x(e), t.y = i.btVector3_y(e), t.z = i.btVector3_z(e);
        }
        static _convertToBulletVec3(e, t, r) {
            v._bullet.btVector3_setValue(t, r ? -e.x : e.x, e.y, e.z);
        }
        static _rotationTransformScaleSkinAnimation(e, t, r, i, a, n, s, o, l, _, h, c) {
            var d, u, m, f, E, T = I._tempArray16_0, p = I._tempArray16_1, g = I._tempArray16_2, S = i + i, R = a + a, v = n + n, x = i * S, A = a * S, L = a * R, C = n * S, D = n * R, M = n * v, y = s * S, O = s * R, N = s * v;
            for (T[15] = 1, T[0] = 1 - L - M, T[1] = A + N, T[2] = C - O, T[4] = A - N, T[5] = 1 - x - M, 
            T[6] = D + y, T[8] = C + O, T[9] = D - y, T[10] = 1 - x - L, p[15] = 1, p[0] = o, 
            p[5] = l, p[10] = _, d = 0; d < 4; d++) u = T[d], m = T[d + 4], f = T[d + 8], E = T[d + 12], 
            g[d] = u, g[d + 4] = m, g[d + 8] = f, g[d + 12] = u * e + m * t + f * r + E;
            for (d = 0; d < 4; d++) u = g[d], m = g[d + 4], f = g[d + 8], E = g[d + 12], h[d + c] = u * p[0] + m * p[1] + f * p[2] + E * p[3], 
            h[d + c + 4] = u * p[4] + m * p[5] + f * p[6] + E * p[7], h[d + c + 8] = u * p[8] + m * p[9] + f * p[10] + E * p[11], 
            h[d + c + 12] = u * p[12] + m * p[13] + f * p[14] + E * p[15];
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxix(e, t, r, i, a, n) {
            var s, o, l = 0, _ = 0, h = e.length;
            for (s = 0; s < h; l += e[s].keyframeWidth, _ += 16, s++) I._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], i, _), 
            0 != s && (o = 16 * e[s].parentIndex, I.mulMatrixByArray(i, o, i, _, i, _));
            var c = r.length;
            for (s = 0; s < c; s++) I.mulMatrixByArrayAndMatrixFast(i, 16 * n[s], r[s], a, 16 * s);
        }
        static _computeAnimationDatasByArrayAndMatrixFast(e, t, r, i) {
            for (var a = 0, n = e.length; a < n; a++) I.mulMatrixByArrayAndMatrixFast(t, 16 * i[a], e[a], r, 16 * a);
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(e, t, r, i, a) {
            var n, s, o = 0, l = 0, _ = e.length;
            for (n = 0; n < _; o += e[n].keyframeWidth, l += 16, n++) I._rotationTransformScaleSkinAnimation(t[o + 7], t[o + 8], t[o + 9], t[o + 3], t[o + 4], t[o + 5], t[o + 6], t[o + 0], t[o + 1], t[o + 2], i, l), 
            0 != n && (s = 16 * e[n].parentIndex, I.mulMatrixByArray(i, s, i, l, i, l));
            var h = r.length;
            for (n = 0; n < h; n++) {
                var c = 16 * n;
                I.mulMatrixByArrayAndMatrixFast(i, c, r[n], a, c);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFastOld(e, t, r) {
            for (var i = e.length, a = 0; a < i; a++) {
                var n = 16 * a;
                I.mulMatrixByArrayAndMatrixFast(t, n, e[a], r, n);
            }
        }
        static _computeRootAnimationData(e, t, r) {
            for (var i = 0, a = 0, n = 0, s = e.length; i < s; a += e[i].keyframeWidth, n += 16, 
            i++) I.createAffineTransformationArray(t[a + 0], t[a + 1], t[a + 2], t[a + 3], t[a + 4], t[a + 5], t[a + 6], t[a + 7], t[a + 8], t[a + 9], r, n);
        }
        static transformVector3ArrayByQuat(e, t, r, i, a) {
            var n = e[t], s = e[t + 1], o = e[t + 2], l = r.x, _ = r.y, h = r.z, c = r.w, d = c * n + _ * o - h * s, u = c * s + h * n - l * o, m = c * o + l * s - _ * n, f = -l * n - _ * s - h * o;
            i[a] = d * c + f * -l + u * -h - m * -_, i[a + 1] = u * c + f * -_ + m * -l - d * -h, 
            i[a + 2] = m * c + f * -h + d * -_ - u * -l;
        }
        static mulMatrixByArray(e, t, r, i, a, n) {
            var s, o, l, _, h;
            if (a === r) {
                for (r = I._tempArray16_3, s = 0; s < 16; ++s) r[s] = a[n + s];
                i = 0;
            }
            for (s = 0; s < 4; s++) o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12], 
            a[n + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3], a[n + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7], 
            a[n + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11], a[n + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
        }
        static mulMatrixByArrayFast(e, t, r, i, a, n) {
            var s, o, l, _, h;
            for (s = 0; s < 4; s++) o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12], 
            a[n + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3], a[n + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7], 
            a[n + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11], a[n + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
        }
        static mulMatrixByArrayAndMatrixFast(e, t, r, i, a) {
            var n, s, o, l, _, h = r.elements, c = h[0], d = h[1], u = h[2], m = h[3], f = h[4], E = h[5], T = h[6], p = h[7], g = h[8], S = h[9], R = h[10], v = h[11], x = h[12], I = h[13], A = h[14], L = h[15], C = t, D = t + 4, M = t + 8, y = t + 12, O = a, N = a + 4, b = a + 8, P = a + 12;
            for (n = 0; n < 4; n++) s = e[C + n], o = e[D + n], l = e[M + n], _ = e[y + n], 
            i[O + n] = s * c + o * d + l * u + _ * m, i[N + n] = s * f + o * E + l * T + _ * p, 
            i[b + n] = s * g + o * S + l * R + _ * v, i[P + n] = s * x + o * I + l * A + _ * L;
        }
        static createAffineTransformationArray(e, t, r, i, a, n, s, o, l, _, h, c) {
            var d = i + i, u = a + a, m = n + n, f = i * d, E = i * u, T = i * m, p = a * u, g = a * m, S = n * m, R = s * d, v = s * u, x = s * m;
            h[c + 0] = (1 - (p + S)) * o, h[c + 1] = (E + x) * o, h[c + 2] = (T - v) * o, h[c + 3] = 0, 
            h[c + 4] = (E - x) * l, h[c + 5] = (1 - (f + S)) * l, h[c + 6] = (g + R) * l, h[c + 7] = 0, 
            h[c + 8] = (T + v) * _, h[c + 9] = (g - R) * _, h[c + 10] = (1 - (f + p)) * _, h[c + 11] = 0, 
            h[c + 12] = e, h[c + 13] = t, h[c + 14] = r, h[c + 15] = 1;
        }
        static transformVector3ArrayToVector3ArrayCoordinate(e, t, r, i, a) {
            var n = e[t + 0], s = e[t + 1], o = e[t + 2], l = r.elements, _ = n * l[3] + s * l[7] + o * l[11] + l[15];
            i[a] = n * l[0] + s * l[4] + o * l[8] + l[12] / _, i[a + 1] = n * l[1] + s * l[5] + o * l[9] + l[13] / _, 
            i[a + 2] = n * l[2] + s * l[6] + o * l[10] + l[14] / _;
        }
        static transformVector3ArrayToVector3ArrayNormal(e, t, r, i, a) {
            var n = e[t + 0], s = e[t + 1], o = e[t + 2], l = r.elements;
            i[a] = n * l[0] + s * l[4] + o * l[8], i[a + 1] = n * l[1] + s * l[5] + o * l[9], 
            i[a + 2] = n * l[2] + s * l[6] + o * l[10];
        }
        static transformLightingMapTexcoordArray(e, t, r, i, a) {
            i[a + 0] = e[t + 0] * r.x + r.z, i[a + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w);
        }
        static getURLVerion(e) {
            var t = e.indexOf("?");
            return t >= 0 ? e.substr(t) : null;
        }
        static _createAffineTransformationArray(e, t, r, i) {
            var a = t.x, n = t.y, s = t.z, o = t.w, l = a + a, _ = n + n, h = s + s, c = a * l, d = a * _, u = a * h, m = n * _, f = n * h, E = s * h, T = o * l, p = o * _, g = o * h, S = r.x, R = r.y, v = r.z;
            i[0] = (1 - (m + E)) * S, i[1] = (d + g) * S, i[2] = (u - p) * S, i[3] = 0, i[4] = (d - g) * R, 
            i[5] = (1 - (c + E)) * R, i[6] = (f + T) * R, i[7] = 0, i[8] = (u + p) * v, i[9] = (f - T) * v, 
            i[10] = (1 - (c + m)) * v, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
        }
        static _mulMatrixArray(e, t, r, i, a) {
            var n = t, s = e, o = i, l = n[r], _ = n[r + 1], h = n[r + 2], c = n[r + 3], d = n[r + 4], u = n[r + 5], m = n[r + 6], f = n[r + 7], E = n[r + 8], T = n[r + 9], p = n[r + 10], g = n[r + 11], S = n[r + 12], R = n[r + 13], v = n[r + 14], x = n[r + 15], I = s[0], A = s[1], L = s[2], C = s[3], D = s[4], M = s[5], y = s[6], O = s[7], N = s[8], b = s[9], P = s[10], w = s[11], V = s[12], B = s[13], F = s[14], U = s[15];
            o[a] = l * I + _ * D + h * N + c * V, o[a + 1] = l * A + _ * M + h * b + c * B, 
            o[a + 2] = l * L + _ * y + h * P + c * F, o[a + 3] = l * C + _ * O + h * w + c * U, 
            o[a + 4] = d * I + u * D + m * N + f * V, o[a + 5] = d * A + u * M + m * b + f * B, 
            o[a + 6] = d * L + u * y + m * P + f * F, o[a + 7] = d * C + u * O + m * w + f * U, 
            o[a + 8] = E * I + T * D + p * N + g * V, o[a + 9] = E * A + T * M + p * b + g * B, 
            o[a + 10] = E * L + T * y + p * P + g * F, o[a + 11] = E * C + T * O + p * w + g * U, 
            o[a + 12] = S * I + R * D + v * N + x * V, o[a + 13] = S * A + R * M + v * b + x * B, 
            o[a + 14] = S * L + R * y + v * P + x * F, o[a + 15] = S * C + R * O + v * w + x * U;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            n.subtract(t, e, f.TEMPVector30), n.normalize(f.TEMPVector30, f.TEMPVector30), r.x = Math.asin(f.TEMPVector30.y), 
            r.y = I.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
        }
        static transformQuat(e, t, r) {
            var i = t, a = e.x, n = e.y, s = e.z, o = i[0], l = i[1], _ = i[2], h = i[3], c = h * a + l * s - _ * n, d = h * n + _ * a - o * s, u = h * s + o * n - l * a, m = -o * a - l * n - _ * s;
            r.x = c * h + m * -o + d * -_ - u * -l, r.y = d * h + m * -l + u * -o - c * -_, 
            r.z = u * h + m * -_ + c * -l - d * -o;
        }
        static quaternionWeight(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w;
        }
        static quaternionConjugate(e, t) {
            t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
        }
        static scaleWeight(e, t, r) {
            var i = e.x, a = e.y, n = e.z;
            r.x = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), r.y = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t), 
            r.z = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t);
        }
        static scaleBlend(e, t, r, i) {
            var a = I._tempVector3_0, n = I._tempVector3_1;
            I.scaleWeight(e, 1 - r, a), I.scaleWeight(t, r, n);
            var s = r > .5 ? t : e;
            i.x = s.x > 0 ? Math.abs(a.x * n.x) : -Math.abs(a.x * n.x), i.y = s.y > 0 ? Math.abs(a.y * n.y) : -Math.abs(a.y * n.y), 
            i.z = s.z > 0 ? Math.abs(a.z * n.z) : -Math.abs(a.z * n.z);
        }
        static matrix4x4MultiplyFFF(e, t, r) {
            var i, a, n, s, o;
            if (r === t) for (t = new Float32Array(16), i = 0; i < 16; ++i) t[i] = r[i];
            var l = t[0], _ = t[1], h = t[2], c = t[3], d = t[4], u = t[5], m = t[6], f = t[7], E = t[8], T = t[9], p = t[10], g = t[11], S = t[12], R = t[13], v = t[14], x = t[15];
            for (i = 0; i < 4; i++) a = e[i], n = e[i + 4], s = e[i + 8], o = e[i + 12], r[i] = a * l + n * _ + s * h + o * c, 
            r[i + 4] = a * d + n * u + s * m + o * f, r[i + 8] = a * E + n * T + s * p + o * g, 
            r[i + 12] = a * S + n * R + s * v + o * x;
        }
        static matrix4x4MultiplyFFFForNative(e, r, i) {
            t.LayaGL.instance.matrix4x4Multiply(e, r, i);
        }
        static matrix4x4MultiplyMFM(e, t, r) {
            I.matrix4x4MultiplyFFF(e.elements, t, r.elements);
        }
        static _buildTexture2D(e, r, i, a, n = !1) {
            var s = new t.Texture2D(e, r, i, n, !0);
            return s.anisoLevel = 1, s.filterMode = t.FilterMode.Point, x._generateTexture2D(s, e, r, a), 
            s;
        }
        static _drawBound(e, t, r) {
            e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
            var i = I._tempVector3_0, a = I._tempVector3_1, n = t.min, s = t.max;
            i.setValue(n.x, n.y, n.z), a.setValue(s.x, n.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, n.y, n.z), 
            a.setValue(n.x, n.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, n.y, n.z), a.setValue(s.x, n.y, s.z), 
            e.addLine(i, a, r, r), i.setValue(n.x, n.y, s.z), a.setValue(s.x, n.y, s.z), e.addLine(i, a, r, r), 
            i.setValue(n.x, n.y, n.z), a.setValue(n.x, s.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, n.y, s.z), 
            a.setValue(n.x, s.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, n.y, n.z), a.setValue(s.x, s.y, n.z), 
            e.addLine(i, a, r, r), i.setValue(s.x, n.y, s.z), a.setValue(s.x, s.y, s.z), e.addLine(i, a, r, r), 
            i.setValue(n.x, s.y, n.z), a.setValue(s.x, s.y, n.z), e.addLine(i, a, r, r), i.setValue(n.x, s.y, n.z), 
            a.setValue(n.x, s.y, s.z), e.addLine(i, a, r, r), i.setValue(s.x, s.y, n.z), a.setValue(s.x, s.y, s.z), 
            e.addLine(i, a, r, r), i.setValue(n.x, s.y, s.z), a.setValue(s.x, s.y, s.z), e.addLine(i, a, r, r);
        }
        static _getHierarchyPath(e, t, r) {
            r.length = 0;
            for (var i = t; i !== e; ) {
                var a = i._parent;
                if (!a) return null;
                r.push(a.getChildIndex(i)), i = a;
            }
            return r;
        }
        static _getNodeByHierarchyPath(e, t) {
            for (var r = e, i = t.length - 1; i >= 0; i--) r = r.getChildAt(t[i]);
            return r;
        }
    }
    I._tempVector3_0 = new n(), I._tempVector3_1 = new n(), I._tempArray16_0 = new Float32Array(16), 
    I._tempArray16_1 = new Float32Array(16), I._tempArray16_2 = new Float32Array(16), 
    I._tempArray16_3 = new Float32Array(16), I._compIdToNode = new Object();
    class A extends t.Resource {
        constructor() {
            super(), this._nodes = new R(), this._animationEvents = [];
        }
        static _parse(e, r = null, i = null) {
            var a = new A(), n = new t.Byte(e), s = n.readUTFString();
            switch (s) {
              case "LAYAANIMATION:03":
                p.parse(a, n);
                break;

              case "LAYAANIMATION:04":
              case "LAYAANIMATION:COMPRESSION_04":
                S.parse(a, n, s);
                break;

              default:
                throw "unknown animationClip version.";
            }
            return a;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, A.ANIMATIONCLIP);
        }
        duration() {
            return this._duration;
        }
        _hermiteInterpolate(e, t, r, i) {
            var a = e.outTangent, n = t.inTangent;
            if (Number.isFinite(a) && Number.isFinite(n)) {
                var s = r * r, o = s * r, l = o - 2 * s + r, _ = o - s, h = -2 * o + 3 * s;
                return (2 * o - 3 * s + 1) * e.value + l * a * i + _ * n * i + h * t.value;
            }
            return e.value;
        }
        _hermiteInterpolateVector3(e, t, r, i, a) {
            var n = e.value, s = e.outTangent, o = t.value, l = t.inTangent, _ = r * r, h = _ * r, c = 2 * h - 3 * _ + 1, d = h - 2 * _ + r, u = h - _, m = -2 * h + 3 * _, f = s.x, E = l.x;
            Number.isFinite(f) && Number.isFinite(E) ? a.x = c * n.x + d * f * i + u * E * i + m * o.x : a.x = n.x, 
            f = s.y, E = l.y, Number.isFinite(f) && Number.isFinite(E) ? a.y = c * n.y + d * f * i + u * E * i + m * o.y : a.y = n.y, 
            f = s.z, E = l.z, Number.isFinite(f) && Number.isFinite(E) ? a.z = c * n.z + d * f * i + u * E * i + m * o.z : a.z = n.z;
        }
        _hermiteInterpolateQuaternion(e, t, r, i, a) {
            var n = e.value, s = e.outTangent, o = t.value, l = t.inTangent, _ = r * r, h = _ * r, c = 2 * h - 3 * _ + 1, d = h - 2 * _ + r, u = h - _, m = -2 * h + 3 * _, f = s.x, E = l.x;
            Number.isFinite(f) && Number.isFinite(E) ? a.x = c * n.x + d * f * i + u * E * i + m * o.x : a.x = n.x, 
            f = s.y, E = l.y, Number.isFinite(f) && Number.isFinite(E) ? a.y = c * n.y + d * f * i + u * E * i + m * o.y : a.y = n.y, 
            f = s.z, E = l.z, Number.isFinite(f) && Number.isFinite(E) ? a.z = c * n.z + d * f * i + u * E * i + m * o.z : a.z = n.z, 
            f = s.w, E = l.w, Number.isFinite(f) && Number.isFinite(E) ? a.w = c * n.w + d * f * i + u * E * i + m * o.w : a.w = n.w;
        }
        _evaluateClipDatasRealTime(e, t, r, i, a, n) {
            for (var s = 0, o = e.count; s < o; s++) {
                var l, _ = e.getNodeByIndex(s), h = _.type, c = _._keyFrames, d = c.length, u = r[s];
                if (a) for (-1 !== u && t < c[u].time && (u = -1, r[s] = u), l = u + 1; l < d && !(c[l].time > t); ) u++, 
                l++, r[s] = u; else for ((l = u + 1) !== d && t > c[l].time && (u = d - 1, r[s] = u), 
                l = u + 1; u > -1 && !(c[u].time < t); ) u--, l--, r[s] = u;
                var m = l === d;
                switch (h) {
                  case 0:
                    if (-1 !== u) {
                        var E = c[u];
                        if (m) n[s] = E.value; else {
                            var T, p = c[l], g = p.time - E.time;
                            T = 0 !== g ? (t - E.time) / g : 0, n[s] = this._hermiteInterpolate(E, p, T, g);
                        }
                    } else n[s] = c[0].value;
                    i && (n[s] = n[s] - c[0].value);
                    break;

                  case 1:
                  case 4:
                    var S = n[s];
                    if (this._evaluateFrameNodeVector3DatasRealTime(c, u, m, t, S), i) {
                        var R = c[0].value;
                        S.x -= R.x, S.y -= R.y, S.z -= R.z;
                    }
                    break;

                  case 2:
                    var v = n[s];
                    if (this._evaluateFrameNodeQuaternionDatasRealTime(c, u, m, t, v), i) {
                        var x = A._tempQuaternion0, L = c[0].value;
                        I.quaternionConjugate(L, x), f.multiply(x, v, v);
                    }
                    break;

                  case 3:
                    S = n[s], this._evaluateFrameNodeVector3DatasRealTime(c, u, m, t, S), i && (R = c[0].value, 
                    S.x /= R.x, S.y /= R.y, S.z /= R.z);
                    break;

                  default:
                    throw "AnimationClip:unknown node type.";
                }
            }
        }
        _evaluateClipDatasRealTimeForNative(e, r, i, a) {
            t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, i, a);
        }
        _evaluateFrameNodeVector3DatasRealTime(e, t, r, i, a) {
            if (-1 !== t) {
                var n = e[t];
                if (r) {
                    var s = n.value;
                    a.x = s.x, a.y = s.y, a.z = s.z;
                } else {
                    var o, l = e[t + 1], _ = n.time, h = l.time - _;
                    o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateVector3(n, l, o, h, a);
                }
            } else {
                var c = e[0].value;
                a.x = c.x, a.y = c.y, a.z = c.z;
            }
        }
        _evaluateFrameNodeQuaternionDatasRealTime(e, t, r, i, a) {
            if (-1 !== t) {
                var n = e[t];
                if (r) {
                    var s = n.value;
                    a.x = s.x, a.y = s.y, a.z = s.z, a.w = s.w;
                } else {
                    var o, l = e[t + 1], _ = n.time, h = l.time - _;
                    o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateQuaternion(n, l, o, h, a);
                }
            } else {
                var c = e[0].value;
                a.x = c.x, a.y = c.y, a.z = c.z, a.w = c.w;
            }
        }
        _binarySearchEventIndex(e) {
            for (var t, r = 0, i = this._animationEvents.length - 1; r <= i; ) {
                t = Math.floor((r + i) / 2);
                var a = this._animationEvents[t].time;
                if (a == e) return t;
                a > e ? i = t - 1 : r = t + 1;
            }
            return r;
        }
        addEvent(e) {
            var t = this._binarySearchEventIndex(e.time);
            this._animationEvents.splice(t, 0, e);
        }
        _disposeResource() {
            this._nodes = null, this._nodesMap = null;
        }
    }
    A.ANIMATIONCLIP = "ANIMATIONCLIP", A._tempQuaternion0 = new f();
    class L {
        constructor() {
            this._currentState = null;
        }
        get normalizedTime() {
            return this._normalizedTime;
        }
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        _resetPlayState(e) {
            this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0, 
            this._lastIsFront = !0;
        }
        _cloneTo(e) {
            e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime, 
            e._normalizedTime = this._normalizedTime, e._normalizedPlayTime = this._normalizedPlayTime, 
            e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
        }
    }
    class C {
        constructor(e) {
            this._defaultState = null, this._referenceCount = 0, this._playType = -1, this._crossDuration = -1, 
            this._crossMark = 0, this._crossNodesOwnersCount = 0, this._crossNodesOwners = [], 
            this._crossNodesOwnersIndicesMap = {}, this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], 
            this._statesMap = {}, this._states = [], this._playStateInfo = new L(), this._crossPlayStateInfo = new L(), 
            this.blendingMode = C.BLENDINGMODE_OVERRIDE, this.defaultWeight = 1, this.playOnWake = !0, 
            this.name = e;
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(e) {
            this._defaultState = e, this._statesMap[e.name] = e;
        }
        _removeClip(e, t, r, i) {
            var a = i._clip, n = e[r];
            if (e.splice(r, 1), delete t[i.name], this._animator) {
                var s = a._nodes, o = n._nodeOwners;
                a._removeReference();
                for (var l = 0, _ = s.count; l < _; l++) this._animator._removeKeyframeNodeOwner(o, s.getNodeByIndex(l));
            }
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(e = 1) {
            for (var t = 0, r = this._states.length; t < r; t++) this._states[t]._addReference(e);
            this._referenceCount += e;
        }
        _removeReference(e = 1) {
            for (var t = 0, r = this._states.length; t < r; t++) this._states[t]._removeReference(e);
            this._referenceCount -= e;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getAnimatorState(e) {
            var t = this._statesMap[e];
            return t || null;
        }
        addState(e) {
            var t = e.name;
            if (this._statesMap[t]) throw "AnimatorControllerLayer:this stat's name has exist.";
            this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip._addReference(), 
            this._animator._getOwnersByClip(e));
        }
        removeState(e) {
            for (var t = this._states, r = -1, i = 0, a = t.length; i < a; i++) if (t[i] === e) {
                r = i;
                break;
            }
            -1 !== r && this._removeClip(t, this._statesMap, r, e);
        }
        destroy() {
            this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null, 
            this._crossPlayStateInfo = null, this._defaultState = null;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight, 
            t.playOnWake = this.playOnWake;
        }
        clone() {
            var e = new C(this.name);
            return this.cloneTo(e), e;
        }
    }
    C.BLENDINGMODE_OVERRIDE = 0, C.BLENDINGMODE_ADDTIVE = 1;
    class D {
        constructor(e = 0, t = 0, r = 0, i = 0) {
            var a = this.elements = new Float32Array(4);
            a[0] = e, a[1] = t, a[2] = r, a[3] = i;
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        get w() {
            return this.elements[3];
        }
        set w(e) {
            this.elements[3] = e;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2], 
            this.elements[3] = e[t + 3];
        }
        cloneTo(e) {
            var t = e.elements, r = this.elements;
            t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3];
        }
        clone() {
            var e = new D();
            return this.cloneTo(e), e;
        }
        static lerp(e, t, r, i) {
            var a = i.elements, n = e.elements, s = t.elements, o = n[0], l = n[1], _ = n[2], h = n[3];
            a[0] = o + r * (s[0] - o), a[1] = l + r * (s[1] - l), a[2] = _ + r * (s[2] - _), 
            a[3] = h + r * (s[3] - h);
        }
        static transformByM4x4(e, t, r) {
            var i = e.elements, a = i[0], n = i[1], s = i[2], o = i[3], l = t.elements, _ = r.elements;
            _[0] = a * l[0] + n * l[4] + s * l[8] + o * l[12], _[1] = a * l[1] + n * l[5] + s * l[9] + o * l[13], 
            _[2] = a * l[2] + n * l[6] + s * l[10] + o * l[14], _[3] = a * l[3] + n * l[7] + s * l[11] + o * l[15];
        }
        static equals(e, t) {
            var i = e.elements, a = t.elements;
            return r.nearEqual(Math.abs(i[0]), Math.abs(a[0])) && r.nearEqual(Math.abs(i[1]), Math.abs(a[1])) && r.nearEqual(Math.abs(i[2]), Math.abs(a[2])) && r.nearEqual(Math.abs(i[3]), Math.abs(a[3]));
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(e, t) {
            var r = e.elements, i = t.elements, a = e.length();
            a > 0 && (i[0] = r[0] * a, i[1] = r[1] * a, i[2] = r[2] * a, i[3] = r[3] * a);
        }
        static add(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2], i[3] = a[3] + n[3];
        }
        static subtract(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] - n[0], i[1] = a[1] - n[1], i[2] = a[2] - n[2], i[3] = a[3] - n[3];
        }
        static multiply(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] * n[0], i[1] = a[1] * n[1], i[2] = a[2] * n[2], i[3] = a[3] * n[3];
        }
        static scale(e, t, r) {
            var i = r.elements, a = e.elements;
            i[0] = a[0] * t, i[1] = a[1] * t, i[2] = a[2] * t, i[3] = a[3] * t;
        }
        static Clamp(e, t, r, i) {
            var a = e.elements, n = a[0], s = a[1], o = a[2], l = a[3], _ = t.elements, h = _[0], c = _[1], d = _[2], u = _[3], m = r.elements, f = m[0], E = m[1], T = m[2], p = m[3], g = i.elements;
            n = (n = n > f ? f : n) < h ? h : n, s = (s = s > E ? E : s) < c ? c : s, o = (o = o > T ? T : o) < d ? d : o, 
            l = (l = l > p ? p : l) < u ? u : l, g[0] = n, g[1] = s, g[2] = o, g[3] = l;
        }
        static distanceSquared(e, t) {
            var r = e.elements, i = t.elements, a = r[0] - i[0], n = r[1] - i[1], s = r[2] - i[2], o = r[3] - i[3];
            return a * a + n * n + s * s + o * o;
        }
        static distance(e, t) {
            var r = e.elements, i = t.elements, a = r[0] - i[0], n = r[1] - i[1], s = r[2] - i[2], o = r[3] - i[3];
            return Math.sqrt(a * a + n * n + s * s + o * o);
        }
        static dot(e, t) {
            var r = e.elements, i = t.elements;
            return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
        }
        static min(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = Math.min(a[0], n[0]), i[1] = Math.min(a[1], n[1]), i[2] = Math.min(a[2], n[2]), 
            i[3] = Math.min(a[3], n[3]);
        }
        static max(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = Math.max(a[0], n[0]), i[1] = Math.max(a[1], n[1]), i[2] = Math.max(a[2], n[2]), 
            i[3] = Math.max(a[3], n[3]);
        }
    }
    D.ZERO = new D(), D.ONE = new D(1, 1, 1, 1), D.UnitX = new D(1, 0, 0, 0), D.UnitY = new D(0, 1, 0, 0), 
    D.UnitZ = new D(0, 0, 1, 0), D.UnitW = new D(0, 0, 0, 1);
    class M {
        constructor(e = 0, t = 0, r = 0, i = null) {
            var a;
            a = i || new Float32Array(3), this.elements = a, a[0] = e, a[1] = t, a[2] = r;
        }
        static distanceSquared(e, t) {
            var r = e.elements, i = t.elements, a = r[0] - i[0], n = r[1] - i[1], s = r[2] - i[2];
            return a * a + n * n + s * s;
        }
        static distance(e, t) {
            var r = e.elements, i = t.elements, a = r[0] - i[0], n = r[1] - i[1], s = r[2] - i[2];
            return Math.sqrt(a * a + n * n + s * s);
        }
        static min(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = Math.min(a[0], n[0]), i[1] = Math.min(a[1], n[1]), i[2] = Math.min(a[2], n[2]);
        }
        static max(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = Math.max(a[0], n[0]), i[1] = Math.max(a[1], n[1]), i[2] = Math.max(a[2], n[2]);
        }
        static transformQuat(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements, s = a[0], o = a[1], l = a[2], _ = n[0], h = n[1], c = n[2], d = n[3], u = d * s + h * l - c * o, m = d * o + c * s - _ * l, f = d * l + _ * o - h * s, E = -_ * s - h * o - c * l;
            i[0] = u * d + E * -_ + m * -c - f * -h, i[1] = m * d + E * -h + f * -_ - u * -c, 
            i[2] = f * d + E * -c + u * -h - m * -_;
        }
        static scalarLength(e) {
            var t = e.elements, r = t[0], i = t[1], a = t[2];
            return Math.sqrt(r * r + i * i + a * a);
        }
        static scalarLengthSquared(e) {
            var t = e.elements, r = t[0], i = t[1], a = t[2];
            return r * r + i * i + a * a;
        }
        static normalize(e, t) {
            var r = e.elements, i = t.elements, a = r[0], n = r[1], s = r[2], o = a * a + n * n + s * s;
            o > 0 && (o = 1 / Math.sqrt(o), i[0] = r[0] * o, i[1] = r[1] * o, i[2] = r[2] * o);
        }
        static multiply(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] * n[0], i[1] = a[1] * n[1], i[2] = a[2] * n[2];
        }
        static scale(e, t, r) {
            var i = r.elements, a = e.elements;
            i[0] = a[0] * t, i[1] = a[1] * t, i[2] = a[2] * t;
        }
        static lerp(e, t, r, i) {
            var a = i.elements, n = e.elements, s = t.elements, o = n[0], l = n[1], _ = n[2];
            a[0] = o + r * (s[0] - o), a[1] = l + r * (s[1] - l), a[2] = _ + r * (s[2] - _);
        }
        static transformV3ToV3(e, t, r) {
            var i = M._tempVector4;
            M.transformV3ToV4(e, t, i);
            var a = i.elements, n = r.elements;
            n[0] = a[0], n[1] = a[1], n[2] = a[2];
        }
        static transformV3ToV4(e, t, r) {
            var i = e.elements, a = i[0], n = i[1], s = i[2], o = t.elements, l = r.elements;
            l[0] = a * o[0] + n * o[4] + s * o[8] + o[12], l[1] = a * o[1] + n * o[5] + s * o[9] + o[13], 
            l[2] = a * o[2] + n * o[6] + s * o[10] + o[14], l[3] = a * o[3] + n * o[7] + s * o[11] + o[15];
        }
        static TransformNormal(e, t, r) {
            var i = e.elements, a = i[0], n = i[1], s = i[2], o = t.elements, l = r.elements;
            l[0] = a * o[0] + n * o[4] + s * o[8], l[1] = a * o[1] + n * o[5] + s * o[9], l[2] = a * o[2] + n * o[6] + s * o[10];
        }
        static transformCoordinate(e, t, r) {
            var i = e.elements, a = i[0], n = i[1], s = i[2], o = t.elements, l = a * o[3] + n * o[7] + s * o[11] + o[15], _ = r.elements;
            _[0] = a * o[0] + n * o[4] + s * o[8] + o[12] / l, _[1] = a * o[1] + n * o[5] + s * o[9] + o[13] / l, 
            _[2] = a * o[2] + n * o[6] + s * o[10] + o[14] / l;
        }
        static Clamp(e, t, r, i) {
            var a = e.elements, n = a[0], s = a[1], o = a[2], l = t.elements, _ = l[0], h = l[1], c = l[2], d = r.elements, u = d[0], m = d[1], f = d[2], E = i.elements;
            n = (n = n > u ? u : n) < _ ? _ : n, s = (s = s > m ? m : s) < h ? h : s, o = (o = o > f ? f : o) < c ? c : o, 
            E[0] = n, E[1] = s, E[2] = o;
        }
        static add(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2];
        }
        static subtract(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] - n[0], i[1] = a[1] - n[1], i[2] = a[2] - n[2];
        }
        static cross(e, t, r) {
            var i = e.elements, a = t.elements, n = r.elements, s = i[0], o = i[1], l = i[2], _ = a[0], h = a[1], c = a[2];
            n[0] = o * c - l * h, n[1] = l * _ - s * c, n[2] = s * h - o * _;
        }
        static dot(e, t) {
            var r = e.elements, i = t.elements;
            return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
        }
        static equals(e, t) {
            var i = e.elements, a = t.elements;
            return r.nearEqual(i[0], a[0]) && r.nearEqual(i[1], a[1]) && r.nearEqual(i[2], a[2]);
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        setValue(e, t, r) {
            this.elements[0] = e, this.elements[1] = t, this.elements[2] = r;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2];
        }
        cloneTo(e) {
            var t = e.elements, r = this.elements;
            t[0] = r[0], t[1] = r[1], t[2] = r[2];
        }
        clone() {
            var e = new M();
            return this.cloneTo(e), e;
        }
        toDefault() {
            this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
        }
    }
    M._tempVector4 = new D(), M.ZERO = new M(0, 0, 0), M.ONE = new M(1, 1, 1), M.NegativeUnitX = new M(-1, 0, 0), 
    M.UnitX = new M(1, 0, 0), M.UnitY = new M(0, 1, 0), M.UnitZ = new M(0, 0, 1), M.ForwardRH = new M(0, 0, -1), 
    M.ForwardLH = new M(0, 0, 1), M.Up = new M(0, 1, 0), M.NAN = new M(NaN, NaN, NaN);
    class y {
        constructor(e = 1, t = 0, r = 0, i = 0, a = 0, n = 1, s = 0, o = 0, l = 0, _ = 0, h = 1, c = 0, d = 0, u = 0, m = 0, f = 1, E = null) {
            var T = this.elements = E || new Float32Array(16);
            T[0] = e, T[1] = t, T[2] = r, T[3] = i, T[4] = a, T[5] = n, T[6] = s, T[7] = o, 
            T[8] = l, T[9] = _, T[10] = h, T[11] = c, T[12] = d, T[13] = u, T[14] = m, T[15] = f;
        }
        static createRotationX(e, t) {
            var r = t.elements, i = Math.sin(e), a = Math.cos(e);
            r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0, r[0] = r[15] = 1, 
            r[5] = r[10] = a, r[6] = i, r[9] = -i;
        }
        static createRotationY(e, t) {
            var r = t.elements, i = Math.sin(e), a = Math.cos(e);
            r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[5] = r[15] = 1, 
            r[0] = r[10] = a, r[2] = -i, r[8] = i;
        }
        static createRotationZ(e, t) {
            var r = t.elements, i = Math.sin(e), a = Math.cos(e);
            r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[10] = r[15] = 1, 
            r[0] = r[5] = a, r[1] = i, r[4] = -i;
        }
        static createRotationYawPitchRoll(e, t, r, i) {
            f.createFromYawPitchRoll(e, t, r, y._tempQuaternion), y.createRotationQuaternion(y._tempQuaternion, i);
        }
        static createRotationAxis(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = Math.cos(t), o = Math.sin(t), l = i * i, _ = a * a, h = n * n, c = i * a, d = i * n, u = a * n, m = r.elements;
            m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0, m[15] = 1, m[0] = l + s * (1 - l), 
            m[1] = c - s * c + o * n, m[2] = d - s * d - o * a, m[4] = c - s * c - o * n, m[5] = _ + s * (1 - _), 
            m[6] = u - s * u + o * i, m[8] = d - s * d + o * a, m[9] = u - s * u - o * i, m[10] = h + s * (1 - h);
        }
        setRotation(e) {
            var t = e.x, r = e.y, i = e.z, a = e.w, n = t * t, s = r * r, o = i * i, l = t * r, _ = i * a, h = i * t, c = r * a, d = r * i, u = t * a, m = this.elements;
            m[0] = 1 - 2 * (s + o), m[1] = 2 * (l + _), m[2] = 2 * (h - c), m[4] = 2 * (l - _), 
            m[5] = 1 - 2 * (o + n), m[6] = 2 * (d + u), m[8] = 2 * (h + c), m[9] = 2 * (d - u), 
            m[10] = 1 - 2 * (s + n);
        }
        setPosition(e) {
            var t = this.elements;
            t[12] = e.x, t[13] = e.y, t[14] = e.z;
        }
        static createRotationQuaternion(e, t) {
            var r = t.elements, i = e.x, a = e.y, n = e.z, s = e.w, o = i * i, l = a * a, _ = n * n, h = i * a, c = n * s, d = n * i, u = a * s, m = a * n, f = i * s;
            r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0, r[15] = 1, r[0] = 1 - 2 * (l + _), 
            r[1] = 2 * (h + c), r[2] = 2 * (d - u), r[4] = 2 * (h - c), r[5] = 1 - 2 * (_ + o), 
            r[6] = 2 * (m + f), r[8] = 2 * (d + u), r[9] = 2 * (m - f), r[10] = 1 - 2 * (l + o);
        }
        static createTranslate(e, t) {
            var r = t.elements;
            r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0, r[0] = r[5] = r[10] = r[15] = 1, 
            r[12] = e.x, r[13] = e.y, r[14] = e.z;
        }
        static createScaling(e, t) {
            var r = t.elements;
            r[0] = e.x, r[5] = e.y, r[10] = e.z, r[1] = r[4] = r[8] = r[12] = r[9] = r[13] = r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0, 
            r[15] = 1;
        }
        static multiply(e, t, r) {
            var i = t.elements, a = e.elements, n = r.elements, s = i[0], o = i[1], l = i[2], _ = i[3], h = i[4], c = i[5], d = i[6], u = i[7], m = i[8], f = i[9], E = i[10], T = i[11], p = i[12], g = i[13], S = i[14], R = i[15], v = a[0], x = a[1], I = a[2], A = a[3], L = a[4], C = a[5], D = a[6], M = a[7], y = a[8], O = a[9], N = a[10], b = a[11], P = a[12], w = a[13], V = a[14], B = a[15];
            n[0] = s * v + o * L + l * y + _ * P, n[1] = s * x + o * C + l * O + _ * w, n[2] = s * I + o * D + l * N + _ * V, 
            n[3] = s * A + o * M + l * b + _ * B, n[4] = h * v + c * L + d * y + u * P, n[5] = h * x + c * C + d * O + u * w, 
            n[6] = h * I + c * D + d * N + u * V, n[7] = h * A + c * M + d * b + u * B, n[8] = m * v + f * L + E * y + T * P, 
            n[9] = m * x + f * C + E * O + T * w, n[10] = m * I + f * D + E * N + T * V, n[11] = m * A + f * M + E * b + T * B, 
            n[12] = p * v + g * L + S * y + R * P, n[13] = p * x + g * C + S * O + R * w, n[14] = p * I + g * D + S * N + R * V, 
            n[15] = p * A + g * M + S * b + R * B;
        }
        static multiplyForNative(e, r, i) {
            t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, i.elements);
        }
        static createFromQuaternion(e, t) {
            var r = t.elements, i = e.x, a = e.y, n = e.z, s = e.w, o = i + i, l = a + a, _ = n + n, h = i * o, c = a * o, d = a * l, u = n * o, m = n * l, f = n * _, E = s * o, T = s * l, p = s * _;
            r[0] = 1 - d - f, r[1] = c + p, r[2] = u - T, r[3] = 0, r[4] = c - p, r[5] = 1 - h - f, 
            r[6] = m + E, r[7] = 0, r[8] = u + T, r[9] = m - E, r[10] = 1 - h - d, r[11] = 0, 
            r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1;
        }
        static createAffineTransformation(e, t, r, i) {
            var a = i.elements, n = t.x, s = t.y, o = t.z, l = t.w, _ = n + n, h = s + s, c = o + o, d = n * _, u = n * h, m = n * c, f = s * h, E = s * c, T = o * c, p = l * _, g = l * h, S = l * c, R = r.x, v = r.y, x = r.z;
            a[0] = (1 - (f + T)) * R, a[1] = (u + S) * R, a[2] = (m - g) * R, a[3] = 0, a[4] = (u - S) * v, 
            a[5] = (1 - (d + T)) * v, a[6] = (E + p) * v, a[7] = 0, a[8] = (m + g) * x, a[9] = (E - p) * x, 
            a[10] = (1 - (d + f)) * x, a[11] = 0, a[12] = e.x, a[13] = e.y, a[14] = e.z, a[15] = 1;
        }
        static createLookAt(e, t, r, i) {
            var a = i.elements, s = y._tempVector0, o = y._tempVector1, l = y._tempVector2;
            n.subtract(e, t, l), n.normalize(l, l), n.cross(r, l, s), n.normalize(s, s), n.cross(l, s, o), 
            a[3] = a[7] = a[11] = 0, a[15] = 1, a[0] = s.x, a[4] = s.y, a[8] = s.z, a[1] = o.x, 
            a[5] = o.y, a[9] = o.z, a[2] = l.x, a[6] = l.y, a[10] = l.z, a[12] = -n.dot(s, e), 
            a[13] = -n.dot(o, e), a[14] = -n.dot(l, e);
        }
        static createPerspective(e, t, r, i, a) {
            var n = 1 / Math.tan(.5 * e), s = r / (n / t), o = r / n;
            y.createPerspectiveOffCenter(-s, s, -o, o, r, i, a);
        }
        static createPerspectiveOffCenter(e, t, r, i, a, n, s) {
            var o = s.elements, l = n / (n - a);
            o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[12] = o[13] = o[15] = 0, o[0] = 2 * a / (t - e), 
            o[5] = 2 * a / (i - r), o[8] = (e + t) / (t - e), o[9] = (i + r) / (i - r), o[10] = -l, 
            o[11] = -1, o[14] = -a * l;
        }
        static createOrthoOffCenter(e, t, r, i, a, n, s) {
            var o = s.elements, l = 1 / (n - a);
            o[1] = o[2] = o[3] = o[4] = o[6] = o[8] = o[7] = o[9] = o[11] = 0, o[15] = 1, o[0] = 2 / (t - e), 
            o[5] = 2 / (i - r), o[10] = -l, o[12] = (e + t) / (e - t), o[13] = (i + r) / (r - i), 
            o[14] = -a * l;
        }
        getElementByRowColumn(e, t) {
            if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            return this.elements[4 * e + t];
        }
        setElementByRowColumn(e, t, r) {
            if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            this.elements[4 * e + t] = r;
        }
        equalsOtherMatrix(e) {
            var t = this.elements, i = e.elements;
            return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]) && r.nearEqual(t[4], i[4]) && r.nearEqual(t[5], i[5]) && r.nearEqual(t[6], i[6]) && r.nearEqual(t[7], i[7]) && r.nearEqual(t[8], i[8]) && r.nearEqual(t[9], i[9]) && r.nearEqual(t[10], i[10]) && r.nearEqual(t[11], i[11]) && r.nearEqual(t[12], i[12]) && r.nearEqual(t[13], i[13]) && r.nearEqual(t[14], i[14]) && r.nearEqual(t[15], i[15]);
        }
        decomposeTransRotScale(e, t, r) {
            var i = y._tempMatrix4x4;
            return this.decomposeTransRotMatScale(e, i, r) ? (f.createFromMatrix4x4(i, t), !0) : (t.identity(), 
            !1);
        }
        decomposeTransRotMatScale(e, t, i) {
            var a = this.elements, s = e, o = t.elements, l = i;
            s.x = a[12], s.y = a[13], s.z = a[14];
            var _ = a[0], h = a[1], c = a[2], d = a[4], u = a[5], m = a[6], f = a[8], E = a[9], T = a[10], p = l.x = Math.sqrt(_ * _ + h * h + c * c), g = l.y = Math.sqrt(d * d + u * u + m * m), S = l.z = Math.sqrt(f * f + E * E + T * T);
            if (r.isZero(p) || r.isZero(g) || r.isZero(S)) return o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[8] = o[9] = o[11] = o[12] = o[13] = o[14] = 0, 
            o[0] = o[5] = o[10] = o[15] = 1, !1;
            var R = y._tempVector0;
            R.x = f / S, R.y = E / S, R.z = T / S;
            var v = y._tempVector1;
            v.x = _ / p, v.y = h / p, v.z = c / p;
            var x = y._tempVector2;
            n.cross(R, v, x);
            var I = y._tempVector1;
            return n.cross(x, R, I), o[3] = o[7] = o[11] = o[12] = o[13] = o[14] = 0, o[15] = 1, 
            o[0] = I.x, o[1] = I.y, o[2] = I.z, o[4] = x.x, o[5] = x.y, o[6] = x.z, o[8] = R.x, 
            o[9] = R.y, o[10] = R.z, o[0] * _ + o[1] * h + o[2] * c < 0 && (l.x = -p), o[4] * d + o[5] * u + o[6] * m < 0 && (l.y = -g), 
            o[8] * f + o[9] * E + o[10] * T < 0 && (l.z = -S), !0;
        }
        decomposeYawPitchRoll(e) {
            var t = Math.asin(-this.elements[9]);
            e.y = t, Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]), 
            e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]), 
            e.x = 0);
        }
        normalize() {
            var e = this.elements, t = e[0], r = e[1], i = e[2], a = Math.sqrt(t * t + r * r + i * i);
            if (!a) return e[0] = 0, e[1] = 0, void (e[2] = 0);
            1 != a && (a = 1 / a, e[0] = t * a, e[1] = r * a, e[2] = i * a);
        }
        transpose() {
            var e, t;
            return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], 
            e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7], 
            e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        invert(e) {
            var t = this.elements, r = e.elements, i = t[0], a = t[1], n = t[2], s = t[3], o = t[4], l = t[5], _ = t[6], h = t[7], c = t[8], d = t[9], u = t[10], m = t[11], f = t[12], E = t[13], T = t[14], p = t[15], g = i * l - a * o, S = i * _ - n * o, R = i * h - s * o, v = a * _ - n * l, x = a * h - s * l, I = n * h - s * _, A = c * E - d * f, L = c * T - u * f, C = c * p - m * f, D = d * T - u * E, M = d * p - m * E, y = u * p - m * T, O = g * y - S * M + R * D + v * C - x * L + I * A;
            0 !== Math.abs(O) && (O = 1 / O, r[0] = (l * y - _ * M + h * D) * O, r[1] = (n * M - a * y - s * D) * O, 
            r[2] = (E * I - T * x + p * v) * O, r[3] = (u * x - d * I - m * v) * O, r[4] = (_ * C - o * y - h * L) * O, 
            r[5] = (i * y - n * C + s * L) * O, r[6] = (T * R - f * I - p * S) * O, r[7] = (c * I - u * R + m * S) * O, 
            r[8] = (o * M - l * C + h * A) * O, r[9] = (a * C - i * M - s * A) * O, r[10] = (f * x - E * R + p * g) * O, 
            r[11] = (d * R - c * x - m * g) * O, r[12] = (l * L - o * D - _ * A) * O, r[13] = (i * D - a * L + n * A) * O, 
            r[14] = (E * S - f * v - T * g) * O, r[15] = (c * v - d * S + u * g) * O);
        }
        static billboard(e, t, i, a, s, o) {
            n.subtract(e, t, y._tempVector0);
            var l = n.scalarLengthSquared(y._tempVector0);
            r.isZero(l) ? (n.scale(s, -1, y._tempVector1), y._tempVector1.cloneTo(y._tempVector0)) : n.scale(y._tempVector0, 1 / Math.sqrt(l), y._tempVector0), 
            n.cross(a, y._tempVector0, y._tempVector2), n.normalize(y._tempVector2, y._tempVector2), 
            n.cross(y._tempVector0, y._tempVector2, y._tempVector3);
            var _ = y._tempVector2, h = y._tempVector3, c = y._tempVector0, d = e, u = o.elements;
            u[0] = _.x, u[1] = _.y, u[2] = _.z, u[3] = 0, u[4] = h.x, u[5] = h.y, u[6] = h.z, 
            u[7] = 0, u[8] = c.x, u[9] = c.y, u[10] = c.z, u[11] = 0, u[12] = d.x, u[13] = d.y, 
            u[14] = d.z, u[15] = 1;
        }
        identity() {
            var e = this.elements;
            e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
            e[0] = e[5] = e[10] = e[15] = 1;
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements)) for (t = 0; t < 16; ++t) i[t] = r[t];
        }
        clone() {
            var e = new y();
            return this.cloneTo(e), e;
        }
        static translation(e, t) {
            var r = t.elements;
            r[0] = r[5] = r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z;
        }
        getTranslationVector(e) {
            var t = this.elements;
            e.x = t[12], e.y = t[13], e.z = t[14];
        }
        setTranslationVector(e) {
            var t = this.elements, r = e;
            t[12] = r.x, t[13] = r.y, t[14] = r.z;
        }
        getForward(e) {
            var t = this.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }
        setForward(e) {
            var t = this.elements;
            t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
        }
    }
    y._tempMatrix4x4 = new y(), y.TEMPMatrix0 = new y(), y.TEMPMatrix1 = new y(), y._tempVector0 = new n(), 
    y._tempVector1 = new n(), y._tempVector2 = new n(), y._tempVector3 = new n(), y._tempQuaternion = new f(), 
    y.DEFAULT = new y(), y.ZERO = new y(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    class O {
        constructor(e = 0, t = 0, r = 0, i = 1, a = null) {
            var n;
            (n = a || new Float32Array(4))[0] = e, n[1] = t, n[2] = r, n[3] = i, this.elements = n;
        }
        static _dotArray(e, t) {
            return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        }
        static _normalizeArray(e, t) {
            var r = e[0], i = e[1], a = e[2], n = e[3], s = r * r + i * i + a * a + n * n;
            s > 0 && (s = 1 / Math.sqrt(s), t[0] = r * s, t[1] = i * s, t[2] = a * s, t[3] = n * s);
        }
        static _lerpArray(e, t, r, i) {
            var a = 1 - r;
            O._dotArray(e, t) >= 0 ? (i[0] = a * e[0] + r * t[0], i[1] = a * e[1] + r * t[1], 
            i[2] = a * e[2] + r * t[2], i[3] = a * e[3] + r * t[3]) : (i[0] = a * e[0] - r * t[0], 
            i[1] = a * e[1] - r * t[1], i[2] = a * e[2] - r * t[2], i[3] = a * e[3] - r * t[3]), 
            O._normalizeArray(i, i);
        }
        static createFromYawPitchRoll(e, t, r, i) {
            var a = .5 * r, n = .5 * t, s = .5 * e, o = Math.sin(a), l = Math.cos(a), _ = Math.sin(n), h = Math.cos(n), c = Math.sin(s), d = Math.cos(s), u = i.elements;
            u[0] = d * _ * l + c * h * o, u[1] = c * h * l - d * _ * o, u[2] = d * h * o - c * _ * l, 
            u[3] = d * h * l + c * _ * o;
        }
        static multiply(e, t, r) {
            var i = e.elements, a = t.elements, n = r.elements, s = i[0], o = i[1], l = i[2], _ = i[3], h = a[0], c = a[1], d = a[2], u = a[3], m = o * d - l * c, f = l * h - s * d, E = s * c - o * h, T = s * h + o * c + l * d;
            n[0] = s * u + h * _ + m, n[1] = o * u + c * _ + f, n[2] = l * u + d * _ + E, n[3] = _ * u - T;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            M.subtract(t, e, O.TEMPVector30), M.normalize(O.TEMPVector30, O.TEMPVector30), r.elements[0] = Math.asin(O.TEMPVector30.y), 
            r.elements[1] = O.arcTanAngle(-O.TEMPVector30.z, -O.TEMPVector30.x);
        }
        static createFromAxisAngle(e, t, r) {
            var i = r.elements, a = e.elements;
            t *= .5;
            var n = Math.sin(t);
            i[0] = n * a[0], i[1] = n * a[1], i[2] = n * a[2], i[3] = Math.cos(t);
        }
        static createFromMatrix3x3(e, t) {
            var r, i = t.elements, a = e.elements, n = a[0] + a[4] + a[8];
            if (n > 0) r = Math.sqrt(n + 1), i[3] = .5 * r, r = .5 / r, i[0] = (a[5] - a[7]) * r, 
            i[1] = (a[6] - a[2]) * r, i[2] = (a[1] - a[3]) * r; else {
                var s = 0;
                a[4] > a[0] && (s = 1), a[8] > a[3 * s + s] && (s = 2);
                var o = (s + 1) % 3, l = (s + 2) % 3;
                r = Math.sqrt(a[3 * s + s] - a[3 * o + o] - a[3 * l + l] + 1), i[s] = .5 * r, r = .5 / r, 
                i[3] = (a[3 * o + l] - a[3 * l + o]) * r, i[o] = (a[3 * o + s] + a[3 * s + o]) * r, 
                i[l] = (a[3 * l + s] + a[3 * s + l]) * r;
            }
        }
        static createFromMatrix4x4(e, t) {
            var r, i, a = e.elements, n = t.elements, s = a[0] + a[5] + a[10];
            s > 0 ? (r = Math.sqrt(s + 1), n[3] = .5 * r, r = .5 / r, n[0] = (a[6] - a[9]) * r, 
            n[1] = (a[8] - a[2]) * r, n[2] = (a[1] - a[4]) * r) : a[0] >= a[5] && a[0] >= a[10] ? (i = .5 / (r = Math.sqrt(1 + a[0] - a[5] - a[10])), 
            n[0] = .5 * r, n[1] = (a[1] + a[4]) * i, n[2] = (a[2] + a[8]) * i, n[3] = (a[6] - a[9]) * i) : a[5] > a[10] ? (i = .5 / (r = Math.sqrt(1 + a[5] - a[0] - a[10])), 
            n[0] = (a[4] + a[1]) * i, n[1] = .5 * r, n[2] = (a[9] + a[6]) * i, n[3] = (a[8] - a[2]) * i) : (i = .5 / (r = Math.sqrt(1 + a[10] - a[0] - a[5])), 
            n[0] = (a[8] + a[2]) * i, n[1] = (a[9] + a[6]) * i, n[2] = .5 * r, n[3] = (a[1] - a[4]) * i);
        }
        static slerp(e, t, r, i) {
            var a, n, s, o, l, _ = e.elements, h = t.elements, c = i.elements, d = _[0], u = _[1], m = _[2], f = _[3], E = h[0], T = h[1], p = h[2], g = h[3];
            return (n = d * E + u * T + m * p + f * g) < 0 && (n = -n, E = -E, T = -T, p = -p, 
            g = -g), 1 - n > 1e-6 ? (a = Math.acos(n), s = Math.sin(a), o = Math.sin((1 - r) * a) / s, 
            l = Math.sin(r * a) / s) : (o = 1 - r, l = r), c[0] = o * d + l * E, c[1] = o * u + l * T, 
            c[2] = o * m + l * p, c[3] = o * f + l * g, c;
        }
        static lerp(e, t, r, i) {
            O._lerpArray(e.elements, t.elements, r, i.elements);
        }
        static add(e, t, r) {
            var i = r.elements, a = e.elements, n = t.elements;
            i[0] = a[0] + n[0], i[1] = a[1] + n[1], i[2] = a[2] + n[2], i[3] = a[3] + n[3];
        }
        static dot(e, t) {
            return O._dotArray(e.elements, t.elements);
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        get w() {
            return this.elements[3];
        }
        set w(e) {
            this.elements[3] = e;
        }
        scaling(e, t) {
            var r = t.elements, i = this.elements;
            r[0] = i[0] * e, r[1] = i[1] * e, r[2] = i[2] * e, r[3] = i[3] * e;
        }
        normalize(e) {
            O._normalizeArray(this.elements, e.elements);
        }
        length() {
            var e = this.elements, t = e[0], r = e[1], i = e[2], a = e[3];
            return Math.sqrt(t * t + r * r + i * i + a * a);
        }
        rotateX(e, t) {
            var r = t.elements, i = this.elements;
            e *= .5;
            var a = i[0], n = i[1], s = i[2], o = i[3], l = Math.sin(e), _ = Math.cos(e);
            r[0] = a * _ + o * l, r[1] = n * _ + s * l, r[2] = s * _ - n * l, r[3] = o * _ - a * l;
        }
        rotateY(e, t) {
            var r = t.elements, i = this.elements;
            e *= .5;
            var a = i[0], n = i[1], s = i[2], o = i[3], l = Math.sin(e), _ = Math.cos(e);
            r[0] = a * _ - s * l, r[1] = n * _ + o * l, r[2] = s * _ + a * l, r[3] = o * _ - n * l;
        }
        rotateZ(e, t) {
            var r = t.elements, i = this.elements;
            e *= .5;
            var a = i[0], n = i[1], s = i[2], o = i[3], l = Math.sin(e), _ = Math.cos(e);
            r[0] = a * _ + n * l, r[1] = n * _ - a * l, r[2] = s * _ + o * l, r[3] = o * _ - s * l;
        }
        getYawPitchRoll(e) {
            M.transformQuat(M.ForwardRH, this, O.TEMPVector31), M.transformQuat(M.Up, this, O.TEMPVector32);
            var t = O.TEMPVector32.elements;
            O.angleTo(M.ZERO, O.TEMPVector31, O.TEMPVector33);
            var r = O.TEMPVector33.elements;
            r[0] == Math.PI / 2 ? (r[1] = O.arcTanAngle(t[2], t[0]), r[2] = 0) : r[0] == -Math.PI / 2 ? (r[1] = O.arcTanAngle(-t[2], -t[0]), 
            r[2] = 0) : (y.createRotationY(-r[1], O.TEMPMatrix0), y.createRotationX(-r[0], O.TEMPMatrix1), 
            M.transformCoordinate(O.TEMPVector32, O.TEMPMatrix0, O.TEMPVector32), M.transformCoordinate(O.TEMPVector32, O.TEMPMatrix1, O.TEMPVector32), 
            r[2] = O.arcTanAngle(t[1], -t[0])), r[1] <= -Math.PI && (r[1] = Math.PI), r[2] <= -Math.PI && (r[2] = Math.PI), 
            r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0, r[2] = 0, r[0] = Math.PI - r[0]);
            var i = e.elements;
            i[0] = r[1], i[1] = r[0], i[2] = r[2];
        }
        invert(e) {
            var t = e.elements, r = this.elements, i = r[0], a = r[1], n = r[2], s = r[3], o = i * i + a * a + n * n + s * s, l = o ? 1 / o : 0;
            t[0] = -i * l, t[1] = -a * l, t[2] = -n * l, t[3] = s * l;
        }
        identity() {
            var e = this.elements;
            e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2], 
            this.elements[3] = e[t + 3];
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements)) for (t = 0; t < 4; ++t) i[t] = r[t];
        }
        clone() {
            var e = new O();
            return this.cloneTo(e), e;
        }
        equals(e) {
            var t = this.elements, i = e.elements;
            return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]);
        }
        static rotationLookAt(e, t, r) {
            O.lookAt(M.ZERO, e, t, r);
        }
        static lookAt(e, t, r, i) {
            m.lookAt(e, t, r, O._tempMatrix3x3), O.rotationMatrix(O._tempMatrix3x3, i);
        }
        lengthSquared() {
            var e = this.elements[0], t = this.elements[1], r = this.elements[2], i = this.elements[3];
            return e * e + t * t + r * r + i * i;
        }
        static invert(e, t) {
            var i = e.elements, a = t.elements, n = e.lengthSquared();
            r.isZero(n) || (n = 1 / n, a[0] = -i[0] * n, a[1] = -i[1] * n, a[2] = -i[2] * n, 
            a[3] = i[3] * n);
        }
        static rotationMatrix(e, t) {
            var r, i, a = e.elements, n = a[0], s = a[1], o = a[2], l = a[3], _ = a[4], h = a[5], c = a[6], d = a[7], u = a[8], m = t.elements, f = n + _ + u;
            f > 0 ? (r = Math.sqrt(f + 1), m[3] = .5 * r, r = .5 / r, m[0] = (h - d) * r, m[1] = (c - o) * r, 
            m[2] = (s - l) * r) : n >= _ && n >= u ? (i = .5 / (r = Math.sqrt(1 + n - _ - u)), 
            m[0] = .5 * r, m[1] = (s + l) * i, m[2] = (o + c) * i, m[3] = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - n - u)), 
            m[0] = (l + s) * i, m[1] = .5 * r, m[2] = (d + h) * i, m[3] = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - n - _)), 
            m[0] = (c + o) * i, m[1] = (d + h) * i, m[2] = .5 * r, m[3] = (s - l) * i);
        }
    }
    O.TEMPVector30 = new M(), O.TEMPVector31 = new M(), O.TEMPVector32 = new M(), O.TEMPVector33 = new M(), 
    O.TEMPMatrix0 = new y(), O.TEMPMatrix1 = new y(), O._tempMatrix3x3 = new m(), O.DEFAULT = new O(), 
    O.NAN = new O(NaN, NaN, NaN, NaN);
    class N {
        constructor() {
            this._referenceCount = 0, this._clip = null, this._nodeOwners = [], this._currentFrameIndices = null, 
            this._realtimeDatas = [], this._scripts = null, this.speed = 1, this.clipStart = 0, 
            this.clipEnd = 1;
        }
        get clip() {
            return this._clip;
        }
        set clip(e) {
            if (this._clip !== e) {
                if (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount), 
                e) {
                    var r = this._realtimeDatas, i = e._nodes, a = i.count;
                    this._currentFrameIndices = new Int16Array(a), this._resetFrameIndices(), this._referenceCount > 0 && e._addReference(this._referenceCount), 
                    this._realtimeDatas.length = a;
                    for (var s = 0; s < a; s++) switch (i.getNodeByIndex(s).type) {
                      case 0:
                        break;

                      case 1:
                      case 3:
                      case 4:
                        r[s] = t.Render.supportWebGLPlusAnimation ? new M() : new n();
                        break;

                      case 2:
                        r[s] = t.Render.supportWebGLPlusAnimation ? new O() : new f();
                        break;

                      default:
                        throw "AnimationClipParser04:unknown type.";
                    }
                }
                this._clip = e;
            }
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(e = 1) {
            this._clip && this._clip._addReference(e), this._referenceCount += e;
        }
        _removeReference(e = 1) {
            this._clip && this._clip._removeReference(e), this._referenceCount -= e;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        _resetFrameIndices() {
            for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this._currentFrameIndices[e] = -1;
        }
        addScript(e) {
            var t = new e();
            return this._scripts = this._scripts || [], this._scripts.push(t), t;
        }
        getScript(e) {
            if (this._scripts) for (var t = 0, r = this._scripts.length; t < r; t++) {
                var i = this._scripts[t];
                if (i instanceof e) return i;
            }
            return null;
        }
        getScripts(e) {
            var t;
            if (this._scripts) for (var r = 0, i = this._scripts.length; r < i; r++) {
                var a = this._scripts[r];
                a instanceof e && (t = t || []).push(a);
            }
            return t;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd, 
            t.clip = this._clip;
        }
        clone() {
            var e = new N();
            return this.cloneTo(e), e;
        }
    }
    class b {
        constructor() {
            this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1, 
            this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null, 
            this.value = null, this.crossFixedValue = null;
        }
        saveCrossFixedValue() {
            if (this.propertyOwner) switch (this.type) {
              case 0:
                this.crossFixedValue = this.value;
                break;

              case 1:
              case 3:
              case 4:
              case 2:
                this.value.cloneTo(this.crossFixedValue);
                break;

              default:
                throw "Animator:unknown type.";
            }
        }
    }
    class P extends t.Component {
        constructor() {
            super(), this._keyframeNodeOwners = [], this._linkAvatarSpritesData = {}, this._linkAvatarSprites = [], 
            this._renderableSprites = [], this.cullingMode = P.CULLINGMODE_CULLCOMPLETELY, this._controllerLayers = [], 
            this._linkSprites = {}, this._speed = 1, this._keyframeNodeOwnerMap = {}, this._updateMark = 0;
        }
        static _update(e) {
            for (var t = e._animatorPool, r = t.elements, i = 0, a = t.length; i < a; i++) {
                var n = r[i];
                n && n.enabled && n._update();
            }
        }
        get speed() {
            return this._speed;
        }
        set speed(e) {
            this._speed = e;
        }
        _linkToSprites(e) {
            for (var t in e) {
                for (var r = this.owner, i = e[t], a = 0, n = i.length; a < n; a++) {
                    var s = i[a];
                    if ("" === s) break;
                    if (!(r = r.getChildByName(s))) break;
                }
                r && this.linkSprite3DToAvatarNode(t, r);
            }
        }
        _addKeyframeNodeOwner(e, t, r) {
            var i = t._indexInList, a = t.fullPath, n = this._keyframeNodeOwnerMap[a];
            if (n) n.referenceCount++, e[i] = n; else {
                for (var s = r, o = 0, l = t.propertyCount; o < l && (s = s[t.getPropertyByIndex(o)]); o++) ;
                (n = this._keyframeNodeOwnerMap[a] = new b()).fullPath = a, n.indexInList = this._keyframeNodeOwners.length, 
                n.referenceCount = 1, n.propertyOwner = r;
                var _ = t.propertyCount, h = [];
                for (o = 0; o < _; o++) h[o] = t.getPropertyByIndex(o);
                if (n.property = h, n.type = t.type, s) if (0 === t.type) n.defaultValue = s; else {
                    var c = new s.constructor();
                    s.cloneTo(c), n.defaultValue = c, n.value = new s.constructor(), n.crossFixedValue = new s.constructor();
                }
                this._keyframeNodeOwners.push(n), e[i] = n;
            }
        }
        _removeKeyframeNodeOwner(e, t) {
            var r = t.fullPath, i = this._keyframeNodeOwnerMap[r];
            i && (i.referenceCount--, 0 === i.referenceCount && (delete this._keyframeNodeOwnerMap[r], 
            this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(i), 1)), e[t._indexInList] = null);
        }
        _getOwnersByClip(e) {
            var t = e._clip._nodes, r = t.count, i = e._nodeOwners;
            i.length = r;
            for (var a = 0; a < r; a++) {
                for (var n = t.getNodeByIndex(a), s = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, o = 0, l = n.ownerPathCount; o < l; o++) {
                    var _ = n.getOwnerPathByIndex(o);
                    if ("" === _) break;
                    if (!(s = s.getChildByName(_))) break;
                }
                if (s) {
                    var h = n.propertyOwner;
                    h && (s = s[h]), s && this._addKeyframeNodeOwner(i, n, s);
                }
            }
        }
        _updatePlayer(e, t, r, i) {
            var a = e._clip._duration * (e.clipEnd - e.clipStart), n = t._elapsedTime, s = n + r;
            t._lastElapsedTime = n, t._elapsedTime = s;
            var o = s / a;
            t._normalizedTime = o;
            var l = o % 1;
            t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = a;
            var _ = e._scripts;
            if (!i && s >= a) {
                if (t._finish = !0, t._elapsedTime = a, t._normalizedPlayTime = 1, _) for (var h = 0, c = _.length; h < c; h++) _[h].onStateExit();
            } else if (_) for (h = 0, c = _.length; h < c; h++) _[h].onStateUpdate();
        }
        _eventScript(e, t, r, i, a) {
            if (a) for (var n = t.length; r < n; r++) {
                var s = t[r];
                if (!(s.time <= i)) break;
                for (var o = 0, l = e.length; o < l; o++) {
                    var _ = e[o], h = _[s.eventName];
                    h && h.apply(_, s.params);
                }
            } else for (;r >= 0 && (s = t[r]).time >= i; r--) for (o = 0, l = e.length; o < l; o++) (h = (_ = e[o])[s.eventName]) && h.apply(_, s.params);
            return r;
        }
        _updateEventScript(e, t) {
            var r = this.owner._scripts;
            if (r) {
                var i = e._clip, a = i._animationEvents, n = i._duration, s = t._elapsedTime, o = s % n, l = Math.abs(Math.floor(s / n) - Math.floor(t._lastElapsedTime / n)), _ = t._elapsedTime >= t._lastElapsedTime;
                if (t._lastIsFront !== _ && (_ ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = _), 
                _) {
                    t._playEventIndex = this._eventScript(r, a, t._playEventIndex, l > 0 ? n : o, !0);
                    for (var h = 0, c = l - 1; h < c; h++) this._eventScript(r, a, 0, n, !0);
                    l > 0 && o > 0 && (t._playEventIndex = this._eventScript(r, a, 0, o, !0));
                } else {
                    t._playEventIndex = this._eventScript(r, a, t._playEventIndex, l > 0 ? 0 : o, !1);
                    var d = a.length - 1;
                    for (h = 0, c = l - 1; h < c; h++) this._eventScript(r, a, d, 0, !1);
                    l > 0 && o > 0 && (t._playEventIndex = this._eventScript(r, a, d, o, !1));
                }
            }
        }
        _updateClipDatas(e, t, r, i) {
            var a = e._clip, n = a._duration, s = e.clipStart * n + r._normalizedPlayTime * r._duration, o = e._currentFrameIndices, l = r._elapsedTime > r._lastElapsedTime;
            a._evaluateClipDatasRealTime(a._nodes, s, o, t, l, e._realtimeDatas);
        }
        _applyFloat(e, t, r, i, a, n, s) {
            if (r.updateMark === this._updateMark) if (i) e[t] += a * s; else {
                var o = e[t];
                e[t] = o + a * (s - o);
            } else if (n) e[t] = i ? r.defaultValue + s : s; else if (i) e[t] = r.defaultValue + a * s; else {
                var l = r.defaultValue;
                e[t] = l + a * (s - l);
            }
        }
        _applyPositionAndRotationEuler(e, t, r, i, a, n) {
            if (e.updateMark === this._updateMark) if (t) n.x += r * a.x, n.y += r * a.y, n.z += r * a.z; else {
                var s = n.x, o = n.y, l = n.z;
                n.x = s + r * (a.x - s), n.y = o + r * (a.y - o), n.z = l + r * (a.z - l);
            } else if (i) if (t) {
                var _ = e.defaultValue;
                n.x = _.x + a.x, n.y = _.y + a.y, n.z = _.z + a.z;
            } else n.x = a.x, n.y = a.y, n.z = a.z; else if (_ = e.defaultValue, t) n.x = _.x + r * a.x, 
            n.y = _.y + r * a.y, n.z = _.z + r * a.z; else {
                var h = _.x, c = _.y, d = _.z;
                n.x = h + r * (a.x - h), n.y = c + r * (a.y - c), n.z = d + r * (a.z - d);
            }
        }
        _applyRotation(e, t, r, i, a, n) {
            if (e.updateMark === this._updateMark) if (t) {
                var s = P._tempQuaternion1;
                I.quaternionWeight(a, r, s), s.normalize(s), f.multiply(n, s, n);
            } else f.lerp(n, a, r, n); else if (i) if (t) {
                var o = e.defaultValue;
                f.multiply(o, a, n);
            } else n.x = a.x, n.y = a.y, n.z = a.z, n.w = a.w; else o = e.defaultValue, t ? (s = P._tempQuaternion1, 
            I.quaternionWeight(a, r, s), s.normalize(s), f.multiply(o, s, n)) : f.lerp(o, a, r, n);
        }
        _applyScale(e, t, r, i, a, n) {
            if (e.updateMark === this._updateMark) if (t) {
                var s = P._tempVector31;
                I.scaleWeight(a, r, s), n.x = n.x * s.x, n.y = n.y * s.y, n.z = n.z * s.z;
            } else I.scaleBlend(n, a, r, n); else if (i) if (t) {
                var o = e.defaultValue;
                n.x = o.x * a.x, n.y = o.y * a.y, n.z = o.z * a.z;
            } else n.x = a.x, n.y = a.y, n.z = a.z; else o = e.defaultValue, t ? (s = P._tempVector31, 
            I.scaleWeight(a, r, s), n.x = o.x * s.x, n.y = o.y * s.y, n.z = o.z * s.z) : I.scaleBlend(o, a, r, n);
        }
        _applyCrossData(e, t, r, i, a, n, s) {
            var o = e.propertyOwner;
            if (o) {
                switch (e.type) {
                  case 0:
                    for (var l = e.property, _ = l.length - 1, h = 0; h < _ && (o = o[l[h]]); h++) ;
                    var c = a + s * (n - a);
                    e.value = c, this._applyFloat(o, l[_], e, t, r, i, c);
                    break;

                  case 1:
                    var d = o.localPosition, u = e.value, m = a.x, E = a.y, T = a.z;
                    u.x = m + s * (n.x - m), u.y = E + s * (n.y - E), u.z = T + s * (n.z - T), this._applyPositionAndRotationEuler(e, t, r, i, u, d), 
                    o.localPosition = d;
                    break;

                  case 2:
                    var p = o.localRotation, g = e.value;
                    f.lerp(a, n, s, g), this._applyRotation(e, t, r, i, g, p), o.localRotation = p;
                    break;

                  case 3:
                    var S = o.localScale, R = e.value;
                    I.scaleBlend(a, n, s, R), this._applyScale(e, t, r, i, R, S), o.localScale = S;
                    break;

                  case 4:
                    var v = o.localRotationEuler, x = e.value;
                    m = a.x, E = a.y, T = a.z, x.x = m + s * (n.x - m), x.y = E + s * (n.y - E), x.z = T + s * (n.z - T), 
                    this._applyPositionAndRotationEuler(e, t, r, i, x, v), o.localRotationEuler = v;
                }
                e.updateMark = this._updateMark;
            }
        }
        _setClipDatasToNode(e, t, r, i) {
            for (var a = e._realtimeDatas, n = e._clip._nodes, s = e._nodeOwners, o = 0, l = n.count; o < l; o++) {
                var _ = s[o];
                if (_) {
                    var h = _.propertyOwner;
                    if (h) {
                        switch (_.type) {
                          case 0:
                            for (var c = _.property, d = c.length - 1, u = 0; u < d && (h = h[c[u]]); u++) ;
                            this._applyFloat(h, c[d], _, t, r, i, a[o]);
                            break;

                          case 1:
                            var m = h.localPosition;
                            this._applyPositionAndRotationEuler(_, t, r, i, a[o], m), h.localPosition = m;
                            break;

                          case 2:
                            var f = h.localRotation;
                            this._applyRotation(_, t, r, i, a[o], f), h.localRotation = f;
                            break;

                          case 3:
                            var E = h.localScale;
                            this._applyScale(_, t, r, i, a[o], E), h.localScale = E;
                            break;

                          case 4:
                            var T = h.localRotationEuler;
                            this._applyPositionAndRotationEuler(_, t, r, i, a[o], T), h.localRotationEuler = T;
                        }
                        _.updateMark = this._updateMark;
                    }
                }
            }
        }
        _setCrossClipDatasToNode(e, t, r, i, a) {
            for (var n = e._crossNodesOwners, s = e._crossNodesOwnersCount, o = e.blendingMode !== C.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, _ = r._realtimeDatas, h = e._destCrossClipNodeIndices, c = r._nodeOwners, d = t._realtimeDatas, u = e._srcCrossClipNodeIndices, m = t._nodeOwners, f = 0; f < s; f++) {
                var E = n[f];
                if (E) {
                    var T = u[f], p = h[f], g = -1 !== T ? d[T] : c[p].defaultValue, S = -1 !== p ? _[p] : m[T].defaultValue;
                    this._applyCrossData(E, o, l, a, g, S, i);
                }
            }
        }
        _setFixedCrossClipDatasToNode(e, t, r, i) {
            for (var a = e._crossNodesOwners, n = e._crossNodesOwnersCount, s = e.blendingMode !== C.BLENDINGMODE_OVERRIDE, o = e.defaultWeight, l = t._realtimeDatas, _ = e._destCrossClipNodeIndices, h = 0; h < n; h++) {
                var c = a[h];
                if (c) {
                    var d = _[h], u = c.crossFixedValue, m = -1 !== d ? l[d] : c.defaultValue;
                    this._applyCrossData(c, s, o, i, u, m, r);
                }
            }
        }
        _revertDefaultKeyframeNodes(e) {
            for (var t = e._nodeOwners, r = 0, i = t.length; r < i; r++) {
                var a = t[r];
                if (a) {
                    var n = a.propertyOwner;
                    if (n) switch (a.type) {
                      case 0:
                        for (var s = a.property, o = s.length - 1, l = 0; l < o && (n = n[s[l]]); l++) ;
                        n[s[o]] = a.defaultValue;
                        break;

                      case 1:
                        var _ = n.localPosition, h = a.defaultValue;
                        _.x = h.x, _.y = h.y, _.z = h.z, n.localPosition = _;
                        break;

                      case 2:
                        var c = n.localRotation, d = a.defaultValue;
                        c.x = d.x, c.y = d.y, c.z = d.z, c.w = d.w, n.localRotation = c;
                        break;

                      case 3:
                        var u = n.localScale;
                        h = a.defaultValue, u.x = h.x, u.y = h.y, u.z = h.z, n.localScale = u;
                        break;

                      case 4:
                        var m = n.localRotationEuler;
                        h = a.defaultValue, m.x = h.x, m.y = h.y, m.z = h.z, n.localRotationEuler = m;
                        break;

                      default:
                        throw "Animator:unknown type.";
                    }
                }
            }
        }
        _onAdded() {
            var e = this.owner._parent;
            this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
        }
        _onDestroy() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) this._controllerLayers[e]._removeReference();
            var r = this.owner._parent;
            this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null);
        }
        _onEnable() {
            this.owner._scene._animatorPool.add(this);
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
            }
        }
        _onDisable() {
            this.owner._scene._animatorPool.remove(this);
        }
        _handleSpriteOwnersBySprite(e, t, r) {
            for (var i = 0, a = this._controllerLayers.length; i < a; i++) for (var n = this._controllerLayers[i]._states, s = 0, o = n.length; s < o; s++) {
                var l = n[s], _ = l._clip, h = t.join("/"), c = _._nodesMap[h];
                if (c) for (var d = l._nodeOwners, u = 0, m = c.length; u < m; u++) e ? this._addKeyframeNodeOwner(d, c[u], r) : this._removeKeyframeNodeOwner(d, c[u]);
            }
        }
        _parse(e) {
            var r = e.avatar;
            if (r) {
                this.avatar = t.Loader.getRes(r.path);
                var i = r.linkSprites;
                this._linkSprites = i, this._linkToSprites(i);
            }
            e.clipPaths;
            for (var a = e.playOnWake, n = e.layers, s = 0; s < n.length; s++) {
                var o = n[s], l = new C(o.name);
                l.defaultWeight = 0 === s ? 1 : o.weight;
                var _ = o.blendingMode;
                _ && (l.blendingMode = _), this.addControllerLayer(l);
                for (var h = o.states, c = 0, d = h.length; c < d; c++) {
                    var u = h[c], m = u.clipPath;
                    if (m) {
                        var f, E = u.name;
                        if (f = t.Loader.getRes(m)) {
                            var T = new N();
                            T.name = E, T.clip = f, l.addState(T), 0 === c && (this.getControllerLayer(s).defaultState = T);
                        }
                    }
                }
                void 0 !== a && (l.playOnWake = a);
            }
            var p = e.cullingMode;
            void 0 !== p && (this.cullingMode = p);
        }
        _update() {
            var e = this.owner._scene.timer, r = e._delta / 1e3;
            if (0 !== this._speed && 0 !== r) {
                var i;
                if (this.cullingMode === P.CULLINGMODE_CULLCOMPLETELY) {
                    i = !1;
                    for (var a = 0, n = this._renderableSprites.length; a < n; a++) if (this._renderableSprites[a]._render.isRender) {
                        i = !0;
                        break;
                    }
                } else i = !0;
                this._updateMark++;
                var s = e.scale;
                for (a = 0, n = this._controllerLayers.length; a < n; a++) {
                    var o = this._controllerLayers[a], l = o._playStateInfo, _ = o._crossPlayStateInfo;
                    switch (m = o.blendingMode !== C.BLENDINGMODE_OVERRIDE, o._playType) {
                      case 0:
                        var h = l._currentState, c = h._clip, d = this._speed * h.speed, u = l._finish;
                        if (u || this._updatePlayer(h, l, r * d, c.islooping), i) {
                            var m = o.blendingMode !== C.BLENDINGMODE_OVERRIDE;
                            this._updateClipDatas(h, m, l, s * d), this._setClipDatasToNode(h, m, o.defaultWeight, 0 === a), 
                            u || this._updateEventScript(h, l);
                        }
                        break;

                      case 1:
                        c = (h = l._currentState)._clip;
                        var f = o._crossPlayState, E = f._clip, T = o._crossDuration, p = _._startPlayTime, g = E._duration - p, S = T > g ? g / T : 1, R = this._speed * f.speed;
                        this._updatePlayer(f, _, r * S * R, E.islooping);
                        var v = (_._elapsedTime - p) / S / T;
                        v >= 1 ? i && (this._updateClipDatas(f, m, _, s * R), this._setClipDatasToNode(f, m, o.defaultWeight, 0 === a), 
                        o._playType = 0, l._currentState = f, _._cloneTo(l)) : (l._finish || (d = this._speed * h.speed, 
                        this._updatePlayer(h, l, r * d, c.islooping), i && this._updateClipDatas(h, m, l, s * d)), 
                        i && (this._updateClipDatas(f, m, _, s * S * R), this._setCrossClipDatasToNode(o, h, f, v, 0 === a))), 
                        i && (this._updateEventScript(h, l), this._updateEventScript(f, _));
                        break;

                      case 2:
                        E = (f = o._crossPlayState)._clip, T = o._crossDuration, p = _._startPlayTime, S = T > (g = E._duration - p) ? g / T : 1, 
                        R = this._speed * f.speed, this._updatePlayer(f, _, r * S * R, E.islooping), i && ((v = (_._elapsedTime - p) / S / T) >= 1 ? (this._updateClipDatas(f, m, _, s * R), 
                        this._setClipDatasToNode(f, m, 1, 0 === a), o._playType = 0, l._currentState = f, 
                        _._cloneTo(l)) : (this._updateClipDatas(f, m, _, s * S * R), this._setFixedCrossClipDatasToNode(o, f, v, 0 === a)), 
                        this._updateEventScript(f, _));
                    }
                }
                i && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices), 
                this._updateAvatarNodesToSprite());
            }
        }
        _cloneTo(e) {
            var t = e;
            t.avatar = this.avatar, t.cullingMode = this.cullingMode;
            for (var r = 0, i = this._controllerLayers.length; r < i; r++) {
                var a = this._controllerLayers[r];
                t.addControllerLayer(a.clone());
                for (var n = a._states, s = 0, o = n.length; s < o; s++) {
                    var l = n[s].clone(), _ = t.getControllerLayer(r);
                    _.addState(l), 0 == s && (_.defaultState = l);
                }
            }
            t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
        }
        getDefaultState(e = 0) {
            return this._controllerLayers[e].defaultState;
        }
        addState(e, t = 0) {
            this._controllerLayers[t].addState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
        }
        removeState(e, t = 0) {
            this._controllerLayers[t].removeState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
        }
        addControllerLayer(e) {
            this._controllerLayers.push(e), e._animator = this, e._addReference();
            for (var t = e._states, r = 0, i = t.length; r < i; r++) this._getOwnersByClip(t[r]);
        }
        getControllerLayer(e = 0) {
            return this._controllerLayers[e];
        }
        play(e = null, t = 0, r = Number.NEGATIVE_INFINITY) {
            var i = this._controllerLayers[t];
            if (i) {
                var a = i.defaultState;
                if (!e && !a) throw new Error("Animator:must have default clip value,please set clip property.");
                var n = i._playStateInfo, s = n._currentState, o = e ? i._statesMap[e] : a, l = o._clip._duration;
                s !== o ? (r !== Number.NEGATIVE_INFINITY ? n._resetPlayState(l * r) : n._resetPlayState(0), 
                null !== s && s !== o && this._revertDefaultKeyframeNodes(s), i._playType = 0, n._currentState = o) : r !== Number.NEGATIVE_INFINITY && (n._resetPlayState(l * r), 
                i._playType = 0);
                var _ = o._scripts;
                if (_) for (var h = 0, c = _.length; h < c; h++) _[h].onStateEnter();
            } else console.warn("Invalid layerIndex " + t + ".");
        }
        crossFade(e, t, r = 0, i = Number.NEGATIVE_INFINITY) {
            var a = this._controllerLayers[r];
            if (a) {
                var n = a._statesMap[e];
                if (n) {
                    var s = a._playType;
                    if (-1 === s) return void this.play(e, r, i);
                    var o = a._crossPlayStateInfo, l = a._crossNodesOwners, _ = a._crossNodesOwnersIndicesMap, h = a._playStateInfo._currentState, c = n._nodeOwners, d = a._destCrossClipNodeIndices, u = n._clip, m = u._nodes, f = u._nodesDic;
                    switch (s) {
                      case 0:
                        var E = h._nodeOwners, T = a._srcCrossClipNodeIndices, p = h._clip, g = p._nodes, S = p._nodesDic;
                        a._playType = 1;
                        for (var R = ++a._crossMark, v = a._crossNodesOwnersCount = 0, x = 0, I = g.count; x < I; x++) {
                            var A = g.getNodeByIndex(x), L = A._indexInList, C = E[L];
                            if (C) {
                                var D = A.fullPath;
                                T[v] = L;
                                var M = f[D];
                                d[v] = M ? M._indexInList : -1, _[D] = R, l[v] = C, v++;
                            }
                        }
                        for (x = 0, I = m.count; x < I; x++) {
                            var y = (M = m.getNodeByIndex(x))._indexInList, O = c[y];
                            if (O) {
                                var N = M.fullPath;
                                S[N] || (T[v] = -1, d[v] = y, _[N] = R, l[v] = O, v++);
                            }
                        }
                        break;

                      case 1:
                      case 2:
                        for (a._playType = 2, x = 0, I = l.length; x < I; x++) {
                            var b = l[x];
                            b.saveCrossFixedValue(), M = f[b.fullPath], d[x] = M ? M._indexInList : -1;
                        }
                        for (v = a._crossNodesOwnersCount, R = a._crossMark, x = 0, I = m.count; x < I; x++) (O = c[y = (M = m.getNodeByIndex(x))._indexInList]) && _[N = M.fullPath] !== R && (d[v] = y, 
                        _[N] = R, b = c[y], l[v] = b, b.saveCrossFixedValue(), v++);
                    }
                    a._crossNodesOwnersCount = v, a._crossPlayState = n, a._crossDuration = h._clip._duration * t, 
                    i !== Number.NEGATIVE_INFINITY ? o._resetPlayState(u._duration * i) : o._resetPlayState(0);
                    var P = n._scripts;
                    if (P) for (x = 0, I = P.length; x < I; x++) P[x].onStateEnter();
                } else console.warn("Invalid name " + r + ".");
            } else console.warn("Invalid layerIndex " + r + ".");
        }
        getCurrentAnimatorPlayState(e = 0) {
            return this._controllerLayers[e]._playStateInfo;
        }
        get avatar() {
            return this._avatar;
        }
        set avatar(e) {
            if (this._avatar !== e) if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(), 
            this.owner._changeHierarchyAnimatorAvatar(this, e); else {
                var t = this.owner._parent;
                this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
            }
        }
        _isLinkSpriteToAnimationNodeData(e, t, r) {
            var i = this._linkAvatarSpritesData[t];
            if (r) i || (this._linkAvatarSpritesData[t] = i = []), i.push(e); else {
                var a = i.indexOf(e);
                i.splice(a, 1);
            }
        }
        _getAvatarOwnersAndInitDatasAsync() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) for (var r = this._controllerLayers[e]._states, i = 0, a = r.length; i < a; i++) this._getOwnersByClip(r[i]);
            for (var n in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                var s = this._linkAvatarSpritesData[n];
                if (s) for (var o = 0, l = s.length; o < l; o++) this._isLinkSpriteToAnimationNode(s[o], n, !0);
            }
        }
        _isLinkSpriteToAnimationNode(e, t, r) {
            if (this._avatar) {
                var i = this._avatarNodeMap[t];
                if (i) if (r) {
                    e._transform._dummy = i.transform, this._linkAvatarSprites.push(e);
                    var a = i.transform, n = e.transform;
                    if (!n.owner.isStatic && a) {
                        var s = n.worldMatrix, o = this.owner._transform._parent;
                        if (o) I.matrix4x4MultiplyMFM(o.worldMatrix, a.getWorldMatrix(), s); else for (var l = s.elements, _ = a.getWorldMatrix(), h = 0; h < 16; h++) l[h] = _[h];
                        n.worldMatrix = s;
                    }
                } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
            }
        }
        _updateAvatarNodesToSprite() {
            for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                var r = this._linkAvatarSprites[e], i = r.transform._dummy, a = r.transform;
                if (!a.owner.isStatic && i) {
                    var n = a.worldMatrix, s = this.owner._transform;
                    I.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), n), a.worldMatrix = n;
                }
            }
        }
        linkSprite3DToAvatarNode(e, t) {
            return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), 
            !0;
        }
        unLinkSprite3DToAvatarNode(e) {
            var t = e.transform._dummy;
            if (t) {
                var r = t._owner.name;
                return this._isLinkSpriteToAnimationNodeData(e, r, !1), this._isLinkSpriteToAnimationNode(e, r, !1), 
                !0;
            }
            return !1;
        }
        _updateAnimationNodeWorldMatix(e, r, i, a, n) {
            t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, i, n, a);
        }
    }
    P._tempVector30 = new n(), P._tempVector31 = new n(), P._tempQuaternion0 = new f(), 
    P._tempQuaternion1 = new f(), P.CULLINGMODE_ALWAYSANIMATE = 0, P.CULLINGMODE_CULLCOMPLETELY = 2;
    class w {
        constructor() {
            this.source = null, this.destination = null, this.camera = null, this.compositeShaderData = null, 
            this.command = null, this.deferredReleaseTextures = [];
        }
    }
    class V {
        constructor() {
            this.invertY = !1;
        }
    }
    V._instance = new V();
    class B extends t.BaseTexture {
        constructor(e, r, i = t.RenderTextureFormat.R8G8B8, a = t.RenderTextureDepthFormat.DEPTH_16) {
            super(i, !1), this._inPool = !1, this._isCameraTarget = !1, this._glTextureType = t.LayaGL.instance.TEXTURE_2D, 
            this._width = e, this._height = r, this._depthStencilFormat = a, this._mipmapCount = 1, 
            this._create(e, r);
        }
        static get currentActive() {
            return B._currentActive;
        }
        static createFromPool(e, r, i = t.RenderTextureFormat.R8G8B8, a = t.RenderTextureDepthFormat.DEPTH_16) {
            for (var n, s = 0, o = B._pool.length; s < o; s++) if ((n = B._pool[s])._width == e && n._height == r && n._format == i && n._depthStencilFormat == a) {
                n._inPool = !1;
                var l = B._pool[o - 1];
                return B._pool[s] = l, B._pool.length -= 1, n;
            }
            return (n = new B(e, r, i, a)).lock = !0, n;
        }
        static recoverToPool(e) {
            e._inPool || (B._pool.push(e), e._inPool = !0);
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaulteTexture() {
            return t.Texture2D.grayTexture;
        }
        _create(e, r) {
            var i = t.LayaGL.instance, a = i, n = this._glTextureType, s = t.LayaGL.layaGPUInstance, o = s._isWebGL2, l = this._format;
            if (this._frameBuffer = i.createFramebuffer(), i.bindFramebuffer(i.FRAMEBUFFER, this._frameBuffer), 
            l !== t.RenderTextureFormat.Depth && l !== t.RenderTextureFormat.ShadowMap) {
                switch (t.WebGLContext.bindTexture(i, n, this._glTexture), l) {
                  case t.RenderTextureFormat.R8G8B8:
                    o ? a.texStorage2D(n, this._mipmapCount, a.RGB8, e, r) : i.texImage2D(n, 0, i.RGB, e, r, 0, i.RGB, i.UNSIGNED_BYTE, null);
                    break;

                  case t.RenderTextureFormat.R8G8B8A8:
                    o ? a.texStorage2D(n, this._mipmapCount, a.RGBA8, e, r) : i.texImage2D(n, 0, i.RGBA, e, r, 0, i.RGBA, i.UNSIGNED_BYTE, null);
                    break;

                  case t.RenderTextureFormat.Alpha8:
                    o ? a.texStorage2D(n, 0, a.R8, e, r) : i.texImage2D(n, 0, i.ALPHA, e, r, 0, i.ALPHA, i.UNSIGNED_BYTE, null);
                    break;

                  case t.RenderTextureFormat.R16G16B16A16:
                    o ? a.texStorage2D(n, this._mipmapCount, a.RGBA16F, e, r) : i.texImage2D(n, 0, i.RGBA, e, r, 0, i.RGBA, s._oesTextureHalfFloat.HALF_FLOAT_OES, null);
                }
                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, this._glTexture, 0);
            }
            if (l == t.RenderTextureFormat.Depth || l == t.RenderTextureFormat.ShadowMap) {
                switch (t.WebGLContext.bindTexture(i, n, this._glTexture), this._depthStencilFormat) {
                  case t.RenderTextureDepthFormat.DEPTH_16:
                    o ? a.texStorage2D(n, this._mipmapCount, a.DEPTH_COMPONENT16, e, r) : i.texImage2D(n, 0, i.DEPTH_COMPONENT, e, r, 0, i.DEPTH_COMPONENT, i.UNSIGNED_SHORT, null), 
                    i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, this._glTexture, 0);
                    break;

                  case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                    o ? a.texStorage2D(n, this._mipmapCount, a.DEPTH24_STENCIL8, e, r) : i.texImage2D(n, 0, i.DEPTH_STENCIL, e, r, 0, i.DEPTH_STENCIL, s._webgl_depth_texture.UNSIGNED_INT_24_8_WEBGL, null), 
                    i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, this._glTexture, 0);
                    break;

                  default:
                    throw "RenderTexture: depth format RenderTexture must use depthFormat with DEPTH_16 and DEPTHSTENCIL_16_8.";
                }
                o && l == t.RenderTextureFormat.ShadowMap && a.texParameteri(n, a.TEXTURE_COMPARE_MODE, a.COMPARE_REF_TO_TEXTURE);
            } else if (this._depthStencilFormat !== t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE) {
                switch (this._depthStencilBuffer = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, this._depthStencilBuffer), 
                this._depthStencilFormat) {
                  case t.RenderTextureDepthFormat.DEPTH_16:
                    i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT16, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                  case t.RenderTextureDepthFormat.STENCIL_8:
                    i.renderbufferStorage(i.RENDERBUFFER, i.STENCIL_INDEX8, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                  case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                    i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                  default:
                    throw "RenderTexture: unkonw depth format.";
                }
                i.bindRenderbuffer(i.RENDERBUFFER, null);
            }
            i.bindFramebuffer(i.FRAMEBUFFER, null), this._setWarpMode(i.TEXTURE_WRAP_S, this._wrapModeU), 
            this._setWarpMode(i.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode), 
            this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource(), 
            this._setGPUMemory(e * r * 4);
        }
        _start() {
            var e = t.LayaGL.instance;
            e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), B._currentActive = this, this._isCameraTarget && (V._instance.invertY = !0), 
            this._readyed = !1;
        }
        _end() {
            var e = t.LayaGL.instance;
            e.bindFramebuffer(e.FRAMEBUFFER, null), B._currentActive = null, this._isCameraTarget && (V._instance.invertY = !1), 
            this._readyed = !0;
        }
        getData(e, r, i, a, n) {
            if (t.Render.isConchApp && 2 == window.conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
            var s = t.LayaGL.instance;
            return s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.checkFramebufferStatus(s.FRAMEBUFFER) === s.FRAMEBUFFER_COMPLETE ? (s.readPixels(e, r, i, a, s.RGBA, s.UNSIGNED_BYTE, n), 
            s.bindFramebuffer(s.FRAMEBUFFER, null), n) : (s.bindFramebuffer(s.FRAMEBUFFER, null), 
            null);
        }
        _disposeResource() {
            if (this._frameBuffer) {
                var e = t.LayaGL.instance;
                e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer), 
                this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null, 
                this._setGPUMemory(0);
            }
        }
        getDataAsync(e, r, i, a, n) {
            var s = t.LayaGL.instance;
            s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.readPixelsAsync(e, r, i, a, s.RGBA, s.UNSIGNED_BYTE, function(e) {
                n(new Uint8Array(e));
            }), s.bindFramebuffer(s.FRAMEBUFFER, null);
        }
    }
    B._pool = [];
    class F {
        constructor() {
            this._mask = [], this._length = 0;
        }
        _intersectionDefineDatas(e) {
            for (var t = e._mask, r = this._mask, i = this._length - 1; i >= 0; i--) {
                var a = r[i] & t[i];
                0 == a && i == this._length - 1 ? this._length-- : r[i] = a;
            }
        }
        add(e) {
            var t = e._index, r = t + 1, i = this._mask, a = this._length;
            if (a < r) {
                for (i.length < r && (i.length = r); a < t; a++) i[a] = 0;
                i[t] = e._value, this._length = r;
            } else r > this._length ? (i[t] = e._value, this._length = r) : i[t] |= e._value;
        }
        remove(e) {
            var t = e._index, r = this._mask, i = this._length - 1;
            if (!(t > i)) {
                var a = r[t] & ~e._value;
                t == i && 0 === a ? this._length-- : r[t] = a;
            }
        }
        addDefineDatas(e) {
            var t = e._mask, r = e._length, i = this._mask, a = i.length;
            if (a < r) {
                i.length = r;
                for (var n = 0; n < a; n++) i[n] |= t[n];
                for (;a < r; a++) i[a] = t[a];
                this._length = r;
            } else {
                for (n = 0; n < r; n++) i[n] |= t[n];
                this._length = Math.max(this._length, r);
            }
        }
        removeDefineDatas(e) {
            for (var t = e._mask, r = this._mask, i = this._length - 1, a = e._length - 1; a >= 0; a--) if (!(a > i)) {
                var n = r[a] & ~t[a];
                a == i && 0 === n ? (i--, this._length--) : r[a] = n;
            }
        }
        has(e) {
            var t = e._index;
            return !(t >= this._length) && 0 != (this._mask[t] & e._value);
        }
        clear() {
            this._length = 0;
        }
        cloneTo(e) {
            var t = e, r = t._mask, i = this._mask, a = this._length;
            r.length = a;
            for (var n = 0; n < a; n++) r[n] = i[n];
            t._length = a;
        }
        clone() {
            var e = new F();
            return this.cloneTo(e), e;
        }
    }
    class U {
        constructor(e, t) {
            this._index = e, this._value = t;
        }
    }
    class G {
        constructor(e, t, r, i) {
            this._subShaderIndex = 0, this._passIndex = 0, this.setValue(e, t, r, i);
        }
        get shader() {
            return this._shader;
        }
        get subShaderIndex() {
            return this._subShaderIndex;
        }
        get passIndex() {
            return this._passIndex;
        }
        get defineNames() {
            return this._defineNames;
        }
        setValue(e, t, r, i) {
            if (!e) throw "ShaderVariantInfo:Shader can't be null.";
            var a = e.getSubShaderAt(t);
            if (!a) throw `ShaderVariantInfo:Shader don't have subShaderIndex of ${t}.`;
            var n = a._passes[r];
            if (!n) throw `ShaderVariantInfo:Shader don't have passIndex of ${r}.`;
            for (var s = n._validDefine, o = 0, l = i.length; o < l; o++) {
                var h = i[o];
                if (!s.has(_.Shader3D.getDefineByName(h))) throw `ShaderVariantInfo:Invalid defineName ${h} in ${e._name} subShaderIndex of ${t} passIndex of ${r}.`;
            }
            this._shader = e, this._subShaderIndex = t, this._passIndex = r, this._defineNames = i;
        }
        equal(e) {
            if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex || this._passIndex !== e._passIndex) return !1;
            var t = this._defineNames, r = e._defineNames;
            if (t.length !== r.length) return !1;
            for (var i = 0, a = this._defineNames.length; i < a; i++) if (t[i] !== r[i]) return !1;
            return !0;
        }
        clone() {
            return new G(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
        }
    }
    class z {
        constructor() {
            this._allCompiled = !1, this._variants = [];
        }
        get allCompiled() {
            return this._allCompiled;
        }
        get variantCount() {
            return this._variants.length;
        }
        add(e) {
            for (var t = 0, r = this._variants.length; t < r; t++) if (this._variants[t].equal(e)) return !1;
            return this._variants.push(e.clone()), this._allCompiled = !1, !0;
        }
        remove(e) {
            for (var t = 0, r = this._variants.length; t < r; t++) if (this._variants[t].equal(e)) return this._variants.splice(t, 1), 
            !0;
            return !1;
        }
        contatins(e) {
            for (var t = 0, r = this._variants.length; t < r; t++) if (this._variants[t].equal(e)) return !0;
            return !1;
        }
        getByIndex(e) {
            return this._variants[e];
        }
        clear() {
            this._variants.length = 0;
        }
        compile() {
            if (!this._allCompiled) {
                for (var e = this._variants, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    _.Shader3D.compileShaderByDefineNames(i._shader._name, i._subShaderIndex, i._passIndex, i._defineNames);
                }
                this._allCompiled = !0;
            }
        }
    }
    class H {
        constructor(e, t, r, i) {
            this._attributeMap = null, this._uniformMap = null, this._enableInstancing = !1, 
            this._subShaders = [], this._name = e, this._attributeMap = t, this._uniformMap = r, 
            this._enableInstancing = i;
        }
        static _getNamesByDefineData(e, t) {
            var r = H._maskMap, i = e._mask;
            t.length = 0;
            for (var a = 0, n = e._length; a < n; a++) for (var s = r[a], o = i[a], l = 0; l < 32; l++) {
                var _ = 1 << l;
                if (o > 0 && _ > o) break;
                o & _ && t.push(s[_]);
            }
        }
        static getDefineByName(e) {
            var t = H._defineMap[e];
            if (!t) {
                var r = H._maskMap, i = H._defineCounter, a = Math.floor(i / 32), n = 1 << i % 32;
                t = new U(a, n), H._defineMap[e] = t, a == r.length && (r.length++, r[a] = {}), 
                r[a][n] = e, H._defineCounter++;
            }
            return t;
        }
        static propertyNameToID(e) {
            if (null != H._propertyNameMap[e]) return H._propertyNameMap[e];
            var t = H._propertyNameCounter++;
            return H._propertyNameMap[e] = t, t;
        }
        static addInclude(e, r) {
            r = r.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, r);
        }
        static compileShaderByDefineNames(e, t, r, i) {
            var a = H.find(e);
            if (a) {
                var n = a.getSubShaderAt(t);
                if (n) {
                    var s = n._passes[r];
                    if (s) {
                        var o = H._compileDefineDatas;
                        o.clear();
                        for (var l = 0, _ = i.length; l < _; l++) o.add(H.getDefineByName(i[l]));
                        s.withCompile(o);
                    } else console.warn("Shader3D: unknown passIndex.");
                } else console.warn("Shader3D: unknown subShaderIndex.");
            } else console.warn("Shader3D: unknown shader name.");
        }
        static add(e, t = null, r = null, i = !1) {
            return H._preCompileShader[e] = new H(e, t, r, i);
        }
        static find(e) {
            return H._preCompileShader[e];
        }
        get name() {
            return this._name;
        }
        addSubShader(e) {
            this._subShaders.push(e), e._owner = this;
        }
        getSubShaderAt(e) {
            return this._subShaders[e];
        }
        static compileShader(e, t, r, ...i) {
            var a = H.find(e);
            if (a) {
                var n = a.getSubShaderAt(t);
                if (n) {
                    var s = n._passes[r];
                    if (s) {
                        var o = H._compileDefineDatas, l = o._mask;
                        l.length = 0;
                        for (var _ = 0, h = i.length; _ < h; _++) l.push(i[_]);
                        o._length = i.length, s.withCompile(o);
                    } else console.warn("Shader3D: unknown passIndex.");
                } else console.warn("Shader3D: unknown subShaderIndex.");
            } else console.warn("Shader3D: unknown shader name.");
        }
    }
    H._compileDefineDatas = new F(), H.RENDER_STATE_CULL = 0, H.RENDER_STATE_BLEND = 1, 
    H.RENDER_STATE_BLEND_SRC = 2, H.RENDER_STATE_BLEND_DST = 3, H.RENDER_STATE_BLEND_SRC_RGB = 4, 
    H.RENDER_STATE_BLEND_DST_RGB = 5, H.RENDER_STATE_BLEND_SRC_ALPHA = 6, H.RENDER_STATE_BLEND_DST_ALPHA = 7, 
    H.RENDER_STATE_BLEND_CONST_COLOR = 8, H.RENDER_STATE_BLEND_EQUATION = 9, H.RENDER_STATE_BLEND_EQUATION_RGB = 10, 
    H.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, H.RENDER_STATE_DEPTH_TEST = 12, H.RENDER_STATE_DEPTH_WRITE = 13, 
    H.PERIOD_CUSTOM = 0, H.PERIOD_MATERIAL = 1, H.PERIOD_SPRITE = 2, H.PERIOD_CAMERA = 3, 
    H.PERIOD_SCENE = 4, H._propertyNameCounter = 0, H._propertyNameMap = {}, H._defineCounter = 0, 
    H._defineMap = {}, H._preCompileShader = {}, H._maskMap = [], H.debugMode = !1, 
    H.debugShaderVariantCollection = new z();
    class W {
        constructor(e = null) {
            this._ownerResource = null, this._data = null, this._defineDatas = new F(), this._runtimeCopyValues = [], 
            this._ownerResource = e, this._initData();
        }
        _initData() {
            this._data = new Object();
        }
        getData() {
            return this._data;
        }
        addDefine(e) {
            this._defineDatas.add(e);
        }
        removeDefine(e) {
            this._defineDatas.remove(e);
        }
        hasDefine(e) {
            return this._defineDatas.has(e);
        }
        clearDefine() {
            this._defineDatas.clear();
        }
        getBool(e) {
            return this._data[e];
        }
        setBool(e, t) {
            this._data[e] = t;
        }
        getInt(e) {
            return this._data[e];
        }
        setInt(e, t) {
            this._data[e] = t;
        }
        getNumber(e) {
            return this._data[e];
        }
        setNumber(e, t) {
            this._data[e] = t;
        }
        getVector2(e) {
            return this._data[e];
        }
        setVector2(e, t) {
            this._data[e] = t;
        }
        getVector3(e) {
            return this._data[e];
        }
        setVector3(e, t) {
            this._data[e] = t;
        }
        getVector(e) {
            return this._data[e];
        }
        setVector(e, t) {
            this._data[e] = t;
        }
        getQuaternion(e) {
            return this._data[e];
        }
        setQuaternion(e, t) {
            this._data[e] = t;
        }
        getMatrix4x4(e) {
            return this._data[e];
        }
        setMatrix4x4(e, t) {
            this._data[e] = t;
        }
        getBuffer(e) {
            return this._data[e];
        }
        setBuffer(e, t) {
            this._data[e] = t;
        }
        setTexture(e, t) {
            var r = this._data[e];
            this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(), 
            t && t._addReference());
        }
        getTexture(e) {
            return this._data[e];
        }
        setAttribute(e, t) {
            this._data[e] = t;
        }
        getAttribute(e) {
            return this._data[e];
        }
        getLength() {
            return this._data.length;
        }
        setLength(e) {
            this._data.length = e;
        }
        cloneTo(e) {
            var r = e, s = r._data;
            for (var o in this._data) {
                var l = this._data[o];
                if (null != l) if ("number" == typeof l) s[o] = l; else if ("number" == typeof l) s[o] = l; else if ("boolean" == typeof l) s[o] = l; else if (l instanceof i) {
                    var _ = s[o] || (s[o] = new i());
                    l.cloneTo(_), s[o] = _;
                } else if (l instanceof n) {
                    var h = s[o] || (s[o] = new n());
                    l.cloneTo(h), s[o] = h;
                } else if (l instanceof a) {
                    var c = s[o] || (s[o] = new a());
                    l.cloneTo(c), s[o] = c;
                } else if (l instanceof y) {
                    var d = s[o] || (s[o] = new y());
                    l.cloneTo(d), s[o] = d;
                } else l instanceof t.BaseTexture && (s[o] = l);
            }
            this._defineDatas.cloneTo(r._defineDatas);
        }
        clone() {
            var e = new W();
            return this.cloneTo(e), e;
        }
        cloneToForNative(e) {
            var r = e;
            this._int32Data.length - r._int32Data.length > 0 && r.needRenewArrayBufferForNative(this._int32Data.length), 
            r._int32Data.set(this._int32Data, 0);
            var s = r._nativeArray, o = this._nativeArray.length;
            s.length = o;
            for (var l = 0; l < o; l++) {
                var _ = this._nativeArray[l];
                if (_) if ("number" == typeof _) s[l] = _, r.setNumber(l, _); else if ("number" == typeof _) s[l] = _, 
                r.setInt(l, _); else if ("boolean" == typeof _) s[l] = _, r.setBool(l, _); else if (_ instanceof i) {
                    var h = s[l] || (s[l] = new i());
                    _.cloneTo(h), s[l] = h, r.setVector2(l, h);
                } else if (_ instanceof n) {
                    var c = s[l] || (s[l] = new n());
                    _.cloneTo(c), s[l] = c, r.setVector3(l, c);
                } else if (_ instanceof a) {
                    var d = s[l] || (s[l] = new a());
                    _.cloneTo(d), s[l] = d, r.setVector(l, d);
                } else if (_ instanceof y) {
                    var u = s[l] || (s[l] = new y());
                    _.cloneTo(u), s[l] = u, r.setMatrix4x4(l, u);
                } else _ instanceof t.BaseTexture && (s[l] = _, r.setTexture(l, _));
            }
            this._defineDatas.cloneTo(r._defineDatas);
        }
        _initDataForNative() {
            this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [], 
            this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data), 
            this._float32Data = new Float32Array(this._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
        }
        needRenewArrayBufferForNative(e) {
            if (e >= this._int32Data.length) {
                var r = 4 * (e + 1), i = this._int32Data, a = this._data.conchRef, n = this._data._ptrID;
                this._data = new ArrayBuffer(r), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data), 
                this._data.conchRef = a, this._data._ptrID = n, i && this._int32Data.set(i, 0);
                var s = t.LayaGL.instance;
                s.updateArrayBufferRef ? s.updateArrayBufferRef(this._data._ptrID, a.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(this._data._ptrID, a.isSyncToRender(), this._data);
            }
        }
        getDataForNative() {
            return this._nativeArray;
        }
        getIntForNative(e) {
            return this._int32Data[e];
        }
        setIntForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
        }
        getBoolForNative(e) {
            return 1 == this._int32Data[e];
        }
        setBoolForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this._nativeArray[e] = t;
        }
        getNumberForNative(e) {
            return this._float32Data[e];
        }
        setNumberForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
        }
        getMatrix4x4ForNative(e) {
            return this._nativeArray[e];
        }
        setMatrix4x4ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVectorForNative(e) {
            return this._nativeArray[e];
        }
        setVectorForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVector2ForNative(e) {
            return this._nativeArray[e];
        }
        setVector2ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVector3ForNative(e) {
            return this._nativeArray[e];
        }
        setVector3ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getQuaternionForNative(e) {
            return this._nativeArray[e];
        }
        setQuaternionForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getBufferForNative(e) {
            return this._nativeArray[e];
        }
        setBufferForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var r = this.setReferenceForNative(t);
            this._int32Data[e] = r;
        }
        getAttributeForNative(e) {
            return this._nativeArray[e];
        }
        setAttributeForNative(e, r) {
            this._nativeArray[e] = r, r._ptrID || t.LayaGL.instance.createArrayBufferRef(r, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0), 
            t.LayaGL.instance.syncBufferToRenderThread(r), this._int32Data[e] = r._ptrID;
        }
        getTextureForNative(e) {
            return this._nativeArray[e];
        }
        setTextureForNative(e, t) {
            if (t) {
                this.needRenewArrayBufferForNative(e);
                var r = this._nativeArray[e];
                this._nativeArray[e] = t;
                var i = t._getSource() || t.defaulteTexture._getSource();
                this._int32Data[e] = i.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(), 
                t && t._addReference());
            }
        }
        setReferenceForNative(e) {
            this.clearRuntimeCopyArray();
            var r = 0, i = 0;
            return W._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE), 
            r = 0, i = e.getPtrID(r)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY), 
            r = e.getRefNum() - 1, i = e.getPtrID(r), this._runtimeCopyValues.push({
                obj: e,
                refID: r,
                ptrID: i
            })), t.LayaGL.instance.syncBufferToRenderThread(e, r), i;
        }
        static setRuntimeValueMode(e) {
            W._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
        }
        clearRuntimeCopyArray() {
            var e = t.Stat.loopCount;
            if (this._frameCount != e) {
                this._frameCount = e;
                for (var r = 0, i = this._runtimeCopyValues.length; r < i; r++) {
                    this._runtimeCopyValues[r].obj.clearRefNum();
                }
                this._runtimeCopyValues.length = 0;
            }
        }
    }
    W._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    class k {
        constructor() {
            this._compositeShader = H.find("PostProcessComposite"), this._compositeShaderData = new W(), 
            this._effects = [], this._context = null, this._context = new w(), this._context.compositeShaderData = this._compositeShaderData;
        }
        static __init__() {
            k.SHADERDEFINE_BLOOM_LOW = H.getDefineByName("BLOOM_LOW"), k.SHADERDEFINE_BLOOM = H.getDefineByName("BLOOM"), 
            k.SHADERDEFINE_FINALPASS = H.getDefineByName("FINALPASS");
        }
        _init(e, t) {
            this._context.camera = e, this._context.command = t;
        }
        _render() {
            var e = W._SET_RUNTIME_VALUE_MODE_REFERENCE_;
            t.ILaya.Render.supportWebGLPlusRendering && W.setRuntimeValueMode(!1);
            var r = this._context.camera, i = r.viewport, a = B.createFromPool(V.clientWidth, V.clientHeight, r._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE), n = r._internalRenderTexture;
            this._context.command.clear(), this._context.source = a, this._context.destination = n, 
            this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(n, a), 
            this._context.compositeShaderData.setTexture(k.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
            for (var s = 0, o = this._effects.length; s < o; s++) this._effects[s].render(this._context);
            this._compositeShaderData.addDefine(k.SHADERDEFINE_FINALPASS);
            var l = r._offScreenRenderTexture, _ = l || null;
            this._context.destination = _;
            var h = r._getCanvasWidth(), c = r._getCanvasHeight();
            r._screenOffsetScale.setValue(i.x / h, i.y / c, i.width / h, i.height / c), this._context.command.blitScreenTriangle(this._context.source, _, r._screenOffsetScale, this._compositeShader, this._compositeShaderData), 
            B.recoverToPool(a);
            var d = this._context.deferredReleaseTextures;
            for (s = 0, o = d.length; s < o; s++) B.recoverToPool(d[s]);
            d.length = 0, t.ILaya.Render.supportWebGLPlusRendering && W.setRuntimeValueMode(e);
        }
        addEffect(e) {
            this._effects.push(e);
        }
        removeEffect(e) {
            var t = this._effects.indexOf(e);
            -1 !== t && this._effects.splice(t, 1);
        }
    }
    k.SHADERVALUE_MAINTEX = H.propertyNameToID("u_MainTex"), k.SHADERVALUE_BLOOMTEX = H.propertyNameToID("u_BloomTex"), 
    k.SHADERVALUE_AUTOEXPOSURETEX = H.propertyNameToID("u_AutoExposureTex"), k.SHADERVALUE_BLOOM_DIRTTEX = H.propertyNameToID("u_Bloom_DirtTex"), 
    k.SHADERVALUE_BLOOMTEX_TEXELSIZE = H.propertyNameToID("u_BloomTex_TexelSize"), k.SHADERVALUE_BLOOM_DIRTTILEOFFSET = H.propertyNameToID("u_Bloom_DirtTileOffset"), 
    k.SHADERVALUE_BLOOM_SETTINGS = H.propertyNameToID("u_Bloom_Settings"), k.SHADERVALUE_BLOOM_COLOR = H.propertyNameToID("u_Bloom_Color");
    class X extends t.EventDispatcher {
        constructor(e, r = null, i = null, a = null, s = null) {
            super(), this._owner = e, this._children = [], this._localMatrix = new Float32Array(16), 
            t.Render.supportWebGLPlusAnimation ? (this._localPosition = new M(0, 0, 0, r), this._localRotation = new O(0, 0, 0, 1, i), 
            this._localScale = new M(0, 0, 0, a), this._worldMatrix = s) : (this._localPosition = new n(), 
            this._localRotation = new f(), this._localScale = new n(), this._worldMatrix = new Float32Array(16)), 
            this._localQuaternionUpdate = !1, this._locaEulerlUpdate = !1, this._localUpdate = !1, 
            this._worldUpdate = !0;
        }
        _getlocalMatrix() {
            return this._localUpdate && (I._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix), 
            this._localUpdate = !1), this._localMatrix;
        }
        _onWorldTransform() {
            if (!this._worldUpdate) {
                this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
            }
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(e) {
            this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
        }
        get localRotation() {
            if (this._localQuaternionUpdate) {
                var e = this._localRotationEuler;
                f.createFromYawPitchRoll(e.y / X._angleToRandin, e.x / X._angleToRandin, e.z / X._angleToRandin, this._localRotation), 
                this._localQuaternionUpdate = !1;
            }
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1, 
            this._localUpdate = !0, this._onWorldTransform();
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(e) {
            this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
        }
        get localRotationEuler() {
            if (this._locaEulerlUpdate) {
                this._localRotation.getYawPitchRoll(X._tempVector3);
                var e = X._tempVector3, t = this._localRotationEuler;
                t.x = e.y * X._angleToRandin, t.y = e.x * X._angleToRandin, t.z = e.z * X._angleToRandin, 
                this._locaEulerlUpdate = !1;
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(e) {
            this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0, 
            this._localUpdate = !0, this._onWorldTransform();
        }
        getWorldMatrix() {
            if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                if (null != this._parent) I.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix); else {
                    var e = this._worldMatrix;
                    e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
                    e[0] = e[5] = e[10] = e[15] = 1;
                }
                this._worldUpdate = !1;
            }
            return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1), 
            this._worldMatrix;
        }
        setParent(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children, r = t.indexOf(this);
                    t.splice(r, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }
    }
    X._tempVector3 = new n(), X._angleToRandin = 180 / Math.PI;
    class Y {
        constructor(e = null, t = null, r = null, i = null) {
            this._children = [], this.transform = new X(this, e, t, r, i);
        }
        addChild(e) {
            e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
        }
        removeChild(e) {
            var t = this._children.indexOf(e);
            -1 !== t && this._children.splice(t, 1);
        }
        getChildByName(e) {
            for (var t = 0, r = this._children.length; t < r; t++) {
                var i = this._children[t];
                if (i.name === e) return i;
            }
            return null;
        }
        getChildByIndex(e) {
            return this._children[e];
        }
        getChildCount() {
            return this._children.length;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name;
            for (var r = 0, i = this._children.length; r < i; r++) {
                var a = this._children[r], n = a.clone();
                t.addChild(n);
                var s = a.transform, o = n.transform, l = o.localPosition, _ = o.localRotation, h = o.localScale;
                s.localPosition.cloneTo(l), s.localRotation.cloneTo(_), s.localScale.cloneTo(h), 
                o.localPosition = l, o.localRotation = _, o.localScale = h;
            }
        }
        clone() {
            var e = new Y();
            return this.cloneTo(e), e;
        }
        _cloneNative(e, t, r, i, a, n, s) {
            var o = s._nativeCurCloneCount;
            a[o] = n;
            var l = new Float32Array(e.buffer, 3 * o * 4, 3), _ = new Float32Array(t.buffer, 4 * o * 4, 4), h = new Float32Array(r.buffer, 3 * o * 4, 3), c = new Float32Array(i.buffer, 16 * o * 4, 16), d = new Y(l, _, h, c);
            return d._worldMatrixIndex = o, this._cloneToNative(d, e, t, r, i, a, o, s), d;
        }
        _cloneToNative(e, t, r, i, a, n, s, o) {
            var l = e;
            l.name = this.name;
            for (var _ = 0, h = this._children.length; _ < h; _++) {
                var c = this._children[_];
                o._nativeCurCloneCount++;
                var d = c._cloneNative(t, r, i, a, n, s, o);
                l.addChild(d);
                var u = c.transform, m = d.transform, f = m.localPosition, E = m.localRotation, T = m.localScale;
                u.localPosition.cloneTo(f), u.localRotation.cloneTo(E), u.localScale.cloneTo(T), 
                m.localPosition = f, m.localRotation = E, m.localScale = T;
            }
        }
    }
    class j extends t.Resource {
        constructor() {
            super(), this._nativeNodeCount = 0, this._nativeCurCloneCount = 0;
        }
        static _parse(e, r = null, i = null) {
            var a = new j();
            if (a._rootNode = new Y(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)), 
            t.Render.supportWebGLPlusAnimation && a._nativeNodeCount++, e.version) {
                var n = e.rootNode;
                n && a._parseNode(n, a._rootNode);
            }
            return a;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, j.AVATAR);
        }
        _initCloneToAnimator(e, t) {
            t._avatarNodeMap[e.name] = e;
            for (var r = 0, i = e.getChildCount(); r < i; r++) this._initCloneToAnimator(e.getChildByIndex(r), t);
        }
        _parseNode(e, r) {
            var i = e.props.name;
            r.name = i;
            var a = e.props, n = r.transform, s = n.localPosition, o = n.localRotation, l = n.localScale;
            s.fromArray(a.translate), o.fromArray(a.rotation), l.fromArray(a.scale), n.localPosition = s, 
            n.localRotation = o, n.localScale = l;
            for (var _ = e.child, h = 0, c = _.length; h < c; h++) {
                var d = _[h], u = new Y(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                r.addChild(u), t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(d, u);
            }
        }
        _cloneDatasToAnimator(e) {
            var t;
            t = this._rootNode.clone();
            var r = this._rootNode.transform, i = t.transform, a = i.localPosition, n = i.localRotation, s = i.localScale;
            r.localPosition.cloneTo(a), r.localRotation.cloneTo(n), r.localScale.cloneTo(s), 
            i.localPosition = a, i.localRotation = n, i.localScale = s, e._avatarNodeMap = {}, 
            this._initCloneToAnimator(t, e);
        }
        cloneTo(e) {
            var t = e, r = this._rootNode.clone();
            t._rootNode = r;
        }
        clone() {
            var e = new j();
            return this.cloneTo(e), e;
        }
        _cloneDatasToAnimatorNative(e) {
            var t = new Float32Array(3 * this._nativeNodeCount), r = new Float32Array(4 * this._nativeNodeCount), i = new Float32Array(3 * this._nativeNodeCount), a = new Float32Array(16 * this._nativeNodeCount), n = new Int16Array(this._nativeNodeCount);
            e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = r, e._animationNodeLocalScales = i, 
            e._animationNodeWorldMatrixs = a, e._animationNodeParentIndices = n, this._nativeCurCloneCount = 0;
            var s = this._rootNode._cloneNative(t, r, i, a, n, -1, this), o = this._rootNode.transform, l = s.transform, _ = l.localPosition, h = l.localRotation, c = l.localScale;
            o.localPosition.cloneTo(_), o.localRotation.cloneTo(h), o.localScale.cloneTo(c), 
            l.localPosition = _, l.localRotation = h, l.localScale = c, e._avatarNodeMap = {}, 
            this._initCloneToAnimator(s, e);
        }
    }
    j.AVATAR = "AVATAR";
    class Z extends t.Resource {
        constructor() {
            super(), this._shaderValues = null, this._shaderValues = new W(this), this.renderQueue = Z.RENDERQUEUE_OPAQUE, 
            this._alphaTest = !1;
        }
        static load(e, r) {
            t.Laya.loader.create(e, r, null, Z.MATERIAL);
        }
        static __initDefine__() {
            Z.SHADERDEFINE_ALPHATEST = H.getDefineByName("ALPHATEST");
        }
        static _parse(e, r = null, s = null) {
            var o, l = e, _ = l.props, h = _.type, c = t.ClassUtils.getRegClass(h);
            if (!c) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
            switch (o = new c(), l.version) {
              case "LAYAMATERIAL:01":
              case "LAYAMATERIAL:02":
                var d, u;
                for (var m in _) switch (m) {
                  case "type":
                    break;

                  case "vectors":
                    var f = _[m];
                    for (d = 0, u = f.length; d < u; d++) {
                        var E = f[d], T = E.value;
                        switch (T.length) {
                          case 2:
                            o[E.name] = new i(T[0], T[1]);
                            break;

                          case 3:
                            o[E.name] = new n(T[0], T[1], T[2]);
                            break;

                          case 4:
                            o[E.name] = new a(T[0], T[1], T[2], T[3]);
                            break;

                          default:
                            throw new Error("BaseMaterial:unkonwn color length.");
                        }
                    }
                    break;

                  case "textures":
                    var p = _[m];
                    for (d = 0, u = p.length; d < u; d++) {
                        var g = p[d], S = g.path;
                        S && (o[g.name] = t.Loader.getRes(S));
                    }
                    break;

                  case "defines":
                    var R = _[m];
                    for (d = 0, u = R.length; d < u; d++) {
                        var v = H.getDefineByName(R[d]);
                        o._shaderValues.addDefine(v);
                    }
                    break;

                  case "renderStates":
                    var x = _[m][0], I = o;
                    I.blend = x.blend, I.cull = x.cull, I.depthTest = x.depthTest, I.depthWrite = x.depthWrite, 
                    I.blendSrc = x.srcBlend, I.blendDst = x.dstBlend;
                    break;

                  case "cull":
                    o.cull = _[m];
                    break;

                  case "blend":
                    o.blend = _[m];
                    break;

                  case "depthWrite":
                    o.depthWrite = _[m];
                    break;

                  case "srcBlend":
                    o.blendSrc = _[m];
                    break;

                  case "dstBlend":
                    o.blendDst = _[m];
                    break;

                  default:
                    o[m] = _[m];
                }
                break;

              default:
                throw new Error("BaseMaterial:unkonwn version.");
            }
            return o;
        }
        get shaderData() {
            return this._shaderValues;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Z.ALPHATESTVALUE);
        }
        set alphaTestValue(e) {
            this._shaderValues.setNumber(Z.ALPHATESTVALUE, e);
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest = e, e ? this._shaderValues.addDefine(Z.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Z.SHADERDEFINE_ALPHATEST);
        }
        _removeTetxureReference() {
            var e = this._shaderValues.getData();
            for (var r in e) {
                var i = e[r];
                i && i instanceof t.BaseTexture && i._removeReference();
            }
        }
        _disposeResource() {
            this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
        }
        _addReference(e = 1) {
            super._addReference(e);
            var r = this._shaderValues.getData();
            for (var i in r) {
                var a = r[i];
                a && a instanceof t.BaseTexture && a._addReference();
            }
        }
        _removeReference(e = 1) {
            super._removeReference(e), this._removeTetxureReference();
        }
        setShaderName(e) {
            if (this._shader = H.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.renderQueue = this.renderQueue, this._shaderValues.cloneTo(t._shaderValues);
        }
        clone() {
            var e = new Z();
            return this.cloneTo(e), e;
        }
        get _defineDatas() {
            return this._shaderValues._defineDatas;
        }
    }
    Z.MATERIAL = "MATERIAL", Z.RENDERQUEUE_OPAQUE = 2e3, Z.RENDERQUEUE_ALPHATEST = 2450, 
    Z.RENDERQUEUE_TRANSPARENT = 3e3, Z.ALPHATESTVALUE = H.propertyNameToID("u_AlphaTestValue"), 
    Z.SHADERDEFINE_ALPHATEST = null;
    class q {
        static load(e, r) {
            t.Laya.loader.create(e, r, null, Z.MATERIAL);
        }
        static __initDefine__() {
            q.SHADERDEFINE_ALPHATEST = Z.SHADERDEFINE_ALPHATEST;
        }
    }
    q.MATERIAL = "MATERIAL", q.RENDERQUEUE_OPAQUE = 2e3, q.RENDERQUEUE_ALPHATEST = 2450, 
    q.RENDERQUEUE_TRANSPARENT = 3e3, q.ALPHATESTVALUE = H.propertyNameToID("u_AlphaTestValue"), 
    q.SHADERDEFINE_ALPHATEST = null;
    class Q {
        constructor() {
            this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.srcBlend = Q.BLENDPARAM_ONE, 
            this.dstBlend = Q.BLENDPARAM_ZERO, this.srcBlendRGB = Q.BLENDPARAM_ONE, this.dstBlendRGB = Q.BLENDPARAM_ZERO, 
            this.srcBlendAlpha = Q.BLENDPARAM_ONE, this.dstBlendAlpha = Q.BLENDPARAM_ZERO, this.blendConstColor = new a(1, 1, 1, 1), 
            this.blendEquation = Q.BLENDEQUATION_ADD, this.blendEquationRGB = Q.BLENDEQUATION_ADD, 
            this.blendEquationAlpha = Q.BLENDEQUATION_ADD, this.depthTest = Q.DEPTHTEST_LEQUAL, 
            this.depthWrite = !0;
        }
        cloneTo(e) {
            var t = e;
            t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend, 
            t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha, 
            t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor), 
            t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB, 
            t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
        }
        clone() {
            var e = new Q();
            return this.cloneTo(e), e;
        }
    }
    Q.CULL_NONE = 0, Q.CULL_FRONT = 1, Q.CULL_BACK = 2, Q.BLEND_DISABLE = 0, Q.BLEND_ENABLE_ALL = 1, 
    Q.BLEND_ENABLE_SEPERATE = 2, Q.BLENDPARAM_ZERO = 0, Q.BLENDPARAM_ONE = 1, Q.BLENDPARAM_SRC_COLOR = 768, 
    Q.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, Q.BLENDPARAM_DST_COLOR = 774, Q.BLENDPARAM_ONE_MINUS_DST_COLOR = 775, 
    Q.BLENDPARAM_SRC_ALPHA = 770, Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, Q.BLENDPARAM_DST_ALPHA = 772, 
    Q.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, Q.BLENDPARAM_SRC_ALPHA_SATURATE = 776, Q.BLENDEQUATION_ADD = 32774, 
    Q.BLENDEQUATION_SUBTRACT = 32778, Q.BLENDEQUATION_REVERSE_SUBTRACT = 32779, Q.DEPTHTEST_OFF = 0, 
    Q.DEPTHTEST_NEVER = 512, Q.DEPTHTEST_LESS = 513, Q.DEPTHTEST_EQUAL = 514, Q.DEPTHTEST_LEQUAL = 515, 
    Q.DEPTHTEST_GREATER = 516, Q.DEPTHTEST_NOTEQUAL = 517, Q.DEPTHTEST_GEQUAL = 518, 
    Q.DEPTHTEST_ALWAYS = 519;
    class K extends Z {
        constructor() {
            super(), this._enableVertexColor = !1, this.setShaderName("BLINNPHONG"), this._albedoIntensity = 1, 
            this._albedoColor = new a(1, 1, 1, 1);
            var e = this._shaderValues;
            e.setVector(K.ALBEDOCOLOR, new a(1, 1, 1, 1)), e.setVector(K.MATERIALSPECULAR, new a(1, 1, 1, 1)), 
            e.setNumber(K.SHININESS, .078125), e.setNumber(Z.ALPHATESTVALUE, .5), e.setVector(K.TILINGOFFSET, new a(1, 1, 0, 0)), 
            this._enableLighting = !0, this.renderMode = K.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            K.SHADERDEFINE_DIFFUSEMAP = H.getDefineByName("DIFFUSEMAP"), K.SHADERDEFINE_NORMALMAP = H.getDefineByName("NORMALMAP"), 
            K.SHADERDEFINE_SPECULARMAP = H.getDefineByName("SPECULARMAP"), K.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), 
            K.SHADERDEFINE_ENABLEVERTEXCOLOR = H.getDefineByName("ENABLEVERTEXCOLOR"), K.HIDEBYPOSITION = H.getDefineByName("HIDEBYPOSITION");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _SpecColorR() {
            return this._shaderValues.getVector(K.MATERIALSPECULAR).x;
        }
        set _SpecColorR(e) {
            this._shaderValues.getVector(K.MATERIALSPECULAR).x = e;
        }
        get _SpecColorG() {
            return this._shaderValues.getVector(K.MATERIALSPECULAR).y;
        }
        set _SpecColorG(e) {
            this._shaderValues.getVector(K.MATERIALSPECULAR).y = e;
        }
        get _SpecColorB() {
            return this._shaderValues.getVector(K.MATERIALSPECULAR).z;
        }
        set _SpecColorB(e) {
            this._shaderValues.getVector(K.MATERIALSPECULAR).z = e;
        }
        get _SpecColorA() {
            return this._shaderValues.getVector(K.MATERIALSPECULAR).w;
        }
        set _SpecColorA(e) {
            this._shaderValues.getVector(K.MATERIALSPECULAR).w = e;
        }
        get _AlbedoIntensity() {
            return this._albedoIntensity;
        }
        set _AlbedoIntensity(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(K.ALBEDOCOLOR);
                a.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(K.ALBEDOCOLOR, t);
            }
        }
        get _Shininess() {
            return this._shaderValues.getNumber(K.SHININESS);
        }
        set _Shininess(e) {
            e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(K.SHININESS, e);
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(K.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(K.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(K.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(K.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(K.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(K.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(K.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(K.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        set renderMode(e) {
            switch (e) {
              case K.RENDERMODE_OPAQUE:
                this.alphaTest = !1, this.renderQueue = Z.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              case K.RENDERMODE_CUTOUT:
                this.renderQueue = Z.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              case K.RENDERMODE_TRANSPARENT:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              default:
                throw new Error("Material:renderMode value error.");
            }
        }
        get enableVertexColor() {
            return this._enableVertexColor;
        }
        set enableVertexColor(e) {
            this._enableVertexColor = e, e ? this._shaderValues.addDefine(K.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(K.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(K.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(K.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(K.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(K.TILINGOFFSET, e);
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            var t = this._shaderValues.getVector(K.ALBEDOCOLOR);
            a.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(K.ALBEDOCOLOR, t);
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(e) {
            this._AlbedoIntensity = e;
        }
        get specularColorR() {
            return this._SpecColorR;
        }
        set specularColorR(e) {
            this._SpecColorR = e;
        }
        get specularColorG() {
            return this._SpecColorG;
        }
        set specularColorG(e) {
            this._SpecColorG = e;
        }
        get specularColorB() {
            return this._SpecColorB;
        }
        set specularColorB(e) {
            this._SpecColorB = e;
        }
        get specularColorA() {
            return this._SpecColorA;
        }
        set specularColorA(e) {
            this._SpecColorA = e;
        }
        get specularColor() {
            return this._shaderValues.getVector(K.MATERIALSPECULAR);
        }
        set specularColor(e) {
            this._shaderValues.setVector(K.MATERIALSPECULAR, e);
        }
        get shininess() {
            return this._Shininess;
        }
        set shininess(e) {
            this._Shininess = e;
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(K.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(K.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_DIFFUSEMAP), 
            this._shaderValues.setTexture(K.ALBEDOTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(K.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(K.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_NORMALMAP), 
            this._shaderValues.setTexture(K.NORMALTEXTURE, e);
        }
        get specularTexture() {
            return this._shaderValues.getTexture(K.SPECULARTEXTURE);
        }
        set specularTexture(e) {
            e ? this._shaderValues.addDefine(K.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(K.SHADERDEFINE_SPECULARMAP), 
            this._shaderValues.setTexture(K.SPECULARTEXTURE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(K.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(K.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt(K.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt(K.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt(K.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt(K.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(K.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(K.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(K.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt(K.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(K.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(K.DEPTH_TEST, e);
        }
        get hidePosZ() {
            return this._shaderValues.getNumber(K.HIDEPOSZ);
        }
        set hidePosZ(e) {
            this._shaderValues.setNumber(K.HIDEPOSZ, e);
        }
        set hideFlag(e) {
            e ? this._shaderValues.addDefine(K.HIDEBYPOSITION) : this._shaderValues.removeDefine(K.HIDEBYPOSITION);
        }
        get hideFlag() {
            return !0;
        }
        clone() {
            var e = new K();
            return this.cloneTo(e), e;
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t._enableLighting = this._enableLighting, t._albedoIntensity = this._albedoIntensity, 
            t._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(t._albedoColor);
        }
    }
    K.RENDERMODE_OPAQUE = 0, K.RENDERMODE_CUTOUT = 1, K.RENDERMODE_TRANSPARENT = 2, 
    K.ALBEDOTEXTURE = H.propertyNameToID("u_DiffuseTexture"), K.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"), 
    K.SPECULARTEXTURE = H.propertyNameToID("u_SpecularTexture"), K.ALBEDOCOLOR = H.propertyNameToID("u_DiffuseColor"), 
    K.MATERIALSPECULAR = H.propertyNameToID("u_MaterialSpecular"), K.SHININESS = H.propertyNameToID("u_Shininess"), 
    K.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), K.HIDEPOSZ = H.propertyNameToID("u_HidePosZ"), 
    K.CULL = H.propertyNameToID("s_Cull"), K.BLEND = H.propertyNameToID("s_Blend"), 
    K.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), K.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    K.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), K.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class J extends Z {
        constructor() {
            super(), this.setShaderName("Effect"), this._color = new a(1, 1, 1, 1), this._shaderValues.setVector(J.TINTCOLOR, new a(1, 1, 1, 1)), 
            this.renderMode = J.RENDERMODE_ADDTIVE;
        }
        static __initDefine__() {
            J.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), J.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), 
            J.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(J.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(J.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(J.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(J.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(J.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(J.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(J.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(J.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
              case J.RENDERMODE_ADDTIVE:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE, this.depthTest = Q.DEPTHTEST_LESS, this._shaderValues.addDefine(J.SHADERDEFINE_ADDTIVEFOG);
                break;

              case J.RENDERMODE_ALPHABLENDED:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.removeDefine(J.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("MeshEffectMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(J.TINTCOLOR);
        }
        set color(e) {
            this._shaderValues.setVector(J.TINTCOLOR, e);
        }
        get texture() {
            return this._shaderValues.getTexture(J.MAINTEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(J.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(J.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(J.MAINTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(J.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(J.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(J.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(J.TILINGOFFSET, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(J.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(J.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt(J.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt(J.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt(J.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt(J.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(J.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(J.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(J.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt(J.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(J.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(J.DEPTH_TEST, e);
        }
        clone() {
            var e = new J();
            return this.cloneTo(e), e;
        }
    }
    J.RENDERMODE_ADDTIVE = 0, J.RENDERMODE_ALPHABLENDED = 1, J.MAINTEXTURE = H.propertyNameToID("u_AlbedoTexture"), 
    J.TINTCOLOR = H.propertyNameToID("u_AlbedoColor"), J.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), 
    J.CULL = H.propertyNameToID("s_Cull"), J.BLEND = H.propertyNameToID("s_Blend"), 
    J.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), J.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    J.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), J.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class $ extends Z {
        constructor() {
            super(), this._enableLighting = !0, this.setShaderName("ExtendTerrain"), this.renderMode = $.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            $.SHADERDEFINE_DETAIL_NUM1 = H.getDefineByName("ExtendTerrain_DETAIL_NUM1"), $.SHADERDEFINE_DETAIL_NUM2 = H.getDefineByName("ExtendTerrain_DETAIL_NUM2"), 
            $.SHADERDEFINE_DETAIL_NUM3 = H.getDefineByName("ExtendTerrain_DETAIL_NUM3"), $.SHADERDEFINE_DETAIL_NUM4 = H.getDefineByName("ExtendTerrain_DETAIL_NUM4"), 
            $.SHADERDEFINE_DETAIL_NUM5 = H.getDefineByName("ExtendTerrain_DETAIL_NUM5");
        }
        get splatAlphaTexture() {
            return this._shaderValues.getTexture($.SPLATALPHATEXTURE);
        }
        set splatAlphaTexture(e) {
            this._shaderValues.setTexture($.SPLATALPHATEXTURE, e);
        }
        get diffuseTexture1() {
            return this._shaderValues.getTexture($.DIFFUSETEXTURE1);
        }
        set diffuseTexture1(e) {
            this._shaderValues.setTexture($.DIFFUSETEXTURE1, e), this._setDetailNum(1);
        }
        get diffuseTexture2() {
            return this._shaderValues.getTexture($.DIFFUSETEXTURE2);
        }
        set diffuseTexture2(e) {
            this._shaderValues.setTexture($.DIFFUSETEXTURE2, e), this._setDetailNum(2);
        }
        get diffuseTexture3() {
            return this._shaderValues.getTexture($.DIFFUSETEXTURE3);
        }
        set diffuseTexture3(e) {
            this._shaderValues.setTexture($.DIFFUSETEXTURE3, e), this._setDetailNum(3);
        }
        get diffuseTexture4() {
            return this._shaderValues.getTexture($.DIFFUSETEXTURE4);
        }
        set diffuseTexture4(e) {
            this._shaderValues.setTexture($.DIFFUSETEXTURE4, e), this._setDetailNum(4);
        }
        get diffuseTexture5() {
            return this._shaderValues.getTexture($.DIFFUSETEXTURE5);
        }
        set diffuseTexture5(e) {
            this._shaderValues.setTexture($.DIFFUSETEXTURE5, e), this._setDetailNum(5);
        }
        set diffuseScaleOffset1(e) {
            this._shaderValues.setVector($.DIFFUSESCALEOFFSET1, e);
        }
        set diffuseScaleOffset2(e) {
            this._shaderValues.setVector($.DIFFUSESCALEOFFSET2, e);
        }
        set diffuseScaleOffset3(e) {
            this._shaderValues.setVector($.DIFFUSESCALEOFFSET3, e);
        }
        set diffuseScaleOffset4(e) {
            this._shaderValues.setVector($.DIFFUSESCALEOFFSET4, e);
        }
        set diffuseScaleOffset5(e) {
            this._shaderValues.setVector($.DIFFUSESCALEOFFSET5, e);
        }
        set renderMode(e) {
            switch (e) {
              case $.RENDERMODE_OPAQUE:
                this.renderQueue = Z.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = Q.CULL_BACK, 
                this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              case $.RENDERMODE_TRANSPARENT:
                this.renderQueue = Z.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = Q.CULL_BACK, 
                this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, 
                this.depthTest = Q.DEPTHTEST_LEQUAL;
                break;

              default:
                throw new Error("ExtendTerrainMaterial:renderMode value error.");
            }
        }
        get depthWrite() {
            return this._shaderValues.getBool($.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool($.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt($.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt($.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt($.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt($.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt($.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt($.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt($.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt($.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt($.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt($.DEPTH_TEST, e);
        }
        _setDetailNum(e) {
            switch (e) {
              case 1:
                this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 2:
                this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 3:
                this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 4:
                this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 5:
                this._shaderValues.addDefine($.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM1), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM3), 
                this._shaderValues.removeDefine($.SHADERDEFINE_DETAIL_NUM4);
            }
        }
        clone() {
            var e = new $();
            return this.cloneTo(e), e;
        }
    }
    $.RENDERMODE_OPAQUE = 1, $.RENDERMODE_TRANSPARENT = 2, $.SPLATALPHATEXTURE = H.propertyNameToID("u_SplatAlphaTexture"), 
    $.DIFFUSETEXTURE1 = H.propertyNameToID("u_DiffuseTexture1"), $.DIFFUSETEXTURE2 = H.propertyNameToID("u_DiffuseTexture2"), 
    $.DIFFUSETEXTURE3 = H.propertyNameToID("u_DiffuseTexture3"), $.DIFFUSETEXTURE4 = H.propertyNameToID("u_DiffuseTexture4"), 
    $.DIFFUSETEXTURE5 = H.propertyNameToID("u_DiffuseTexture5"), $.DIFFUSESCALEOFFSET1 = H.propertyNameToID("u_DiffuseScaleOffset1"), 
    $.DIFFUSESCALEOFFSET2 = H.propertyNameToID("u_DiffuseScaleOffset2"), $.DIFFUSESCALEOFFSET3 = H.propertyNameToID("u_DiffuseScaleOffset3"), 
    $.DIFFUSESCALEOFFSET4 = H.propertyNameToID("u_DiffuseScaleOffset4"), $.DIFFUSESCALEOFFSET5 = H.propertyNameToID("u_DiffuseScaleOffset5"), 
    $.CULL = H.propertyNameToID("s_Cull"), $.BLEND = H.propertyNameToID("s_Blend"), 
    $.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), $.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    $.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), $.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite"), 
    (o = e.PBRRenderMode || (e.PBRRenderMode = {}))[o.Opaque = 0] = "Opaque", o[o.Cutout = 1] = "Cutout", 
    o[o.Fade = 2] = "Fade", o[o.Transparent = 3] = "Transparent";
    class ee extends Z {
        constructor() {
            super(), this._enableEmission = !1, this._shaderValues.setVector(ee.ALBEDOCOLOR, new a(1, 1, 1, 1)), 
            this._shaderValues.setVector(ee.EMISSIONCOLOR, new a(1, 1, 1, 1)), this._shaderValues.setNumber(ee.SMOOTHNESS, .5), 
            this._shaderValues.setNumber(ee.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(ee.OCCLUSIONSTRENGTH, 1), 
            this._shaderValues.setNumber(ee.NORMALSCALE, 1), this._shaderValues.setNumber(ee.PARALLAXSCALE, .001), 
            this._shaderValues.setNumber(Z.ALPHATESTVALUE, .5), this.renderMode = e.PBRRenderMode.Opaque;
        }
        static __init__() {
            ee.SHADERDEFINE_ALBEDOTEXTURE = H.getDefineByName("ALBEDOTEXTURE"), ee.SHADERDEFINE_NORMALTEXTURE = H.getDefineByName("NORMALTEXTURE"), 
            ee.SHADERDEFINE_PARALLAXTEXTURE = H.getDefineByName("PARALLAXTEXTURE"), ee.SHADERDEFINE_OCCLUSIONTEXTURE = H.getDefineByName("OCCLUSIONTEXTURE"), 
            ee.SHADERDEFINE_EMISSION = H.getDefineByName("EMISSION"), ee.SHADERDEFINE_EMISSIONTEXTURE = H.getDefineByName("EMISSIONTEXTURE"), 
            ee.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), ee.SHADERDEFINE_TRANSPARENTBLEND = H.getDefineByName("TRANSPARENTBLEND"), 
            ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = H.getDefineByName("LAYA_PBR_BRDF_HIGH"), ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW = H.getDefineByName("LAYA_PBR_BRDF_LOW");
        }
        get albedoColor() {
            return this._shaderValues.getVector(ee.ALBEDOCOLOR);
        }
        set albedoColor(e) {
            this._shaderValues.setVector(ee.ALBEDOCOLOR, e);
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(ee.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_ALBEDOTEXTURE), 
            this._shaderValues.setTexture(ee.ALBEDOTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(ee.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_NORMALTEXTURE), 
            this._shaderValues.setTexture(ee.NORMALTEXTURE, e);
        }
        get normalTextureScale() {
            return this._shaderValues.getNumber(ee.NORMALSCALE);
        }
        set normalTextureScale(e) {
            this._shaderValues.setNumber(ee.NORMALSCALE, e);
        }
        get parallaxTexture() {
            return this._shaderValues.getTexture(ee.PARALLAXTEXTURE);
        }
        set parallaxTexture(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_PARALLAXTEXTURE), 
            this._shaderValues.setTexture(ee.PARALLAXTEXTURE, e);
        }
        get parallaxTextureScale() {
            return this._shaderValues.getNumber(ee.PARALLAXSCALE);
        }
        set parallaxTextureScale(e) {
            this._shaderValues.setNumber(ee.PARALLAXSCALE, Math.max(.005, Math.min(.08, e)));
        }
        get occlusionTexture() {
            return this._shaderValues.getTexture(ee.OCCLUSIONTEXTURE);
        }
        set occlusionTexture(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_OCCLUSIONTEXTURE), 
            this._shaderValues.setTexture(ee.OCCLUSIONTEXTURE, e);
        }
        get occlusionTextureStrength() {
            return this._shaderValues.getNumber(ee.OCCLUSIONSTRENGTH);
        }
        set occlusionTextureStrength(e) {
            this._shaderValues.setNumber(ee.OCCLUSIONSTRENGTH, Math.max(0, Math.min(1, e)));
        }
        get smoothness() {
            return this._shaderValues.getNumber(ee.SMOOTHNESS);
        }
        set smoothness(e) {
            this._shaderValues.setNumber(ee.SMOOTHNESS, Math.max(0, Math.min(1, e)));
        }
        get smoothnessTextureScale() {
            return this._shaderValues.getNumber(ee.SMOOTHNESSSCALE);
        }
        set smoothnessTextureScale(e) {
            this._shaderValues.setNumber(ee.SMOOTHNESSSCALE, Math.max(0, Math.min(1, e)));
        }
        get enableEmission() {
            return this._enableEmission;
        }
        set enableEmission(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(ee.SHADERDEFINE_EMISSION), 
            this._enableEmission = e;
        }
        get emissionColor() {
            return this._shaderValues.getVector(ee.EMISSIONCOLOR);
        }
        set emissionColor(e) {
            this._shaderValues.setVector(ee.EMISSIONCOLOR, e);
        }
        get emissionTexture() {
            return this._shaderValues.getTexture(ee.EMISSIONTEXTURE);
        }
        set emissionTexture(e) {
            e ? this._shaderValues.addDefine(ee.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(ee.SHADERDEFINE_EMISSIONTEXTURE), 
            this._shaderValues.setTexture(ee.EMISSIONTEXTURE, e);
        }
        get tilingOffset() {
            return this._shaderValues.getVector(ee.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ee.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ee.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(ee.TILINGOFFSET, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(ee.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(ee.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt(ee.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt(ee.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt(ee.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt(ee.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(ee.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(ee.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(ee.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt(ee.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(ee.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(ee.DEPTH_TEST, e);
        }
        set renderMode(t) {
            switch (t) {
              case e.PBRRenderMode.Opaque:
                this.alphaTest = !1, this.renderQueue = Z.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                break;

              case e.PBRRenderMode.Cutout:
                this.renderQueue = Z.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                break;

              case e.PBRRenderMode.Fade:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.removeDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                break;

              case e.PBRRenderMode.Transparent:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_ONE, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.addDefine(ee.SHADERDEFINE_TRANSPARENTBLEND);
                break;

              default:
                throw new Error("PBRMaterial:unknown renderMode value.");
            }
        }
        get enableReflection() {
            return !0;
        }
        set enableReflection(e) {}
    }
    ee.ALBEDOTEXTURE = H.propertyNameToID("u_AlbedoTexture"), ee.ALBEDOCOLOR = H.propertyNameToID("u_AlbedoColor"), 
    ee.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), ee.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"), 
    ee.NORMALSCALE = H.propertyNameToID("u_NormalScale"), ee.SMOOTHNESS = H.propertyNameToID("u_Smoothness"), 
    ee.SMOOTHNESSSCALE = H.propertyNameToID("u_SmoothnessScale"), ee.OCCLUSIONTEXTURE = H.propertyNameToID("u_OcclusionTexture"), 
    ee.OCCLUSIONSTRENGTH = H.propertyNameToID("u_occlusionStrength"), ee.PARALLAXTEXTURE = H.propertyNameToID("u_ParallaxTexture"), 
    ee.PARALLAXSCALE = H.propertyNameToID("u_ParallaxScale"), ee.EMISSIONTEXTURE = H.propertyNameToID("u_EmissionTexture"), 
    ee.EMISSIONCOLOR = H.propertyNameToID("u_EmissionColor"), ee.CULL = H.propertyNameToID("s_Cull"), 
    ee.BLEND = H.propertyNameToID("s_Blend"), ee.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), 
    ee.BLEND_DST = H.propertyNameToID("s_BlendDst"), ee.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), 
    ee.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite"), ee.renderQuality = e.PBRRenderQuality.High;
    var te, re, ie, ae, ne, se, oe, le, _e, he, ce = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', de = '#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', ue = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', me = '#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}';
    class fe {
        constructor() {
            this.textureID = -1;
        }
    }
    class Ee extends t.Resource {
        constructor(e, t, r, i, a) {
            super(), this._stateParamsMap = [], this._uploadMark = -1, this._uploadRenderType = -1, 
            this._vs = e, this._ps = t, this._attributeMap = r, this._uniformMap = i, this._shaderPass = a, 
            this._create(), this.lock = !0;
        }
        _create() {
            var e = t.LayaGL.instance;
            for (var r in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER), 
            this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this._program, this._vshader), 
            e.attachShader(this._program, this._pshader), this._attributeMap) e.bindAttribLocation(this._program, this._attributeMap[r], r);
            if (e.linkProgram(this._program), !t.Render.isConchApp && H.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS)) throw e.getProgramInfoLog(this._program);
            var i = [], a = [], n = [], s = [], o = [];
            this._customUniformParamsMap = [];
            var l, _, h, c = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
            for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, _ = 0; _ < c; _++) {
                var d = e.getActiveUniform(this._program, _), u = d.name;
                (l = new fe()).location = e.getUniformLocation(this._program, u), u.indexOf("[0]") > 0 ? (l.name = u = u.substr(0, u.length - 3), 
                l.isArray = !0) : (l.name = u, l.isArray = !1), l.type = d.type, this._addShaderUnifiormFun(l);
                var m = this._uniformMap[u];
                if (null != m) switch (l.dataOffset = H.propertyNameToID(u), m) {
                  case H.PERIOD_CUSTOM:
                    o.push(l);
                    break;

                  case H.PERIOD_MATERIAL:
                    s.push(l);
                    break;

                  case H.PERIOD_SPRITE:
                    n.push(l);
                    break;

                  case H.PERIOD_CAMERA:
                    a.push(l);
                    break;

                  case H.PERIOD_SCENE:
                    i.push(l);
                    break;

                  default:
                    throw new Error("Shader3D: period is unkonw.");
                }
            }
            for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0), 
            _ = 0, h = i.length; _ < h; _++) this._sceneUniformParamsMap.addShaderUniform(i[_]);
            for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0), 
            _ = 0, h = a.length; _ < h; _++) this._cameraUniformParamsMap.addShaderUniform(a[_]);
            for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0), 
            _ = 0, h = n.length; _ < h; _++) this._spriteUniformParamsMap.addShaderUniform(n[_]);
            for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * s.length * 5 + 4, 64, !0), 
            _ = 0, h = s.length; _ < h; _++) this._materialUniformParamsMap.addShaderUniform(s[_]);
            for (this._customUniformParamsMap.length = o.length, _ = 0, h = o.length; _ < h; _++) {
                var f = o[_];
                this._customUniformParamsMap[f.dataOffset] = f;
            }
            var E = this._shaderPass._stateMap;
            for (var T in E) this._stateParamsMap[E[T]] = H.propertyNameToID(T);
        }
        _getRenderState(e, t) {
            var r = this._stateParamsMap[t];
            return null == r ? null : e[r];
        }
        _disposeResource() {
            t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(this._pshader), 
            t.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null, 
            this._setGPUMemory(0), this._curActTexIndex = 0;
        }
        _addShaderUnifiormFun(e) {
            var r = t.LayaGL.instance;
            e.caller = this;
            var i = e.isArray;
            switch (e.type) {
              case r.BOOL:
                e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                break;

              case r.INT:
                e.fun = i ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                break;

              case r.FLOAT:
                e.fun = i ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                break;

              case r.FLOAT_VEC2:
                e.fun = i ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                break;

              case r.FLOAT_VEC3:
                e.fun = i ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                break;

              case r.FLOAT_VEC4:
                e.fun = i ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                break;

              case r.FLOAT_MAT2:
                e.fun = this._uniformMatrix2fv;
                break;

              case r.FLOAT_MAT3:
                e.fun = this._uniformMatrix3fv;
                break;

              case r.FLOAT_MAT4:
                e.fun = i ? this._uniformMatrix4fv : this._uniformMatrix4f;
                break;

              case r.SAMPLER_2D:
              case r.SAMPLER_2D_SHADOW:
                r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_sampler2D;
                break;

              case 35679:
                r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_sampler3D;
                break;

              case r.SAMPLER_CUBE:
                r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_samplerCube;
                break;

              default:
                throw new Error("compile shader err!");
            }
        }
        _createShader(e, t, r) {
            var i = e.createShader(r);
            if (e.shaderSource(i, t), e.compileShader(i), H.debugMode && !e.getShaderParameter(i, e.COMPILE_STATUS)) throw e.getShaderInfoLog(i);
            return i;
        }
        _uniform1f(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, i[0] = r), 1) : 0;
        }
        _uniform1fv(e, r) {
            if (r.length < 4) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform1fv(e.location, r), 
                i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
            }
            return t.LayaGL.instance.uniform1fv(e.location, r), 1;
        }
        _uniform_vec2(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location, i[0] = r.x, i[1] = r.y), 
            1) : 0;
        }
        _uniform_vec2v(e, r) {
            if (r.length < 2) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform2fv(e.location, r), 
                i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
            }
            return t.LayaGL.instance.uniform2fv(e.location, r), 1;
        }
        _uniform_vec3(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z ? (t.LayaGL.instance.uniform3f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z), 
            1) : 0;
        }
        _uniform_vec3v(e, r) {
            return t.LayaGL.instance.uniform3fv(e.location, r), 1;
        }
        _uniform_vec4(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z || i[3] !== r.w ? (t.LayaGL.instance.uniform4f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = r.w), 
            1) : 0;
        }
        _uniform_vec4v(e, r) {
            return t.LayaGL.instance.uniform4fv(e.location, r), 1;
        }
        _uniformMatrix2fv(e, r) {
            return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r), 1;
        }
        _uniformMatrix3fv(e, r) {
            return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r), 1;
        }
        _uniformMatrix4f(e, r) {
            var i = r.elements;
            return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, i), 1;
        }
        _uniformMatrix4fv(e, r) {
            return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1;
        }
        _uniform1i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, i[0] = r), 1) : 0;
        }
        _uniform1iv(e, r) {
            return t.LayaGL.instance.uniform1iv(e.location, r), 1;
        }
        _uniform_ivec2(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location, i[0] = r[0], i[1] = r[1]), 
            1) : 0;
        }
        _uniform_ivec2v(e, r) {
            return t.LayaGL.instance.uniform2iv(e.location, r), 1;
        }
        _uniform_vec3i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] ? (t.LayaGL.instance.uniform3i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2]), 
            1) : 0;
        }
        _uniform_vec3vi(e, r) {
            return t.LayaGL.instance.uniform3iv(e.location, r), 1;
        }
        _uniform_vec4i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform4i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3]), 
            1) : 0;
        }
        _uniform_vec4vi(e, r) {
            return t.LayaGL.instance.uniform4iv(e.location, r), 1;
        }
        _uniform_sampler2D(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(), a = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, a.TEXTURE_2D, i), 
            0;
        }
        _uniform_sampler3D(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(), a = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, WebGL2RenderingContext.TEXTURE_3D, i), 
            0;
        }
        _uniform_samplerCube(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(), a = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(a, e.textureID), t.WebGLContext.bindTexture(a, a.TEXTURE_CUBE_MAP, i), 
            0;
        }
        bind() {
            return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
        }
        uploadUniforms(e, r, i) {
            t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, r, i);
        }
        uploadRenderStateBlendDepth(e) {
            var r = t.LayaGL.instance, i = this._shaderPass.renderState, a = e.getData(), n = this._getRenderState(a, H.RENDER_STATE_DEPTH_WRITE), s = this._getRenderState(a, H.RENDER_STATE_DEPTH_TEST), o = this._getRenderState(a, H.RENDER_STATE_BLEND);
            switch (null == n && (n = i.depthWrite), null == s && (s = i.depthTest), null == o && (o = i.blend), 
            t.WebGLContext.setDepthMask(r, n), s === Q.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext.setDepthTest(r, !0), 
            t.WebGLContext.setDepthFunc(r, s)), o) {
              case Q.BLEND_DISABLE:
                t.WebGLContext.setBlend(r, !1);
                break;

              case Q.BLEND_ENABLE_ALL:
                var l = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION), _ = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC), h = this._getRenderState(a, H.RENDER_STATE_BLEND_DST);
                null == l && (l = i.blendEquation), null == _ && (_ = i.srcBlend), null == h && (h = i.dstBlend), 
                t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquation(r, l), t.WebGLContext.setBlendFunc(r, _, h);
                break;

              case Q.BLEND_ENABLE_SEPERATE:
                var c = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION_RGB), d = this._getRenderState(a, H.RENDER_STATE_BLEND_EQUATION_ALPHA), u = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC_RGB), m = this._getRenderState(a, H.RENDER_STATE_BLEND_DST_RGB), f = this._getRenderState(a, H.RENDER_STATE_BLEND_SRC_ALPHA), E = this._getRenderState(a, H.RENDER_STATE_BLEND_DST_ALPHA);
                null == c && (c = i.blendEquationRGB), null == d && (d = i.blendEquationAlpha), 
                null == u && (u = i.srcBlendRGB), null == m && (m = i.dstBlendRGB), null == f && (f = i.srcBlendAlpha), 
                null == E && (E = i.dstBlendAlpha), t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquationSeparate(r, c, d), 
                t.WebGLContext.setBlendFuncSeperate(r, u, m, f, E);
            }
        }
        uploadRenderStateFrontFace(e, r, i) {
            var a, n = t.LayaGL.instance, s = this._shaderPass.renderState, o = e.getData(), l = this._getRenderState(o, H.RENDER_STATE_CULL);
            switch (null == l && (l = s.cull), l) {
              case Q.CULL_NONE:
                t.WebGLContext.setCullFace(n, !1);
                break;

              case Q.CULL_FRONT:
                t.WebGLContext.setCullFace(n, !0), a = r ? i ? n.CCW : n.CW : i ? n.CW : n.CCW, 
                t.WebGLContext.setFrontFace(n, a);
                break;

              case Q.CULL_BACK:
                t.WebGLContext.setCullFace(n, !0), a = r ? i ? n.CW : n.CCW : i ? n.CCW : n.CW, 
                t.WebGLContext.setFrontFace(n, a);
            }
        }
        uploadCustomUniform(e, r) {
            t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, r);
        }
        _uniformMatrix2fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r), 1;
        }
        _uniformMatrix3fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r), 1;
        }
        _uniformMatrix4fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r), 1;
        }
    }
    class Te {
        constructor() {
            this.elements = [], this.length = 0;
        }
        _add(e) {
            this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
        }
        add(e) {
            this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e, 
            this.length++;
        }
    }
    class pe extends Te {
        constructor() {
            super();
        }
        add(e) {
            e._getIndexInList();
            this._add(e), e._setIndexInList(this.length++);
        }
        remove(e) {
            var t = e._getIndexInList();
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._setIndexInList(t);
            }
            e._setIndexInList(-1);
        }
        clear() {
            for (var e = this.elements, t = 0, r = this.length; t < r; t++) e[t]._setIndexInList(-1);
            this.length = 0;
        }
    }
    class ge {
        constructor(e = 1, t = 1, r = 1, i = 1) {
            this.r = e, this.g = t, this.b = r, this.a = i;
        }
        static gammaToLinearSpace(e) {
            return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
        }
        static linearToGammaSpace(e) {
            return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
        }
        toLinear(e) {
            e.r = ge.gammaToLinearSpace(this.r), e.g = ge.gammaToLinearSpace(this.g), e.b = ge.gammaToLinearSpace(this.b);
        }
        toGamma(e) {
            e.r = ge.linearToGammaSpace(this.r), e.g = ge.linearToGammaSpace(this.g), e.b = ge.linearToGammaSpace(this.b);
        }
        cloneTo(e) {
            var t = e;
            t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
        }
        clone() {
            var e = new ge();
            return this.cloneTo(e), e;
        }
        forNativeElement() {}
    }
    ge.RED = new ge(1, 0, 0, 1), ge.GREEN = new ge(0, 1, 0, 1), ge.BLUE = new ge(0, 0, 1, 1), 
    ge.CYAN = new ge(0, 1, 1, 1), ge.YELLOW = new ge(1, .92, .016, 1), ge.MAGENTA = new ge(1, 0, 1, 1), 
    ge.GRAY = new ge(.5, .5, .5, 1), ge.WHITE = new ge(1, 1, 1, 1), ge.BLACK = new ge(0, 0, 0, 1);
    class Se {
        constructor() {
            this._batchRenderElementPool = [];
        }
        static _registerManager(e) {
            Se._managers.push(e);
        }
        _clear() {
            this._batchRenderElementPoolIndex = 0;
        }
        _getBatchRenderElementFromPool() {
            throw "StaticBatch:must override this function.";
        }
        dispose() {}
    }
    Se._managers = [];
    class Re extends t.EventDispatcher {
        constructor(e) {
            super(), this._localPosition = new n(0, 0, 0), this._localRotation = new f(0, 0, 0, 1), 
            this._localScale = new n(1, 1, 1), this._localRotationEuler = new n(0, 0, 0), this._localMatrix = new y(), 
            this._position = new n(0, 0, 0), this._rotation = new f(0, 0, 0, 1), this._scale = new n(1, 1, 1), 
            this._rotationEuler = new n(0, 0, 0), this._worldMatrix = new y(), this._children = null, 
            this._parent = null, this._dummy = null, this._transformFlag = 0, this._owner = e, 
            this._children = [], this._setTransformFlag(Re.TRANSFORM_LOCALQUATERNION | Re.TRANSFORM_LOCALEULER | Re.TRANSFORM_LOCALMATRIX, !1), 
            this._setTransformFlag(Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDEULER | Re.TRANSFORM_WORLDSCALE | Re.TRANSFORM_WORLDMATRIX, !0);
        }
        get _isFrontFaceInvert() {
            var e = this.getWorldLossyScale(), t = e.x < 0;
            return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
        }
        get owner() {
            return this._owner;
        }
        get worldNeedUpdate() {
            return this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX);
        }
        get localPositionX() {
            return this._localPosition.x;
        }
        set localPositionX(e) {
            this._localPosition.x = e, this.localPosition = this._localPosition;
        }
        get localPositionY() {
            return this._localPosition.y;
        }
        set localPositionY(e) {
            this._localPosition.y = e, this.localPosition = this._localPosition;
        }
        get localPositionZ() {
            return this._localPosition.z;
        }
        set localPositionZ(e) {
            this._localPosition.z = e, this.localPosition = this._localPosition;
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(e) {
            this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(Re.TRANSFORM_LOCALMATRIX, !0), 
            this._onWorldPositionTransform();
        }
        get localRotationX() {
            return this.localRotation.x;
        }
        set localRotationX(e) {
            this._localRotation.x = e, this.localRotation = this._localRotation;
        }
        get localRotationY() {
            return this.localRotation.y;
        }
        set localRotationY(e) {
            this._localRotation.y = e, this.localRotation = this._localRotation;
        }
        get localRotationZ() {
            return this.localRotation.z;
        }
        set localRotationZ(e) {
            this._localRotation.z = e, this.localRotation = this._localRotation;
        }
        get localRotationW() {
            return this.localRotation.w;
        }
        set localRotationW(e) {
            this._localRotation.w = e, this.localRotation = this._localRotation;
        }
        get localRotation() {
            if (this._getTransformFlag(Re.TRANSFORM_LOCALQUATERNION)) {
                var e = this._localRotationEuler;
                f.createFromYawPitchRoll(e.y / Re._angleToRandin, e.x / Re._angleToRandin, e.z / Re._angleToRandin, this._localRotation), 
                this._setTransformFlag(Re.TRANSFORM_LOCALQUATERNION, !1);
            }
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation), 
            this._setTransformFlag(Re.TRANSFORM_LOCALEULER | Re.TRANSFORM_LOCALMATRIX, !0), 
            this._setTransformFlag(Re.TRANSFORM_LOCALQUATERNION, !1), this._onWorldRotationTransform();
        }
        get localScaleX() {
            return this._localScale.x;
        }
        set localScaleX(e) {
            this._localScale.x = e, this.localScale = this._localScale;
        }
        get localScaleY() {
            return this._localScale.y;
        }
        set localScaleY(e) {
            this._localScale.y = e, this.localScale = this._localScale;
        }
        get localScaleZ() {
            return this._localScale.z;
        }
        set localScaleZ(e) {
            this._localScale.z = e, this.localScale = this._localScale;
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(e) {
            this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(Re.TRANSFORM_LOCALMATRIX, !0), 
            this._onWorldScaleTransform();
        }
        get localRotationEulerX() {
            return this.localRotationEuler.x;
        }
        set localRotationEulerX(e) {
            this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEulerY() {
            return this.localRotationEuler.y;
        }
        set localRotationEulerY(e) {
            this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEulerZ() {
            return this.localRotationEuler.z;
        }
        set localRotationEulerZ(e) {
            this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEuler() {
            if (this._getTransformFlag(Re.TRANSFORM_LOCALEULER)) {
                this._localRotation.getYawPitchRoll(Re._tempVector30);
                var e = Re._tempVector30, t = this._localRotationEuler;
                t.x = e.y * Re._angleToRandin, t.y = e.x * Re._angleToRandin, t.z = e.z * Re._angleToRandin, 
                this._setTransformFlag(Re.TRANSFORM_LOCALEULER, !1);
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(e) {
            this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(Re.TRANSFORM_LOCALEULER, !1), 
            this._setTransformFlag(Re.TRANSFORM_LOCALQUATERNION | Re.TRANSFORM_LOCALMATRIX, !0), 
            this._onWorldRotationTransform();
        }
        get localMatrix() {
            return this._getTransformFlag(Re.TRANSFORM_LOCALMATRIX) && (y.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix), 
            this._setTransformFlag(Re.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix;
        }
        set localMatrix(e) {
            this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale), 
            this._setTransformFlag(Re.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(Re.TRANSFORM_LOCALMATRIX, !1), 
            this._onWorldTransform();
        }
        get position() {
            if (this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION)) {
                if (null != this._parent) {
                    var e = this.worldMatrix.elements;
                    this._position.x = e[12], this._position.y = e[13], this._position.z = e[14];
                } else this._localPosition.cloneTo(this._position);
                this._setTransformFlag(Re.TRANSFORM_WORLDPOSITION, !1);
            }
            return this._position;
        }
        set position(e) {
            if (null != this._parent) {
                var t = Re._tempMatrix0;
                this._parent.worldMatrix.invert(t), n.transformCoordinate(e, t, this._localPosition);
            } else e.cloneTo(this._localPosition);
            this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position), 
            this._setTransformFlag(Re.TRANSFORM_WORLDPOSITION, !1);
        }
        get rotation() {
            return this._getTransformFlag(Re.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? f.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation), 
            this._setTransformFlag(Re.TRANSFORM_WORLDQUATERNION, !1)), this._rotation;
        }
        set rotation(e) {
            null != this._parent ? (this._parent.rotation.invert(Re._tempQuaternion0), f.multiply(Re._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation), 
            this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation), 
            this._setTransformFlag(Re.TRANSFORM_WORLDQUATERNION, !1);
        }
        get rotationEuler() {
            if (this._getTransformFlag(Re.TRANSFORM_WORLDEULER)) {
                this.rotation.getYawPitchRoll(Re._tempVector30);
                var e = Re._tempVector30, t = this._rotationEuler;
                t.x = e.y * Re._angleToRandin, t.y = e.x * Re._angleToRandin, t.z = e.z * Re._angleToRandin, 
                this._setTransformFlag(Re.TRANSFORM_WORLDEULER, !1);
            }
            return this._rotationEuler;
        }
        set rotationEuler(e) {
            f.createFromYawPitchRoll(e.y / Re._angleToRandin, e.x / Re._angleToRandin, e.z / Re._angleToRandin, this._rotation), 
            this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler), 
            this._setTransformFlag(Re.TRANSFORM_WORLDEULER, !1);
        }
        get worldMatrix() {
            return this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) && (null != this._parent ? y.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix), 
            this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix;
        }
        set worldMatrix(e) {
            null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix), 
            y.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix, 
            this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX, !1);
        }
        _getScaleMatrix() {
            var e = Re._tempQuaternion0, t = Re._tempMatrix3x30, r = Re._tempMatrix3x31, i = Re._tempMatrix3x32;
            return m.createFromMatrix4x4(this.worldMatrix, r), this.rotation.invert(e), m.createRotationQuaternion(e, t), 
            m.multiply(t, r, i), i;
        }
        _setTransformFlag(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }
        _getTransformFlag(e) {
            return 0 != (this._transformFlag & e);
        }
        _setParent(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children, r = t.indexOf(this);
                    t.splice(r, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }
        _onWorldPositionRotationTransform() {
            if (!(this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Re.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Re.TRANSFORM_WORLDEULER))) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDEULER, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }
        _onWorldPositionScaleTransform() {
            if (!this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Re.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDSCALE, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }
        _onWorldPositionTransform() {
            if (!this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION)) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDPOSITION, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionTransform();
            }
        }
        _onWorldRotationTransform() {
            if (!this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Re.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Re.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDEULER, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }
        _onWorldScaleTransform() {
            if (!this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Re.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDSCALE, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }
        _onWorldTransform() {
            if (!(this._getTransformFlag(Re.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Re.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Re.TRANSFORM_WORLDEULER) && this._getTransformFlag(Re.TRANSFORM_WORLDSCALE))) {
                this._setTransformFlag(Re.TRANSFORM_WORLDMATRIX | Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDEULER | Re.TRANSFORM_WORLDSCALE, !0), 
                this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
            }
        }
        translate(e, t = !0) {
            t ? (y.createFromQuaternion(this.localRotation, Re._tempMatrix0), n.transformCoordinate(e, Re._tempMatrix0, Re._tempVector30), 
            n.add(this.localPosition, Re._tempVector30, this._localPosition), this.localPosition = this._localPosition) : (n.add(this.position, e, this._position), 
            this.position = this._position);
        }
        rotate(e, t = !0, r = !0) {
            var i;
            r ? i = e : (n.scale(e, Math.PI / 180, Re._tempVector30), i = Re._tempVector30), 
            f.createFromYawPitchRoll(i.y, i.x, i.z, Re._tempQuaternion0), t ? (f.multiply(this._localRotation, Re._tempQuaternion0, this._localRotation), 
            this.localRotation = this._localRotation) : (f.multiply(Re._tempQuaternion0, this.rotation, this._rotation), 
            this.rotation = this._rotation);
        }
        getForward(e) {
            var t = this.worldMatrix.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }
        getUp(e) {
            var t = this.worldMatrix.elements;
            e.x = t[4], e.y = t[5], e.z = t[6];
        }
        getRight(e) {
            var t = this.worldMatrix.elements;
            e.x = t[0], e.y = t[1], e.z = t[2];
        }
        lookAt(e, t, i = !1) {
            var a;
            if (i) {
                if (a = this._localPosition, Math.abs(a.x - e.x) < r.zeroTolerance && Math.abs(a.y - e.y) < r.zeroTolerance && Math.abs(a.z - e.z) < r.zeroTolerance) return;
                f.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation), 
                this.localRotation = this._localRotation;
            } else {
                var n = this.position;
                if (a = n, Math.abs(a.x - e.x) < r.zeroTolerance && Math.abs(a.y - e.y) < r.zeroTolerance && Math.abs(a.z - e.z) < r.zeroTolerance) return;
                f.lookAt(n, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
            }
        }
        getWorldLossyScale() {
            if (this._getTransformFlag(Re.TRANSFORM_WORLDSCALE)) {
                if (null !== this._parent) {
                    var e = this._getScaleMatrix().elements;
                    this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8];
                } else this._localScale.cloneTo(this._scale);
                this._setTransformFlag(Re.TRANSFORM_WORLDSCALE, !1);
            }
            return this._scale;
        }
        setWorldLossyScale(e) {
            if (null !== this._parent) {
                var t = Re._tempMatrix3x33, r = Re._tempMatrix3x33, i = r.elements, a = this._parent._getScaleMatrix();
                a.invert(a), m.createFromScaling(e, t), m.multiply(a, t, r), this._localScale.x = i[0], 
                this._localScale.y = i[4], this._localScale.z = i[8];
            } else e.cloneTo(this._localScale);
            this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale), 
            this._setTransformFlag(Re.TRANSFORM_WORLDSCALE, !1);
        }
        get scale() {
            return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."), 
            this.getWorldLossyScale();
        }
        set scale(e) {
            console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."), 
            this.setWorldLossyScale(e);
        }
    }
    Re._tempVector30 = new n(), Re._tempQuaternion0 = new f(), Re._tempMatrix0 = new y(), 
    Re._tempMatrix3x30 = new m(), Re._tempMatrix3x31 = new m(), Re._tempMatrix3x32 = new m(), 
    Re._tempMatrix3x33 = new m(), Re.TRANSFORM_LOCALQUATERNION = 1, Re.TRANSFORM_LOCALEULER = 2, 
    Re.TRANSFORM_LOCALMATRIX = 4, Re.TRANSFORM_WORLDPOSITION = 8, Re.TRANSFORM_WORLDQUATERNION = 16, 
    Re.TRANSFORM_WORLDSCALE = 32, Re.TRANSFORM_WORLDMATRIX = 64, Re.TRANSFORM_WORLDEULER = 128, 
    Re._angleToRandin = 180 / Math.PI;
    class ve extends t.Node {
        constructor(e = null, t = !1) {
            super(), this._needProcessCollisions = !1, this._needProcessTriggers = !1, this._id = ++ve._uniqueIDCounter, 
            this._transform = new Re(this), this._isStatic = t, this.layer = 0, this.name = e || "New Sprite3D";
        }
        static __init__() {}
        static instantiate(e, t = null, r = !0, i = null, a = null) {
            var n = e.clone();
            t && t.addChild(n);
            var s = n.transform;
            if (r) {
                var o = s.worldMatrix;
                e.transform.worldMatrix.cloneTo(o), s.worldMatrix = o;
            } else i && (s.position = i), a && (s.rotation = a);
            return n;
        }
        static load(e, r) {
            t.Laya.loader.create(e, r, null, ve.HIERARCHY);
        }
        get id() {
            return this._id;
        }
        get layer() {
            return this._layer;
        }
        set layer(e) {
            if (this._layer !== e) {
                if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                this._layer = e;
            }
        }
        get url() {
            return this._url;
        }
        get isStatic() {
            return this._isStatic;
        }
        get transform() {
            return this._transform;
        }
        _setCreateURL(e) {
            this._url = t.URL.formatURL(e);
        }
        _changeAnimatorsToLinkSprite3D(e, t, r) {
            var i = this.getComponent(P);
            if (i && (i.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(i, t, r)), this._parent && this._parent instanceof ve) {
                r.unshift(this._parent.name);
                var a = this._parent;
                a._hierarchyAnimator && a._changeAnimatorsToLinkSprite3D(e, t, r);
            }
        }
        _setHierarchyAnimator(e, t) {
            this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var a = this._children[r];
                a._hierarchyAnimator == t && a._setHierarchyAnimator(e, t);
            }
        }
        _clearHierarchyAnimator(e, t) {
            this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var a = this._children[r];
                a._hierarchyAnimator == e && a._clearHierarchyAnimator(e, t);
            }
        }
        _changeHierarchyAnimatorAvatar(e, t) {
            this._changeAnimatorAvatar(t);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var a = this._children[r];
                a._hierarchyAnimator == e && a._changeHierarchyAnimatorAvatar(e, t);
            }
        }
        _changeAnimatorToLinkSprite3DNoAvatar(e, t, r) {
            e._handleSpriteOwnersBySprite(t, r, this);
            for (var i = 0, a = this._children.length; i < a; i++) {
                var n = this._children[i], s = r.length;
                r.push(n.name), n._changeAnimatorToLinkSprite3DNoAvatar(e, t, r), r.splice(s, 1);
            }
        }
        _changeHierarchyAnimator(e) {
            this._hierarchyAnimator = e;
        }
        _changeAnimatorAvatar(e) {}
        _onAdded() {
            if (this._parent instanceof ve) {
                var e = this._parent;
                this.transform._setParent(e.transform), e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null), 
                e._changeAnimatorsToLinkSprite3D(this, !0, [ this.name ]));
            }
            super._onAdded();
        }
        _onRemoved() {
            if (super._onRemoved(), this._parent instanceof ve) {
                var e = this._parent;
                this.transform._setParent(null), e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null), 
                e._changeAnimatorsToLinkSprite3D(this, !1, [ this.name ]));
            }
        }
        _parse(e, t) {
            if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active), 
            null != e.name && (this.name = e.name), void 0 !== e.position) {
                var r = this.transform.localPosition;
                r.fromArray(e.position), this.transform.localPosition = r;
            }
            if (void 0 !== e.rotationEuler) {
                var i = this.transform.localRotationEuler;
                i.fromArray(e.rotationEuler), this.transform.localRotationEuler = i;
            }
            if (void 0 !== e.rotation) {
                var a = this.transform.localRotation;
                a.fromArray(e.rotation), this.transform.localRotation = a;
            }
            if (void 0 !== e.scale) {
                var n = this.transform.localScale;
                n.fromArray(e.scale), this.transform.localScale = n;
            }
            null != e.layer && (this.layer = e.layer);
        }
        _cloneTo(e, t, r) {
            if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
            var i = e, a = this._transform, n = i._transform;
            i.name = this.name, i.destroyed = this.destroyed, i.active = this.active, n.localPosition = a.localPosition, 
            n.localRotation = a.localRotation, n.localScale = a.localScale, i._isStatic = this._isStatic, 
            i.layer = this.layer, super._cloneTo(i, t, r);
        }
        static _createSprite3DInstance(e) {
            for (var t = e._create(), r = e._children, i = 0, a = r.length; i < a; i++) {
                var n = ve._createSprite3DInstance(r[i]);
                t.addChild(n);
            }
            return t;
        }
        static _parseSprite3DInstance(e, t, r, i) {
            for (var a = r._children, n = i._children, s = 0, o = a.length; s < o; s++) ve._parseSprite3DInstance(e, t, a[s], n[s]);
            r._cloneTo(i, e, t);
        }
        clone() {
            var e = ve._createSprite3DInstance(this);
            return ve._parseSprite3DInstance(this, e, this, e), e;
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._transform = null, this._scripts = null, 
            this._url && t.Loader.clearRes(this._url));
        }
        _create() {
            return new ve();
        }
    }
    ve.HIERARCHY = "HIERARCHY", ve.WORLDMATRIX = H.propertyNameToID("u_WorldMat"), ve.MVPMATRIX = H.propertyNameToID("u_MvpMatrix"), 
    ve._uniqueIDCounter = 0;
    class xe extends ve {
        constructor(e) {
            super(e);
        }
        static __init__() {
            xe.SHADERDEFINE_RECEIVE_SHADOW = H.getDefineByName("RECEIVESHADOW"), xe.SAHDERDEFINE_LIGHTMAP = H.getDefineByName("LIGHTMAP"), 
            xe.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = H.getDefineByName("LIGHTMAP_DIRECTIONAL");
        }
        _onInActive() {
            super._onInActive(), this._scene._removeRenderObject(this._render);
        }
        _onActive() {
            super._onActive(), this._scene._addRenderObject(this._render);
        }
        _onActiveInScene() {
            if (super._onActiveInScene(), _.Laya3D._editerEnvironment) {
                var e = this._scene, t = new a();
                e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(xe.PICKCOLOR, t);
            }
        }
        _addToInitStaticBatchManager() {}
        _setBelongScene(e) {
            super._setBelongScene(e), this._render._setBelongScene(e);
        }
        _setUnBelongScene() {
            this._render._shaderValues.removeDefine(xe.SAHDERDEFINE_LIGHTMAP), super._setUnBelongScene();
        }
        _changeHierarchyAnimator(e) {
            if (this._hierarchyAnimator) {
                var t = this._hierarchyAnimator._renderableSprites;
                t.splice(t.indexOf(this), 1);
            }
            e && e._renderableSprites.push(this), super._changeHierarchyAnimator(e);
        }
        destroy(e = !0) {
            super.destroy(e), this._render._destroy(), this._render = null;
        }
        _create() {
            return new xe(this.name);
        }
    }
    xe.LIGHTMAPSCALEOFFSET = H.propertyNameToID("u_LightmapScaleOffset"), xe.LIGHTMAP = H.propertyNameToID("u_LightMap"), 
    xe.LIGHTMAP_DIRECTION = H.propertyNameToID("u_LightMapDirection"), xe.PICKCOLOR = H.propertyNameToID("u_PickColor");
    class Ie {
        constructor() {
            this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0, 
            this._batchRenderElementPool = [];
        }
        static _addToStaticBatchQueue(e, t) {
            e instanceof xe && t.push(e);
            for (var r = 0, i = e.numChildren; r < i; r++) Ie._addToStaticBatchQueue(e._children[r], t);
        }
        static _registerManager(e) {
            Ie._managers.push(e);
        }
        static combine(e, t = null) {
            t || (t = [], e && Ie._addToStaticBatchQueue(e, t));
            var r = t.length;
            if (r > 0) {
                for (var i = 0; i < r; i++) {
                    var a = t[i];
                    a.destroyed || (a._render._isPartOfStaticBatch ? console.warn("StaticBatchManager: Sprite " + a.name + " has a part of Static Batch,it will be ignore.") : a._addToInitStaticBatchManager());
                }
                for (var n = 0, s = Ie._managers.length; n < s; n++) {
                    Ie._managers[n]._initStaticBatchs(e);
                }
            }
        }
        _partition(e, t, r) {
            for (var i = e[Math.floor((r + t) / 2)]; t <= r; ) {
                for (;this._compare(e[t], i) < 0; ) t++;
                for (;this._compare(e[r], i) > 0; ) r--;
                if (t < r) {
                    var a = e[t];
                    e[t] = e[r], e[r] = a, t++, r--;
                } else if (t === r) {
                    t++;
                    break;
                }
            }
            return t;
        }
        _quickSort(e, t, r) {
            if (e.length > 1) {
                var i = this._partition(e, t, r), a = i - 1;
                t < a && this._quickSort(e, t, a), i < r && this._quickSort(e, i, r);
            }
        }
        _compare(e, t) {
            throw "StaticBatch:must override this function.";
        }
        _initStaticBatchs(e) {
            throw "StaticBatch:must override this function.";
        }
        _getBatchRenderElementFromPool() {
            throw "StaticBatch:must override this function.";
        }
        _addBatchSprite(e) {
            this._initBatchSprites.push(e);
        }
        _clear() {
            this._batchRenderElementPoolIndex = 0;
        }
        _garbageCollection() {
            throw "StaticBatchManager: must override it.";
        }
        dispose() {
            this._staticBatches = null;
        }
    }
    Ie._managers = [];
    class Ae {}
    class Le {}
    class Ce {
        static __init__() {
            t.Render.supportWebGLPlusCulling && (Ce._cullingBufferLength = 0, Ce._cullingBuffer = new Float32Array(4096));
        }
        static _drawTraversalCullingBound(e, t) {
            for (var r = e.elements, i = 0, a = e.length; i < a; i++) {
                var n = Ce._tempColor0;
                n.r = 0, n.g = 1, n.b = 0, n.a = 1, I._drawBound(t, r[i].bounds._getBoundBox(), n);
            }
        }
        static _traversalCulling(e, r, i, a, s, o, l) {
            for (var _ = a.elements, h = e.boundFrustum, c = e.position, d = e.cullingMask, u = t.Stat.loopCount, m = 0, f = a.length; m < f; m++) {
                var E = _[m];
                if ((l ? E._castShadow && E._enable : 0 != (Math.pow(2, E._owner._layer) & d) && E._enable) && (t.Stat.frustumCulling++, 
                !e.useOcclusionCulling || E._needRender(h, i))) {
                    E._renderMark = u, E._distanceForSort = n.distance(E.bounds.getCenter(), c);
                    for (var T = E._renderElements, p = 0, g = T.length; p < g; p++) T[p]._update(r, i, s, o);
                }
            }
        }
        static renderObjectCulling(e, t, r, i, a, n) {
            var s, o, l = t._opaqueQueue, _ = t._transparentQueue, h = t._renders;
            l.clear(), _.clear();
            var c = Ie._managers;
            for (s = 0, o = c.length; s < o; s++) c[s]._clear();
            var d = Se._managers;
            for (s = 0, o = d.length; s < o; s++) d[s]._clear();
            var u = t._octree;
            if (u && (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(e, r, i, a, n)), 
            Ce._traversalCulling(e, t, r, h, i, a, n), Ce.debugFrustumCulling) {
                var m = t._debugTool;
                m.clear(), u && (u.drawAllBounds(m), u.drawAllObjects(m)), Ce._drawTraversalCullingBound(h, m);
            }
            var f = l.elements.length;
            f > 0 && l._quickSort(0, f - 1), (f = _.elements.length) > 0 && _._quickSort(0, f - 1);
        }
        static cullingShadow(e, r, i) {
            var a = r._opaqueQueue, s = r._transparentQueue, o = r._renders;
            a.clear(), s.clear();
            for (var l = Ie._managers, _ = 0, h = l.length; _ < h; _++) l[_]._clear();
            var c = Se._managers;
            for (_ = 0, h = c.length; _ < h; _++) c[_]._clear();
            o = r._renders;
            var d = e.position, u = e.cullPlaneCount, m = e.cullPlanes, f = (e.cullSphere, e.direction, 
            o.elements), E = t.Stat.loopCount;
            for (_ = 0, h = o.length; _ < h; _++) {
                var T = f[_];
                if (T._castShadow && T._enable) {
                    t.Stat.frustumCulling++;
                    for (var p = T.bounds, g = p.getMin(), S = p.getMax(), R = g.x, v = g.y, x = g.z, I = S.x, A = S.y, L = S.z, C = !0, D = 0; D < u; D++) {
                        var M = m[D], y = M.normal;
                        if (M.distance + y.x * (y.x < 0 ? R : I) + y.y * (y.y < 0 ? v : A) + y.z * (y.z < 0 ? x : L) < 0) {
                            C = !1;
                            break;
                        }
                    }
                    if (C) {
                        T._renderMark = E, T._distanceForSort = n.distance(p.getCenter(), d);
                        for (var O = T._renderElements, N = (D = 0, O.length); D < N; D++) O[D]._update(r, i, null, null);
                    }
                }
            }
            return a.elements.length > 0;
        }
        static renderObjectCullingNative(e, r, i, a, s, o) {
            var l, _, h, c, d = r._opaqueQueue, u = r._transparentQueue;
            d.clear(), u.clear();
            var m = Ie._managers;
            for (l = 0, _ = m.length; l < _; l++) m[l]._clear();
            var f = Se._managers;
            for (l = 0, _ = f.length; l < _; l++) f[l]._clear();
            var E = a.length, T = a.elements;
            for (l = 0; l < E; l++) T[l].bounds, T[l]._updateForNative && T[l]._updateForNative(i);
            e.boundFrustum;
            Ce.cullingNative(e._boundFrustumBuffer, Ce._cullingBuffer, r._cullingBufferIndices, E, r._cullingBufferResult);
            var p = t.Stat.loopCount, g = i.camera._transform.position;
            for (l = 0; l < E; l++) {
                var S = T[l];
                if (!e.useOcclusionCulling || e._isLayerVisible(S._owner._layer) && S._enable && r._cullingBufferResult[l]) {
                    S._renderMark = p, S._distanceForSort = n.distance(S.bounds.getCenter(), g);
                    var R = S._renderElements;
                    for (h = 0, c = R.length; h < c; h++) {
                        R[h]._update(r, i, s, o);
                    }
                }
            }
            var v = d.elements.length;
            v > 0 && d._quickSort(0, v - 1), (v = u.elements.length) > 0 && u._quickSort(0, v - 1);
        }
        static cullingNative(e, r, i, a, n) {
            return t.LayaGL.instance.culling(e, r, i, a, n);
        }
    }
    Ce._tempColor0 = new ge(), Ce._tempVector0 = new n(), Ce._cameraCullInfo = new Ae(), 
    Ce._shadowCullInfo = new Le(), Ce.debugFrustumCulling = !1;
    class De {
        constructor() {
            this.updateMark = -1, this.pointLightCount = 0, this.spotLightCount = 0, this.indices = [];
        }
    }
    class Me {
        constructor(e, t, r, a) {
            this._updateMark = 0, this._depthSliceParam = new i(), this._xSlices = e, this._ySlices = t, 
            this._zSlices = r;
            var n = e * t, s = r * (1 + Math.ceil(a / 4));
            this._clusterTexture = I._createFloatTextureBuffer(n, s), this._clusterTexture.lock = !0, 
            this._clusterPixels = new Float32Array(n * s * 4);
            for (var o = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
                o[l] = new Array(this._ySlices);
                for (var _ = 0; _ < this._ySlices; _++) {
                    o[l][_] = new Array(this._xSlices);
                    for (var h = 0; h < this._xSlices; h++) o[l][_][h] = new De();
                }
            }
            this._clusterDatas = o;
        }
        _insertSpotLightSphere(e, t, r, i, a) {
            var s = Me._tempVector35;
            s.x = a.x - e.x, s.y = a.y - e.y, s.z = a.z - e.z;
            var o = n.dot(s, s), l = a.w;
            if (!(o > l * l)) return !1;
            var _ = n.dot(s, t);
            return !(Math.cos(i) * Math.sqrt(o - _ * _) - _ * Math.sin(i) > l || _ > l + r || _ < -l);
        }
        _placePointLightToClusters(e, t) {
            for (var r = this._clusterDatas, i = this._updateMark, a = t.zMin, n = t.zMax; a < n; a++) for (var s = t.yMin, o = t.yMax; s < o; s++) for (var l = t.xMin, _ = t.xMax; l < _; l++) {
                var h = r[a][s][l];
                h.updateMark != i && (h.pointLightCount = 0, h.spotLightCount = 0, h.updateMark = i);
                var c = h.indices, d = h.pointLightCount++;
                d < c.length ? c[d] = e : c.push(e);
            }
        }
        _placeSpotLightToClusters(e, t) {
            for (var r = this._clusterDatas, i = this._updateMark, a = t.zMin, n = t.zMax; a < n; a++) for (var s = t.yMin, o = t.yMax; s < o; s++) for (var l = t.xMin, _ = t.xMax; l < _; l++) {
                var h = r[a][s][l];
                h.updateMark != i && (h.pointLightCount = 0, h.spotLightCount = 0, h.updateMark = i);
                var c = h.indices, d = h.pointLightCount + h.spotLightCount++;
                d < c.length ? c[d] = e : c.push(e);
            }
        }
        _insertConePlane(e, t, r, i, a) {
            var s = Me._tempVector36, o = Me._tempVector37;
            n.cross(a, t, s), n.cross(s, t, o), n.normalize(o, o);
            var l = r * Math.tan(i), _ = e.x + r * t.x + l * o.x, h = e.y + r * t.y + l * o.y, c = e.z + r * t.z + l * o.z;
            return _ * a.x + h * a.y + c * a.z <= 0 || e.x * a.x + e.y * a.y + e.z * a.z <= 0;
        }
        _shrinkSphereLightZPerspective(e, t, r, i, a) {
            var n = r.z, s = n - i, o = n + i;
            if (s > t || o <= e) return !1;
            var l = this._depthSliceParam;
            return a.zMin = Math.floor(Math.log2(Math.max(s, e)) * l.x - l.y), a.zMax = Math.min(Math.ceil(Math.log2(o) * l.x - l.y), this._zSlices), 
            !0;
        }
        _shrinkSpotLightZPerspective(e, t, r, i, a, n, s) {
            var o = i.x, l = i.y, _ = i.z, h = Math.tan(n) * a, c = r.x, d = r.y, u = r.z, m = o - c, f = l - d, E = _ - u, T = m * m + f * f + E * E, p = Math.sqrt(1 - E * E / T), g = Math.max(Math.min(u, _ - p * h), r.z - a), S = Math.min(Math.max(u, _ + p * h), r.z + a);
            if (g > t || S <= e) return !1;
            var R = this._depthSliceParam;
            return s.zMin = Math.floor(Math.log2(Math.max(g, e)) * R.x - R.y), s.zMax = Math.min(Math.ceil(Math.log2(S) * R.x - R.y), this._zSlices), 
            !0;
        }
        _shrinkSphereLightByBoundOrth(e, t, r, i, a, n, s) {
            var o = a.z, l = o - n, _ = o + n;
            if (l > i || _ <= r) return !1;
            var h = a.x, c = h - n, d = h + n;
            if (c > e || d <= -e) return !1;
            var u = a.y, m = u - n, f = u + n;
            if (m > t || f <= -t) return !1;
            var E = this._xSlices, T = this._ySlices, p = this._depthSliceParam, g = 2 * e / E, S = 2 * t / T;
            return s.xMin = Math.max(Math.floor((c + e) / g), 0), s.xMax = Math.min(Math.ceil((d + e) / g), E), 
            s.yMin = Math.max(Math.floor((t - f) / S), 0), s.yMax = Math.min(Math.ceil((t - m) / S), T), 
            s.zMin = Math.floor(Math.log2(Math.max(l, r)) * p.x - p.y), s.zMax = Math.min(Math.ceil(Math.log2(_) * p.x - p.y), this._zSlices), 
            !0;
        }
        _shrinkSpotLightByBoundOrth(e, t, r, i, a, n, s, o, l) {
            var _ = n.x, h = n.y, c = n.z, d = Math.tan(o) * s, u = a.x, m = a.y, f = a.z, E = _ - u, T = h - m, p = c - f, g = E * E + T * T + p * p, S = Math.sqrt(1 - p * p / g), R = Math.max(Math.min(f, c - S * d), a.z - s), v = Math.min(Math.max(f, c + S * d), a.z + s);
            if (R > i || v <= r) return !1;
            var x = Math.sqrt(1 - E * E / g), I = Math.max(Math.min(u, _ - x * d), a.x - s), A = Math.min(Math.max(u, _ + x * d), a.x + s);
            if (I > e || A <= -e) return !1;
            var L = Math.sqrt(1 - T * T / g), C = Math.max(Math.min(m, h - L * d), a.y - s), D = Math.min(Math.max(m, h + L * d), a.y + s);
            if (C > t || D <= -t) return !1;
            var M = this._xSlices, y = this._ySlices, O = this._depthSliceParam, N = 2 * e / M, b = 2 * t / y;
            return l.xMin = Math.max(Math.floor((I + e) / N), 0), l.xMax = Math.min(Math.ceil((A + e) / N), M), 
            l.yMin = Math.max(Math.floor((t - D) / b), 0), l.yMax = Math.min(Math.ceil((t - C) / b), y), 
            l.zMin = Math.floor(Math.log2(Math.max(R, r)) * O.x - O.y), l.zMax = Math.min(Math.ceil(Math.log2(v) * O.x - O.y), this._zSlices), 
            !0;
        }
        _shrinkXYByRadiusPerspective(e, t, r, i, a) {
            var n, s, o, l, _, h = e.x, c = e.y, d = e.z, u = this._ySlices + 1;
            for (_ = 0; _ < u; _++) {
                if (c * (m = a[_]).y + d * m.z < t) {
                    s = Math.max(0, _ - 1);
                    break;
                }
            }
            if (_ == u) return !1;
            for (l = this._ySlices, _ = s + 1; _ < u; _++) {
                if (c * (m = a[_]).y + d * m.z <= -t) {
                    l = Math.max(0, _);
                    break;
                }
            }
            for (u = this._xSlices + 1, _ = 0; _ < u; _++) {
                if (h * (m = i[_]).x + d * m.z < t) {
                    n = Math.max(0, _ - 1);
                    break;
                }
            }
            for (o = this._xSlices, _ = n + 1; _ < u; _++) {
                var m;
                if (h * (m = i[_]).x + d * m.z <= -t) {
                    o = Math.max(0, _);
                    break;
                }
            }
            return r.xMin = n, r.xMax = o, r.yMin = s, r.yMax = l, !0;
        }
        _shrinkSpotXYByConePerspective(e, t, r, i, a, n, s) {
            for (var o, l, _, h, c = Me._tempVector32, d = a.yMax + 1, u = a.yMin + 1; u < d; u++) if (this._insertConePlane(e, t, r, i, s[u])) {
                l = Math.max(0, u - 1);
                break;
            }
            h = a.yMax;
            for (u = l + 1; u < d; u++) {
                var m = s[u];
                if (c.setValue(0, -m.y, -m.z), !this._insertConePlane(e, t, r, i, c)) {
                    h = Math.max(0, u);
                    break;
                }
            }
            d = a.xMax + 1;
            for (u = a.xMin + 1; u < d; u++) if (this._insertConePlane(e, t, r, i, n[u])) {
                o = Math.max(0, u - 1);
                break;
            }
            _ = a.xMax;
            for (u = o + 1; u < d; u++) {
                m = n[u];
                if (c.setValue(-m.x, 0, -m.z), !this._insertConePlane(e, t, r, i, c)) {
                    _ = Math.max(0, u);
                    break;
                }
            }
            a.xMin = o, a.xMax = _, a.yMin = l, a.yMax = h;
        }
        _updatePointLightPerspective(e, t, r, i, a, s, o) {
            var l = Me._tempLightBound, _ = Me._tempVector30;
            n.transformV3ToV3(i._transform.position, r, _), _.z *= -1, this._shrinkSphereLightZPerspective(e, t, _, i.range, l) && this._shrinkXYByRadiusPerspective(_, i.range, l, s, o) && this._placePointLightToClusters(a, l);
        }
        _updateSpotLightPerspective(e, t, r, i, a, s, o) {
            var l = Me._tempLightBound, _ = Me._tempVector30, h = Me._tempVector31, c = Me._tempVector34, d = i._transform.position, u = i.range;
            i._transform.worldMatrix.getForward(h), n.normalize(h, h), n.scale(h, u, c), n.add(d, c, c), 
            n.transformV3ToV3(d, r, _), n.transformV3ToV3(c, r, c), _.z *= -1, c.z *= -1;
            var m = i.spotAngle / 2 * Math.PI / 180;
            if (this._shrinkSpotLightZPerspective(e, t, _, c, u, m, l) && this._shrinkXYByRadiusPerspective(_, u, l, s, o)) {
                var f = Me._tempVector33;
                f.x = c.x - _.x, f.y = c.y - _.y, f.z = c.z - _.z, n.normalize(f, f), this._shrinkSpotXYByConePerspective(_, f, u, m, l, s, o), 
                this._placeSpotLightToClusters(a, l);
            }
        }
        _updatePointLightOrth(e, t, r, i, a, s, o) {
            var l = Me._tempLightBound, _ = Me._tempVector30;
            n.transformV3ToV3(s._transform.position, a, _), _.z *= -1, this._shrinkSphereLightByBoundOrth(e, t, r, i, _, s.range, l) && this._placePointLightToClusters(o, l);
        }
        _updateSpotLightOrth(e, t, r, i, a, s, o) {
            var l = Me._tempLightBound, _ = Me._tempVector30, h = Me._tempVector31, c = Me._tempVector34, d = s._transform.position, u = s.range;
            s._transform.worldMatrix.getForward(h), n.normalize(h, h), n.scale(h, u, c), n.add(d, c, c), 
            n.transformV3ToV3(d, a, _), n.transformV3ToV3(c, a, c), _.z *= -1, c.z *= -1;
            var m = s.spotAngle / 2 * Math.PI / 180;
            this._shrinkSpotLightByBoundOrth(e, t, r, i, _, c, u, m, l) && this._placeSpotLightToClusters(o, l);
        }
        update(e, t) {
            this._updateMark++;
            var r = e.nearPlane;
            this._depthSliceParam.x = l._config.lightClusterCount.z / Math.log2(e.farPlane / r), 
            this._depthSliceParam.y = Math.log2(r) * this._depthSliceParam.x;
            var i = e.nearPlane, a = e.farPlane, n = e.viewMatrix, s = t._directionLights._length, o = t._pointLights, _ = o._length, h = o._elements, c = t._spotLights, d = c._length, u = c._elements;
            if (e.orthographic) {
                for (var m = e.orthographicVerticalSize / 2, f = m * e.aspectRatio, E = 0; E < _; E++, 
                s++) this._updatePointLightOrth(f, m, i, a, n, h[E], s);
                for (E = 0; E < d; E++, s++) this._updateSpotLightOrth(f, m, i, a, n, u[E], s);
            } else {
                e._updateClusterPlaneXY();
                var T = e._clusterXPlanes, p = e._clusterYPlanes;
                for (E = 0; E < _; E++, s++) this._updatePointLightPerspective(i, a, n, h[E], s, T, p);
                for (E = 0; E < d; E++, s++) this._updateSpotLightPerspective(i, a, n, u[E], s, T, p);
            }
            if (_ + d > 0) {
                for (var g = this._xSlices, S = this._ySlices, R = this._zSlices, v = g * S * 4, x = v * R, I = this._clusterPixels, A = I.length, L = this._clusterDatas, C = this._updateMark, D = !0, M = 0; M < R; M++) for (var y = 0; y < S; y++) for (var O = 0; O < g; O++) {
                    var N = L[M][y][O], b = 4 * (O + y * g + M * g * S);
                    if (N.updateMark !== C) I[b] = 0, I[b + 1] = 0; else if (D) {
                        var P = N.indices, w = N.pointLightCount, V = N.spotLightCount, B = w + V;
                        if (x + B < A) {
                            I[b] = w, I[b + 1] = V, I[b + 2] = Math.floor(x / v), I[b + 3] = x % v;
                            for (E = 0; E < B; E++) I[x++] = P[E];
                        } else {
                            B = A - (x + B), w = Math.min(w, B), I[b] = w, I[b + 1] = Math.min(V, B - w), I[b + 2] = Math.floor(x / v), 
                            I[b + 3] = x % v;
                            for (E = 0; E < B; E++) I[x++] = P[E];
                            D = !1;
                        }
                    }
                }
                var F = this._clusterTexture.width;
                this._clusterTexture.setSubPixels(0, 0, F, Math.ceil(x / (4 * F)), I);
            }
        }
    }
    Me._tempVector30 = new n(), Me._tempVector31 = new n(), Me._tempVector32 = new n(), 
    Me._tempVector33 = new n(), Me._tempVector34 = new n(), Me._tempVector35 = new n(), 
    Me._tempVector36 = new n(), Me._tempVector37 = new n(), Me._tempLightBound = new class {}();
    class ye {
        constructor() {
            this._coefficients = new Float32Array(27);
        }
        getCoefficient(e, t) {
            return this._coefficients[9 * e + t];
        }
        setCoefficient(e, t, r) {
            this._coefficients[9 * e + t] = r;
        }
        setCoefficients(e, t, r, i, a, n, s, o, l, _) {
            var h = 9 * e;
            this._coefficients[h] = t, this._coefficients[++h] = r, this._coefficients[++h] = i, 
            this._coefficients[++h] = a, this._coefficients[++h] = n, this._coefficients[++h] = s, 
            this._coefficients[++h] = o, this._coefficients[++h] = l, this._coefficients[++h] = _;
        }
        cloneTo(e) {
            if (this !== e) for (var t = this._coefficients, r = e._coefficients, i = 0; i < 27; i++) r[i] = t[i];
        }
    }
    ye._default = new ye();
    class Oe {
        constructor() {
            this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0, 
            this.mousePositionY = 0;
        }
    }
    class Ne {
        constructor() {
            this._indexInList = -1, this._identifier = -1, this._position = new i();
        }
        get identifier() {
            return this._identifier;
        }
        get position() {
            return this._position;
        }
        _getIndexInList() {
            return this._indexInList;
        }
        _setIndexInList(e) {
            this._indexInList = e;
        }
    }
    class be {
        constructor(e, t = 0) {
            this.normal = e, this.distance = t;
        }
        static createPlaneBy3P(e, t, r, i) {
            var a = t.x - e.x, n = t.y - e.y, s = t.z - e.z, o = r.x - e.x, l = r.y - e.y, _ = r.z - e.z, h = n * _ - s * l, c = s * o - a * _, d = a * l - n * o, u = 1 / Math.sqrt(h * h + c * c + d * d), m = h * u, f = c * u, E = d * u, T = i.normal;
            T.x = m, T.y = f, T.z = E, i.distance = -(m * e.x + f * e.y + E * e.z);
        }
        normalize() {
            var e = this.normal.x, t = this.normal.y, r = this.normal.z, i = 1 / Math.sqrt(e * e + t * t + r * r);
            this.normal.x = e * i, this.normal.y = t * i, this.normal.z = r * i, this.distance *= i;
        }
        cloneTo(e) {
            var t = e;
            this.normal.cloneTo(t.normal), t.distance = this.distance;
        }
        clone() {
            var e = new be(new n());
            return this.cloneTo(e), e;
        }
    }
    be.PlaneIntersectionType_Back = 0, be.PlaneIntersectionType_Front = 1, be.PlaneIntersectionType_Intersecting = 2;
    class Pe {
        constructor(e, t) {
            this.origin = e, this.direction = t;
        }
    }
    class we {}
    we.Disjoint = 0, we.Contains = 1, we.Intersects = 2;
    class Ve {
        constructor() {}
        static distancePlaneToPoint(e, t) {
            return n.dot(e.normal, t) - e.distance;
        }
        static distanceBoxToPoint(e, t) {
            var r = e.min, i = r.x, a = r.y, n = r.z, s = e.max, o = s.x, l = s.y, _ = s.z, h = t.x, c = t.y, d = t.z, u = 0;
            return h < i && (u += (i - h) * (i - h)), h > o && (u += (o - h) * (o - h)), c < a && (u += (a - c) * (a - c)), 
            c > l && (u += (l - c) * (l - c)), d < n && (u += (n - d) * (n - d)), d > _ && (u += (_ - d) * (_ - d)), 
            Math.sqrt(u);
        }
        static distanceBoxToBox(e, t) {
            var r, i = e.min, a = i.x, n = i.y, s = i.z, o = e.max, l = o.x, _ = o.y, h = o.z, c = t.min, d = c.x, u = c.y, m = c.z, f = t.max, E = f.x, T = f.y, p = f.z, g = 0;
            return a > E ? g += (r = a - E) * r : d > l && (g += (r = d - l) * r), n > T ? g += (r = n - T) * r : u > _ && (g += (r = u - _) * r), 
            s > p ? g += (r = s - p) * r : m > h && (g += (r = m - h) * r), Math.sqrt(g);
        }
        static distanceSphereToPoint(e, t) {
            var r = Math.sqrt(n.distanceSquared(e.center, t));
            return r -= e.radius, Math.max(r, 0);
        }
        static distanceSphereToSphere(e, t) {
            var r = Math.sqrt(n.distanceSquared(e.center, t.center));
            return r -= e.radius + t.radius, Math.max(r, 0);
        }
        static intersectsRayAndTriangleRD(e, t, i, a, n) {
            var s = e.origin, o = s.x, l = s.y, _ = s.z, h = e.direction, c = h.x, d = h.y, u = h.z, m = t.x, f = t.y, E = t.z, T = i.x, p = i.y, g = i.z, S = a.x, R = a.y, v = a.z, x = Ve._tempV30.x, I = Ve._tempV30.y, A = Ve._tempV30.z;
            x = T - m, I = p - f, A = g - E;
            var L = Ve._tempV31.x, C = Ve._tempV31.y, D = Ve._tempV31.z;
            L = S - m, C = R - f, D = v - E;
            var M = Ve._tempV32.x, y = Ve._tempV32.y, O = Ve._tempV32.z, N = x * (M = d * D - u * C) + I * (y = u * L - c * D) + A * (O = c * C - d * L);
            if (r.isZero(N)) return !1;
            var b = 1 / N, P = Ve._tempV33.x, w = Ve._tempV33.y, V = Ve._tempV33.z, B = (P = o - m) * M + (w = l - f) * y + (V = _ - E) * O;
            if ((B *= b) < 0 || B > 1) return !1;
            var F = Ve._tempV34.x, U = Ve._tempV34.y, G = Ve._tempV34.z, z = c * (F = w * A - V * I) + d * (U = V * x - P * A) + u * (G = P * I - w * x);
            if ((z *= b) < 0 || B + z > 1) return !1;
            var H = L * F + C * U + D * G;
            return !((H *= b) < 0);
        }
        static intersectsRayAndTriangleRP(e, t, r, i, a) {
            return Ve.intersectsRayAndTriangleRD(e, t, r, i, void 0) ? (n.scale(e.direction, void 0, Ve._tempV30), 
            n.add(e.origin, Ve._tempV30, a), !0) : (a = n._ZERO, !1);
        }
        static intersectsRayAndPoint(e, t) {
            n.subtract(e.origin, t, Ve._tempV30);
            var i = n.dot(Ve._tempV30, e.direction), a = n.dot(Ve._tempV30, Ve._tempV30) - r.zeroTolerance;
            return !(a > 0 && i > 0) && !(i * i - a < 0);
        }
        static intersectsRayAndRay(e, t, i) {
            var a = e.origin, s = a.x, o = a.y, l = a.z, _ = e.direction, h = _.x, c = _.y, d = _.z, u = t.origin, m = u.x, f = u.y, E = u.z, T = t.direction, p = T.x, g = T.y, S = T.z;
            n.cross(_, T, Ve._tempV30);
            var R = Ve._tempV30, v = n.scalarLength(Ve._tempV30);
            if (r.isZero(v) && r.nearEqual(m, s) && r.nearEqual(f, o) && r.nearEqual(E, l)) return !0;
            v *= v;
            var x = m - s, I = f - o, A = E - l, L = p, C = g, D = S, M = R.x, y = R.y, O = R.z, N = x * C * O + I * D * M + A * L * y - x * D * y - I * L * O - A * C * M;
            L = h, C = c, D = d;
            var b = N / v;
            n.scale(_, b, Ve._tempV30), n.scale(T, b, Ve._tempV31), n.add(a, Ve._tempV30, Ve._tempV32), 
            n.add(u, Ve._tempV31, Ve._tempV33);
            var P = Ve._tempV32, w = Ve._tempV33;
            return !!(r.nearEqual(w.x, P.x) && r.nearEqual(w.y, P.y) && r.nearEqual(w.z, P.z));
        }
        static intersectsPlaneAndTriangle(e, t, r, i) {
            var a = Ve.intersectsPlaneAndPoint(e, t), n = Ve.intersectsPlaneAndPoint(e, r), s = Ve.intersectsPlaneAndPoint(e, i);
            return a == be.PlaneIntersectionType_Front && n == be.PlaneIntersectionType_Front && s == be.PlaneIntersectionType_Front ? be.PlaneIntersectionType_Front : a == be.PlaneIntersectionType_Back && n == be.PlaneIntersectionType_Back && s == be.PlaneIntersectionType_Back ? be.PlaneIntersectionType_Back : be.PlaneIntersectionType_Intersecting;
        }
        static intersectsRayAndPlaneRD(e, t) {
            var i = t.normal, a = n.dot(i, e.direction);
            if (Math.abs(a) < r.zeroTolerance) return -1;
            var s = n.dot(i, e.origin), o = (-t.distance - s) / a;
            if (o < 0) {
                if (o < -r.zeroTolerance) return -1;
                o = 0;
            }
            return o;
        }
        static intersectsRayAndPlaneRP(e, t, r) {
            var i = Ve.intersectsRayAndPlaneRD(e, t);
            if (-1 == i) return r.setValue(0, 0, 0), !1;
            var a = Ve._tempV30;
            return n.scale(e.direction, i, a), n.add(e.origin, a, r), !0;
        }
        static intersectsRayAndBoxRD(e, t) {
            var i = e.origin, a = i.x, n = i.y, s = i.z, o = e.direction, l = o.x, _ = o.y, h = o.z, c = t.min, d = c.x, u = c.y, m = c.z, f = t.max, E = f.x, T = f.y, p = f.z, g = 0, S = r.MaxValue;
            if (r.isZero(l)) {
                if (a < d || a > E) return -1;
            } else {
                var R = 1 / l, v = (d - a) * R, x = (E - a) * R;
                if (v > x) {
                    var I = v;
                    v = x, x = I;
                }
                if ((g = Math.max(v, g)) > (S = Math.min(x, S))) return -1;
            }
            if (r.isZero(_)) {
                if (n < u || n > T) return -1;
            } else {
                var A = 1 / _, L = (u - n) * A, C = (T - n) * A;
                if (L > C) {
                    var D = L;
                    L = C, C = D;
                }
                if ((g = Math.max(L, g)) > (S = Math.min(C, S))) return -1;
            }
            if (r.isZero(h)) {
                if (s < m || s > p) return -1;
            } else {
                var M = 1 / h, y = (m - s) * M, O = (p - s) * M;
                if (y > O) {
                    var N = y;
                    y = O, O = N;
                }
                if ((g = Math.max(y, g)) > (S = Math.min(O, S))) return -1;
            }
            return g;
        }
        static intersectsRayAndBoxRP(e, t, r) {
            var i = Ve.intersectsRayAndBoxRD(e, t);
            return -1 === i ? (n._ZERO.cloneTo(r), i) : (n.scale(e.direction, i, Ve._tempV30), 
            n.add(e.origin, Ve._tempV30, Ve._tempV31), Ve._tempV31.cloneTo(r), i);
        }
        static intersectsRayAndSphereRD(e, t) {
            var r = t.radius;
            n.subtract(e.origin, t.center, Ve._tempV30);
            var i = n.dot(Ve._tempV30, e.direction), a = n.dot(Ve._tempV30, Ve._tempV30) - r * r;
            if (a > 0 && i > 0) return -1;
            var s = i * i - a;
            if (s < 0) return -1;
            var o = -i - Math.sqrt(s);
            return o < 0 && (o = 0), o;
        }
        static intersectsRayAndSphereRP(e, t, r) {
            var i = Ve.intersectsRayAndSphereRD(e, t);
            return -1 === i ? (n._ZERO.cloneTo(r), i) : (n.scale(e.direction, i, Ve._tempV30), 
            n.add(e.origin, Ve._tempV30, Ve._tempV31), Ve._tempV31.cloneTo(r), i);
        }
        static intersectsSphereAndTriangle(e, t, r, i) {
            var a = e.center, s = e.radius;
            return Ve.closestPointPointTriangle(a, t, r, i, Ve._tempV30), n.subtract(Ve._tempV30, a, Ve._tempV31), 
            n.dot(Ve._tempV31, Ve._tempV31) <= s * s;
        }
        static intersectsPlaneAndPoint(e, t) {
            var r = n.dot(e.normal, t) + e.distance;
            return r > 0 ? be.PlaneIntersectionType_Front : r < 0 ? be.PlaneIntersectionType_Back : be.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndPlane(e, t) {
            n.cross(e.normal, t.normal, Ve._tempV30);
            var i = n.dot(Ve._tempV30, Ve._tempV30);
            return !r.isZero(i);
        }
        static intersectsPlaneAndPlaneRL(e, t, i) {
            var a = e.normal, s = t.normal;
            n.cross(a, s, Ve._tempV34);
            var o = n.dot(Ve._tempV34, Ve._tempV34);
            return !r.isZero(o) && (n.scale(s, e.distance, Ve._tempV30), n.scale(a, t.distance, Ve._tempV31), 
            n.subtract(Ve._tempV30, Ve._tempV31, Ve._tempV32), n.cross(Ve._tempV32, Ve._tempV34, Ve._tempV33), 
            n.normalize(Ve._tempV34, Ve._tempV34), !0);
        }
        static intersectsPlaneAndBox(e, t) {
            var r = e.distance, i = e.normal, a = i.x, s = i.y, o = i.z, l = t.min, _ = l.x, h = l.y, c = l.z, d = t.max, u = d.x, m = d.y, f = d.z;
            Ve._tempV30.x = a > 0 ? _ : u, Ve._tempV30.y = s > 0 ? h : m, Ve._tempV30.z = o > 0 ? c : f, 
            Ve._tempV31.x = a > 0 ? u : _, Ve._tempV31.y = s > 0 ? m : h, Ve._tempV31.z = o > 0 ? f : c;
            var E = n.dot(i, Ve._tempV30);
            return E + r > 0 ? be.PlaneIntersectionType_Front : (E = n.dot(i, Ve._tempV31)) + r < 0 ? be.PlaneIntersectionType_Back : be.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndSphere(e, t) {
            var r = t.radius, i = n.dot(e.normal, t.center) + e.distance;
            return i > r ? be.PlaneIntersectionType_Front : i < -r ? be.PlaneIntersectionType_Back : be.PlaneIntersectionType_Intersecting;
        }
        static intersectsBoxAndBox(e, t) {
            var r = e.min, i = e.max, a = t.min, n = t.max;
            return !(r.x > n.x || a.x > i.x) && (!(r.y > n.y || a.y > i.y) && !(r.z > n.z || a.z > i.z));
        }
        static intersectsBoxAndSphere(e, t) {
            var r = t.center, i = t.radius, a = Ve._tempV30;
            return n.Clamp(r, e.min, e.max, a), n.distanceSquared(r, a) <= i * i;
        }
        static intersectsSphereAndSphere(e, t) {
            var r = e.radius + t.radius;
            return n.distanceSquared(e.center, t.center) <= r * r;
        }
        static boxContainsPoint(e, t) {
            var r = e.min, i = e.max;
            return r.x <= t.x && i.x >= t.x && r.y <= t.y && i.y >= t.y && r.z <= t.z && i.z >= t.z ? we.Contains : we.Disjoint;
        }
        static boxContainsBox(e, t) {
            var r = e.min, i = r.x, a = r.y, n = r.z, s = e.max, o = s.x, l = s.y, _ = s.z, h = t.min, c = h.x, d = h.y, u = h.z, m = t.max, f = m.x, E = m.y, T = m.z;
            return o < c || i > f ? we.Disjoint : l < d || a > E ? we.Disjoint : _ < u || n > T ? we.Disjoint : i <= c && f <= o && a <= d && E <= l && n <= u && T <= _ ? we.Contains : we.Intersects;
        }
        static boxContainsSphere(e, t) {
            var r = e.min, i = r.x, a = r.y, s = r.z, o = e.max, l = o.x, _ = o.y, h = o.z, c = t.center, d = c.x, u = c.y, m = c.z, f = t.radius;
            return n.Clamp(c, r, o, Ve._tempV30), n.distanceSquared(c, Ve._tempV30) > f * f ? we.Disjoint : i + f <= d && d <= l - f && l - i > f && a + f <= u && u <= _ - f && _ - a > f && s + f <= m && m <= h - f && h - s > f ? we.Contains : we.Intersects;
        }
        static sphereContainsPoint(e, t) {
            return n.distanceSquared(t, e.center) <= e.radius * e.radius ? we.Contains : we.Disjoint;
        }
        static sphereContainsTriangle(e, t, r, i) {
            var a = Ve.sphereContainsPoint(e, t), n = Ve.sphereContainsPoint(e, r), s = Ve.sphereContainsPoint(e, i);
            return a == we.Contains && n == we.Contains && s == we.Contains ? we.Contains : Ve.intersectsSphereAndTriangle(e, t, r, i) ? we.Intersects : we.Disjoint;
        }
        static sphereContainsBox(e, t) {
            var r = e.center, i = r.x, a = r.y, s = r.z, o = e.radius, l = t.min, _ = l.x, h = l.y, c = l.z, d = t.max, u = d.x, m = d.y, f = d.z, E = Ve._tempV30;
            E.x, E.y, E.z;
            if (!Ve.intersectsBoxAndSphere(t, e)) return we.Disjoint;
            var T = o * o;
            return i - _, a - m, s - f, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - u, 
            a - m, s - f, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - u, a - h, 
            s - f, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - _, a - h, s - f, 
            n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - _, a - m, s - c, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - u, 
            a - m, s - c, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - u, a - h, 
            s - c, n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : (i - _, a - h, s - c, 
            n.scalarLengthSquared(Ve._tempV30) > T ? we.Intersects : we.Contains)))))));
        }
        static sphereContainsSphere(e, t) {
            var r = e.radius, i = t.radius, a = n.distance(e.center, t.center);
            return r + i < a ? we.Disjoint : r - i < a ? we.Intersects : we.Contains;
        }
        static closestPointPointTriangle(e, t, r, i, a) {
            n.subtract(r, t, Ve._tempV30), n.subtract(i, t, Ve._tempV31), n.subtract(e, t, Ve._tempV32), 
            n.subtract(e, r, Ve._tempV33), n.subtract(e, i, Ve._tempV34);
            var s = n.dot(Ve._tempV30, Ve._tempV32), o = n.dot(Ve._tempV31, Ve._tempV32), l = n.dot(Ve._tempV30, Ve._tempV33), _ = n.dot(Ve._tempV31, Ve._tempV33), h = n.dot(Ve._tempV30, Ve._tempV34), c = n.dot(Ve._tempV31, Ve._tempV34);
            if (s <= 0 && o <= 0) t.cloneTo(a); else if (l >= 0 && _ <= l) r.cloneTo(a); else {
                var d = s * _ - l * o;
                if (d <= 0 && s >= 0 && l <= 0) {
                    var u = s / (s - l);
                    return n.scale(Ve._tempV30, u, a), void n.add(t, a, a);
                }
                if (c >= 0 && h <= c) i.cloneTo(a); else {
                    var m = h * o - s * c;
                    if (m <= 0 && o >= 0 && c <= 0) {
                        var f = o / (o - c);
                        return n.scale(Ve._tempV31, f, a), void n.add(t, a, a);
                    }
                    var E = l * c - h * _;
                    if (E <= 0 && _ - l >= 0 && h - c >= 0) {
                        var T = (_ - l) / (_ - l + (h - c));
                        return n.subtract(i, r, a), n.scale(a, T, a), void n.add(r, a, a);
                    }
                    var p = 1 / (E + m + d), g = m * p, S = d * p;
                    n.scale(Ve._tempV30, g, Ve._tempV35), n.scale(Ve._tempV31, S, Ve._tempV36), n.add(Ve._tempV35, Ve._tempV36, a), 
                    n.add(t, a, a);
                }
            }
        }
        static closestPointPlanePoint(e, t, r) {
            var i = e.normal, a = n.dot(i, t) - e.distance;
            n.scale(i, a, Ve._tempV30), n.subtract(t, Ve._tempV30, r);
        }
        static closestPointBoxPoint(e, t, r) {
            n.max(t, e.min, Ve._tempV30), n.min(Ve._tempV30, e.max, r);
        }
        static closestPointSpherePoint(e, t, r) {
            var i = e.center;
            n.subtract(t, i, r), n.normalize(r, r), n.scale(r, e.radius, r), n.add(r, i, r);
        }
        static closestPointSphereSphere(e, t, r) {
            var i = e.center;
            n.subtract(t.center, i, r), n.normalize(r, r), n.scale(r, e.radius, r), n.add(r, i, r);
        }
    }
    Ve._tempV30 = new n(), Ve._tempV31 = new n(), Ve._tempV32 = new n(), Ve._tempV33 = new n(), 
    Ve._tempV34 = new n(), Ve._tempV35 = new n(), Ve._tempV36 = new n(), (te = e.FrustumCorner || (e.FrustumCorner = {}))[te.FarBottomLeft = 0] = "FarBottomLeft", 
    te[te.FarTopLeft = 1] = "FarTopLeft", te[te.FarTopRight = 2] = "FarTopRight", te[te.FarBottomRight = 3] = "FarBottomRight", 
    te[te.nearBottomLeft = 4] = "nearBottomLeft", te[te.nearTopLeft = 5] = "nearTopLeft", 
    te[te.nearTopRight = 6] = "nearTopRight", te[te.nearBottomRight = 7] = "nearBottomRight", 
    te[te.unknown = 8] = "unknown";
    class Be {
        constructor(e) {
            this._matrix = e, this._near = new be(new n()), this._far = new be(new n()), this._left = new be(new n()), 
            this._right = new be(new n()), this._top = new be(new n()), this._bottom = new be(new n()), 
            Be.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        static getPlanesFromMatrix(e, t, r, i, a, n, s) {
            var o = e.elements, l = o[0], _ = o[1], h = o[2], c = o[3], d = o[4], u = o[5], m = o[6], f = o[7], E = o[8], T = o[9], p = o[10], g = o[11], S = o[12], R = o[13], v = o[14], x = o[15], I = t.normal;
            I.x = h, I.y = m, I.z = p, t.distance = v, t.normalize();
            var A = r.normal;
            A.x = c - h, A.y = f - m, A.z = g - p, r.distance = x - v, r.normalize();
            var L = i.normal;
            L.x = c + l, L.y = f + d, L.z = g + E, i.distance = x + S, i.normalize();
            var C = a.normal;
            C.x = c - l, C.y = f - d, C.z = g - E, a.distance = x - S, a.normalize();
            var D = n.normal;
            D.x = c - _, D.y = f - u, D.z = g - T, n.distance = x - R, n.normalize();
            var M = s.normal;
            M.x = c + _, M.y = f + u, M.z = g + T, s.distance = x + R, s.normalize();
        }
        get matrix() {
            return this._matrix;
        }
        set matrix(e) {
            e.cloneTo(this._matrix), Be.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get near() {
            return this._near;
        }
        get far() {
            return this._far;
        }
        get left() {
            return this._left;
        }
        get right() {
            return this._right;
        }
        get top() {
            return this._top;
        }
        get bottom() {
            return this._bottom;
        }
        equalsBoundFrustum(e) {
            return this._matrix.equalsOtherMatrix(e.matrix);
        }
        equalsObj(e) {
            if (e instanceof Be) {
                var t = e;
                return this.equalsBoundFrustum(t);
            }
            return !1;
        }
        getPlane(e) {
            switch (e) {
              case 0:
                return this._near;

              case 1:
                return this._far;

              case 2:
                return this._left;

              case 3:
                return this._right;

              case 4:
                return this._top;

              case 5:
                return this._bottom;

              default:
                return null;
            }
        }
        static get3PlaneInterPoint(e, t, r, i) {
            var a = e.normal, s = t.normal, o = r.normal;
            n.cross(s, o, Be._tempV30), n.cross(o, a, Be._tempV31), n.cross(a, s, Be._tempV32);
            var l = n.dot(a, Be._tempV30), _ = n.dot(s, Be._tempV31), h = n.dot(o, Be._tempV32);
            n.scale(Be._tempV30, -e.distance / l, Be._tempV33), n.scale(Be._tempV31, -t.distance / _, Be._tempV34), 
            n.scale(Be._tempV32, -r.distance / h, Be._tempV35), n.add(Be._tempV33, Be._tempV34, Be._tempV36), 
            n.add(Be._tempV35, Be._tempV36, i);
        }
        getCorners(t) {
            Be.get3PlaneInterPoint(this._near, this._bottom, this._right, t[e.FrustumCorner.nearBottomRight]), 
            Be.get3PlaneInterPoint(this._near, this._top, this._right, t[e.FrustumCorner.nearTopRight]), 
            Be.get3PlaneInterPoint(this._near, this._top, this._left, t[e.FrustumCorner.nearTopLeft]), 
            Be.get3PlaneInterPoint(this._near, this._bottom, this._left, t[e.FrustumCorner.nearBottomLeft]), 
            Be.get3PlaneInterPoint(this._far, this._bottom, this._right, t[e.FrustumCorner.FarBottomRight]), 
            Be.get3PlaneInterPoint(this._far, this._top, this._right, t[e.FrustumCorner.FarTopRight]), 
            Be.get3PlaneInterPoint(this._far, this._top, this._left, t[e.FrustumCorner.FarTopLeft]), 
            Be.get3PlaneInterPoint(this._far, this._bottom, this._left, t[e.FrustumCorner.FarBottomLeft]);
        }
        containsPoint(e) {
            for (var t = be.PlaneIntersectionType_Front, r = be.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                  case 0:
                    r = Ve.intersectsPlaneAndPoint(this._near, e);
                    break;

                  case 1:
                    r = Ve.intersectsPlaneAndPoint(this._far, e);
                    break;

                  case 2:
                    r = Ve.intersectsPlaneAndPoint(this._left, e);
                    break;

                  case 3:
                    r = Ve.intersectsPlaneAndPoint(this._right, e);
                    break;

                  case 4:
                    r = Ve.intersectsPlaneAndPoint(this._top, e);
                    break;

                  case 5:
                    r = Ve.intersectsPlaneAndPoint(this._bottom, e);
                }
                switch (r) {
                  case be.PlaneIntersectionType_Back:
                    return we.Disjoint;

                  case be.PlaneIntersectionType_Intersecting:
                    t = be.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
              case be.PlaneIntersectionType_Intersecting:
                return we.Intersects;

              default:
                return we.Contains;
            }
        }
        intersects(e) {
            var t = e.min, r = e.max, i = t.x, a = t.y, n = t.z, s = r.x, o = r.y, l = r.z, _ = this._near.normal;
            if (this._near.distance + _.x * (_.x < 0 ? i : s) + _.y * (_.y < 0 ? a : o) + _.z * (_.z < 0 ? n : l) < 0) return !1;
            var h = this._left.normal;
            if (this._left.distance + h.x * (h.x < 0 ? i : s) + h.y * (h.y < 0 ? a : o) + h.z * (h.z < 0 ? n : l) < 0) return !1;
            var c = this._right.normal;
            if (this._right.distance + c.x * (c.x < 0 ? i : s) + c.y * (c.y < 0 ? a : o) + c.z * (c.z < 0 ? n : l) < 0) return !1;
            var d = this._bottom.normal;
            if (this._bottom.distance + d.x * (d.x < 0 ? i : s) + d.y * (d.y < 0 ? a : o) + d.z * (d.z < 0 ? n : l) < 0) return !1;
            var u = this._top.normal;
            if (this._top.distance + u.x * (u.x < 0 ? i : s) + u.y * (u.y < 0 ? a : o) + u.z * (u.z < 0 ? n : l) < 0) return !1;
            var m = this._far.normal;
            return !(this._far.distance + m.x * (m.x < 0 ? i : s) + m.y * (m.y < 0 ? a : o) + m.z * (m.z < 0 ? n : l) < 0);
        }
        containsBoundBox(e) {
            for (var t = Be._tempV30, r = Be._tempV31, i = e.min, a = e.max, n = we.Contains, s = 0; s < 6; s++) {
                var o = this.getPlane(s), l = o.normal;
                if (l.x >= 0 ? (t.x = a.x, r.x = i.x) : (t.x = i.x, r.x = a.x), l.y >= 0 ? (t.y = a.y, 
                r.y = i.y) : (t.y = i.y, r.y = a.y), l.z >= 0 ? (t.z = a.z, r.z = i.z) : (t.z = i.z, 
                r.z = a.z), Ve.intersectsPlaneAndPoint(o, t) === be.PlaneIntersectionType_Back) return we.Disjoint;
                Ve.intersectsPlaneAndPoint(o, r) === be.PlaneIntersectionType_Back && (n = we.Intersects);
            }
            return n;
        }
        containsBoundSphere(e) {
            for (var t = be.PlaneIntersectionType_Front, r = be.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                  case 0:
                    r = Ve.intersectsPlaneAndSphere(this._near, e);
                    break;

                  case 1:
                    r = Ve.intersectsPlaneAndSphere(this._far, e);
                    break;

                  case 2:
                    r = Ve.intersectsPlaneAndSphere(this._left, e);
                    break;

                  case 3:
                    r = Ve.intersectsPlaneAndSphere(this._right, e);
                    break;

                  case 4:
                    r = Ve.intersectsPlaneAndSphere(this._top, e);
                    break;

                  case 5:
                    r = Ve.intersectsPlaneAndSphere(this._bottom, e);
                }
                switch (r) {
                  case be.PlaneIntersectionType_Back:
                    return we.Disjoint;

                  case be.PlaneIntersectionType_Intersecting:
                    t = be.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
              case be.PlaneIntersectionType_Intersecting:
                return we.Intersects;

              default:
                return we.Contains;
            }
        }
    }
    Be._tempV30 = new n(), Be._tempV31 = new n(), Be._tempV32 = new n(), Be._tempV33 = new n(), 
    Be._tempV34 = new n(), Be._tempV35 = new n(), Be._tempV36 = new n();
    class Fe {
        constructor(e, t, r, i) {
            this.minDepth = 0, this.maxDepth = 1, this.x = e, this.y = t, this.width = r, this.height = i;
        }
        project(e, t, r) {
            n.transformV3ToV4(e, t, r);
            var i = r.x, a = r.y, s = r.z, o = r.w;
            1 !== o && (i /= o, a /= o, s /= o), r.x = .5 * (i + 1) * this.width + this.x, r.y = .5 * (1 - a) * this.height + this.y, 
            r.z = s * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(e, t, r) {
            var i = t.elements;
            r.x = (e.x - this.x) / this.width * 2 - 1, r.y = -((e.y - this.y) / this.height * 2 - 1), 
            r.z = (e.z - this.minDepth) / (this.maxDepth - this.minDepth);
            var a = r.x * i[3] + r.y * i[7] + r.z * i[11] + i[15];
            n.transformV3ToV3(r, t, r), 1 !== a && (r.x = r.x / a, r.y = r.y / a, r.z = r.z / a);
        }
        unprojectFromWVP(e, t, r, i, a) {
            y.multiply(t, r, Fe._tempMatrix4x4), i && y.multiply(Fe._tempMatrix4x4, i, Fe._tempMatrix4x4), 
            Fe._tempMatrix4x4.invert(Fe._tempMatrix4x4), this.unprojectFromMat(e, Fe._tempMatrix4x4, a);
        }
        cloneTo(e) {
            e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth, 
            e.maxDepth = this.maxDepth;
        }
    }
    Fe._tempMatrix4x4 = new y();
    class Ue {
        constructor() {}
        static calculateCursorRay(e, t, r, i, a, s) {
            var o = e.x, l = e.y, _ = Ue._tempVector30, h = _;
            h.x = o, h.y = l, h.z = t.minDepth;
            var c = Ue._tempVector31, d = c;
            d.x = o, d.y = l, d.z = t.maxDepth;
            var u = s.origin, m = Ue._tempVector32;
            t.unprojectFromWVP(_, r, i, a, u), t.unprojectFromWVP(c, r, i, a, m);
            var f = s.direction;
            f.x = m.x - u.x, f.y = m.y - u.y, f.z = m.z - u.z, n.normalize(s.direction, s.direction);
        }
        static rayIntersectsTriangle(e, t, r, i) {
            var a = Ue._tempVector30, s = Ue._tempVector31;
            n.subtract(r, t, a), n.subtract(i, t, s);
            var o, l = Ue._tempVector32;
            if (n.cross(e.direction, s, l), (o = n.dot(a, l)) > -Number.MIN_VALUE && o < Number.MIN_VALUE) return Number.NaN;
            var _, h = 1 / o, c = Ue._tempVector33;
            if (n.subtract(e.origin, t, c), _ = n.dot(c, l), (_ *= h) < 0 || _ > 1) return Number.NaN;
            var d, u, m = Ue._tempVector34;
            return n.cross(c, a, m), d = n.dot(e.direction, m), (d *= h) < 0 || _ + d > 1 ? Number.NaN : (u = n.dot(s, m), 
            (u *= h) < 0 ? Number.NaN : u);
        }
    }
    Ue._tempVector30 = new n(), Ue._tempVector31 = new n(), Ue._tempVector32 = new n(), 
    Ue._tempVector33 = new n(), Ue._tempVector34 = new n();
    class Ge extends t.BufferStateBase {
        constructor() {
            super();
        }
        applyVertexBuffer(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            var r = t.LayaGL.instance, i = e.vertexDeclaration, a = i._shaderValues.getData();
            for (var n in this.vertexDeclaration = i, e.bind(), a) {
                var s = parseInt(n), o = a[n];
                r.enableVertexAttribArray(s), r.vertexAttribPointer(s, o[0], o[1], !!o[2], o[3], o[4]);
            }
        }
        applyVertexBuffers(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            for (var r = t.LayaGL.instance, i = 0, a = e.length; i < a; i++) {
                var n = e[i], s = n.vertexDeclaration._shaderValues.getData();
                for (var o in n.bind(), s) {
                    var l = parseInt(o), _ = s[o];
                    r.enableVertexAttribArray(l), r.vertexAttribPointer(l, _[0], _[1], !!_[2], _[3], _[4]);
                }
            }
        }
        applyInstanceVertexBuffer(e) {
            if (t.LayaGL.layaGPUInstance.supportInstance()) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var r = t.LayaGL.instance, i = e.vertexDeclaration._shaderValues.getData();
                for (var a in e.bind(), i) {
                    var n = parseInt(a), s = i[a];
                    r.enableVertexAttribArray(n), r.vertexAttribPointer(n, s[0], s[1], !!s[2], s[3], s[4]), 
                    t.LayaGL.layaGPUInstance.vertexAttribDivisor(n, 1);
                }
            }
        }
        applyIndexBuffer(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
        }
    }
    (re = e.IndexFormat || (e.IndexFormat = {}))[re.UInt8 = 0] = "UInt8", re[re.UInt16 = 1] = "UInt16", 
    re[re.UInt32 = 2] = "UInt32";
    class ze extends t.Buffer {
        get indexType() {
            return this._indexType;
        }
        get indexTypeByteCount() {
            return this._indexTypeByteCount;
        }
        get indexCount() {
            return this._indexCount;
        }
        get canRead() {
            return this._canRead;
        }
        constructor(r, i, a = 35044, n = !1) {
            switch (super(), this._indexType = r, this._indexCount = i, this._bufferUsage = a, 
            this._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER, this._canRead = n, r) {
              case e.IndexFormat.UInt32:
                this._indexTypeByteCount = 4;
                break;

              case e.IndexFormat.UInt16:
                this._indexTypeByteCount = 2;
                break;

              case e.IndexFormat.UInt8:
                this._indexTypeByteCount = 1;
                break;

              default:
                throw new Error("unidentification index type.");
            }
            var s = this._indexTypeByteCount * i, o = t.BufferStateBase._curBindedBufferState;
            if (this._byteLength = s, o ? o._bindedIndexBuffer === this ? t.LayaGL.instance.bufferData(this._bufferType, s, this._bufferUsage) : (o.unBind(), 
            this.bind(), t.LayaGL.instance.bufferData(this._bufferType, s, this._bufferUsage), 
            o.bind()) : (this.bind(), t.LayaGL.instance.bufferData(this._bufferType, s, this._bufferUsage)), 
            n) switch (r) {
              case e.IndexFormat.UInt32:
                this._buffer = new Uint32Array(i);
                break;

              case e.IndexFormat.UInt16:
                this._buffer = new Uint16Array(i);
                break;

              case e.IndexFormat.UInt8:
                this._buffer = new Uint8Array(i);
            }
        }
        _bindForVAO() {
            if (!t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
            var e = t.LayaGL.instance;
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
        }
        bind() {
            if (t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
            if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                var e = t.LayaGL.instance;
                return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedIndexBuffer = this._glBuffer, 
                !0;
            }
            return !1;
        }
        setData(r, i = 0, a = 0, n = 4294967295) {
            var s = this._indexTypeByteCount;
            if (0 !== a || 4294967295 !== n) switch (this._indexType) {
              case e.IndexFormat.UInt32:
                r = new Uint32Array(r.buffer, a * s, n);
                break;

              case e.IndexFormat.UInt16:
                r = new Uint16Array(r.buffer, a * s, n);
                break;

              case e.IndexFormat.UInt8:
                r = new Uint8Array(r.buffer, a * s, n);
            }
            var o = t.BufferStateBase._curBindedBufferState;
            if (o ? o._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r) : (o.unBind(), 
            this.bind(), t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r), o.bind()) : (this.bind(), 
            t.LayaGL.instance.bufferSubData(this._bufferType, i * s, r)), this._canRead) if (0 !== i || 0 !== a || 4294967295 !== n) {
                var l = this._buffer.length - i;
                n > l && (n = l);
                for (var _ = 0; _ < n; _++) this._buffer[i + _] = r[_];
            } else this._buffer = r;
        }
        getData() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        destroy() {
            super.destroy(), this._buffer = null;
        }
    }
    class He {
        static __init__() {
            var e = t.LayaGL.instance;
            He._elementInfos = {
                single: [ 1, e.FLOAT, 0 ],
                vector2: [ 2, e.FLOAT, 0 ],
                vector3: [ 3, e.FLOAT, 0 ],
                vector4: [ 4, e.FLOAT, 0 ],
                color: [ 4, e.FLOAT, 0 ],
                byte4: [ 4, e.UNSIGNED_BYTE, 0 ],
                short2: [ 2, e.FLOAT, 0 ],
                short4: [ 4, e.FLOAT, 0 ],
                normalizedshort2: [ 2, e.FLOAT, 0 ],
                normalizedshort4: [ 4, e.FLOAT, 0 ],
                halfvector2: [ 2, e.FLOAT, 0 ],
                halfvector4: [ 4, e.FLOAT, 0 ]
            };
        }
        static getElementInfos(e) {
            var t = He._elementInfos[e];
            if (t) return t;
            throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }
    }
    He.Single = "single", He.Vector2 = "vector2", He.Vector3 = "vector3", He.Vector4 = "vector4", 
    He.Color = "color", He.Byte4 = "byte4", He.Short2 = "short2", He.Short4 = "short4", 
    He.NormalizedShort2 = "normalizedshort2", He.NormalizedShort4 = "normalizedshort4", 
    He.HalfVector2 = "halfvector2", He.HalfVector4 = "halfvector4";
    class We {
        constructor(e, t) {
            this._id = ++We._uniqueIDCounter, this._vertexElementsDic = {}, this._vertexStride = e, 
            this._vertexElements = t;
            var r = t.length;
            this._shaderValues = new W(null);
            for (var i = 0; i < r; i++) {
                var a = t[i], n = a._elementUsage;
                this._vertexElementsDic[n] = a;
                var s = new Int32Array(5), o = He.getElementInfos(a._elementFormat);
                s[0] = o[0], s[1] = o[1], s[2] = o[2], s[3] = this._vertexStride, s[4] = a._offset, 
                this._shaderValues.setAttribute(n, s);
            }
        }
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        getVertexElementByIndex(e) {
            return this._vertexElements[e];
        }
        getVertexElementByUsage(e) {
            return this._vertexElementsDic[e];
        }
    }
    We._uniqueIDCounter = 1;
    class ke {
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
        constructor(e, t, r) {
            this._offset = e, this._elementFormat = t, this._elementUsage = r;
        }
    }
    class Xe {
        static __init__() {
            Xe.instanceWorldMatrixDeclaration = new We(64, [ new ke(0, He.Vector4, Xe.MESH_WORLDMATRIX_ROW0), new ke(16, He.Vector4, Xe.MESH_WORLDMATRIX_ROW1), new ke(32, He.Vector4, Xe.MESH_WORLDMATRIX_ROW2), new ke(48, He.Vector4, Xe.MESH_WORLDMATRIX_ROW3) ]), 
            Xe.instanceMVPMatrixDeclaration = new We(64, [ new ke(0, He.Vector4, Xe.MESH_MVPMATRIX_ROW0), new ke(16, He.Vector4, Xe.MESH_MVPMATRIX_ROW1), new ke(32, He.Vector4, Xe.MESH_MVPMATRIX_ROW2), new ke(48, He.Vector4, Xe.MESH_MVPMATRIX_ROW3) ]);
        }
        static getVertexDeclaration(e, t = !0) {
            var r = Xe._vertexDeclarationMap[e + (t ? "_0" : "_1")];
            if (!r) {
                for (var i = e.split(","), a = 0, n = [], s = 0, o = i.length; s < o; s++) {
                    var l;
                    switch (i[s]) {
                      case "POSITION":
                        l = new ke(a, He.Vector3, Xe.MESH_POSITION0), a += 12;
                        break;

                      case "NORMAL":
                        l = new ke(a, He.Vector3, Xe.MESH_NORMAL0), a += 12;
                        break;

                      case "COLOR":
                        l = new ke(a, He.Vector4, Xe.MESH_COLOR0), a += 16;
                        break;

                      case "UV":
                        l = new ke(a, He.Vector2, Xe.MESH_TEXTURECOORDINATE0), a += 8;
                        break;

                      case "UV1":
                        l = new ke(a, He.Vector2, Xe.MESH_TEXTURECOORDINATE1), a += 8;
                        break;

                      case "BLENDWEIGHT":
                        l = new ke(a, He.Vector4, Xe.MESH_BLENDWEIGHT0), a += 16;
                        break;

                      case "BLENDINDICES":
                        t ? (l = new ke(a, He.Vector4, Xe.MESH_BLENDINDICES0), a += 16) : (l = new ke(a, He.Byte4, Xe.MESH_BLENDINDICES0), 
                        a += 4);
                        break;

                      case "TANGENT":
                        l = new ke(a, He.Vector4, Xe.MESH_TANGENT0), a += 16;
                        break;

                      default:
                        throw "VertexMesh: unknown vertex flag.";
                    }
                    n.push(l);
                }
                r = new We(a, n), Xe._vertexDeclarationMap[e + (t ? "_0" : "_1")] = r;
            }
            return r;
        }
    }
    Xe.MESH_POSITION0 = 0, Xe.MESH_COLOR0 = 1, Xe.MESH_TEXTURECOORDINATE0 = 2, Xe.MESH_NORMAL0 = 3, 
    Xe.MESH_TANGENT0 = 4, Xe.MESH_BLENDINDICES0 = 5, Xe.MESH_BLENDWEIGHT0 = 6, Xe.MESH_TEXTURECOORDINATE1 = 7, 
    Xe.MESH_WORLDMATRIX_ROW0 = 8, Xe.MESH_WORLDMATRIX_ROW1 = 9, Xe.MESH_WORLDMATRIX_ROW2 = 10, 
    Xe.MESH_WORLDMATRIX_ROW3 = 11, Xe.MESH_MVPMATRIX_ROW0 = 12, Xe.MESH_MVPMATRIX_ROW1 = 13, 
    Xe.MESH_MVPMATRIX_ROW2 = 14, Xe.MESH_MVPMATRIX_ROW3 = 15, Xe._vertexDeclarationMap = {};
    class Ye extends t.Buffer {
        constructor(e, r, i = !1) {
            super(), this._vertexDeclaration = null, this._float32Reader = null;
            var a = t.LayaGL.instance;
            this._bufferUsage = r, this._bufferType = a.ARRAY_BUFFER, this._canRead = i, this._byteLength = e, 
            this.bind(), a.bufferData(this._bufferType, this._byteLength, this._bufferUsage), 
            i && (this._buffer = new Uint8Array(e), this._float32Reader = new Float32Array(this._buffer.buffer));
        }
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(e) {
            this._vertexDeclaration = e;
        }
        get canRead() {
            return this._canRead;
        }
        bind() {
            if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                var e = t.LayaGL.instance;
                return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedVertexBuffer = this._glBuffer, 
                !0;
            }
            return !1;
        }
        orphanStorage() {
            this.bind(), t.LayaGL.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage);
        }
        setData(e, r = 0, i = 0, a = Number.MAX_SAFE_INTEGER) {
            if (this.bind(), 0 !== i || a !== Number.MAX_SAFE_INTEGER) {
                var n = new Uint8Array(e, i, a);
                t.LayaGL.instance.bufferSubData(this._bufferType, r, n), this._canRead && this._buffer.set(n, r);
            } else t.LayaGL.instance.bufferSubData(this._bufferType, r, e), this._canRead && this._buffer.set(new Uint8Array(e), r);
        }
        getUint8Data() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        getFloat32Data() {
            if (this._canRead) return this._float32Reader;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        markAsUnreadbale() {
            this._canRead = !1, this._buffer = null, this._float32Reader = null;
        }
        destroy() {
            super.destroy(), this._buffer = null, this._float32Reader = null, this._vertexDeclaration = null;
        }
    }
    Ye.DATATYPE_FLOAT32ARRAY = 0, Ye.DATATYPE_UINT8ARRAY = 1;
    class je {
        constructor() {}
        _render(e) {}
    }
    class Ze extends je {
        static __init__() {
            Ze.instance = new Ze();
        }
        constructor() {
            super();
            var r = t.LayaGL.instance, i = new Float32Array([ -1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1 ]), a = new Uint8Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0 ]), n = Xe.getVertexDeclaration("POSITION");
            this._vertexBuffer = new Ye(8 * n.vertexStride, r.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = n, 
            this._indexBuffer = new ze(e.IndexFormat.UInt8, 36, r.STATIC_DRAW, !1), this._vertexBuffer.setData(i.buffer), 
            this._indexBuffer.setData(a);
            var s = new Ge();
            s.bind(), s.applyVertexBuffer(this._vertexBuffer), s.applyIndexBuffer(this._indexBuffer), 
            s.unBind(), this._bufferState = s;
        }
        _render(e) {
            var r = t.LayaGL.instance;
            r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces += 12, 
            t.Stat.renderBatches++;
        }
    }
    class qe {
        constructor() {
            this._mesh = Ze.instance;
        }
        get material() {
            return this._material;
        }
        set material(e) {
            this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(), 
            this._material = e);
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            this._mesh !== e && (this._mesh = e);
        }
        _isAvailable() {
            return !(!this._material || !this._mesh);
        }
        _render(e) {
            if (this._material && this._mesh) {
                var r = t.LayaGL.instance, i = e.scene, a = e.cameraShaderValue, s = e.camera, o = W._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && W.setRuntimeValueMode(!1), t.WebGLContext.setCullFace(r, !1), 
                t.WebGLContext.setDepthFunc(r, r.LEQUAL), t.WebGLContext.setDepthMask(r, !1);
                var l = qe._compileDefine;
                this._material._shaderValues._defineDatas.cloneTo(l);
                var _ = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(l), h = _.bind(), c = t.Stat.loopCount !== _._uploadMark, d = _._uploadScene !== i || c;
                (d || h) && (_.uploadUniforms(_._sceneUniformParamsMap, i._shaderValues, d), _._uploadScene = i);
                s._getRenderTexture();
                var u = _._uploadCameraShaderValue !== a || c;
                if (u || h) {
                    var m = qe._tempMatrix0, f = qe._tempMatrix1;
                    s.viewMatrix.cloneTo(m), s.projectionMatrix.cloneTo(f), m.setTranslationVector(n._ZERO), 
                    s.orthographic && y.createPerspective(s.fieldOfView, s.aspectRatio, s.nearPlane, s.farPlane, f);
                    var E = 1 / Math.tan(3.1416 * s.fieldOfView / 180 * .5);
                    f.elements[0] = E / s.aspectRatio, f.elements[5] = E, f.elements[10] = 1e-6 - 1, 
                    f.elements[11] = -1, f.elements[14] = -0, s._applyViewProject(e, m, f), _.uploadUniforms(_._cameraUniformParamsMap, a, u), 
                    _._uploadCameraShaderValue = a;
                }
                var T = _._uploadMaterial !== this._material || c;
                (T || h) && (_.uploadUniforms(_._materialUniformParamsMap, this._material._shaderValues, T), 
                _._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e), 
                t.ILaya.Render.supportWebGLPlusRendering && W.setRuntimeValueMode(o), t.WebGLContext.setDepthFunc(r, r.LESS), 
                t.WebGLContext.setDepthMask(r, !0), s._applyViewProject(e, s.viewMatrix, s.projectionMatrix);
            }
        }
        destroy() {
            this._material && (this._material._removeReference(), this._material = null);
        }
    }
    qe._tempMatrix0 = new y(), qe._tempMatrix1 = new y(), qe._compileDefine = new F();
    class Qe extends ve {
        constructor(e = .3, t = 1e3) {
            super(), this._skyRenderer = new qe(), this._forward = new n(), this._up = new n(), 
            this.clearColor = new a(100 / 255, 149 / 255, 237 / 255, 1), this._shaderValues = new W(null), 
            this._fieldOfView = 60, this._useUserProjectionMatrix = !1, this._orthographic = !1, 
            this._orthographicVerticalSize = 10, this.renderingOrder = 0, this._nearPlane = e, 
            this._farPlane = t, this.cullingMask = 2147483647, this.useOcclusionCulling = !0;
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get fieldOfView() {
            return this._fieldOfView;
        }
        set fieldOfView(e) {
            this._fieldOfView = e, this._calculateProjectionMatrix();
        }
        get nearPlane() {
            return this._nearPlane;
        }
        set nearPlane(e) {
            this._nearPlane = e, this._calculateProjectionMatrix();
        }
        get farPlane() {
            return this._farPlane;
        }
        set farPlane(e) {
            this._farPlane = e, this._calculateProjectionMatrix();
        }
        get orthographic() {
            return this._orthographic;
        }
        set orthographic(e) {
            this._orthographic = e, this._calculateProjectionMatrix();
        }
        get orthographicVerticalSize() {
            return this._orthographicVerticalSize;
        }
        set orthographicVerticalSize(e) {
            this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
        }
        get renderingOrder() {
            return this._renderingOrder;
        }
        set renderingOrder(e) {
            this._renderingOrder = e, this._sortCamerasByRenderingOrder();
        }
        _sortCamerasByRenderingOrder() {
            if (this.displayedInStage) for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++) if (e[r].renderingOrder > e[t].renderingOrder) {
                var i = e[r];
                e[r] = e[t], e[t] = i;
            }
        }
        _calculateProjectionMatrix() {}
        _onScreenSizeChanged() {
            this._calculateProjectionMatrix();
        }
        _prepareCameraToRender() {
            var e = this._shaderValues;
            this.transform.getForward(this._forward), this.transform.getUp(this._up), e.setVector3(Qe.CAMERAPOS, this.transform.position), 
            e.setVector3(Qe.CAMERADIRECTION, this._forward), e.setVector3(Qe.CAMERAUP, this._up);
        }
        render(e = null, t = null) {}
        addLayer(e) {
            this.cullingMask |= Math.pow(2, e);
        }
        removeLayer(e) {
            this.cullingMask &= ~Math.pow(2, e);
        }
        addAllLayers() {
            this.cullingMask = 2147483647;
        }
        removeAllLayers() {
            this.cullingMask = 0;
        }
        resetProjectionMatrix() {
            this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
        }
        _onActive() {
            this._scene._addCamera(this), super._onActive();
        }
        _onInActive() {
            this._scene._removeCamera(this), super._onInActive();
        }
        _parse(e, r) {
            super._parse(e, r), this.orthographic = e.orthographic, void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize), 
            void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e.nearPlane, 
            this.farPlane = e.farPlane;
            var i = e.clearColor;
            this.clearColor = new a(i[0], i[1], i[2], i[3]);
            var n = e.skyboxMaterial;
            n && (this._skyRenderer.material = t.Loader.getRes(n.path));
        }
        destroy(e = !0) {
            this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged), 
            super.destroy(e);
        }
        _create() {
            return new Qe();
        }
    }
    Qe._tempMatrix4x40 = new y(), Qe.CAMERAPOS = H.propertyNameToID("u_CameraPos"), 
    Qe.VIEWMATRIX = H.propertyNameToID("u_View"), Qe.PROJECTMATRIX = H.propertyNameToID("u_Projection"), 
    Qe.VIEWPROJECTMATRIX = H.propertyNameToID("u_ViewProjection"), Qe.CAMERADIRECTION = H.propertyNameToID("u_CameraDirection"), 
    Qe.CAMERAUP = H.propertyNameToID("u_CameraUp"), Qe.VIEWPORT = H.propertyNameToID("u_Viewport"), 
    Qe.PROJECTION_PARAMS = H.propertyNameToID("u_ProjectionParams"), Qe.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", 
    Qe.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", Qe._invertYScaleMatrix = new y(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), 
    Qe._invertYProjectionMatrix = new y(), Qe._invertYProjectionViewMatrix = new y(), 
    Qe.CLEARFLAG_SOLIDCOLOR = 0, Qe.CLEARFLAG_SKY = 1, Qe.CLEARFLAG_DEPTHONLY = 2, Qe.CLEARFLAG_NONE = 3, 
    (ie = e.ShadowMode || (e.ShadowMode = {}))[ie.None = 0] = "None", ie[ie.Hard = 1] = "Hard", 
    ie[ie.SoftLow = 2] = "SoftLow", ie[ie.SoftHigh = 3] = "SoftHigh";
    class Ke extends t.Resource {
        constructor() {
            super(), this._bufferState = new Ge(), this._bufferStateInvertUV = new Ge();
            var e = t.LayaGL.instance;
            this._vertexBuffer = new Ye(64, e.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = Ke._vertexDeclaration, 
            this._vertexBuffer.setData(Ke._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.unBind(), this._vertexBufferInvertUV = new Ye(64, e.STATIC_DRAW, !1), 
            this._vertexBufferInvertUV.vertexDeclaration = Ke._vertexDeclaration, this._vertexBufferInvertUV.setData(Ke._verticesInvertUV.buffer), 
            this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV), 
            this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
        }
        static __init__() {
            Ke._vertexDeclaration = new We(16, [ new ke(0, He.Vector4, Ke.SCREENQUAD_POSITION_UV) ]), 
            Ke.instance = new Ke(), Ke.instance.lock = !0;
        }
        render() {
            var e = t.LayaGL.instance;
            this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
        }
        renderInvertUV() {
            var e = t.LayaGL.instance;
            this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
        }
        destroy() {
            super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), 
            this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0);
        }
    }
    Ke.SCREENQUAD_POSITION_UV = 0, Ke._vertices = new Float32Array([ 1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0 ]), 
    Ke._verticesInvertUV = new Float32Array([ 1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1 ]);
    class Je extends t.Resource {
        constructor() {
            super(), this._bufferState = new Ge(), this._bufferStateInvertUV = new Ge();
            var e = t.LayaGL.instance;
            this._vertexBuffer = new Ye(48, e.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = Je._vertexDeclaration, 
            this._vertexBuffer.setData(Je._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.unBind(), this._vertexBufferInvertUV = new Ye(48, e.STATIC_DRAW, !1), 
            this._vertexBufferInvertUV.vertexDeclaration = Je._vertexDeclaration, this._vertexBufferInvertUV.setData(Je._verticesInvertUV.buffer), 
            this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV), 
            this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
        }
        static __init__() {
            Je._vertexDeclaration = new We(16, [ new ke(0, He.Vector4, Je.SCREENTRIANGLE_POSITION_UV) ]), 
            Je.instance = new Je(), Je.instance.lock = !0;
        }
        render() {
            var e = t.LayaGL.instance;
            this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
        }
        renderInvertUV() {
            var e = t.LayaGL.instance;
            this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
        }
        destroy() {
            super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), 
            this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0);
        }
    }
    Je.SCREENTRIANGLE_POSITION_UV = 0, Je._vertices = new Float32Array([ -1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0 ]), 
    Je._verticesInvertUV = new Float32Array([ -1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1 ]);
    class $e {
        constructor() {
            this._commandBuffer = null;
        }
        static __init__() {
            $e._screenShaderData = new W(), $e._screenShader = H.find("BlitScreen");
        }
        run() {}
        recover() {
            this._commandBuffer = null;
        }
    }
    $e.SCREENTEXTURE_NAME = "u_MainTex", $e.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale", 
    $e.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", $e.SCREENTEXTURE_ID = H.propertyNameToID($e.SCREENTEXTURE_NAME), 
    $e.SCREENTEXTUREOFFSETSCALE_ID = H.propertyNameToID($e.SCREENTEXTUREOFFSETSCALE_NAME), 
    $e.MAINTEXTURE_TEXELSIZE_ID = H.propertyNameToID($e.MAINTEXTURE_TEXELSIZE_NAME);
    class et extends $e {
        constructor() {
            super(...arguments), this._source = null, this._dest = null, this._offsetScale = null, 
            this._shader = null, this._shaderData = null, this._subShader = 0, this._sourceTexelSize = new a(), 
            this._screenType = 0;
        }
        static create(e, t, r = null, i = null, a = null, n = 0, s = et._SCREENTYPE_QUAD) {
            var o;
            return (o = et._pool.length > 0 ? et._pool.pop() : new et())._source = e, o._dest = t, 
            o._offsetScale = r, o._shader = i, o._shaderData = a, o._subShader = n, o._screenType = s, 
            o;
        }
        run() {
            var e = this._shader || $e._screenShader, r = this._shaderData || $e._screenShaderData, i = this._dest;
            t.LayaGL.instance.viewport(0, 0, i ? i.width : V.clientWidth, i ? i.height : V.clientHeight), 
            r.setTexture($e.SCREENTEXTURE_ID, this._source), r.setVector($e.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || et._defaultOffsetScale), 
            this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height), 
            r.setVector($e.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), i && i._start();
            for (var a = e.getSubShaderAt(this._subShader)._passes, n = 0, s = a.length; n < s; n++) {
                var o = et._compileDefine;
                r._defineDatas.cloneTo(o);
                var l = a[n].withCompile(o);
                switch (l.bind(), l.uploadUniforms(l._materialUniformParamsMap, r, !0), l.uploadRenderStateBlendDepth(r), 
                l.uploadRenderStateFrontFace(r, !1, null), this._screenType) {
                  case et._SCREENTYPE_QUAD:
                    V._instance.invertY ? Ke.instance.renderInvertUV() : Ke.instance.render();
                    break;

                  case et._SCREENTYPE_TRIANGLE:
                    V._instance.invertY ? Je.instance.renderInvertUV() : Je.instance.render();
                    break;

                  default:
                    throw "BlitScreenQuadCMD:unknown screen Type.";
                }
            }
            i && i._end();
        }
        recover() {
            et._pool.push(this), this._source = null, this._dest = null, this._offsetScale = null, 
            this._shader = null, this._shaderData = null, super.recover();
        }
    }
    et._SCREENTYPE_QUAD = 0, et._SCREENTYPE_TRIANGLE = 1, et._compileDefine = new F(), 
    et._pool = [], et._defaultOffsetScale = new a(0, 0, 1, 1);
    class tt extends $e {
        constructor() {
            super(...arguments), this._renderTexture = null;
        }
        static create(e) {
            var t;
            return (t = tt._pool.length > 0 ? tt._pool.pop() : new tt())._renderTexture = e, 
            t;
        }
        run() {
            this._renderTexture._start();
        }
        recover() {
            tt._pool.push(this), this._renderTexture = null;
        }
    }
    tt._pool = [];
    class rt extends $e {
        constructor() {
            super(...arguments), this._shaderData = null, this._nameID = 0, this._texture = null;
        }
        static create(e, t, r) {
            var i;
            return (i = rt._pool.length > 0 ? rt._pool.pop() : new rt())._shaderData = e, i._nameID = t, 
            i._texture = r, i;
        }
        run() {
            this._shaderData.setTexture(this._nameID, this._texture);
        }
        recover() {
            rt._pool.push(this), this._shaderData = null, this._nameID = 0, this._texture = null;
        }
    }
    rt._pool = [];
    class it {
        constructor() {
            this._camera = null, this._commands = [];
        }
        _apply() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run();
        }
        setShaderDataTexture(e, t, r) {
            this._commands.push(rt.create(e, t, r));
        }
        blitScreenQuad(e, t, r = null, i = null, a = null, n = 0) {
            this._commands.push(et.create(e, t, r, i, a, n, et._SCREENTYPE_QUAD));
        }
        blitScreenTriangle(e, t, r = null, i = null, a = null, n = 0) {
            this._commands.push(et.create(e, t, r, i, a, n, et._SCREENTYPE_TRIANGLE));
        }
        setRenderTarget(e) {
            this._commands.push(tt.create(e));
        }
        clear() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].recover();
            this._commands.length = 0;
        }
    }
    class at {}
    (ae = e.LightType || (e.LightType = {}))[ae.Directional = 0] = "Directional", ae[ae.Spot = 1] = "Spot", 
    ae[ae.Point = 2] = "Point";
    class nt extends ve {
        constructor() {
            super(), this._shadowMode = e.ShadowMode.None, this._isAlternate = !1, this._shadowResolution = 2048, 
            this._shadowDistance = 50, this._shadowDepthBias = 1, this._shadowNormalBias = 1, 
            this._shadowNearPlane = .1, this._shadowStrength = 1, this._intensity = 1, this._intensityColor = new n(), 
            this.color = new n(1, 1, 1), this._lightmapBakedType = nt.LIGHTMAPBAKEDTYPE_REALTIME;
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(e) {
            this._intensity = e;
        }
        get shadowMode() {
            return this._shadowMode;
        }
        set shadowMode(e) {
            this._shadowMode = e;
        }
        get shadowDistance() {
            return this._shadowDistance;
        }
        set shadowDistance(e) {
            this._shadowDistance = e;
        }
        get shadowResolution() {
            return this._shadowResolution;
        }
        set shadowResolution(e) {
            this._shadowResolution = e;
        }
        get shadowDepthBias() {
            return this._shadowDepthBias;
        }
        set shadowDepthBias(e) {
            this._shadowDepthBias = e;
        }
        get shadowNormalBias() {
            return this._shadowNormalBias;
        }
        set shadowNormalBias(e) {
            this._shadowNormalBias = e;
        }
        get shadowStrength() {
            return this._shadowStrength;
        }
        set shadowStrength(e) {
            this._shadowStrength = e;
        }
        get shadowNearPlane() {
            return this._shadowNearPlane;
        }
        set shadowNearPlane(e) {
            this._shadowNearPlane = e;
        }
        get lightmapBakedType() {
            return this._lightmapBakedType;
        }
        set lightmapBakedType(e) {
            this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== nt.LIGHTMAPBAKEDTYPE_BAKED ? this._addToScene() : this._removeFromScene()));
        }
        _parse(e, t) {
            super._parse(e, t);
            var r = e.color;
            this.color.fromArray(r), this.intensity = e.intensity, this.lightmapBakedType = e.lightmapBakedType;
        }
        _addToScene() {
            var e = this._scene, t = l._config.maxLightCount;
            e._lightCount < t ? (e._lightCount++, this._addToLightQueue(), this._isAlternate = !1) : (e._alternateLights.add(this), 
            this._isAlternate = !0, console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore."));
        }
        _removeFromScene() {
            var e = this._scene;
            if (this._isAlternate) e._alternateLights.remove(this); else if (e._lightCount--, 
            this._removeFromLightQueue(), e._alternateLights._length > 0) {
                var t = e._alternateLights.shift();
                t._addToLightQueue(), t._isAlternate = !1, e._lightCount++;
            }
        }
        _addToLightQueue() {}
        _removeFromLightQueue() {}
        _onActive() {
            super._onActive(), this.lightmapBakedType !== nt.LIGHTMAPBAKEDTYPE_BAKED && this._addToScene();
        }
        _onInActive() {
            super._onInActive(), this.lightmapBakedType !== nt.LIGHTMAPBAKEDTYPE_BAKED && this._removeFromScene();
        }
        _create() {
            return new nt();
        }
        get diffuseColor() {
            return console.log("LightSprite: discard property,please use color property instead."), 
            this.color;
        }
        set diffuseColor(e) {
            console.log("LightSprite: discard property,please use color property instead."), 
            this.color = e;
        }
    }
    nt.LIGHTMAPBAKEDTYPE_REALTIME = 0, nt.LIGHTMAPBAKEDTYPE_MIXED = 1, nt.LIGHTMAPBAKEDTYPE_BAKED = 2, 
    (ne = e.ShadowCascadesMode || (e.ShadowCascadesMode = {}))[ne.NoCascades = 0] = "NoCascades", 
    ne[ne.TwoCascades = 1] = "TwoCascades", ne[ne.FourCascades = 2] = "FourCascades", 
    function(e) {
        e[e.Near = 0] = "Near", e[e.Far = 1] = "Far", e[e.Left = 2] = "Left", e[e.Right = 3] = "Right", 
        e[e.Bottom = 4] = "Bottom", e[e.Top = 5] = "Top";
    }(se || (se = {}));
    class st {
        static supportShadow() {
            return t.LayaGL.layaGPUInstance._isWebGL2 || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.Depth);
        }
        static init() {
            t.LayaGL.layaGPUInstance._isWebGL2 ? st._shadowTextureFormat = t.RenderTextureFormat.ShadowMap : st._shadowTextureFormat = t.RenderTextureFormat.Depth;
        }
        static getTemporaryShadowTexture(e, r, i) {
            var a = B.createFromPool(e, r, st._shadowTextureFormat, i);
            return a.filterMode = t.FilterMode.Bilinear, a.wrapModeU = t.WarpMode.Clamp, a.wrapModeV = t.WarpMode.Clamp, 
            a;
        }
        static getShadowBias(t, i, a, n) {
            var s;
            t._lightType == e.LightType.Directional ? s = 2 / i.elements[0] : t._lightType == e.LightType.Spot ? s = Math.tan(.5 * t.spotAngle * r.Deg2Rad) * t.range : (console.warn("ShadowUtils:Only spot and directional shadow casters are supported now."), 
            s = 0);
            var o = s / a, l = -t._shadowDepthBias * o, _ = -t._shadowNormalBias * o;
            if (t.shadowMode == e.ShadowMode.SoftHigh) {
                const e = 2.5;
                l *= e, _ *= e;
            }
            n.setValue(l, _, 0, 0);
        }
        static getCameraFrustumPlanes(e, t) {
            Be.getPlanesFromMatrix(e, t[se.Near], t[se.Far], t[se.Left], t[se.Right], t[se.Top], t[se.Bottom]);
        }
        static getFarWithRadius(e, t) {
            return Math.sqrt(e * e / t);
        }
        static getCascadesSplitDistance(t, r, i, a, n, s, o, l) {
            l[0] = i;
            var _ = a - i, h = Math.tan(.5 * n), c = 1 + h * h * (s * s + 1);
            switch (o) {
              case e.ShadowCascadesMode.NoCascades:
                l[1] = st.getFarWithRadius(a, c);
                break;

              case e.ShadowCascadesMode.TwoCascades:
                l[1] = st.getFarWithRadius(i + _ * t, c), l[2] = st.getFarWithRadius(a, c);
                break;

              case e.ShadowCascadesMode.FourCascades:
                l[1] = st.getFarWithRadius(i + _ * r.x, c), l[2] = st.getFarWithRadius(i + _ * r.y, c), 
                l[3] = st.getFarWithRadius(i + _ * r.z, c), l[4] = st.getFarWithRadius(a, c);
            }
        }
        static applySliceTransform(e, t, r, i, a) {
            var n = st._tempMatrix0.elements, s = 1 / t, o = 1 / r;
            n[0] = e.resolution * s, n[5] = e.resolution * o, n[12] = e.offsetX * s, n[13] = e.offsetY * o, 
            n[1] = n[2] = n[2] = n[4] = n[6] = n[7] = n[8] = n[9] = n[11] = n[14] = 0, n[10] = n[15] = 1;
            var l = 16 * i;
            I._mulMatrixArray(n, a, l, a, l);
        }
        static getDirectionLightShadowCullPlanes(t, r, i, a, s, o) {
            var l = st._frustumCorners, _ = st._backPlaneFaces, h = st._frustumPlaneNeighbors, c = st._frustumTwoPlaneCorners, d = st._edgePlanePoint2, u = o.cullPlanes, m = t[se.Near], f = t[se.Far], E = t[se.Left], T = t[se.Right], p = t[se.Bottom], g = t[se.Top], S = i[r] - a, R = st._adjustNearPlane, v = st._adjustFarPlane;
            m.normal.cloneTo(R.normal), f.normal.cloneTo(v.normal), R.distance = m.distance - S, 
            v.distance = Math.min(-m.distance + o.sphereCenterZ + o.splitBoundSphere.radius, f.distance), 
            Be.get3PlaneInterPoint(R, p, T, l[e.FrustumCorner.nearBottomRight]), Be.get3PlaneInterPoint(R, g, T, l[e.FrustumCorner.nearTopRight]), 
            Be.get3PlaneInterPoint(R, g, E, l[e.FrustumCorner.nearTopLeft]), Be.get3PlaneInterPoint(R, p, E, l[e.FrustumCorner.nearBottomLeft]), 
            Be.get3PlaneInterPoint(v, p, T, l[e.FrustumCorner.FarBottomRight]), Be.get3PlaneInterPoint(v, g, T, l[e.FrustumCorner.FarTopRight]), 
            Be.get3PlaneInterPoint(v, g, E, l[e.FrustumCorner.FarTopLeft]), Be.get3PlaneInterPoint(v, p, E, l[e.FrustumCorner.FarBottomLeft]);
            for (var x = 0, I = 0; I < 6; I++) {
                var A;
                switch (I) {
                  case se.Near:
                    A = R;
                    break;

                  case se.Far:
                    A = v;
                    break;

                  default:
                    A = t[I];
                }
                n.dot(A.normal, s) < 0 && (A.cloneTo(u[x]), _[x] = I, x++);
            }
            var L = x;
            for (I = 0; I < x; I++) for (var C = _[I], D = h[C], M = 0; M < 4; M++) {
                for (var y = D[M], O = !0, N = 0; N < x; N++) if (y == _[N]) {
                    O = !1;
                    break;
                }
                if (O) {
                    var b = c[C][y], P = l[b[0]], w = l[b[1]];
                    n.add(P, s, d), be.createPlaneBy3P(P, w, d, u[L++]);
                }
            }
            o.cullPlaneCount = L;
        }
        static getBoundSphereByFrustum(e, t, r, i, a, s, o) {
            var l, _, h = Math.sqrt(1 + i * i) * Math.tan(r / 2), c = h * h, d = t - e, u = t + e;
            c > d / u ? (l = t, _ = t * h) : (l = .5 * u * (1 + c), _ = .5 * Math.sqrt(d * d + 2 * (t * t + e * e) * c + u * u * c * c));
            var m = o.center;
            return o.radius = _, n.scale(s, l, m), n.add(a, m, m), l;
        }
        static getMaxTileResolutionInAtlas(e, t, r) {
            for (var i = Math.min(e, t), a = Math.floor(e / i) * Math.floor(t / i); a < r; ) i = Math.floor(i >> 1), 
            a = Math.floor(e / i) * Math.floor(t / i);
            return i;
        }
        static getDirectionalLightMatrices(e, t, r, i, a, s, o, l) {
            var _ = o.splitBoundSphere, h = _.center, c = _.radius, d = s / 2, u = c * d / (d - st.atlasBorderSize), m = 2 * u, f = s / m, E = m / s, T = Math.ceil(n.dot(h, e) * f) * E, p = Math.ceil(n.dot(h, t) * f) * E, g = n.dot(h, r);
            h.x = e.x * T + t.x * p + r.x * g, h.y = e.y * T + t.y * p + r.y * g, h.z = e.z * T + t.z * p + r.z * g;
            var S = o.position, R = o.viewMatrix, v = o.projectionMatrix, x = o.viewProjectMatrix;
            o.resolution = s, o.offsetX = i % 2 * s, o.offsetY = Math.floor(i / 2) * s, n.scale(r, c + a, S), 
            n.subtract(h, S, S), y.createLookAt(S, h, e, R), y.createOrthoOffCenter(-u, u, -u, u, 0, 2 * c + a, v), 
            y.multiply(v, R, x), I._mulMatrixArray(st._shadowMapScaleOffsetMatrix.elements, x.elements, 0, l, 16 * i);
        }
        static prepareShadowReceiverShaderValues(e, t, r, i, a, n, s, o, l) {
            if (n.setValue(1 / t, 1 / r, t, r), s.setValue(e._shadowStrength, 0, 0, 0), a > 1) {
                const e = 16;
                for (var _ = a * e, h = 4 * e; _ < h; _++) o[_] = 0;
                for (_ = 0; _ < a; _++) {
                    var c = i[_].splitBoundSphere, d = c.center, u = c.radius, m = 4 * _;
                    l[m] = d.x, l[m + 1] = d.y, l[m + 2] = d.z, l[m + 3] = u * u;
                }
                const t = 4;
                for (_ = a * t, h = 4 * t; _ < h; _++) l[_] = 0;
            }
        }
    }
    st._tempMatrix0 = new y(), st._shadowMapScaleOffsetMatrix = new y(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, 1, 0, .5, .5, 0, 1), 
    st._frustumCorners = [ new n(), new n(), new n(), new n(), new n(), new n(), new n(), new n() ], 
    st._adjustNearPlane = new be(new n()), st._adjustFarPlane = new be(new n()), st._backPlaneFaces = new Array(5), 
    st._edgePlanePoint2 = new n(), st._frustumPlaneNeighbors = [ [ se.Left, se.Right, se.Top, se.Bottom ], [ se.Left, se.Right, se.Top, se.Bottom ], [ se.Near, se.Far, se.Top, se.Bottom ], [ se.Near, se.Far, se.Top, se.Bottom ], [ se.Near, se.Far, se.Left, se.Right ], [ se.Near, se.Far, se.Left, se.Right ] ], 
    st._frustumTwoPlaneCorners = [ [ [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearTopLeft ], [ e.FrustumCorner.nearTopRight, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearTopRight ] ], [ [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarTopRight ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.FarTopLeft ] ], [ [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarTopLeft ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.nearTopLeft ] ], [ [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearTopRight ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.nearTopRight, e.FrustumCorner.FarTopRight ] ], [ [ e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearBottomRight ], [ e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarBottomLeft ], [ e.FrustumCorner.FarBottomLeft, e.FrustumCorner.nearBottomLeft ], [ e.FrustumCorner.nearBottomRight, e.FrustumCorner.FarBottomRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ] ], [ [ e.FrustumCorner.nearTopRight, e.FrustumCorner.nearTopLeft ], [ e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarTopRight ], [ e.FrustumCorner.nearTopLeft, e.FrustumCorner.FarTopLeft ], [ e.FrustumCorner.FarTopRight, e.FrustumCorner.nearTopRight ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ], [ e.FrustumCorner.unknown, e.FrustumCorner.unknown ] ] ], 
    st.atlasBorderSize = 4, (oe = e.CameraClearFlags || (e.CameraClearFlags = {}))[oe.SolidColor = 0] = "SolidColor", 
    oe[oe.Sky = 1] = "Sky", oe[oe.DepthOnly = 2] = "DepthOnly", oe[oe.Nothing = 3] = "Nothing";
    class ot extends Qe {
        constructor(r = 0, n = .3, s = 1e3) {
            super(n, s), this._updateViewMatrix = !0, this._postProcess = null, this._enableHDR = !1, 
            this._viewportParams = new a(), this._projectionParams = new a(), this._offScreenRenderTexture = null, 
            this._internalRenderTexture = null, this._postProcessCommandBuffers = [], this._clusterPlaneCacheFlag = new i(-1, -1), 
            this._screenOffsetScale = new a(), this.enableRender = !0, this.clearFlag = e.CameraClearFlags.SolidColor, 
            this._viewMatrix = new y(), this._projectionMatrix = new y(), this._projectionViewMatrix = new y(), 
            this._viewport = new Fe(0, 0, 0, 0), this._normalizedViewport = new Fe(0, 0, 1, 1), 
            this._aspectRatio = r, this._boundFrustum = new Be(new y()), t.Render.supportWebGLPlusCulling && (this._boundFrustumBuffer = new Float32Array(24)), 
            this._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE, this, this._onScreenSizeChanged), 
            this.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        get aspectRatio() {
            if (0 === this._aspectRatio) {
                var e = this.viewport;
                return e.width / e.height;
            }
            return this._aspectRatio;
        }
        set aspectRatio(e) {
            if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
            this._aspectRatio = e, this._calculateProjectionMatrix();
        }
        get viewport() {
            return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, V.clientWidth, V.clientHeight), 
            this._viewport;
        }
        set viewport(e) {
            var t, r;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = V.clientWidth, 
            r = V.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / r, 
            this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / r, 
            this._calculationViewport(this._normalizedViewport, t, r), this._calculateProjectionMatrix();
        }
        get normalizedViewport() {
            return this._normalizedViewport;
        }
        set normalizedViewport(e) {
            var t, r;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = V.clientWidth, 
            r = V.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport), 
            this._calculationViewport(e, t, r), this._calculateProjectionMatrix();
        }
        get viewMatrix() {
            if (this._updateViewMatrix) {
                var e = this.transform.getWorldLossyScale(), t = e.x, r = e.y, i = e.z, a = this._viewMatrix.elements;
                this.transform.worldMatrix.cloneTo(this._viewMatrix), a[0] /= t, a[1] /= t, a[2] /= t, 
                a[4] /= r, a[5] /= r, a[6] /= r, a[8] /= i, a[9] /= i, a[10] /= i, this._viewMatrix.invert(this._viewMatrix), 
                this._updateViewMatrix = !1;
            }
            return this._viewMatrix;
        }
        get projectionMatrix() {
            return this._projectionMatrix;
        }
        set projectionMatrix(e) {
            this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
        }
        get projectionViewMatrix() {
            return y.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix), 
            this._projectionViewMatrix;
        }
        get boundFrustum() {
            if (this._boundFrustum.matrix = this.projectionViewMatrix, t.Render.supportWebGLPlusCulling) {
                var e = this._boundFrustum.near, r = this._boundFrustum.far, i = this._boundFrustum.left, a = this._boundFrustum.right, n = this._boundFrustum.top, s = this._boundFrustum.bottom, o = e.normal, l = r.normal, _ = i.normal, h = a.normal, c = n.normal, d = s.normal, u = this._boundFrustumBuffer;
                u[0] = o.x, u[1] = o.y, u[2] = o.z, u[3] = e.distance, u[4] = l.x, u[5] = l.y, u[6] = l.z, 
                u[7] = r.distance, u[8] = _.x, u[9] = _.y, u[10] = _.z, u[11] = i.distance, u[12] = h.x, 
                u[13] = h.y, u[14] = h.z, u[15] = a.distance, u[16] = c.x, u[17] = c.y, u[18] = c.z, 
                u[19] = n.distance, u[20] = d.x, u[21] = d.y, u[22] = d.z, u[23] = s.distance;
            }
            return this._boundFrustum;
        }
        get renderTarget() {
            return this._offScreenRenderTexture;
        }
        set renderTarget(e) {
            var t = this._offScreenRenderTexture;
            t !== e && (t && (t._isCameraTarget = !1), e && (e._isCameraTarget = !0), this._offScreenRenderTexture = e, 
            this._calculateProjectionMatrix());
        }
        get postProcess() {
            return this._postProcess;
        }
        set postProcess(e) {
            this._postProcess = e;
            var t = new it();
            this.addCommandBuffer(ot.CAMERAEVENT_POSTPROCESS, t), e._init(this, t);
        }
        get enableHDR() {
            return this._enableHDR;
        }
        set enableHDR(e) {
            !e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.R16G16B16A16) ? this._enableHDR = e : console.warn("Camera:can't enable HDR in this device.");
        }
        _calculationViewport(e, t, r) {
            var i = e.x * t, a = e.y * r, n = i + Math.max(e.width * t, 0), s = a + Math.max(e.height * r, 0), o = Math.ceil(i), l = Math.ceil(a), _ = Math.floor(n), h = Math.floor(s), c = o - i >= .5 ? Math.floor(i) : o, d = l - a >= .5 ? Math.floor(a) : l, u = n - _ >= .5 ? Math.ceil(n) : _, m = s - h >= .5 ? Math.ceil(s) : h;
            this._viewport.x = c, this._viewport.y = d, this._viewport.width = u - c, this._viewport.height = m - d;
        }
        _calculateProjectionMatrix() {
            if (!this._useUserProjectionMatrix) if (this._orthographic) {
                var e = .5 * this.orthographicVerticalSize, t = e * this.aspectRatio;
                y.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
            } else y.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
        }
        _isLayerVisible(e) {
            return 0 != (Math.pow(2, e) & this.cullingMask);
        }
        _onTransformChanged(e) {
            (e &= Re.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
        }
        _parse(e, t) {
            super._parse(e, t);
            var r = e.clearFlag;
            void 0 !== r && (this.clearFlag = r);
            var i = e.viewport;
            this.normalizedViewport = new Fe(i[0], i[1], i[2], i[3]);
            var a = e.enableHDR;
            void 0 !== a && (this.enableHDR = a);
        }
        _getCanvasWidth() {
            return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : V.clientWidth;
        }
        _getCanvasHeight() {
            return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : V.clientHeight;
        }
        _getRenderTexture() {
            return this._internalRenderTexture || this._offScreenRenderTexture;
        }
        _needInternalRenderTexture() {
            return !(!this._postProcess && !this._enableHDR);
        }
        _applyPostProcessCommandBuffers() {
            for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) this._postProcessCommandBuffers[e]._apply();
        }
        _getRenderTextureFormat() {
            return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t.RenderTextureFormat.R8G8B8;
        }
        _prepareCameraToRender() {
            super._prepareCameraToRender();
            var e = this.viewport;
            this._viewportParams.setValue(e.x, e.y, e.width, e.height), this._projectionParams.setValue(this._nearPlane, this._farPlane, V._instance.invertY ? -1 : 1, 0), 
            this._shaderValues.setVector(Qe.VIEWPORT, this._viewportParams), this._shaderValues.setVector(Qe.PROJECTION_PARAMS, this._projectionParams);
        }
        _applyViewProject(e, t, r) {
            var i, a = this._shaderValues;
            e.invertY ? (y.multiply(Qe._invertYScaleMatrix, r, Qe._invertYProjectionMatrix), 
            y.multiply(Qe._invertYProjectionMatrix, t, Qe._invertYProjectionViewMatrix), r = Qe._invertYProjectionMatrix, 
            i = Qe._invertYProjectionViewMatrix) : (y.multiply(r, t, this._projectionViewMatrix), 
            i = this._projectionViewMatrix), e.viewMatrix = t, e.projectionMatrix = r, e.projectionViewMatrix = i, 
            a.setMatrix4x4(Qe.VIEWMATRIX, t), a.setMatrix4x4(Qe.PROJECTMATRIX, r), a.setMatrix4x4(Qe.VIEWPROJECTMATRIX, i);
        }
        _updateClusterPlaneXY() {
            var e = this.fieldOfView, t = this.aspectRatio;
            if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !== t) {
                var r = l._config.lightClusterCount, i = r.x, a = r.y, s = i + 1, o = a + 1, _ = this._clusterXPlanes, h = this._clusterYPlanes;
                if (!_) {
                    _ = this._clusterXPlanes = new Array(s), h = this._clusterYPlanes = new Array(o);
                    for (var c = 0; c < s; c++) _[c] = new n();
                    for (c = 0; c < o; c++) h[c] = new n();
                }
                var d = Math.tan(this.fieldOfView / 2 * Math.PI / 180), u = this.aspectRatio * d, m = 2 * d / i, f = 2 * u / a;
                for (c = 0; c < s; c++) {
                    var E = f * c - u, T = 1 / Math.sqrt(1 + E * E);
                    _[c].setValue(T, 0, -E * T);
                }
                for (c = 0; c < o; c++) {
                    E = d - m * c;
                    var p = -1 / Math.sqrt(1 + E * E);
                    h[c].setValue(0, p, -E * p);
                }
                this._clusterPlaneCacheFlag.x = e, this._clusterPlaneCacheFlag.y = t;
            }
        }
        render(r = null, i = null) {
            if (this.activeInHierarchy) {
                var a, n = this.viewport, s = this._needInternalRenderTexture(), o = t.LayaGL.instance, h = V._instance, c = h.scene = this._scene;
                h.pipelineMode = "Forward", s ? (this._internalRenderTexture = B.createFromPool(n.width, n.height, this._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTH_16), 
                this._internalRenderTexture.filterMode = t.FilterMode.Bilinear) : this._internalRenderTexture = null;
                var d = c._mainLight, u = d && d.shadowMode !== e.ShadowMode.None && st.supportShadow();
                if (u ? (c._shaderValues.addDefine(at.SHADERDEFINE_SHADOW), (a = _.Scene3D._shadowCasterPass).update(this, d), 
                a.render(h, c)) : c._shaderValues.removeDefine(at.SHADERDEFINE_SHADOW), h.camera = this, 
                h.cameraShaderValue = this._shaderValues, ot._updateMark++, c._preRenderScript(), 
                s && !this._offScreenRenderTexture && (this.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e.CameraClearFlags.Nothing)) if (this._enableHDR) {
                    var m = B.createFromPool(n.width, n.height, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16);
                    m.filterMode = t.FilterMode.Bilinear, t.WebGLContext.bindTexture(o, o.TEXTURE_2D, m._getSource()), 
                    o.copyTexSubImage2D(o.TEXTURE_2D, 0, 0, 0, n.x, V.clientHeight - (n.y + n.height), n.width, n.height), 
                    (E = et.create(m, this._internalRenderTexture)).run(), E.recover(), B.recoverToPool(m);
                } else t.WebGLContext.bindTexture(o, o.TEXTURE_2D, this._internalRenderTexture._getSource()), 
                o.copyTexSubImage2D(o.TEXTURE_2D, 0, 0, 0, n.x, V.clientHeight - (n.y + n.height), n.width, n.height);
                var f = this._getRenderTexture();
                if (f && f._start(), h.viewport = n, this._prepareCameraToRender(), l._config._multiLighting && Me.instance.update(this, this._scene), 
                this._applyViewProject(h, this.viewMatrix, this._projectionMatrix), c._preCulling(h, this, r, i), 
                c._clear(o, h), c._renderScene(h), c._postRenderScript(), f && f._end(), s) {
                    if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers(); else if (this._enableHDR) {
                        var E, T = this._getCanvasWidth(), p = this._getCanvasHeight();
                        this._screenOffsetScale.setValue(n.x / T, n.y / p, n.width / T, n.height / p), (E = et.create(this._internalRenderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null, this._screenOffsetScale)).run(), 
                        E.recover();
                    }
                    B.recoverToPool(this._internalRenderTexture);
                }
                u && a.cleanUp();
            }
        }
        viewportPointToRay(e, t) {
            Ue.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }
        normalizedViewportPointToRay(e, t) {
            var r = ot._tempVector20, i = this.viewport;
            r.x = e.x * i.width, r.y = e.y * i.height, Ue.calculateCursorRay(r, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }
        worldToViewportPoint(e, r) {
            y.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
            this.viewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX, 
            r.y = r.y / t.Laya.stage.clientScaleY;
        }
        worldToNormalizedViewportPoint(e, r) {
            y.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
            this.normalizedViewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX, 
            r.y = r.y / t.Laya.stage.clientScaleY;
        }
        convertScreenCoordToOrthographicCoord(e, r) {
            if (this._orthographic) {
                var i = V.clientWidth, a = V.clientHeight, s = this.orthographicVerticalSize * this.aspectRatio / i, o = this.orthographicVerticalSize / a;
                return r.x = (-i / 2 + e.x * t.Laya.stage.clientScaleX) * s, r.y = (a / 2 - e.y * t.Laya.stage.clientScaleY) * o, 
                r.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane, n.transformCoordinate(r, this.transform.worldMatrix, r), 
                !0;
            }
            return !1;
        }
        destroy(e = !0) {
            this._offScreenRenderTexture = null, this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged), 
            super.destroy(e);
        }
        addCommandBuffer(e, t) {
            switch (e) {
              case ot.CAMERAEVENT_POSTPROCESS:
                this._postProcessCommandBuffers.push(t), t._camera = this;
                break;

              default:
                throw "Camera:unknown event.";
            }
        }
        removeCommandBuffer(e, t) {
            switch (e) {
              case ot.CAMERAEVENT_POSTPROCESS:
                var r = this._postProcessCommandBuffers.indexOf(t);
                -1 !== r && this._postProcessCommandBuffers.splice(r, 1);
                break;

              default:
                throw "Camera:unknown event.";
            }
        }
        removeCommandBuffers(e) {
            switch (e) {
              case ot.CAMERAEVENT_POSTPROCESS:
                this._postProcessCommandBuffers.length = 0;
                break;

              default:
                throw "Camera:unknown event.";
            }
        }
        _create() {
            return new ot();
        }
    }
    ot.CAMERAEVENT_POSTPROCESS = 0, ot._tempVector20 = new i(), ot._updateMark = 0;
    class lt {
        constructor() {
            this.succeeded = !1, this.collider = null, this.point = new n(), this.normal = new n(), 
            this.hitFraction = 0;
        }
    }
    class _t {
        constructor() {}
        static setColliderCollision(e, t, r) {}
        static getIColliderCollision(e, t) {
            return !1;
        }
    }
    _t.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, _t.COLLISIONFILTERGROUP_STATICFILTER = 2, 
    _t.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, _t.COLLISIONFILTERGROUP_DEBRISFILTER = 8, 
    _t.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, _t.COLLISIONFILTERGROUP_CHARACTERFILTER = 32, 
    _t.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, _t.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128, 
    _t.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, _t.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512, 
    _t.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, _t.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048, 
    _t.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, _t.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192, 
    _t.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, _t.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768, 
    _t.COLLISIONFILTERGROUP_ALLFILTER = -1, _t.gravity = new n(0, -9.81, 0);
    class ht extends Te {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
            this._add(e), e._inPhysicUpdateListIndex = this.length++;
        }
        remove(e) {
            var t = e._inPhysicUpdateListIndex;
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._inPhysicUpdateListIndex = t;
            }
            e._inPhysicUpdateListIndex = -1;
        }
    }
    class ct {
        constructor() {
            this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0, 
            this.normal = new n(), this.positionOnA = new n(), this.positionOnB = new n(), this._id = ++this._idCounter;
        }
    }
    class dt {
        constructor() {
            this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1, 
            this.contacts = [];
        }
        _setUpdateFrame(e) {
            this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
        }
    }
    class ut {
        constructor() {
            this._hitResultsPoolIndex = 0, this._hitResultsPool = [], this._contactPonintsPoolIndex = 0, 
            this._contactPointsPool = [], this._collisionsPool = [], this._collisions = {};
        }
        getHitResult() {
            var e = this._hitResultsPool[this._hitResultsPoolIndex++];
            return e || (e = new lt(), this._hitResultsPool.push(e)), e;
        }
        recoverAllHitResultsPool() {
            this._hitResultsPoolIndex = 0;
        }
        getContactPoints() {
            var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
            return e || (e = new ct(), this._contactPointsPool.push(e)), e;
        }
        recoverAllContactPointsPool() {
            this._contactPonintsPoolIndex = 0;
        }
        getCollision(e, t) {
            var r, i = e.id, a = t.id, n = this._collisions[i];
            return n && (r = n[a]), r || (n || (n = {}, this._collisions[i] = n), (r = 0 === this._collisionsPool.length ? new dt() : this._collisionsPool.pop())._colliderA = e, 
            r._colliderB = t, n[a] = r), r;
        }
        recoverCollision(e) {
            var t = e._colliderA.id, r = e._colliderB.id;
            this._collisions[t][r] = null, this._collisionsPool.push(e);
        }
        garbageCollection() {
            for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0, 
            this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                var t = this._collisionsPool[e], r = !0;
                for (var i in t) t[i] ? r = !1 : delete t[i];
                r && delete this._collisionsPool[e];
            }
        }
    }
    class mt {
        constructor() {
            this._scale = new n(1, 1, 1), this._centerMatrix = new y(), this._attatched = !1, 
            this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null, 
            this._referenceCount = 0, this._localOffset = new n(0, 0, 0), this._localRotation = new f(0, 0, 0, 1), 
            this.needsCustomCollisionCallback = !1;
        }
        static __init__() {
            var e = v._bullet;
            mt._btScale = e.btVector3_create(1, 1, 1), mt._btVector30 = e.btVector3_create(0, 0, 0), 
            mt._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), mt._btTransform0 = e.btTransform_create();
        }
        static _createAffineTransformation(e, t, r) {
            var i = t.x, a = t.y, n = t.z, s = t.w, o = i + i, l = a + a, _ = n + n, h = i * o, c = i * l, d = i * _, u = a * l, m = a * _, f = n * _, E = s * o, T = s * l, p = s * _;
            r[0] = 1 - (u + f), r[1] = c + p, r[2] = d - T, r[3] = 0, r[4] = c - p, r[5] = 1 - (h + f), 
            r[6] = m + E, r[7] = 0, r[8] = d + T, r[9] = m - E, r[10] = 1 - (h + u), r[11] = 0, 
            r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
        }
        get type() {
            return this._type;
        }
        get localOffset() {
            return this._localOffset;
        }
        set localOffset(e) {
            this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }
        get localRotation() {
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }
        _setScale(e) {
            if (this._compoundParent) this.updateLocalTransformations(); else {
                var t = v._bullet;
                t.btVector3_setValue(mt._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, mt._btScale);
            }
        }
        _addReference() {
            this._referenceCount++;
        }
        _removeReference() {
            this._referenceCount--;
        }
        updateLocalTransformations() {
            if (this._compoundParent) {
                var e = mt._tempVector30;
                n.multiply(this.localOffset, this._scale, e), mt._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
            } else mt._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
        }
        cloneTo(e) {
            var t = e;
            this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation), 
            t.localOffset = t.localOffset, t.localRotation = t.localRotation;
        }
        clone() {
            return null;
        }
        destroy() {
            this._btShape && (v._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
        }
    }
    mt.SHAPEORIENTATION_UPX = 0, mt.SHAPEORIENTATION_UPY = 1, mt.SHAPEORIENTATION_UPZ = 2, 
    mt.SHAPETYPES_BOX = 0, mt.SHAPETYPES_SPHERE = 1, mt.SHAPETYPES_CYLINDER = 2, mt.SHAPETYPES_CAPSULE = 3, 
    mt.SHAPETYPES_CONVEXHULL = 4, mt.SHAPETYPES_COMPOUND = 5, mt.SHAPETYPES_STATICPLANE = 6, 
    mt.SHAPETYPES_CONE = 7, mt._tempVector30 = new n();
    class ft extends mt {
        static __init__() {
            ft._btSize = v._bullet.btVector3_create(0, 0, 0);
        }
        get sizeX() {
            return this._sizeX;
        }
        get sizeY() {
            return this._sizeY;
        }
        get sizeZ() {
            return this._sizeZ;
        }
        constructor(e = 1, t = 1, r = 1) {
            super(), this._sizeX = e, this._sizeY = t, this._sizeZ = r, this._type = mt.SHAPETYPES_BOX;
            var i = v._bullet;
            i.btVector3_setValue(ft._btSize, e / 2, t / 2, r / 2), this._btShape = i.btBoxShape_create(ft._btSize);
        }
        clone() {
            var e = new ft(this._sizeX, this._sizeY, this._sizeZ);
            return this.cloneTo(e), e;
        }
    }
    class Et extends mt {
        constructor(e = .5, t = 1.25, r = mt.SHAPEORIENTATION_UPY) {
            super(), this._radius = e, this._length = t, this._orientation = r, this._type = mt.SHAPETYPES_CAPSULE;
            var i = v._bullet;
            switch (r) {
              case mt.SHAPEORIENTATION_UPX:
                this._btShape = i.btCapsuleShapeX_create(e, t - 2 * e);
                break;

              case mt.SHAPEORIENTATION_UPY:
                this._btShape = i.btCapsuleShape_create(e, t - 2 * e);
                break;

              case mt.SHAPEORIENTATION_UPZ:
                this._btShape = i.btCapsuleShapeZ_create(e, t - 2 * e);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        get length() {
            return this._length;
        }
        get orientation() {
            return this._orientation;
        }
        _setScale(e) {
            var t = Et._tempVector30;
            switch (this.orientation) {
              case mt.SHAPEORIENTATION_UPX:
                t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
                break;

              case mt.SHAPEORIENTATION_UPY:
                t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
                break;

              case mt.SHAPEORIENTATION_UPZ:
                t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            super._setScale(t);
        }
        clone() {
            var e = new Et(this._radius, this._length, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    Et._tempVector30 = new n();
    class Tt extends mt {
        constructor() {
            super(), this._childColliderShapes = [], this._type = mt.SHAPETYPES_COMPOUND, this._btShape = v._bullet.btCompoundShape_create();
        }
        static __init__() {
            var e = v._bullet;
            Tt._btVector3One = e.btVector3_create(1, 1, 1), Tt._btTransform = e.btTransform_create(), 
            Tt._btOffset = e.btVector3_create(0, 0, 0), Tt._btRotation = e.btQuaternion_create(0, 0, 0, 1);
        }
        _clearChildShape(e) {
            e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
        }
        _addReference() {}
        _removeReference() {}
        _updateChildTransform(e) {
            var t = v._bullet, r = e.localOffset, i = e.localRotation, a = mt._btVector30, n = mt._btQuaternion0, s = mt._btTransform0;
            t.btVector3_setValue(a, -r.x, r.y, r.z), t.btQuaternion_setValue(n, -i.x, i.y, i.z, -i.w), 
            t.btTransform_setOrigin(s, a), t.btTransform_setRotation(s, n), t.btCompoundShape_updateChildTransform(this._btShape, e._indexInCompound, s, !0);
        }
        addChildShape(e) {
            if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
            e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length, 
            this._childColliderShapes.push(e);
            var t = e.localOffset, r = e.localRotation, i = v._bullet;
            i.btVector3_setValue(Tt._btOffset, -t.x, t.y, t.z), i.btQuaternion_setValue(Tt._btRotation, -r.x, r.y, r.z, -r.w), 
            i.btTransform_setOrigin(Tt._btTransform, Tt._btOffset), i.btTransform_setRotation(Tt._btTransform, Tt._btRotation);
            var a = i.btCollisionShape_getLocalScaling(this._btShape);
            i.btCollisionShape_setLocalScaling(this._btShape, Tt._btVector3One), i.btCompoundShape_addChildShape(this._btShape, Tt._btTransform, e._btShape), 
            i.btCollisionShape_setLocalScaling(this._btShape, a), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
        }
        removeChildShape(e) {
            if (e._compoundParent === this) {
                var t = e._indexInCompound;
                this._clearChildShape(e);
                var r = this._childColliderShapes[this._childColliderShapes.length - 1];
                r._indexInCompound = t, this._childColliderShapes[t] = r, this._childColliderShapes.pop(), 
                v._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, t);
            }
        }
        clearChildShape() {
            for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this._clearChildShape(this._childColliderShapes[e]), 
            v._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
            this._childColliderShapes.length = 0;
        }
        getChildShapeCount() {
            return this._childColliderShapes.length;
        }
        cloneTo(e) {
            var t = e;
            t.clearChildShape();
            for (var r = 0, i = this._childColliderShapes.length; r < i; r++) t.addChildShape(this._childColliderShapes[r].clone());
        }
        clone() {
            var e = new Tt();
            return this.cloneTo(e), e;
        }
        destroy() {
            super.destroy();
            for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                var r = this._childColliderShapes[e];
                0 === r._referenceCount && r.destroy();
            }
        }
    }
    class pt extends mt {
        constructor(e = .5, t = 1, r = mt.SHAPEORIENTATION_UPY) {
            super(), this._radius = 1, this._height = .5, this._radius = e, this._height = t, 
            this._orientation = r, this._type = mt.SHAPETYPES_CYLINDER;
            var i = v._bullet;
            switch (r) {
              case mt.SHAPEORIENTATION_UPX:
                this._btShape = i.btConeShapeX_create(e, t);
                break;

              case mt.SHAPEORIENTATION_UPY:
                this._btShape = i.btConeShape_create(e, t);
                break;

              case mt.SHAPEORIENTATION_UPZ:
                this._btShape = i.btConeShapeZ_create(e, t);
                break;

              default:
                throw "ConeColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        get height() {
            return this._height;
        }
        get orientation() {
            return this._orientation;
        }
        clone() {
            var e = new pt(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    class gt extends mt {
        constructor(e = .5, t = 1, r = mt.SHAPEORIENTATION_UPY) {
            super(), this._radius = 1, this._height = .5, this._radius = e, this._height = t, 
            this._orientation = r, this._type = mt.SHAPETYPES_CYLINDER;
            var i = v._bullet;
            switch (r) {
              case mt.SHAPEORIENTATION_UPX:
                i.btVector3_setValue(gt._btSize, t / 2, e, e), this._btShape = i.btCylinderShapeX_create(gt._btSize);
                break;

              case mt.SHAPEORIENTATION_UPY:
                i.btVector3_setValue(gt._btSize, e, t / 2, e), this._btShape = i.btCylinderShape_create(gt._btSize);
                break;

              case mt.SHAPEORIENTATION_UPZ:
                i.btVector3_setValue(gt._btSize, e, e, t / 2), this._btShape = i.btCylinderShapeZ_create(gt._btSize);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        static __init__() {
            gt._btSize = v._bullet.btVector3_create(0, 0, 0);
        }
        get radius() {
            return this._radius;
        }
        get height() {
            return this._height;
        }
        get orientation() {
            return this._orientation;
        }
        clone() {
            var e = new gt(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    class St extends mt {
        constructor() {
            super(), this._mesh = null, this._convex = !1;
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            if (this._mesh !== e) {
                var t = v._bullet;
                this._mesh && t.destroy(this._btShape), e && (this._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()), 
                t.btGImpactShapeInterface_updateBound(this._btShape)), this._mesh = e;
            }
        }
        get convex() {
            return this._convex;
        }
        set convex(e) {
            this._convex = e;
        }
        _setScale(e) {
            if (this._compoundParent) this.updateLocalTransformations(); else {
                var t = v._bullet;
                t.btVector3_setValue(mt._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, mt._btScale), 
                t.btGImpactShapeInterface_updateBound(this._btShape);
            }
        }
        cloneTo(e) {
            var t = e;
            t.convex = this._convex, t.mesh = this._mesh, super.cloneTo(e);
        }
        clone() {
            var e = new St();
            return this.cloneTo(e), e;
        }
        destroy() {
            this._btShape && (v._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
        }
    }
    class Rt extends mt {
        get radius() {
            return this._radius;
        }
        constructor(e = .5) {
            super(), this._radius = e, this._type = mt.SHAPETYPES_SPHERE, this._btShape = v._bullet.btSphereShape_create(e);
        }
        clone() {
            var e = new Rt(this._radius);
            return this.cloneTo(e), e;
        }
    }
    class vt extends t.Component {
        constructor(e, t) {
            super(), this._restitution = 0, this._friction = .5, this._rollingFriction = 0, 
            this._ccdMotionThreshold = 0, this._ccdSweptSphereRadius = 0, this._collisionGroup = _t.COLLISIONFILTERGROUP_DEFAULTFILTER, 
            this._canCollideWith = _t.COLLISIONFILTERGROUP_ALLFILTER, this._colliderShape = null, 
            this._transformFlag = 2147483647, this._controlBySimulation = !1, this._enableProcessCollisions = !0, 
            this._inPhysicUpdateListIndex = -1, this.canScaleShape = !0, this._collisionGroup = e, 
            this._canCollideWith = t, vt._physicObjectsMap[this.id] = this;
        }
        static __init__() {
            var e = v._bullet;
            vt._btVector30 = e.btVector3_create(0, 0, 0), vt._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1);
        }
        static _createAffineTransformationArray(e, t, r, i, a, n, s, o, l) {
            var _ = i + i, h = a + a, c = n + n, d = i * _, u = i * h, m = i * c, f = a * h, E = a * c, T = n * c, p = s * _, g = s * h, S = s * c, R = o[0], v = o[1], x = o[2];
            l[0] = (1 - (f + T)) * R, l[1] = (u + S) * R, l[2] = (m - g) * R, l[3] = 0, l[4] = (u - S) * v, 
            l[5] = (1 - (d + T)) * v, l[6] = (E + p) * v, l[7] = 0, l[8] = (m + g) * x, l[9] = (E - p) * x, 
            l[10] = (1 - (d + f)) * x, l[11] = 0, l[12] = e, l[13] = t, l[14] = r, l[15] = 1;
        }
        static _creatShape(e) {
            var r;
            switch (e.type) {
              case "BoxColliderShape":
                var i = e.size;
                r = i ? new ft(i[0], i[1], i[2]) : new ft();
                break;

              case "SphereColliderShape":
                r = new Rt(e.radius);
                break;

              case "CapsuleColliderShape":
                r = new Et(e.radius, e.height, e.orientation);
                break;

              case "MeshColliderShape":
                var a = new St();
                e.mesh && (a.mesh = t.Loader.getRes(e.mesh)), r = a;
                break;

              case "ConeColliderShape":
                r = new pt(e.radius, e.height, e.orientation);
                break;

              case "CylinderColliderShape":
                r = new gt(e.radius, e.height, e.orientation);
                break;

              default:
                throw "unknown shape type.";
            }
            if (e.center) {
                var n = r.localOffset;
                n.fromArray(e.center), r.localOffset = n;
            }
            return r;
        }
        static physicVector3TransformQuat(e, t, r, i, a, n) {
            var s = e.x, o = e.y, l = e.z, _ = a * s + r * l - i * o, h = a * o + i * s - t * l, c = a * l + t * o - r * s, d = -t * s - r * o - i * l;
            n.x = _ * a + d * -t + h * -i - c * -r, n.y = h * a + d * -r + c * -t - _ * -i, 
            n.z = c * a + d * -i + _ * -r - h * -t;
        }
        static physicQuaternionMultiply(e, t, r, i, a, n) {
            var s = a.x, o = a.y, l = a.z, _ = a.w, h = t * l - r * o, c = r * s - e * l, d = e * o - t * s, u = e * s + t * o + r * l;
            n.x = e * _ + s * i + h, n.y = t * _ + o * i + c, n.z = r * _ + l * i + d, n.w = i * _ - u;
        }
        get restitution() {
            return this._restitution;
        }
        set restitution(e) {
            this._restitution = e, this._btColliderObject && v._bullet.btCollisionObject_setRestitution(this._btColliderObject, e);
        }
        get friction() {
            return this._friction;
        }
        set friction(e) {
            this._friction = e, this._btColliderObject && v._bullet.btCollisionObject_setFriction(this._btColliderObject, e);
        }
        get rollingFriction() {
            return this._rollingFriction;
        }
        set rollingFriction(e) {
            this._rollingFriction = e, this._btColliderObject && v._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, e);
        }
        get ccdMotionThreshold() {
            return this._ccdMotionThreshold;
        }
        set ccdMotionThreshold(e) {
            this._ccdMotionThreshold = e, this._btColliderObject && v._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e);
        }
        get ccdSweptSphereRadius() {
            return this._ccdSweptSphereRadius;
        }
        set ccdSweptSphereRadius(e) {
            this._ccdSweptSphereRadius = e, this._btColliderObject && v._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e);
        }
        get isActive() {
            return !!this._btColliderObject && v._bullet.btCollisionObject_isActive(this._btColliderObject);
        }
        get colliderShape() {
            return this._colliderShape;
        }
        set colliderShape(e) {
            var t = this._colliderShape;
            if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e, 
            e) {
                if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                if (e._attatched = !0, e._attatchedCollisionObject = this, this._btColliderObject) {
                    v._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, e._btShape);
                    var r = this._simulation && this._enabled;
                    r && t && this._removeFromSimulation(), this._onShapeChange(e), r && (this._derivePhysicsTransformation(!0), 
                    this._addToSimulation());
                }
            } else this._simulation && this._enabled && t && this._removeFromSimulation();
        }
        get simulation() {
            return this._simulation;
        }
        get collisionGroup() {
            return this._collisionGroup;
        }
        set collisionGroup(e) {
            this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
            this._addToSimulation()));
        }
        get canCollideWith() {
            return this._canCollideWith;
        }
        set canCollideWith(e) {
            this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
            this._addToSimulation()));
        }
        _parseShape(e) {
            var t = e.length;
            if (1 === t) {
                var r = vt._creatShape(e[0]);
                this.colliderShape = r;
            } else {
                for (var i = new Tt(), a = 0; a < t; a++) r = vt._creatShape(e[a]), i.addChildShape(r);
                this.colliderShape = i;
            }
        }
        _onScaleChange(e) {
            this._colliderShape._setScale(e);
        }
        _onEnable() {
            this._simulation = this.owner._scene.physicsSimulation, v._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 1e30), 
            this._colliderShape && (this._derivePhysicsTransformation(!0), this._addToSimulation());
        }
        _onDisable() {
            this._colliderShape && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)), 
            this._simulation = null;
        }
        _onDestroy() {
            delete vt._physicObjectsMap[this.id], v._bullet.btCollisionObject_destroy(this._btColliderObject), 
            this._colliderShape.destroy(), super._onDestroy(), this._btColliderObject = null, 
            this._colliderShape = null, this._simulation = null, this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        _isValid() {
            return this._simulation && this._colliderShape && this._enabled;
        }
        _parse(e) {
            null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith), 
            null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold), 
            null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
        }
        _setTransformFlag(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }
        _getTransformFlag(e) {
            return 0 != (this._transformFlag & e);
        }
        _addToSimulation() {}
        _removeFromSimulation() {}
        _derivePhysicsTransformation(e) {
            var t = v._bullet, r = this._btColliderObject, i = t.btCollisionObject_getWorldTransform(r);
            this._innerDerivePhysicsTransformation(i, e), t.btCollisionObject_setWorldTransform(r, i);
        }
        _innerDerivePhysicsTransformation(e, t) {
            var r = v._bullet, i = this.owner._transform;
            if (t || this._getTransformFlag(Re.TRANSFORM_WORLDPOSITION)) {
                var a = this._colliderShape.localOffset, s = i.position, o = vt._btVector30;
                if (0 !== a.x || 0 !== a.y || 0 !== a.z) {
                    var l = vt._tempVector30, _ = i.worldMatrix;
                    n.transformCoordinate(a, _, l), r.btVector3_setValue(o, -l.x, l.y, l.z);
                } else r.btVector3_setValue(o, -s.x, s.y, s.z);
                r.btTransform_setOrigin(e, o), this._setTransformFlag(Re.TRANSFORM_WORLDPOSITION, !1);
            }
            if (t || this._getTransformFlag(Re.TRANSFORM_WORLDQUATERNION)) {
                var h = this._colliderShape.localRotation, c = vt._btQuaternion0, d = i.rotation;
                if (0 !== h.x || 0 !== h.y || 0 !== h.z || 1 !== h.w) {
                    var u = vt._tempQuaternion0;
                    vt.physicQuaternionMultiply(d.x, d.y, d.z, d.w, h, u), r.btQuaternion_setValue(c, -u.x, u.y, u.z, -u.w);
                } else r.btQuaternion_setValue(c, -d.x, d.y, d.z, -d.w);
                r.btTransform_setRotation(e, c), this._setTransformFlag(Re.TRANSFORM_WORLDQUATERNION, !1);
            }
            (t || this._getTransformFlag(Re.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(i.getWorldLossyScale()), 
            this._setTransformFlag(Re.TRANSFORM_WORLDSCALE, !1));
        }
        _updateTransformComponent(e) {
            var t = v._bullet, r = this._colliderShape, i = r.localOffset, a = r.localRotation, s = this.owner._transform, o = s.position, l = s.rotation, _ = t.btTransform_getOrigin(e), h = t.btTransform_getRotation(e), c = -t.btQuaternion_x(h), d = t.btQuaternion_y(h), u = t.btQuaternion_z(h), m = -t.btQuaternion_w(h);
            if (0 !== a.x || 0 !== a.y || 0 !== a.z || 1 !== a.w) {
                var f = vt._tempQuaternion0;
                a.invert(f), vt.physicQuaternionMultiply(c, d, u, m, f, l);
            } else l.x = c, l.y = d, l.z = u, l.w = m;
            if (s.rotation = l, 0 !== i.x || 0 !== i.y || 0 !== i.z) {
                var E = t.btCollisionShape_getLocalScaling(r._btShape), T = vt._tempVector30;
                T.x = i.x * t.btVector3_x(E), T.y = i.y * t.btVector3_y(E), T.z = i.z * t.btVector3_z(E), 
                n.transformQuat(T, l, T), o.x = -t.btVector3_x(_) - T.x, o.y = t.btVector3_y(_) - T.y, 
                o.z = t.btVector3_z(_) - T.z;
            } else o.x = -t.btVector3_x(_), o.y = t.btVector3_y(_), o.z = t.btVector3_z(_);
            s.position = o;
        }
        _onShapeChange(e) {
            var t = this._btColliderObject, r = v._bullet, i = r.btCollisionObject_getCollisionFlags(t);
            e.needsCustomCollisionCallback ? 0 == (i & vt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && r.btCollisionObject_setCollisionFlags(t, i | vt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (i & vt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && r.btCollisionObject_setCollisionFlags(t, i ^ vt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
        }
        _onAdded() {
            this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction, 
            this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold, 
            this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        _onTransformChanged(e) {
            !vt._addUpdateList && this._controlBySimulation || (e &= Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e, 
            this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
        }
        _cloneTo(e) {
            var t = e;
            t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction, 
            t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius, 
            t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith, 
            t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
        }
    }
    vt.ACTIVATIONSTATE_ACTIVE_TAG = 1, vt.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, vt.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3, 
    vt.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, vt.ACTIVATIONSTATE_DISABLE_SIMULATION = 5, 
    vt.COLLISIONFLAGS_STATIC_OBJECT = 1, vt.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, vt.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4, 
    vt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, vt.COLLISIONFLAGS_CHARACTER_OBJECT = 16, 
    vt.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, vt.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64, 
    vt._tempVector30 = new n(), vt._tempQuaternion0 = new f(), vt._tempQuaternion1 = new f(), 
    vt._tempMatrix4x40 = new y(), vt._physicObjectsMap = {}, vt._addUpdateList = !0;
    class xt {
        constructor(e, t = 0) {
            this._gravity = new n(0, -10, 0), this._btVector3Zero = v._bullet.btVector3_create(0, 0, 0), 
            this._btDefaultQuaternion = v._bullet.btQuaternion_create(0, 0, 0, -1), this._collisionsUtils = new ut(), 
            this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new ht(), 
            this._characters = [], this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60, 
            this.maxSubSteps = e.maxSubSteps, this.fixedTimeStep = e.fixedTimeStep;
            var r = v._bullet;
            this._btCollisionConfiguration = r.btDefaultCollisionConfiguration_create(), this._btDispatcher = r.btCollisionDispatcher_create(this._btCollisionConfiguration), 
            this._btBroadphase = r.btDbvtBroadphase_create(), r.btOverlappingPairCache_setInternalGhostPairCallback(r.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), r.btGhostPairCallback_create());
            var i = e.flags;
            if (i & xt.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._btCollisionWorld = new r.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration); else {
                if (i & xt.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var a = r.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = r.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, a, this._btCollisionConfiguration), 
                this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            this._btDiscreteDynamicsWorld && (this._btSolverInfo = r.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld), 
            this._btDispatchInfo = r.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld)), 
            this._btClosestRayResultCallback = r.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btAllHitsRayResultCallback = r.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btClosestConvexResultCallback = r.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            this._btAllConvexResultCallback = r.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero), 
            r.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        static __init__() {
            var e = v._bullet;
            xt._btTempVector30 = e.btVector3_create(0, 0, 0), xt._btTempVector31 = e.btVector3_create(0, 0, 0), 
            xt._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), xt._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1), 
            xt._btTempTransform0 = e.btTransform_create(), xt._btTempTransform1 = e.btTransform_create();
        }
        static createConstraint() {}
        get continuousCollisionDetection() {
            return v._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
        }
        set continuousCollisionDetection(e) {
            v._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, e);
        }
        get gravity() {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._gravity;
        }
        set gravity(e) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._gravity = e;
            var t = v._bullet, r = xt._btTempVector30;
            t.btVector3_setValue(r, -e.x, e.y, e.z), t.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, r);
        }
        get speculativeContactRestitution() {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            return v._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
        }
        set speculativeContactRestitution(e) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            v._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, e);
        }
        _simulate(e) {
            this._updatedRigidbodies = 0;
            var t = v._bullet;
            this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t.PerformDiscreteCollisionDetection(this._btCollisionWorld);
        }
        _destroy() {
            var e = v._bullet;
            this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld), 
            this._btDiscreteDynamicsWorld = null) : (e.btCollisionWorld_destroy(this._btCollisionWorld), 
            this._btCollisionWorld = null), e.btDbvtBroadphase_destroy(this._btBroadphase), 
            this._btBroadphase = null, e.btCollisionDispatcher_destroy(this._btDispatcher), 
            this._btDispatcher = null, e.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration), 
            this._btCollisionConfiguration = null;
        }
        _addPhysicsCollider(e, t, r) {
            v._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r);
        }
        _removePhysicsCollider(e) {
            v._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject);
        }
        _addRigidBody(e, t, r) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            v._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, e._btColliderObject, t, r);
        }
        _removeRigidBody(e) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            v._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, e._btColliderObject);
        }
        _addCharacter(e, t, r) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            var i = v._bullet;
            i.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r), 
            i.btDynamicsWorld_addAction(this._btCollisionWorld, e._btKinematicCharacter);
        }
        _removeCharacter(e) {
            if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            var t = v._bullet;
            t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject), 
            t.btDynamicsWorld_removeAction(this._btCollisionWorld, e._btKinematicCharacter);
        }
        raycastFromTo(e, t, r = null, i = _t.COLLISIONFILTERGROUP_ALLFILTER, a = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            var n = v._bullet, s = this._btClosestRayResultCallback, o = xt._btTempVector30, l = xt._btTempVector31;
            if (n.btVector3_setValue(o, -e.x, e.y, e.z), n.btVector3_setValue(l, -t.x, t.y, t.z), 
            n.ClosestRayResultCallback_set_m_rayFromWorld(s, o), n.ClosestRayResultCallback_set_m_rayToWorld(s, l), 
            n.RayResultCallback_set_m_collisionFilterGroup(s, i), n.RayResultCallback_set_m_collisionFilterMask(s, a), 
            n.RayResultCallback_set_m_collisionObject(s, null), n.RayResultCallback_set_m_closestHitFraction(s, 1), 
            n.btCollisionWorld_rayTest(this._btCollisionWorld, o, l, s), n.RayResultCallback_hasHit(s)) {
                if (r) {
                    r.succeeded = !0, r.collider = vt._physicObjectsMap[n.btCollisionObject_getUserIndex(n.RayResultCallback_get_m_collisionObject(s))], 
                    r.hitFraction = n.RayResultCallback_get_m_closestHitFraction(s);
                    var _ = n.ClosestRayResultCallback_get_m_hitPointWorld(s), h = r.point;
                    h.x = -n.btVector3_x(_), h.y = n.btVector3_y(_), h.z = n.btVector3_z(_);
                    var c = n.ClosestRayResultCallback_get_m_hitNormalWorld(s), d = r.normal;
                    d.x = -n.btVector3_x(c), d.y = n.btVector3_y(c), d.z = n.btVector3_z(c);
                }
                return !0;
            }
            return r && (r.succeeded = !1), !1;
        }
        raycastAllFromTo(e, t, r, i = _t.COLLISIONFILTERGROUP_ALLFILTER, a = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            var n = v._bullet, s = this._btAllHitsRayResultCallback, o = xt._btTempVector30, l = xt._btTempVector31;
            r.length = 0, n.btVector3_setValue(o, -e.x, e.y, e.z), n.btVector3_setValue(l, -t.x, t.y, t.z), 
            n.AllHitsRayResultCallback_set_m_rayFromWorld(s, o), n.AllHitsRayResultCallback_set_m_rayToWorld(s, l), 
            n.RayResultCallback_set_m_collisionFilterGroup(s, i), n.RayResultCallback_set_m_collisionFilterMask(s, a);
            var _ = n.AllHitsRayResultCallback_get_m_collisionObjects(s), h = n.AllHitsRayResultCallback_get_m_hitPointWorld(s), c = n.AllHitsRayResultCallback_get_m_hitNormalWorld(s), d = n.AllHitsRayResultCallback_get_m_hitFractions(s);
            n.tBtCollisionObjectArray_clear(_), n.tVector3Array_clear(h), n.tVector3Array_clear(c), 
            n.tScalarArray_clear(d), n.btCollisionWorld_rayTest(this._btCollisionWorld, o, l, s);
            var u = n.tBtCollisionObjectArray_size(_);
            if (u > 0) {
                this._collisionsUtils.recoverAllHitResultsPool();
                for (var m = 0; m < u; m++) {
                    var f = this._collisionsUtils.getHitResult();
                    r.push(f), f.succeeded = !0, f.collider = vt._physicObjectsMap[n.btCollisionObject_getUserIndex(n.tBtCollisionObjectArray_at(_, m))], 
                    f.hitFraction = n.tScalarArray_at(d, m);
                    var E = n.tVector3Array_at(h, m), T = f.point;
                    T.x = -n.btVector3_x(E), T.y = n.btVector3_y(E), T.z = n.btVector3_z(E);
                    var p = n.tVector3Array_at(c, m), g = f.normal;
                    g.x = -n.btVector3_x(p), g.y = n.btVector3_y(p), g.z = n.btVector3_z(p);
                }
                return !0;
            }
            return !1;
        }
        rayCast(e, t = null, r = 2147483647, i = _t.COLLISIONFILTERGROUP_ALLFILTER, a = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            var s = e.origin, o = xt._tempVector30;
            return n.normalize(e.direction, o), n.scale(o, r, o), n.add(s, o, o), this.raycastFromTo(s, o, t, i, a);
        }
        rayCastAll(e, t, r = 2147483647, i = _t.COLLISIONFILTERGROUP_ALLFILTER, a = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            var s = e.origin, o = xt._tempVector30;
            return n.normalize(e.direction, o), n.scale(o, r, o), n.add(s, o, o), this.raycastAllFromTo(s, o, t, i, a);
        }
        shapeCast(e, t, r, i = null, a = null, n = null, s = _t.COLLISIONFILTERGROUP_ALLFILTER, o = _t.COLLISIONFILTERGROUP_ALLFILTER, l = 0) {
            var _ = v._bullet, h = this._btClosestConvexResultCallback, c = xt._btTempVector30, d = xt._btTempVector31, u = xt._btTempQuaternion0, m = xt._btTempQuaternion1, f = xt._btTempTransform0, E = xt._btTempTransform1, T = e._btShape;
            if (_.btVector3_setValue(c, -t.x, t.y, t.z), _.btVector3_setValue(d, -r.x, r.y, r.z), 
            _.ConvexResultCallback_set_m_collisionFilterGroup(h, s), _.ConvexResultCallback_set_m_collisionFilterMask(h, o), 
            _.btTransform_setOrigin(f, c), _.btTransform_setOrigin(E, d), a ? (_.btQuaternion_setValue(u, -a.x, a.y, a.z, -a.w), 
            _.btTransform_setRotation(f, u)) : _.btTransform_setRotation(f, this._btDefaultQuaternion), 
            n ? (_.btQuaternion_setValue(m, -n.x, n.y, n.z, -n.w), _.btTransform_setRotation(E, m)) : _.btTransform_setRotation(E, this._btDefaultQuaternion), 
            _.ClosestConvexResultCallback_set_m_hitCollisionObject(h, null), _.ConvexResultCallback_set_m_closestHitFraction(h, 1), 
            _.btCollisionWorld_convexSweepTest(this._btCollisionWorld, T, f, E, h, l), _.ConvexResultCallback_hasHit(h)) {
                if (i) {
                    i.succeeded = !0, i.collider = vt._physicObjectsMap[_.btCollisionObject_getUserIndex(_.ClosestConvexResultCallback_get_m_hitCollisionObject(h))], 
                    i.hitFraction = _.ConvexResultCallback_get_m_closestHitFraction(h);
                    var p = _.ClosestConvexResultCallback_get_m_hitPointWorld(h), g = _.ClosestConvexResultCallback_get_m_hitNormalWorld(h), S = i.point, R = i.normal;
                    S.x = -_.btVector3_x(p), S.y = _.btVector3_y(p), S.z = _.btVector3_z(p), R.x = -_.btVector3_x(g), 
                    R.y = _.btVector3_y(g), R.z = _.btVector3_z(g);
                }
                return !0;
            }
            return i && (i.succeeded = !1), !1;
        }
        shapeCastAll(e, t, r, i, a = null, n = null, s = _t.COLLISIONFILTERGROUP_ALLFILTER, o = _t.COLLISIONFILTERGROUP_ALLFILTER, l = 0) {
            var _ = v._bullet, h = this._btAllConvexResultCallback, c = xt._btTempVector30, d = xt._btTempVector31, u = xt._btTempQuaternion0, m = xt._btTempQuaternion1, f = xt._btTempTransform0, E = xt._btTempTransform1, T = e._btShape;
            i.length = 0, _.btVector3_setValue(c, -t.x, t.y, t.z), _.btVector3_setValue(d, -r.x, r.y, r.z), 
            _.ConvexResultCallback_set_m_collisionFilterGroup(h, s), _.ConvexResultCallback_set_m_collisionFilterMask(h, o), 
            _.btTransform_setOrigin(f, c), _.btTransform_setOrigin(E, d), a ? (_.btQuaternion_setValue(u, -a.x, a.y, a.z, -a.w), 
            _.btTransform_setRotation(f, u)) : _.btTransform_setRotation(f, this._btDefaultQuaternion), 
            n ? (_.btQuaternion_setValue(m, -n.x, n.y, n.z, -n.w), _.btTransform_setRotation(E, m)) : _.btTransform_setRotation(E, this._btDefaultQuaternion);
            var p = _.AllConvexResultCallback_get_m_collisionObjects(h);
            _.tBtCollisionObjectArray_clear(p), _.btCollisionWorld_convexSweepTest(this._btCollisionWorld, T, f, E, h, l);
            var g = _.tBtCollisionObjectArray_size(p);
            if (g > 0) {
                for (var S = _.AllConvexResultCallback_get_m_hitPointWorld(h), R = _.AllConvexResultCallback_get_m_hitNormalWorld(h), x = _.AllConvexResultCallback_get_m_hitFractions(h), I = 0; I < g; I++) {
                    var A = this._collisionsUtils.getHitResult();
                    i.push(A), A.succeeded = !0, A.collider = vt._physicObjectsMap[_.btCollisionObject_getUserIndex(_.tBtCollisionObjectArray_at(p, I))], 
                    A.hitFraction = _.tScalarArray_at(x, I);
                    var L = _.tVector3Array_at(S, I), C = A.point;
                    C.x = -_.btVector3_x(L), C.y = _.btVector3_y(L), C.z = _.btVector3_z(L);
                    var D = _.tVector3Array_at(R, I), M = A.normal;
                    M.x = -_.btVector3_x(D), M.y = _.btVector3_y(D), M.z = _.btVector3_z(D);
                }
                return !0;
            }
            return !1;
        }
        addConstraint(e, t = !1) {
            if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            e._simulation = this;
        }
        removeConstraint(e) {
            if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
        }
        _updatePhysicsTransformFromRender() {
            for (var e = this._physicsUpdateList.elements, t = 0, r = this._physicsUpdateList.length; t < r; t++) {
                var i = e[t];
                i._derivePhysicsTransformation(!1), i._inPhysicUpdateListIndex = -1;
            }
            this._physicsUpdateList.length = 0;
        }
        _updateCharacters() {
            for (var e = 0, t = this._characters.length; e < t; e++) {
                var r = this._characters[e];
                r._updateTransformComponent(v._bullet.btCollisionObject_getWorldTransform(r._btColliderObject));
            }
        }
        _updateCollisions() {
            this._collisionsUtils.recoverAllContactPointsPool();
            var e = this._currentFrameCollisions;
            this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0, 
            this._previousFrameCollisions = e;
            for (var r = t.Stat.loopCount, i = v._bullet, a = i.btDispatcher_getNumManifolds(this._btDispatcher), n = 0; n < a; n++) {
                var s, o = i.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, n), l = vt._physicObjectsMap[i.btCollisionObject_getUserIndex(i.btPersistentManifold_getBody0(o))], _ = vt._physicObjectsMap[i.btCollisionObject_getUserIndex(i.btPersistentManifold_getBody1(o))], h = null, c = null;
                if ((l.isTrigger || _.isTrigger) && (l.owner._needProcessTriggers || _.owner._needProcessTriggers)) for (var d = i.btPersistentManifold_getNumContacts(o), u = 0; u < d; u++) {
                    var m = i.btPersistentManifold_getContactPoint(o, u), f = i.btManifoldPoint_getDistance(m);
                    if (f <= 0) {
                        c = (h = this._collisionsUtils.getCollision(l, _)).contacts, (s = h._updateFrame !== r) && (h._isTrigger = !0, 
                        c.length = 0);
                        break;
                    }
                } else if ((l.owner._needProcessCollisions || _.owner._needProcessCollisions) && (l._enableProcessCollisions || _._enableProcessCollisions)) for (d = i.btPersistentManifold_getNumContacts(o), 
                u = 0; u < d; u++) if (m = i.btPersistentManifold_getContactPoint(o, u), (f = i.btManifoldPoint_getDistance(m)) <= 0) {
                    var E = this._collisionsUtils.getContactPoints();
                    E.colliderA = l, E.colliderB = _, E.distance = f;
                    var T = i.btManifoldPoint_get_m_normalWorldOnB(m), p = E.normal;
                    p.x = -i.btVector3_x(T), p.y = i.btVector3_y(T), p.z = i.btVector3_z(T);
                    var g = i.btManifoldPoint_get_m_positionWorldOnA(m), S = E.positionOnA;
                    S.x = -i.btVector3_x(g), S.y = i.btVector3_y(g), S.z = i.btVector3_z(g);
                    var R = i.btManifoldPoint_get_m_positionWorldOnB(m), x = E.positionOnB;
                    x.x = -i.btVector3_x(R), x.y = i.btVector3_y(R), x.z = i.btVector3_z(R), h || (c = (h = this._collisionsUtils.getCollision(l, _)).contacts, 
                    (s = h._updateFrame !== r) && (h._isTrigger = !1, c.length = 0)), c.push(E);
                }
                h && s && (this._currentFrameCollisions.push(h), h._setUpdateFrame(r));
            }
        }
        _eventScripts() {
            for (var e = t.Stat.loopCount, r = 0, i = this._currentFrameCollisions.length; r < i; r++) {
                var a = this._currentFrameCollisions[r], n = a._colliderA, s = a._colliderB;
                if (!n.destroyed && !s.destroyed) if (e - a._lastUpdateFrame == 1) {
                    var o = n.owner, l = o._scripts;
                    if (l) if (a._isTrigger) {
                        if (o._needProcessTriggers) for (var _ = 0, h = l.length; _ < h; _++) l[_].onTriggerStay(s);
                    } else if (o._needProcessCollisions) for (_ = 0, h = l.length; _ < h; _++) a.other = s, 
                    l[_].onCollisionStay(a);
                    var c = s.owner, d = c._scripts;
                    if (d) if (a._isTrigger) {
                        if (c._needProcessTriggers) for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerStay(n);
                    } else if (c._needProcessCollisions) for (_ = 0, h = d.length; _ < h; _++) a.other = n, 
                    d[_].onCollisionStay(a);
                } else {
                    if (l = (o = n.owner)._scripts) if (a._isTrigger) {
                        if (o._needProcessTriggers) for (_ = 0, h = l.length; _ < h; _++) l[_].onTriggerEnter(s);
                    } else if (o._needProcessCollisions) for (_ = 0, h = l.length; _ < h; _++) a.other = s, 
                    l[_].onCollisionEnter(a);
                    if (d = (c = s.owner)._scripts) if (a._isTrigger) {
                        if (c._needProcessTriggers) for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerEnter(n);
                    } else if (c._needProcessCollisions) for (_ = 0, h = d.length; _ < h; _++) a.other = n, 
                    d[_].onCollisionEnter(a);
                }
            }
            for (r = 0, i = this._previousFrameCollisions.length; r < i; r++) {
                var u = this._previousFrameCollisions[r], m = u._colliderA, f = u._colliderB;
                if (!m.destroyed && !f.destroyed && e - u._updateFrame == 1) {
                    if (this._collisionsUtils.recoverCollision(u), l = (o = m.owner)._scripts) if (u._isTrigger) {
                        if (o._needProcessTriggers) for (_ = 0, h = l.length; _ < h; _++) l[_].onTriggerExit(f);
                    } else if (o._needProcessCollisions) for (_ = 0, h = l.length; _ < h; _++) u.other = f, 
                    l[_].onCollisionExit(u);
                    if (d = (c = f.owner)._scripts) if (u._isTrigger) {
                        if (c._needProcessTriggers) for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerExit(m);
                    } else if (c._needProcessCollisions) for (_ = 0, h = d.length; _ < h; _++) u.other = m, 
                    d[_].onCollisionExit(u);
                }
            }
        }
        clearForces() {
            if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            v._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
        }
    }
    xt.PHYSICSENGINEFLAGS_NONE = 0, xt.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, xt.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2, 
    xt.PHYSICSENGINEFLAGS_MULTITHREADED = 4, xt.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, 
    xt.SOLVERMODE_RANDMIZE_ORDER = 1, xt.SOLVERMODE_FRICTION_SEPARATE = 2, xt.SOLVERMODE_USE_WARMSTARTING = 4, 
    xt.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, xt.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, 
    xt.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, xt.SOLVERMODE_CACHE_FRIENDLY = 128, 
    xt.SOLVERMODE_SIMD = 256, xt.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512, 
    xt.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, xt._tempVector30 = new n(), 
    xt.disableSimulation = !1;
    class It {
        constructor() {
            this._eventList = [], this._mouseTouch = new Oe(), this._touchPool = [], this._touches = new pe(), 
            this._multiTouchEnabled = !0, this._pushEventList = (e => {
                e.cancelable && e.preventDefault(), this._eventList.push(e);
            }).bind(this);
        }
        __init__(e, t) {
            this._scene = t, e.oncontextmenu = function(e) {
                return !1;
            };
        }
        _onCanvasEvent(e) {
            e.addEventListener("mousedown", this._pushEventList), e.addEventListener("mouseup", this._pushEventList, !0), 
            e.addEventListener("mousemove", this._pushEventList, !0), e.addEventListener("touchstart", this._pushEventList), 
            e.addEventListener("touchend", this._pushEventList, !0), e.addEventListener("touchmove", this._pushEventList, !0), 
            e.addEventListener("touchcancel", this._pushEventList, !0);
        }
        _offCanvasEvent(e) {
            e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener("mouseup", this._pushEventList, !0), 
            e.removeEventListener("mousemove", this._pushEventList, !0), e.removeEventListener("touchstart", this._pushEventList), 
            e.removeEventListener("touchend", this._pushEventList, !0), e.removeEventListener("touchmove", this._pushEventList, !0), 
            e.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0, 
            this._touches.clear();
        }
        touchCount() {
            return this._touches.length;
        }
        get multiTouchEnabled() {
            return this._multiTouchEnabled;
        }
        set multiTouchEnabled(e) {
            this._multiTouchEnabled = e;
        }
        _getTouch(e) {
            var t = this._touchPool[e];
            return t || (t = new Ne(), this._touchPool[e] = t, t._identifier = e), t;
        }
        _mouseTouchDown() {
            var e = this._mouseTouch, r = e.sprite;
            if (e._pressedSprite = r, e._pressedLoopCount = t.Stat.loopCount, r) {
                var i = r._scripts;
                if (i) for (var a = 0, n = i.length; a < n; a++) i[a].onMouseDown();
            }
        }
        _mouseTouchUp() {
            var e, t, r = this._mouseTouch, i = r._pressedSprite;
            r._pressedSprite = null, r._pressedLoopCount = -1;
            var a = r.sprite;
            if (a && a === i) {
                var n = a._scripts;
                if (n) for (e = 0, t = n.length; e < t; e++) n[e].onMouseClick();
            }
            if (i) {
                var s = i._scripts;
                if (s) for (e = 0, t = s.length; e < t; e++) s[e].onMouseUp();
            }
        }
        _mouseTouchRayCast(t) {
            var r = It._tempHitResult0, i = It._tempVector20, a = It._tempRay0;
            r.succeeded = !1;
            var n = this._mouseTouch.mousePositionX, s = this._mouseTouch.mousePositionY;
            i.x = n, i.y = s;
            for (var o = t.length - 1; o >= 0; o--) {
                var l = t[o], _ = l.viewport;
                if (i.x >= _.x && i.y >= _.y && i.x <= _.width && i.y <= _.height) if (l.viewportPointToRay(i, a), 
                this._scene._physicsSimulation.rayCast(a, r) || l.clearFlag === e.CameraClearFlags.SolidColor || l.clearFlag === e.CameraClearFlags.Sky) break;
            }
            var h = this._mouseTouch, c = h.sprite;
            if (r.succeeded) {
                var d = r.collider.owner;
                h.sprite = d;
                var u = d._scripts;
                if (c !== d && u) for (var m = 0, f = u.length; m < f; m++) u[m].onMouseEnter();
            } else h.sprite = null;
            if (c && c !== d) {
                var E = c._scripts;
                if (E) for (m = 0, f = E.length; m < f; m++) E[m].onMouseOut();
            }
        }
        _changeTouches(e, r) {
            for (var i = 0, a = 0, n = this._touches.length, s = 0, o = e.length; s < o; s++) {
                var l = e[s], _ = l.identifier;
                if (this._multiTouchEnabled || 0 === _) {
                    var h = this._getTouch(_), c = h._position, d = It._tempPoint;
                    d.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(d);
                    var u = d.x, m = d.y;
                    switch (r) {
                      case 0:
                        this._touches.add(h), i += u, a += m;
                        break;

                      case 1:
                        this._touches.remove(h), i -= u, a -= m;
                        break;

                      case 2:
                        i = u - c.x, a = m - c.y;
                    }
                    c.x = u, c.y = m;
                }
            }
            var f = this._touches.length;
            0 === f ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * n + i) / f, 
            this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * n + a) / f);
        }
        _update() {
            var e, r, i, a, n = v._enablePhysics && !xt.disableSimulation;
            r = this._eventList.length;
            var s = this._scene._cameraPool;
            if (r > 0) {
                var o = !1;
                for (e = 0; e < r; e++) {
                    var l = this._eventList[e];
                    switch (l.type) {
                      case "mousedown":
                        n && this._mouseTouchDown();
                        break;

                      case "mouseup":
                        n && this._mouseTouchUp();
                        break;

                      case "mousemove":
                        var _ = It._tempPoint;
                        _.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(_), 
                        this._mouseTouch.mousePositionX = _.x, this._mouseTouch.mousePositionY = _.y, n && (o = !0);
                        break;

                      case "touchstart":
                        var h = this._touches.length;
                        this._changeTouches(l.changedTouches, 0), n && (o = !0, 0 === h && this._mouseTouchDown());
                        break;

                      case "touchend":
                      case "touchcancel":
                        this._changeTouches(l.changedTouches, 1), n && 0 === this._touches.length && this._mouseTouchUp();
                        break;

                      case "touchmove":
                        this._changeTouches(l.changedTouches, 2), n && (o = !0);
                        break;

                      default:
                        throw "Input3D:unkonwn event type.";
                    }
                }
                o && this._mouseTouchRayCast(s), this._eventList.length = 0;
            }
            if (n) {
                var c = this._mouseTouch, d = c._pressedSprite;
                if (d && t.Stat.loopCount > c._pressedLoopCount) {
                    var u = d._scripts;
                    if (u) for (i = 0, a = u.length; i < a; i++) u[i].onMouseDrag();
                }
                var m = c.sprite;
                if (m) {
                    var f = m._scripts;
                    if (f) for (i = 0, a = f.length; i < a; i++) f[i].onMouseOver();
                }
            }
        }
        getTouch(e) {
            return e < this._touches.length ? this._touches.elements[e] : null;
        }
    }
    It._tempPoint = new t.Point(), It._tempVector20 = new i(), It._tempRay0 = new Pe(new n(), new n()), 
    It._tempHitResult0 = new lt();
    class At {
        constructor() {
            this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
        }
    }
    class Lt {
        static get vertexDeclaration() {
            return Lt._vertexDeclaration;
        }
        static __init__() {
            Lt._vertexDeclaration = new We(20, [ new ke(0, He.Vector3, Xe.MESH_POSITION0), new ke(12, He.Vector2, Xe.MESH_TEXTURECOORDINATE0) ]);
        }
        get position() {
            return this._position;
        }
        get textureCoordinate0() {
            return this._textureCoordinate0;
        }
        get vertexDeclaration() {
            return Lt._vertexDeclaration;
        }
        constructor(e, t) {
            this._position = e, this._textureCoordinate0 = t;
        }
    }
    class Ct extends je {
        constructor(r = 48, i = 48) {
            super();
            var a = t.LayaGL.instance;
            this._stacks = r, this._slices = i;
            for (var n = Lt.vertexDeclaration, s = n.vertexStride / 4, o = (this._stacks + 1) * (this._slices + 1), l = 3 * this._stacks * (this._slices + 1) * 2, _ = new Float32Array(o * s), h = new Uint16Array(l), c = Math.PI / this._stacks, d = 2 * Math.PI / this._slices, u = 0, m = 0, f = 0, E = 0; E < this._stacks + 1; E++) for (var T = Math.sin(E * c), p = Math.cos(E * c), g = 0; g < this._slices + 1; g++) {
                var S = T * Math.sin(g * d), R = T * Math.cos(g * d);
                _[m + 0] = S * Ct._radius, _[m + 1] = p * Ct._radius, _[m + 2] = R * Ct._radius, 
                _[m + 3] = -g / this._slices + .75, _[m + 4] = E / this._stacks, m += s, E != this._stacks - 1 && (h[f++] = u + 1, 
                h[f++] = u, h[f++] = u + (this._slices + 1), h[f++] = u + (this._slices + 1), h[f++] = u, 
                h[f++] = u + this._slices, u++);
            }
            this._vertexBuffer = new Ye(4 * _.length, a.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = n, 
            this._indexBuffer = new ze(e.IndexFormat.UInt16, h.length, a.STATIC_DRAW, !1), this._vertexBuffer.setData(_.buffer), 
            this._indexBuffer.setData(h);
            var v = new Ge();
            v.bind(), v.applyVertexBuffer(this._vertexBuffer), v.applyIndexBuffer(this._indexBuffer), 
            v.unBind(), this._bufferState = v;
        }
        static __init__() {
            Ct.instance = new Ct();
        }
        get stacks() {
            return this._stacks;
        }
        get slices() {
            return this._slices;
        }
        _render(e) {
            var r = t.LayaGL.instance, i = this._indexBuffer.indexCount;
            r.drawElements(r.TRIANGLES, i, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += i / 3, 
            t.Stat.renderBatches++;
        }
    }
    Ct._radius = 1, (le = e.TextureCubeFace || (e.TextureCubeFace = {}))[le.PositiveX = 0] = "PositiveX", 
    le[le.NegativeX = 1] = "NegativeX", le[le.PositiveY = 2] = "PositiveY", le[le.NegativeY = 3] = "NegativeY", 
    le[le.PositiveZ = 4] = "PositiveZ", le[le.NegativeZ = 5] = "NegativeZ";
    class Dt extends t.BaseTexture {
        constructor(e, r = t.TextureFormat.R8G8B8, i = !1) {
            super(r, i), this._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP, this._width = e, 
            this._height = e;
            var a = t.LayaGL.instance;
            if (this._setWarpMode(a.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(a.TEXTURE_WRAP_T, this._wrapModeV), 
            this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._mipmap) {
                this._mipmapCount = Math.ceil(Math.log2(e)) + 1;
                for (var n = 0; n < this._mipmapCount; n++) this._setPixels([], n, Math.max(e >> n, 1), Math.max(e >> n, 1));
                this._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else this._mipmapCount = 1, this._setGPUMemory(e * e * 4 * 6);
        }
        static get blackTexture() {
            return Dt._blackTexture;
        }
        static get grayTexture() {
            return Dt._grayTexture;
        }
        static __init__() {
            var e = new Dt(1, t.TextureFormat.R8G8B8, !1), r = new Dt(1, t.TextureFormat.R8G8B8, !1), i = new Uint8Array(3);
            i[0] = 0, i[1] = 0, i[2] = 0, e.setSixSidePixels([ i, i, i, i, i, i ]), e.lock = !0, 
            i[0] = 128, i[1] = 128, i[2] = 128, r.setSixSidePixels([ i, i, i, i, i, i ]), r.lock = !0, 
            Dt._grayTexture = r, Dt._blackTexture = e;
        }
        static _parse(e, t = null, r = null) {
            var i = r ? new Dt(0, r[0], r[1]) : new Dt(0);
            return i.setSixSideImageSources(e), i;
        }
        static _parseBin(e, t = null, r = null) {
            var i = r ? new Dt(0, r[0], r[1]) : new Dt(0);
            return i.setSixSideImageSources(e), i;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, Dt.TEXTURECUBE);
        }
        get defaulteTexture() {
            return Dt.grayTexture;
        }
        _setPixels(e, r, i, a) {
            var n = t.LayaGL.instance, s = this._getGLFormat();
            t.WebGLContext.bindTexture(n, this._glTextureType, this._glTexture), this.format === t.TextureFormat.R8G8B8 ? (n.pixelStorei(n.UNPACK_ALIGNMENT, 1), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[0]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[1]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[2]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[3]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[4]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[5]), 
            n.pixelStorei(n.UNPACK_ALIGNMENT, 4)) : (n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[0]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[1]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[2]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[3]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[4]), 
            n.texImage2D(n.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, a, 0, s, n.UNSIGNED_BYTE, e[5]));
        }
        setSixSideImageSources(e, r = !1) {
            for (var i, a, n = 0; n < 6; n++) {
                var s = e[n];
                if (!s) return void console.log("TextureCube: image Source can't be null.");
                var o = s.width, l = s.height;
                if (n > 0 && i !== o) return void console.log("TextureCube: each side image's width and height must same.");
                if ((i = o) !== (a = l)) return void console.log("TextureCube: each side image's width and height must same.");
            }
            this._width = i, this._height = a;
            var _ = t.LayaGL.instance;
            t.WebGLContext.bindTexture(_, this._glTextureType, this._glTexture);
            var h = this._getGLFormat();
            if (t.Render.isConchApp) {
                if (1 == r) for (var c = 0; c < 6; c++) e[c].setPremultiplyAlpha(r);
                _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[0]), 
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[1]), 
                _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[2]), 
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[3]), 
                _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[4]), 
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[5]);
            } else r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[0]), 
            _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[1]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[2]), 
            _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[3]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[4]), 
            _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[5]), r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
            this._mipmap && this._isPot(i) && this._isPot(a) ? (_.generateMipmap(this._glTextureType), 
            this._setGPUMemory(i * a * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(i * a * 4 * 6), 
            this._setWarpMode(_.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(_.TEXTURE_WRAP_T, this._wrapModeV), 
            this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
        }
        setSixSidePixels(e, r = 0) {
            if (!e) throw new Error("TextureCube:pixels can't be null.");
            var i = Math.max(this._width >> r, 1), a = Math.max(this._height >> r, 1), n = i * a * this._getFormatByteCount();
            if (e[0].length < n) throw "TextureCube:pixels length should at least " + n + ".";
            if (this._setPixels(e, r, i, a), 0 === r) {
                var s = t.LayaGL.instance;
                this._setWarpMode(s.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s.TEXTURE_WRAP_T, this._wrapModeV);
            }
            this._readyed = !0, this._activeResource();
        }
        setImageSource(r, i, a = 0) {
            var n = this._width, s = this._height;
            if (!i || n === i.width && s === i.height) {
                var o = t.LayaGL.instance;
                t.WebGLContext.bindTexture(o, this._glTextureType, this._glTexture);
                var l = this._getGLFormat();
                switch (r) {
                  case e.TextureCubeFace.NegativeX:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_NEGATIVE_X, a, l, l, o.UNSIGNED_BYTE, i);
                    break;

                  case e.TextureCubeFace.PositiveX:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X, a, l, l, o.UNSIGNED_BYTE, i);
                    break;

                  case e.TextureCubeFace.NegativeY:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_NEGATIVE_Y, a, l, l, o.UNSIGNED_BYTE, i);
                    break;

                  case e.TextureCubeFace.PositiveY:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_Y, a, l, l, o.UNSIGNED_BYTE, i);
                    break;

                  case e.TextureCubeFace.NegativeZ:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_NEGATIVE_Z, a, l, l, o.UNSIGNED_BYTE, i);
                    break;

                  case e.TextureCubeFace.PositiveZ:
                    o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_Z, a, l, l, o.UNSIGNED_BYTE, i);
                }
                this._mipmap && this._isPot(n) && this._isPot(s) ? (o.generateMipmap(this._glTextureType), 
                this._setGPUMemory(n * s * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(n * s * 4 * 6), 
                this._setWarpMode(o.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(o.TEXTURE_WRAP_T, this._wrapModeV), 
                this._setFilterMode(this._filterMode), this._readyed = !0;
            } else console.log("TextureCube: imageSource's width and height must same.");
        }
    }
    Dt.TEXTURECUBE = "TEXTURECUBE";
    class Mt {
        constructor() {
            this._length = 0, this._elements = [];
        }
        add(e) {
            this._length === this._elements.length ? this._elements.push(e) : this._elements[this._length] = e, 
            this._length++;
        }
        remove(e) {
            var t = this._elements.indexOf(e);
            if (this._length--, t !== this._length) {
                var r = this._elements[this._length];
                this._elements[t] = r;
            }
        }
        shift() {
            return this._length--, this._elements.shift();
        }
    }
    class yt extends Mt {
        getSunLight() {
            for (var e, t = -1, r = this._elements, i = 0; i < this._length; i++) {
                var a = r[i]._intensity;
                t < a && (t = a, e = i);
            }
            return e;
        }
    }
    class Ot extends Mt {
        remove(e) {
            var t = this._elements.indexOf(e);
            this._elements.splice(t, 1), this._length--;
        }
    }
    class Nt extends Z {
        constructor() {
            super(), this.setShaderName("LineShader"), this._shaderValues.setVector(Nt.COLOR, new a(1, 1, 1, 1));
        }
        static __initDefine__() {}
        get color() {
            return this._shaderValues.getVector(Nt.COLOR);
        }
        set color(e) {
            this._shaderValues.setVector(Nt.COLOR, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Nt.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Nt.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Nt.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Nt.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Nt.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Nt.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Nt.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Nt.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Nt.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Nt.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Nt.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Nt.DEPTH_TEST);
        }
        clone() {
            var e = new Nt();
            return this.cloneTo(e), e;
        }
    }
    Nt.COLOR = H.propertyNameToID("u_Color"), Nt.CULL = H.propertyNameToID("s_Cull"), 
    Nt.BLEND = H.propertyNameToID("s_Blend"), Nt.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), 
    Nt.BLEND_DST = H.propertyNameToID("s_BlendDst"), Nt.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), 
    Nt.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class bt {
        constructor(e, t) {
            this.min = e, this.max = t;
        }
        _rotateExtents(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.elements;
            r.x = Math.abs(s[0] * i) + Math.abs(s[4] * a) + Math.abs(s[8] * n), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * a) + Math.abs(s[9] * n), 
            r.z = Math.abs(s[2] * i) + Math.abs(s[6] * a) + Math.abs(s[10] * n);
        }
        getCorners(e) {
            e.length = 8;
            var t = this.min.x, r = this.min.y, i = this.min.z, a = this.max.x, s = this.max.y, o = this.max.z;
            e[0] = new n(t, s, o), e[1] = new n(a, s, o), e[2] = new n(a, r, o), e[3] = new n(t, r, o), 
            e[4] = new n(t, s, i), e[5] = new n(a, s, i), e[6] = new n(a, r, i), e[7] = new n(t, r, i);
        }
        getCenter(e) {
            n.add(this.min, this.max, e), n.scale(e, .5, e);
        }
        getExtent(e) {
            n.subtract(this.max, this.min, e), n.scale(e, .5, e);
        }
        setCenterAndExtent(e, t) {
            n.subtract(e, t, this.min), n.add(e, t, this.max);
        }
        tranform(e, t) {
            var r = bt._tempVector30, i = bt._tempVector31;
            this.getCenter(r), this.getExtent(i), n.transformCoordinate(r, e, r), this._rotateExtents(i, e, i), 
            t.setCenterAndExtent(r, i);
        }
        toDefault() {
            this.min.toDefault(), this.max.toDefault();
        }
        static createfromPoints(e, t) {
            if (null == e) throw new Error("points");
            var r = t.min, i = t.max;
            r.x = Number.MAX_VALUE, r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, i.x = -Number.MAX_VALUE, 
            i.y = -Number.MAX_VALUE, i.z = -Number.MAX_VALUE;
            for (var a = 0, s = e.length; a < s; ++a) n.min(r, e[a], r), n.max(i, e[a], i);
        }
        static merge(e, t, r) {
            n.min(e.min, t.min, r.min), n.max(e.max, t.max, r.max);
        }
        cloneTo(e) {
            var t = e;
            this.min.cloneTo(t.min), this.max.cloneTo(t.max);
        }
        clone() {
            var e = new bt(new n(), new n());
            return this.cloneTo(e), e;
        }
    }
    bt._tempVector30 = new n(), bt._tempVector31 = new n();
    class Pt {
        constructor(e, t) {
            this._updateFlag = 0, this._center = new n(), this._extent = new n(), this._boundBox = new bt(new n(), new n()), 
            e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max), this._setUpdateFlag(Pt._UPDATE_CENTER | Pt._UPDATE_EXTENT, !0);
        }
        setMin(e) {
            var t = this._boundBox.min;
            e !== t && e.cloneTo(t), this._setUpdateFlag(Pt._UPDATE_CENTER | Pt._UPDATE_EXTENT, !0), 
            this._setUpdateFlag(Pt._UPDATE_MIN, !1);
        }
        getMin() {
            var e = this._boundBox.min;
            return this._getUpdateFlag(Pt._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e), 
            this._setUpdateFlag(Pt._UPDATE_MIN, !1)), e;
        }
        setMax(e) {
            var t = this._boundBox.max;
            e !== t && e.cloneTo(t), this._setUpdateFlag(Pt._UPDATE_CENTER | Pt._UPDATE_EXTENT, !0), 
            this._setUpdateFlag(Pt._UPDATE_MAX, !1);
        }
        getMax() {
            var e = this._boundBox.max;
            return this._getUpdateFlag(Pt._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e), 
            this._setUpdateFlag(Pt._UPDATE_MAX, !1)), e;
        }
        setCenter(e) {
            e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(Pt._UPDATE_MIN | Pt._UPDATE_MAX, !0), 
            this._setUpdateFlag(Pt._UPDATE_CENTER, !1);
        }
        getCenter() {
            return this._getUpdateFlag(Pt._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center), 
            this._setUpdateFlag(Pt._UPDATE_CENTER, !1)), this._center;
        }
        setExtent(e) {
            e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(Pt._UPDATE_MIN | Pt._UPDATE_MAX, !0), 
            this._setUpdateFlag(Pt._UPDATE_EXTENT, !1);
        }
        getExtent() {
            return this._getUpdateFlag(Pt._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent), 
            this._setUpdateFlag(Pt._UPDATE_EXTENT, !1)), this._extent;
        }
        _getUpdateFlag(e) {
            return 0 != (this._updateFlag & e);
        }
        _setUpdateFlag(e, t) {
            t ? this._updateFlag |= e : this._updateFlag &= ~e;
        }
        _getCenter(e, t, r) {
            n.add(e, t, r), n.scale(r, .5, r);
        }
        _getExtent(e, t, r) {
            n.subtract(t, e, r), n.scale(r, .5, r);
        }
        _getMin(e, t, r) {
            n.subtract(e, t, r);
        }
        _getMax(e, t, r) {
            n.add(e, t, r);
        }
        _rotateExtents(e, t, r) {
            var i = e.x, a = e.y, n = e.z, s = t.elements;
            r.x = Math.abs(s[0] * i) + Math.abs(s[4] * a) + Math.abs(s[8] * n), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * a) + Math.abs(s[9] * n), 
            r.z = Math.abs(s[2] * i) + Math.abs(s[6] * a) + Math.abs(s[10] * n);
        }
        _tranform(e, t) {
            var r = t._center, i = t._extent;
            n.transformCoordinate(this.getCenter(), e, r), this._rotateExtents(this.getExtent(), e, i), 
            t._boundBox.setCenterAndExtent(r, i), t._updateFlag = 0;
        }
        _getBoundBox() {
            if (this._updateFlag & Pt._UPDATE_MIN) {
                var e = this._boundBox.min;
                this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(Pt._UPDATE_MIN, !1);
            }
            if (this._updateFlag & Pt._UPDATE_MAX) {
                var t = this._boundBox.max;
                this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(Pt._UPDATE_MAX, !1);
            }
            return this._boundBox;
        }
        cloneTo(e) {
            var t = e;
            this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max), 
            this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
        }
        clone() {
            var e = new Pt(new n(), new n());
            return this.cloneTo(e), e;
        }
    }
    Pt._UPDATE_MIN = 1, Pt._UPDATE_MAX = 2, Pt._UPDATE_CENTER = 4, Pt._UPDATE_EXTENT = 8;
    class wt {
        constructor() {
            this._destroyed = !1;
        }
        get destroyed() {
            return this._destroyed;
        }
        _getType() {
            throw "GeometryElement:must override it.";
        }
        _prepareRender(e) {
            return !0;
        }
        _render(e) {
            throw "GeometryElement:must override it.";
        }
        destroy() {
            this._destroyed || (this._destroyed = !0);
        }
    }
    wt._typeCounter = 0;
    class Vt {
        static get vertexDeclaration() {
            return Vt._vertexDeclaration;
        }
        static __init__() {
            Vt._vertexDeclaration = new We(28, [ new ke(0, He.Vector3, Xe.MESH_POSITION0), new ke(12, He.Vector4, Xe.MESH_COLOR0) ]);
        }
        get vertexDeclaration() {
            return Vt._vertexDeclaration;
        }
        constructor() {}
    }
    class Bt extends wt {
        constructor(e, r) {
            super(), this._floatCountPerVertices = 7, this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE, 
            this._bufferState = new Ge(), this._floatBound = new Float32Array(6), this._calculateBound = !1, 
            this._maxLineCount = 0, this._lineCount = 0;
            var i = 2 * r;
            this._owner = e, this._maxLineCount = r, this._vertices = new Float32Array(i * this._floatCountPerVertices), 
            this._vertexBuffer = new Ye(Vt.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !1), 
            this._vertexBuffer.vertexDeclaration = Vt.vertexDeclaration, this._bufferState.bind(), 
            this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
            var a = Bt._tempVector0, n = Bt._tempVector1;
            a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), 
            this._bounds = new Pt(a, n);
        }
        _getType() {
            return Bt._type;
        }
        _resizeLineData(e) {
            var r = 2 * e, i = this._vertices;
            this._vertexBuffer.destroy(), this._maxLineCount = e;
            var a = r * this._floatCountPerVertices;
            this._vertices = new Float32Array(a), this._vertexBuffer = new Ye(Vt.vertexDeclaration.vertexStride * r, t.LayaGL.instance.STATIC_DRAW, !1), 
            this._vertexBuffer.vertexDeclaration = Vt.vertexDeclaration, a < i.length ? (this._vertices.set(new Float32Array(i.buffer, 0, a)), 
            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * a)) : (this._vertices.set(i), 
            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i.length)), this._bufferState.bind(), 
            this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
        }
        _updateLineVertices(e, t, r, i, a) {
            t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z), 
            i && (this._vertices[e + 3] = i.r, this._vertices[e + 4] = i.g, this._vertices[e + 5] = i.b, 
            this._vertices[e + 6] = i.a), r && (this._vertices[e + 7] = r.x, this._vertices[e + 8] = r.y, 
            this._vertices[e + 9] = r.z), a && (this._vertices[e + 10] = a.r, this._vertices[e + 11] = a.g, 
            this._vertices[e + 12] = a.b, this._vertices[e + 13] = a.a), this._minUpdate = Math.min(this._minUpdate, e), 
            this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
            var s = this._bounds, o = this._floatBound, l = s.getMin(), _ = s.getMax();
            n.min(l, t, l), n.min(l, r, l), n.max(_, t, _), n.max(_, r, _), s.setMin(l), s.setMax(_), 
            o[0] = l.x, o[1] = l.y, o[2] = l.z, o[3] = _.x, o[4] = _.y, o[5] = _.z;
        }
        _reCalculateBound() {
            if (this._calculateBound) {
                var e = this._vertices, t = Bt._tempVector0, r = Bt._tempVector1;
                t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (var i = 0; i < 2 * this._lineCount; ++i) {
                    var a = this._floatCountPerVertices * i, n = e[a + 0], s = e[a + 1], o = e[a + 2];
                    t.x = Math.min(n, t.x), t.y = Math.min(s, t.y), t.z = Math.min(o, t.z), r.x = Math.max(n, r.x), 
                    r.y = Math.max(s, r.y), r.z = Math.max(o, r.z);
                }
                this._bounds.setMin(t), this._bounds.setMax(r);
                var l = this._floatBound;
                l[0] = t.x, l[1] = t.y, l[2] = t.z, l[3] = r.x, l[4] = r.y, l[5] = r.z, this._calculateBound = !1;
            }
        }
        _removeLineData(e) {
            var t = 2 * this._floatCountPerVertices, r = e + 1, i = e * t, a = this._vertices, n = new Float32Array(a.buffer, r * t * 4, (this._lineCount - r) * t);
            a.set(n, i), this._minUpdate = Math.min(this._minUpdate, i), this._maxUpdate = Math.max(this._maxUpdate, i + n.length), 
            this._lineCount--;
            var s = this._floatBound, o = a[i], l = a[i + 1], _ = a[i + 2], h = a[i + 7], c = a[i + 8], d = a[i + 9], u = s[0], m = s[1], f = s[2], E = s[3], T = s[4], p = s[5];
            o !== u && o !== E && l !== m && l !== T && _ !== f && _ !== p && h !== u && h !== E && c !== m && c !== T && d !== f && d !== p || (this._calculateBound = !0);
        }
        _updateLineData(e, t, r, i, a) {
            var n = 2 * this._floatCountPerVertices;
            this._updateLineVertices(e * n, t, r, i, a);
        }
        _updateLineDatas(e, t) {
            for (var r = 2 * this._floatCountPerVertices, i = t.length, a = 0; a < i; a++) {
                var n = t[a];
                this._updateLineVertices((e + a) * r, n.startPosition, n.endPosition, n.startColor, n.endColor);
            }
        }
        _getLineData(e, t) {
            var r = t.startPosition, i = t.startColor, a = t.endPosition, n = t.endColor, s = this._vertices, o = e * this._floatCountPerVertices * 2;
            r.x = s[o + 0], r.y = s[o + 1], r.z = s[o + 2], i.r = s[o + 3], i.g = s[o + 4], 
            i.b = s[o + 5], i.a = s[o + 6], a.x = s[o + 7], a.y = s[o + 8], a.z = s[o + 9], 
            n.r = s[o + 10], n.g = s[o + 11], n.b = s[o + 12], n.a = s[o + 13];
        }
        _prepareRender(e) {
            return !0;
        }
        _render(e) {
            if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)), 
            this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                this._bufferState.bind();
                var r = t.LayaGL.instance;
                r.drawArrays(r.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++;
            }
        }
        destroy() {
            this._destroyed || (super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), 
            this._bufferState = null, this._vertexBuffer = null, this._vertices = null);
        }
    }
    Bt._tempVector0 = new n(), Bt._tempVector1 = new n(), Bt._type = wt._typeCounter++;
    class Ft {
        constructor() {
            this.updateMark = -1, this.indexInList = -1, this.batched = !1;
        }
    }
    class Ut extends wt {
        constructor() {
            super(), this.maxInstanceCount = 1024, this.instanceWorldMatrixData = new Float32Array(16 * this.maxInstanceCount), 
            this.instanceMVPMatrixData = new Float32Array(16 * this.maxInstanceCount);
            var e = t.LayaGL.instance;
            this.instanceWorldMatrixBuffer = new Ye(4 * this.instanceWorldMatrixData.length, e.DYNAMIC_DRAW), 
            this.instanceMVPMatrixBuffer = new Ye(4 * this.instanceMVPMatrixData.length, e.DYNAMIC_DRAW), 
            this.instanceWorldMatrixBuffer.vertexDeclaration = Xe.instanceWorldMatrixDeclaration, 
            this.instanceMVPMatrixBuffer.vertexDeclaration = Xe.instanceMVPMatrixDeclaration;
        }
        static __init__() {
            Ut.instance = new Ut();
        }
        _render(e) {
            var r = t.LayaGL.instance, i = e.renderElement, a = i.instanceSubMesh, n = i.instanceBatchElementList.length, s = a._indexCount;
            a._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance.drawElementsInstanced(r.TRIANGLES, s, r.UNSIGNED_SHORT, 2 * a._indexStart, n), 
            t.Stat.renderBatches++, t.Stat.savedRenderBatches += n - 1, t.Stat.trianglesFaces += s * n / 3;
        }
    }
    class Gt {
        constructor() {
            this.renderSubShader = null, this.renderType = Gt.RENDERTYPE_NORMAL;
        }
        getInvertFront() {
            return this._transform._isFrontFaceInvert;
        }
        setTransform(e) {
            this._transform = e;
        }
        setGeometry(e) {
            this._geometry = e;
        }
        addToOpaqueRenderQueue(e, t) {
            t.elements.add(this);
        }
        addToTransparentRenderQueue(e, t) {
            t.elements.add(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
        }
        _update(e, t, r, i) {
            if (this.material) {
                var a = this.material._shader.getSubShaderAt(0);
                if (this.renderSubShader = null, r) if (i) {
                    var n = a.getFlag(i);
                    if (!n) return;
                    for (var s = r._subShaders, o = 0, l = s.length; o < l; o++) {
                        var _ = s[o];
                        if (n === _.getFlag(i)) {
                            this.renderSubShader = _;
                            break;
                        }
                    }
                    if (!this.renderSubShader) return;
                } else this.renderSubShader = r.getSubShaderAt(0); else this.renderSubShader = a;
                var h = e._getRenderQueue(this.material.renderQueue);
                h.isTransparent ? this.addToTransparentRenderQueue(t, h) : this.addToOpaqueRenderQueue(t, h);
            }
        }
        _render(e) {
            var t, r, i, a = e.invertY, n = ot._updateMark, s = e.scene, o = e.cameraShaderValue, l = this._transform, _ = this._geometry;
            e.renderElement = this;
            var h = n !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
            h ? (this.render._renderUpdate(e, l), this.render._renderUpdateWithCamera(e, l), 
            this.render._updateMark = n, this.render._updateRenderType = this.renderType) : this.renderType == Gt.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l), 
            this.render._renderUpdateWithCamera(e, l));
            var c = e.pipelineMode;
            if (_._prepareRender(e)) for (var d = this.renderSubShader._passes, u = 0, m = d.length; u < m; u++) {
                var f = d[u];
                if (f._pipelineMode === c) {
                    var E = Gt._compileDefine;
                    s._shaderValues._defineDatas.cloneTo(E), E.addDefineDatas(this.render._shaderValues._defineDatas), 
                    E.addDefineDatas(this.material._shaderValues._defineDatas);
                    var T = e.shader = f.withCompile(E), p = T.bind(), g = n !== T._uploadMark, S = T._uploadScene !== s || g;
                    (S || p) && (T.uploadUniforms(T._sceneUniformParamsMap, s._shaderValues, S), T._uploadScene = s);
                    var R = T._uploadRender !== this.render || T._uploadRenderType !== this.renderType || g;
                    (R || p) && (T.uploadUniforms(T._spriteUniformParamsMap, this.render._shaderValues, R), 
                    T._uploadRender = this.render, T._uploadRenderType = this.renderType);
                    var v = T._uploadCameraShaderValue !== o || g;
                    (v || p) && (T.uploadUniforms(T._cameraUniformParamsMap, o, v), T._uploadCameraShaderValue = o);
                    var x = T._uploadMaterial !== this.material || g;
                    (x || p) && (T.uploadUniforms(T._materialUniformParamsMap, this.material._shaderValues, x), 
                    T._uploadMaterial = this.material);
                    var I = this.material._shaderValues;
                    t !== this.material || r !== T ? (T.uploadRenderStateBlendDepth(I), T.uploadRenderStateFrontFace(I, a, this.getInvertFront()), 
                    t = this.material, r = T, i = this.render) : i !== this.render && (T.uploadRenderStateFrontFace(I, a, this.getInvertFront()), 
                    i = this.render), _._render(e), T._uploadMark = n;
                }
            }
            h && this.renderType !== Gt.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e);
        }
        destroy() {
            this._transform = null, this._geometry = null, this.material = null, this.render = null;
        }
    }
    Gt.RENDERTYPE_NORMAL = 0, Gt.RENDERTYPE_STATICBATCH = 1, Gt.RENDERTYPE_INSTANCEBATCH = 2, 
    Gt.RENDERTYPE_VERTEXBATCH = 3, Gt._compileDefine = new F();
    class zt extends Gt {
        constructor() {
            super(), this._dynamicWorldPositionNormalNeedUpdate = !0;
        }
        _onWorldMatrixChanged() {
            this._dynamicWorldPositionNormalNeedUpdate = !0;
        }
        _computeWorldPositionsAndNormals(e, t, r, i) {
            if (this._dynamicWorldPositionNormalNeedUpdate) {
                for (var a = this._geometry, n = a._vertexBuffer, s = n.vertexDeclaration.vertexStride / 4, o = n.getFloat32Data(), l = this._transform.worldMatrix, _ = this._transform.rotation, h = a._indices, c = 0; c < i; c++) {
                    var d = (r ? h[c] : c) * s, u = 3 * c;
                    I.transformVector3ArrayToVector3ArrayCoordinate(o, d + e, l, this._dynamicWorldPositions, u), 
                    -1 !== t && I.transformVector3ArrayByQuat(o, d + t, _, this._dynamicWorldNormals, u);
                }
                this._dynamicWorldPositionNormalNeedUpdate = !1;
            }
        }
        setTransform(e) {
            this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), 
            e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0, 
            this._transform = e);
        }
        setGeometry(e) {
            if (this._geometry !== e) {
                var t = e, r = t._mesh;
                if (r) {
                    var i = r._subMeshes.length > 1, a = i ? t._indexCount : r._vertexCount;
                    if (a <= _.SubMeshDynamicBatch.maxAllowVertexCount) {
                        var n = 3 * a;
                        this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(n), 
                        this._dynamicWorldNormals = new Float32Array(n), this._dynamicVertexCount = a, this._dynamicMultiSubMesh = i;
                    } else this._dynamicVertexBatch = !1;
                }
                this._geometry = e;
            }
        }
        addToOpaqueRenderQueue(e, r) {
            var i = this.staticBatch, a = r.elements, n = a.elements;
            if (i) {
                var s = _.MeshRenderStaticBatchManager.instance, o = s.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, i._batchID);
                if (s._updateCountMark === o.updateMark) {
                    var l = o.indexInList;
                    if (o.batched) n[l].staticBatchElementList.add(this); else {
                        var h = n[l], c = h.render, d = s._getBatchRenderElementFromPool();
                        d.renderType = Gt.RENDERTYPE_STATICBATCH, d.setGeometry(i), d.material = h.material;
                        var u = i.batchOwner, m = u ? u._transform : null;
                        d.setTransform(m), d.render = c, d.renderSubShader = h.renderSubShader;
                        var f = d.staticBatchElementList;
                        f.length = 0, f.add(h), f.add(this), n[l] = d, o.batched = !0;
                    }
                } else o.updateMark = s._updateCountMark, o.indexInList = a.length, o.batched = !1, 
                a.add(this);
            } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                var E = this._geometry, T = _.MeshRenderDynamicBatchManager.instance, p = T.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, E._id, this._transform._isFrontFaceInvert);
                if (T._updateCountMark === p.updateMark) {
                    var g = p.indexInList;
                    if (p.batched) {
                        var S = n[g].instanceBatchElementList;
                        S.length === Ut.instance.maxInstanceCount ? (p.updateMark = T._updateCountMark, 
                        p.indexInList = a.length, p.batched = !1, a.add(this)) : S.add(this);
                    } else {
                        var R = n[g], v = R.render, x = T._getBatchRenderElementFromPool();
                        x.renderType = Gt.RENDERTYPE_INSTANCEBATCH, x.setGeometry(Ut.instance), x.material = R.material, 
                        x.setTransform(null), x.render = v, x.instanceSubMesh = E, x.renderSubShader = R.renderSubShader;
                        var I = x.instanceBatchElementList;
                        I.length = 0, I.add(R), I.add(this), n[g] = x, p.batched = !0;
                    }
                } else p.updateMark = T._updateCountMark, p.indexInList = a.length, p.batched = !1, 
                a.add(this);
            } else if (this._dynamicVertexBatch) {
                var A = this._geometry._vertexBuffer.vertexDeclaration, L = _.MeshRenderDynamicBatchManager.instance, C = L.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, A.id);
                if (L._updateCountMark === C.updateMark) {
                    var D = C.indexInList;
                    if (C.batched) n[D].vertexBatchElementList.add(this); else {
                        var M = n[D], y = M.render, O = L._getBatchRenderElementFromPool();
                        O.renderType = Gt.RENDERTYPE_VERTEXBATCH, O.setGeometry(_.SubMeshDynamicBatch.instance), 
                        O.material = M.material, O.setTransform(null), O.render = y, O.vertexBatchVertexDeclaration = A, 
                        O.renderSubShader = M.renderSubShader;
                        var N = O.vertexBatchElementList;
                        N.length = 0, N.add(M), N.add(this), n[D] = O, C.batched = !0;
                    }
                } else C.updateMark = L._updateCountMark, C.indexInList = a.length, C.batched = !1, 
                a.add(this);
            } else a.add(this);
        }
        addToTransparentRenderQueue(e, r) {
            var i = this.staticBatch, a = r.elements, n = a.elements;
            if (i) {
                var s = _.MeshRenderStaticBatchManager.instance, o = r.lastTransparentRenderElement;
                if (o) {
                    var l = o.render;
                    if (o._geometry._getType() !== this._geometry._getType() || o.staticBatch !== i || o.material !== this.material || l.receiveShadow !== this.render.receiveShadow || l.lightmapIndex !== this.render.lightmapIndex) a.add(this), 
                    r.lastTransparentBatched = !1; else {
                        if (r.lastTransparentBatched) n[a.length - 1].staticBatchElementList.add(this); else {
                            var h = s._getBatchRenderElementFromPool();
                            h.renderType = Gt.RENDERTYPE_STATICBATCH, h.setGeometry(i), h.material = o.material;
                            var c = i.batchOwner, d = c ? c._transform : null;
                            h.setTransform(d), h.render = this.render, h.renderSubShader = o.renderSubShader;
                            var u = h.staticBatchElementList;
                            u.length = 0, u.add(o), u.add(this), n[a.length - 1] = h;
                        }
                        r.lastTransparentBatched = !0;
                    }
                } else a.add(this), r.lastTransparentBatched = !1;
            } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                var m = this._geometry, f = _.MeshRenderDynamicBatchManager.instance, E = r.lastTransparentRenderElement;
                if (E) {
                    var T = E.render;
                    if (E._geometry._getType() !== this._geometry._getType() || E._geometry !== m || E.material !== this.material || T.receiveShadow !== this.render.receiveShadow) a.add(this), 
                    r.lastTransparentBatched = !1; else if (r.lastTransparentBatched) {
                        var p = n[a.length - 1].instanceBatchElementList;
                        p.length === Ut.instance.maxInstanceCount ? (a.add(this), r.lastTransparentBatched = !1) : (p.add(this), 
                        r.lastTransparentBatched = !0);
                    } else {
                        var g = f._getBatchRenderElementFromPool();
                        g.renderType = Gt.RENDERTYPE_INSTANCEBATCH, g.setGeometry(Ut.instance), g.material = E.material, 
                        g.setTransform(null), g.render = this.render, g.instanceSubMesh = m, g.renderSubShader = E.renderSubShader;
                        var S = g.instanceBatchElementList;
                        S.length = 0, S.add(E), S.add(this), n[a.length - 1] = g, r.lastTransparentBatched = !0;
                    }
                } else a.add(this), r.lastTransparentBatched = !1;
            } else if (this._dynamicVertexBatch) {
                var R = this._geometry._vertexBuffer.vertexDeclaration, v = _.MeshRenderDynamicBatchManager.instance, x = r.lastTransparentRenderElement;
                if (x) {
                    var I = x.render;
                    if (x._geometry._getType() !== this._geometry._getType() || x._geometry._vertexBuffer._vertexDeclaration !== R || x.material !== this.material || I.receiveShadow !== this.render.receiveShadow || I.lightmapIndex !== this.render.lightmapIndex) a.add(this), 
                    r.lastTransparentBatched = !1; else {
                        if (r.lastTransparentBatched) n[a.length - 1].vertexBatchElementList.add(this); else {
                            var A = v._getBatchRenderElementFromPool();
                            A.renderType = Gt.RENDERTYPE_VERTEXBATCH, A.setGeometry(_.SubMeshDynamicBatch.instance), 
                            A.material = x.material, A.setTransform(null), A.render = this.render, A.vertexBatchVertexDeclaration = R, 
                            A.renderSubShader = x.renderSubShader;
                            var L = A.vertexBatchElementList;
                            L.length = 0, L.add(x), L.add(this), n[a.length - 1] = A;
                        }
                        r.lastTransparentBatched = !0;
                    }
                } else a.add(this), r.lastTransparentBatched = !1;
            } else a.add(this);
            r.lastTransparentRenderElement = this;
        }
        getInvertFront() {
            switch (this.renderType) {
              case Gt.RENDERTYPE_NORMAL:
                return this._transform._isFrontFaceInvert;

              case Gt.RENDERTYPE_STATICBATCH:
              case Gt.RENDERTYPE_VERTEXBATCH:
                return !1;

              case Gt.RENDERTYPE_INSTANCEBATCH:
                return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;

              default:
                throw "SubMeshRenderElement: unknown renderType";
            }
        }
        destroy() {
            super.destroy(), this._dynamicWorldPositions = null, this._dynamicWorldNormals = null, 
            this.staticBatch = null, this.staticBatchElementList = null, this.vertexBatchElementList = null, 
            this.vertexBatchVertexDeclaration = null;
        }
    }
    class Ht extends wt {
        constructor(e, t) {
            super(), this._bufferState = new Ge(), this._batchID = Ht._batchIDCounter++, this._batchElements = [], 
            this._currentBatchVertexCount = 0, this._currentBatchIndexCount = 0, this._vertexDeclaration = t, 
            this.batchOwner = e;
        }
        _getStaticBatchBakedVertexs(e, t, r, i, a, n) {
            var s, o = n._vertexBuffer, l = o.vertexDeclaration, _ = l.getVertexElementByUsage(Xe.MESH_POSITION0)._offset / 4, h = l.getVertexElementByUsage(Xe.MESH_NORMAL0), c = h ? h._offset / 4 : -1, d = l.getVertexElementByUsage(Xe.MESH_COLOR0), u = d ? d._offset / 4 : -1, m = l.getVertexElementByUsage(Xe.MESH_TEXTURECOORDINATE0), f = m ? m._offset / 4 : -1, E = l.getVertexElementByUsage(Xe.MESH_TEXTURECOORDINATE1), T = E ? E._offset / 4 : -1, p = l.getVertexElementByUsage(Xe.MESH_TANGENT0), g = p ? p._offset / 4 : -1, S = l.vertexStride / 4, R = o.getFloat32Data();
            r ? (r.worldMatrix.invert(Ht._tempMatrix4x40), s = Ht._tempMatrix4x41, y.multiply(Ht._tempMatrix4x40, i.worldMatrix, s)) : s = i.worldMatrix;
            var v = Ht._tempMatrix4x42;
            s.invert(v), v.transpose();
            var x = Ht._tempQuaternion0;
            s.decomposeTransRotScale(Ht._tempVector30, x, Ht._tempVector31);
            for (var A = a.lightmapScaleOffset, L = n.vertexCount, C = 0; C < L; C++) {
                var D, M, O = C * S, N = 18 * (C + t);
                I.transformVector3ArrayToVector3ArrayCoordinate(R, O + _, s, e, N + 0), -1 !== c && I.transformVector3ArrayToVector3ArrayNormal(R, O + c, v, e, N + 3);
                var b = N + 6;
                if (-1 !== u) {
                    var P = O + u;
                    for (D = 0, M = 4; D < M; D++) e[b + D] = R[P + D];
                } else for (D = 0, M = 4; D < M; D++) e[b + D] = 1;
                if (-1 !== f) {
                    var w = O + f;
                    e[N + 10] = R[w], e[N + 11] = R[w + 1];
                }
                if (A && (-1 !== T ? I.transformLightingMapTexcoordArray(R, O + T, A, e, N + 12) : I.transformLightingMapTexcoordArray(R, O + f, A, e, N + 12)), 
                -1 !== g) {
                    var V = O + g;
                    e[N + 14] = R[V], e[N + 15] = R[V + 1], e[N + 16] = R[V + 2], e[N + 17] = R[V + 3];
                }
            }
            return L;
        }
        addTest(e) {
            var t = e.meshFilter.sharedMesh.vertexCount;
            return !(this._currentBatchVertexCount + t > Ht.maxBatchVertexCount);
        }
        add(e) {
            var t = e.meshFilter.sharedMesh, r = t.vertexCount;
            this._batchElements.push(e);
            var i = e._render;
            i._isPartOfStaticBatch = !0, i._staticBatch = this;
            for (var a = i._renderElements, n = 0, s = a.length; n < s; n++) a[n].staticBatch = this;
            this._currentBatchIndexCount += t._indexBuffer.indexCount, this._currentBatchVertexCount += r;
        }
        remove(e) {
            var t = e.meshFilter.sharedMesh, r = this._batchElements.indexOf(e);
            if (-1 !== r) {
                this._batchElements.splice(r, 1);
                for (var i = e._render._renderElements, a = 0, n = i.length; a < n; a++) i[a].staticBatch = null;
                this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount, 
                this._currentBatchVertexCount = this._currentBatchVertexCount - t.vertexCount, e._render._isPartOfStaticBatch = !1;
            }
        }
        finishInit() {
            this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(), 
            t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
            var r = t.LayaGL.instance, i = 0, a = 0, n = this.batchOwner, s = this._vertexDeclaration.vertexStride / 4, o = new Float32Array(s * this._currentBatchVertexCount), l = new Uint16Array(this._currentBatchIndexCount);
            this._vertexBuffer = new Ye(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, r.STATIC_DRAW), 
            this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new ze(e.IndexFormat.UInt16, this._currentBatchIndexCount, r.STATIC_DRAW);
            for (var _ = 0, h = this._batchElements.length; _ < h; _++) {
                for (var c, d = this._batchElements[_], u = d.meshFilter.sharedMesh, m = this._getStaticBatchBakedVertexs(o, i, n ? n._transform : null, d._transform, d._render, u), f = u._indexBuffer.getData(), E = i, T = a + f.length, p = d._render._renderElements, g = 0, S = u.subMeshCount; g < S; g++) {
                    var R = u._subMeshes[g], v = a + R._indexStart, x = p[g];
                    x.staticBatchIndexStart = v, x.staticBatchIndexEnd = v + R._indexCount;
                }
                if (l.set(f, a), n ? d._transform._isFrontFaceInvert !== n.transform._isFrontFaceInvert : d._transform._isFrontFaceInvert) for (c = a; c < T; c += 3) {
                    l[c] = E + l[c];
                    var I = l[c + 1], A = l[c + 2];
                    l[c + 1] = E + A, l[c + 2] = E + I;
                } else for (c = a; c < T; c += 3) l[c] = E + l[c], l[c + 1] = E + l[c + 1], l[c + 2] = E + l[c + 2];
                a += f.length, i += m;
            }
            this._vertexBuffer.setData(o.buffer), this._indexBuffer.setData(l);
            var L = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addGPUMemory(L), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
        }
        _render(e) {
            this._bufferState.bind();
            for (var r = t.LayaGL.instance, i = e.renderElement.staticBatchElementList, a = i.elements, n = 0, s = 0, o = i.length, l = 1; l < o; l++) {
                if (a[l - 1].staticBatchIndexEnd !== a[l].staticBatchIndexStart) {
                    var _ = a[n].staticBatchIndexStart, h = a[s].staticBatchIndexEnd - _;
                    r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _), n = ++s, t.Stat.trianglesFaces += h / 3;
                } else s++;
            }
            _ = a[n].staticBatchIndexStart, h = a[s].staticBatchIndexEnd - _, r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _), 
            t.Stat.renderBatches++, t.Stat.savedRenderBatches += o - 1, t.Stat.trianglesFaces += h / 3;
        }
        dispose() {
            var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null, 
            this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(), 
            this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null, 
            this._bufferState = null;
        }
    }
    Ht._tempVector30 = new n(), Ht._tempVector31 = new n(), Ht._tempQuaternion0 = new f(), 
    Ht._tempMatrix4x40 = new y(), Ht._tempMatrix4x41 = new y(), Ht._tempMatrix4x42 = new y(), 
    Ht.maxBatchVertexCount = 65535, Ht._batchIDCounter = 0;
    class Wt extends Ie {
        constructor() {
            super(), this._opaqueBatchMarks = [], this._updateCountMark = 0;
        }
        static __init__() {
            Wt._verDec = Xe.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
        }
        _compare(e, t) {
            var r = e._render, i = t._render, a = e.meshFilter.sharedMesh, n = t.meshFilter.sharedMesh, s = r.lightmapIndex - i.lightmapIndex;
            if (0 === s) {
                var o = (r.receiveShadow ? 1 : 0) - (i.receiveShadow ? 1 : 0);
                if (0 === o) {
                    var l = r.sharedMaterial && i.sharedMaterial ? r.sharedMaterial.id - i.sharedMaterial.id : 0;
                    if (0 === l) {
                        var _ = a._vertexBuffer.vertexDeclaration.id - n._vertexBuffer.vertexDeclaration.id;
                        return 0 === _ ? n._indexBuffer.indexCount - a._indexBuffer.indexCount : _;
                    }
                    return l;
                }
                return o;
            }
            return s;
        }
        _getBatchRenderElementFromPool() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new zt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
            e.staticBatchElementList = new Te()), e;
        }
        _getStaticBatch(e, t, r) {
            var i = e[r];
            return i || (i = e[r] = new Ht(t, Wt._verDec), this._staticBatches[i._batchID] = i), 
            i;
        }
        _initStaticBatchs(e) {
            var t = this._initBatchSprites;
            this._quickSort(t, 0, t.length - 1);
            for (var r, i = [], a = !1, n = 0, s = 0, o = t.length; s < o; s++) {
                var l = t[s];
                if (a) r.addTest(l) ? r.add(l) : (a = !1, n++); else s !== o - 1 && ((r = this._getStaticBatch(i, e, n)).add(l), 
                a = !0);
            }
            for (s = 0, o = i.length; s < o; s++) {
                var _ = i[s];
                _ && _.finishInit();
            }
            this._initBatchSprites.length = 0;
        }
        _removeRenderSprite(e) {
            var t = e._render, r = t._staticBatch, i = r._batchElements, a = i.indexOf(e);
            if (-1 !== a) {
                i.splice(a, 1), t._staticBatch = null;
                for (var n = t._renderElements, s = 0, o = n.length; s < o; s++) n[s].staticBatch = null;
            }
            0 === i.length && (delete this._staticBatches[r._batchID], r.dispose());
        }
        _clear() {
            super._clear(), this._updateCountMark++;
        }
        _garbageCollection() {
            for (var e in this._staticBatches) {
                var t = this._staticBatches[e];
                0 === t._batchElements.length && (t.dispose(), delete this._staticBatches[e]);
            }
        }
        getBatchOpaquaMark(e, t, r, i) {
            var a = t ? 1 : 0, n = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []), s = n[a] || (n[a] = []), o = s[r] || (s[r] = []);
            return o[i] || (o[i] = new Ft());
        }
    }
    Wt.instance = new Wt();
    class kt extends t.EventDispatcher {
        constructor(e) {
            if (super(), this._lightmapScaleOffset = new a(1, 1, 0, 0), this._indexInList = -1, 
            this._indexInCastShadowList = -1, this._boundsChange = !0, this._castShadow = !1, 
            this._supportOctree = !0, this._sharedMaterials = [], this._renderMark = -1, this._indexInOctreeMotionList = -1, 
            this._updateMark = -1, this._updateRenderType = -1, this._isPartOfStaticBatch = !1, 
            this._staticBatch = null, this._id = ++kt._uniqueIDCounter, this._indexInCastShadowList = -1, 
            this._bounds = new Pt(n._ZERO, n._ZERO), t.Render.supportWebGLPlusCulling) {
                var r = Ce._cullingBufferLength;
                this._cullingBufferIndex = r;
                var i = Ce._cullingBuffer, s = r + 7;
                if (s >= i.length) {
                    var o = i;
                    (i = Ce._cullingBuffer = new Float32Array(i.length + 4096)).set(o, 0);
                }
                i[r] = 2, Ce._cullingBufferLength = s;
            }
            this._renderElements = [], this._owner = e, this._enable = !0, this._materialsInstance = [], 
            this._shaderValues = new W(null), this.lightmapIndex = -1, this.receiveShadow = !1, 
            this.sortingFudge = 0, e && this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
        }
        get id() {
            return this._id;
        }
        get lightmapIndex() {
            return this._lightmapIndex;
        }
        set lightmapIndex(e) {
            this._lightmapIndex = e;
        }
        get lightmapScaleOffset() {
            return this._lightmapScaleOffset;
        }
        set lightmapScaleOffset(e) {
            if (!e) throw "BaseRender: lightmapScaleOffset can't be null.";
            this._lightmapScaleOffset = e, this._shaderValues.setVector(xe.LIGHTMAPSCALEOFFSET, e);
        }
        get enable() {
            return this._enable;
        }
        set enable(e) {
            this._enable = !!e;
        }
        get material() {
            var e = this._sharedMaterials[0];
            if (e && !this._materialsInstance[0]) {
                var t = this._getInstanceMaterial(e, 0), r = this._renderElements[0];
                r && (r.material = t);
            }
            return this._sharedMaterials[0];
        }
        set material(e) {
            this.sharedMaterial = e;
        }
        get materials() {
            for (var e = 0, t = this._sharedMaterials.length; e < t; e++) if (!this._materialsInstance[e]) {
                var r = this._getInstanceMaterial(this._sharedMaterials[e], e), i = this._renderElements[e];
                i && (i.material = r);
            }
            return this._sharedMaterials.slice();
        }
        set materials(e) {
            this.sharedMaterials = e;
        }
        get sharedMaterial() {
            return this._sharedMaterials[0];
        }
        set sharedMaterial(e) {
            var t = this._sharedMaterials[0];
            if (t !== e) {
                this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                var r = this._renderElements[0];
                r && (r.material = e);
            }
        }
        get sharedMaterials() {
            return this._sharedMaterials.slice();
        }
        set sharedMaterials(e) {
            for (var t = this._materialsInstance, r = this._sharedMaterials, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                n && n._removeReference();
            }
            if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
            var s = e.length;
            for (t.length = s, r.length = s, i = 0; i < s; i++) {
                n = r[i];
                var o = e[i];
                if (n !== o) {
                    t[i] = !1;
                    var l = this._renderElements[i];
                    l && (l.material = o);
                }
                o && o._addReference(), r[i] = o;
            }
        }
        get bounds() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
            this._bounds;
        }
        set receiveShadow(e) {
            this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues.addDefine(xe.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(xe.SHADERDEFINE_RECEIVE_SHADOW));
        }
        get receiveShadow() {
            return this._receiveShadow;
        }
        get castShadow() {
            return this._castShadow;
        }
        set castShadow(e) {
            this._castShadow = e;
        }
        get isPartOfStaticBatch() {
            return this._isPartOfStaticBatch;
        }
        get isRender() {
            return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1;
        }
        _getOctreeNode() {
            return this._octreeNode;
        }
        _setOctreeNode(e) {
            this._octreeNode = e;
        }
        _getIndexInMotionList() {
            return this._indexInOctreeMotionList;
        }
        _setIndexInMotionList(e) {
            this._indexInOctreeMotionList = e;
        }
        _changeMaterialReference(e, t) {
            e && e._removeReference(), t._addReference();
        }
        _getInstanceMaterial(e, t) {
            var r = e.clone();
            return r.name = r.name + "(Instance)", this._materialsInstance[t] = !0, this._changeMaterialReference(this._sharedMaterials[t], r), 
            this._sharedMaterials[t] = r, r;
        }
        _applyLightMapParams() {
            var e = this._scene.lightmaps, t = this._shaderValues, r = this._lightmapIndex;
            if (r >= 0 && r < e.length) {
                var i = e[r];
                t.setTexture(xe.LIGHTMAP, i.lightmapColor), t.addDefine(xe.SAHDERDEFINE_LIGHTMAP), 
                i.lightmapDirection ? (t.setTexture(xe.LIGHTMAP_DIRECTION, i.lightmapDirection), 
                t.addDefine(xe.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)) : t.removeDefine(xe.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
            } else t.removeDefine(xe.SAHDERDEFINE_LIGHTMAP), t.removeDefine(xe.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
        }
        _onWorldMatNeedChange(e) {
            this._boundsChange = !0, this._octreeNode && (e &= Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
        }
        _calculateBoundingBox() {
            throw "BaseRender: must override it.";
        }
        _getIndexInList() {
            return this._indexInList;
        }
        _setIndexInList(e) {
            this._indexInList = e;
        }
        _setBelongScene(e) {
            this._scene = e;
        }
        _needRender(e, t) {
            return !0;
        }
        _renderUpdate(e, t) {}
        _renderUpdateWithCamera(e, t) {}
        _revertBatchRenderUpdate(e) {}
        _destroy() {
            -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this), 
            this.offAll();
            var e = 0, t = 0;
            for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e].destroy();
            for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
            this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null, 
            this._lightmapScaleOffset = null;
        }
        markAsUnStatic() {
            this._isPartOfStaticBatch && (Wt.instance._removeRenderSprite(this._owner), this._isPartOfStaticBatch = !1);
        }
    }
    kt._tempBoundBoxCorners = [ new n(), new n(), new n(), new n(), new n(), new n(), new n(), new n() ], 
    kt._uniqueIDCounter = 0, kt._defaultLightmapScaleOffset = new a(1, 1, 0, 0);
    class Xt extends kt {
        constructor(e) {
            super(e), this._projectionViewWorldMatrix = new y();
        }
        _calculateBoundingBox() {
            var e = this._owner.transform.worldMatrix, r = this._owner._geometryFilter;
            if (r._reCalculateBound(), r._bounds._tranform(e, this._bounds), t.Render.supportWebGLPlusCulling) {
                var i = this._bounds.getMin(), a = this._bounds.getMax(), n = Ce._cullingBuffer;
                n[this._cullingBufferIndex + 1] = i.x, n[this._cullingBufferIndex + 2] = i.y, n[this._cullingBufferIndex + 3] = i.z, 
                n[this._cullingBufferIndex + 4] = a.x, n[this._cullingBufferIndex + 5] = a.y, n[this._cullingBufferIndex + 6] = a.z;
            }
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix, i = this._shaderValues;
            if (t) {
                var a = t.worldMatrix;
                i.setMatrix4x4(ve.WORLDMATRIX, a), y.multiply(r, a, this._projectionViewWorldMatrix), 
                i.setMatrix4x4(ve.MVPMATRIX, this._projectionViewWorldMatrix);
            } else i.setMatrix4x4(ve.WORLDMATRIX, y.DEFAULT), i.setMatrix4x4(ve.MVPMATRIX, r);
        }
    }
    class Yt extends xe {
        get maxLineCount() {
            return this._geometryFilter._maxLineCount;
        }
        set maxLineCount(e) {
            this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
        }
        get lineCount() {
            return this._geometryFilter._lineCount;
        }
        set lineCount(e) {
            if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
            this._geometryFilter._lineCount = e;
        }
        get pixelLineRenderer() {
            return this._render;
        }
        constructor(e = 2, t = null) {
            super(t), this._geometryFilter = new Bt(this, e), this._render = new Xt(this), this._changeRenderObjects(this._render, 0, Nt.defaultMaterial);
        }
        _changeRenderObjects(e, t, r) {
            var i = this._render._renderElements;
            r || (r = Nt.defaultMaterial);
            var a = i[t];
            a || (a = i[t] = new Gt()), a.setTransform(this._transform), a.setGeometry(this._geometryFilter), 
            a.render = this._render, a.material = r;
        }
        addLine(e, t, r, i) {
            if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
            this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r, i);
        }
        addLines(e) {
            var t = this._geometryFilter._lineCount, r = e.length;
            if (t + r > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
            this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += r;
        }
        removeLine(e) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._removeLineData(e);
        }
        setLine(e, t, r, i, a) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._updateLineData(e, t, r, i, a);
        }
        getLine(e, t) {
            if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._getLineData(e, t);
        }
        clear() {
            this._geometryFilter._lineCount = 0;
        }
        _create() {
            return new Yt();
        }
    }
    class jt {
        constructor(e = !1) {
            this.isTransparent = !1, this.elements = new Te(), this.lastTransparentRenderElement = null, 
            this.lastTransparentBatched = !1, this.isTransparent = e;
        }
        _compare(e, t) {
            var r = e.material.renderQueue - t.material.renderQueue;
            return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r;
        }
        _partitionRenderObject(e, t) {
            for (var r = this.elements.elements, i = r[Math.floor((t + e) / 2)]; e <= t; ) {
                for (;this._compare(r[e], i) < 0; ) e++;
                for (;this._compare(r[t], i) > 0; ) t--;
                if (e < t) {
                    var a = r[e];
                    r[e] = r[t], r[t] = a, e++, t--;
                } else if (e === t) {
                    e++;
                    break;
                }
            }
            return e;
        }
        _quickSort(e, t) {
            if (this.elements.length > 1) {
                var r = this._partitionRenderObject(e, t), i = r - 1;
                e < i && this._quickSort(e, i), r < t && this._quickSort(r, t);
            }
        }
        _render(e) {
            for (var t = this.elements.elements, r = 0, i = this.elements.length; r < i; r++) t[r]._render(e);
        }
        clear() {
            this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
        }
    }
    class Zt {
        constructor(e, t, r, i) {
            this._bounds = new bt(new n(), new n()), this._objects = [], this._isContaion = !1, 
            this.center = new n(), this.baseLength = 0, this._setValues(e, t, r, i);
        }
        static _encapsulates(e, t) {
            return Ve.boxContainsBox(e, t) == we.Contains;
        }
        _setValues(e, t, r, i) {
            this._octree = e, this._parent = t, this.baseLength = r, i.cloneTo(this.center);
            var a = this._bounds.min, n = this._bounds.max, s = e._looseness * r / 2;
            a.setValue(i.x - s, i.y - s, i.z - s), n.setValue(i.x + s, i.y + s, i.z + s);
        }
        _getChildBound(e) {
            if (null != this._children && this._children[e]) return this._children[e]._bounds;
            var t = this.baseLength / 4, r = this.baseLength / 2 * this._octree._looseness / 2, i = Zt._tempBoundBox, a = i.min, n = i.max;
            switch (e) {
              case 0:
                a.x = this.center.x - t - r, a.y = this.center.y + t - r, a.z = this.center.z - t - r, 
                n.x = this.center.x - t + r, n.y = this.center.y + t + r, n.z = this.center.z - t + r;
                break;

              case 1:
                a.x = this.center.x + t - r, a.y = this.center.y + t - r, a.z = this.center.z - t - r, 
                n.x = this.center.x + t + r, n.y = this.center.y + t + r, n.z = this.center.z - t + r;
                break;

              case 2:
                a.x = this.center.x - t - r, a.y = this.center.y + t - r, a.z = this.center.z + t - r, 
                n.x = this.center.x - t + r, n.y = this.center.y + t + r, n.z = this.center.z + t + r;
                break;

              case 3:
                a.x = this.center.x + t - r, a.y = this.center.y + t - r, a.z = this.center.z + t - r, 
                n.x = this.center.x + t + r, n.y = this.center.y + t + r, n.z = this.center.z + t + r;
                break;

              case 4:
                a.x = this.center.x - t - r, a.y = this.center.y - t - r, a.z = this.center.z - t - r, 
                n.x = this.center.x - t + r, n.y = this.center.y - t + r, n.z = this.center.z - t + r;
                break;

              case 5:
                a.x = this.center.x + t - r, a.y = this.center.y - t - r, a.z = this.center.z - t - r, 
                n.x = this.center.x + t + r, n.y = this.center.y - t + r, n.z = this.center.z - t + r;
                break;

              case 6:
                a.x = this.center.x - t - r, a.y = this.center.y - t - r, a.z = this.center.z + t - r, 
                n.x = this.center.x - t + r, n.y = this.center.y - t + r, n.z = this.center.z + t + r;
                break;

              case 7:
                a.x = this.center.x + t - r, a.y = this.center.y - t - r, a.z = this.center.z + t - r, 
                n.x = this.center.x + t + r, n.y = this.center.y - t + r, n.z = this.center.z + t + r;
            }
            return i;
        }
        _getChildCenter(e) {
            if (null != this._children) return this._children[e].center;
            var t = this.baseLength / 4, r = Zt._tempVector30;
            switch (e) {
              case 0:
                r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z - t;
                break;

              case 1:
                r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z - t;
                break;

              case 2:
                r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z + t;
                break;

              case 3:
                r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z + t;
                break;

              case 4:
                r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z - t;
                break;

              case 5:
                r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z - t;
                break;

              case 6:
                r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z + t;
                break;

              case 7:
                r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z + t;
            }
            return r;
        }
        _getChild(e) {
            var t = this.baseLength / 4;
            switch (this._children || (this._children = []), e) {
              case 0:
                return this._children[0] || (this._children[0] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x + -t, this.center.y + t, this.center.z - t)));

              case 1:
                return this._children[1] || (this._children[1] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y + t, this.center.z - t)));

              case 2:
                return this._children[2] || (this._children[2] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y + t, this.center.z + t)));

              case 3:
                return this._children[3] || (this._children[3] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y + t, this.center.z + t)));

              case 4:
                return this._children[4] || (this._children[4] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y - t, this.center.z - t)));

              case 5:
                return this._children[5] || (this._children[5] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y - t, this.center.z - t)));

              case 6:
                return this._children[6] || (this._children[6] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x - t, this.center.y - t, this.center.z + t)));

              case 7:
                return this._children[7] || (this._children[7] = new Zt(this._octree, this, this.baseLength / 2, new n(this.center.x + t, this.center.y - t, this.center.z + t)));

              default:
                throw "BoundsOctreeNode: unknown index.";
            }
        }
        _shouldMerge() {
            for (var e = this._objects.length, t = 0; t < 8; t++) {
                var r = this._children[t];
                if (r) {
                    if (null != r._children) return !1;
                    e += r._objects.length;
                }
            }
            return e <= Zt._NUM_OBJECTS_ALLOWED;
        }
        _mergeChildren() {
            for (var e = 0; e < 8; e++) {
                var t = this._children[e];
                if (t) {
                    t._parent = null;
                    for (var r = t._objects, i = r.length - 1; i >= 0; i--) {
                        var a = r[i];
                        this._objects.push(a), a._setOctreeNode(this);
                    }
                }
            }
            this._children = null;
        }
        _merge() {
            if (null === this._children) {
                var e = this._parent;
                e && e._shouldMerge() && (e._mergeChildren(), e._merge());
            }
        }
        _checkAddNode(e) {
            if (null == this._children) {
                if (this._objects.length < Zt._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                for (var t = this._objects.length - 1; t >= 0; t--) {
                    var r = this._objects[t], i = this._bestFitChild(r.bounds.getCenter());
                    Zt._encapsulates(this._getChildBound(i), r.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(r), 1), 
                    this._getChild(i)._add(r));
                }
            }
            var a = this._bestFitChild(e.bounds.getCenter());
            return Zt._encapsulates(this._getChildBound(a), e.bounds._getBoundBox()) ? this._getChild(a)._checkAddNode(e) : this;
        }
        _add(e) {
            var t = this._checkAddNode(e);
            t._objects.push(e), e._setOctreeNode(t);
        }
        _remove(e) {
            var t = this._objects.indexOf(e);
            this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
        }
        _addUp(e) {
            return Ve.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === we.Contains ? (this._add(e), 
            !0) : !!this._parent && this._parent._addUp(e);
        }
        _getCollidingWithFrustum(e, r, i, a, s, o) {
            var l = e.boundFrustum, _ = e.position, h = e.cullingMask;
            if (i) {
                var c = l.containsBoundBox(this._bounds);
                if (t.Stat.octreeNodeCulling++, c === we.Disjoint) return;
                i = c === we.Intersects;
            }
            this._isContaion = !i;
            for (var d = r.scene, u = t.Stat.loopCount, m = 0, f = this._objects.length; m < f; m++) {
                var E = this._objects[m];
                if (o ? E._castShadow && E._enable : 0 != (Math.pow(2, E._owner._layer) & h) && E._enable) {
                    if (i && (t.Stat.frustumCulling++, !E._needRender(l, r))) continue;
                    E._renderMark = u, E._distanceForSort = n.distance(E.bounds.getCenter(), _);
                    for (var T = E._renderElements, p = 0, g = T.length; p < g; p++) {
                        T[p]._update(d, r, a, s);
                    }
                }
            }
            if (null != this._children) for (m = 0; m < 8; m++) {
                var S = this._children[m];
                S && S._getCollidingWithFrustum(e, r, i, a, s, o);
            }
        }
        _getCollidingWithBoundBox(e, t, r) {
            if (t) {
                var i = Ve.boxContainsBox(this._bounds, e);
                if (i === we.Disjoint) return;
                t = i === we.Intersects;
            }
            if (t) for (var a = 0, n = this._objects.length; a < n; a++) {
                var s = this._objects[a];
                Ve.intersectsBoxAndBox(s.bounds._getBoundBox(), e) && r.push(s);
            }
            if (null != this._children) for (a = 0; a < 8; a++) {
                this._children[a]._getCollidingWithBoundBox(e, t, r);
            }
        }
        _bestFitChild(e) {
            return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
        }
        _update(e) {
            if (Ve.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === we.Contains) {
                var t = this._checkAddNode(e);
                if (t !== e._getOctreeNode()) {
                    t._objects.push(e), e._setOctreeNode(t);
                    var r = this._objects.indexOf(e);
                    this._objects.splice(r, 1), this._merge();
                }
                return !0;
            }
            if (this._parent) {
                var i = this._parent._addUp(e);
                return i && (r = this._objects.indexOf(e), this._objects.splice(r, 1), this._merge()), 
                i;
            }
            return !1;
        }
        add(e) {
            return !!Zt._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), 
            !0);
        }
        remove(e) {
            return e._getOctreeNode() === this && (this._remove(e), !0);
        }
        update(e) {
            return e._getOctreeNode() === this && this._update(e);
        }
        shrinkIfPossible(e) {
            if (this.baseLength < 2 * e) return this;
            for (var t = -1, r = 0, i = this._objects.length; r < i; r++) {
                var a = this._objects[r], n = this._bestFitChild(a.bounds.getCenter());
                if (0 != r && n != t) return this;
                var s = this._getChildBound(n);
                if (!Zt._encapsulates(s, a.bounds._getBoundBox())) return this;
                0 == r && (t = n);
            }
            if (null == this._children) {
                if (-1 != t) {
                    var o = this._getChildCenter(t);
                    this._setValues(this._octree, null, this.baseLength / 2, o);
                }
                return this;
            }
            var l = !1;
            for (r = 0, i = this._children.length; r < i; r++) {
                var _ = this._children[r];
                if (_ && _.hasAnyObjects()) {
                    if (l) return this;
                    if (t >= 0 && t != r) return this;
                    l = !0, t = r;
                }
            }
            if (-1 != t) {
                var h = this._children[t];
                return h._parent = null, h;
            }
            return this;
        }
        hasAnyObjects() {
            if (this._objects.length > 0) return !0;
            if (null != this._children) for (var e = 0; e < 8; e++) {
                var t = this._children[e];
                if (t && t.hasAnyObjects()) return !0;
            }
            return !1;
        }
        getCollidingWithBoundBox(e, t) {
            this._getCollidingWithBoundBox(e, !0, t);
        }
        getCollidingWithRay(e, t, r = Number.MAX_VALUE) {
            var i = Ve.intersectsRayAndBoxRD(e, this._bounds);
            if (!(-1 == i || i > r)) {
                for (var a = 0, n = this._objects.length; a < n; a++) {
                    var s = this._objects[a];
                    -1 !== (i = Ve.intersectsRayAndBoxRD(e, s.bounds._getBoundBox())) && i <= r && t.push(s);
                }
                if (null != this._children) for (a = 0; a < 8; a++) {
                    this._children[a].getCollidingWithRay(e, t, r);
                }
            }
        }
        getCollidingWithFrustum(e, t, r, i, a) {
            this._getCollidingWithFrustum(e, t, !0, r, i, a);
        }
        isCollidingWithBoundBox(e) {
            if (!Ve.intersectsBoxAndBox(this._bounds, e)) return !1;
            for (var t = 0, r = this._objects.length; t < r; t++) {
                var i = this._objects[t];
                if (Ve.intersectsBoxAndBox(i.bounds._getBoundBox(), e)) return !0;
            }
            if (null != this._children) for (t = 0; t < 8; t++) {
                if (this._children[t].isCollidingWithBoundBox(e)) return !0;
            }
            return !1;
        }
        isCollidingWithRay(e, t = Number.MAX_VALUE) {
            var r = Ve.intersectsRayAndBoxRD(e, this._bounds);
            if (-1 == r || r > t) return !1;
            for (var i = 0, a = this._objects.length; i < a; i++) {
                var n = this._objects[i];
                if (-1 !== (r = Ve.intersectsRayAndBoxRD(e, n.bounds._getBoundBox())) && r <= t) return !0;
            }
            if (null != this._children) for (i = 0; i < 8; i++) {
                if (this._children[i].isCollidingWithRay(e, t)) return !0;
            }
            return !1;
        }
        getBound() {
            return this._bounds;
        }
        drawAllBounds(e, t, r) {
            if (null !== this._children || 0 != this._objects.length) {
                t++;
                var i = Zt._tempColor0;
                if (this._isContaion) i.r = 0, i.g = 0, i.b = 1; else {
                    var a = r ? t / r : 0;
                    i.r = 1 - a, i.g = a, i.b = 0;
                }
                if (i.a = .3, I._drawBound(e, this._bounds, i), null != this._children) for (var n = 0; n < 8; n++) {
                    var s = this._children[n];
                    s && s.drawAllBounds(e, t, r);
                }
            }
        }
        drawAllObjects(e, t, r) {
            t++;
            var i = Zt._tempColor0;
            if (this._isContaion) i.r = 0, i.g = 0, i.b = 1; else {
                var a = r ? t / r : 0;
                i.r = 1 - a, i.g = a, i.b = 0;
            }
            i.a = 1;
            for (var n = 0, s = this._objects.length; n < s; n++) I._drawBound(e, this._objects[n].bounds._getBoundBox(), i);
            if (null != this._children) for (n = 0; n < 8; n++) {
                var o = this._children[n];
                o && o.drawAllObjects(e, t, r);
            }
        }
    }
    Zt._tempVector3 = new n(), Zt._tempVector30 = new n(), Zt._tempVector31 = new n(), 
    Zt._tempColor0 = new ge(), Zt._tempBoundBox = new bt(new n(), new n()), Zt._NUM_OBJECTS_ALLOWED = 8;
    class qt extends Te {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
            this._add(e), e._setIndexInMotionList(this.length++);
        }
        remove(e) {
            var t = e._getIndexInMotionList();
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._setIndexInMotionList(t);
            }
            e._setIndexInMotionList(-1);
        }
    }
    class Qt {
        constructor(e, t, r, i) {
            this._motionObjects = new qt(), this.count = 0, r > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + r + " Adjusted to: " + e), 
            r = e), this._initialSize = e, this._minSize = r, this._looseness = Math.min(Math.max(i, 1), 2), 
            this._rootNode = new Zt(this, null, e, t);
        }
        _getMaxDepth(e, t) {
            t++;
            var r = e._children;
            if (null != r) for (var i = t, a = 0, n = r.length; a < n; a++) {
                var s = r[a];
                s && (t = Math.max(this._getMaxDepth(s, i), t));
            }
            return t;
        }
        _grow(e) {
            var t = e.x >= 0 ? 1 : -1, r = e.y >= 0 ? 1 : -1, i = e.z >= 0 ? 1 : -1, a = this._rootNode, s = this._rootNode.baseLength / 2, o = 2 * this._rootNode.baseLength, l = this._rootNode.center, _ = new n(l.x + t * s, l.y + r * s, l.z + i * s);
            if (this._rootNode = new Zt(this, null, o, _), a.hasAnyObjects()) {
                for (var h = this._rootNode._bestFitChild(a.center), c = [], d = 0; d < 8; d++) d == h && (a._parent = this._rootNode, 
                c[d] = a);
                this._rootNode._children = c;
            }
        }
        add(e) {
            for (var t = 0; !this._rootNode.add(e); ) {
                var r = Qt._tempVector30;
                if (n.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(r), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
            }
            this.count++;
        }
        remove(e) {
            var t = e._getOctreeNode().remove(e);
            return t && this.count--, t;
        }
        update(e) {
            var t = 0, r = e._getOctreeNode();
            if (r) {
                for (;!r._update(e); ) {
                    var i = Qt._tempVector30;
                    if (n.subtract(e.bounds.getCenter(), this._rootNode.center, i), this._grow(i), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                }
                return !0;
            }
            return !1;
        }
        shrinkRootIfPossible() {
            this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
        }
        addMotionObject(e) {
            this._motionObjects.add(e);
        }
        removeMotionObject(e) {
            this._motionObjects.remove(e);
        }
        updateMotionObjects() {
            for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects.length; t < r; t++) {
                var i = e[t];
                this.update(i), i._setIndexInMotionList(-1);
            }
            this._motionObjects.length = 0;
        }
        isCollidingWithBoundBox(e) {
            return this._rootNode.isCollidingWithBoundBox(e);
        }
        isCollidingWithRay(e, t = Number.MAX_VALUE) {
            return this._rootNode.isCollidingWithRay(e, t);
        }
        getCollidingWithBoundBox(e, t) {
            this._rootNode.getCollidingWithBoundBox(e, t);
        }
        getCollidingWithRay(e, t, r = Number.MAX_VALUE) {
            this._rootNode.getCollidingWithRay(e, t, r);
        }
        getCollidingWithFrustum(e, t, r, i, a) {
            this._rootNode.getCollidingWithFrustum(e, t, r, i, a);
        }
        getMaxBounds() {
            return this._rootNode.getBound();
        }
        drawAllBounds(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllBounds(e, -1, t);
        }
        drawAllObjects(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllObjects(e, -1, t);
        }
    }
    Qt._tempVector30 = new n();
    class Kt {}
    class Jt {
        constructor(e, t) {
            this.center = e, this.radius = t;
        }
        toDefault() {
            this.center.toDefault(), this.radius = 0;
        }
        static createFromSubPoints(e, t, r, i) {
            if (null == e) throw new Error("points");
            if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
            if (r < 0 || t + r > e.length) throw new Error("count" + r + "Must be in the range <= " + e.length + "}");
            var a = t + r, s = Jt._tempVector3;
            s.x = 0, s.y = 0, s.z = 0;
            for (var o = t; o < a; ++o) n.add(e[o], s, s);
            var l = i.center;
            n.scale(s, 1 / r, l);
            var _ = 0;
            for (o = t; o < a; ++o) {
                var h = n.distanceSquared(l, e[o]);
                h > _ && (_ = h);
            }
            i.radius = Math.sqrt(_);
        }
        static createfromPoints(e, t) {
            if (null == e) throw new Error("points");
            Jt.createFromSubPoints(e, 0, e.length, t);
        }
        intersectsRayDistance(e) {
            return Ve.intersectsRayAndSphereRD(e, this);
        }
        intersectsRayPoint(e, t) {
            return Ve.intersectsRayAndSphereRP(e, this, t);
        }
        cloneTo(e) {
            var t = e;
            this.center.cloneTo(t.center), t.radius = this.radius;
        }
        clone() {
            var e = new Jt(new n(), 0);
            return this.cloneTo(e), e;
        }
    }
    Jt._tempVector3 = new n();
    class $t {
        constructor() {
            this.cameraShaderValue = new W(), this.position = new n(), this.viewMatrix = new y(), 
            this.projectionMatrix = new y(), this.viewProjectMatrix = new y(), this.cullPlanes = [ new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()) ], 
            this.splitBoundSphere = new Jt(new n(), 0);
        }
    }
    class er {
        constructor() {
            this._shadowBias = new a(), this._shadowParams = new a(), this._shadowMapSize = new a(), 
            this._shadowMatrices = new Float32Array(16 * er._maxCascades), this._splitBoundSpheres = new Float32Array(4 * er._maxCascades), 
            this._cascadeCount = 0, this._shadowMapWidth = 0, this._shadowMapHeight = 0, this._shadowSliceDatas = [ new $t(), new $t(), new $t(), new $t() ], 
            this._lightUp = new n(), this._lightSide = new n(), this._lightForward = new n();
        }
        _setupShadowCasterShaderValues(e, t, r, i, a) {
            t.setVector(er.SHADOW_BIAS, a), t.setVector3(er.SHADOW_LIGHT_DIRECTION, i);
            var n = r.cameraShaderValue;
            n.setMatrix4x4(Qe.VIEWMATRIX, r.viewMatrix), n.setMatrix4x4(Qe.PROJECTMATRIX, r.projectionMatrix), 
            n.setMatrix4x4(Qe.VIEWPROJECTMATRIX, r.viewProjectMatrix), e.viewMatrix = r.viewMatrix, 
            e.projectionViewMatrix = r.projectionMatrix, e.projectionViewMatrix = r.viewProjectMatrix;
        }
        _setupShadowReceiverShaderValues(t) {
            var r = this._light;
            switch (r.shadowCascadesMode !== e.ShadowCascadesMode.NoCascades ? t.addDefine(at.SHADERDEFINE_SHADOW_CASCADE) : t.removeDefine(at.SHADERDEFINE_SHADOW_CASCADE), 
            r.shadowMode) {
              case e.ShadowMode.Hard:
                t.removeDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                break;

              case e.ShadowMode.SoftLow:
                t.addDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                break;

              case e.ShadowMode.SoftHigh:
                t.addDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH), t.removeDefine(at.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
            }
            t.setTexture(er.SHADOW_MAP, this._shadowMap), t.setBuffer(er.SHADOW_MATRICES, this._shadowMatrices), 
            t.setVector(er.SHADOW_MAP_SIZE, this._shadowMapSize), t.setVector(er.SHADOW_PARAMS, this._shadowParams), 
            t.setBuffer(er.SHADOW_SPLIT_SPHERES, this._splitBoundSpheres);
        }
        update(t, i) {
            this._light = i;
            var a = er._tempMatrix0, s = a.elements, o = this._lightUp, l = this._lightSide, _ = this._lightForward;
            y.createFromQuaternion(i._transform.rotation, a), l.setValue(s[0], s[1], s[2]), 
            o.setValue(s[4], s[5], s[6]), _.setValue(-s[8], -s[9], -s[10]);
            var h, c, d, u, m = i._shadowResolution, f = i._shadowCascadesMode;
            f == e.ShadowCascadesMode.NoCascades ? (h = 1, c = m, d = m, u = m) : (h = f == e.ShadowCascadesMode.TwoCascades ? 2 : 4, 
            d = 2 * (c = st.getMaxTileResolutionInAtlas(m, m, h)), u = f == e.ShadowCascadesMode.TwoCascades ? c : 2 * c), 
            this._cascadeCount = h, this._shadowMapWidth = d, this._shadowMapHeight = u;
            var E = er._cascadesSplitDistance, T = er._frustumPlanes, p = t.nearPlane, g = Math.min(t.farPlane, i._shadowDistance), S = this._shadowMatrices, R = this._splitBoundSpheres;
            st.getCascadesSplitDistance(i._shadowTwoCascadeSplits, i._shadowFourCascadeSplits, p, g, t.fieldOfView * r.Deg2Rad, t.aspectRatio, f, E), 
            st.getCameraFrustumPlanes(t.projectionViewMatrix, T);
            var v = er._tempVector30;
            t._transform.getForward(v), n.normalize(v, v);
            for (var x = 0; x < h; x++) {
                var I = this._shadowSliceDatas[x];
                I.sphereCenterZ = st.getBoundSphereByFrustum(E[x], E[x + 1], t.fieldOfView * r.Deg2Rad, t.aspectRatio, t._transform.position, v, I.splitBoundSphere), 
                st.getDirectionLightShadowCullPlanes(T, x, E, p, _, I), st.getDirectionalLightMatrices(o, l, _, x, i._shadowNearPlane, c, I, S), 
                h > 1 && st.applySliceTransform(I, d, u, x, S);
            }
            st.prepareShadowReceiverShaderValues(i, d, u, this._shadowSliceDatas, h, this._shadowMapSize, this._shadowParams, S, R);
        }
        render(e, r) {
            var i = r._shaderValues;
            e.pipelineMode = "ShadowCaster", W.setRuntimeValueMode(!1);
            var a = this._shadowMap = st.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, t.RenderTextureDepthFormat.DEPTH_16);
            a._start();
            for (var n = this._light, s = 0, o = this._cascadeCount; s < o; s++) {
                var l = this._shadowSliceDatas[s];
                st.getShadowBias(n, l.projectionMatrix, l.resolution, this._shadowBias), this._setupShadowCasterShaderValues(e, i, l, this._lightForward, this._shadowBias);
                var _ = Ce._shadowCullInfo;
                _.position = l.position, _.cullPlanes = l.cullPlanes, _.cullPlaneCount = l.cullPlaneCount, 
                _.cullSphere = l.splitBoundSphere, _.direction = this._lightForward;
                var h = Ce.cullingShadow(_, r, e);
                e.cameraShaderValue = l.cameraShaderValue, ot._updateMark++;
                var c = t.LayaGL.instance, d = l.resolution, u = l.offsetX, m = l.offsetY;
                c.enable(c.SCISSOR_TEST), c.viewport(u, m, d, d), c.scissor(u, m, d, d), c.clear(c.DEPTH_BUFFER_BIT), 
                h && (c.scissor(u + 1, m + 1, d - 2, d - 2), r._opaqueQueue._render(e));
            }
            a._end(), this._setupShadowReceiverShaderValues(i), W.setRuntimeValueMode(!0), e.pipelineMode = "Forward";
        }
        cleanUp() {
            B.recoverToPool(this._shadowMap), this._shadowMap = null, this._light = null;
        }
    }
    er._tempVector30 = new n(), er._tempMatrix0 = new y(), er.SHADOW_BIAS = H.propertyNameToID("u_ShadowBias"), 
    er.SHADOW_LIGHT_DIRECTION = H.propertyNameToID("u_ShadowLightDirection"), er.SHADOW_SPLIT_SPHERES = H.propertyNameToID("u_ShadowSplitSpheres"), 
    er.SHADOW_MATRICES = H.propertyNameToID("u_ShadowMatrices"), er.SHADOW_MAP_SIZE = H.propertyNameToID("u_ShadowMapSize"), 
    er.SHADOW_MAP = H.propertyNameToID("u_ShadowMap"), er.SHADOW_PARAMS = H.propertyNameToID("u_ShadowParams"), 
    er._maxCascades = 4, er._cascadesSplitDistance = new Array(er._maxCascades + 1), 
    er._frustumPlanes = new Array(new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n()), new be(new n())), 
    (_e = e.AmbientMode || (e.AmbientMode = {}))[_e.SolidColor = 0] = "SolidColor", 
    _e[_e.SphericalHarmonics = 1] = "SphericalHarmonics";
    class tr extends t.Sprite {
        constructor() {
            super(), this._lightCount = 0, this._pointLights = new Mt(), this._spotLights = new Mt(), 
            this._directionLights = new yt(), this._alternateLights = new Ot(), this._lightmaps = [], 
            this._skyRenderer = new qe(), this._input = new It(), this._timer = t.ILaya.timer, 
            this._time = 0, this._shCoefficients = new Array(7), this._ambientMode = e.AmbientMode.SolidColor, 
            this._ambientSphericalHarmonics = new ye(), this._ambientSphericalHarmonicsIntensity = 1, 
            this._reflectionDecodeFormat = t.TextureDecodeFormat.Normal, this._reflectionIntensity = 1, 
            this._collsionTestList = [], this._renders = new pe(), this._opaqueQueue = new jt(!1), 
            this._transparentQueue = new jt(!0), this._cameraPool = [], this._animatorPool = new pe(), 
            this._scriptPool = new Array(), this._tempScriptPool = new Array(), this._needClearScriptPool = !1, 
            this._reflectionCubeHDRParams = new a(), this.currentCreationLayer = Math.pow(2, 0), 
            this.enableLight = !0, this._key = new t.SubmitKey(), this._pickIdToSprite = new Object(), 
            this._reflectionMode = 0, v._enablePhysics && (this._physicsSimulation = new xt(tr.physicsSettings)), 
            this._shaderValues = new W(null), this.enableFog = !1, this.fogStart = 300, this.fogRange = 1e3, 
            this.fogColor = new n(.7, .7, .7), this.ambientColor = new n(.212, .227, .259), 
            this.reflectionIntensity = 1, this.reflection = Dt.blackTexture;
            for (var r = 0; r < 7; r++) this._shCoefficients[r] = new a();
            if (this._shaderValues.setVector(tr.REFLECTIONCUBE_HDR_PARAMS, this._reflectionCubeHDRParams), 
            t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices = new Int32Array(1024), 
            this._cullingBufferResult = new Int32Array(1024)), this._scene = this, this._input.__init__(t.Render.canvas, this), 
            tr.octreeCulling && (this._octree = new Qt(tr.octreeInitialSize, tr.octreeInitialCenter, tr.octreeMinNodeSize, tr.octreeLooseness)), 
            Ce.debugFrustumCulling) {
                this._debugTool = new Yt();
                var i = new Nt();
                i.renderQueue = Z.RENDERQUEUE_TRANSPARENT, i.alphaTest = !1, i.depthWrite = !1, 
                i.cull = Q.CULL_BACK, i.blend = Q.BLEND_ENABLE_ALL, i.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                i.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, i.depthTest = Q.DEPTHTEST_LESS, this._debugTool.pixelLineRenderer.sharedMaterial = i;
            }
        }
        static __init__() {
            var r = l._config;
            if (r._multiLighting) {
                const e = 4;
                var i = r.maxLightCount, a = r.lightClusterCount;
                Me.instance = new Me(a.x, a.y, a.z, Math.min(r.maxLightCount, r._maxAreaLightCountPerClusterAverage)), 
                tr._lightTexture = I._createFloatTextureBuffer(e, i), tr._lightTexture.lock = !0, 
                tr._lightPixles = new Float32Array(i * e * 4);
            }
            at.SHADERDEFINE_FOG = H.getDefineByName("FOG"), at.SHADERDEFINE_DIRECTIONLIGHT = H.getDefineByName("DIRECTIONLIGHT"), 
            at.SHADERDEFINE_POINTLIGHT = H.getDefineByName("POINTLIGHT"), at.SHADERDEFINE_SPOTLIGHT = H.getDefineByName("SPOTLIGHT"), 
            at.SHADERDEFINE_SHADOW = H.getDefineByName("SHADOW"), at.SHADERDEFINE_SHADOW_CASCADE = H.getDefineByName("SHADOW_CASCADE"), 
            at.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = H.getDefineByName("SHADOW_SOFT_SHADOW_LOW"), 
            at.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = H.getDefineByName("SHADOW_SOFT_SHADOW_HIGH"), 
            at.SHADERDEFINE_GI_AMBIENT_SH = H.getDefineByName("GI_AMBIENT_SH");
            var n = l._config, s = tr._configDefineValues;
            switch (n._multiLighting || s.add(H.SHADERDEFINE_LEGACYSINGALLIGHTING), t.LayaGL.layaGPUInstance._isWebGL2 ? s.add(H.SHADERDEFINE_GRAPHICS_API_GLES3) : s.add(H.SHADERDEFINE_GRAPHICS_API_GLES2), 
            n.pbrRenderQuality) {
              case e.PBRRenderQuality.High:
                s.add(ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
                break;

              case e.PBRRenderQuality.Low:
                s.add(ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
                break;

              default:
                throw "Scene3D:unknown shader quality.";
            }
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, tr.HIERARCHY);
        }
        get url() {
            return this._url;
        }
        get enableFog() {
            return this._enableFog;
        }
        set enableFog(e) {
            this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(at.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(at.SHADERDEFINE_FOG));
        }
        get fogColor() {
            return this._shaderValues.getVector3(tr.FOGCOLOR);
        }
        set fogColor(e) {
            this._shaderValues.setVector3(tr.FOGCOLOR, e);
        }
        get fogStart() {
            return this._shaderValues.getNumber(tr.FOGSTART);
        }
        set fogStart(e) {
            this._shaderValues.setNumber(tr.FOGSTART, e);
        }
        get fogRange() {
            return this._shaderValues.getNumber(tr.FOGRANGE);
        }
        set fogRange(e) {
            this._shaderValues.setNumber(tr.FOGRANGE, e);
        }
        get ambientMode() {
            return this._ambientMode;
        }
        set ambientMode(t) {
            if (this._ambientMode !== t) {
                switch (t) {
                  case e.AmbientMode.SolidColor:
                    this._shaderValues.removeDefine(at.SHADERDEFINE_GI_AMBIENT_SH);
                    break;

                  case e.AmbientMode.SphericalHarmonics:
                    this._shaderValues.addDefine(at.SHADERDEFINE_GI_AMBIENT_SH);
                    break;

                  default:
                    throw "Scene3D: unknown ambientMode.";
                }
                this._ambientMode = t;
            }
        }
        get ambientColor() {
            return this._shaderValues.getVector3(tr.AMBIENTCOLOR);
        }
        set ambientColor(e) {
            this._shaderValues.setVector3(tr.AMBIENTCOLOR, e);
        }
        get ambientSphericalHarmonics() {
            return this._ambientSphericalHarmonics;
        }
        set ambientSphericalHarmonics(e) {
            var t = e || ye._default;
            this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity, 2.2)), 
            this._ambientSphericalHarmonics != e && e.cloneTo(this._ambientSphericalHarmonics);
        }
        get ambientSphericalHarmonicsIntensity() {
            return this._ambientSphericalHarmonicsIntensity;
        }
        set ambientSphericalHarmonicsIntensity(e) {
            if (e = Math.max(Math.min(e, 8), 0), this._ambientSphericalHarmonicsIntensity !== e) {
                var t = this._ambientSphericalHarmonics || ye._default;
                this._applySHCoefficients(t, Math.pow(e, 2.2)), this._ambientSphericalHarmonicsIntensity = e;
            }
        }
        get reflection() {
            return this._reflection;
        }
        set reflection(e) {
            this._reflection != e && (this._shaderValues.setTexture(tr.REFLECTIONTEXTURE, e || Dt.blackTexture), 
            this._reflection = e);
        }
        get reflectionDecodingFormat() {
            return this._reflectionDecodeFormat;
        }
        set reflectionDecodingFormat(e) {
            this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this._reflectionIntensity, 
            this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5), 
            this._reflectionDecodeFormat = e);
        }
        get reflectionIntensity() {
            return this._reflectionIntensity;
        }
        set reflectionIntensity(e) {
            e = Math.max(Math.min(e, 1), 0), this._reflectionCubeHDRParams.x = e, this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5), 
            this._reflectionIntensity = e;
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get physicsSimulation() {
            return this._physicsSimulation;
        }
        get timer() {
            return this._timer;
        }
        set timer(e) {
            this._timer = e;
        }
        get input() {
            return this._input;
        }
        get lightmaps() {
            return this._lightmaps.slice();
        }
        set lightmaps(e) {
            var t = this._lightmaps;
            if (t) for (var r = 0, i = t.length; r < i; r++) {
                (n = t[r]).lightmapColor._removeReference(), n.lightmapDirection._removeReference();
            }
            if (e) {
                var a = e.length;
                for (t.length = a, r = 0; r < a; r++) {
                    var n;
                    (n = e[r]).lightmapColor && n.lightmapColor._addReference(), n.lightmapDirection && n.lightmapDirection._addReference(), 
                    t[r] = n;
                }
            } else t.length = 0;
        }
        _applySHCoefficients(e, t) {
            for (var r = this._shCoefficients, i = 0; i < 3; i++) {
                var a = r[i], n = r[i + 3];
                a.setValue(e.getCoefficient(i, 3) * t, e.getCoefficient(i, 1) * t, e.getCoefficient(i, 2) * t, (e.getCoefficient(i, 0) - e.getCoefficient(i, 6)) * t), 
                n.setValue(e.getCoefficient(i, 4) * t, e.getCoefficient(i, 5) * t, 3 * e.getCoefficient(i, 6) * t, e.getCoefficient(i, 7) * t);
            }
            r[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e.getCoefficient(2, 8) * t, 1);
            var s = this._shaderValues;
            s.setVector(tr.AMBIENTSHAR, r[0]), s.setVector(tr.AMBIENTSHAG, r[1]), s.setVector(tr.AMBIENTSHAB, r[2]), 
            s.setVector(tr.AMBIENTSHBR, r[3]), s.setVector(tr.AMBIENTSHBG, r[4]), s.setVector(tr.AMBIENTSHBB, r[5]), 
            s.setVector(tr.AMBIENTSHC, r[6]);
        }
        _update() {
            var e = this.timer._delta / 1e3;
            this._time += e, this._shaderValues.setNumber(tr.TIME, this._time);
            var t = this._physicsSimulation;
            v._enablePhysics && !xt.disableSimulation && (t._updatePhysicsTransformFromRender(), 
            vt._addUpdateList = !1, t._simulate(e), t._updateCharacters(), vt._addUpdateList = !0, 
            t._updateCollisions(), t._eventScripts()), this._input._update(), this._clearScript(), 
            this._updateScript(), P._update(this), this._lateUpdateScript();
        }
        _binarySearchIndexInCameraPool(e) {
            for (var t, r = 0, i = this._cameraPool.length - 1; r <= i; ) {
                t = Math.floor((r + i) / 2);
                var a = this._cameraPool[t]._renderingOrder;
                if (a == e._renderingOrder) return t;
                a > e._renderingOrder ? i = t - 1 : r = t + 1;
            }
            return r;
        }
        _allotPickColorByID(e, t) {
            var r = Math.floor(e / 65025);
            e -= 255 * r * 255;
            var i = Math.floor(e / 255), a = e -= 255 * i;
            t.x = r / 255, t.y = i / 255, t.z = a / 255, t.w = 1;
        }
        _searchIDByPickColor(e) {
            return 255 * e.x * 255 + 255 * e.y + e.z;
        }
        onEnable() {
            this._input._onCanvasEvent(t.Render.canvas);
        }
        onDisable() {
            this._input._offCanvasEvent(t.Render.canvas);
        }
        _setCreateURL(e) {
            this._url = t.URL.formatURL(e);
        }
        _getGroup() {
            return this._group;
        }
        _setGroup(e) {
            this._group = e;
        }
        _clearScript() {
            if (this._needClearScriptPool) {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && (i._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(i));
                }
                this._scriptPool = this._tempScriptPool, e.length = 0, this._tempScriptPool = e, 
                this._needClearScriptPool = !1;
            }
        }
        _updateScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onUpdate();
            }
        }
        _lateUpdateScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onLateUpdate();
            }
        }
        _onActive() {
            super._onActive(), t.ILaya.stage._scene3Ds.push(this);
        }
        _onInActive() {
            super._onInActive();
            var e = t.ILaya.stage._scene3Ds;
            e.splice(e.indexOf(this), 1);
        }
        _prepareSceneToRender() {
            var e = this._shaderValues;
            if (l._config._multiLighting) {
                var t = tr._lightTexture, r = tr._lightPixles;
                const l = t.width, R = 4 * l;
                var i = 0, a = this._directionLights._length, s = this._directionLights._elements;
                if (a > 0) {
                    var o = this._directionLights.getSunLight();
                    this._mainLight = s[o];
                    for (var _ = 0; _ < a; _++, i++) {
                        var h = (g = s[_])._direction, c = g._intensityColor, d = R * i;
                        n.scale(g.color, g._intensity, c), g.transform.worldMatrix.getForward(h), n.normalize(h, h), 
                        r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 4] = h.x, r[d + 5] = h.y, r[d + 6] = h.z, 
                        _ == o && (e.setVector3(tr.SUNLIGHTDIRCOLOR, c), e.setVector3(tr.SUNLIGHTDIRECTION, h));
                    }
                    e.addDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                var u = this._pointLights._length;
                if (u > 0) {
                    var m = this._pointLights._elements;
                    for (_ = 0; _ < u; _++, i++) {
                        var f = (S = m[_]).transform.position;
                        c = S._intensityColor, d = R * i;
                        n.scale(S.color, S._intensity, c), r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 3] = S.range, 
                        r[d + 4] = f.x, r[d + 5] = f.y, r[d + 6] = f.z;
                    }
                    e.addDefine(at.SHADERDEFINE_POINTLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_POINTLIGHT);
                var E = this._spotLights._length;
                if (E > 0) {
                    var T = this._spotLights._elements;
                    for (_ = 0; _ < E; _++, i++) {
                        var p = T[_];
                        h = p._direction, f = p.transform.position, c = p._intensityColor, d = R * i;
                        n.scale(p.color, p._intensity, c), p.transform.worldMatrix.getForward(h), n.normalize(h, h), 
                        r[d] = c.x, r[d + 1] = c.y, r[d + 2] = c.z, r[d + 3] = p.range, r[d + 4] = f.x, 
                        r[d + 5] = f.y, r[d + 6] = f.z, r[d + 7] = p.spotAngle * Math.PI / 180, r[d + 8] = h.x, 
                        r[d + 9] = h.y, r[d + 10] = h.z;
                    }
                    e.addDefine(at.SHADERDEFINE_SPOTLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_SPOTLIGHT);
                i > 0 && t.setSubPixels(0, 0, l, i, r, 0), e.setTexture(tr.LIGHTBUFFER, t), e.setInt(tr.DIRECTIONLIGHTCOUNT, this._directionLights._length), 
                e.setTexture(tr.CLUSTERBUFFER, Me.instance._clusterTexture);
            } else {
                if (this._directionLights._length > 0) {
                    var g = this._directionLights._elements[0];
                    this._mainLight = g, n.scale(g.color, g._intensity, g._intensityColor), g.transform.worldMatrix.getForward(g._direction), 
                    n.normalize(g._direction, g._direction), e.setVector3(tr.LIGHTDIRCOLOR, g._intensityColor), 
                    e.setVector3(tr.LIGHTDIRECTION, g._direction), e.setVector3(tr.SUNLIGHTDIRCOLOR, g._intensityColor), 
                    e.setVector3(tr.SUNLIGHTDIRECTION, g._direction), e.addDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_DIRECTIONLIGHT);
                if (this._pointLights._length > 0) {
                    var S = this._pointLights._elements[0];
                    n.scale(S.color, S._intensity, S._intensityColor), e.setVector3(tr.POINTLIGHTCOLOR, S._intensityColor), 
                    e.setVector3(tr.POINTLIGHTPOS, S.transform.position), e.setNumber(tr.POINTLIGHTRANGE, S.range), 
                    e.addDefine(at.SHADERDEFINE_POINTLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_POINTLIGHT);
                if (this._spotLights._length > 0) {
                    var R = this._spotLights._elements[0];
                    n.scale(R.color, R._intensity, R._intensityColor), e.setVector3(tr.SPOTLIGHTCOLOR, R._intensityColor), 
                    e.setVector3(tr.SPOTLIGHTPOS, R.transform.position), R.transform.worldMatrix.getForward(R._direction), 
                    n.normalize(R._direction, R._direction), e.setVector3(tr.SPOTLIGHTDIRECTION, R._direction), 
                    e.setNumber(tr.SPOTLIGHTRANGE, R.range), e.setNumber(tr.SPOTLIGHTSPOTANGLE, R.spotAngle * Math.PI / 180), 
                    e.addDefine(at.SHADERDEFINE_SPOTLIGHT);
                } else e.removeDefine(at.SHADERDEFINE_SPOTLIGHT);
            }
        }
        _addScript(e) {
            var t = this._scriptPool;
            e._indexInPool = t.length, t.push(e);
        }
        _removeScript(e) {
            this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this._needClearScriptPool = !0;
        }
        _preRenderScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onPreRender();
            }
        }
        _postRenderScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onPostRender();
            }
        }
        _addCamera(e) {
            for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, i = this._cameraPool.length; t < i && this._cameraPool[t]._renderingOrder <= r; ) t++;
            this._cameraPool.splice(t, 0, e);
        }
        _removeCamera(e) {
            this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
        }
        _preCulling(e, t, r, i) {
            var a = Ce._cameraCullInfo;
            a.position = t._transform.position, a.cullingMask = t.cullingMask, a.boundFrustum = t.boundFrustum, 
            a.useOcclusionCulling = t.useOcclusionCulling, Ce.renderObjectCulling(a, this, e, r, i, !1);
        }
        _clear(r, i) {
            var a, n, s, o = i.viewport, l = i.camera, _ = l._getRenderTexture(), h = o.width, c = o.height;
            l._needInternalRenderTexture() ? (a = 0, n = 0) : (a = o.x, n = l._getCanvasHeight() - o.y - c), 
            r.viewport(a, n, h, c);
            var d = l.clearFlag;
            switch (d !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (d = e.CameraClearFlags.SolidColor), 
            d) {
              case e.CameraClearFlags.SolidColor:
                var u = l.clearColor;
                if (r.enable(r.SCISSOR_TEST), r.scissor(a, n, h, c), u ? r.clearColor(u.x, u.y, u.z, u.w) : r.clearColor(0, 0, 0, 0), 
                _) switch (s = r.COLOR_BUFFER_BIT, _.depthStencilFormat) {
                  case t.RenderTextureDepthFormat.DEPTH_16:
                    s |= r.DEPTH_BUFFER_BIT;
                    break;

                  case t.RenderTextureDepthFormat.STENCIL_8:
                    s |= r.STENCIL_BUFFER_BIT;
                    break;

                  case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                    s |= r.DEPTH_BUFFER_BIT, s |= r.STENCIL_BUFFER_BIT;
                } else s = r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT;
                t.WebGLContext.setDepthMask(r, !0), r.clear(s), r.disable(r.SCISSOR_TEST);
                break;

              case e.CameraClearFlags.Sky:
              case e.CameraClearFlags.DepthOnly:
                if (r.enable(r.SCISSOR_TEST), r.scissor(a, n, h, c), _) switch (_.depthStencilFormat) {
                  case t.RenderTextureDepthFormat.DEPTH_16:
                    s = r.DEPTH_BUFFER_BIT;
                    break;

                  case t.RenderTextureDepthFormat.STENCIL_8:
                    s = r.STENCIL_BUFFER_BIT;
                    break;

                  case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                    s = r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT;
                } else s = r.DEPTH_BUFFER_BIT;
                t.WebGLContext.setDepthMask(r, !0), r.clear(s), r.disable(r.SCISSOR_TEST);
                break;

              case e.CameraClearFlags.Nothing:
                break;

              default:
                throw new Error("Scene3D:camera clearFlag invalid.");
            }
        }
        _renderScene(t) {
            var r = t.camera;
            if (this._opaqueQueue._render(t), r.clearFlag === e.CameraClearFlags.Sky && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)), 
            this._transparentQueue._render(t), Ce.debugFrustumCulling) for (var i = this._debugTool._render._renderElements, a = 0, n = i.length; a < n; a++) i[a]._update(this, t, null, null), 
            i[a]._render(t);
        }
        _parse(e, r) {
            var i = e.lightmaps;
            if (i) {
                for (var a = i.length, n = new Array(a), s = 0; s < a; s++) {
                    var o = new Kt(), l = i[s];
                    l.path ? o.lightmapColor = t.Loader.getRes(l.path) : (o.lightmapColor = t.Loader.getRes(l.color.path), 
                    l.direction && (o.lightmapDirection = t.Loader.getRes(l.direction.path))), n[s] = o;
                }
                this.lightmaps = n;
            }
            var _ = e.ambientColor;
            if (_) {
                var h = this.ambientColor;
                h.fromArray(_), this.ambientColor = h;
            }
            var c = e.sky;
            if (c) switch (this._skyRenderer.material = t.Loader.getRes(c.material.path), c.mesh) {
              case "SkyBox":
                this._skyRenderer.mesh = Ze.instance;
                break;

              case "SkyDome":
                this._skyRenderer.mesh = Ct.instance;
                break;

              default:
                this.skyRenderer.mesh = Ze.instance;
            }
            this.enableFog = e.enableFog, this.fogStart = e.fogStart, this.fogRange = e.fogRange;
            var d = e.fogColor;
            if (d) {
                var u = this.fogColor;
                u.fromArray(d), this.fogColor = u;
            }
            var m = e.ambientSphericalHarmonics;
            if (m) {
                var f = this.ambientSphericalHarmonics;
                for (s = 0; s < 3; s++) {
                    var E = 9 * s;
                    f.setCoefficients(s, m[E], m[E + 1], m[E + 2], m[E + 3], m[E + 4], m[E + 5], m[E + 6], m[E + 7], m[E + 8]);
                }
                this.ambientSphericalHarmonics = f;
            }
            var T = e.reflection;
            null != T && (this.reflection = t.Loader.getRes(T));
            var p = e.reflectionDecodingFormat;
            null != p && (this.reflectionDecodingFormat = p);
            var g = e.ambientMode;
            null != g && (this.ambientMode = g);
            var S = e.ambientSphericalHarmonicsIntensity;
            null != S && (this.ambientSphericalHarmonicsIntensity = S);
            var R = e.reflectionIntensity;
            null != R && (this.reflectionIntensity = R);
        }
        _addRenderObject(e) {
            if (this._octree && e._supportOctree) this._octree.add(e); else if (this._renders.add(e), 
            t.Render.supportWebGLPlusCulling) {
                var r = e._getIndexInList(), i = this._cullingBufferIndices.length;
                if (r >= i) {
                    var a = this._cullingBufferIndices, n = this._cullingBufferResult;
                    this._cullingBufferIndices = new Int32Array(i + 1024), this._cullingBufferResult = new Int32Array(i + 1024), 
                    this._cullingBufferIndices.set(a, 0), this._cullingBufferResult.set(n, 0);
                }
                this._cullingBufferIndices[r] = e._cullingBufferIndex;
            }
        }
        _removeRenderObject(e) {
            var r;
            this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (r = this._renders.elements[this._renders.length - 1]), 
            this._renders.remove(e), t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[r._getIndexInList()] = r._cullingBufferIndex));
        }
        _getRenderQueue(e) {
            return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._skyRenderer.destroy(), this._skyRenderer = null, 
            this._directionLights = null, this._pointLights = null, this._spotLights = null, 
            this._alternateLights = null, this._lightmaps = null, this._shaderValues = null, 
            this._renders = null, this._cameraPool = null, this._octree = null, this._physicsSimulation && this._physicsSimulation._destroy(), 
            t.Loader.clearRes(this.url));
        }
        render(e, r, i) {
            e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
        }
        renderSubmit() {
            var e, r, i;
            t.LayaGL.instance;
            for (this._prepareSceneToRender(), e = 0, i = (r = this._cameraPool.length) - 1; e < r; e++) {
                t.Render.supportWebGLPlusRendering && W.setRuntimeValueMode(e == i);
                var a = this._cameraPool[e];
                a.enableRender && a.render();
            }
            return t.Context.set2DRenderConfig(), 1;
        }
        getRenderType() {
            return 0;
        }
        releaseRender() {}
        reUse(e, t) {
            return 0;
        }
        get customReflection() {
            return this._reflection;
        }
        set customReflection(e) {
            this._reflection != e && (this._shaderValues.setTexture(tr.REFLECTIONTEXTURE, e || Dt.blackTexture), 
            this._reflection = e);
        }
        get reflectionMode() {
            return this._reflectionMode;
        }
        set reflectionMode(e) {
            this._reflectionMode = e;
        }
        setlightmaps(e) {
            for (var t = this._lightmaps, r = 0, i = t.length; r < i; r++) t[r].lightmapColor._removeReference();
            if (!e) throw new Error("Scene3D: value value can't be null.");
            var a = e.length;
            for (t.length = a, r = 0; r < a; r++) {
                var n = e[r];
                n._addReference(), t[r] || (t[r] = new Kt()), t[r].lightmapColor = n;
            }
        }
        getlightmaps() {
            for (var e = new Array(this._lightmaps.length), t = 0; t < this._lightmaps.length; t++) e[t] = this._lightmaps[t].lightmapColor;
            return e;
        }
    }
    tr._shadowCasterPass = new er(), tr.HIERARCHY = "HIERARCHY", tr.physicsSettings = new At(), 
    tr.octreeCulling = !1, tr.octreeInitialSize = 64, tr.octreeInitialCenter = new n(0, 0, 0), 
    tr.octreeMinNodeSize = 2, tr.octreeLooseness = 1.25, tr.REFLECTIONMODE_SKYBOX = 0, 
    tr.REFLECTIONMODE_CUSTOM = 1, tr.FOGCOLOR = H.propertyNameToID("u_FogColor"), tr.FOGSTART = H.propertyNameToID("u_FogStart"), 
    tr.FOGRANGE = H.propertyNameToID("u_FogRange"), tr.DIRECTIONLIGHTCOUNT = H.propertyNameToID("u_DirationLightCount"), 
    tr.LIGHTBUFFER = H.propertyNameToID("u_LightBuffer"), tr.CLUSTERBUFFER = H.propertyNameToID("u_LightClusterBuffer"), 
    tr.SUNLIGHTDIRECTION = H.propertyNameToID("u_SunLight.direction"), tr.SUNLIGHTDIRCOLOR = H.propertyNameToID("u_SunLight.color"), 
    tr.AMBIENTSHAR = H.propertyNameToID("u_AmbientSHAr"), tr.AMBIENTSHAG = H.propertyNameToID("u_AmbientSHAg"), 
    tr.AMBIENTSHAB = H.propertyNameToID("u_AmbientSHAb"), tr.AMBIENTSHBR = H.propertyNameToID("u_AmbientSHBr"), 
    tr.AMBIENTSHBG = H.propertyNameToID("u_AmbientSHBg"), tr.AMBIENTSHBB = H.propertyNameToID("u_AmbientSHBb"), 
    tr.AMBIENTSHC = H.propertyNameToID("u_AmbientSHC"), tr.REFLECTIONPROBE = H.propertyNameToID("u_ReflectionProbe"), 
    tr.REFLECTIONCUBE_HDR_PARAMS = H.propertyNameToID("u_ReflectCubeHDRParams"), tr.LIGHTDIRECTION = H.propertyNameToID("u_DirectionLight.direction"), 
    tr.LIGHTDIRCOLOR = H.propertyNameToID("u_DirectionLight.color"), tr.POINTLIGHTPOS = H.propertyNameToID("u_PointLight.position"), 
    tr.POINTLIGHTRANGE = H.propertyNameToID("u_PointLight.range"), tr.POINTLIGHTATTENUATION = H.propertyNameToID("u_PointLight.attenuation"), 
    tr.POINTLIGHTCOLOR = H.propertyNameToID("u_PointLight.color"), tr.SPOTLIGHTPOS = H.propertyNameToID("u_SpotLight.position"), 
    tr.SPOTLIGHTDIRECTION = H.propertyNameToID("u_SpotLight.direction"), tr.SPOTLIGHTSPOTANGLE = H.propertyNameToID("u_SpotLight.spot"), 
    tr.SPOTLIGHTRANGE = H.propertyNameToID("u_SpotLight.range"), tr.SPOTLIGHTCOLOR = H.propertyNameToID("u_SpotLight.color"), 
    tr.AMBIENTCOLOR = H.propertyNameToID("u_AmbientColor"), tr.REFLECTIONTEXTURE = H.propertyNameToID("u_ReflectTexture"), 
    tr.TIME = H.propertyNameToID("u_Time"), tr._configDefineValues = new F();
    class rr extends t.ShaderCompile {
        constructor(e, t, r, i) {
            for (var a in super(t, r, null), this._cacheSharders = {}, this._cacheShaderHierarchy = 1, 
            this._renderState = new Q(), this._validDefine = new F(), this._tags = {}, this._owner = e, 
            this._stateMap = i, this.defs) this._validDefine.add(H.getDefineByName(a));
        }
        get renderState() {
            return this._renderState;
        }
        _compileToTree(e, r, i, a, n) {
            var s, o, l, _, h, c, d, u, m, f, E;
            for (m = i; m < r.length; m++) if (!((l = r[m]).length < 1) && 0 !== (c = l.indexOf("//"))) {
                if (c >= 0 && (l = l.substr(0, c)), s = u || new t.ShaderNode(a), u = null, s.text = l, 
                (c = l.indexOf("#")) >= 0) {
                    for (_ = "#", E = c + 1, f = l.length; E < f; E++) {
                        var T = l.charAt(E);
                        if (" " === T || "\t" === T || "?" === T) break;
                        _ += T;
                    }
                    switch (s.name = _, _) {
                      case "#ifdef":
                      case "#ifndef":
                        if (s.setParent(e), e = s, n) for (d = l.substr(E).split(t.ShaderCompile._splitToWordExps3), 
                        E = 0; E < d.length; E++) (l = d[E]).length && (n[l] = !0);
                        continue;

                      case "#if":
                      case "#elif":
                        if (s.setParent(e), e = s, n) for (d = l.substr(E).split(t.ShaderCompile._splitToWordExps3), 
                        E = 0; E < d.length; E++) (l = d[E]).length && "defined" != l && (n[l] = !0);
                        continue;

                      case "#else":
                        o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e), e = s;
                        continue;

                      case "#endif":
                        o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e);
                        continue;

                      case "#include":
                        d = t.ShaderCompile.splitToWords(l, null);
                        var p = t.ShaderCompile.includes[d[1]];
                        if (!p) throw "ShaderCompile error no this include file:" + d[1];
                        if ((c = d[0].indexOf("?")) < 0) {
                            s.setParent(e), l = p.getWith("with" == d[2] ? d[3] : null), this._compileToTree(s, l.split("\n"), 0, a, n), 
                            s.text = "";
                            continue;
                        }
                        s.setCondition(d[0].substr(c + 1), t.ShaderCompile.IFDEF_YES), s.text = p.getWith("with" == d[2] ? d[3] : null);
                        break;

                      case "#import":
                        h = (d = t.ShaderCompile.splitToWords(l, null))[1], a.push({
                            node: s,
                            file: t.ShaderCompile.includes[h],
                            ofs: s.text.length
                        });
                        continue;
                    }
                } else {
                    if ((o = e.childs[e.childs.length - 1]) && !o.name) {
                        a.length > 0 && t.ShaderCompile.splitToWords(l, o), u = s, o.text += "\n" + l;
                        continue;
                    }
                    a.length > 0 && t.ShaderCompile.splitToWords(l, s);
                }
                s.setParent(e);
            }
        }
        _resizeCacheShaderMap(e, t, r) {
            var i = this._cacheShaderHierarchy - 1;
            if (t == i) {
                for (var a in e) for (var n = e[a], s = 0, o = r - i; s < o; s++) s == o - 1 ? e[0] = n : e = e[0 == s ? a : 0] = {};
                this._cacheShaderHierarchy = r;
            } else for (var a in e) this._resizeCacheShaderMap(e[a], ++t, r);
        }
        _addDebugShaderVariantCollection(e, t, r) {
            var i = H._debugShaderVariantInfo, a = this._owner, n = a._owner, s = e._mask;
            H._getNamesByDefineData(e, t), r.length = s.length;
            for (var o = 0, l = s.length; o < l; o++) r[o] = s[o];
            i ? i.setValue(n, n._subShaders.indexOf(a), a._passes.indexOf(this), t) : H._debugShaderVariantInfo = i = new G(n, n._subShaders.indexOf(a), a._passes.indexOf(this), t), 
            H.debugShaderVariantCollection.add(i);
        }
        withCompile(e) {
            var r, i = rr._debugDefineString, a = rr._debugDefineMask;
            e._intersectionDefineDatas(this._validDefine), H.debugMode && (r = e._length, this._addDebugShaderVariantCollection(e, i, a)), 
            e.addDefineDatas(tr._configDefineValues);
            var n = this._cacheSharders, s = e._length;
            s > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(n, 0, s), this._cacheShaderHierarchy = s);
            for (var o = e._mask, _ = e._length - 1, h = this._cacheShaderHierarchy - 1, c = 0; c < h; c++) {
                var d = _ < c ? 0 : o[c], u = n[d];
                u || (n[d] = u = {}), n = u;
            }
            var m = _ < h ? 0 : o[h], f = n[m];
            if (f) return f;
            var E = rr._defineString;
            H._getNamesByDefineData(e, E);
            var T, p, g = l._config, S = g.lightClusterCount, R = {}, v = "";
            t.WebGL._isWebGL2 ? (T = "#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n", 
            p = "#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n") : (T = "", 
            p = "#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"), 
            v += "#define MAX_LIGHT_COUNT " + g.maxLightCount + "\n", v += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + g._maxAreaLightCountPerClusterAverage + "\n", 
            v += "#define CLUSTER_X_COUNT " + S.x + "\n", v += "#define CLUSTER_Y_COUNT " + S.y + "\n", 
            v += "#define CLUSTER_Z_COUNT " + S.z + "\n", v += "#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel + "\n";
            c = 0;
            for (var x = E.length; c < x; c++) {
                var I = E[c];
                v += "#define " + I + "\n", R[I] = !0;
            }
            var A = this._VS.toscript(R, []), L = "";
            0 == A[0].indexOf("#version") && (L = A[0] + "\n", A.shift());
            var C = this._PS.toscript(R, []), D = "";
            if (0 == C[0].indexOf("#version") && (D = C[0] + "\n", C.shift()), f = new Ee(L + T + v + A.join("\n"), D + p + v + C.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this), 
            n[m] = f, H.debugMode) {
                var M = "", y = "";
                for (c = 0, x = r; c < x; c++) y += c == x - 1 ? a[c] : a[c] + ",";
                for (c = 0, x = i.length; c < x; c++) M += c == x - 1 ? i[c] : i[c] + ",";
                console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + y + "] DefineNames:[" + M + "]", "color:green");
            }
            return f;
        }
        setTag(e, t) {
            t ? this._tags[e] = t : delete this._tags[e];
        }
        getTag(e) {
            return this._tags[e];
        }
    }
    rr._defineString = [], rr._debugDefineString = [], rr._debugDefineMask = [];
    class ir {
        constructor(e, t) {
            this._flags = {}, this._passes = [], this._attributeMap = e, this._uniformMap = t;
        }
        setFlag(e, t) {
            t ? this._flags[e] = t : delete this._flags[e];
        }
        getFlag(e) {
            return this._flags[e];
        }
        addShaderPass(e, t, r = null, i = "Forward") {
            var a = new rr(this, e, t, r);
            return a._pipelineMode = i, this._passes.push(a), a;
        }
    }
    (he = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[he.SpecularTextureAlpha = 0] = "SpecularTextureAlpha", 
    he[he.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    class ar extends ee {
        constructor() {
            super(), this.setShaderName("PBRSpecular"), this._shaderValues.setVector(ar.SPECULARCOLOR, new a(.2, .2, .2, 1));
        }
        static __init__() {
            ar.SHADERDEFINE_SPECULARGLOSSTEXTURE = H.getDefineByName("SPECULARGLOSSTEXTURE"), 
            ar.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = H.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
            var e = {
                a_Position: Xe.MESH_POSITION0,
                a_Normal: Xe.MESH_NORMAL0,
                a_Tangent0: Xe.MESH_TANGENT0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0,
                a_Texcoord1: Xe.MESH_TEXTURECOORDINATE1,
                a_BoneWeights: Xe.MESH_BLENDWEIGHT0,
                a_BoneIndices: Xe.MESH_BLENDINDICES0,
                a_MvpMatrix: Xe.MESH_MVPMATRIX_ROW0,
                a_WorldMat: Xe.MESH_WORLDMATRIX_ROW0
            }, t = {
                u_Bones: H.PERIOD_CUSTOM,
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_WorldMat: H.PERIOD_SPRITE,
                u_LightmapScaleOffset: H.PERIOD_SPRITE,
                u_LightMap: H.PERIOD_SPRITE,
                u_LightMapDirection: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_View: H.PERIOD_CAMERA,
                u_ProjectionParams: H.PERIOD_CAMERA,
                u_Viewport: H.PERIOD_CAMERA,
                u_ViewProjection: H.PERIOD_CAMERA,
                u_AlphaTestValue: H.PERIOD_MATERIAL,
                u_AlbedoColor: H.PERIOD_MATERIAL,
                u_EmissionColor: H.PERIOD_MATERIAL,
                u_AlbedoTexture: H.PERIOD_MATERIAL,
                u_NormalTexture: H.PERIOD_MATERIAL,
                u_ParallaxTexture: H.PERIOD_MATERIAL,
                u_OcclusionTexture: H.PERIOD_MATERIAL,
                u_EmissionTexture: H.PERIOD_MATERIAL,
                u_Smoothness: H.PERIOD_MATERIAL,
                u_SmoothnessScale: H.PERIOD_MATERIAL,
                u_occlusionStrength: H.PERIOD_MATERIAL,
                u_NormalScale: H.PERIOD_MATERIAL,
                u_ParallaxScale: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_SpecGlossTexture: H.PERIOD_MATERIAL,
                u_SpecularColor: H.PERIOD_MATERIAL,
                u_ReflectTexture: H.PERIOD_SCENE,
                u_ReflectIntensity: H.PERIOD_SCENE,
                u_AmbientColor: H.PERIOD_SCENE,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE,
                u_DirationLightCount: H.PERIOD_SCENE,
                u_LightBuffer: H.PERIOD_SCENE,
                u_LightClusterBuffer: H.PERIOD_SCENE,
                u_ShadowBias: H.PERIOD_SCENE,
                u_ShadowLightDirection: H.PERIOD_SCENE,
                u_ShadowMap: H.PERIOD_SCENE,
                u_ShadowParams: H.PERIOD_SCENE,
                u_ShadowSplitSpheres: H.PERIOD_SCENE,
                u_ShadowMatrices: H.PERIOD_SCENE,
                u_ShadowMapSize: H.PERIOD_SCENE,
                u_AmbientSHAr: H.PERIOD_SCENE,
                u_AmbientSHAg: H.PERIOD_SCENE,
                u_AmbientSHAb: H.PERIOD_SCENE,
                u_AmbientSHBr: H.PERIOD_SCENE,
                u_AmbientSHBg: H.PERIOD_SCENE,
                u_AmbientSHBb: H.PERIOD_SCENE,
                u_AmbientSHC: H.PERIOD_SCENE,
                u_ReflectionProbe: H.PERIOD_SCENE,
                u_ReflectCubeHDRParams: H.PERIOD_SCENE,
                "u_DirectionLight.direction": H.PERIOD_SCENE,
                "u_DirectionLight.color": H.PERIOD_SCENE,
                "u_PointLight.position": H.PERIOD_SCENE,
                "u_PointLight.range": H.PERIOD_SCENE,
                "u_PointLight.color": H.PERIOD_SCENE,
                "u_SpotLight.position": H.PERIOD_SCENE,
                "u_SpotLight.direction": H.PERIOD_SCENE,
                "u_SpotLight.range": H.PERIOD_SCENE,
                "u_SpotLight.spot": H.PERIOD_SCENE,
                "u_SpotLight.color": H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("PBRSpecular"), a = new ir(e, t);
            i.addSubShader(a), a.addShaderPass(de, ce, r, "Forward"), a.addShaderPass(me, ue, r, "ShadowCaster");
        }
        get specularTexture() {
            return this._shaderValues.getTexture(ar.SPECULARTEXTURE);
        }
        set specularTexture(e) {
            e ? this._shaderValues.addDefine(ar.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(ar.SHADERDEFINE_SPECULARGLOSSTEXTURE), 
            this._shaderValues.setTexture(ar.SPECULARTEXTURE, e);
        }
        get specularColor() {
            return this._shaderValues.getVector(ar.SPECULARCOLOR);
        }
        set specularColor(e) {
            this._shaderValues.setVector(ar.SPECULARCOLOR, e);
        }
        clone() {
            var e = new ar();
            return this.cloneTo(e), e;
        }
    }
    ar.SPECULARTEXTURE = H.propertyNameToID("u_SpecularTexture"), ar.SPECULARCOLOR = H.propertyNameToID("u_SpecularColor");
    var nr, sr, or = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', lr = '#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRVSInput.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', _r = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', hr = '#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}';
    (nr = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[nr.MetallicGlossTextureAlpha = 0] = "MetallicGlossTextureAlpha", 
    nr[nr.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    class cr extends ee {
        constructor() {
            super(), this._smoothnessSource = 0, this.setShaderName("PBR"), this._shaderValues.setNumber(cr.METALLIC, 0);
        }
        static __init__() {
            cr.SHADERDEFINE_METALLICGLOSSTEXTURE = H.getDefineByName("METALLICGLOSSTEXTURE"), 
            cr.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = H.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
            var e = {
                a_Position: Xe.MESH_POSITION0,
                a_Normal: Xe.MESH_NORMAL0,
                a_Tangent0: Xe.MESH_TANGENT0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0,
                a_Texcoord1: Xe.MESH_TEXTURECOORDINATE1,
                a_BoneWeights: Xe.MESH_BLENDWEIGHT0,
                a_BoneIndices: Xe.MESH_BLENDINDICES0,
                a_MvpMatrix: Xe.MESH_MVPMATRIX_ROW0,
                a_WorldMat: Xe.MESH_WORLDMATRIX_ROW0
            }, t = {
                u_Bones: H.PERIOD_CUSTOM,
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_WorldMat: H.PERIOD_SPRITE,
                u_LightmapScaleOffset: H.PERIOD_SPRITE,
                u_LightMap: H.PERIOD_SPRITE,
                u_LightMapDirection: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_View: H.PERIOD_CAMERA,
                u_ProjectionParams: H.PERIOD_CAMERA,
                u_Viewport: H.PERIOD_CAMERA,
                u_ViewProjection: H.PERIOD_CAMERA,
                u_AlphaTestValue: H.PERIOD_MATERIAL,
                u_AlbedoColor: H.PERIOD_MATERIAL,
                u_EmissionColor: H.PERIOD_MATERIAL,
                u_AlbedoTexture: H.PERIOD_MATERIAL,
                u_NormalTexture: H.PERIOD_MATERIAL,
                u_ParallaxTexture: H.PERIOD_MATERIAL,
                u_OcclusionTexture: H.PERIOD_MATERIAL,
                u_EmissionTexture: H.PERIOD_MATERIAL,
                u_Smoothness: H.PERIOD_MATERIAL,
                u_SmoothnessScale: H.PERIOD_MATERIAL,
                u_occlusionStrength: H.PERIOD_MATERIAL,
                u_NormalScale: H.PERIOD_MATERIAL,
                u_ParallaxScale: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_MetallicGlossTexture: H.PERIOD_MATERIAL,
                u_Metallic: H.PERIOD_MATERIAL,
                u_ReflectTexture: H.PERIOD_SCENE,
                u_ReflectIntensity: H.PERIOD_SCENE,
                u_AmbientColor: H.PERIOD_SCENE,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE,
                u_DirationLightCount: H.PERIOD_SCENE,
                u_LightBuffer: H.PERIOD_SCENE,
                u_LightClusterBuffer: H.PERIOD_SCENE,
                u_ShadowBias: H.PERIOD_SCENE,
                u_ShadowLightDirection: H.PERIOD_SCENE,
                u_ShadowMap: H.PERIOD_SCENE,
                u_ShadowParams: H.PERIOD_SCENE,
                u_ShadowSplitSpheres: H.PERIOD_SCENE,
                u_ShadowMatrices: H.PERIOD_SCENE,
                u_ShadowMapSize: H.PERIOD_SCENE,
                u_AmbientSHAr: H.PERIOD_SCENE,
                u_AmbientSHAg: H.PERIOD_SCENE,
                u_AmbientSHAb: H.PERIOD_SCENE,
                u_AmbientSHBr: H.PERIOD_SCENE,
                u_AmbientSHBg: H.PERIOD_SCENE,
                u_AmbientSHBb: H.PERIOD_SCENE,
                u_AmbientSHC: H.PERIOD_SCENE,
                u_ReflectionProbe: H.PERIOD_SCENE,
                u_ReflectCubeHDRParams: H.PERIOD_SCENE,
                "u_DirectionLight.direction": H.PERIOD_SCENE,
                "u_DirectionLight.color": H.PERIOD_SCENE,
                "u_PointLight.position": H.PERIOD_SCENE,
                "u_PointLight.range": H.PERIOD_SCENE,
                "u_PointLight.color": H.PERIOD_SCENE,
                "u_SpotLight.position": H.PERIOD_SCENE,
                "u_SpotLight.direction": H.PERIOD_SCENE,
                "u_SpotLight.range": H.PERIOD_SCENE,
                "u_SpotLight.spot": H.PERIOD_SCENE,
                "u_SpotLight.color": H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("PBR"), a = new ir(e, t);
            i.addSubShader(a), a.addShaderPass(lr, or, r, "Forward"), a.addShaderPass(hr, _r, r, "ShadowCaster");
        }
        get metallicGlossTexture() {
            return this._shaderValues.getTexture(cr.METALLICGLOSSTEXTURE);
        }
        set metallicGlossTexture(e) {
            e ? this._shaderValues.addDefine(cr.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(cr.SHADERDEFINE_METALLICGLOSSTEXTURE), 
            this._shaderValues.setTexture(cr.METALLICGLOSSTEXTURE, e);
        }
        get metallic() {
            return this._shaderValues.getNumber(cr.METALLIC);
        }
        set metallic(e) {
            this._shaderValues.setNumber(cr.METALLIC, Math.max(0, Math.min(1, e)));
        }
        get smoothnessSource() {
            return this._smoothnessSource;
        }
        set smoothnessSource(e) {
            e ? this._shaderValues.addDefine(cr.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues.removeDefine(cr.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
            this._smoothnessSource = e;
        }
        clone() {
            var e = new cr();
            return this.cloneTo(e), e;
        }
    }
    cr.METALLICGLOSSTEXTURE = H.propertyNameToID("u_MetallicGlossTexture"), cr.METALLIC = H.propertyNameToID("u_Metallic");
    class dr extends Z {
        constructor() {
            super(), this.setShaderName("SkyBox"), this.tintColor = new a(.5, .5, .5, .5), this.exposure = 1, 
            this.rotation = 0;
        }
        static __initDefine__() {}
        get tintColor() {
            return this._shaderValues.getVector(dr.TINTCOLOR);
        }
        set tintColor(e) {
            this._shaderValues.setVector(dr.TINTCOLOR, e);
        }
        get exposure() {
            return this._shaderValues.getNumber(dr.EXPOSURE);
        }
        set exposure(e) {
            this._shaderValues.setNumber(dr.EXPOSURE, e);
        }
        get rotation() {
            return this._shaderValues.getNumber(dr.ROTATION);
        }
        set rotation(e) {
            this._shaderValues.setNumber(dr.ROTATION, e);
        }
        get textureCube() {
            return this._shaderValues.getTexture(dr.TEXTURECUBE);
        }
        set textureCube(e) {
            this._shaderValues.setTexture(dr.TEXTURECUBE, e);
        }
        clone() {
            var e = new dr();
            return this.cloneTo(e), e;
        }
    }
    dr.TINTCOLOR = H.propertyNameToID("u_TintColor"), dr.EXPOSURE = H.propertyNameToID("u_Exposure"), 
    dr.ROTATION = H.propertyNameToID("u_Rotation"), dr.TEXTURECUBE = H.propertyNameToID("u_CubeTexture");
    class ur extends Z {
        constructor() {
            super(), this.setShaderName("SkyBoxProcedural"), this.sunDisk = ur.SUN_HIGH_QUALITY, 
            this.sunSize = .04, this.sunSizeConvergence = 5, this.atmosphereThickness = 1, this.skyTint = new a(.5, .5, .5, 1), 
            this.groundTint = new a(.369, .349, .341, 1), this.exposure = 1.3;
        }
        static __initDefine__() {
            ur.SHADERDEFINE_SUN_HIGH_QUALITY = H.getDefineByName("SUN_HIGH_QUALITY"), ur.SHADERDEFINE_SUN_SIMPLE = H.getDefineByName("SUN_SIMPLE");
        }
        get sunDisk() {
            return this._sunDisk;
        }
        set sunDisk(e) {
            switch (e) {
              case ur.SUN_HIGH_QUALITY:
                this._shaderValues.removeDefine(ur.SHADERDEFINE_SUN_SIMPLE), this._shaderValues.addDefine(ur.SHADERDEFINE_SUN_HIGH_QUALITY);
                break;

              case ur.SUN_SIMPLE:
                this._shaderValues.removeDefine(ur.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.addDefine(ur.SHADERDEFINE_SUN_SIMPLE);
                break;

              case ur.SUN_NODE:
                this._shaderValues.removeDefine(ur.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.removeDefine(ur.SHADERDEFINE_SUN_SIMPLE);
                break;

              default:
                throw "SkyBoxProceduralMaterial: unknown sun value.";
            }
            this._sunDisk = e;
        }
        get sunSize() {
            return this._shaderValues.getNumber(ur.SUNSIZE);
        }
        set sunSize(e) {
            e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(ur.SUNSIZE, e);
        }
        get sunSizeConvergence() {
            return this._shaderValues.getNumber(ur.SUNSIZECONVERGENCE);
        }
        set sunSizeConvergence(e) {
            e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(ur.SUNSIZECONVERGENCE, e);
        }
        get atmosphereThickness() {
            return this._shaderValues.getNumber(ur.ATMOSPHERETHICKNESS);
        }
        set atmosphereThickness(e) {
            e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(ur.ATMOSPHERETHICKNESS, e);
        }
        get skyTint() {
            return this._shaderValues.getVector(ur.SKYTINT);
        }
        set skyTint(e) {
            this._shaderValues.setVector(ur.SKYTINT, e);
        }
        get groundTint() {
            return this._shaderValues.getVector(ur.GROUNDTINT);
        }
        set groundTint(e) {
            this._shaderValues.setVector(ur.GROUNDTINT, e);
        }
        get exposure() {
            return this._shaderValues.getNumber(ur.EXPOSURE);
        }
        set exposure(e) {
            e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(ur.EXPOSURE, e);
        }
        clone() {
            var e = new ur();
            return this.cloneTo(e), e;
        }
    }
    ur.SUN_NODE = 0, ur.SUN_SIMPLE = 1, ur.SUN_HIGH_QUALITY = 2, ur.SUNSIZE = H.propertyNameToID("u_SunSize"), 
    ur.SUNSIZECONVERGENCE = H.propertyNameToID("u_SunSizeConvergence"), ur.ATMOSPHERETHICKNESS = H.propertyNameToID("u_AtmosphereThickness"), 
    ur.SKYTINT = H.propertyNameToID("u_SkyTint"), ur.GROUNDTINT = H.propertyNameToID("u_GroundTint"), 
    ur.EXPOSURE = H.propertyNameToID("u_Exposure");
    class mr extends Z {
        constructor() {
            super(), this._albedoColor = new a(1, 1, 1, 1), this._albedoIntensity = 1, this._enableVertexColor = !1, 
            this.setShaderName("Unlit"), this._shaderValues.setVector(mr.ALBEDOCOLOR, new a(1, 1, 1, 1)), 
            this.renderMode = mr.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            mr.SHADERDEFINE_ALBEDOTEXTURE = H.getDefineByName("ALBEDOTEXTURE"), mr.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), 
            mr.SHADERDEFINE_ENABLEVERTEXCOLOR = H.getDefineByName("ENABLEVERTEXCOLOR");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _AlbedoIntensity() {
            return this._albedoIntensity;
        }
        set _AlbedoIntensity(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(mr.ALBEDOCOLOR);
                a.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(mr.ALBEDOCOLOR, t);
            }
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(mr.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(mr.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(mr.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(mr.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(mr.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(mr.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(mr.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(mr.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            var t = this._shaderValues.getVector(mr.ALBEDOCOLOR);
            a.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(mr.ALBEDOCOLOR, t);
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(e) {
            this._AlbedoIntensity = e;
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(mr.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(mr.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(mr.SHADERDEFINE_ALBEDOTEXTURE), 
            this._shaderValues.setTexture(mr.ALBEDOTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(mr.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(mr.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(mr.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(mr.TILINGOFFSET, e);
        }
        get enableVertexColor() {
            return this._enableVertexColor;
        }
        set enableVertexColor(e) {
            this._enableVertexColor = e, e ? this._shaderValues.addDefine(mr.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(mr.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set renderMode(e) {
            switch (e) {
              case mr.RENDERMODE_OPAQUE:
                this.alphaTest = !1, this.renderQueue = Z.RENDERQUEUE_OPAQUE, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              case mr.RENDERMODE_CUTOUT:
                this.renderQueue = Z.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_DISABLE, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              case mr.RENDERMODE_TRANSPARENT:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_BACK, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS;
                break;

              default:
                throw new Error("UnlitMaterial : renderMode value error.");
            }
        }
        get depthWrite() {
            return this._shaderValues.getBool(mr.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(mr.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt(mr.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt(mr.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt(mr.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt(mr.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(mr.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(mr.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(mr.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt(mr.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(mr.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(mr.DEPTH_TEST, e);
        }
        clone() {
            var e = new mr();
            return this.cloneTo(e), e;
        }
    }
    mr.RENDERMODE_OPAQUE = 0, mr.RENDERMODE_CUTOUT = 1, mr.RENDERMODE_TRANSPARENT = 2, 
    mr.RENDERMODE_ADDTIVE = 3, mr.ALBEDOTEXTURE = H.propertyNameToID("u_AlbedoTexture"), 
    mr.ALBEDOCOLOR = H.propertyNameToID("u_AlbedoColor"), mr.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), 
    mr.CULL = H.propertyNameToID("s_Cull"), mr.BLEND = H.propertyNameToID("s_Blend"), 
    mr.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), mr.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    mr.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), mr.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class fr extends Z {
        constructor() {
            super(), this.setShaderName("WaterPrimary"), this._shaderValues.setVector(fr.HORIZONCOLOR, new a(.172, .463, .435, 0)), 
            this._shaderValues.setNumber(fr.WAVESCALE, .15), this._shaderValues.setVector(fr.WAVESPEED, new a(19, 9, -16, -7));
        }
        static __initDefine__() {
            fr.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), fr.SHADERDEFINE_NORMALTEXTURE = H.getDefineByName("NORMALTEXTURE");
        }
        get horizonColor() {
            return this._shaderValues.getVector(fr.HORIZONCOLOR);
        }
        set horizonColor(e) {
            this._shaderValues.setVector(fr.HORIZONCOLOR, e);
        }
        get mainTexture() {
            return this._shaderValues.getTexture(fr.MAINTEXTURE);
        }
        set mainTexture(e) {
            e ? this._shaderValues.addDefine(fr.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(fr.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(fr.MAINTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(fr.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(fr.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(fr.SHADERDEFINE_NORMALTEXTURE), 
            this._shaderValues.setTexture(fr.NORMALTEXTURE, e);
        }
        get waveScale() {
            return this._shaderValues.getNumber(fr.WAVESCALE);
        }
        set waveScale(e) {
            this._shaderValues.setNumber(fr.WAVESCALE, e);
        }
        get waveSpeed() {
            return this._shaderValues.getVector(fr.WAVESPEED);
        }
        set waveSpeed(e) {
            this._shaderValues.setVector(fr.WAVESPEED, e);
        }
        clone() {
            var e = new fr();
            return this.cloneTo(e), e;
        }
    }
    fr.HORIZONCOLOR = H.propertyNameToID("u_HorizonColor"), fr.MAINTEXTURE = H.propertyNameToID("u_MainTexture"), 
    fr.NORMALTEXTURE = H.propertyNameToID("u_NormalTexture"), fr.WAVESCALE = H.propertyNameToID("u_WaveScale"), 
    fr.WAVESPEED = H.propertyNameToID("u_WaveSpeed");
    class Er {}
    class Tr extends kt {
        constructor(e) {
            super(e), this._revertStaticBatchDefineUV1 = !1, this._projectionViewWorldMatrix = new y();
        }
        _createRenderElement() {
            return new zt();
        }
        _onMeshChange(e) {
            if (e) {
                var t = e.subMeshCount;
                this._renderElements.length = t;
                for (var r = 0; r < t; r++) {
                    var i = this._renderElements[r];
                    if (!i) {
                        var a = this.sharedMaterials[r];
                        (i = this._renderElements[r] = this._createRenderElement()).setTransform(this._owner._transform), 
                        i.render = this, i.material = a || K.defaultMaterial;
                    }
                    i.setGeometry(e.getSubMesh(r));
                }
            } else this._renderElements.length = 0;
            this._boundsChange = !0;
        }
        _calculateBoundingBox() {
            var e = this._owner.meshFilter.sharedMesh;
            if (e) {
                var r = this._owner.transform.worldMatrix;
                e.bounds._tranform(r, this._bounds);
            }
            if (t.Render.supportWebGLPlusCulling) {
                var i = this._bounds.getMin(), a = this._bounds.getMax(), n = Ce._cullingBuffer;
                n[this._cullingBufferIndex + 1] = i.x, n[this._cullingBufferIndex + 2] = i.y, n[this._cullingBufferIndex + 3] = i.z, 
                n[this._cullingBufferIndex + 4] = a.x, n[this._cullingBufferIndex + 5] = a.y, n[this._cullingBufferIndex + 6] = a.z;
            }
        }
        _needRender(e, t) {
            return !e || e.intersects(this.bounds._getBoundBox());
        }
        _renderUpdate(e, t) {
            this._applyLightMapParams();
            var r = e.renderElement;
            switch (r.renderType) {
              case Gt.RENDERTYPE_NORMAL:
                this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, t.worldMatrix);
                break;

              case Gt.RENDERTYPE_STATICBATCH:
                t ? this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, y.DEFAULT), 
                this._shaderValues.hasDefine(Er.SHADERDEFINE_UV1) ? this._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(Er.SHADERDEFINE_UV1), 
                this._revertStaticBatchDefineUV1 = !0), this._shaderValues.setVector(xe.LIGHTMAPSCALEOFFSET, kt._defaultLightmapScaleOffset);
                break;

              case Gt.RENDERTYPE_VERTEXBATCH:
                this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, y.DEFAULT);
                break;

              case Gt.RENDERTYPE_INSTANCEBATCH:
                for (var i = Ut.instance.instanceWorldMatrixData, a = r.instanceBatchElementList, n = a.elements, s = a.length, o = 0; o < s; o++) i.set(n[o]._transform.worldMatrix.elements, 16 * o);
                var l = Ut.instance.instanceWorldMatrixBuffer;
                l.orphanStorage(), l.setData(i.buffer, 0, 0, 16 * s * 4), this._shaderValues.addDefine(Er.SHADERDEFINE_GPU_INSTANCE);
            }
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix;
            if (r) {
                var i = e.renderElement;
                switch (i.renderType) {
                  case Gt.RENDERTYPE_NORMAL:
                  case Gt.RENDERTYPE_STATICBATCH:
                  case Gt.RENDERTYPE_VERTEXBATCH:
                    t ? (y.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(ve.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(ve.MVPMATRIX, r);
                    break;

                  case Gt.RENDERTYPE_INSTANCEBATCH:
                    for (var a = Ut.instance.instanceMVPMatrixData, n = i.instanceBatchElementList, s = n.elements, o = n.length, l = 0; l < o; l++) {
                        var _ = s[l]._transform.worldMatrix;
                        I.mulMatrixByArray(r.elements, 0, _.elements, 0, a, 16 * l);
                    }
                    var h = Ut.instance.instanceMVPMatrixBuffer;
                    h.orphanStorage(), h.setData(a.buffer, 0, 0, 16 * o * 4);
                }
            }
        }
        _revertBatchRenderUpdate(e) {
            switch (e.renderElement.renderType) {
              case Gt.RENDERTYPE_STATICBATCH:
                this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(Er.SHADERDEFINE_UV1), 
                this._shaderValues.setVector(xe.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                break;

              case Gt.RENDERTYPE_INSTANCEBATCH:
                this._shaderValues.removeDefine(Er.SHADERDEFINE_GPU_INSTANCE);
            }
        }
        _destroy() {
            this._isPartOfStaticBatch && Wt.instance._removeRenderSprite(this._owner), super._destroy();
        }
    }
    class pr {
        constructor(e) {
            this._owner = e;
        }
        get sharedMesh() {
            return this._sharedMesh;
        }
        set sharedMesh(e) {
            if (this._sharedMesh !== e) {
                var t = this._owner._render._shaderValues, r = this._sharedMesh;
                if (r) {
                    r._removeReference(), this._getMeshDefine(r, pr._meshVerticeDefine);
                    for (var i = 0, a = pr._meshVerticeDefine.length; i < a; i++) t.removeDefine(pr._meshVerticeDefine[i]);
                }
                if (e) {
                    e._addReference(), this._getMeshDefine(e, pr._meshVerticeDefine);
                    for (i = 0, a = pr._meshVerticeDefine.length; i < a; i++) t.addDefine(pr._meshVerticeDefine[i]);
                }
                this._owner._render._onMeshChange(e), this._sharedMesh = e;
            }
        }
        _getMeshDefine(e, t) {
            t.length = 0;
            for (var r = 0, i = e._subMeshes.length; r < i; r++) for (var a = e.getSubMesh(r)._vertexBuffer._vertexDeclaration._vertexElements, n = 0, s = a.length; n < s; n++) {
                switch (a[n]._elementUsage) {
                  case Xe.MESH_COLOR0:
                    t.push(Er.SHADERDEFINE_COLOR);
                    break;

                  case Xe.MESH_TEXTURECOORDINATE0:
                    t.push(Er.SHADERDEFINE_UV0);
                    break;

                  case Xe.MESH_TEXTURECOORDINATE1:
                    t.push(Er.SHADERDEFINE_UV1);
                }
            }
        }
        destroy() {
            this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
        }
    }
    pr._meshVerticeDefine = [];
    class gr extends wt {
        constructor() {
            super(), this._bufferState = new Ge();
            var r = t.LayaGL.instance, i = Xe.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * gr.maxIndicesCount;
            this._vertices = new Float32Array(i / 4), this._vertexBuffer = new Ye(i, r.DYNAMIC_DRAW), 
            this._indices = new Int16Array(gr.maxIndicesCount), this._indexBuffer = new ze(e.IndexFormat.UInt16, this._indices.length, r.DYNAMIC_DRAW);
            var a = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addMemory(a, a);
        }
        static __init__() {
            gr.instance = new gr();
        }
        _getBatchVertices(e, t, r, i, a, n) {
            var s = e.vertexStride / 4, o = n._vertexBuffer.getFloat32Data(), l = (a.render.lightmapScaleOffset, 
            a._dynamicMultiSubMesh), _ = a._dynamicVertexCount;
            a._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, _);
            for (var h = a._dynamicWorldPositions, c = a._dynamicWorldNormals, d = n._indices, u = 0; u < _; u++) {
                var m = (l ? d[u] : u) * s, f = (u + r) * s, E = 3 * u, T = f + this._positionOffset;
                t[T] = h[E], t[T + 1] = h[E + 1], t[T + 2] = h[E + 2], -1 !== this._normalOffset && (t[T = f + this._normalOffset] = c[E], 
                t[T + 1] = c[E + 1], t[T + 2] = c[E + 2]), -1 !== this._colorOffset && (T = f + this._colorOffset, 
                E = m + this._colorOffset, t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2], 
                t[T + 3] = o[E + 3]), -1 !== this._uv0Offset && (T = f + this._uv0Offset, E = m + this._uv0Offset, 
                t[T] = o[E], t[T + 1] = o[E + 1]), -1 !== this._sTangentOffset && (T = f + this._sTangentOffset, 
                E = m + this._sTangentOffset, t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2], 
                t[T + 3] = o[E + 3], T = f + this._sTangentOffset, E = m + this._sTangentOffset, 
                t[T] = o[E], t[T + 1] = o[E + 1], t[T + 2] = o[E + 2], t[T + 3] = o[E + 3]);
            }
        }
        _getBatchIndices(e, t, r, i, a, n) {
            var s, o, l, _ = a._indices, h = i._isFrontFaceInvert;
            if (n) if (h) for (s = 0, o = _.length; s < o; s += 3) {
                var c = r + s;
                e[l = t + s] = c, e[l + 1] = c + 2, e[l + 2] = c + 1;
            } else for (s = 0, o = _.length; s < o; s += 3) c = r + s, e[l = t + s] = c, e[l + 1] = c + 1, 
            e[l + 2] = c + 2; else if (h) for (s = 0, o = _.length; s < o; s += 3) e[l = t + s] = r + _[s], 
            e[l + 1] = r + _[s + 2], e[l + 2] = r + _[s + 1]; else for (s = 0, o = _.length; s < o; s += 3) e[l = t + s] = r + _[s], 
            e[l + 1] = r + _[s + 1], e[l + 2] = r + _[s + 2];
        }
        _flush(e, r) {
            var i = t.LayaGL.instance;
            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState.vertexDeclaration.vertexStride), 
            this._indexBuffer.setData(this._indices, 0, 0, r), i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0);
        }
        _prepareRender(e) {
            var t = e.renderElement.vertexBatchVertexDeclaration;
            this._bufferState = _.MeshRenderDynamicBatchManager.instance._getBufferState(t), 
            this._positionOffset = t.getVertexElementByUsage(Xe.MESH_POSITION0)._offset / 4;
            var r = t.getVertexElementByUsage(Xe.MESH_NORMAL0);
            this._normalOffset = r ? r._offset / 4 : -1;
            var i = t.getVertexElementByUsage(Xe.MESH_COLOR0);
            this._colorOffset = i ? i._offset / 4 : -1;
            var a = t.getVertexElementByUsage(Xe.MESH_TEXTURECOORDINATE0);
            this._uv0Offset = a ? a._offset / 4 : -1;
            var n = t.getVertexElementByUsage(Xe.MESH_TEXTURECOORDINATE1);
            this._uv1Offset = n ? n._offset / 4 : -1;
            var s = t.getVertexElementByUsage(Xe.MESH_TANGENT0);
            return this._sTangentOffset = s ? s._offset / 4 : -1, !0;
        }
        _render(e) {
            this._bufferState.bind();
            for (var r = e.renderElement, i = r.vertexBatchVertexDeclaration, a = r.vertexBatchElementList, n = 0, s = 0, o = (i.vertexStride, 
            0), l = a.length, _ = a.elements, h = 0; h < l; h++) {
                var c = _[h], d = c._geometry, u = d._indexCount;
                s + u > gr.maxIndicesCount && (this._flush(n, s), o++, t.Stat.trianglesFaces += s / 3, 
                n = s = 0);
                var m = c._transform;
                this._getBatchVertices(i, this._vertices, n, m, c, d), this._getBatchIndices(this._indices, s, n, m, d, c._dynamicMultiSubMesh), 
                n += c._dynamicVertexCount, s += u;
            }
            this._flush(n, s), o++, t.Stat.renderBatches += o, t.Stat.savedRenderBatches += l - o, 
            t.Stat.trianglesFaces += s / 3;
        }
    }
    gr.maxAllowVertexCount = 10, gr.maxAllowAttribueCount = 900, gr.maxIndicesCount = 32e3;
    class Sr extends Se {
        constructor() {
            super(), this._instanceBatchOpaqueMarks = [], this._vertexBatchOpaqueMarks = [], 
            this._cacheBufferStates = [], this._updateCountMark = 0;
        }
        getInstanceBatchOpaquaMark(e, t, r, i) {
            var a = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = []), n = a[t] || (a[t] = []), s = n[r] || (n[r] = []);
            return s[i ? 1 : 0] || (s[i ? 1 : 0] = new Ft());
        }
        getVertexBatchOpaquaMark(e, t, r, i) {
            var a = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []), n = a[t ? 0 : 1] || (a[t ? 0 : 1] = []), s = n[r] || (n[r] = []);
            return s[i] || (s[i] = new Ft());
        }
        _getBufferState(e) {
            var t = this._cacheBufferStates[e.id];
            if (!t) {
                var r = gr.instance;
                (t = new Ge()).bind();
                var i = r._vertexBuffer;
                i.vertexDeclaration = e, t.applyVertexBuffer(i), t.applyIndexBuffer(r._indexBuffer), 
                t.unBind(), this._cacheBufferStates[e.id] = t;
            }
            return t;
        }
        _getBatchRenderElementFromPool() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new zt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
            e.vertexBatchElementList = new Te(), e.instanceBatchElementList = new Te()), e;
        }
        _clear() {
            super._clear(), this._updateCountMark++;
        }
    }
    Sr.instance = new Sr();
    class Rr extends xe {
        static __init__() {
            Er.SHADERDEFINE_UV0 = H.getDefineByName("UV"), Er.SHADERDEFINE_COLOR = H.getDefineByName("COLOR"), 
            Er.SHADERDEFINE_UV1 = H.getDefineByName("UV1"), Er.SHADERDEFINE_GPU_INSTANCE = H.getDefineByName("GPU_INSTANCE"), 
            Ie._registerManager(Wt.instance), Se._registerManager(Sr.instance);
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get meshRenderer() {
            return this._render;
        }
        constructor(e = null, t = null) {
            super(t), this._meshFilter = new pr(this), this._render = new Tr(this), e && (this._meshFilter.sharedMesh = e);
        }
        _parse(e, r) {
            super._parse(e, r);
            var i = this.meshRenderer, n = e.lightmapIndex;
            null != n && (i.lightmapIndex = n);
            var s = e.lightmapScaleOffset;
            s && (i.lightmapScaleOffset = new a(s[0], s[1], s[2], s[3])), null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)), 
            null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
            var o = e.materials;
            if (o) {
                var l = i.sharedMaterials, _ = o.length;
                l.length = _;
                for (var h = 0; h < _; h++) l[h] = t.Loader.getRes(o[h].path);
                i.sharedMaterials = l;
            }
        }
        _addToInitStaticBatchManager() {
            this.meshFilter.sharedMesh && Wt.instance._addBatchSprite(this);
        }
        _cloneTo(e, t, r) {
            var i = e;
            i._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
            var a = this._render, n = i._render;
            n.enable = a.enable, n.sharedMaterials = a.sharedMaterials, n.castShadow = a.castShadow;
            var s = a.lightmapScaleOffset;
            s && (n.lightmapScaleOffset = s.clone()), n.lightmapIndex = a.lightmapIndex, n.receiveShadow = a.receiveShadow, 
            n.sortingFudge = a.sortingFudge, super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._meshFilter.destroy());
        }
        _create() {
            return new Rr();
        }
    }
    class vr {}
    vr.Blend = 0, vr.Fixed = 1;
    class xr {
        constructor(e, t) {
            this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0, 
            this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null, 
            this._rgbElements = null, this._maxColorRGBKeysCount = e, this._maxColorAlphaKeysCount = t, 
            this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
        }
        get mode() {
            return this._mode;
        }
        set mode(e) {
            this._mode = e;
        }
        get colorRGBKeysCount() {
            return this._colorRGBKeysCount;
        }
        get colorAlphaKeysCount() {
            return this._colorAlphaKeysCount;
        }
        get maxColorRGBKeysCount() {
            return this._maxColorRGBKeysCount;
        }
        get maxColorAlphaKeysCount() {
            return this._maxColorAlphaKeysCount;
        }
        addColorRGB(e, t) {
            if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                var r = 4 * this._colorRGBKeysCount;
                this._rgbElements[r] = e, this._rgbElements[r + 1] = t.r, this._rgbElements[r + 2] = t.g, 
                this._rgbElements[r + 3] = t.b, this._colorRGBKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
        }
        addColorAlpha(e, t) {
            if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                var r = 2 * this._colorAlphaKeysCount;
                this._alphaElements[r] = e, this._alphaElements[r + 1] = t, this._colorAlphaKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
        }
        updateColorRGB(e, t, r) {
            if (e < this._colorRGBKeysCount) {
                var i = 4 * e;
                this._rgbElements[i] = t, this._rgbElements[i + 1] = r.r, this._rgbElements[i + 2] = r.g, 
                this._rgbElements[i + 3] = r.b;
            } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
        }
        updateColorAlpha(e, t, r) {
            if (e < this._colorAlphaKeysCount) {
                var i = 2 * e;
                this._alphaElements[i] = t, this._alphaElements[i + 1] = r;
            } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
        }
        evaluateColorRGB(e, t, r = 0, i = !1) {
            e = Math.min(Math.max(e, 0), 1);
            var a = this._rgbElements, n = r;
            if (i) for (var s = n; s >= 0; s--) {
                var o = 4 * s;
                if (e === (u = a[o])) return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3], n;
                switch (this._mode) {
                  case vr.Blend:
                    if (e > u) {
                        if (e > (d = a[o + 4])) throw "Gradient:wrong startSearchIndex.";
                        var l = d - u, _ = d - e, h = e - u;
                        return t.r = (_ * a[o + 1] + h * a[o + 5]) / l, t.g = (_ * a[o + 2] + h * a[o + 6]) / l, 
                        t.b = (_ * a[o + 3] + h * a[o + 7]) / l, n;
                    }
                    n--;
                    continue;

                  case vr.Fixed:
                    if (e > u) {
                        if (e > a[o + 4]) throw "Gradient:wrong startSearchIndex.";
                        return t.r = a[o + 5], t.g = a[o + 6], t.b = a[o + 7], n;
                    }
                    n--;
                    continue;

                  default:
                    throw "Gradient:unknown mode.";
                }
            } else {
                s = 0;
                for (var c = this._rgbElements.length; s < c; s++) {
                    var d;
                    if (e === (d = a[o = 4 * s])) return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3], 
                    n;
                    switch (this._mode) {
                      case vr.Blend:
                        if (e < d) {
                            var u;
                            if (e < (u = a[o - 4])) throw "Gradient:wrong startSearchIndex.";
                            l = d - u, _ = d - e, h = e - u;
                            return t.r = (_ * a[o - 3] + h * a[o + 1]) / l, t.g = (_ * a[o - 2] + h * a[o + 2]) / l, 
                            t.b = (_ * a[o - 1] + h * a[o + 3]) / l, n;
                        }
                        n++;
                        continue;

                      case vr.Fixed:
                        if (e < d) {
                            if (e < a[o - 4]) throw "Gradient:wrong startSearchIndex.";
                            return t.r = a[o + 1], t.g = a[o + 2], t.b = a[o + 3], n;
                        }
                        n++;
                        continue;

                      default:
                        throw "Gradient:unknown mode.";
                    }
                }
            }
            return n;
        }
        evaluateColorAlpha(e, t, r = 0, i = !1) {
            e = Math.min(Math.max(e, 0), 1);
            var a = this._alphaElements, n = r;
            if (i) for (var s = n; s >= 0; s--) {
                if (e === (u = a[c = 2 * s])) return t.a = a[c + 1], n;
                switch (this._mode) {
                  case vr.Blend:
                    if (e > u) {
                        if (e > (d = a[c + 2])) throw "Gradient:wrong startSearchIndex.";
                        var o = d - u, l = d - e, _ = e - u;
                        return t.a = (l * a[c + 1] + _ * a[c + 3]) / o, n;
                    }
                    n--;
                    continue;

                  case vr.Fixed:
                    if (e > u) {
                        if (e > a[c + 2]) throw "Gradient:wrong startSearchIndex.";
                        return t.a = a[c + 3], n;
                    }
                    n--;
                    continue;

                  default:
                    throw "Gradient:unknown mode.";
                }
            } else {
                s = n;
                for (var h = this._alphaElements.length; s < h; s++) {
                    var c, d;
                    if (e === (d = a[c = 2 * s])) return t.a = a[c + 1], n;
                    switch (this._mode) {
                      case vr.Blend:
                        if (e < d) {
                            var u;
                            if (e < (u = a[c - 2])) throw "Gradient:wrong startSearchIndex.";
                            o = d - u, l = d - e, _ = e - u;
                            return t.a = (l * a[c - 1] + _ * a[c + 1]) / o, n;
                        }
                        n++;
                        continue;

                      case vr.Fixed:
                        if (e < d) {
                            if (e < a[c - 2]) throw "Gradient:wrong startSearchIndex.";
                            return t.a = a[c + 1], n;
                        }
                        n++;
                        continue;

                      default:
                        throw "Gradient:unknown mode.";
                    }
                }
            }
            return n;
        }
        cloneTo(e) {
            var t, r, i = e;
            i._colorAlphaKeysCount = this._colorAlphaKeysCount;
            var a = i._alphaElements;
            for (t = 0, r = this._alphaElements.length; t < r; t++) a[t] = this._alphaElements[t];
            i._colorRGBKeysCount = this._colorRGBKeysCount;
            var n = i._rgbElements;
            for (t = 0, r = this._rgbElements.length; t < r; t++) n[t] = this._rgbElements[t];
        }
        clone() {
            var e = new xr(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
            return this.cloneTo(e), e;
        }
    }
    class Ir {
        get time() {
            return this._time;
        }
        get minCount() {
            return this._minCount;
        }
        get maxCount() {
            return this._maxCount;
        }
        constructor(e, t, r) {
            this._time = e, this._minCount = t, this._maxCount = r;
        }
        cloneTo(e) {
            var t = e;
            t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
        }
        clone() {
            var e = new Ir(this._time, this._minCount, this._maxCount);
            return this.cloneTo(e), e;
        }
    }
    class Ar {
        constructor() {
            this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null, 
            this._gradient = null, this._gradientMin = null, this._gradientMax = null;
        }
        static createByConstant(e) {
            var t = new Ar();
            return t._type = 0, t._constant = e, t;
        }
        static createByGradient(e) {
            var t = new Ar();
            return t._type = 1, t._gradient = e, t;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new Ar();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new Ar();
            return r._type = 3, r._gradientMin = e, r._gradientMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin), 
            this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient), 
            this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
        }
        clone() {
            var e = new Ar();
            return this.cloneTo(e), e;
        }
    }
    class Lr {
        get color() {
            return this._color;
        }
        constructor(e) {
            this._color = e;
        }
        cloneTo(e) {
            var t = e;
            this._color.cloneTo(t._color), t.enable = this.enable;
        }
        clone() {
            var e;
            switch (this._color.type) {
              case 0:
                e = Ar.createByConstant(this._color.constant.clone());
                break;

              case 1:
                e = Ar.createByGradient(this._color.gradient.clone());
                break;

              case 2:
                e = Ar.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                break;

              case 3:
                e = Ar.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
            }
            var t = new Lr(e);
            return t.enable = this.enable, t;
        }
    }
    class Cr {
        constructor() {
            this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0, 
            this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
        }
        static createByConstant(e = 0) {
            var t = new Cr();
            return t._type = 0, t._constant = e, t;
        }
        static createByOverTime(e) {
            var t = new Cr();
            return t._type = 1, t._overTime = e, t;
        }
        static createByRandomTwoConstant(e = 0, t = 0) {
            var r = new Cr();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoOverTime(e, t) {
            var r = new Cr();
            return r._type = 3, r._overTimeMin = e, r._overTimeMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get frameOverTimeData() {
            return this._overTime;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get frameOverTimeDataMin() {
            return this._overTimeMin;
        }
        get frameOverTimeDataMax() {
            return this._overTimeMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, this._overTime && this._overTime.cloneTo(t._overTime), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin), 
            this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
        }
        clone() {
            var e = new Cr();
            return this.cloneTo(e), e;
        }
    }
    class Dr {
        constructor() {
            this._type = 0, this._separateAxes = !1, this._constant = 0, this._constantSeparate = null, 
            this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null, 
            this._gradientW = null, this._constantMin = 0, this._constantMax = 0, this._constantMinSeparate = null, 
            this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null, 
            this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null, 
            this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null, 
            this._gradientWMin = null, this._gradientWMax = null;
        }
        static createByConstant(e) {
            var t = new Dr();
            return t._type = 0, t._separateAxes = !1, t._constant = e, t;
        }
        static createByConstantSeparate(e) {
            var t = new Dr();
            return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
        }
        static createByGradient(e) {
            var t = new Dr();
            return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
        }
        static createByGradientSeparate(e, t, r) {
            var i = new Dr();
            return i._type = 1, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r, 
            i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new Dr();
            return r._type = 2, r._separateAxes = !1, r._constantMin = e, r._constantMax = t, 
            r;
        }
        static createByRandomTwoConstantSeparate(e, t) {
            var r = new Dr();
            return r._type = 2, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t, 
            r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new Dr();
            return r._type = 3, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t, 
            r;
        }
        static createByRandomTwoGradientSeparate(e, t, r, i, a, n, s, o) {
            var l = new Dr();
            return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t, 
            l._gradientYMin = r, l._gradientYMax = i, l._gradientZMin = a, l._gradientZMax = n, 
            l._gradientWMin = s, l._gradientWMax = o, l;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get constant() {
            return this._constant;
        }
        get constantSeparate() {
            return this._constantSeparate;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get gradientW() {
            return this._gradientW;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        get gradientWMin() {
            return this._gradientWMin;
        }
        get gradientWMax() {
            return this._gradientWMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant, 
            this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient), 
            this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
            this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
            this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new Dr();
            return this.cloneTo(e), e;
        }
    }
    class Mr {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new Mr();
            return this.cloneTo(e), e;
        }
    }
    class yr {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
        }
        getKeyByIndex(e) {
            return this._elements[2 * e];
        }
        getValueByIndex(e) {
            return this._elements[2 * e + 1];
        }
        getAverageValue() {
            for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                this._elements[e + 1];
                this._elements[e + 3], this._elements[e + 2] - this._elements[e];
            }
            return 0;
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new yr();
            return this.cloneTo(e), e;
        }
    }
    class Or {
        constructor() {
            this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null, 
            this._gradientY = null, this._gradientZ = null, this._constantMin = 0, this._constantMax = 0, 
            this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null, 
            this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, 
            this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, 
            this._gradientZMax = null;
        }
        static createByGradient(e) {
            var t = new Or();
            return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
        }
        static createByGradientSeparate(e, t, r) {
            var i = new Or();
            return i._type = 0, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r, 
            i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new Or();
            return r._type = 1, r._separateAxes = !1, r._constantMin = e, r._constantMax = t, 
            r;
        }
        static createByRandomTwoConstantSeparate(e, t) {
            var r = new Or();
            return r._type = 1, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t, 
            r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new Or();
            return r._type = 2, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t, 
            r;
        }
        static createByRandomTwoGradientSeparate(e, t, r, i, a, n) {
            var s = new Or();
            return s._type = 2, s._separateAxes = !0, s._gradientXMin = e, s._gradientXMax = t, 
            s._gradientYMin = r, s._gradientYMax = i, s._gradientZMin = a, s._gradientZMax = n, 
            s;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        getMaxSizeInGradient() {
            var e, t, r = -Number.MAX_VALUE;
            switch (this._type) {
              case 0:
                if (this._separateAxes) {
                    for (e = 0, t = this._gradientX.gradientCount; e < t; e++) r = Math.max(r, this._gradientX.getValueByIndex(e));
                    for (e = 0, t = this._gradientY.gradientCount; e < t; e++) r = Math.max(r, this._gradientY.getValueByIndex(e));
                } else for (e = 0, t = this._gradient.gradientCount; e < t; e++) r = Math.max(r, this._gradient.getValueByIndex(e));
                break;

              case 1:
                this._separateAxes ? (r = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x), 
                r = Math.max(r, this._constantMinSeparate.y), r = Math.max(r, this._constantMaxSeparate.y)) : r = Math.max(this._constantMin, this._constantMax);
                break;

              case 2:
                if (this._separateAxes) {
                    for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMax.getValueByIndex(e));
                    for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientYMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientZMax.getValueByIndex(e));
                } else {
                    for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientMax.getValueByIndex(e));
                }
            }
            return r;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient), 
            this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
            this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
            this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new Or();
            return this.cloneTo(e), e;
        }
    }
    class Nr {
        constructor() {
            this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null, 
            this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null, 
            this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null, 
            this._gradientZMin = null, this._gradientZMax = null;
        }
        static createByConstant(e) {
            var t = new Nr();
            return t._type = 0, t._constant = e, t;
        }
        static createByGradient(e, t, r) {
            var i = new Nr();
            return i._type = 1, i._gradientX = e, i._gradientY = t, i._gradientZ = r, i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new Nr();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoGradient(e, t, r, i, a, n) {
            var s = new Nr();
            return s._type = 3, s._gradientXMin = e, s._gradientXMax = t, s._gradientYMin = r, 
            s._gradientYMax = i, s._gradientZMin = a, s._gradientZMax = n, s;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX), 
            this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin), 
            this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new Nr();
            return this.cloneTo(e), e;
        }
    }
    class br {
        get angularVelocity() {
            return this._angularVelocity;
        }
        constructor(e) {
            this._angularVelocity = e;
        }
        cloneTo(e) {
            var t = e;
            this._angularVelocity.cloneTo(t._angularVelocity), t.enable = this.enable;
        }
        clone() {
            var e;
            switch (this._angularVelocity.type) {
              case 0:
                e = this._angularVelocity.separateAxes ? Dr.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : Dr.createByConstant(this._angularVelocity.constant);
                break;

              case 1:
                e = this._angularVelocity.separateAxes ? Dr.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : Dr.createByGradient(this._angularVelocity.gradient.clone());
                break;

              case 2:
                e = this._angularVelocity.separateAxes ? Dr.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : Dr.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                break;

              case 3:
                e = this._angularVelocity.separateAxes ? Dr.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : Dr.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
            }
            var t = new br(e);
            return t.enable = this.enable, t;
        }
    }
    class Pr {
        constructor() {
            this.enable = !0, this.randomDirection = 0;
        }
        _getShapeBoundBox(e) {
            throw new Error("BaseShape: must override it.");
        }
        _getSpeedBoundBox(e) {
            throw new Error("BaseShape: must override it.");
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            throw new Error("BaseShape: must override it.");
        }
        _calculateProceduralBounds(e, t, r) {
            this._getShapeBoundBox(e);
            var i = e.min, a = e.max;
            n.multiply(i, t, i), n.multiply(a, t, a);
            var s = new bt(new n(), new n());
            this.randomDirection ? (s.min = new n(-1, -1, -1), s.max = new n(1, 1, 1)) : this._getSpeedBoundBox(s);
            var o = new bt(new n(), new n()), l = o.min, _ = o.max;
            n.scale(s.min, r.y, l), n.scale(s.max, r.y, _), n.add(e.min, l, l), n.add(e.max, _, _), 
            n.min(e.min, l, e.min), n.max(e.max, l, e.max);
            var h = new bt(new n(), new n()), c = h.min, d = h.max;
            n.scale(s.min, r.x, c), n.scale(s.max, r.x, d), n.min(h.min, d, l), n.max(h.min, d, _), 
            n.min(e.min, l, e.min), n.max(e.max, l, e.max);
        }
        cloneTo(e) {
            e.enable = this.enable;
        }
        clone() {
            var e = new Pr();
            return this.cloneTo(e), e;
        }
    }
    class wr {
        static _randomPointUnitArcCircle(e, t, r = null) {
            var i;
            i = r ? r.getFloat() * e : Math.random() * e, t.x = Math.cos(i), t.y = Math.sin(i);
        }
        static _randomPointInsideUnitArcCircle(e, t, r = null) {
            var i;
            wr._randomPointUnitArcCircle(e, t, r), i = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5), 
            t.x = t.x * i, t.y = t.y * i;
        }
        static _randomPointUnitCircle(e, t = null) {
            var r;
            r = t ? t.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(r), 
            e.y = Math.sin(r);
        }
        static _randomPointInsideUnitCircle(e, t = null) {
            var r;
            wr._randomPointUnitCircle(e), r = t ? Math.pow(t.getFloat(), .5) : Math.pow(Math.random(), .5), 
            e.x = e.x * r, e.y = e.y * r;
        }
        static _randomPointUnitSphere(e, t = null) {
            var r, i;
            t ? (r = e.z = 2 * t.getFloat() - 1, i = t.getFloat() * Math.PI * 2) : (r = e.z = 2 * Math.random() - 1, 
            i = Math.random() * Math.PI * 2);
            var a = Math.sqrt(1 - r * r);
            e.x = a * Math.cos(i), e.y = a * Math.sin(i);
        }
        static _randomPointInsideUnitSphere(e, t = null) {
            var r;
            wr._randomPointUnitSphere(e), r = t ? Math.pow(t.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3), 
            e.x = e.x * r, e.y = e.y * r, e.z = e.z * r;
        }
        static _randomPointInsideHalfUnitBox(e, t = null) {
            t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5, 
            e.y = Math.random() - .5, e.z = Math.random() - .5);
        }
        constructor() {}
    }
    class Vr extends Pr {
        constructor() {
            super(), this.x = 1, this.y = 1, this.z = 1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
            var r = e.max;
            r.x = .5 * this.x, r.y = .5 * this.y, r.z = .5 * this.z;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = 0, t.y = 0, t.z = 0;
            var r = e.max;
            r.x = 0, r.y = 1, r.z = 0;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], wr._randomPointInsideHalfUnitBox(e, r), i[16] = r.seed) : wr._randomPointInsideHalfUnitBox(e), 
            e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? r ? (r.seed = i[17], 
            wr._randomPointUnitSphere(t, r), i[17] = r.seed) : wr._randomPointUnitSphere(t) : (t.x = 0, 
            t.y = 0, t.z = 1);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new Vr();
            return this.cloneTo(e), e;
        }
    }
    class Br extends Pr {
        constructor() {
            super(), this.radius = 1, this.arc = 2 * Math.PI, this.emitFromEdge = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.z = -this.radius, t.y = 0;
            var r = e.max;
            r.x = r.z = this.radius, r.y = 0;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var r = e.max;
            r.x = r.y = 1, r.z = 0;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            var a = Br._tempPositionPoint;
            r ? (r.seed = i[16], this.emitFromEdge ? wr._randomPointUnitArcCircle(this.arc, Br._tempPositionPoint, r) : wr._randomPointInsideUnitArcCircle(this.arc, Br._tempPositionPoint, r), 
            i[16] = r.seed) : this.emitFromEdge ? wr._randomPointUnitArcCircle(this.arc, Br._tempPositionPoint) : wr._randomPointInsideUnitArcCircle(this.arc, Br._tempPositionPoint), 
            e.x = -a.x, e.y = a.y, e.z = 0, n.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17], 
            wr._randomPointUnitSphere(t, r), i[17] = r.seed) : wr._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new Br();
            return this.cloneTo(e), e;
        }
    }
    Br._tempPositionPoint = new i();
    class Fr extends Pr {
        constructor() {
            super(), this.angle = 25 / 180 * Math.PI, this.radius = 1, this.length = 5, this.emitType = 0;
        }
        _getShapeBoundBox(e) {
            const t = this.radius + this.length * Math.sin(this.angle), r = this.length * Math.cos(this.angle);
            var i = e.min;
            i.x = i.y = -t, i.z = 0;
            var a = e.max;
            a.x = a.y = t, a.z = r;
        }
        _getSpeedBoundBox(e) {
            const t = Math.sin(this.angle);
            var r = e.min;
            r.x = r.y = -t, r.z = 0;
            var i = e.max;
            i.x = i.y = t, i.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            var a, s, o, l = Fr._tempPositionPoint, _ = Math.cos(this.angle), h = Math.sin(this.angle);
            switch (this.emitType) {
              case 0:
                r ? (r.seed = i[16], wr._randomPointInsideUnitCircle(Fr._tempPositionPoint, r), 
                i[16] = r.seed) : wr._randomPointInsideUnitCircle(Fr._tempPositionPoint), a = l.x, 
                s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17], 
                wr._randomPointInsideUnitCircle(Fr._tempDirectionPoint, r), i[17] = r.seed) : wr._randomPointInsideUnitCircle(Fr._tempDirectionPoint), 
                o = Fr._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = a * h, t.y = s * h), 
                t.z = _;
                break;

              case 1:
                r ? (r.seed = i[16], wr._randomPointUnitCircle(Fr._tempPositionPoint, r), i[16] = r.seed) : wr._randomPointUnitCircle(Fr._tempPositionPoint), 
                a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17], 
                wr._randomPointInsideUnitCircle(Fr._tempDirectionPoint, r), i[17] = r.seed) : wr._randomPointInsideUnitCircle(Fr._tempDirectionPoint), 
                o = Fr._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = a * h, t.y = s * h), 
                t.z = _;
                break;

              case 2:
                r ? (r.seed = i[16], wr._randomPointInsideUnitCircle(Fr._tempPositionPoint, r)) : wr._randomPointInsideUnitCircle(Fr._tempPositionPoint), 
                a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, t.x = a * h, 
                t.y = s * h, t.z = _, n.normalize(t, t), r ? (n.scale(t, this.length * r.getFloat(), t), 
                i[16] = r.seed) : n.scale(t, this.length * Math.random(), t), n.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17], 
                wr._randomPointUnitSphere(t, r), i[17] = r.seed) : wr._randomPointUnitSphere(t));
                break;

              case 3:
                r ? (r.seed = i[16], wr._randomPointUnitCircle(Fr._tempPositionPoint, r)) : wr._randomPointUnitCircle(Fr._tempPositionPoint), 
                a = l.x, s = l.y, e.x = a * this.radius, e.y = s * this.radius, e.z = 0, t.x = a * h, 
                t.y = s * h, t.z = _, n.normalize(t, t), r ? (n.scale(t, this.length * r.getFloat(), t), 
                i[16] = r.seed) : n.scale(t, this.length * Math.random(), t), n.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17], 
                wr._randomPointUnitSphere(t, r), i[17] = r.seed) : wr._randomPointUnitSphere(t));
                break;

              default:
                throw new Error("ConeShape:emitType is invalid.");
            }
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.angle = this.angle, t.radius = this.radius, t.length = this.length, t.emitType = this.emitType, 
            t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new Fr();
            return this.cloneTo(e), e;
        }
    }
    Fr._tempPositionPoint = new i(), Fr._tempDirectionPoint = new i();
    class Ur extends Pr {
        constructor() {
            super(), this.radius = 1, this.emitFromShell = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var r = e.max;
            r.x = r.y = this.radius, r.z = 0;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var r = e.max;
            r.x = r.y = r.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], this.emitFromShell ? wr._randomPointUnitSphere(e, r) : wr._randomPointInsideUnitSphere(e, r), 
            i[16] = r.seed) : this.emitFromShell ? wr._randomPointUnitSphere(e) : wr._randomPointInsideUnitSphere(e), 
            n.scale(e, this.radius, e);
            var a = e.z;
            a < 0 && (e.z = -1 * a), this.randomDirection ? r ? (r.seed = i[17], wr._randomPointUnitSphere(t, r), 
            i[17] = r.seed) : wr._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new Ur();
            return this.cloneTo(e), e;
        }
    }
    class Gr extends Pr {
        constructor() {
            super(), this.radius = 1, this.emitFromShell = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var r = e.max;
            r.x = r.y = r.z = this.radius;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -1;
            var r = e.max;
            r.x = r.y = r.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], this.emitFromShell ? wr._randomPointUnitSphere(e, r) : wr._randomPointInsideUnitSphere(e, r), 
            i[16] = r.seed) : this.emitFromShell ? wr._randomPointUnitSphere(e) : wr._randomPointInsideUnitSphere(e), 
            n.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17], wr._randomPointUnitSphere(t, r), 
            i[17] = r.seed) : wr._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new Gr();
            return this.cloneTo(e), e;
        }
    }
    class zr {
        get size() {
            return this._size;
        }
        constructor(e) {
            this._size = e;
        }
        cloneTo(e) {
            var t = e;
            this._size.cloneTo(t._size), t.enable = this.enable;
        }
        clone() {
            var e;
            switch (this._size.type) {
              case 0:
                e = this._size.separateAxes ? Or.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : Or.createByGradient(this._size.gradient.clone());
                break;

              case 1:
                e = this._size.separateAxes ? Or.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : Or.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                break;

              case 2:
                e = this._size.separateAxes ? Or.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : Or.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
            }
            var t = new zr(e);
            return t.enable = this.enable, t;
        }
    }
    class Hr {
        constructor() {
            this._type = 0, this._constant = 0, this._constantMin = 0, this._constantMax = 0;
        }
        static createByConstant(e = 0) {
            var t = new Hr();
            return t._type = 0, t._constant = e, t;
        }
        static createByRandomTwoConstant(e = 0, t = 0) {
            var r = new Hr();
            return r._type = 1, r._constantMin = e, r._constantMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin, 
            t._constantMax = this._constantMax;
        }
        clone() {
            var e = new Hr();
            return this.cloneTo(e), e;
        }
    }
    class Wr {
        constructor(e, t) {
            this.type = 0, this.randomRow = !1, this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, 
            this.enable = !1, this.tiles = new i(1, 1), this.type = 0, this.randomRow = !0, 
            this.rowIndex = 0, this.cycles = 1, this.enableUVChannels = 1, this._frame = e, 
            this._startFrame = t;
        }
        get frame() {
            return this._frame;
        }
        get startFrame() {
            return this._startFrame;
        }
        cloneTo(e) {
            var t = e;
            this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t.rowIndex = this.rowIndex, 
            t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, t.enable = this.enable, 
            this._frame.cloneTo(t._frame), this._startFrame.cloneTo(t._startFrame);
        }
        clone() {
            var e, t;
            switch (this._frame.type) {
              case 0:
                e = Cr.createByConstant(this._frame.constant);
                break;

              case 1:
                e = Cr.createByOverTime(this._frame.frameOverTimeData.clone());
                break;

              case 2:
                e = Cr.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                break;

              case 3:
                e = Cr.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
            }
            switch (this._startFrame.type) {
              case 0:
                t = Hr.createByConstant(this._startFrame.constant);
                break;

              case 1:
                t = Hr.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
            }
            var r = new Wr(e, t);
            return this.cloneTo(r), r;
        }
    }
    class kr {
        constructor(e) {
            this.enable = !1, this.space = 0, this._velocity = e;
        }
        get velocity() {
            return this._velocity;
        }
        cloneTo(e) {
            var t = e;
            this._velocity.cloneTo(t._velocity), t.enable = this.enable, t.space = this.space;
        }
        clone() {
            var e;
            switch (this._velocity.type) {
              case 0:
                e = Nr.createByConstant(this._velocity.constant.clone());
                break;

              case 1:
                e = Nr.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                break;

              case 2:
                e = Nr.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                break;

              case 3:
                e = Nr.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
            }
            var t = new kr(e);
            return t.enable = this.enable, t.space = this.space, t;
        }
    }
    class Xr {}
    Xr.WORLDPOSITION = H.propertyNameToID("u_WorldPosition"), Xr.WORLDROTATION = H.propertyNameToID("u_WorldRotation"), 
    Xr.POSITIONSCALE = H.propertyNameToID("u_PositionScale"), Xr.SIZESCALE = H.propertyNameToID("u_SizeScale"), 
    Xr.SCALINGMODE = H.propertyNameToID("u_ScalingMode"), Xr.GRAVITY = H.propertyNameToID("u_Gravity"), 
    Xr.THREEDSTARTROTATION = H.propertyNameToID("u_ThreeDStartRotation"), Xr.STRETCHEDBILLBOARDLENGTHSCALE = H.propertyNameToID("u_StretchedBillboardLengthScale"), 
    Xr.STRETCHEDBILLBOARDSPEEDSCALE = H.propertyNameToID("u_StretchedBillboardSpeedScale"), 
    Xr.SIMULATIONSPACE = H.propertyNameToID("u_SimulationSpace"), Xr.CURRENTTIME = H.propertyNameToID("u_CurrentTime"), 
    Xr.VOLVELOCITYCONST = H.propertyNameToID("u_VOLVelocityConst"), Xr.VOLVELOCITYGRADIENTX = H.propertyNameToID("u_VOLVelocityGradientX"), 
    Xr.VOLVELOCITYGRADIENTY = H.propertyNameToID("u_VOLVelocityGradientY"), Xr.VOLVELOCITYGRADIENTZ = H.propertyNameToID("u_VOLVelocityGradientZ"), 
    Xr.VOLVELOCITYCONSTMAX = H.propertyNameToID("u_VOLVelocityConstMax"), Xr.VOLVELOCITYGRADIENTXMAX = H.propertyNameToID("u_VOLVelocityGradientMaxX"), 
    Xr.VOLVELOCITYGRADIENTYMAX = H.propertyNameToID("u_VOLVelocityGradientMaxY"), Xr.VOLVELOCITYGRADIENTZMAX = H.propertyNameToID("u_VOLVelocityGradientMaxZ"), 
    Xr.VOLSPACETYPE = H.propertyNameToID("u_VOLSpaceType"), Xr.COLOROVERLIFEGRADIENTALPHAS = H.propertyNameToID("u_ColorOverLifeGradientAlphas"), 
    Xr.COLOROVERLIFEGRADIENTCOLORS = H.propertyNameToID("u_ColorOverLifeGradientColors"), 
    Xr.MAXCOLOROVERLIFEGRADIENTALPHAS = H.propertyNameToID("u_MaxColorOverLifeGradientAlphas"), 
    Xr.MAXCOLOROVERLIFEGRADIENTCOLORS = H.propertyNameToID("u_MaxColorOverLifeGradientColors"), 
    Xr.SOLSIZEGRADIENT = H.propertyNameToID("u_SOLSizeGradient"), Xr.SOLSIZEGRADIENTX = H.propertyNameToID("u_SOLSizeGradientX"), 
    Xr.SOLSIZEGRADIENTY = H.propertyNameToID("u_SOLSizeGradientY"), Xr.SOLSizeGradientZ = H.propertyNameToID("u_SOLSizeGradientZ"), 
    Xr.SOLSizeGradientMax = H.propertyNameToID("u_SOLSizeGradientMax"), Xr.SOLSIZEGRADIENTXMAX = H.propertyNameToID("u_SOLSizeGradientMaxX"), 
    Xr.SOLSIZEGRADIENTYMAX = H.propertyNameToID("u_SOLSizeGradientMaxY"), Xr.SOLSizeGradientZMAX = H.propertyNameToID("u_SOLSizeGradientMaxZ"), 
    Xr.ROLANGULARVELOCITYCONST = H.propertyNameToID("u_ROLAngularVelocityConst"), Xr.ROLANGULARVELOCITYCONSTSEPRARATE = H.propertyNameToID("u_ROLAngularVelocityConstSeprarate"), 
    Xr.ROLANGULARVELOCITYGRADIENT = H.propertyNameToID("u_ROLAngularVelocityGradient"), 
    Xr.ROLANGULARVELOCITYGRADIENTX = H.propertyNameToID("u_ROLAngularVelocityGradientX"), 
    Xr.ROLANGULARVELOCITYGRADIENTY = H.propertyNameToID("u_ROLAngularVelocityGradientY"), 
    Xr.ROLANGULARVELOCITYGRADIENTZ = H.propertyNameToID("u_ROLAngularVelocityGradientZ"), 
    Xr.ROLANGULARVELOCITYCONSTMAX = H.propertyNameToID("u_ROLAngularVelocityConstMax"), 
    Xr.ROLANGULARVELOCITYCONSTMAXSEPRARATE = H.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"), 
    Xr.ROLANGULARVELOCITYGRADIENTMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMax"), 
    Xr.ROLANGULARVELOCITYGRADIENTXMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxX"), 
    Xr.ROLANGULARVELOCITYGRADIENTYMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxY"), 
    Xr.ROLANGULARVELOCITYGRADIENTZMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"), 
    Xr.ROLANGULARVELOCITYGRADIENTWMAX = H.propertyNameToID("u_ROLAngularVelocityGradientMaxW"), 
    Xr.TEXTURESHEETANIMATIONCYCLES = H.propertyNameToID("u_TSACycles"), Xr.TEXTURESHEETANIMATIONSUBUVLENGTH = H.propertyNameToID("u_TSASubUVLength"), 
    Xr.TEXTURESHEETANIMATIONGRADIENTUVS = H.propertyNameToID("u_TSAGradientUVs"), Xr.TEXTURESHEETANIMATIONGRADIENTMAXUVS = H.propertyNameToID("u_TSAMaxGradientUVs");
    class Yr extends Z {
        constructor() {
            super(), this.setShaderName("PARTICLESHURIKEN"), this._color = new a(1, 1, 1, 1), 
            this.renderMode = Yr.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            Yr.SHADERDEFINE_DIFFUSEMAP = H.getDefineByName("DIFFUSEMAP"), Yr.SHADERDEFINE_TINTCOLOR = H.getDefineByName("TINTCOLOR"), 
            Yr.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG"), Yr.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Yr.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Yr.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Yr.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Yr.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Yr.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Yr.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Yr.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Yr.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
              case Yr.RENDERMODE_ADDTIVE:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Q.CULL_NONE, 
                this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE, 
                this.alphaTest = !1, this._shaderValues.addDefine(Yr.SHADERDEFINE_ADDTIVEFOG);
                break;

              case Yr.RENDERMODE_ALPHABLENDED:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Q.CULL_NONE, 
                this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, 
                this.alphaTest = !1, this._shaderValues.removeDefine(Yr.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("ShurikenParticleMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(Yr.TINTCOLOR);
        }
        set color(e) {
            e ? this._shaderValues.addDefine(Yr.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(Yr.SHADERDEFINE_TINTCOLOR), 
            this._shaderValues.setVector(Yr.TINTCOLOR, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Yr.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Yr.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Yr.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(Yr.TILINGOFFSET, e);
        }
        get texture() {
            return this._shaderValues.getTexture(Yr.DIFFUSETEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(Yr.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(Yr.SHADERDEFINE_DIFFUSEMAP), 
            this._shaderValues.setTexture(Yr.DIFFUSETEXTURE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Yr.DEPTH_WRITE);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Yr.DEPTH_WRITE, e);
        }
        get cull() {
            return this._shaderValues.getInt(Yr.CULL);
        }
        set cull(e) {
            this._shaderValues.setInt(Yr.CULL, e);
        }
        get blend() {
            return this._shaderValues.getInt(Yr.BLEND);
        }
        set blend(e) {
            this._shaderValues.setInt(Yr.BLEND, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Yr.BLEND_SRC);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Yr.BLEND_SRC, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Yr.BLEND_DST);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Yr.BLEND_DST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Yr.DEPTH_TEST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Yr.DEPTH_TEST, e);
        }
        clone() {
            var e = new Yr();
            return this.cloneTo(e), e;
        }
    }
    Yr.RENDERMODE_ALPHABLENDED = 0, Yr.RENDERMODE_ADDTIVE = 1, Yr.DIFFUSETEXTURE = H.propertyNameToID("u_texture"), 
    Yr.TINTCOLOR = H.propertyNameToID("u_Tintcolor"), Yr.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), 
    Yr.CULL = H.propertyNameToID("s_Cull"), Yr.BLEND = H.propertyNameToID("s_Blend"), 
    Yr.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), Yr.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    Yr.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), Yr.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class jr extends kt {
        constructor(e) {
            super(e), this._finalGravity = new n(), this._tempRotationMatrix = new y(), this._mesh = null, 
            this.stretchedBillboardCameraSpeedScale = 0, this.stretchedBillboardSpeedScale = 0, 
            this.stretchedBillboardLengthScale = 2, this._defaultBoundBox = new bt(new n(), new n()), 
            this.renderMode = 0, this._supportOctree = !1;
        }
        get renderMode() {
            return this._renderMode;
        }
        set renderMode(e) {
            if (this._renderMode !== e) {
                var t = this._shaderValues;
                switch (this._renderMode) {
                  case 0:
                    t.removeDefine(Xr.SHADERDEFINE_RENDERMODE_BILLBOARD);
                    break;

                  case 1:
                    t.removeDefine(Xr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                    break;

                  case 2:
                    t.removeDefine(Xr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                    break;

                  case 3:
                    t.removeDefine(Xr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                    break;

                  case 4:
                    t.removeDefine(Xr.SHADERDEFINE_RENDERMODE_MESH);
                }
                switch (this._renderMode = e, e) {
                  case 0:
                    t.addDefine(Xr.SHADERDEFINE_RENDERMODE_BILLBOARD);
                    break;

                  case 1:
                    t.addDefine(Xr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                    break;

                  case 2:
                    t.addDefine(Xr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                    break;

                  case 3:
                    t.addDefine(Xr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                    break;

                  case 4:
                    t.addDefine(Xr.SHADERDEFINE_RENDERMODE_MESH);
                    break;

                  default:
                    throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                }
                var r = this._owner.particleSystem;
                r && r._initBufferDatas();
            }
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e, 
            e && e._addReference(), this._owner.particleSystem._initBufferDatas());
        }
        _calculateBoundingBox() {
            if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE, 
            e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (r = this._bounds.getMax()).x = Number.MAX_VALUE, 
            r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, this._bounds.setMax(r), t.Render.supportWebGLPlusCulling) {
                var e = this._bounds.getMin(), r = this._bounds.getMax(), i = Ce._cullingBuffer;
                i[this._cullingBufferIndex + 1] = e.x, i[this._cullingBufferIndex + 2] = e.y, i[this._cullingBufferIndex + 3] = e.z, 
                i[this._cullingBufferIndex + 4] = r.x, i[this._cullingBufferIndex + 5] = r.y, i[this._cullingBufferIndex + 6] = r.z;
            }
        }
        _needRender(e, t) {
            return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
        }
        _renderUpdate(e, t) {
            var r = this._owner.particleSystem, i = this._shaderValues, a = this._owner.transform;
            switch (r.simulationSpace) {
              case 0:
                break;

              case 1:
                i.setVector3(Xr.WORLDPOSITION, a.position), i.setQuaternion(Xr.WORLDROTATION, a.rotation);
                break;

              default:
                throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
            switch (r.scaleMode) {
              case 0:
                var s = a.getWorldLossyScale();
                i.setVector3(Xr.POSITIONSCALE, s), i.setVector3(Xr.SIZESCALE, s);
                break;

              case 1:
                var o = a.localScale;
                i.setVector3(Xr.POSITIONSCALE, o), i.setVector3(Xr.SIZESCALE, o);
                break;

              case 2:
                i.setVector3(Xr.POSITIONSCALE, a.getWorldLossyScale()), i.setVector3(Xr.SIZESCALE, n._ONE);
            }
            n.scale(_t.gravity, r.gravityModifier, this._finalGravity), i.setVector3(Xr.GRAVITY, this._finalGravity), 
            i.setInt(Xr.SIMULATIONSPACE, r.simulationSpace), i.setBool(Xr.THREEDSTARTROTATION, r.threeDStartRotation), 
            i.setInt(Xr.SCALINGMODE, r.scaleMode), i.setNumber(Xr.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale), 
            i.setNumber(Xr.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale), 
            i.setNumber(Xr.CURRENTTIME, r._currentTime);
        }
        get bounds() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
            this._bounds;
        }
        _destroy() {
            super._destroy(), this._mesh && (this._mesh._removeReference(), this._mesh = null);
        }
    }
    class Zr {
        constructor() {}
    }
    Zr.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, Zr.PARTICLE_POSITION0 = 1, Zr.PARTICLE_COLOR0 = 2, 
    Zr.PARTICLE_TEXTURECOORDINATE0 = 3, Zr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, 
    Zr.PARTICLE_DIRECTIONTIME = 5, Zr.PARTICLE_STARTCOLOR0 = 6, Zr.PARTICLE_ENDCOLOR0 = 7, 
    Zr.PARTICLE_STARTSIZE = 8, Zr.PARTICLE_STARTROTATION = 9, Zr.PARTICLE_STARTSPEED = 10, 
    Zr.PARTICLE_RANDOM0 = 11, Zr.PARTICLE_RANDOM1 = 12, Zr.PARTICLE_SIMULATIONWORLDPOSTION = 13, 
    Zr.PARTICLE_SIMULATIONWORLDROTATION = 14;
    class qr extends Zr {
        static get vertexDeclaration() {
            return qr._vertexDeclaration;
        }
        static __init__() {
            qr._vertexDeclaration = new We(152, [ new ke(0, He.Vector4, Zr.PARTICLE_CORNERTEXTURECOORDINATE0), new ke(16, He.Vector4, Zr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new ke(32, He.Vector4, Zr.PARTICLE_DIRECTIONTIME), new ke(48, He.Vector4, Zr.PARTICLE_STARTCOLOR0), new ke(64, He.Vector3, Zr.PARTICLE_STARTSIZE), new ke(76, He.Vector3, Zr.PARTICLE_STARTROTATION), new ke(88, He.Single, Zr.PARTICLE_STARTSPEED), new ke(92, He.Vector4, Zr.PARTICLE_RANDOM0), new ke(108, He.Vector4, Zr.PARTICLE_RANDOM1), new ke(124, He.Vector3, Zr.PARTICLE_SIMULATIONWORLDPOSTION), new ke(136, He.Vector4, Zr.PARTICLE_SIMULATIONWORLDROTATION) ]);
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get positionStartLifeTime() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
        constructor(e, t, r, i, a, n, s, o, l, _, h, c, d, u) {
            super(), this._cornerTextureCoordinate = e, this._positionStartLifeTime = t, this._velocity = r, 
            this._startColor = i, this._startSize = a, this._startRotation0 = n, this._startRotation1 = s, 
            this._startRotation2 = o, this._startLifeTime = l, this._time = _, this._startSpeed = h, 
            this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = u;
        }
    }
    class Qr extends Zr {
        static __init__() {
            Qr._vertexDeclaration = new We(172, [ new ke(0, He.Vector3, Zr.PARTICLE_POSITION0), new ke(12, He.Vector4, Zr.PARTICLE_COLOR0), new ke(28, He.Vector2, Zr.PARTICLE_TEXTURECOORDINATE0), new ke(36, He.Vector4, Zr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new ke(52, He.Vector4, Zr.PARTICLE_DIRECTIONTIME), new ke(68, He.Vector4, Zr.PARTICLE_STARTCOLOR0), new ke(84, He.Vector3, Zr.PARTICLE_STARTSIZE), new ke(96, He.Vector3, Zr.PARTICLE_STARTROTATION), new ke(108, He.Single, Zr.PARTICLE_STARTSPEED), new ke(112, He.Vector4, Zr.PARTICLE_RANDOM0), new ke(128, He.Vector4, Zr.PARTICLE_RANDOM1), new ke(144, He.Vector3, Zr.PARTICLE_SIMULATIONWORLDPOSTION), new ke(156, He.Vector4, Zr.PARTICLE_SIMULATIONWORLDROTATION) ]);
        }
        static get vertexDeclaration() {
            return Qr._vertexDeclaration;
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get position() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
        constructor(e, t, r, i, a, n, s, o, l, _, h, c, d, u) {
            super(), this._cornerTextureCoordinate = e, this._positionStartLifeTime = t, this._velocity = r, 
            this._startColor = i, this._startSize = a, this._startRotation0 = n, this._startRotation1 = s, 
            this._startRotation2 = o, this._startLifeTime = l, this._time = _, this._startSpeed = h, 
            this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = u;
        }
    }
    class Kr {
        constructor(e) {
            this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = e, 
            this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        static getFloatFromInt(e) {
            return 1 / 8388607 * (8388607 & e);
        }
        static getByteFromInt(e) {
            return (8388607 & e) >>> 15;
        }
        get seed() {
            return this.seeds[0];
        }
        set seed(e) {
            this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        getUint() {
            return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1], 
            this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8, 
            this.seeds[3];
        }
        getFloat() {
            return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
        }
        getSignedFloat() {
            return 2 * this.getFloat() - 1;
        }
    }
    class Jr {
        constructor() {
            this._emissionRate = 10, this._destroyed = !1, this._bursts = [];
        }
        set emissionRate(e) {
            if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
            this._emissionRate = e;
        }
        get emissionRate() {
            return this._emissionRate;
        }
        get destroyed() {
            return this._destroyed;
        }
        destroy() {
            this._bursts = null, this._destroyed = !0;
        }
        getBurstsCount() {
            return this._bursts.length;
        }
        getBurstByIndex(e) {
            return this._bursts[e];
        }
        addBurst(e) {
            var t = this._bursts.length;
            if (t > 0) for (var r = 0; r < t; r++) this._bursts[r].time > e.time && this._bursts.splice(r, 0, e);
            this._bursts.push(e);
        }
        removeBurst(e) {
            var t = this._bursts.indexOf(e);
            -1 !== t && this._bursts.splice(t, 1);
        }
        removeBurstByIndex(e) {
            this._bursts.splice(e, 1);
        }
        clearBurst() {
            this._bursts.length = 0;
        }
        cloneTo(e) {
            var t = e, r = t._bursts;
            r.length = this._bursts.length;
            for (var i = 0, a = this._bursts.length; i < a; i++) {
                var n = r[i];
                n ? this._bursts[i].cloneTo(n) : r[i] = this._bursts[i].clone();
            }
            t._emissionRate = this._emissionRate, t.enable = this.enable;
        }
        clone() {
            var e = new Jr();
            return this.cloneTo(e), e;
        }
    }
    class $r {
        constructor() {}
        static _getStartLifetimeFromGradient(e, r) {
            for (var i = 1, a = e.gradientCount; i < a; i++) {
                var n = e.getKeyByIndex(i);
                if (n >= r) {
                    var s = e.getKeyByIndex(i - 1), o = (r - s) / (n - s);
                    return t.MathUtil.lerp(e.getValueByIndex(i - 1), e.getValueByIndex(i), o);
                }
            }
            throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
        }
        static _randomInvertRoationArray(e, t, r, i, a) {
            var n;
            i ? (i.seed = a[6], n = i.getFloat(), a[6] = i.seed) : n = Math.random(), n < r ? (t.x = -e.x, 
            t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
        }
        static _randomInvertRoation(e, t, r, i) {
            var a;
            return r ? (r.seed = i[6], a = r.getFloat(), i[6] = r.seed) : a = Math.random(), 
            a < t && (e = -e), e;
        }
        static create(e, r, i) {
            var n = e.autoRandomSeed, s = e._rand, o = e._randomSeeds;
            switch (e.startColorType) {
              case 0:
                var l = e.startColorConstant;
                $r.startColor.x = l.x, $r.startColor.y = l.y, $r.startColor.z = l.z, $r.startColor.w = l.w;
                break;

              case 2:
                n ? a.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), $r.startColor) : (s.seed = o[3], 
                a.lerp(e.startColorConstantMin, e.startColorConstantMax, s.getFloat(), $r.startColor), 
                o[3] = s.seed);
            }
            var _ = e.colorOverLifetime;
            if (_ && _.enable) {
                var h = _.color;
                switch (h.type) {
                  case 0:
                    $r.startColor.x = $r.startColor.x * h.constant.x, $r.startColor.y = $r.startColor.y * h.constant.y, 
                    $r.startColor.z = $r.startColor.z * h.constant.z, $r.startColor.w = $r.startColor.w * h.constant.w;
                    break;

                  case 2:
                    var c;
                    n ? c = Math.random() : (s.seed = o[10], c = s.getFloat(), o[10] = s.seed);
                    var d = h.constantMin, u = h.constantMax;
                    $r.startColor.x = $r.startColor.x * t.MathUtil.lerp(d.x, u.x, c), $r.startColor.y = $r.startColor.y * t.MathUtil.lerp(d.y, u.y, c), 
                    $r.startColor.z = $r.startColor.z * t.MathUtil.lerp(d.z, u.z, c), $r.startColor.w = $r.startColor.w * t.MathUtil.lerp(d.w, u.w, c);
                }
            }
            var m = $r.startSize;
            switch (e.startSizeType) {
              case 0:
                if (e.threeDStartSize) {
                    var f = e.startSizeConstantSeparate;
                    m[0] = f.x, m[1] = f.y, m[2] = f.z;
                } else m[0] = m[1] = m[2] = e.startSizeConstant;
                break;

              case 2:
                if (e.threeDStartSize) {
                    var E = e.startSizeConstantMinSeparate, T = e.startSizeConstantMaxSeparate;
                    n ? (m[0] = t.MathUtil.lerp(E.x, T.x, Math.random()), m[1] = t.MathUtil.lerp(E.y, T.y, Math.random()), 
                    m[2] = t.MathUtil.lerp(E.z, T.z, Math.random())) : (s.seed = o[4], m[0] = t.MathUtil.lerp(E.x, T.x, s.getFloat()), 
                    m[1] = t.MathUtil.lerp(E.y, T.y, s.getFloat()), m[2] = t.MathUtil.lerp(E.z, T.z, s.getFloat()), 
                    o[4] = s.seed);
                } else n ? m[0] = m[1] = m[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (s.seed = o[4], 
                m[0] = m[1] = m[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, s.getFloat()), 
                o[4] = s.seed);
            }
            var p = e.sizeOverLifetime;
            if (p && p.enable && 1 === p.size.type) {
                var g, S = p.size;
                if (S.separateAxes) n ? (m[0] = m[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, Math.random()), 
                m[1] = m[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, Math.random()), 
                m[2] = m[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, Math.random())) : (s.seed = o[11], 
                m[0] = m[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, s.getFloat()), 
                m[1] = m[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, s.getFloat()), 
                m[2] = m[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, s.getFloat()), 
                o[11] = s.seed); else n ? g = t.MathUtil.lerp(S.constantMin, S.constantMax, Math.random()) : (s.seed = o[11], 
                g = t.MathUtil.lerp(S.constantMin, S.constantMax, s.getFloat()), o[11] = s.seed), 
                m[0] = m[0] * g, m[1] = m[1] * g, m[2] = m[2] * g;
            }
            var R = r.renderMode;
            if (1 !== R) switch (e.startRotationType) {
              case 0:
                if (e.threeDStartRotation) {
                    var v = e.startRotationConstantSeparate, x = $r._tempVector30;
                    $r._randomInvertRoationArray(v, x, e.randomizeRotationDirection, n ? null : s, o), 
                    $r.startRotation[0] = x.x, $r.startRotation[1] = x.y, $r.startRotation[2] = 4 !== R ? -x.z : x.z;
                } else $r.startRotation[0] = $r._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, n ? null : s, o), 
                $r.startRotation[1] = 0, $r.startRotation[2] = 0;
                break;

              case 2:
                if (e.threeDStartRotation) {
                    var I = e.startRotationConstantMinSeparate, A = e.startRotationConstantMaxSeparate, L = $r._tempVector30;
                    n ? (L.x = t.MathUtil.lerp(I.x, A.x, Math.random()), L.y = t.MathUtil.lerp(I.y, A.y, Math.random()), 
                    L.z = t.MathUtil.lerp(I.z, A.z, Math.random())) : (s.seed = o[5], L.x = t.MathUtil.lerp(I.x, A.x, s.getFloat()), 
                    L.y = t.MathUtil.lerp(I.y, A.y, s.getFloat()), L.z = t.MathUtil.lerp(I.z, A.z, s.getFloat()), 
                    o[5] = s.seed), $r._randomInvertRoationArray(L, L, e.randomizeRotationDirection, n ? null : s, o), 
                    $r.startRotation[0] = L.x, $r.startRotation[1] = L.y, $r.startRotation[2] = 4 !== R ? -L.z : L.z;
                } else n ? $r.startRotation[0] = $r._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, n ? null : s, o) : (s.seed = o[5], 
                $r.startRotation[0] = $r._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, s.getFloat()), e.randomizeRotationDirection, n ? null : s, o), 
                o[5] = s.seed);
            }
            switch (e.startLifetimeType) {
              case 0:
                $r.startLifeTime = e.startLifetimeConstant;
                break;

              case 1:
                $r.startLifeTime = $r._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                break;

              case 2:
                n ? $r.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (s.seed = o[7], 
                $r.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, s.getFloat()), 
                o[7] = s.seed);
                break;

              case 3:
                var C = e.emissionTime;
                n ? $r.startLifeTime = t.MathUtil.lerp($r._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, C), $r._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, C), Math.random()) : (s.seed = o[7], 
                $r.startLifeTime = t.MathUtil.lerp($r._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, C), $r._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, C), s.getFloat()), 
                o[7] = s.seed);
            }
            var D = e.textureSheetAnimation;
            if (D && D.enable) {
                var M, y = D.tiles, O = y.x, N = y.y, b = 1 / O, P = 1 / N, w = D.startFrame;
                switch (w.type) {
                  case 0:
                    M = w.constant;
                    break;

                  case 1:
                    n ? M = t.MathUtil.lerp(w.constantMin, w.constantMax, Math.random()) : (s.seed = o[14], 
                    M = t.MathUtil.lerp(w.constantMin, w.constantMax, s.getFloat()), o[14] = s.seed);
                }
                var V = D.frame, B = D.cycles;
                switch (V.type) {
                  case 0:
                    M += V.constant * B;
                    break;

                  case 2:
                    n ? M += t.MathUtil.lerp(V.constantMin, V.constantMax, Math.random()) * B : (s.seed = o[15], 
                    M += t.MathUtil.lerp(V.constantMin, V.constantMax, s.getFloat()) * B, o[15] = s.seed);
                }
                var F = 0;
                switch (D.type) {
                  case 0:
                    F = Math.floor(M / O);
                    break;

                  case 1:
                    D.randomRow ? n ? F = Math.floor(Math.random() * N) : (s.seed = o[13], F = Math.floor(s.getFloat() * N), 
                    o[13] = s.seed) : F = D.rowIndex;
                }
                var U = Math.floor(M % O);
                $r.startUVInfo = $r.startUVInfo, $r.startUVInfo[0] = b, $r.startUVInfo[1] = P, $r.startUVInfo[2] = U * b, 
                $r.startUVInfo[3] = F * P;
            } else $r.startUVInfo = $r.startUVInfo, $r.startUVInfo[0] = 1, $r.startUVInfo[1] = 1, 
            $r.startUVInfo[2] = 0, $r.startUVInfo[3] = 0;
        }
    }
    $r._tempVector30 = new n(), $r.startColor = new a(), $r.startSize = new Float32Array(3), 
    $r.startRotation = new Float32Array(3), $r.startUVInfo = new Float32Array(4);
    class ei extends wt {
        constructor(e) {
            super(), this._boundingSphere = null, this._boundingBox = null, this._boundingBoxCorners = null, 
            this._owner = null, this._ownerRender = null, this._vertices = null, this._floatCountPerVertex = 0, 
            this._startLifeTimeIndex = 0, this._timeIndex = 0, this._simulateUpdate = !1, this._firstActiveElement = 0, 
            this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, 
            this._drawCounter = 0, this._bufferMaxParticles = 0, this._emission = null, this._shape = null, 
            this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1, this._playStartDelay = 0, 
            this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0, this._burstsIndex = 0, 
            this._velocityOverLifetime = null, this._colorOverLifetime = null, this._sizeOverLifetime = null, 
            this._rotationOverLifetime = null, this._textureSheetAnimation = null, this._startLifetimeType = 0, 
            this._startLifetimeConstant = 0, this._startLifeTimeGradient = null, this._startLifetimeConstantMin = 0, 
            this._startLifetimeConstantMax = 0, this._startLifeTimeGradientMin = null, this._startLifeTimeGradientMax = null, 
            this._maxStartLifetime = 0, this._uvLength = new i(), this._vertexStride = 0, this._indexStride = 0, 
            this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = new Ge(), 
            this._currentTime = 0, this._startUpdateLoopCount = 0, this._rand = null, this._randomSeeds = null, 
            this.duration = 0, this.looping = !1, this.prewarm = !1, this.startDelayType = 0, 
            this.startDelay = 0, this.startDelayMin = 0, this.startDelayMax = 0, this.startSpeedType = 0, 
            this.startSpeedConstant = 0, this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 0, 
            this.threeDStartSize = !1, this.startSizeType = 0, this.startSizeConstant = 0, this.startSizeConstantSeparate = null, 
            this.startSizeConstantMin = 0, this.startSizeConstantMax = 0, this.startSizeConstantMinSeparate = null, 
            this.startSizeConstantMaxSeparate = null, this.threeDStartRotation = !1, this.startRotationType = 0, 
            this.startRotationConstant = 0, this.startRotationConstantSeparate = null, this.startRotationConstantMin = 0, 
            this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = null, 
            this.startRotationConstantMaxSeparate = null, this.randomizeRotationDirection = 0, 
            this.startColorType = 0, this.startColorConstant = new a(1, 1, 1, 1), this.startColorConstantMin = new a(0, 0, 0, 0), 
            this.startColorConstantMax = new a(1, 1, 1, 1), this.gravityModifier = 0, this.simulationSpace = 0, 
            this.simulationSpeed = 1, this.scaleMode = 0, this.playOnAwake = !1, this.randomSeed = null, 
            this.autoRandomSeed = !1, this.isPerformanceMode = !1, this._firstActiveElement = 0, 
            this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, 
            this._owner = e, this._ownerRender = e.particleRenderer, this._boundingBoxCorners = [], 
            this._boundingSphere = new Jt(new n(), Number.MAX_VALUE), this._boundingBox = new bt(new n(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new n(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)), 
            this._currentTime = 0, this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1, 
            this._burstsIndex = 0, this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0, 
            this._simulateUpdate = !1, this._bufferMaxParticles = 1, this.duration = 5, this.looping = !0, 
            this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0, 
            this.startDelayMax = 0, this._startLifetimeType = 0, this._startLifetimeConstant = 5, 
            this._startLifeTimeGradient = new yr(), this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 5, 
            this._startLifeTimeGradientMin = new yr(), this._startLifeTimeGradientMax = new yr(), 
            this._maxStartLifetime = 5, this.startSpeedType = 0, this.startSpeedConstant = 5, 
            this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 5, this.threeDStartSize = !1, 
            this.startSizeType = 0, this.startSizeConstant = 1, this.startSizeConstantSeparate = new n(1, 1, 1), 
            this.startSizeConstantMin = 0, this.startSizeConstantMax = 1, this.startSizeConstantMinSeparate = new n(0, 0, 0), 
            this.startSizeConstantMaxSeparate = new n(1, 1, 1), this.threeDStartRotation = !1, 
            this.startRotationType = 0, this.startRotationConstant = 0, this.startRotationConstantSeparate = new n(0, 0, 0), 
            this.startRotationConstantMin = 0, this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = new n(0, 0, 0), 
            this.startRotationConstantMaxSeparate = new n(0, 0, 0), this.gravityModifier = 0, 
            this.simulationSpace = 1, this.scaleMode = 0, this.playOnAwake = !0, this._rand = new Kr(0), 
            this.autoRandomSeed = !0, this.randomSeed = new Uint32Array(1), this._randomSeeds = new Uint32Array(ei._RANDOMOFFSET.length), 
            this.isPerformanceMode = !0, this._emission = new Jr(), this._emission.enable = !0;
        }
        get maxParticles() {
            return this._bufferMaxParticles - 1;
        }
        set maxParticles(e) {
            var t = e + 1;
            t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
        }
        get emission() {
            return this._emission;
        }
        get aliveParticleCount() {
            return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
        }
        get emissionTime() {
            return this._emissionTime > this.duration ? this.duration : this._emissionTime;
        }
        get shape() {
            return this._shape;
        }
        set shape(e) {
            this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(Xr.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(Xr.SHADERDEFINE_SHAPE), 
            this._shape = e);
        }
        get isAlive() {
            return !!(this._isPlaying || this.aliveParticleCount > 0);
        }
        get isEmitting() {
            return this._isEmitting;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        get isPaused() {
            return this._isPaused;
        }
        get startLifetimeType() {
            return this._startLifetimeType;
        }
        set startLifetimeType(e) {
            var t, r;
            switch (this.startLifetimeType) {
              case 0:
                this._maxStartLifetime = this.startLifetimeConstant;
                break;

              case 1:
                this._maxStartLifetime = -Number.MAX_VALUE;
                var i = i;
                for (t = 0, r = i.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                break;

              case 2:
                this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                break;

              case 3:
                this._maxStartLifetime = -Number.MAX_VALUE;
                var a = a;
                for (t = 0, r = a.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
                var n = n;
                for (t = 0, r = n.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, n.getValueByIndex(t));
            }
            this._startLifetimeType = e;
        }
        get startLifetimeConstant() {
            return this._startLifetimeConstant;
        }
        set startLifetimeConstant(e) {
            0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
        }
        get startLifeTimeGradient() {
            return this._startLifeTimeGradient;
        }
        set startLifeTimeGradient(e) {
            if (1 === this._startLifetimeType) {
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (var t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradient = e;
        }
        get startLifetimeConstantMin() {
            return this._startLifetimeConstantMin;
        }
        set startLifetimeConstantMin(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)), 
            this._startLifetimeConstantMin = e;
        }
        get startLifetimeConstantMax() {
            return this._startLifetimeConstantMax;
        }
        set startLifetimeConstantMax(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)), 
            this._startLifetimeConstantMax = e;
        }
        get startLifeTimeGradientMin() {
            return this._startLifeTimeGradientMin;
        }
        set startLifeTimeGradientMin(e) {
            if (3 === this._startLifetimeType) {
                var t, r;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                for (t = 0, r = this._startLifeTimeGradientMax.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
            }
            this._startLifeTimeGradientMin = e;
        }
        get startLifeTimeGradientMax() {
            return this._startLifeTimeGradientMax;
        }
        set startLifeTimeGradientMax(e) {
            if (3 === this._startLifetimeType) {
                var t, r;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = this._startLifeTimeGradientMin.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                for (t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradientMax = e;
        }
        get velocityOverLifetime() {
            return this._velocityOverLifetime;
        }
        set velocityOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.velocity, i = r.type;
                if (e.enable) switch (i) {
                  case 0:
                    t.addDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                    break;

                  case 1:
                    t.addDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                    break;

                  case 2:
                    t.addDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                    break;

                  case 3:
                    t.addDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                } else t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
                t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                switch (i) {
                  case 0:
                    t.setVector3(Xr.VOLVELOCITYCONST, r.constant);
                    break;

                  case 1:
                    t.setBuffer(Xr.VOLVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Xr.VOLVELOCITYGRADIENTY, r.gradientY._elements), 
                    t.setBuffer(Xr.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
                    break;

                  case 2:
                    t.setVector3(Xr.VOLVELOCITYCONST, r.constantMin), t.setVector3(Xr.VOLVELOCITYCONSTMAX, r.constantMax);
                    break;

                  case 3:
                    t.setBuffer(Xr.VOLVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Xr.VOLVELOCITYGRADIENTXMAX, r.gradientXMax._elements), 
                    t.setBuffer(Xr.VOLVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Xr.VOLVELOCITYGRADIENTYMAX, r.gradientYMax._elements), 
                    t.setBuffer(Xr.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Xr.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements);
                }
                t.setInt(Xr.VOLSPACETYPE, e.space);
            } else t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
            t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
            this._velocityOverLifetime = e;
        }
        get colorOverLifetime() {
            return this._colorOverLifetime;
        }
        set colorOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.color;
                if (e.enable) switch (r.type) {
                  case 1:
                    t.addDefine(Xr.SHADERDEFINE_COLOROVERLIFETIME);
                    break;

                  case 3:
                    t.addDefine(Xr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                } else t.removeDefine(Xr.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Xr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                switch (r.type) {
                  case 1:
                    var i = r.gradient;
                    t.setBuffer(Xr.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Xr.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements);
                    break;

                  case 3:
                    var a = r.gradientMin, n = r.gradientMax;
                    t.setBuffer(Xr.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Xr.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements), 
                    t.setBuffer(Xr.MAXCOLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Xr.MAXCOLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
                }
            } else t.removeDefine(Xr.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Xr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME), 
            t.setBuffer(Xr.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Xr.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements), 
            t.setBuffer(Xr.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Xr.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements), 
            t.setBuffer(Xr.MAXCOLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Xr.MAXCOLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
            this._colorOverLifetime = e;
        }
        get sizeOverLifetime() {
            return this._sizeOverLifetime;
        }
        set sizeOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.size, i = r.separateAxes, a = r.type;
                if (e.enable) switch (a) {
                  case 0:
                    i ? t.addDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                    break;

                  case 2:
                    i ? t.addDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                } else t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
                t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                switch (a) {
                  case 0:
                    i ? (t.setBuffer(Xr.SOLSIZEGRADIENTX, r.gradientX._elements), t.setBuffer(Xr.SOLSIZEGRADIENTY, r.gradientY._elements), 
                    t.setBuffer(Xr.SOLSizeGradientZ, r.gradientZ._elements)) : t.setBuffer(Xr.SOLSIZEGRADIENT, r.gradient._elements);
                    break;

                  case 2:
                    i ? (t.setBuffer(Xr.SOLSIZEGRADIENTX, r.gradientXMin._elements), t.setBuffer(Xr.SOLSIZEGRADIENTXMAX, r.gradientXMax._elements), 
                    t.setBuffer(Xr.SOLSIZEGRADIENTY, r.gradientYMin._elements), t.setBuffer(Xr.SOLSIZEGRADIENTYMAX, r.gradientYMax._elements), 
                    t.setBuffer(Xr.SOLSizeGradientZ, r.gradientZMin._elements), t.setBuffer(Xr.SOLSizeGradientZMAX, r.gradientZMax._elements)) : (t.setBuffer(Xr.SOLSIZEGRADIENT, r.gradientMin._elements), 
                    t.setBuffer(Xr.SOLSizeGradientMax, r.gradientMax._elements));
                }
            } else t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
            t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
            this._sizeOverLifetime = e;
        }
        get rotationOverLifetime() {
            return this._rotationOverLifetime;
        }
        set rotationOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.angularVelocity;
                if (!r) return;
                var i = r.separateAxes, a = r.type;
                if (e.enable) switch (i ? t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIME), 
                a) {
                  case 0:
                    t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                    break;

                  case 1:
                    t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                    break;

                  case 2:
                    t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                    break;

                  case 3:
                    t.addDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                } else t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
                t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
                t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                switch (a) {
                  case 0:
                    i ? t.setVector3(Xr.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantSeparate) : t.setNumber(Xr.ROLANGULARVELOCITYCONST, r.constant);
                    break;

                  case 1:
                    i ? (t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTY, r.gradientY._elements), 
                    t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
                    break;

                  case 2:
                    i ? (t.setVector3(Xr.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantMinSeparate), t.setVector3(Xr.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r.constantMaxSeparate)) : (t.setNumber(Xr.ROLANGULARVELOCITYCONST, r.constantMin), 
                    t.setNumber(Xr.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
                    break;

                  case 3:
                    i ? (t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax._elements), 
                    t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax._elements), 
                    t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax._elements)) : (t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENT, r.gradientMin._elements), 
                    t.setBuffer(Xr.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements));
                }
            } else t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
            t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
            t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
            this._rotationOverLifetime = e;
        }
        get textureSheetAnimation() {
            return this._textureSheetAnimation;
        }
        set textureSheetAnimation(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.frame, i = r.type;
                if (e.enable) switch (i) {
                  case 1:
                    t.addDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                    break;

                  case 3:
                    t.addDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                } else t.removeDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                if (1 === i || 3 === i) {
                    t.setNumber(Xr.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                    var a = e.tiles, n = this._uvLength;
                    n.x = 1 / a.x, n.y = 1 / a.y, t.setVector2(Xr.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                }
                switch (i) {
                  case 1:
                    t.setBuffer(Xr.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData._elements);
                    break;

                  case 3:
                    t.setBuffer(Xr.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeDataMin._elements), 
                    t.setBuffer(Xr.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax._elements);
                }
            } else t.removeDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Xr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
            this._textureSheetAnimation = e;
        }
        _getVertexBuffer(e = 0) {
            return 0 === e ? this._vertexBuffer : null;
        }
        _getIndexBuffer() {
            return this._indexBuffer;
        }
        _generateBoundingSphere() {
            var e = this._boundingSphere.center;
            e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
        }
        _generateBoundingBox() {
            var e, t, r, i, a, s, o, l, _, h = this._owner.particleRenderer, c = this._boundingBox.min, d = this._boundingBox.max;
            switch (this.startLifetimeType) {
              case 0:
                r = this.startLifetimeConstant;
                break;

              case 1:
                r = -Number.MAX_VALUE;
                var u = u;
                for (e = 0, t = u.gradientCount; e < t; e++) r = Math.max(r, u.getValueByIndex(e));
                break;

              case 2:
                r = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                break;

              case 3:
                r = -Number.MAX_VALUE;
                var m = m;
                for (e = 0, t = m.gradientCount; e < t; e++) r = Math.max(r, m.getValueByIndex(e));
                var f = f;
                for (e = 0, t = f.gradientCount; e < t; e++) r = Math.max(r, f.getValueByIndex(e));
            }
            switch (this.startSpeedType) {
              case 0:
                i = a = this.startSpeedConstant;
                break;

              case 1:
                break;

              case 2:
                i = this.startLifetimeConstantMin, a = this.startLifetimeConstantMax;
            }
            this._shape && this._shape.enable || (s = o = n._ZERO, l = n._ZERO, _ = n._UnitZ);
            var E, T, p = new n(l.x * i, l.y * i, l.z * i), g = new n(_.x * a, _.y * a, _.z * a);
            if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
                var S = this._velocityOverLifetime.velocity;
                switch (S.type) {
                  case 0:
                    S.constant;
                    break;

                  case 1:
                    new n(S.gradientX.getAverageValue(), S.gradientY.getAverageValue(), S.gradientZ.getAverageValue());
                    break;

                  case 2:
                    S.constantMin, S.constantMax;
                    break;

                  case 3:
                    new n(S.gradientXMin.getAverageValue(), S.gradientYMin.getAverageValue(), S.gradientZMin.getAverageValue()), 
                    new n(S.gradientXMax.getAverageValue(), S.gradientYMax.getAverageValue(), S.gradientZMax.getAverageValue());
                }
            }
            var R, v, x, I, A = this._owner.transform, L = A.position, C = ei._tempVector39, D = h.renderMode;
            switch (this.scaleMode) {
              case 0:
                var M = A.getWorldLossyScale();
                E = M, C.x = M.x, C.y = M.z, C.z = M.y, 1 === D && (T = M);
                break;

              case 1:
                var y = A.localScale;
                E = y, C.x = y.x, C.y = y.z, C.z = y.y, 1 === D && (T = y);
                break;

              case 2:
                E = A.getWorldLossyScale(), C.x = C.y = C.z = 1, 1 === D && (T = n._ONE);
            }
            switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (R = new n(p.x * r, p.y * r, p.z * r), 
            v = new n(g.x * r, g.y * r, g.z * r), 2 != this.scaleMode ? (n.add(s, R, c), n.multiply(E, c, c), 
            n.add(o, v, d), n.multiply(E, d, d)) : (n.multiply(E, s, c), n.add(c, R, c), n.multiply(E, o, d), 
            n.add(d, v, d))), this.simulationSpace) {
              case 0:
                break;

              case 1:
                n.add(c, L, c), n.add(d, L, d);
            }
            switch (this.startSizeType) {
              case 0:
                if (this.threeDStartSize) {
                    var O = O;
                    x = Math.max(O.x, O.y), 1 === D && (I = O.y);
                } else x = this.startSizeConstant, 1 === D && (I = this.startSizeConstant);
                break;

              case 1:
                break;

              case 2:
                if (this.threeDStartSize) {
                    var N = N;
                    x = Math.max(N.x, N.y), 1 === D && (I = N.y);
                } else x = this.startSizeConstantMax, 1 === D && (I = this.startSizeConstantMax);
            }
            if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
                this._sizeOverLifetime.size;
                x *= this._sizeOverLifetime.size.getMaxSizeInGradient();
            }
            var b, P, w = ei._tempVector30;
            switch (D) {
              case 0:
                b = x * ei.halfKSqrtOf2, n.scale(C, x, w), n.subtract(c, w, c), n.add(d, w, d);
                break;

              case 1:
                var V = ei._tempVector31, B = ei._tempVector32, F = ei._tempVector33, U = ei._tempVector34;
                this._velocityOverLifetime && this._velocityOverLifetime.enable || (n.multiply(T, g, B), 
                n.multiply(T, p, F));
                var G = I * h.stretchedBillboardLengthScale, z = n.scalarLength(B) * h.stretchedBillboardSpeedScale + G, H = n.scalarLength(F) * h.stretchedBillboardSpeedScale + G, W = ei._tempVector35, k = ei._tempVector36;
                n.normalize(B, W), n.scale(W, z, U), n.subtract(v, U, U), n.normalize(F, k), n.scale(k, H, V), 
                n.add(R, V, V), b = x * ei.halfKSqrtOf2, n.scale(C, b, w);
                var X = ei._tempVector37, Y = ei._tempVector38;
                n.scale(W, .5, X), n.scale(k, .5, Y), n.multiply(X, C, X), n.multiply(Y, C, Y), 
                n.add(c, Y, c), n.min(c, U, c), n.subtract(c, w, c), n.subtract(d, X, d), n.max(d, V, d), 
                n.add(d, w, d);
                break;

              case 2:
                P = .5 * (x *= Math.cos(.7853981633974483)), w.x = C.x * P, w.y = C.z * P, n.subtract(c, w, c), 
                n.add(d, w, d);
                break;

              case 3:
                P = .5 * (x *= Math.cos(.7853981633974483)), n.scale(C, P, w), n.subtract(c, w, c), 
                n.add(d, w, d);
            }
            this._boundingBox.getCorners(this._boundingBoxCorners);
        }
        _updateEmission() {
            if (this.isAlive) if (this._simulateUpdate) this._simulateUpdate = !1; else {
                var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                e = Math.min(ei._maxElapsedTime, e * this.simulationSpeed), this._updateParticles(e);
            }
        }
        _updateParticles(e) {
            (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e, 
            this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e, 
            this._totalDelayTime < this._playStartDelay || this._emission.enable && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
        }
        _updateParticlesSimulationRestart(e) {
            this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, 
            this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0, 
            this._totalDelayTime = 0, this._currentTime = e;
            var t = e;
            t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable && this._advanceTime(e, e);
        }
        _retireActiveParticles() {
            for (;this._firstActiveElement != this._firstNewElement; ) {
                var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride, t = e + this._timeIndex;
                if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
            }
        }
        _freeRetiredParticles() {
            for (;this._firstRetiredElement != this._firstActiveElement; ) {
                var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                if (this.isPerformanceMode && e < 3) break;
                this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
            }
        }
        _burst(e, r) {
            for (var i = 0, a = this._emission._bursts, n = a.length; this._burstsIndex < n; this._burstsIndex++) {
                var s, o = a[this._burstsIndex], l = o.time;
                if (!(e <= l && l < r)) break;
                this.autoRandomSeed ? s = t.MathUtil.lerp(o.minCount, o.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0], 
                s = t.MathUtil.lerp(o.minCount, o.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed), 
                i += s;
            }
            return i;
        }
        _advanceTime(e, t) {
            var r, i = this._emissionTime;
            this._emissionTime += e;
            var a = 0;
            if (this._emissionTime > this.duration) {
                if (!this.looping) {
                    for (a = Math.min(this.maxParticles - this.aliveParticleCount, a), r = 0; r < a; r++) this.emit(t);
                    return this._isPlaying = !1, void this.stop();
                }
                a += this._burst(i, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0, 
                a += this._burst(0, this._emissionTime);
            } else a += this._burst(i, this._emissionTime);
            for (a = Math.min(this.maxParticles - this.aliveParticleCount, a), r = 0; r < a; r++) this.emit(t);
            var n = this.emission.emissionRate;
            if (n > 0) {
                var s = 1 / n;
                for (this._frameRateTime += s, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime); ) this._frameRateTime += s;
                this._frameRateTime = Math.floor(t / s) * s;
            }
        }
        _initBufferDatas() {
            if (this._vertexBuffer) {
                this._vertexBuffer.destroy(), this._indexBuffer.destroy();
                var r = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                t.Resource._addMemory(-r, -r);
            }
            var i = t.LayaGL.instance, a = this._ownerRender, n = a.renderMode;
            if (-1 !== n && this.maxParticles > 0) {
                var s, o, l, _, h, c, d, u = 0, m = (r = 0, a.mesh);
                if (4 === n) {
                    if (m) {
                        d = Qr.vertexDeclaration, this._floatCountPerVertex = d.vertexStride / 4, this._startLifeTimeIndex = 12, 
                        this._timeIndex = 16, this._vertexStride = m._vertexCount;
                        var f = this._bufferMaxParticles * this._vertexStride, E = f % 65535;
                        if (Math.floor(f / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                        u = d.vertexStride * E, this._vertexBuffer = new Ye(u, i.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = d, 
                        this._vertices = new Float32Array(this._floatCountPerVertex * E), this._indexStride = m._indexBuffer.indexCount;
                        var T = m._indexBuffer.getData(), p = this._bufferMaxParticles * this._indexStride;
                        for (this._indexBuffer = new ze(e.IndexFormat.UInt16, p, i.STATIC_DRAW), s = new Uint16Array(p), 
                        r = u + 2 * p, h = 0, o = 0; o < this._bufferMaxParticles; o++) {
                            var g = o * this._vertexStride;
                            for (l = 0, _ = T.length; l < _; l++) s[h++] = g + T[l];
                        }
                        this._indexBuffer.setData(s), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
                        this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                    }
                } else {
                    for (d = qr.vertexDeclaration, this._floatCountPerVertex = d.vertexStride / 4, this._startLifeTimeIndex = 7, 
                    this._timeIndex = 11, this._vertexStride = 4, u = d.vertexStride * this._bufferMaxParticles * this._vertexStride, 
                    this._vertexBuffer = new Ye(u, i.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = d, 
                    this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride), 
                    o = 0; o < this._bufferMaxParticles; o++) c = o * this._floatCountPerVertex * this._vertexStride, 
                    this._vertices[c] = -.5, this._vertices[c + 1] = -.5, this._vertices[c + 2] = 0, 
                    this._vertices[c + 3] = 1, c += this._floatCountPerVertex, this._vertices[c] = .5, 
                    this._vertices[c + 1] = -.5, this._vertices[c + 2] = 1, this._vertices[c + 3] = 1, 
                    c += this._floatCountPerVertex, this._vertices[c] = .5, this._vertices[c + 1] = .5, 
                    this._vertices[c + 2] = 1, this._vertices[c + 3] = 0, c += this._floatCountPerVertex, 
                    this._vertices[c] = -.5, this._vertices[c + 1] = .5, this._vertices[c + 2] = 0, 
                    this._vertices[c + 3] = 0;
                    for (this._indexStride = 6, this._indexBuffer = new ze(e.IndexFormat.UInt16, 6 * this._bufferMaxParticles, i.STATIC_DRAW), 
                    s = new Uint16Array(6 * this._bufferMaxParticles), o = 0; o < this._bufferMaxParticles; o++) {
                        h = 6 * o;
                        var S = o * this._vertexStride, R = S + 2;
                        s[h++] = S, s[h++] = R, s[h++] = S + 1, s[h++] = S, s[h++] = S + 3, s[h++] = R;
                    }
                    this._indexBuffer.setData(s), r = u + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(), 
                    this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), 
                    this._bufferState.unBind();
                }
                t.Resource._addMemory(r, r);
            }
        }
        destroy() {
            super.destroy();
            var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
            t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer.destroy(), 
            this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null, 
            this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null, 
            this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null, 
            this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null, 
            this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null, 
            this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null, 
            this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null, 
            this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null, 
            this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
        }
        emit(e) {
            var t = ei._tempPosition, r = ei._tempDirection;
            return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, r) : this._shape.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0, 
            r.x = r.y = 0, r.z = 1), this.addParticle(t, r, e);
        }
        addParticle(e, r, i) {
            n.normalize(r, r);
            var a = this._firstFreeElement + 1;
            if (a >= this._bufferMaxParticles && (a = 0), a === this._firstRetiredElement) return !1;
            var s, o, l, _, h, c, d, u, m, f, E = this._owner.transform;
            if ($r.create(this, this._ownerRender, E), this._currentTime - i >= $r.startLifeTime) return !0;
            switch (0 == this.simulationSpace && (s = E.position, o = E.rotation), this.startSpeedType) {
              case 0:
                l = this.startSpeedConstant;
                break;

              case 2:
                this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random()) : (this._rand.seed = this._randomSeeds[8], 
                l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat()), 
                this._randomSeeds[8] = this._rand.seed);
            }
            var T = this._velocityOverLifetime && this._velocityOverLifetime.enable;
            if (T) {
                var p = this._velocityOverLifetime.velocity.type;
                2 === p || 3 === p ? this.autoRandomSeed ? (_ = Math.random(), h = Math.random(), 
                c = Math.random()) : (this._rand.seed = this._randomSeeds[9], _ = this._rand.getFloat(), 
                h = this._rand.getFloat(), c = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : T = !1;
            } else T = !1;
            var g = this._colorOverLifetime && this._colorOverLifetime.enable;
            g ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? d = Math.random() : (this._rand.seed = this._randomSeeds[10], 
            d = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : g = !1 : g = !1;
            var S = this._sizeOverLifetime && this._sizeOverLifetime.enable;
            S ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? u = Math.random() : (this._rand.seed = this._randomSeeds[11], 
            u = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : S = !1 : S = !1;
            var R = this._rotationOverLifetime && this._rotationOverLifetime.enable;
            if (R) {
                var v = this._rotationOverLifetime.angularVelocity.type;
                2 === v || 3 === v ? this.autoRandomSeed ? m = Math.random() : (this._rand.seed = this._randomSeeds[12], 
                m = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : R = !1;
            } else R = !1;
            var x = this._textureSheetAnimation && this._textureSheetAnimation.enable;
            x ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? f = Math.random() : (this._rand.seed = this._randomSeeds[15], 
            f = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : x = !1 : x = !1;
            var I, A, L, C, D, M, y = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride, O = $r.startUVInfo[0], N = $r.startUVInfo[1], b = $r.startUVInfo[2], P = $r.startUVInfo[3], w = this._ownerRender;
            if (4 === w.renderMode) {
                var V = w.mesh._vertexBuffer;
                I = V.getFloat32Data();
                var B = V.vertexDeclaration;
                L = B.getVertexElementByUsage(Xe.MESH_POSITION0)._offset / 4;
                var F = B.getVertexElementByUsage(Xe.MESH_COLOR0);
                C = F ? F._offset / 4 : -1;
                var U = B.getVertexElementByUsage(Xe.MESH_TEXTURECOORDINATE0);
                D = U ? U._offset / 4 : -1, A = B.vertexStride / 4, M = 0;
            } else {
                this._vertices[y + 2] = b, this._vertices[y + 3] = P + N;
                var G = y + this._floatCountPerVertex;
                this._vertices[G + 2] = b + O, this._vertices[G + 3] = P + N;
                var z = G + this._floatCountPerVertex;
                this._vertices[z + 2] = b + O, this._vertices[z + 3] = P;
                var H = z + this._floatCountPerVertex;
                this._vertices[H + 2] = b, this._vertices[H + 3] = P;
            }
            for (var W = y, k = y + this._floatCountPerVertex * this._vertexStride; W < k; W += this._floatCountPerVertex) {
                var X;
                if (4 === w.renderMode) {
                    X = W;
                    var Y = A * M++, j = Y + L;
                    this._vertices[X++] = I[j++], this._vertices[X++] = I[j++], this._vertices[X++] = I[j], 
                    -1 === C ? (this._vertices[X++] = 1, this._vertices[X++] = 1, this._vertices[X++] = 1, 
                    this._vertices[X++] = 1) : (j = Y + C, this._vertices[X++] = I[j++], this._vertices[X++] = I[j++], 
                    this._vertices[X++] = I[j++], this._vertices[X++] = I[j]), -1 === D ? (this._vertices[X++] = 0, 
                    this._vertices[X++] = 0) : (j = Y + D, this._vertices[X++] = b + I[j++] * O, this._vertices[X++] = P + I[j] * N);
                } else X = W + 4;
                switch (this._vertices[X++] = e.x, this._vertices[X++] = e.y, this._vertices[X++] = e.z, 
                this._vertices[X++] = $r.startLifeTime, this._vertices[X++] = r.x, this._vertices[X++] = r.y, 
                this._vertices[X++] = r.z, this._vertices[X++] = i, this._vertices[X++] = $r.startColor.x, 
                this._vertices[X++] = $r.startColor.y, this._vertices[X++] = $r.startColor.z, this._vertices[X++] = $r.startColor.w, 
                this._vertices[X++] = $r.startSize[0], this._vertices[X++] = $r.startSize[1], this._vertices[X++] = $r.startSize[2], 
                this._vertices[X++] = $r.startRotation[0], this._vertices[X++] = $r.startRotation[1], 
                this._vertices[X++] = $r.startRotation[2], this._vertices[X++] = l, g && (this._vertices[X + 1] = d), 
                S && (this._vertices[X + 2] = u), R && (this._vertices[X + 3] = m), x && (this._vertices[X + 4] = f), 
                T && (this._vertices[X + 5] = _, this._vertices[X + 6] = h, this._vertices[X + 7] = c), 
                this.simulationSpace) {
                  case 0:
                    X += 8, this._vertices[X++] = s.x, this._vertices[X++] = s.y, this._vertices[X++] = s.z, 
                    this._vertices[X++] = o.x, this._vertices[X++] = o.y, this._vertices[X++] = o.z, 
                    this._vertices[X++] = o.w;
                    break;

                  case 1:
                    break;

                  default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
            }
            return this._firstFreeElement = a, !0;
        }
        addNewParticlesToVertexBuffer() {
            var e, t = this._vertexStride * this._floatCountPerVertex * 4;
            this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t, 
            this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t, 
            this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t), 
            this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)), 
            this._firstNewElement = this._firstFreeElement;
        }
        _getType() {
            return ei._type;
        }
        _prepareRender(e) {
            return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(), 
            this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
        }
        _render(e) {
            var r;
            this._bufferState.bind();
            var i = t.LayaGL.instance;
            this._firstActiveElement < this._firstFreeElement ? (r = (this._firstFreeElement - this._firstActiveElement) * this._indexStride, 
            i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), 
            t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride, 
            i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride), 
            t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++, this._firstFreeElement > 0 && (r = this._firstFreeElement * this._indexStride, 
            i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3, 
            t.Stat.renderBatches++));
        }
        play() {
            if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1, 
            this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed) for (var e = 0, r = this._randomSeeds.length; e < r; e++) this._randomSeeds[e] = this.randomSeed[0] + ei._RANDOMOFFSET[e];
            switch (this.startDelayType) {
              case 0:
                this._playStartDelay = this.startDelay;
                break;

              case 1:
                this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2], 
                this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()), 
                this._randomSeeds[2] = this._rand.seed);
                break;

              default:
                throw new Error("Utils3D: startDelayType is invalid.");
            }
            this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = t.Stat.loopCount;
        }
        pause() {
            this._isPaused = !0;
        }
        simulate(e, t = !0) {
            this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1, 
            this._updateParticles(e)), this.pause();
        }
        stop() {
            this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
        }
        cloneTo(e) {
            var t = e;
            t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm, 
            t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin, 
            t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime, 
            t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant, 
            this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin, 
            t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin), 
            this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType, 
            t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin, 
            t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize, 
            t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant, 
            this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin, 
            t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate), 
            this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation, 
            t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant, 
            this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin, 
            t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate), 
            this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate), 
            t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType, 
            this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin), 
            this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier, 
            t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake, 
            t.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0], t.maxParticles = this.maxParticles, 
            this._emission && (t._emission = this._emission.clone()), this.shape && (t.shape = this.shape.clone()), 
            this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()), 
            this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()), 
            this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()), 
            this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()), 
            t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting, 
            t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay, 
            t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime, 
            t._burstsIndex = this._burstsIndex;
        }
        clone() {
            var e = new ei(null);
            return this.cloneTo(e), e;
        }
    }
    ei._RANDOMOFFSET = new Uint32Array([ 592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447 ]), 
    ei.halfKSqrtOf2 = .71, ei._maxElapsedTime = 1 / 3, ei._tempVector30 = new n(), ei._tempVector31 = new n(), 
    ei._tempVector32 = new n(), ei._tempVector33 = new n(), ei._tempVector34 = new n(), 
    ei._tempVector35 = new n(), ei._tempVector36 = new n(), ei._tempVector37 = new n(), 
    ei._tempVector38 = new n(), ei._tempVector39 = new n(), ei._tempPosition = new n(), 
    ei._tempDirection = new n(), ei._type = wt._typeCounter++;
    class ti extends xe {
        static __init__() {
            Xr.SHADERDEFINE_RENDERMODE_BILLBOARD = H.getDefineByName("SPHERHBILLBOARD"), Xr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = H.getDefineByName("STRETCHEDBILLBOARD"), 
            Xr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = H.getDefineByName("HORIZONTALBILLBOARD"), 
            Xr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = H.getDefineByName("VERTICALBILLBOARD"), 
            Xr.SHADERDEFINE_COLOROVERLIFETIME = H.getDefineByName("COLOROVERLIFETIME"), Xr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = H.getDefineByName("RANDOMCOLOROVERLIFETIME"), 
            Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = H.getDefineByName("VELOCITYOVERLIFETIMECONSTANT"), 
            Xr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = H.getDefineByName("VELOCITYOVERLIFETIMECURVE"), 
            Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = H.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT"), 
            Xr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = H.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE"), 
            Xr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = H.getDefineByName("TEXTURESHEETANIMATIONCURVE"), 
            Xr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = H.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIME = H.getDefineByName("ROTATIONOVERLIFETIME"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = H.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = H.getDefineByName("ROTATIONOVERLIFETIMECONSTANT"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = H.getDefineByName("ROTATIONOVERLIFETIMECURVE"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = H.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS"), 
            Xr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = H.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES"), 
            Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVE = H.getDefineByName("SIZEOVERLIFETIMECURVE"), 
            Xr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = H.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE"), 
            Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = H.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES"), 
            Xr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = H.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"), 
            Xr.SHADERDEFINE_RENDERMODE_MESH = H.getDefineByName("RENDERMODE_MESH"), Xr.SHADERDEFINE_SHAPE = H.getDefineByName("SHAPE");
        }
        get particleSystem() {
            return this._particleSystem;
        }
        get particleRenderer() {
            return this._render;
        }
        constructor() {
            super(null), this._render = new jr(this), this._particleSystem = new ei(this);
            var e = this._render._renderElements[0] = new Gt();
            e.setTransform(this._transform), e.render = this._render, e.setGeometry(this._particleSystem), 
            e.material = Yr.defaultMaterial;
        }
        _parseModule(e, r) {
            for (var i in r) switch (i) {
              case "bases":
                var a = r.bases;
                for (var n in a) e[n] = a[n];
                break;

              case "vector2s":
                var s = r.vector2s;
                for (var n in s) {
                    var o = e[n], l = s[n];
                    o.setValue(l[0], l[1]), e[n] = o;
                }
                break;

              case "vector3s":
                var _ = r.vector3s;
                for (var n in _) {
                    var h = e[n], c = _[n];
                    h.setValue(c[0], c[1], c[2]), e[n] = h;
                }
                break;

              case "vector4s":
                var d = r.vector4s;
                for (var n in d) {
                    var u = e[n], m = d[n];
                    u.setValue(m[0], m[1], m[2], m[3]), e[n] = u;
                }
                break;

              case "gradientDataNumbers":
                var f = r.gradientDataNumbers;
                for (var n in f) {
                    for (var E = e[n], T = r[n], p = 0, g = T.length; p < g; p++) {
                        var S = T[p];
                        E.add(S.key, S.value);
                    }
                    e[n] = E;
                }
                break;

              case "resources":
                var R = r.resources;
                for (var n in R) e[n] = t.Loader.getRes(R[n]);
                break;

              case "bursts":
                var v = r.bursts;
                for (p = 0, g = v.length; p < g; p++) {
                    var x = v[p];
                    e.addBurst(new Ir(x.time, x.min, x.max));
                }
                break;

              case "randomSeed":
                e.randomSeed[0] = r.randomSeed;
                break;

              case "shapeType":
              case "type":
              case "color":
              case "size":
              case "frame":
              case "startFrame":
              case "angularVelocity":
              case "velocity":
                break;

              default:
                throw "ShurikenParticle3D:unknown type.";
            }
        }
        _parse(e, t) {
            if (super._parse(e, t), e.main) {
                var r = this.particleSystem, i = this.particleRenderer;
                this._parseModule(i, e.renderer), this._parseModule(r, e.main), this._parseModule(r.emission, e.emission);
                var s = e.shape;
                if (s) {
                    var o;
                    switch (s.shapeType) {
                      case 0:
                        o = new Gr();
                        break;

                      case 1:
                        o = new Ur();
                        break;

                      case 2:
                        o = new Fr();
                        break;

                      case 3:
                        o = new Vr();
                        break;

                      case 7:
                        o = new Br();
                        break;

                      default:
                        throw "ShuriKenParticle3D:unknown shape type.";
                    }
                    this._parseModule(o, s), r.shape = o;
                }
                var l = e.velocityOverLifetime;
                if (l) {
                    var _, h = l.velocity;
                    switch (h.type) {
                      case 0:
                        var c = h.constant;
                        _ = Nr.createByConstant(c ? new n(c[0], c[1], c[2]) : new n(0, 0, 0));
                        break;

                      case 1:
                        _ = Nr.createByGradient(this._initParticleVelocity(h.gradientX), this._initParticleVelocity(h.gradientY), this._initParticleVelocity(h.gradientZ));
                        break;

                      case 2:
                        var d = h.constantMin, u = h.constantMax;
                        _ = Nr.createByRandomTwoConstant(d ? new n(d[0], d[1], d[2]) : new n(0, 0, 0), u ? new n(u[0], u[1], u[2]) : new n(0, 0, 0));
                        break;

                      case 3:
                        _ = Nr.createByRandomTwoGradient(this._initParticleVelocity(h.gradientXMin), this._initParticleVelocity(h.gradientXMax), this._initParticleVelocity(h.gradientYMin), this._initParticleVelocity(h.gradientYMax), this._initParticleVelocity(h.gradientZMin), this._initParticleVelocity(h.gradientZMax));
                    }
                    var m = new kr(_);
                    this._parseModule(m, l), r.velocityOverLifetime = m;
                }
                var f = e.colorOverLifetime;
                if (f) {
                    var E, T = f.color;
                    switch (T.type) {
                      case 0:
                        var p = T.constant;
                        E = Ar.createByConstant(p ? new a(p[0], p[1], p[2], p[3]) : new a(0, 0, 0, 0));
                        break;

                      case 1:
                        E = Ar.createByGradient(this._initParticleColor(T.gradient));
                        break;

                      case 2:
                        var g = T.constantMin, S = T.constantMax;
                        E = Ar.createByRandomTwoConstant(g ? new a(g[0], g[1], g[2], g[3]) : new a(0, 0, 0, 0), g ? new a(S[0], S[1], S[2], S[3]) : new a(0, 0, 0, 0));
                        break;

                      case 3:
                        E = Ar.createByRandomTwoGradient(this._initParticleColor(T.gradientMin), this._initParticleColor(T.gradientMax));
                    }
                    var R = new Lr(E);
                    this._parseModule(R, f), r.colorOverLifetime = R;
                }
                var v = e.sizeOverLifetime;
                if (v) {
                    var x, I = v.size;
                    switch (I.type) {
                      case 0:
                        x = I.separateAxes ? Or.createByGradientSeparate(this._initParticleSize(I.gradientX), this._initParticleSize(I.gradientY), this._initParticleSize(I.gradientZ)) : Or.createByGradient(this._initParticleSize(I.gradient));
                        break;

                      case 1:
                        if (I.separateAxes) {
                            var A = I.constantMinSeparate, L = I.constantMaxSeparate;
                            x = Or.createByRandomTwoConstantSeparate(A ? new n(A[0], A[1], A[2]) : new n(0, 0, 0), L ? new n(L[0], L[1], L[2]) : new n(0, 0, 0));
                        } else x = Or.createByRandomTwoConstant(I.constantMin || 0, I.constantMax || 0);
                        break;

                      case 2:
                        x = I.separateAxes ? Or.createByRandomTwoGradientSeparate(this._initParticleSize(I.gradientXMin), this._initParticleSize(I.gradientYMin), this._initParticleSize(I.gradientZMin), this._initParticleSize(I.gradientXMax), this._initParticleSize(I.gradientYMax), this._initParticleSize(I.gradientZMax)) : Or.createByRandomTwoGradient(this._initParticleSize(I.gradientMin), this._initParticleSize(I.gradientMax));
                    }
                    var C = new zr(x);
                    this._parseModule(C, v), r.sizeOverLifetime = C;
                }
                var D = e.rotationOverLifetime;
                if (D) {
                    var M, y = D.angularVelocity;
                    switch (y.type) {
                      case 0:
                        if (y.separateAxes) {
                            var O = y.constantSeparate;
                            M = Dr.createByConstantSeparate(O ? new n(O[0], O[1], O[2]) : new n(0, 0, Math.PI / 4));
                        } else M = Dr.createByConstant(y.constant || Math.PI / 4);
                        break;

                      case 1:
                        M = y.separateAxes ? Dr.createByGradientSeparate(this._initParticleRotation(y.gradientX), this._initParticleRotation(y.gradientY), this._initParticleRotation(y.gradientZ)) : Dr.createByGradient(this._initParticleRotation(y.gradient));
                        break;

                      case 2:
                        if (y.separateAxes) {
                            var N = y.constantMinSeparate, b = y.constantMaxSeparate;
                            M = Dr.createByRandomTwoConstantSeparate(N ? new n(N[0], N[1], N[2]) : new n(0, 0, 0), b ? new n(b[0], b[1], b[2]) : new n(0, 0, Math.PI / 4));
                        } else M = Dr.createByRandomTwoConstant(y.constantMin || 0, y.constantMax || Math.PI / 4);
                        break;

                      case 3:
                        y.separateAxes || (M = Dr.createByRandomTwoGradient(this._initParticleRotation(y.gradientMin), this._initParticleRotation(y.gradientMax)));
                    }
                    var P = new br(M);
                    this._parseModule(P, D), r.rotationOverLifetime = P;
                }
                var w = e.textureSheetAnimation;
                if (w) {
                    var V, B = w.frame;
                    switch (B.type) {
                      case 0:
                        V = Cr.createByConstant(B.constant);
                        break;

                      case 1:
                        V = Cr.createByOverTime(this._initParticleFrame(B.overTime));
                        break;

                      case 2:
                        V = Cr.createByRandomTwoConstant(B.constantMin, B.constantMax);
                        break;

                      case 3:
                        V = Cr.createByRandomTwoOverTime(this._initParticleFrame(B.overTimeMin), this._initParticleFrame(B.overTimeMax));
                    }
                    var F, U = w.startFrame;
                    switch (U.type) {
                      case 0:
                        F = Hr.createByConstant(U.constant);
                        break;

                      case 1:
                        F = Hr.createByRandomTwoConstant(U.constantMin, U.constantMax);
                    }
                    var G = new Wr(V, F);
                    this._parseModule(G, w), r.textureSheetAnimation = G;
                }
            } else this._parseOld(e);
        }
        _activeHierarchy(e) {
            super._activeHierarchy(e), this.particleSystem.playOnAwake && this.particleSystem.play();
        }
        _inActiveHierarchy(e) {
            super._inActiveHierarchy(e), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
        }
        _cloneTo(e, t, r) {
            var i = e, a = i._particleSystem;
            this._particleSystem.cloneTo(a);
            var n = i._render, s = this._render;
            n.sharedMaterials = s.sharedMaterials, n.enable = s.enable, n.renderMode = s.renderMode, 
            n.mesh = s.mesh, n.stretchedBillboardCameraSpeedScale = s.stretchedBillboardCameraSpeedScale, 
            n.stretchedBillboardSpeedScale = s.stretchedBillboardSpeedScale, n.stretchedBillboardLengthScale = s.stretchedBillboardLengthScale, 
            n.sortingFudge = s.sortingFudge, super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._particleSystem.destroy(), this._particleSystem = null);
        }
        _create() {
            return new ti();
        }
        _parseOld(e) {
            const r = Math.PI / 180;
            var s, o, l, _ = this.particleRenderer, h = e.material;
            h && (l = t.Loader.getRes(h.path)), _.sharedMaterial = l;
            var c = e.meshPath;
            c && (_.mesh = t.Loader.getRes(c)), _.renderMode = e.renderMode, _.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale, 
            _.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, _.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale, 
            _.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
            var d = this.particleSystem;
            d.isPerformanceMode = e.isPerformanceMode, d.duration = e.duration, d.looping = e.looping, 
            d.prewarm = e.prewarm, d.startDelayType = e.startDelayType, d.startDelay = e.startDelay, 
            d.startDelayMin = e.startDelayMin, d.startDelayMax = e.startDelayMax, d.startLifetimeType = e.startLifetimeType, 
            d.startLifetimeConstant = e.startLifetimeConstant, d.startLifeTimeGradient = ti._initStartLife(e.startLifetimeGradient), 
            d.startLifetimeConstantMin = e.startLifetimeConstantMin, d.startLifetimeConstantMax = e.startLifetimeConstantMax, 
            d.startLifeTimeGradientMin = ti._initStartLife(e.startLifetimeGradientMin), d.startLifeTimeGradientMax = ti._initStartLife(e.startLifetimeGradientMax), 
            d.startSpeedType = e.startSpeedType, d.startSpeedConstant = e.startSpeedConstant, 
            d.startSpeedConstantMin = e.startSpeedConstantMin, d.startSpeedConstantMax = e.startSpeedConstantMax, 
            d.threeDStartSize = e.threeDStartSize, d.startSizeType = e.startSizeType, d.startSizeConstant = e.startSizeConstant;
            var u = e.startSizeConstantSeparate, m = d.startSizeConstantSeparate;
            m.x = u[0], m.y = u[1], m.z = u[2], d.startSizeConstantMin = e.startSizeConstantMin, 
            d.startSizeConstantMax = e.startSizeConstantMax;
            var f = e.startSizeConstantMinSeparate, E = d.startSizeConstantMinSeparate;
            E.x = f[0], E.y = f[1], E.z = f[2];
            var T = e.startSizeConstantMaxSeparate, p = d.startSizeConstantMaxSeparate;
            p.x = T[0], p.y = T[1], p.z = T[2], d.threeDStartRotation = e.threeDStartRotation, 
            d.startRotationType = e.startRotationType, d.startRotationConstant = e.startRotationConstant * r;
            var g = e.startRotationConstantSeparate, S = d.startRotationConstantSeparate;
            S.x = g[0] * r, S.y = g[1] * r, S.z = g[2] * r, d.startRotationConstantMin = e.startRotationConstantMin * r, 
            d.startRotationConstantMax = e.startRotationConstantMax * r;
            var R = e.startRotationConstantMinSeparate, v = d.startRotationConstantMinSeparate;
            v.x = R[0] * r, v.y = R[1] * r, v.z = R[2] * r;
            var x = e.startRotationConstantMaxSeparate, I = d.startRotationConstantMaxSeparate;
            I.x = x[0] * r, I.y = x[1] * r, I.z = x[2] * r, d.randomizeRotationDirection = e.randomizeRotationDirection, 
            d.startColorType = e.startColorType;
            var A = e.startColorConstant, L = d.startColorConstant;
            L.x = A[0], L.y = A[1], L.z = A[2], L.w = A[3];
            var C = e.startColorConstantMin, D = d.startColorConstantMin;
            D.x = C[0], D.y = C[1], D.z = C[2], D.w = C[3];
            var M = e.startColorConstantMax, y = d.startColorConstantMax;
            y.x = M[0], y.y = M[1], y.z = M[2], y.w = M[3], d.gravityModifier = e.gravityModifier, 
            d.simulationSpace = e.simulationSpace, void 0 !== e.simulationSpeed && (d.simulationSpeed = e.simulationSpeed), 
            d.scaleMode = e.scaleMode, d.playOnAwake = e.playOnAwake, d.maxParticles = e.maxParticles;
            var O = e.autoRandomSeed;
            null != O && (d.autoRandomSeed = O);
            var N = e.randomSeed;
            null != N && (d.randomSeed[0] = N);
            var b = e.emission, P = d.emission;
            if (b) {
                P.emissionRate = b.emissionRate;
                var w = b.bursts;
                if (w) for (s = 0, o = w.length; s < o; s++) {
                    var V = w[s];
                    P.addBurst(new Ir(V.time, V.min, V.max));
                }
                P.enable = b.enable;
            } else P.enable = !1;
            var B = e.shape;
            if (B) {
                var F;
                switch (B.shapeType) {
                  case 0:
                    var U;
                    F = U = new Gr(), U.radius = B.sphereRadius, U.emitFromShell = B.sphereEmitFromShell, 
                    U.randomDirection = B.sphereRandomDirection;
                    break;

                  case 1:
                    var G;
                    F = G = new Ur(), G.radius = B.hemiSphereRadius, G.emitFromShell = B.hemiSphereEmitFromShell, 
                    G.randomDirection = B.hemiSphereRandomDirection;
                    break;

                  case 2:
                    var z;
                    F = z = new Fr(), z.angle = B.coneAngle * r, z.radius = B.coneRadius, z.length = B.coneLength, 
                    z.emitType = B.coneEmitType, z.randomDirection = B.coneRandomDirection;
                    break;

                  case 3:
                    var H;
                    F = H = new Vr(), H.x = B.boxX, H.y = B.boxY, H.z = B.boxZ, H.randomDirection = B.boxRandomDirection;
                    break;

                  case 7:
                    var W;
                    F = W = new Br(), W.radius = B.circleRadius, W.arc = B.circleArc * r, W.emitFromEdge = B.circleEmitFromEdge, 
                    W.randomDirection = B.circleRandomDirection;
                    break;

                  default:
                    var k;
                    F = k = new Br(), k.radius = B.circleRadius, k.arc = B.circleArc * r, k.emitFromEdge = B.circleEmitFromEdge, 
                    k.randomDirection = B.circleRandomDirection;
                }
                F.enable = B.enable, d.shape = F;
            }
            var X = e.velocityOverLifetime;
            if (X) {
                var Y, j = X.velocity;
                switch (j.type) {
                  case 0:
                    var Z = j.constant;
                    Y = Nr.createByConstant(new n(Z[0], Z[1], Z[2]));
                    break;

                  case 1:
                    Y = Nr.createByGradient(this._initParticleVelocity(j.gradientX), this._initParticleVelocity(j.gradientY), this._initParticleVelocity(j.gradientZ));
                    break;

                  case 2:
                    var q = j.constantMin, Q = j.constantMax;
                    Y = Nr.createByRandomTwoConstant(new n(q[0], q[1], q[2]), new n(Q[0], Q[1], Q[2]));
                    break;

                  case 3:
                    Y = Nr.createByRandomTwoGradient(this._initParticleVelocity(j.gradientXMin), this._initParticleVelocity(j.gradientXMax), this._initParticleVelocity(j.gradientYMin), this._initParticleVelocity(j.gradientYMax), this._initParticleVelocity(j.gradientZMin), this._initParticleVelocity(j.gradientZMax));
                }
                var K = new kr(Y);
                K.space = X.space, K.enable = X.enable, d.velocityOverLifetime = K;
            }
            var J = e.colorOverLifetime;
            if (J) {
                var $, ee = J.color;
                switch (ee.type) {
                  case 0:
                    var te = ee.constant;
                    $ = Ar.createByConstant(new a(te[0], te[1], te[2], te[3]));
                    break;

                  case 1:
                    $ = Ar.createByGradient(this._initParticleColor(ee.gradient));
                    break;

                  case 2:
                    var re = ee.constantMin, ie = ee.constantMax;
                    $ = Ar.createByRandomTwoConstant(new a(re[0], re[1], re[2], re[3]), new a(ie[0], ie[1], ie[2], ie[3]));
                    break;

                  case 3:
                    $ = Ar.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                }
                var ae = new Lr($);
                ae.enable = J.enable, d.colorOverLifetime = ae;
            }
            var ne = e.sizeOverLifetime;
            if (ne) {
                var se, oe = ne.size;
                switch (oe.type) {
                  case 0:
                    se = oe.separateAxes ? Or.createByGradientSeparate(this._initParticleSize(oe.gradientX), this._initParticleSize(oe.gradientY), this._initParticleSize(oe.gradientZ)) : Or.createByGradient(this._initParticleSize(oe.gradient));
                    break;

                  case 1:
                    if (oe.separateAxes) {
                        var le = oe.constantMinSeparate, _e = oe.constantMaxSeparate;
                        se = Or.createByRandomTwoConstantSeparate(new n(le[0], le[1], le[2]), new n(_e[0], _e[1], _e[2]));
                    } else se = Or.createByRandomTwoConstant(oe.constantMin, oe.constantMax);
                    break;

                  case 2:
                    se = oe.separateAxes ? Or.createByRandomTwoGradientSeparate(this._initParticleSize(oe.gradientXMin), this._initParticleSize(oe.gradientYMin), this._initParticleSize(oe.gradientZMin), this._initParticleSize(oe.gradientXMax), this._initParticleSize(oe.gradientYMax), this._initParticleSize(oe.gradientZMax)) : Or.createByRandomTwoGradient(this._initParticleSize(oe.gradientMin), this._initParticleSize(oe.gradientMax));
                }
                var he = new zr(se);
                he.enable = ne.enable, d.sizeOverLifetime = he;
            }
            var ce = e.rotationOverLifetime;
            if (ce) {
                var de, ue = ce.angularVelocity;
                switch (ue.type) {
                  case 0:
                    if (ue.separateAxes) {
                        var me = ue.constantSeparate;
                        de = Dr.createByConstantSeparate(new n(me[0] * r, me[1] * r, me[2] * r));
                    } else de = Dr.createByConstant(ue.constant * r);
                    break;

                  case 1:
                    de = ue.separateAxes ? Dr.createByGradientSeparate(this._initParticleRotation(ue.gradientX), this._initParticleRotation(ue.gradientY), this._initParticleRotation(ue.gradientZ)) : Dr.createByGradient(this._initParticleRotation(ue.gradient));
                    break;

                  case 2:
                    if (ue.separateAxes) {
                        var fe = ue.constantMinSeparate, Ee = ue.constantMaxSeparate;
                        de = Dr.createByRandomTwoConstantSeparate(new n(fe[0] * r, fe[1] * r, fe[2] * r), new n(Ee[0] * r, Ee[1] * r, Ee[2] * r));
                    } else de = Dr.createByRandomTwoConstant(ue.constantMin * r, ue.constantMax * r);
                    break;

                  case 3:
                    ue.separateAxes || (de = Dr.createByRandomTwoGradient(this._initParticleRotation(ue.gradientMin), this._initParticleRotation(ue.gradientMax)));
                }
                var Te = new br(de);
                Te.enable = ce.enable, d.rotationOverLifetime = Te;
            }
            var pe = e.textureSheetAnimation;
            if (pe) {
                var ge, Se = pe.frame;
                switch (Se.type) {
                  case 0:
                    ge = Cr.createByConstant(Se.constant);
                    break;

                  case 1:
                    ge = Cr.createByOverTime(this._initParticleFrame(Se.overTime));
                    break;

                  case 2:
                    ge = Cr.createByRandomTwoConstant(Se.constantMin, Se.constantMax);
                    break;

                  case 3:
                    ge = Cr.createByRandomTwoOverTime(this._initParticleFrame(Se.overTimeMin), this._initParticleFrame(Se.overTimeMax));
                }
                var Re, ve = pe.startFrame;
                switch (ve.type) {
                  case 0:
                    Re = Hr.createByConstant(ve.constant);
                    break;

                  case 1:
                    Re = Hr.createByRandomTwoConstant(ve.constantMin, ve.constantMax);
                }
                var xe = new Wr(ge, Re);
                xe.enable = pe.enable;
                var Ie = pe.tiles;
                xe.tiles = new i(Ie[0], Ie[1]), xe.type = pe.type, xe.randomRow = pe.randomRow;
                var Ae = pe.rowIndex;
                void 0 !== Ae && (xe.rowIndex = Ae), xe.cycles = pe.cycles, d.textureSheetAnimation = xe;
            }
        }
        _initParticleColor(e) {
            var t = new xr(4, 4);
            if (e) {
                var r, i, a = e.alphas;
                if (a) for (r = 0, i = a.length; r < i; r++) {
                    3 == r && i > 4 && (r = i - 1, console.warn("GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."));
                    var n = a[r];
                    t.addColorAlpha(n.key, n.value);
                } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1);
                var s = e.rgbs;
                if (s) for (r = 0, i = s.length; r < i; r++) {
                    3 == r && i > 4 && (r = i - 1, console.warn("GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."));
                    var o = s[r], l = o.value;
                    t.addColorRGB(o.key, new ge(l[0], l[1], l[2], 1));
                } else t.addColorRGB(0, new ge(1, 1, 1, 1)), t.addColorRGB(1, new ge(1, 1, 1, 1));
            } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1), t.addColorRGB(0, new ge(1, 1, 1, 1)), 
            t.addColorRGB(1, new ge(1, 1, 1, 1));
            return t;
        }
        _initParticleFrame(e) {
            var t = new Mr();
            if (e) for (var r = e.frames, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                t.add(n.key, n.value);
            } else t.add(0, 0), t.add(1, 1);
            return t;
        }
        static _initStartLife(e) {
            for (var t = new yr(), r = e.startLifetimes, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                t.add(n.key, n.value);
            }
            return t;
        }
        _initParticleVelocity(e) {
            for (var t = new yr(), r = e.velocitys, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                t.add(n.key, n.value);
            }
            return t;
        }
        _initParticleSize(e) {
            var t = new yr();
            if (e) for (var r = e.sizes, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                t.add(n.key, n.value);
            } else t.add(0, 0), t.add(1, 1);
            return t;
        }
        _initParticleRotation(e) {
            for (var t = new yr(), r = e.angularVelocitys, i = 0, a = r.length; i < a; i++) {
                var n = r[i];
                t.add(n.key, n.value / 180 * Math.PI);
            }
            return t;
        }
    }
    class ri {}
    class ii extends Tr {
        constructor(e) {
            super(e), this._bones = [], this._skinnedDataLoopMarks = [], this._localBounds = new Pt(n._ZERO, n._ZERO), 
            this._cacheAnimationNode = [];
        }
        get localBounds() {
            return this._localBounds;
        }
        set localBounds(e) {
            this._localBounds = e;
        }
        get rootBone() {
            return this._cacheRootBone;
        }
        set rootBone(e) {
            this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
            e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
            this._cacheRootBone = e, this._onWorldMatNeedChange(Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDSCALE));
        }
        get bones() {
            return this._bones;
        }
        _computeSkinnedData() {
            if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._skinnedMatrixCaches, r = 0, i = this._cacheMesh.subMeshCount; r < i; r++) for (var a = this._cacheMesh.getSubMesh(r)._boneIndicesList, n = this._skinnedData[r], s = 0, o = a.length; s < o; s++) {
                var l = a[s];
                this._computeSubSkinnedData(e, l, n[s], t);
            }
        }
        _computeSubSkinnedData(e, r, i, a) {
            for (var n = 0, s = r.length; n < s; n++) {
                var o = r[n];
                if (this._skinnedDataLoopMarks[o] === t.Stat.loopCount) for (var l = a[o], _ = this._skinnedData[l.subMeshIndex][l.batchIndex], h = 16 * l.batchBoneIndex, c = 16 * n, d = 0; d < 16; d++) i[c + d] = _[h + d]; else this._cacheAvatar ? I._mulMatrixArray(this._cacheAnimationNode[o].transform.getWorldMatrix(), e[o].elements, 0, i, 16 * n) : I._mulMatrixArray(this._bones[o].transform.worldMatrix.elements, e[o].elements, 0, i, 16 * n), 
                this._skinnedDataLoopMarks[o] = t.Stat.loopCount;
            }
        }
        _onWorldMatNeedChange(e) {
            this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
        }
        _createRenderElement() {
            return new Gt();
        }
        _onMeshChange(e) {
            super._onMeshChange(e), this._cacheMesh = e;
            var t = e.subMeshCount;
            this._skinnedData = [], this._skinnedDataLoopMarks.length = e._inverseBindPoses.length;
            for (var r = 0; r < t; r++) for (var i = e.getSubMesh(r)._boneIndicesList, a = i.length, n = this._skinnedData[r] = [], s = 0; s < a; s++) n[s] = new Float32Array(16 * i[s].length);
            this._cacheAvatar && e && this._getCacheAnimationNodes();
        }
        _setCacheAnimator(e) {
            this._cacheAnimator = e, this._shaderValues.addDefine(ri.SHADERDEFINE_BONE), this._setRootNode();
        }
        _calculateBoundingBox() {
            if (this._cacheAvatar) if (this._cacheAnimator && this._rootBone) {
                var e = ii._tempMatrix4x4;
                I.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e), 
                this._localBounds._tranform(e, this._bounds);
            } else super._calculateBoundingBox(); else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
            if (t.Render.supportWebGLPlusCulling) {
                var r = this._bounds.getMin(), i = this._bounds.getMax(), a = Ce._cullingBuffer;
                a[this._cullingBufferIndex + 1] = r.x, a[this._cullingBufferIndex + 2] = r.y, a[this._cullingBufferIndex + 3] = r.z, 
                a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
            }
        }
        _renderUpdate(e, t) {
            if (this._cacheAnimator) if (this._computeSkinnedData(), this._cacheAvatar) {
                var r = this._cacheAnimator.owner._transform;
                this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, r.worldMatrix);
            } else this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, y.DEFAULT); else this._shaderValues.setMatrix4x4(ve.WORLDMATRIX, t.worldMatrix);
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix;
            if (this._cacheAnimator) if (this._cacheAvatar) {
                var i = this._cacheAnimator.owner._transform;
                y.multiply(r, i.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(ve.MVPMATRIX, this._projectionViewWorldMatrix);
            } else this._shaderValues.setMatrix4x4(ve.MVPMATRIX, r); else y.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), 
            this._shaderValues.setMatrix4x4(ve.MVPMATRIX, this._projectionViewWorldMatrix);
        }
        _destroy() {
            super._destroy(), this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
        }
        get bounds() {
            return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(), 
            this._boundsChange = !1), this._bounds;
        }
        _setRootBone(e) {
            this._rootBone = e, this._setRootNode();
        }
        _setRootNode() {
            var e;
            e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null, 
            this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(Re.TRANSFORM_WORLDPOSITION | Re.TRANSFORM_WORLDQUATERNION | Re.TRANSFORM_WORLDSCALE), 
            this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
            this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
            e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), 
            this._cacheRootAnimationNode = e);
        }
        _getCacheAnimationNodes() {
            var e = this._cacheMesh._boneNames, r = this._cacheMesh._inverseBindPoses.length;
            if (t.Render.supportWebGLPlusAnimation) {
                this._cacheAnimationNodeIndices = new Uint16Array(r);
                var i = this._cacheAnimator._avatarNodeMap;
                for (s = 0; s < r; s++) {
                    var a = i[e[s]];
                    this._cacheAnimationNodeIndices[s] = a ? a._worldMatrixIndex : 0;
                }
            } else {
                this._cacheAnimationNode.length = r;
                for (var n = this._cacheAnimator._avatarNodeMap, s = 0; s < r; s++) {
                    var o = n[e[s]];
                    this._cacheAnimationNode[s] = o;
                }
            }
        }
        _setCacheAvatar(e) {
            this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._shaderValues.addDefine(ri.SHADERDEFINE_BONE), 
            this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
        }
        _computeSubSkinnedDataNative(e, r, i, a, n) {
            t.LayaGL.instance.computeSubSkinnedData(e, r, i, a, n);
        }
        _computeSkinnedDataForNative() {
            if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar) for (var e = this._cacheMesh._inverseBindPoses, r = this._cacheMesh._skinnedMatrixCaches, i = 0, a = this._cacheMesh.subMeshCount; i < a; i++) for (var n = this._cacheMesh.getSubMesh(i)._boneIndicesList, s = this._skinnedData[i], o = 0, l = n.length; o < l; o++) {
                var _ = n[o];
                this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, _, s[o]) : this._computeSubSkinnedData(e, _, s[o], r);
            }
        }
    }
    ii._tempMatrix4x4 = new y();
    class ai extends xe {
        constructor(e = null, t = null) {
            super(t), this._meshFilter = new pr(this), this._render = new ii(this), e && (this._meshFilter.sharedMesh = e);
        }
        static __init__() {
            ri.SHADERDEFINE_BONE = H.getDefineByName("BONE");
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get skinnedMeshRenderer() {
            return this._render;
        }
        _parse(e, r) {
            super._parse(e, r);
            var i = this.skinnedMeshRenderer, s = e.lightmapIndex;
            null != s && (i.lightmapIndex = s);
            var o, l = e.lightmapScaleOffset;
            if (l && (i.lightmapScaleOffset = new a(l[0], l[1], l[2], l[3])), o = e.meshPath) {
                var _ = t.Loader.getRes(o);
                _ && (this.meshFilter.sharedMesh = _);
            }
            var h = e.materials;
            if (h) {
                var c = i.sharedMaterials, d = h.length;
                c.length = d;
                for (var u = 0; u < d; u++) c[u] = t.Loader.getRes(h[u].path);
                i.sharedMaterials = c;
            }
            var m = e.boundBox, f = m.min, E = m.max;
            if (i.localBounds.setMin(new n(f[0], f[1], f[2])), i.localBounds.setMax(new n(E[0], E[1], E[2])), 
            r) {
                var T = e.rootBone;
                i.rootBone = r[T];
                var p, g = e.bones;
                for (u = 0, p = g.length; u < p; u++) i.bones.push(r[g[u]]);
            } else e.rootBone && i._setRootBone(e.rootBone);
        }
        _changeHierarchyAnimator(e) {
            super._changeHierarchyAnimator(e), this.skinnedMeshRenderer._setCacheAnimator(e);
        }
        _changeAnimatorAvatar(e) {
            this.skinnedMeshRenderer._setCacheAvatar(e);
        }
        _cloneTo(e, t, r) {
            var i = e;
            i.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
            var a = this._render, n = i._render;
            n.enable = a.enable, n.sharedMaterials = a.sharedMaterials, n.castShadow = a.castShadow;
            var s = a.lightmapScaleOffset;
            s && (n.lightmapScaleOffset = s.clone()), n.receiveShadow = a.receiveShadow, n.sortingFudge = a.sortingFudge, 
            n._rootBone = a._rootBone;
            var o = a.bones, l = n.bones, _ = o.length;
            l.length = _;
            var h = a.rootBone;
            if (h) {
                var c = I._getHierarchyPath(t, h, ai._tempArray0);
                n.rootBone = c ? I._getNodeByHierarchyPath(r, c) : h;
            }
            for (var d = 0; d < o.length; d++) c = I._getHierarchyPath(t, o[d], ai._tempArray0), 
            l[d] = c ? I._getNodeByHierarchyPath(r, c) : o[d];
            var u = a.localBounds;
            u && u.cloneTo(n.localBounds), super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._meshFilter.destroy());
        }
        _create() {
            return new ai();
        }
    }
    ai._tempArray0 = [], ai.BONES = H.propertyNameToID("u_Bones");
    class ni extends Z {
        constructor() {
            super(), this.setShaderName("Trail"), this._color = new a(1, 1, 1, 1), this._shaderValues.setVector(ni.TINTCOLOR, new a(1, 1, 1, 1)), 
            this.renderMode = ni.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            ni.SHADERDEFINE_MAINTEXTURE = H.getDefineByName("MAINTEXTURE"), ni.SHADERDEFINE_TILINGOFFSET = H.getDefineByName("TILINGOFFSET"), 
            ni.SHADERDEFINE_ADDTIVEFOG = H.getDefineByName("ADDTIVEFOG");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(ni.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(ni.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(ni.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(ni.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(ni.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(ni.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(ni.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(ni.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
              case ni.RENDERMODE_ADDTIVE:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE, this.depthTest = Q.DEPTHTEST_LESS, this._shaderValues.addDefine(ni.SHADERDEFINE_ADDTIVEFOG);
                break;

              case ni.RENDERMODE_ALPHABLENDED:
                this.renderQueue = Z.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1, 
                this.cull = Q.CULL_NONE, this.blend = Q.BLEND_ENABLE_ALL, this.blendSrc = Q.BLENDPARAM_SRC_ALPHA, 
                this.blendDst = Q.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Q.DEPTHTEST_LESS, 
                this._shaderValues.removeDefine(ni.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("TrailMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(ni.TINTCOLOR);
        }
        set color(e) {
            this._shaderValues.setVector(ni.TINTCOLOR, e);
        }
        get texture() {
            return this._shaderValues.getTexture(ni.MAINTEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(ni.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(ni.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(ni.MAINTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(ni.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ni.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ni.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(ni.TILINGOFFSET, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(ni.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(ni.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(ni.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(ni.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(ni.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(ni.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(ni.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(ni.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(ni.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(ni.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(ni.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(ni.DEPTH_TEST);
        }
        clone() {
            var e = new ni();
            return this.cloneTo(e), e;
        }
    }
    ni.RENDERMODE_ALPHABLENDED = 0, ni.RENDERMODE_ADDTIVE = 1, ni.MAINTEXTURE = H.propertyNameToID("u_MainTexture"), 
    ni.TINTCOLOR = H.propertyNameToID("u_MainColor"), ni.TILINGOFFSET = H.propertyNameToID("u_TilingOffset"), 
    ni.CULL = H.propertyNameToID("s_Cull"), ni.BLEND = H.propertyNameToID("s_Blend"), 
    ni.BLEND_SRC = H.propertyNameToID("s_BlendSrc"), ni.BLEND_DST = H.propertyNameToID("s_BlendDst"), 
    ni.DEPTH_TEST = H.propertyNameToID("s_DepthTest"), ni.DEPTH_WRITE = H.propertyNameToID("s_DepthWrite");
    class si {}
    si.Stretch = 0, si.Tile = 1, (sr = e.TrailAlignment || (e.TrailAlignment = {}))[sr.View = 0] = "View", 
    sr[sr.TransformZ = 1] = "TransformZ";
    class oi {
        static get vertexDeclaration1() {
            return oi._vertexDeclaration1;
        }
        static get vertexDeclaration2() {
            return oi._vertexDeclaration2;
        }
        get vertexDeclaration() {
            return oi._vertexDeclaration1;
        }
        static __init__() {
            oi._vertexDeclaration1 = new We(32, [ new ke(0, He.Vector3, oi.TRAIL_POSITION0), new ke(12, He.Vector3, oi.TRAIL_OFFSETVECTOR), new ke(24, He.Single, oi.TRAIL_TIME0), new ke(28, He.Single, oi.TRAIL_TEXTURECOORDINATE0Y) ]), 
            oi._vertexDeclaration2 = new We(20, [ new ke(0, He.Single, oi.TRAIL_TEXTURECOORDINATE0X), new ke(4, He.Color, oi.TRAIL_COLOR) ]);
        }
    }
    oi.TRAIL_POSITION0 = 0, oi.TRAIL_OFFSETVECTOR = 1, oi.TRAIL_TIME0 = 2, oi.TRAIL_TEXTURECOORDINATE0Y = 3, 
    oi.TRAIL_TEXTURECOORDINATE0X = 4, oi.TRAIL_COLOR = 5;
    class li extends wt {
        constructor(e) {
            super(), this._floatCountPerVertices1 = 8, this._floatCountPerVertices2 = 5, this._increaseSegementCount = 16, 
            this._activeIndex = 0, this._endIndex = 0, this._needAddFirstVertex = !1, this._isTempEndVertex = !1, 
            this._vertices1 = null, this._vertices2 = null, this._lastFixedVertexPosition = new n(), 
            this._bufferState = new Ge(), this.tmpColor = new ge(), this._disappearBoundsMode = !1, 
            this._owner = e, this._segementCount = this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState);
            var r = this._owner._owner.trailRenderer.bounds, i = this._owner._owner.transform.position;
            r.setMin(i), r.setMax(i), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
        }
        _resizeData(e, r) {
            this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(e);
            var i = t.LayaGL.instance, a = 2 * e, n = oi.vertexDeclaration1, s = oi.vertexDeclaration2, o = [], l = a * n.vertexStride, _ = a * s.vertexStride, h = l + _;
            this._vertices1 = new Float32Array(a * this._floatCountPerVertices1), this._vertices2 = new Float32Array(a * this._floatCountPerVertices2), 
            this._vertexBuffer1 = new Ye(l, i.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = n, 
            this._vertexBuffer2 = new Ye(_, i.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = s, 
            o.push(this._vertexBuffer1), o.push(this._vertexBuffer2), r.bind(), r.applyVertexBuffers(o), 
            r.unBind(), t.Resource._addMemory(h, h);
        }
        _resetData() {
            var e = this._endIndex - this._activeIndex, r = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e), i = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e), a = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e), n = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
            if (e === this._segementCount) {
                this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy();
                var s = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                t.Resource._addMemory(-s, -s), this._segementCount += this._increaseSegementCount, 
                this._resizeData(this._segementCount, this._bufferState);
            }
            this._vertices1.set(r, 0), this._vertices2.set(i, 0), this._subDistance.set(a, 0), 
            this._subBirthTime.set(n, 0), this._endIndex = e, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4), 
            this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
        }
        _updateTrail(e, t, r) {
            n.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r));
        }
        _addTrailByFirstPosition(e, t) {
            this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0, 
            this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition), 
            this._needAddFirstVertex = !0;
        }
        _addTrailByNextPosition(t, i) {
            var a = li._tempVector30, s = li._tempVector31;
            switch (this._owner.alignment) {
              case e.TrailAlignment.View:
                var o = t.viewMatrix;
                n.transformCoordinate(i, o, li._tempVector33), n.transformCoordinate(this._lastFixedVertexPosition, o, li._tempVector34), 
                n.subtract(li._tempVector33, li._tempVector34, a), n.cross(li._tempVector33, a, s);
                break;

              case e.TrailAlignment.TransformZ:
                n.subtract(i, this._lastFixedVertexPosition, a);
                var l = li._tempVector32;
                this._owner._owner.transform.getForward(l), n.cross(a, l, s);
            }
            n.normalize(s, s), n.scale(s, this._owner.widthMultiplier / 2, s);
            var _, h, c = n.scalarLength(a);
            this._needAddFirstVertex && (this._updateVerticesByPositionData(i, s, this._endIndex - 1), 
            this._needAddFirstVertex = !1), c - this._owner.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (_ = this._endIndex - 1, 
            h = c - this._subDistance[_], this._updateVerticesByPosition(i, s, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(), 
            this._updateVerticesByPosition(i, s, c, this._endIndex), this._owner._totalLength += c, 
            this._endIndex++), i.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (_ = this._endIndex - 1, 
            h = c - this._subDistance[_], this._updateVerticesByPosition(i, s, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(), 
            this._updateVerticesByPosition(i, s, c, this._endIndex), this._owner._totalLength += c, 
            this._endIndex++), this._isTempEndVertex = !0);
        }
        _updateVerticesByPositionData(e, r, i) {
            var a = 2 * this._floatCountPerVertices1 * i, s = this._owner._curtime;
            this._vertices1[a] = e.x, this._vertices1[a + 1] = e.y, this._vertices1[a + 2] = e.z, 
            this._vertices1[a + 3] = -r.x, this._vertices1[a + 4] = -r.y, this._vertices1[a + 5] = -r.z, 
            this._vertices1[a + 6] = s, this._vertices1[a + 7] = 1, this._vertices1[a + 8] = e.x, 
            this._vertices1[a + 9] = e.y, this._vertices1[a + 10] = e.z, this._vertices1[a + 11] = r.x, 
            this._vertices1[a + 12] = r.y, this._vertices1[a + 13] = r.z, this._vertices1[a + 14] = s, 
            this._vertices1[a + 15] = 0;
            var o = this._owner._owner.trailRenderer.bounds, l = o.getMin(), _ = o.getMax(), h = li._tempVector35, c = li._tempVector36, d = li._tempVector32;
            n.add(e, r, h), n.subtract(e, r, c), n.min(c, h, d), n.min(l, d, l), o.setMin(l), 
            n.max(h, c, d), n.max(_, d, _), o.setMax(_), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
            var u = 2 * this._floatCountPerVertices1;
            this._vertexBuffer1.setData(this._vertices1.buffer, 4 * a, 4 * a, 4 * u);
        }
        _updateVerticesByPosition(e, t, r, i) {
            this._updateVerticesByPositionData(e, t, i), this._subDistance[i] = r, this._subBirthTime[i] = this._owner._curtime;
        }
        _updateVertexBufferUV() {
            var e, r, i;
            if (this._disappearBoundsMode) {
                e = this._owner._owner.trailRenderer.bounds;
                var a = this._owner._owner.transform.position;
                e.setMin(a), e.setMax(a), r = e.getMin(), i = e.getMax(), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
            }
            for (var s = this._endIndex, o = 0, l = this._owner.colorGradient, _ = l.colorAlphaKeysCount - 1, h = l.colorRGBKeysCount - 1, c = this._owner._totalLength, d = 2 * this._floatCountPerVertices2, u = this._activeIndex; u < s; u++) {
                var m, f;
                u !== this._activeIndex && (o += this._subDistance[u]), this._owner.textureMode == si.Stretch ? f = m = 1 - o / c : (f = 1 - o / c, 
                m = 1 - (c - o)), h = l.evaluateColorRGB(f, this.tmpColor, h, !0), _ = l.evaluateColorAlpha(f, this.tmpColor, _, !0);
                var E = u * d;
                if (this._vertices2[E + 0] = m, this._vertices2[E + 1] = this.tmpColor.r, this._vertices2[E + 2] = this.tmpColor.g, 
                this._vertices2[E + 3] = this.tmpColor.b, this._vertices2[E + 4] = this.tmpColor.a, 
                this._vertices2[E + 5] = m, this._vertices2[E + 6] = this.tmpColor.r, this._vertices2[E + 7] = this.tmpColor.g, 
                this._vertices2[E + 8] = this.tmpColor.b, this._vertices2[E + 9] = this.tmpColor.a, 
                this._disappearBoundsMode) {
                    var T = 2 * this._floatCountPerVertices1 * u, p = li._tempVector32, g = li._tempVector33, S = li._tempVector34;
                    p.setValue(this._vertices1[T + 0], this._vertices1[T + 1], this._vertices1[T + 2]), 
                    g.setValue(this._vertices1[T + 3], this._vertices1[T + 4], this._vertices1[T + 5]), 
                    n.add(p, g, S), n.min(S, r, r), n.max(S, i, i), n.subtract(p, g, S), n.min(S, r, r), 
                    n.max(S, i, i);
                }
            }
            this._disappearBoundsMode && (e.setMin(r), e.setMax(i), this._disappearBoundsMode = !1, 
            t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
            var R = this._activeIndex * d;
            this._vertexBuffer2.setData(this._vertices2.buffer, 4 * R, 4 * R, 4 * (s * d - R));
        }
        _updateDisappear() {
            for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++) {
                var i = t + 1;
                if (i !== e && (this._owner._totalLength -= this._subDistance[i]), this._isTempEndVertex && i === e - 1) {
                    this._floatCountPerVertices1;
                    var a = this._lastFixedVertexPosition;
                    a.x = this._vertices1[0], a.y = this._vertices1[1], a.z = this._vertices1[2], this._isTempEndVertex = !1;
                }
                this._activeIndex++, this._disappearBoundsMode = !0;
            }
        }
        _getType() {
            return li._type;
        }
        _prepareRender(e) {
            return this._endIndex - this._activeIndex > 1;
        }
        _render(e) {
            this._bufferState.bind();
            var r = t.LayaGL.instance, i = 2 * this._activeIndex, a = 2 * this._endIndex - i;
            r.drawArrays(r.TRIANGLE_STRIP, i, a), t.Stat.renderBatches++, t.Stat.trianglesFaces += a - 2;
        }
        destroy() {
            super.destroy();
            var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
            t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1.destroy(), 
            this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null, 
            this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null, 
            this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null, 
            this._disappearBoundsMode = !1;
        }
        _calculateBoundingBoxForNative() {
            var e = this._owner._owner.trailRenderer, t = e.bounds, r = t.getMin(), i = t.getMax(), a = Ce._cullingBuffer;
            a[e._cullingBufferIndex + 1] = r.x, a[e._cullingBufferIndex + 2] = r.y, a[e._cullingBufferIndex + 3] = r.z, 
            a[e._cullingBufferIndex + 4] = i.x, a[e._cullingBufferIndex + 5] = i.y, a[e._cullingBufferIndex + 6] = i.z;
        }
        clear() {
            this._activeIndex = 0, this._endIndex = 0, this._disappearBoundsMode = !1, this._subBirthTime.fill(0), 
            this._subDistance.fill(0), this._segementCount = 0, this._isTempEndVertex = !1, 
            this._needAddFirstVertex = !1, this._lastFixedVertexPosition.setValue(0, 0, 0);
        }
    }
    li.ALIGNMENT_VIEW = 0, li.ALIGNMENT_TRANSFORM_Z = 1, li._tempVector30 = new n(), 
    li._tempVector31 = new n(), li._tempVector32 = new n(), li._tempVector33 = new n(), 
    li._tempVector34 = new n(), li._tempVector35 = new n(), li._tempVector36 = new n(), 
    li._type = wt._typeCounter++;
    class _i {
        constructor(e) {
            this._totalLength = 0, this._lastPosition = new n(), this._curtime = 0, this.alignment = _i.ALIGNMENT_VIEW, 
            this._owner = e, this._initDefaultData(), this.addRenderElement();
        }
        get time() {
            return this._time;
        }
        set time(e) {
            this._time = e, this._owner._render._shaderValues.setNumber(_i.LIFETIME, e);
        }
        get minVertexDistance() {
            return this._minVertexDistance;
        }
        set minVertexDistance(e) {
            this._minVertexDistance = e;
        }
        get widthMultiplier() {
            return this._widthMultiplier;
        }
        set widthMultiplier(e) {
            this._widthMultiplier = e;
        }
        get widthCurve() {
            return this._widthCurve;
        }
        set widthCurve(e) {
            this._widthCurve = e;
            var t, r, i = new Float32Array(4 * e.length), a = 0;
            for (t = 0, r = e.length; t < r; t++) i[a++] = e[t].time, i[a++] = e[t].inTangent, 
            i[a++] = e[t].outTangent, i[a++] = e[t].value;
            this._owner._render._shaderValues.setBuffer(_i.WIDTHCURVE, i), this._owner._render._shaderValues.setInt(_i.WIDTHCURVEKEYLENGTH, e.length);
        }
        get colorGradient() {
            return this._colorGradient;
        }
        set colorGradient(e) {
            this._colorGradient = e;
        }
        get textureMode() {
            return this._textureMode;
        }
        set textureMode(e) {
            this._textureMode = e;
        }
        addRenderElement() {
            var e = this._owner._render, t = e._renderElements, r = e.sharedMaterials[0];
            r || (r = ni.defaultMaterial);
            var i = new Gt();
            i.setTransform(this._owner._transform), i.render = e, i.material = r, this._trialGeometry = new li(this), 
            i.setGeometry(this._trialGeometry), t.push(i);
        }
        _update(e) {
            var t = this._owner._render;
            this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(_i.CURTIME, this._curtime);
            var r = this._owner.transform.position, i = t._renderElements[0]._geometry;
            i._updateDisappear(), i._updateTrail(e.camera, this._lastPosition, r), i._updateVertexBufferUV(), 
            r.cloneTo(this._lastPosition);
        }
        _initDefaultData() {
            this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = si.Stretch;
            var e = [], t = new u();
            t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
            var r = new u();
            r.time = 1, r.inTangent = 0, r.outTangent = 0, r.value = 1, e.push(r), this.widthCurve = e;
            var i = new xr(2, 2);
            i.mode = vr.Blend, i.addColorRGB(0, ge.WHITE), i.addColorRGB(1, ge.WHITE), i.addColorAlpha(0, 1), 
            i.addColorAlpha(1, 1), this.colorGradient = i;
        }
        destroy() {
            this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null, 
            this._colorGradient = null;
        }
        clear() {
            this._trialGeometry.clear(), this._lastPosition.setValue(0, 0, 0), this._curtime = 0, 
            this._totalLength = 0;
        }
    }
    _i.CURTIME = H.propertyNameToID("u_CurTime"), _i.LIFETIME = H.propertyNameToID("u_LifeTime"), 
    _i.WIDTHCURVE = H.propertyNameToID("u_WidthCurve"), _i.WIDTHCURVEKEYLENGTH = H.propertyNameToID("u_WidthCurveKeyLength"), 
    _i.ALIGNMENT_VIEW = 0, _i.ALIGNMENT_TRANSFORM_Z = 1;
    class hi extends kt {
        constructor(e) {
            super(e), this._projectionViewWorldMatrix = new y();
        }
        _calculateBoundingBox() {}
        _needRender(e, t) {
            return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds._getBoundBox());
        }
        _updateForNative(e) {
            this._owner.trailFilter._update(e);
        }
        _renderUpdate(e, t) {
            super._renderUpdate(e, t);
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix;
            t ? (y.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(ve.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(ve.MVPMATRIX, r);
        }
    }
    class ci extends xe {
        static __init__() {}
        get trailFilter() {
            return this._geometryFilter;
        }
        get trailRenderer() {
            return this._render;
        }
        constructor(e = null) {
            super(e), this._render = new hi(this), this._geometryFilter = new _i(this);
        }
        _parse(e, r) {
            super._parse(e, r);
            var i, a, n = this._render, s = this._geometryFilter, o = e.materials;
            if (o) {
                var l = n.sharedMaterials, _ = o.length;
                for (l.length = _, i = 0; i < _; i++) l[i] = t.Loader.getRes(o[i].path);
                n.sharedMaterials = l;
            }
            s.time = e.time, s.minVertexDistance = e.minVertexDistance, s.widthMultiplier = e.widthMultiplier, 
            s.textureMode = e.textureMode, null != e.alignment && (s.alignment = e.alignment);
            var h = [], c = e.widthCurve;
            for (i = 0, a = c.length; i < a; i++) {
                var d = new u();
                d.time = c[i].time, d.inTangent = c[i].inTangent, d.outTangent = c[i].outTangent, 
                d.value = c[i].value, h.push(d);
            }
            s.widthCurve = h;
            var m = e.colorGradient, f = m.colorKeys, E = m.alphaKeys, T = new xr(f.length, E.length);
            for (T.mode = m.mode, i = 0, a = f.length; i < a; i++) {
                var p = f[i];
                T.addColorRGB(p.time, new ge(p.value[0], p.value[1], p.value[2], 1));
            }
            for (i = 0, a = E.length; i < a; i++) {
                var g = E[i];
                T.addColorAlpha(g.time, g.value);
            }
            s.colorGradient = T;
        }
        _onActive() {
            super._onActive(), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
        }
        _cloneTo(e, t, r) {
            var i, a;
            super._cloneTo(e, t, r);
            var n = e, s = n.trailFilter;
            s.time = this.trailFilter.time, s.minVertexDistance = this.trailFilter.minVertexDistance, 
            s.widthMultiplier = this.trailFilter.widthMultiplier, s.textureMode = this.trailFilter.textureMode, 
            s.alignment = this.trailFilter.alignment;
            var o = this.trailFilter.widthCurve, l = [];
            for (i = 0, a = o.length; i < a; i++) {
                var _ = new u();
                o[i].cloneTo(_), l.push(_);
            }
            s.widthCurve = l;
            var h = new xr(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
            this.trailFilter.colorGradient.cloneTo(h), s.colorGradient = h, n.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._geometryFilter.destroy(), this._geometryFilter = null);
        }
        clear() {
            this._geometryFilter.clear();
        }
        _create() {
            return new ci();
        }
    }
    class di {
        constructor(e, t, r, i) {
            this._position = e, this._normal = t, this._textureCoord0 = r, this._textureCoord1 = i;
        }
        static __init__() {
            di._vertexDeclaration = new We(40, [ new ke(0, He.Vector3, di.TERRAIN_POSITION0), new ke(12, He.Vector3, di.TERRAIN_NORMAL0), new ke(24, He.Vector2, di.TERRAIN_TEXTURECOORDINATE0), new ke(32, He.Vector2, di.TERRAIN_TEXTURECOORDINATE1) ]);
        }
        static get vertexDeclaration() {
            return di._vertexDeclaration;
        }
        get position() {
            return this._position;
        }
        get normal() {
            return this._normal;
        }
        get textureCoord0() {
            return this._textureCoord0;
        }
        get textureCoord1() {
            return this._textureCoord1;
        }
        get vertexDeclaration() {
            return di._vertexDeclaration;
        }
    }
    di.TERRAIN_POSITION0 = 0, di.TERRAIN_NORMAL0 = 1, di.TERRAIN_TEXTURECOORDINATE0 = 2, 
    di.TERRAIN_TEXTURECOORDINATE1 = 3;
    class ui {}
    ui._interactive = {
        getWorldTransform: (e, t) => {},
        setWorldTransform: (e, t) => {
            var r = vt._physicObjectsMap[e];
            r._simulation._updatedRigidbodies++, r._updateTransformComponent(t);
        }
    };
    class mi extends vt {
        constructor(e = .1, t = null, r = _t.COLLISIONFILTERGROUP_DEFAULTFILTER, i = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            super(r, i), this._upAxis = new n(0, 1, 0), this._maxSlope = 45, this._jumpSpeed = 10, 
            this._fallSpeed = 55, this._gravity = new n(0, 3 * -9.8, 0), this._btKinematicCharacter = null, 
            this._stepHeight = e, t && (this._upAxis = t), this._controlBySimulation = !0;
        }
        static __init__() {
            mi._btTempVector30 = v._bullet.btVector3_create(0, 0, 0);
        }
        get fallSpeed() {
            return this._fallSpeed;
        }
        set fallSpeed(e) {
            this._fallSpeed = e, v._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e);
        }
        get jumpSpeed() {
            return this._jumpSpeed;
        }
        set jumpSpeed(e) {
            this._jumpSpeed = e, v._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e);
        }
        get gravity() {
            return this._gravity;
        }
        set gravity(e) {
            this._gravity = e;
            var t = v._bullet, r = mi._btTempVector30;
            t.btVector3_setValue(r, -e.x, e.y, e.z), t.btKinematicCharacterController_setGravity(this._btKinematicCharacter, r);
        }
        get maxSlope() {
            return this._maxSlope;
        }
        set maxSlope(e) {
            this._maxSlope = e, v._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e / 180 * Math.PI);
        }
        get isGrounded() {
            return v._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
        }
        get stepHeight() {
            return this._stepHeight;
        }
        set stepHeight(e) {
            this._stepHeight = e, v._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e);
        }
        get upAxis() {
            return this._upAxis;
        }
        set upAxis(e) {
            this._upAxis = e;
            var t = mi._btTempVector30;
            I._convertToBulletVec3(e, t, !1), v._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, t);
        }
        _constructCharacter() {
            var e = v._bullet;
            this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this._btKinematicCharacter);
            var t = mi._btTempVector30;
            e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z), this._btKinematicCharacter = e.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, t), 
            this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed, 
            this.gravity = this._gravity;
        }
        _onShapeChange(e) {
            super._onShapeChange(e), this._constructCharacter();
        }
        _onAdded() {
            var e = v._bullet, t = e.btPairCachingGhostObject_create();
            e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_setCollisionFlags(t, vt.COLLISIONFLAGS_CHARACTER_OBJECT), 
            this._btColliderObject = t, this._colliderShape && this._constructCharacter(), super._onAdded();
        }
        _addToSimulation() {
            this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removeCharacter(this);
            var e = this._simulation._characters;
            e.splice(e.indexOf(this), 1);
        }
        _cloneTo(e) {
            super._cloneTo(e);
            var t = e;
            t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this._maxSlope, 
            t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t.gravity = this._gravity;
        }
        _onDestroy() {
            v._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter), super._onDestroy(), 
            this._btKinematicCharacter = null;
        }
        move(e) {
            var t = mi._btVector30, r = v._bullet;
            r.btVector3_setValue(t, -e.x, e.y, e.z), r.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, t);
        }
        jump(e = null) {
            var t = v._bullet, r = mi._btVector30;
            e ? (I._convertToBulletVec3(e, r, !0), t.btKinematicCharacterController_jump(this._btKinematicCharacter, r)) : (t.btVector3_setValue(r, 0, 0, 0), 
            t.btKinematicCharacterController_jump(this._btKinematicCharacter, r));
        }
    }
    mi.UPAXIS_X = 0, mi.UPAXIS_Y = 1, mi.UPAXIS_Z = 2;
    class fi extends vt {
        constructor(e, t) {
            super(e, t), this._isTrigger = !1;
        }
        get isTrigger() {
            return this._isTrigger;
        }
        set isTrigger(e) {
            this._isTrigger = e;
            var t = v._bullet;
            if (this._btColliderObject) {
                var r = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
                e ? 0 == (r & vt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r | vt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (r & vt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r ^ vt.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
            }
        }
        _onAdded() {
            super._onAdded(), this.isTrigger = this._isTrigger;
        }
        _cloneTo(e) {
            super._cloneTo(e), e.isTrigger = this._isTrigger;
        }
    }
    class Ei extends fi {
        constructor(e = _t.COLLISIONFILTERGROUP_DEFAULTFILTER, t = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            super(e, t), this._enableProcessCollisions = !1;
        }
        _addToSimulation() {
            this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removePhysicsCollider(this);
        }
        _parse(e) {
            null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
            null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
            super._parse(e), this._parseShape(e.shapes);
        }
        _onAdded() {
            var e = v._bullet, t = e.btCollisionObject_create();
            e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_forceActivationState(t, vt.ACTIVATIONSTATE_DISABLE_SIMULATION);
            var r = e.btCollisionObject_getCollisionFlags(t);
            this.owner.isStatic ? ((r & vt.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (r ^= vt.COLLISIONFLAGS_KINEMATIC_OBJECT), 
            r |= vt.COLLISIONFLAGS_STATIC_OBJECT) : ((r & vt.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (r ^= vt.COLLISIONFLAGS_STATIC_OBJECT), 
            r |= vt.COLLISIONFLAGS_KINEMATIC_OBJECT), e.btCollisionObject_setCollisionFlags(t, r), 
            this._btColliderObject = t, super._onAdded();
        }
    }
    class Ti extends fi {
        constructor(e = _t.COLLISIONFILTERGROUP_DEFAULTFILTER, t = _t.COLLISIONFILTERGROUP_ALLFILTER) {
            super(e, t), this._isKinematic = !1, this._mass = 1, this._gravity = new n(0, -10, 0), 
            this._angularDamping = 0, this._linearDamping = 0, this._overrideGravity = !1, this._totalTorque = new n(0, 0, 0), 
            this._totalForce = new n(0, 0, 0), this._linearVelocity = new n(), this._angularVelocity = new n(), 
            this._linearFactor = new n(1, 1, 1), this._angularFactor = new n(1, 1, 1), this._detectCollisions = !0, 
            this._controlBySimulation = !0;
        }
        static __init__() {
            var e = v._bullet;
            Ti._btTempVector30 = e.btVector3_create(0, 0, 0), Ti._btTempVector31 = e.btVector3_create(0, 0, 0), 
            Ti._btVector3Zero = e.btVector3_create(0, 0, 0), Ti._btInertia = e.btVector3_create(0, 0, 0), 
            Ti._btImpulse = e.btVector3_create(0, 0, 0), Ti._btImpulseOffset = e.btVector3_create(0, 0, 0), 
            Ti._btGravity = e.btVector3_create(0, 0, 0), Ti._btTransform0 = e.btTransform_create();
        }
        get mass() {
            return this._mass;
        }
        set mass(e) {
            e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
        }
        get isKinematic() {
            return this._isKinematic;
        }
        set isKinematic(e) {
            this._isKinematic = e, this._controlBySimulation = !e;
            var t = v._bullet, r = !!(this._simulation && this._enabled && this._colliderShape);
            r && this._removeFromSimulation();
            var i = this._btColliderObject, a = t.btCollisionObject_getCollisionFlags(i);
            e ? (a |= vt.COLLISIONFLAGS_KINEMATIC_OBJECT, t.btCollisionObject_setCollisionFlags(i, a), 
            t.btCollisionObject_forceActivationState(this._btColliderObject, vt.ACTIVATIONSTATE_DISABLE_DEACTIVATION), 
            this._enableProcessCollisions = !1, this._updateMass(0)) : ((a & vt.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (a ^= vt.COLLISIONFLAGS_KINEMATIC_OBJECT), 
            t.btCollisionObject_setCollisionFlags(i, a), t.btCollisionObject_setActivationState(this._btColliderObject, vt.ACTIVATIONSTATE_ACTIVE_TAG), 
            this._enableProcessCollisions = !0, this._updateMass(this._mass));
            var n = Ti._btVector3Zero;
            t.btCollisionObject_setInterpolationLinearVelocity(i, n), t.btRigidBody_setLinearVelocity(i, n), 
            t.btCollisionObject_setInterpolationAngularVelocity(i, n), t.btRigidBody_setAngularVelocity(i, n), 
            r && this._addToSimulation();
        }
        get linearDamping() {
            return this._linearDamping;
        }
        set linearDamping(e) {
            this._linearDamping = e, this._btColliderObject && v._bullet.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping);
        }
        get angularDamping() {
            return this._angularDamping;
        }
        set angularDamping(e) {
            this._angularDamping = e, this._btColliderObject && v._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e);
        }
        get overrideGravity() {
            return this._overrideGravity;
        }
        set overrideGravity(e) {
            this._overrideGravity = e;
            var t = v._bullet;
            if (this._btColliderObject) {
                var r = t.btRigidBody_getFlags(this._btColliderObject);
                e ? 0 == (r & Ti._BT_DISABLE_WORLD_GRAVITY) && t.btRigidBody_setFlags(this._btColliderObject, r | Ti._BT_DISABLE_WORLD_GRAVITY) : (r & Ti._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this._btColliderObject, r ^ Ti._BT_DISABLE_WORLD_GRAVITY);
            }
        }
        get gravity() {
            return this._gravity;
        }
        set gravity(e) {
            this._gravity = e;
            var t = v._bullet;
            t.btVector3_setValue(Ti._btGravity, -e.x, e.y, e.z), t.btRigidBody_setGravity(this._btColliderObject, Ti._btGravity);
        }
        get totalForce() {
            if (this._btColliderObject) {
                var e = v._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                return I._convertToLayaVec3(e, this._totalForce, !0), this._totalForce;
            }
            return null;
        }
        get linearFactor() {
            return this._linearFactor;
        }
        set linearFactor(e) {
            this._linearFactor = e;
            var t = Ti._btTempVector30;
            I._convertToBulletVec3(e, t, !1), v._bullet.btRigidBody_setLinearFactor(this._btColliderObject, t);
        }
        get linearVelocity() {
            return this._btColliderObject && I._convertToLayaVec3(v._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity, !0), 
            this._linearVelocity;
        }
        set linearVelocity(e) {
            if (this._linearVelocity = e, this._btColliderObject) {
                var t = Ti._btTempVector30;
                I._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), v._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, t);
            }
        }
        get angularFactor() {
            return this._angularFactor;
        }
        set angularFactor(e) {
            this._angularFactor = e;
            var t = Ti._btTempVector30;
            I._convertToBulletVec3(e, t, !1), v._bullet.btRigidBody_setAngularFactor(this._btColliderObject, t);
        }
        get angularVelocity() {
            return this._btColliderObject && I._convertToLayaVec3(v._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity, !0), 
            this._angularVelocity;
        }
        set angularVelocity(e) {
            if (this._angularVelocity = e, this._btColliderObject) {
                var t = Ti._btTempVector30;
                I._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), v._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, t);
            }
        }
        get totalTorque() {
            if (this._btColliderObject) {
                var e = v._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                return I._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque;
            }
            return null;
        }
        get detectCollisions() {
            return this._detectCollisions;
        }
        set detectCollisions(e) {
            this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this), 
            this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
        }
        get isSleeping() {
            return !!this._btColliderObject && v._bullet.btCollisionObject_getActivationState(this._btColliderObject) === vt.ACTIVATIONSTATE_ISLAND_SLEEPING;
        }
        get sleepLinearVelocity() {
            return v._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
        }
        set sleepLinearVelocity(e) {
            var t = v._bullet;
            t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
        }
        get sleepAngularVelocity() {
            return v._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
        }
        set sleepAngularVelocity(e) {
            var t = v._bullet;
            t.btRigidBody_setSleepingThresholds(this._btColliderObject, t.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e);
        }
        _updateMass(e) {
            if (this._btColliderObject && this._colliderShape) {
                var t = v._bullet;
                t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e, Ti._btInertia), 
                t.btRigidBody_setMassProps(this._btColliderObject, e, Ti._btInertia), t.btRigidBody_updateInertiaTensor(this._btColliderObject);
            }
        }
        _onScaleChange(e) {
            super._onScaleChange(e), this._updateMass(this._isKinematic ? 0 : this._mass);
        }
        _derivePhysicsTransformation(e) {
            var t = v._bullet, r = this._btColliderObject, i = t.btCollisionObject_getWorldTransform(r), a = Ti._btTransform0;
            t.btTransform_equal(a, i), this._innerDerivePhysicsTransformation(a, e), t.btRigidBody_setCenterOfMassTransform(r, a);
        }
        _onAdded() {
            var e = v._bullet, t = e.layaMotionState_create();
            e.layaMotionState_set_rigidBodyID(t, this._id), this._btLayaMotionState = t;
            var r = e.btRigidBodyConstructionInfo_create(0, t, null, Ti._btVector3Zero), i = e.btRigidBody_create(r);
            e.btCollisionObject_setUserIndex(i, this.id), this._btColliderObject = i, super._onAdded(), 
            this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor, 
            this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
            this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic, 
            e.btRigidBodyConstructionInfo_destroy(r);
        }
        _onShapeChange(e) {
            if (super._onShapeChange(e), this._isKinematic) this._updateMass(0); else {
                var t = v._bullet;
                t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t.btCollisionObject_getWorldTransform(this._btColliderObject)), 
                this._updateMass(this._mass);
            }
        }
        _parse(e) {
            if (null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
            null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
            null != e.mass && (this.mass = e.mass), null != e.isKinematic && (this.isKinematic = e.isKinematic), 
            null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e.angularDamping && (this.angularDamping = e.angularDamping), 
            null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), null != e.linearFactor) {
                var t = this.linearFactor;
                t.fromArray(e.linearFactor), this.linearFactor = t;
            }
            if (null != e.angularFactor) {
                var r = this.angularFactor;
                r.fromArray(e.angularFactor), this.angularFactor = r;
            }
            e.gravity && (this.gravity.fromArray(e.gravity), this.gravity = this.gravity), super._parse(e), 
            this._parseShape(e.shapes);
        }
        _onDestroy() {
            v._bullet.btMotionState_destroy(this._btLayaMotionState), super._onDestroy(), this._btLayaMotionState = null, 
            this._gravity = null, this._totalTorque = null, this._linearVelocity = null, this._angularVelocity = null, 
            this._linearFactor = null, this._angularFactor = null;
        }
        _addToSimulation() {
            this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
        }
        _removeFromSimulation() {
            this._simulation._removeRigidBody(this);
        }
        _cloneTo(e) {
            super._cloneTo(e);
            var t = e;
            t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this._gravity, 
            t.angularDamping = this._angularDamping, t.linearDamping = this._linearDamping, 
            t.overrideGravity = this._overrideGravity, t.linearVelocity = this._linearVelocity, 
            t.angularVelocity = this._angularVelocity, t.linearFactor = this._linearFactor, 
            t.angularFactor = this._angularFactor, t.detectCollisions = this._detectCollisions;
        }
        applyForce(e, t = null) {
            if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var r = v._bullet, i = Ti._btTempVector30;
            if (r.btVector3_setValue(i, -e.x, e.y, e.z), t) {
                var a = Ti._btTempVector31;
                r.btVector3_setValue(a, -t.x, t.y, t.z), r.btRigidBody_applyForce(this._btColliderObject, i, a);
            } else r.btRigidBody_applyCentralForce(this._btColliderObject, i);
        }
        applyTorque(e) {
            if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = v._bullet, r = Ti._btTempVector30;
            t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorque(this._btColliderObject, r);
        }
        applyImpulse(e, t = null) {
            if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var r = v._bullet;
            r.btVector3_setValue(Ti._btImpulse, -e.x, e.y, e.z), t ? (r.btVector3_setValue(Ti._btImpulseOffset, -t.x, t.y, t.z), 
            r.btRigidBody_applyImpulse(this._btColliderObject, Ti._btImpulse, Ti._btImpulseOffset)) : r.btRigidBody_applyCentralImpulse(this._btColliderObject, Ti._btImpulse);
        }
        applyTorqueImpulse(e) {
            if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = v._bullet, r = Ti._btTempVector30;
            t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorqueImpulse(this._btColliderObject, r);
        }
        wakeUp() {
            this._btColliderObject && v._bullet.btCollisionObject_activate(this._btColliderObject, !1);
        }
        clearForces() {
            var e = this._btColliderObject;
            if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = v._bullet;
            t.btRigidBody_clearForces(e);
            var r = Ti._btVector3Zero;
            t.btCollisionObject_setInterpolationLinearVelocity(e, r), t.btRigidBody_setLinearVelocity(e, r), 
            t.btCollisionObject_setInterpolationAngularVelocity(e, r), t.btRigidBody_setAngularVelocity(e, r);
        }
    }
    Ti.TYPE_STATIC = 0, Ti.TYPE_DYNAMIC = 1, Ti.TYPE_KINEMATIC = 2, Ti._BT_DISABLE_WORLD_GRAVITY = 1, 
    Ti._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    class pi extends mt {
        static __init__() {
            pi._btNormal = v._bullet.btVector3_create(0, 0, 0);
        }
        constructor(e, t) {
            super(), this._normal = e, this._offset = t, this._type = mt.SHAPETYPES_STATICPLANE;
            var r = v._bullet;
            r.btVector3_setValue(pi._btNormal, -e.x, e.y, e.z), this._btShape = r.btStaticPlaneShape_create(pi._btNormal, t);
        }
        clone() {
            var e = new pi(this._normal, this._offset);
            return this.cloneTo(e), e;
        }
    }
    class gi extends wt {
        constructor(e) {
            super(), this._id = ++gi._uniqueIDCounter, this._mesh = e, this._boneIndicesList = [], 
            this._subIndexBufferStart = [], this._subIndexBufferCount = [];
        }
        get indexCount() {
            return this._indexCount;
        }
        _setIndexRange(e, t) {
            this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * e, t);
        }
        _getType() {
            return gi._type;
        }
        _prepareRender(e) {
            return this._mesh._uploadVerticesData(), !0;
        }
        _render(r) {
            var i = this._mesh;
            if (i.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance.supportElementIndexUint32()) {
                var a, n = t.LayaGL.instance, s = r.renderElement.render._skinnedData;
                switch (i.indexFormat) {
                  case e.IndexFormat.UInt32:
                    a = n.UNSIGNED_INT;
                    break;

                  case e.IndexFormat.UInt16:
                    a = n.UNSIGNED_SHORT;
                    break;

                  case e.IndexFormat.UInt8:
                    a = n.UNSIGNED_BYTE;
                }
                if (i._bufferState.bind(), s) for (var o = s[this._indexInMesh], l = 0, _ = this._boneIndicesList.length; l < _; l++) r.shader.uploadCustomUniform(ai.BONES, o[l]), 
                n.drawElements(n.TRIANGLES, this._subIndexBufferCount[l], a, 2 * this._subIndexBufferStart[l]); else n.drawElements(n.TRIANGLES, this._indexCount, a, 2 * this._indexStart);
                t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++;
            } else console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
        }
        getIndices() {
            if (this._mesh._isReadable) return this._indices.slice();
            throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(e) {
            this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
        }
        destroy() {
            this._destroyed || (super.destroy(), this._indexBuffer.destroy(), this._indexBuffer = null, 
            this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null, 
            this._subIndexBufferCount = null, this._skinAnimationDatas = null);
        }
    }
    gi._uniqueIDCounter = 0, gi._type = wt._typeCounter++;
    class Si {
        constructor(e, t, r) {
            this.subMeshIndex = e, this.batchIndex = t, this.batchBoneIndex = r;
        }
    }
    class Ri extends t.Resource {
        constructor(t = !0) {
            super(), this._tempVector30 = new n(), this._tempVector31 = new n(), this._tempVector32 = new n(), 
            this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1, this._needUpdateBounds = !0, 
            this._bounds = new Pt(new n(), new n()), this._bufferState = new Ge(), this._instanceBufferState = new Ge(), 
            this._vertexBuffer = null, this._indexBuffer = null, this._skinnedMatrixCaches = [], 
            this._vertexCount = 0, this._indexFormat = e.IndexFormat.UInt16, this._isReadable = t, 
            this._subMeshes = [];
        }
        static __init__() {
            var e = v._bullet;
            e && (Ri._nativeTempVector30 = e.btVector3_create(0, 0, 0), Ri._nativeTempVector31 = e.btVector3_create(0, 0, 0), 
            Ri._nativeTempVector32 = e.btVector3_create(0, 0, 0));
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, Ri.MESH);
        }
        get inverseAbsoluteBindPoses() {
            return this._inverseBindPoses;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(e) {
            this._bounds !== e && e.cloneTo(this._bounds);
        }
        get indexFormat() {
            return this._indexFormat;
        }
        _getPositionElement(e) {
            for (var t = e.vertexDeclaration._vertexElements, r = 0, i = t.length; r < i; r++) {
                var a = t[r];
                if (a._elementFormat === He.Vector3 && a._elementUsage === Xe.MESH_POSITION0) return a;
            }
            return null;
        }
        _getVerticeElementData(e, t) {
            e.length = this._vertexCount;
            var r = this._vertexBuffer.vertexDeclaration, s = r.getVertexElementByUsage(t);
            if (s) {
                var o = this._vertexBuffer.getUint8Data(), l = this._vertexBuffer.getFloat32Data(), _ = r.vertexStride, h = _ / 4, c = s._offset, d = c / 4;
                switch (t) {
                  case Xe.MESH_TEXTURECOORDINATE0:
                  case Xe.MESH_TEXTURECOORDINATE1:
                    for (var u = 0; u < this._vertexCount; u++) {
                        var m = h * u + d;
                        e[u] = new i(l[m], l[m + 1]);
                    }
                    break;

                  case Xe.MESH_POSITION0:
                  case Xe.MESH_NORMAL0:
                    for (u = 0; u < this._vertexCount; u++) {
                        m = h * u + d;
                        e[u] = new n(l[m], l[m + 1], l[m + 2]);
                    }
                    break;

                  case Xe.MESH_TANGENT0:
                  case Xe.MESH_BLENDWEIGHT0:
                    for (u = 0; u < this._vertexCount; u++) {
                        m = h * u + d;
                        e[u] = new a(l[m], l[m + 1], l[m + 2], l[m + 3]);
                    }
                    break;

                  case Xe.MESH_COLOR0:
                    for (u = 0; u < this._vertexCount; u++) {
                        m = h * u + d;
                        e[u] = new ge(l[m], l[m + 1], l[m + 2], l[m + 3]);
                    }
                    break;

                  case Xe.MESH_BLENDINDICES0:
                    for (u = 0; u < this._vertexCount; u++) {
                        m = _ * u + c;
                        e[u] = new a(o[m], o[m + 1], o[m + 2], o[m + 3]);
                    }
                    break;

                  default:
                    throw "Mesh:Unknown elementUsage.";
                }
            }
        }
        _setVerticeElementData(e, t) {
            var r = this._vertexBuffer.vertexDeclaration, i = r.getVertexElementByUsage(t);
            if (i) {
                var a = this._vertexBuffer.getUint8Data(), n = this._vertexBuffer.getFloat32Data(), s = r.vertexStride, o = s / 4, l = i._offset, _ = l / 4;
                switch (t) {
                  case Xe.MESH_TEXTURECOORDINATE0:
                  case Xe.MESH_TEXTURECOORDINATE1:
                    for (var h = 0, c = e.length; h < c; h++) {
                        var d = o * h + _, u = e[h];
                        n[d] = u.x, n[d + 1] = u.y;
                    }
                    break;

                  case Xe.MESH_POSITION0:
                  case Xe.MESH_NORMAL0:
                    for (h = 0, c = e.length; h < c; h++) {
                        d = o * h + _;
                        var m = e[h];
                        n[d] = m.x, n[d + 1] = m.y, n[d + 2] = m.z;
                    }
                    break;

                  case Xe.MESH_TANGENT0:
                  case Xe.MESH_BLENDWEIGHT0:
                    for (h = 0, c = e.length; h < c; h++) {
                        d = o * h + _;
                        var f = e[h];
                        n[d] = f.x, n[d + 1] = f.y, n[d + 2] = f.z, n[d + 3] = f.w;
                    }
                    break;

                  case Xe.MESH_COLOR0:
                    for (h = 0, c = e.length; h < c; h++) {
                        d = o * h + _;
                        var E = e[h];
                        n[d] = E.r, n[d + 1] = E.g, n[d + 2] = E.b, n[d + 3] = E.a;
                    }
                    break;

                  case Xe.MESH_BLENDINDICES0:
                    for (h = 0, c = e.length; h < c; h++) {
                        d = s * h + l, f = e[h];
                        a[d] = f.x, a[d + 1] = f.y, a[d + 2] = f.z, a[d + 3] = f.w;
                    }
                    break;

                  default:
                    throw "Mesh:Unknown elementUsage.";
                }
                this._minVerticesUpdate = 0, this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
            } else console.warn("Mesh: the mesh don't have  this VertexElement.");
        }
        _disposeResource() {
            for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e].destroy();
            this._btTriangleMesh && v._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh), 
            this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._bufferState.destroy(), 
            this._instanceBufferState.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), 
            this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null, 
            this._indexBuffer = null, this._subMeshes = null, this._btTriangleMesh = null, this._indexBuffer = null, 
            this._boneNames = null, this._inverseBindPoses = null;
        }
        _setSubMeshes(e) {
            this._subMeshes = e;
            for (var t = 0, r = e.length; t < r; t++) e[t]._indexInMesh = t;
        }
        _setBuffer(e, t) {
            var r = this._bufferState;
            r.bind(), r.applyVertexBuffer(e), r.applyIndexBuffer(t), r.unBind();
            var i = this._instanceBufferState;
            i.bind(), i.applyVertexBuffer(e), i.applyInstanceVertexBuffer(Ut.instance.instanceWorldMatrixBuffer), 
            i.applyInstanceVertexBuffer(Ut.instance.instanceMVPMatrixBuffer), i.applyIndexBuffer(t), 
            i.unBind();
        }
        _getPhysicMesh() {
            if (!this._btTriangleMesh) {
                for (var e = v._bullet, t = e.btTriangleMesh_create(), r = Ri._nativeTempVector30, i = Ri._nativeTempVector31, a = Ri._nativeTempVector32, n = this._tempVector30, s = this._tempVector31, o = this._tempVector32, l = this._vertexBuffer, _ = this._getPositionElement(l), h = l.getFloat32Data(), c = l.vertexDeclaration.vertexStride / 4, d = _._offset / 4, u = this._indexBuffer.getData(), m = 0, f = u.length; m < f; m += 3) {
                    var E = u[m] * c + d, T = u[m + 1] * c + d, p = u[m + 2] * c + d;
                    n.setValue(h[E], h[E + 1], h[E + 2]), s.setValue(h[T], h[T + 1], h[T + 2]), o.setValue(h[p], h[p + 1], h[p + 2]), 
                    I._convertToBulletVec3(n, r, !0), I._convertToBulletVec3(s, i, !0), I._convertToBulletVec3(o, a, !0), 
                    e.btTriangleMesh_addTriangle(t, r, i, a, !0);
                }
                this._btTriangleMesh = t;
            }
            return this._btTriangleMesh;
        }
        _uploadVerticesData() {
            var e = this._minVerticesUpdate, t = this._maxVerticesUpdate;
            if (-1 !== e && -1 !== t) {
                var r = e;
                this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r, t - e), 
                this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1;
            }
        }
        getSubMesh(e) {
            return this._subMeshes[e];
        }
        getPositions(e) {
            if (!this._isReadable) throw "Mesh:can't get positions on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_POSITION0);
        }
        setPositions(e) {
            if (!this._isReadable) throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_POSITION0), this._needUpdateBounds = !0;
        }
        getColors(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_COLOR0);
        }
        setColors(e) {
            if (!this._isReadable) throw "Mesh:setColors() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_COLOR0);
        }
        getUVs(e, t = 0) {
            if (!this._isReadable) throw "Mesh:can't get uvs on mesh,isReadable must be true.";
            switch (t) {
              case 0:
                this._getVerticeElementData(e, Xe.MESH_TEXTURECOORDINATE0);
                break;

              case 1:
                this._getVerticeElementData(e, Xe.MESH_TEXTURECOORDINATE1);
                break;

              default:
                throw "Mesh:Invalid channel.";
            }
        }
        setUVs(e, t = 0) {
            if (!this._isReadable) throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
            switch (t) {
              case 0:
                this._setVerticeElementData(e, Xe.MESH_TEXTURECOORDINATE0);
                break;

              case 1:
                this._setVerticeElementData(e, Xe.MESH_TEXTURECOORDINATE1);
                break;

              default:
                throw "Mesh:Invalid channel.";
            }
        }
        getNormals(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_NORMAL0);
        }
        setNormals(e) {
            if (!this._isReadable) throw "Mesh:setNormals() need must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_NORMAL0);
        }
        getTangents(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_TANGENT0);
        }
        setTangents(e) {
            if (!this._isReadable) throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_TANGENT0);
        }
        getBoneWeights(e) {
            if (!this._isReadable) throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_BLENDWEIGHT0);
        }
        setBoneWeights(e) {
            if (!this._isReadable) throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_BLENDWEIGHT0);
        }
        getBoneIndices(e) {
            if (!this._isReadable) throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
            this._getVerticeElementData(e, Xe.MESH_BLENDINDICES0);
        }
        setBoneIndices(e) {
            if (!this._isReadable) throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, Xe.MESH_BLENDINDICES0);
        }
        markAsUnreadbale() {
            this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1;
        }
        getVertexDeclaration() {
            return this._vertexBuffer._vertexDeclaration;
        }
        getVertices() {
            if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
            throw "Mesh:can't get vertices on mesh,isReadable must be true.";
        }
        setVertices(e) {
            this._vertexBuffer.setData(e), this._needUpdateBounds = !0;
        }
        getIndices() {
            if (this._isReadable) return this._indexBuffer.getData().slice();
            throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(r) {
            var i;
            r instanceof Uint32Array ? i = e.IndexFormat.UInt32 : r instanceof Uint16Array ? i = e.IndexFormat.UInt16 : r instanceof Uint8Array && (i = e.IndexFormat.UInt8);
            var a = this._indexBuffer;
            this._indexFormat === i && a.indexCount === r.length || (a.destroy(), this._indexBuffer = a = new ze(i, r.length, t.LayaGL.instance.STATIC_DRAW, this._isReadable)), 
            a.setData(r), this._indexFormat = i;
        }
        calculateBounds() {
            if (!this._isReadable) throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
            if (this._needUpdateBounds) {
                var e = this._tempVector30, t = this._tempVector31;
                e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
                for (var r = this._vertexBuffer, i = this._getPositionElement(r), a = r.getFloat32Data(), n = r.vertexDeclaration.vertexStride / 4, s = i._offset / 4, o = 0, l = a.length; o < l; o += n) {
                    var _ = o + s, h = a[_], c = a[_ + 1], d = a[_ + 2];
                    e.x = Math.min(e.x, h), e.y = Math.min(e.y, c), e.z = Math.min(e.z, d), t.x = Math.max(t.x, h), 
                    t.y = Math.max(t.y, c), t.z = Math.max(t.z, d);
                }
                this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1;
            }
        }
        cloneTo(t) {
            var r = t, i = this._vertexBuffer, a = new Ye(i._byteLength, i.bufferUsage, i.canRead);
            a.vertexDeclaration = i.vertexDeclaration, a.setData(i.getUint8Data().slice().buffer), 
            r._vertexBuffer = a, r._vertexCount = this._vertexCount;
            var n, s = this._indexBuffer, o = new ze(e.IndexFormat.UInt16, s.indexCount, s.bufferUsage, s.canRead);
            o.setData(s.getData().slice()), r._indexBuffer = o, r._setBuffer(r._vertexBuffer, o), 
            r._setCPUMemory(this.cpuMemory), r._setGPUMemory(this.gpuMemory);
            var l = this._boneNames;
            if (l) {
                var _ = r._boneNames = [];
                for (n = 0; n < l.length; n++) _[n] = l[n];
            }
            var h = this._inverseBindPoses;
            if (h) {
                var c = r._inverseBindPoses = [];
                for (n = 0; n < h.length; n++) c[n] = h[n];
            }
            var d = this._skinnedMatrixCaches.length;
            for (r._skinnedMatrixCaches.length = d, n = 0; n < d; n++) {
                var u = this._skinnedMatrixCaches[n];
                r._skinnedMatrixCaches[n] = new Si(u.subMeshIndex, u.batchIndex, u.batchBoneIndex);
            }
            for (n = 0; n < this.subMeshCount; n++) {
                var m = this._subMeshes[n], f = m._subIndexBufferStart, E = m._subIndexBufferCount, T = m._boneIndicesList, p = new gi(r);
                p._subIndexBufferStart.length = f.length, p._subIndexBufferCount.length = E.length, 
                p._boneIndicesList.length = T.length;
                for (var g = 0; g < f.length; g++) p._subIndexBufferStart[g] = f[g];
                for (g = 0; g < E.length; g++) p._subIndexBufferCount[g] = E[g];
                for (g = 0; g < T.length; g++) p._boneIndicesList[g] = new Uint16Array(T[g]);
                p._indexBuffer = o, p._indexStart = m._indexStart, p._indexCount = m._indexCount, 
                p._indices = new Uint16Array(o.getData().buffer, 2 * m._indexStart, m._indexCount);
                var S = r._vertexBuffer;
                p._vertexBuffer = S, r._subMeshes.push(p);
            }
            r._setSubMeshes(r._subMeshes);
        }
        clone() {
            var e = new Ri();
            return this.cloneTo(e), e;
        }
    }
    Ri.MESH = "MESH";
    class vi {
        static __init__() {}
        static _createMesh(r, i, a) {
            var n = t.LayaGL.instance, s = new Ri(), o = new gi(s), l = new Ye(4 * i.length, n.STATIC_DRAW, !0);
            l.vertexDeclaration = r, l.setData(i.buffer), s._vertexBuffer = l, s._vertexCount = l._byteLength / r.vertexStride;
            var _ = new ze(e.IndexFormat.UInt16, a.length, n.STATIC_DRAW, !0);
            _.setData(a), s._indexBuffer = _, s._setBuffer(l, _), o._vertexBuffer = l, o._indexBuffer = _, 
            o._setIndexRange(0, _.indexCount);
            var h = o._subIndexBufferStart, c = o._subIndexBufferCount, d = o._boneIndicesList;
            h.length = 1, c.length = 1, d.length = 1, h[0] = 0, c[0] = _.indexCount;
            var u = [];
            u.push(o), s._setSubMeshes(u), s.calculateBounds();
            var m = l._byteLength + _._byteLength;
            return s._setCPUMemory(m), s._setGPUMemory(m), s;
        }
        static createBox(e = 1, t = 1, r = 1) {
            var i = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), a = e / 2, n = t / 2, s = r / 2, o = new Float32Array([ -a, n, -s, 0, 1, 0, 0, 0, a, n, -s, 0, 1, 0, 1, 0, a, n, s, 0, 1, 0, 1, 1, -a, n, s, 0, 1, 0, 0, 1, -a, -n, -s, 0, -1, 0, 0, 1, a, -n, -s, 0, -1, 0, 1, 1, a, -n, s, 0, -1, 0, 1, 0, -a, -n, s, 0, -1, 0, 0, 0, -a, n, -s, -1, 0, 0, 0, 0, -a, n, s, -1, 0, 0, 1, 0, -a, -n, s, -1, 0, 0, 1, 1, -a, -n, -s, -1, 0, 0, 0, 1, a, n, -s, 1, 0, 0, 1, 0, a, n, s, 1, 0, 0, 0, 0, a, -n, s, 1, 0, 0, 0, 1, a, -n, -s, 1, 0, 0, 1, 1, -a, n, s, 0, 0, 1, 0, 0, a, n, s, 0, 0, 1, 1, 0, a, -n, s, 0, 0, 1, 1, 1, -a, -n, s, 0, 0, 1, 0, 1, -a, n, -s, 0, 0, -1, 1, 0, a, n, -s, 0, 0, -1, 0, 0, a, -n, -s, 0, 0, -1, 0, 1, -a, -n, -s, 0, 0, -1, 1, 1 ]), l = new Uint16Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20 ]);
            return vi._createMesh(i, o, l);
        }
        static createCapsule(e = .5, t = 2, r = 16, i = 32) {
            var a, n, s = (r + 1) * (i + 1) * 2 + 2 * (i + 1), o = 3 * r * (i + 1) * 2 * 2 + 2 * i * 3, l = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), _ = l.vertexStride / 4, h = new Float32Array(s * _), c = new Uint16Array(o), d = Math.PI / 2 / r, u = 2 * Math.PI / i, m = t / 2 - e, f = 0, E = 0, T = 0, p = 0, g = 0, S = 0;
            for (a = 0; a <= r; a++) for (n = 0; n <= i; n++) f = e * Math.cos(a * d) * Math.cos(n * u + Math.PI), 
            E = e * Math.sin(a * d), T = e * Math.cos(a * d) * Math.sin(n * u + Math.PI), h[p++] = f, 
            h[p++] = E + m, h[p++] = T, h[p++] = f, h[p++] = E, h[p++] = T, h[p++] = 1 - n / i, 
            h[p++] = (1 - a / r) * (Math.PI * e / 2 / (t + Math.PI * e)), a < r && (c[g++] = a * (i + 1) + n + (i + 1), 
            c[g++] = a * (i + 1) + n, c[g++] = a * (i + 1) + n + 1, c[g++] = a * (i + 1) + n + i, 
            c[g++] = a * (i + 1) + n, c[g++] = a * (i + 1) + n + (i + 1));
            for (S += (r + 1) * (i + 1), a = 0; a <= r; a++) for (n = 0; n <= i; n++) f = e * Math.cos(a * d) * Math.cos(n * u + Math.PI), 
            E = e * Math.sin(-a * d), T = e * Math.cos(a * d) * Math.sin(n * u + Math.PI), h[p++] = f, 
            h[p++] = E - m, h[p++] = T, h[p++] = f, h[p++] = E, h[p++] = T, h[p++] = 1 - n / i, 
            h[p++] = (a / r * (Math.PI * e / 2) + (t + Math.PI * e / 2)) / (t + Math.PI * e), 
            a < r && (c[g++] = S + a * (i + 1) + n, c[g++] = S + a * (i + 1) + n + (i + 1), 
            c[g++] = S + a * (i + 1) + n + 1, c[g++] = S + a * (i + 1) + n, c[g++] = S + a * (i + 1) + n + i, 
            c[g++] = S + a * (i + 1) + n + (i + 1));
            for (S += (r + 1) * (i + 1), n = 0; n <= i; n++) f = e * Math.cos(n * u + Math.PI), 
            E = m, T = e * Math.sin(n * u + Math.PI), h[p++] = f, h[p + 8 * (i + 1) - 1] = f, 
            h[p++] = E, h[p + 8 * (i + 1) - 1] = -E, h[p++] = T, h[p + 8 * (i + 1) - 1] = T, 
            h[p++] = f, h[p + 8 * (i + 1) - 1] = f, h[p++] = 0, h[p + 8 * (i + 1) - 1] = 0, 
            h[p++] = T, h[p + 8 * (i + 1) - 1] = T, h[p++] = 1 - 1 * n / i, h[p + 8 * (i + 1) - 1] = 1 - 1 * n / i, 
            h[p++] = Math.PI * e / 2 / (t + Math.PI * e), h[p + 8 * (i + 1) - 1] = (Math.PI * e / 2 + t) / (t + Math.PI * e);
            for (n = 0; n < i; n++) c[g++] = n + S + (i + 1), c[g++] = n + S + 1, c[g++] = n + S, 
            c[g++] = n + S + (i + 1), c[g++] = n + S + (i + 1) + 1, c[g++] = n + S + 1;
            return S += 2 * (i + 1), vi._createMesh(l, h, c);
        }
        static createCone(e = .5, t = 1, r = 32) {
            for (var i, a = r + 1 + 1 + 2 * (r + 1), s = 6 * r + 3 * r, o = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), l = o.vertexStride / 4, _ = new Float32Array(a * l), h = new Uint16Array(s), c = 2 * Math.PI / r, d = t / 2, u = 0, m = 0, E = 0, T = 0, p = 0, g = new n(), S = new n(0, -1, 0), R = new n(0, d, 0), v = new n(), x = new n(), I = new f(), A = new n(), L = 0, C = 0, D = 0; D <= r; D++) u = D * c, 
            E = Math.cos(u + Math.PI) * e, T = d, p = Math.sin(u + Math.PI) * e, _[L++] = 0, 
            _[L + 8 * (r + 1) - 1] = E, _[L++] = T, _[L + 8 * (r + 1) - 1] = -T, _[L++] = 0, 
            _[L + 8 * (r + 1) - 1] = p, g.x = E, g.y = 0, g.z = p, v.x = E, v.y = -T, v.z = p, 
            n.subtract(v, R, x), n.normalize(x, x), i = Math.acos(n.dot(S, x)), n.cross(S, x, A), 
            n.normalize(A, A), f.createFromAxisAngle(A, i, I), n.normalize(g, g), n.transformQuat(g, I, g), 
            n.normalize(g, g), _[L++] = g.x, _[L + 8 * (r + 1) - 1] = g.x, _[L++] = g.y, _[L + 8 * (r + 1) - 1] = g.y, 
            _[L++] = g.z, _[L + 8 * (r + 1) - 1] = g.z, _[L++] = 1 - 1 * D / r, _[L + 8 * (r + 1) - 1] = 1 - 1 * D / r, 
            _[L++] = 0, _[L + 8 * (r + 1) - 1] = 1;
            L += 8 * (r + 1);
            for (var M = 0; M < r; M++) h[C++] = M + m + (r + 1), h[C++] = M + m + 1, h[C++] = M + m, 
            h[C++] = M + m + (r + 1), h[C++] = M + m + (r + 1) + 1, h[C++] = M + m + 1;
            m += 2 * (r + 1);
            for (var y = 0; y <= r; y++) 0 === y && (_[L++] = 0, _[L++] = -d, _[L++] = 0, _[L++] = 0, 
            _[L++] = -1, _[L++] = 0, _[L++] = .5, _[L++] = .5), u = y * c, E = Math.cos(u + Math.PI) * e, 
            T = -d, p = Math.sin(u + Math.PI) * e, _[L++] = E, _[L++] = T, _[L++] = p, _[L++] = 0, 
            _[L++] = -1, _[L++] = 0, _[L++] = .5 + .5 * Math.cos(u), _[L++] = .5 + .5 * Math.sin(u);
            for (var O = 0; O < r; O++) h[C++] = 0 + m, h[C++] = O + 2 + m, h[C++] = O + 1 + m;
            return m += r + 1 + 1, vi._createMesh(o, _, h);
        }
        static createCylinder(e = .5, t = 2, r = 32) {
            for (var i = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), a = 3 * r + 6 * r + 3 * r, n = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), s = n.vertexStride / 4, o = new Float32Array(i * s), l = new Uint16Array(a), _ = 2 * Math.PI / r, h = t / 2, c = 0, d = 0, u = 0, m = 0, f = 0, E = 0, T = 0, p = 0; p <= r; p++) 0 === p && (o[E++] = 0, 
            o[E++] = h, o[E++] = 0, o[E++] = 0, o[E++] = 1, o[E++] = 0, o[E++] = .5, o[E++] = .5), 
            c = p * _, u = Math.cos(c) * e, m = h, f = Math.sin(c) * e, o[E++] = u, o[E++] = m, 
            o[E++] = f, o[E++] = 0, o[E++] = 1, o[E++] = 0, o[E++] = .5 + .5 * Math.cos(c), 
            o[E++] = .5 + .5 * Math.sin(c);
            for (var g = 0; g < r; g++) l[T++] = 0, l[T++] = g + 1, l[T++] = g + 2;
            d += r + 1 + 1;
            for (var S = 0; S <= r; S++) c = S * _, u = Math.cos(c + Math.PI) * e, m = h, f = Math.sin(c + Math.PI) * e, 
            o[E++] = u, o[E + 8 * (r + 1) - 1] = u, o[E++] = m, o[E + 8 * (r + 1) - 1] = -m, 
            o[E++] = f, o[E + 8 * (r + 1) - 1] = f, o[E++] = u, o[E + 8 * (r + 1) - 1] = u, 
            o[E++] = 0, o[E + 8 * (r + 1) - 1] = 0, o[E++] = f, o[E + 8 * (r + 1) - 1] = f, 
            o[E++] = 1 - 1 * S / r, o[E + 8 * (r + 1) - 1] = 1 - 1 * S / r, o[E++] = 0, o[E + 8 * (r + 1) - 1] = 1;
            E += 8 * (r + 1);
            for (var R = 0; R < r; R++) l[T++] = R + d + (r + 1), l[T++] = R + d + 1, l[T++] = R + d, 
            l[T++] = R + d + (r + 1), l[T++] = R + d + (r + 1) + 1, l[T++] = R + d + 1;
            d += 2 * (r + 1);
            for (var v = 0; v <= r; v++) 0 === v && (o[E++] = 0, o[E++] = -h, o[E++] = 0, o[E++] = 0, 
            o[E++] = -1, o[E++] = 0, o[E++] = .5, o[E++] = .5), c = v * _, u = Math.cos(c + Math.PI) * e, 
            m = -h, f = Math.sin(c + Math.PI) * e, o[E++] = u, o[E++] = m, o[E++] = f, o[E++] = 0, 
            o[E++] = -1, o[E++] = 0, o[E++] = .5 + .5 * Math.cos(c), o[E++] = .5 + .5 * Math.sin(c);
            for (var x = 0; x < r; x++) l[T++] = 0 + d, l[T++] = x + 2 + d, l[T++] = x + 1 + d;
            return d += r + 1 + 1, vi._createMesh(n, o, l);
        }
        static createPlane(e = 10, t = 10, r = 10, i = 10) {
            for (var a = (r + 1) * (i + 1), n = new Uint16Array(r * i * 2 * 3), s = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), o = s.vertexStride / 4, l = new Float32Array(a * o), _ = e / 2, h = t / 2, c = e / r, d = t / i, u = 0, m = 0; m <= i; m++) for (var f = 0; f <= r; f++) l[u++] = f * c - _, 
            l[u++] = 0, l[u++] = m * d - h, l[u++] = 0, l[u++] = 1, l[u++] = 0, l[u++] = 1 * f / r, 
            l[u++] = 1 * m / i;
            var E = 0;
            for (m = 0; m < i; m++) for (f = 0; f < r; f++) n[E++] = (m + 1) * (r + 1) + f, 
            n[E++] = m * (r + 1) + f, n[E++] = (m + 1) * (r + 1) + f + 1, n[E++] = m * (r + 1) + f, 
            n[E++] = m * (r + 1) + f + 1, n[E++] = (m + 1) * (r + 1) + f + 1;
            return vi._createMesh(s, l, n);
        }
        static createQuad(e = 1, t = 1) {
            var r = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), i = e / 2, a = t / 2, n = new Float32Array([ -i, a, 0, 0, 0, 1, 0, 0, i, a, 0, 0, 0, 1, 1, 0, -i, -a, 0, 0, 0, 1, 0, 1, i, -a, 0, 0, 0, 1, 1, 1 ]), s = new Uint16Array([ 0, 1, 2, 3, 2, 1 ]);
            return vi._createMesh(r, n, s);
        }
        static createSphere(e = .5, t = 32, r = 32) {
            var i = (t + 1) * (r + 1), a = 3 * t * (r + 1) * 2, n = new Uint16Array(a), s = Xe.getVertexDeclaration("POSITION,NORMAL,UV"), o = s.vertexStride / 4, l = new Float32Array(i * o), _ = Math.PI / t, h = 2 * Math.PI / r, c = 0;
            i = 0, a = 0;
            for (var d = 0; d < t + 1; d++) for (var u = Math.sin(d * _), m = Math.cos(d * _), f = 0; f < r + 1; f++) {
                var E = u * Math.sin(f * h + 1 * Math.PI / 2), T = u * Math.cos(f * h + 1 * Math.PI / 2);
                l[i + 0] = E * e, l[i + 1] = m * e, l[i + 2] = T * e, l[i + 3] = E, l[i + 4] = m, 
                l[i + 5] = T, l[i + 6] = f / r, l[i + 7] = d / t, i += o, d != t - 1 && (n[a++] = c + (r + 1), 
                n[a++] = c, n[a++] = c + 1, n[a++] = c + r, n[a++] = c, n[a++] = c + (r + 1), c++);
            }
            return vi._createMesh(s, l, n);
        }
    }
    var xi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n", Ii = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', Ai = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n", Li = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', Ci = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "Shadow.glsl"\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tfloat shadowValue = shadowValue = sampleShadowmap(v_ShadowCoord);\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', Di = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', Mi = 'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\nmediump vec3 layaDecodeDirectionalLightmap (mediump vec3 color, lowp vec4 dirTex, mediump vec3 normalWorld)\r\n{\r\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\r\n    // in a way, that using it for half Lambert and then dividing by a "rebalancing coefficient"\r\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\r\n\r\n    // Note that dir is not unit length on purpose. Its length is "directionality", like\r\n    // for the directional specular lightmaps.\r\n\tlowp vec3 directional=dirTex.xyz - 0.5;\r\n\tdirectional.x=-directional.x;//NOTE:because coord System\r\n    mediump float halfLambert = dot(normalWorld,directional) + 0.5;\r\n\r\n    return color * halfLambert / max(1e-4, dirTex.w);\r\n}\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tmediump vec3 bakedColor =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\t\tlowp vec4 bakedDirTex = texture2D (u_LightMapDirection, giInput.lightmapUV);\r\n            indirectDiffuse = layaDecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);\r\n\t\t#else //unDirectional lightmap\r\n\t\t\tindirectDiffuse = bakedColor;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor; //already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n', yi = "#ifdef GRAPHICS_API_GLES3\r\n\t#define INVERSE_MAT(mat) inverse(mat)\r\n#else\r\n\t#define INVERSE_MAT(mat) inverseMat(mat)\r\n#endif\r\n\r\nstruct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\n#ifndef GRAPHICS_API_GLES3\r\n\tmat3 inverseMat(mat3 m) {\r\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n\t\tfloat b01 = a22 * a11 - a12 * a21;\r\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\r\n\t\tfloat b21 = a21 * a10 - a11 * a20;\r\n\r\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n\t}\r\n#endif\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else //pixelComponent==3\r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = lightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n", Oi = '// ------------------------------------------------------------------\r\n//  PCF Filtering Tent Functions\r\n// ------------------------------------------------------------------\r\n\r\n// Assuming a isoceles right angled triangle of height "triangleHeight" (as drawn below).\r\n// This function return the area of the triangle above the first texel(in Y the first texel).\r\n//\r\n// |\\      <-- 45 degree slop isosceles right angled triangle\r\n// | \\\r\n// ----    <-- length of this side is "triangleHeight"\r\n// _ _ _ _ <-- texels\r\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight)\r\n{\r\n    return triangleHeight - 0.5;\r\n}\r\n\r\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\r\n// This function return the area of the triangle above each of those texels.\r\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\r\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\r\n//  /   \\\r\n// _ _ _ _ <-- texels\r\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut)\r\n{\r\n    // Compute the exterior areas,a and h is same.\r\n    float a = offset + 0.5;\r\n    float offsetSquaredHalved = a * a * 0.5;\r\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\r\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\r\n\r\n    // Compute the middle areas\r\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\r\n    // intersect the axis between Y and Z (ie where offset = 0).\r\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\r\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\r\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\r\n    float clampedOffsetLeft = min(offset,0.0);\r\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\r\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\r\n\r\n    // We do the same for the Z but with the right part of the isoceles triangle\r\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\r\n    float clampedOffsetRight = max(offset,0.0);\r\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\r\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\r\n}\r\n\r\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\r\n// This function return the weight of each texels area relative to the full triangle area.\r\n//  /       \\\r\n// _ _ _ _ _ _ <-- texels\r\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB)\r\n{\r\n    vec4 areaFrom3texelTriangle;\r\n    vec4 areaUncutFrom3texelTriangle;\r\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\r\n\r\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\r\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\r\n    // 0.16 is 1/(the triangle area)\r\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\r\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\r\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\r\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\r\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\r\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\r\n}\r\n\r\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\r\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\r\n{\r\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\r\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\r\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\r\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\r\n\r\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\r\n    vec3 texelsWeightsUA, texelsWeightsUB;\r\n    vec3 texelsWeightsVA, texelsWeightsVB;\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\r\n\r\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\r\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\r\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\r\n\r\n    // move the PCF bilinear fetches to respect texels weights\r\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\r\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\r\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\r\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\r\n\r\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\r\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\r\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\r\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\r\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\r\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\r\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\r\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\r\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\r\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\r\n\r\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\r\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\r\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\r\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\r\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\r\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\r\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\r\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\r\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\r\n}', Ni = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n", bi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', Pi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nuniform vec4 u_DiffuseColor;\r\nvarying vec3 v_HideWorldPos;\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r#if defined(HIDEBYPOSITION)\r\n\t uniform float u_HidePosZ;\r\n#endif\r\n\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(HIDEBYPOSITION)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tfloat shadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t\tdif *= shadowAttenuation;\r\n\t\t\t\tspe *= shadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tdirectionLight.color *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tgl_FragColor.rgb+=specular;\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n#if defined(HIDEBYPOSITION)\r\n\t\tif(u_HidePosZ>=v_HideWorldPos.z)discard;\r\n#endif\r\n}\r\n\r\n', wi = '#include "Lighting.glsl";\r\n#include "Shadow.glsl";\r\nvarying vec3 v_HideWorldPos;\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif  \r\n\tv_HideWorldPos=(worldMat*position).xyz;\r\n\t v_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\t\tvec3 positionWS=(worldMat*position).xyz;\r\n\t\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tv_ViewDir = u_CameraPos-positionWS;\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\t\t\tv_PositionWorld = positionWS;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord =getShadowCoord(vec4(positionWS,1.0));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', Vi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', Bi = '#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', Fi = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}", Ui = '#include "Lighting.glsl";\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n', Gi = '// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------', zi = "struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#ifndef SETUP_BRDF_INPUT\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = getMetallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = getAlpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = getOcclusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\tfloat shadowAttenuation = 1.0;\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tshadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t#endif\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tshadowAttenuation *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowAttenuation);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n", Hi = "attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif", Wi = "#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\tuniform sampler2D u_LightMapDirection;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float getAlpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float getOcclusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 getMetallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n", ki = "vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax=(worldInvMat*u_CameraPos-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t#endif\r\n}", Xi = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', Yi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}', ji = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}', Zi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}', qi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}', Qi = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}', Ki = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}', Ji = '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}', $i = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}', ea = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', ta = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}", ra = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}", ia = '#ifndef GRAPHICS_API_GLES3\r\n\t#define NO_NATIVE_SHADOWMAP\r\n#endif\r\n\r\n#ifdef NO_NATIVE_SHADOWMAP\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2D textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName,coord3.xy).r<coord3.z?0.0:1.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\r\n#else\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2DShadow textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName,coord3,0.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW)\r\n    #define CALCULATE_SHADOWS\r\n#endif\r\n\r\nuniform vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\t#include "ShadowSampleTent.glsl"\r\n\r\n\tTEXTURE2D_SHADOW(u_ShadowMap);\r\n\tuniform vec4 u_ShadowMapSize;\r\n\tuniform vec4 u_ShadowParams; // x: shadowStrength\r\n\tuniform mat4 u_ShadowMatrices[4];\r\n\tuniform vec4 u_ShadowSplitSpheres[4];// max cascade is 4\r\n\r\n\tmediump int computeCascadeIndex(vec3 positionWS)\r\n\t{\r\n\t\tvec3 fromCenter0 = positionWS - u_ShadowSplitSpheres[0].xyz;\r\n\t\tvec3 fromCenter1 = positionWS - u_ShadowSplitSpheres[1].xyz;\r\n\t\tvec3 fromCenter2 = positionWS - u_ShadowSplitSpheres[2].xyz;\r\n\t\tvec3 fromCenter3 = positionWS - u_ShadowSplitSpheres[3].xyz;\r\n\r\n\t\tmediump vec4 comparison = vec4(\r\n\t\t\tdot(fromCenter0, fromCenter0)<u_ShadowSplitSpheres[0].w,\r\n\t\t\tdot(fromCenter1, fromCenter1)<u_ShadowSplitSpheres[1].w,\r\n\t\t\tdot(fromCenter2, fromCenter2)<u_ShadowSplitSpheres[2].w,\r\n\t\t\tdot(fromCenter3, fromCenter3)<u_ShadowSplitSpheres[3].w);\r\n\t\tcomparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\r\n\t\tmediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\r\n\t\tmediump int index = 4 - int(dot(comparison, indexCoefficient));\r\n\t\treturn index;\r\n\t}\r\n\r\n\tvec4 getShadowCoord(vec4 positionWS)\r\n\t{\r\n\t\t#ifdef SHADOW_CASCADE\r\n\t\t\tmediump int cascadeIndex = computeCascadeIndex(positionWS.xyz);\r\n\t\t\tif(cascadeIndex > 3)// out of shadow range cascadeIndex is 4.\r\n\t\t\t\treturn vec4(0.0);\r\n\t\t\t\r\n\t\t\t#ifdef GRAPHICS_API_GLES3\r\n\t\t\t\treturn u_ShadowMatrices[cascadeIndex] * positionWS;\r\n\t\t\t#else\r\n\t\t\t\tmat4 shadowMat;\r\n\t\t\t\tif(cascadeIndex == 0)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[0];\r\n\t\t\t\telse if(cascadeIndex == 1)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[1];\r\n\t\t\t\telse if(cascadeIndex == 2)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[2];\r\n\t\t\t\telse\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[3];\r\n\t\t\t\treturn shadowMat * positionWS;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\treturn u_ShadowMatrices[0] * positionWS;\r\n\t\t#endif\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tvec4 attenuation4;\r\n\t\tvec2 offset=shadowMapSize.xy/2.0;\r\n\t\tvec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\r\n\t\tvec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\r\n\t\tvec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\r\n\t\tvec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\r\n\t\tattenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\r\n\t\tattenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\r\n\t\tattenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\r\n\t\tattenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\r\n\t\tattenuation = dot(attenuation4, vec4(0.25));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tfloat fetchesWeights[9];\r\n\t\tvec2 fetchesUV[9];\r\n\t\tsampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\r\n\t\tattenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.x);//shadowParams.x:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\nvec3 applyShadowBias(vec3 positionWS, vec3 normalWS, vec3 lightDirection)\r\n{\r\n    float invNdotL = 1.0 - clamp(dot(-lightDirection, normalWS),0.0,1.0);\r\n    float scale = invNdotL * u_ShadowBias.y;\r\n\r\n    // normal bias is negative since we want to apply an inset normal offset\r\n    positionWS += -lightDirection * u_ShadowBias.xxx;\r\n    positionWS += normalWS * vec3(scale);\r\n    return positionWS;\r\n}\r\n', aa = '#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform mat4 u_ViewProjection;\r\n\r\nuniform vec3 u_ShadowLightDirection;\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nvec4 shadowCasterVertex()\r\n{\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\t\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tworldMat = worldMat * skinTransform;\r\n\t#endif\r\n\r\n\tvec4 positionWS = worldMat * a_Position;\r\n\tvec3 normalWS = normalize(a_Normal*INVERSE_MAT(mat3(worldMat)));//if no normalize will cause precision problem\r\n\r\n\tpositionWS.xyz = applyShadowBias(positionWS.xyz,normalWS,u_ShadowLightDirection);\r\n\r\n\tvec4 positionCS = u_ViewProjection * positionWS;\r\n\tpositionCS.z = max(positionCS.z, 0.0);//min ndc z is 0.0\r\n\r\n\t// //TODO没考虑UV动画呢\r\n\t// #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tv_Texcoord0=a_Texcoord0;\r\n\t// #endif\r\n    return positionCS;\r\n}\r\n', na = "// #ifdef ALPHATEST\r\n// \tuniform float u_AlphaTestValue;\r\n// #endif\r\n\r\n// #ifdef DIFFUSEMAP\r\n// \tuniform sampler2D u_DiffuseTexture;\r\n// #endif\r\n\r\n// #if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n// \tvarying vec2 v_Texcoord0;\r\n// #endif\r\n\r\nvec4 shadowCasterFragment()\r\n{\r\n    return vec4(0.0);\r\n    // #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t// \tif( alpha < u_AlphaTestValue )\r\n\t// \t{\r\n\t// \t\tdiscard;\r\n\t// \t}\r\n\t// #endif\r\n}\r\n", sa = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n", oa = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', la = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n', _a = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n", ha = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ", ca = '#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', da = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n", ua = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', ma = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n', fa = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';
    class Ea {
        constructor() {}
        static __init__() {
            H.SHADERDEFINE_LEGACYSINGALLIGHTING = H.getDefineByName("LEGACYSINGLELIGHTING"), 
            H.SHADERDEFINE_GRAPHICS_API_GLES2 = H.getDefineByName("GRAPHICS_API_GLES2"), H.SHADERDEFINE_GRAPHICS_API_GLES3 = H.getDefineByName("GRAPHICS_API_GLES3"), 
            H.addInclude("Lighting.glsl", yi), H.addInclude("ShadowSampleTent.glsl", Oi), H.addInclude("GlobalIllumination.glsl", Mi), 
            H.addInclude("Shadow.glsl", ia), H.addInclude("ShadowCasterVS.glsl", aa), H.addInclude("ShadowCasterFS.glsl", na), 
            H.addInclude("Colors.glsl", Ji), H.addInclude("Sampling.glsl", ta), H.addInclude("StdLib.glsl", ra), 
            H.addInclude("PBRVSInput.glsl", Hi), H.addInclude("PBRFSInput.glsl", Wi), H.addInclude("LayaPBRBRDF.glsl", Gi), 
            H.addInclude("PBRCore.glsl", zi), H.addInclude("PBRVertex.glsl", ki);
            var e = {
                a_Position: Xe.MESH_POSITION0,
                a_Color: Xe.MESH_COLOR0,
                a_Normal: Xe.MESH_NORMAL0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0,
                a_Texcoord1: Xe.MESH_TEXTURECOORDINATE1,
                a_BoneWeights: Xe.MESH_BLENDWEIGHT0,
                a_BoneIndices: Xe.MESH_BLENDINDICES0,
                a_Tangent0: Xe.MESH_TANGENT0,
                a_MvpMatrix: Xe.MESH_MVPMATRIX_ROW0,
                a_WorldMat: Xe.MESH_WORLDMATRIX_ROW0
            }, t = {
                u_Bones: H.PERIOD_CUSTOM,
                u_DiffuseTexture: H.PERIOD_MATERIAL,
                u_SpecularTexture: H.PERIOD_MATERIAL,
                u_NormalTexture: H.PERIOD_MATERIAL,
                u_AlphaTestValue: H.PERIOD_MATERIAL,
                u_DiffuseColor: H.PERIOD_MATERIAL,
                u_MaterialSpecular: H.PERIOD_MATERIAL,
                u_Shininess: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_WorldMat: H.PERIOD_SPRITE,
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_LightmapScaleOffset: H.PERIOD_SPRITE,
                u_LightMap: H.PERIOD_SPRITE,
                u_LightMapDirection: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_Viewport: H.PERIOD_CAMERA,
                u_ProjectionParams: H.PERIOD_CAMERA,
                u_View: H.PERIOD_CAMERA,
                u_ViewProjection: H.PERIOD_CAMERA,
                u_ReflectTexture: H.PERIOD_SCENE,
                u_ReflectIntensity: H.PERIOD_SCENE,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE,
                u_DirationLightCount: H.PERIOD_SCENE,
                u_LightBuffer: H.PERIOD_SCENE,
                u_LightClusterBuffer: H.PERIOD_SCENE,
                u_AmbientColor: H.PERIOD_SCENE,
                u_ShadowBias: H.PERIOD_SCENE,
                u_ShadowLightDirection: H.PERIOD_SCENE,
                u_ShadowMap: H.PERIOD_SCENE,
                u_ShadowParams: H.PERIOD_SCENE,
                u_ShadowSplitSpheres: H.PERIOD_SCENE,
                u_ShadowMatrices: H.PERIOD_SCENE,
                u_ShadowMapSize: H.PERIOD_SCENE,
                u_AmbientSHAr: H.PERIOD_SCENE,
                u_AmbientSHAg: H.PERIOD_SCENE,
                u_AmbientSHAb: H.PERIOD_SCENE,
                u_AmbientSHBr: H.PERIOD_SCENE,
                u_AmbientSHBg: H.PERIOD_SCENE,
                u_AmbientSHBb: H.PERIOD_SCENE,
                u_AmbientSHC: H.PERIOD_SCENE,
                "u_DirectionLight.color": H.PERIOD_SCENE,
                "u_DirectionLight.direction": H.PERIOD_SCENE,
                "u_PointLight.position": H.PERIOD_SCENE,
                "u_PointLight.range": H.PERIOD_SCENE,
                "u_PointLight.color": H.PERIOD_SCENE,
                "u_SpotLight.position": H.PERIOD_SCENE,
                "u_SpotLight.direction": H.PERIOD_SCENE,
                "u_SpotLight.range": H.PERIOD_SCENE,
                "u_SpotLight.spot": H.PERIOD_SCENE,
                "u_SpotLight.color": H.PERIOD_SCENE,
                u_HidePosZ: H.PERIOD_MATERIAL
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("BLINNPHONG", null, null, !0), a = new ir(e, t);
            i.addSubShader(a), a.addShaderPass(wi, Pi, r, "Forward");
            a.addShaderPass(Bi, Vi, r, "ShadowCaster");
            e = {
                a_Position: Xe.MESH_POSITION0,
                a_Color: Xe.MESH_COLOR0
            }, t = {
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_Color: H.PERIOD_MATERIAL
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("LineShader"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(bi, Ni, r), 
            e = {
                a_Position: Xe.MESH_POSITION0,
                a_Color: Xe.MESH_COLOR0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0,
                a_BoneWeights: Xe.MESH_BLENDWEIGHT0,
                a_BoneIndices: Xe.MESH_BLENDINDICES0,
                a_MvpMatrix: Xe.MESH_MVPMATRIX_ROW0
            }, t = {
                u_Bones: H.PERIOD_CUSTOM,
                u_AlbedoTexture: H.PERIOD_MATERIAL,
                u_AlbedoColor: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_AlphaTestValue: H.PERIOD_MATERIAL,
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("Unlit", null, null, !0), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(ua, da, r), 
            e = {
                a_Position: Xe.MESH_POSITION0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0,
                a_BoneWeights: Xe.MESH_BLENDWEIGHT0,
                a_BoneIndices: Xe.MESH_BLENDINDICES0,
                a_MvpMatrix: Xe.MESH_MVPMATRIX_ROW0
            }, t = {
                u_Bones: H.PERIOD_CUSTOM,
                u_AlbedoTexture: H.PERIOD_MATERIAL,
                u_AlbedoColor: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_AlphaTestValue: H.PERIOD_MATERIAL,
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("Effect", null, null, !0), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(Li, Ai, r), 
            e = {
                a_CornerTextureCoordinate: Zr.PARTICLE_CORNERTEXTURECOORDINATE0,
                a_MeshPosition: Zr.PARTICLE_POSITION0,
                a_MeshColor: Zr.PARTICLE_COLOR0,
                a_MeshTextureCoordinate: Zr.PARTICLE_TEXTURECOORDINATE0,
                a_ShapePositionStartLifeTime: Zr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                a_DirectionTime: Zr.PARTICLE_DIRECTIONTIME,
                a_StartColor: Zr.PARTICLE_STARTCOLOR0,
                a_EndColor: Zr.PARTICLE_ENDCOLOR0,
                a_StartSize: Zr.PARTICLE_STARTSIZE,
                a_StartRotation0: Zr.PARTICLE_STARTROTATION,
                a_StartSpeed: Zr.PARTICLE_STARTSPEED,
                a_Random0: Zr.PARTICLE_RANDOM0,
                a_Random1: Zr.PARTICLE_RANDOM1,
                a_SimulationWorldPostion: Zr.PARTICLE_SIMULATIONWORLDPOSTION,
                a_SimulationWorldRotation: Zr.PARTICLE_SIMULATIONWORLDROTATION
            }, t = {
                u_Tintcolor: H.PERIOD_MATERIAL,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_texture: H.PERIOD_MATERIAL,
                u_WorldPosition: H.PERIOD_SPRITE,
                u_WorldRotation: H.PERIOD_SPRITE,
                u_PositionScale: H.PERIOD_SPRITE,
                u_SizeScale: H.PERIOD_SPRITE,
                u_ScalingMode: H.PERIOD_SPRITE,
                u_Gravity: H.PERIOD_SPRITE,
                u_ThreeDStartRotation: H.PERIOD_SPRITE,
                u_StretchedBillboardLengthScale: H.PERIOD_SPRITE,
                u_StretchedBillboardSpeedScale: H.PERIOD_SPRITE,
                u_SimulationSpace: H.PERIOD_SPRITE,
                u_CurrentTime: H.PERIOD_SPRITE,
                u_ColorOverLifeGradientAlphas: H.PERIOD_SPRITE,
                u_ColorOverLifeGradientColors: H.PERIOD_SPRITE,
                u_MaxColorOverLifeGradientAlphas: H.PERIOD_SPRITE,
                u_MaxColorOverLifeGradientColors: H.PERIOD_SPRITE,
                u_VOLVelocityConst: H.PERIOD_SPRITE,
                u_VOLVelocityGradientX: H.PERIOD_SPRITE,
                u_VOLVelocityGradientY: H.PERIOD_SPRITE,
                u_VOLVelocityGradientZ: H.PERIOD_SPRITE,
                u_VOLVelocityConstMax: H.PERIOD_SPRITE,
                u_VOLVelocityGradientMaxX: H.PERIOD_SPRITE,
                u_VOLVelocityGradientMaxY: H.PERIOD_SPRITE,
                u_VOLVelocityGradientMaxZ: H.PERIOD_SPRITE,
                u_VOLSpaceType: H.PERIOD_SPRITE,
                u_SOLSizeGradient: H.PERIOD_SPRITE,
                u_SOLSizeGradientX: H.PERIOD_SPRITE,
                u_SOLSizeGradientY: H.PERIOD_SPRITE,
                u_SOLSizeGradientZ: H.PERIOD_SPRITE,
                u_SOLSizeGradientMax: H.PERIOD_SPRITE,
                u_SOLSizeGradientMaxX: H.PERIOD_SPRITE,
                u_SOLSizeGradientMaxY: H.PERIOD_SPRITE,
                u_SOLSizeGradientMaxZ: H.PERIOD_SPRITE,
                u_ROLAngularVelocityConst: H.PERIOD_SPRITE,
                u_ROLAngularVelocityConstSeprarate: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradient: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientX: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientY: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientZ: H.PERIOD_SPRITE,
                u_ROLAngularVelocityConstMax: H.PERIOD_SPRITE,
                u_ROLAngularVelocityConstMaxSeprarate: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientMax: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientMaxX: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientMaxY: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientMaxZ: H.PERIOD_SPRITE,
                u_ROLAngularVelocityGradientMaxW: H.PERIOD_SPRITE,
                u_TSACycles: H.PERIOD_SPRITE,
                u_TSASubUVLength: H.PERIOD_SPRITE,
                u_TSAGradientUVs: H.PERIOD_SPRITE,
                u_TSAMaxGradientUVs: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_CameraDirection: H.PERIOD_CAMERA,
                u_CameraUp: H.PERIOD_CAMERA,
                u_View: H.PERIOD_CAMERA,
                u_Projection: H.PERIOD_CAMERA,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("PARTICLESHURIKEN"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(Ui, Fi, r), 
            e = {
                a_Position: Xe.MESH_POSITION0
            }, t = {
                u_TintColor: H.PERIOD_MATERIAL,
                u_Exposure: H.PERIOD_MATERIAL,
                u_Rotation: H.PERIOD_MATERIAL,
                u_CubeTexture: H.PERIOD_MATERIAL,
                u_ViewProjection: H.PERIOD_CAMERA
            }, i = H.add("SkyBox"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(oa, sa), 
            e = {
                a_Position: Xe.MESH_POSITION0
            }, t = {
                u_SunSize: H.PERIOD_MATERIAL,
                u_SunSizeConvergence: H.PERIOD_MATERIAL,
                u_AtmosphereThickness: H.PERIOD_MATERIAL,
                u_SkyTint: H.PERIOD_MATERIAL,
                u_GroundTint: H.PERIOD_MATERIAL,
                u_Exposure: H.PERIOD_MATERIAL,
                u_ViewProjection: H.PERIOD_CAMERA,
                "u_SunLight.direction": H.PERIOD_SCENE,
                "u_SunLight.color": H.PERIOD_SCENE
            }, i = H.add("SkyBoxProcedural"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(_a, la), 
            e = {
                a_Position: Xe.MESH_POSITION0,
                a_Normal: Xe.MESH_NORMAL0,
                a_Texcoord0: Xe.MESH_TEXTURECOORDINATE0
            }, t = {
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_WorldMat: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_Viewport: H.PERIOD_CAMERA,
                u_ProjectionParams: H.PERIOD_CAMERA,
                u_View: H.PERIOD_CAMERA,
                u_LightmapScaleOffset: H.PERIOD_SPRITE,
                u_LightMap: H.PERIOD_SPRITE,
                u_SplatAlphaTexture: H.PERIOD_MATERIAL,
                u_DiffuseTexture1: H.PERIOD_MATERIAL,
                u_DiffuseTexture2: H.PERIOD_MATERIAL,
                u_DiffuseTexture3: H.PERIOD_MATERIAL,
                u_DiffuseTexture4: H.PERIOD_MATERIAL,
                u_DiffuseTexture5: H.PERIOD_MATERIAL,
                u_DiffuseScaleOffset1: H.PERIOD_MATERIAL,
                u_DiffuseScaleOffset2: H.PERIOD_MATERIAL,
                u_DiffuseScaleOffset3: H.PERIOD_MATERIAL,
                u_DiffuseScaleOffset4: H.PERIOD_MATERIAL,
                u_DiffuseScaleOffset5: H.PERIOD_MATERIAL,
                u_FogStart: H.PERIOD_SCENE,
                u_FogRange: H.PERIOD_SCENE,
                u_FogColor: H.PERIOD_SCENE,
                u_DirationLightCount: H.PERIOD_SCENE,
                u_LightBuffer: H.PERIOD_SCENE,
                u_LightClusterBuffer: H.PERIOD_SCENE,
                u_AmbientColor: H.PERIOD_SCENE,
                u_ShadowMap: H.PERIOD_SCENE,
                u_shadowMap2: H.PERIOD_SCENE,
                u_shadowMap3: H.PERIOD_SCENE,
                u_ShadowSplitSpheres: H.PERIOD_SCENE,
                u_ShadowMatrices: H.PERIOD_SCENE,
                u_ShadowMapSize: H.PERIOD_SCENE,
                "u_DirectionLight.color": H.PERIOD_SCENE,
                "u_DirectionLight.direction": H.PERIOD_SCENE,
                "u_PointLight.position": H.PERIOD_SCENE,
                "u_PointLight.range": H.PERIOD_SCENE,
                "u_PointLight.color": H.PERIOD_SCENE,
                "u_SpotLight.position": H.PERIOD_SCENE,
                "u_SpotLight.direction": H.PERIOD_SCENE,
                "u_SpotLight.range": H.PERIOD_SCENE,
                "u_SpotLight.spot": H.PERIOD_SCENE,
                "u_SpotLight.color": H.PERIOD_SCENE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("ExtendTerrain"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(Di, Ci, r), 
            e = {
                a_Position: oi.TRAIL_POSITION0,
                a_OffsetVector: oi.TRAIL_OFFSETVECTOR,
                a_Texcoord0X: oi.TRAIL_TEXTURECOORDINATE0X,
                a_Texcoord0Y: oi.TRAIL_TEXTURECOORDINATE0Y,
                a_BirthTime: oi.TRAIL_TIME0,
                a_Color: oi.TRAIL_COLOR
            }, t = {
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_View: H.PERIOD_CAMERA,
                u_Projection: H.PERIOD_CAMERA,
                u_TilingOffset: H.PERIOD_MATERIAL,
                u_MainTexture: H.PERIOD_MATERIAL,
                u_MainColor: H.PERIOD_MATERIAL,
                u_CurTime: H.PERIOD_SPRITE,
                u_LifeTime: H.PERIOD_SPRITE,
                u_WidthCurve: H.PERIOD_SPRITE,
                u_WidthCurveKeyLength: H.PERIOD_SPRITE,
                u_GradientColorkey: H.PERIOD_SPRITE,
                u_GradientAlphakey: H.PERIOD_SPRITE
            }, r = {
                s_Cull: H.RENDER_STATE_CULL,
                s_Blend: H.RENDER_STATE_BLEND,
                s_BlendSrc: H.RENDER_STATE_BLEND_SRC,
                s_BlendDst: H.RENDER_STATE_BLEND_DST,
                s_DepthTest: H.RENDER_STATE_DEPTH_TEST,
                s_DepthWrite: H.RENDER_STATE_DEPTH_WRITE
            }, i = H.add("Trail"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(ca, ha, r), 
            e = {
                a_Position: Xe.MESH_POSITION0,
                a_Normal: Xe.MESH_NORMAL0,
                a_Tangent0: Xe.MESH_TANGENT0
            }, t = {
                u_MvpMatrix: H.PERIOD_SPRITE,
                u_WorldMat: H.PERIOD_SPRITE,
                u_CameraPos: H.PERIOD_CAMERA,
                u_Time: H.PERIOD_SCENE,
                u_MainTexture: H.PERIOD_MATERIAL,
                u_NormalTexture: H.PERIOD_MATERIAL,
                u_HorizonColor: H.PERIOD_MATERIAL,
                u_WaveScale: H.PERIOD_MATERIAL,
                u_WaveSpeed: H.PERIOD_MATERIAL
            }, i = H.add("WaterPrimary"), a = new ir(e, t), i.addSubShader(a), a.addShaderPass(fa, ma), 
            e = {
                a_PositionTexcoord: Xe.MESH_POSITION0
            }, t = {
                u_MainTex: H.PERIOD_MATERIAL,
                u_OffsetScale: H.PERIOD_MATERIAL
            }, i = H.add("BlitScreen"), a = new ir(e, t), i.addSubShader(a);
            var n = a.addShaderPass(Ii, xi).renderState;
            n.depthTest = Q.DEPTHTEST_ALWAYS, n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, 
            e = {
                a_PositionTexcoord: Xe.MESH_POSITION0
            }, t = {
                u_MainTex: H.PERIOD_MATERIAL,
                u_BloomTex: H.PERIOD_MATERIAL,
                u_AutoExposureTex: H.PERIOD_MATERIAL,
                u_MainTex_TexelSize: H.PERIOD_MATERIAL,
                u_SampleScale: H.PERIOD_MATERIAL,
                u_Threshold: H.PERIOD_MATERIAL,
                u_Params: H.PERIOD_MATERIAL
            }, i = H.add("PostProcessBloom"), a = new ir(e, t), i.addSubShader(a), (n = a.addShaderPass(Xi, Zi).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, a = new ir(e, t), 
            i.addSubShader(a), (n = a.addShaderPass(Xi, qi).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, a = new ir(e, t), 
            i.addSubShader(a), (n = a.addShaderPass(Xi, Yi).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, a = new ir(e, t), 
            i.addSubShader(a), (n = a.addShaderPass(Xi, ji).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, a = new ir(e, t), 
            i.addSubShader(a), (n = a.addShaderPass(Xi, Ki).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, a = new ir(e, t), 
            i.addSubShader(a), (n = a.addShaderPass(Xi, Qi).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE, e = {
                a_PositionTexcoord: Xe.MESH_POSITION0
            }, t = {
                u_MainTex: H.PERIOD_MATERIAL,
                u_BloomTex: H.PERIOD_MATERIAL,
                u_AutoExposureTex: H.PERIOD_MATERIAL,
                u_Bloom_DirtTileOffset: H.PERIOD_MATERIAL,
                u_Bloom_DirtTex: H.PERIOD_MATERIAL,
                u_BloomTex_TexelSize: H.PERIOD_MATERIAL,
                u_Bloom_Settings: H.PERIOD_MATERIAL,
                u_Bloom_Color: H.PERIOD_MATERIAL
            }, i = H.add("PostProcessComposite"), a = new ir(e, t), i.addSubShader(a), (n = a.addShaderPass(ea, $i).renderState).depthTest = Q.DEPTHTEST_ALWAYS, 
            n.depthWrite = !1, n.cull = Q.CULL_NONE, n.blend = Q.BLEND_DISABLE;
        }
    }
    class Ta extends nt {
        constructor() {
            super(), this._direction = new n(), this._shadowCascadesMode = e.ShadowCascadesMode.NoCascades, 
            this._shadowTwoCascadeSplits = 1 / 3, this._shadowFourCascadeSplits = new n(1 / 15, .2, 7 / 15), 
            this._lightType = e.LightType.Directional;
        }
        get shadowCascadesMode() {
            return this._shadowCascadesMode;
        }
        set shadowCascadesMode(e) {
            this._shadowCascadesMode = e;
        }
        get shadowTwoCascadeSplits() {
            return this._shadowTwoCascadeSplits;
        }
        set shadowTwoCascadeSplits(e) {
            this._shadowTwoCascadeSplits = e;
        }
        get shadowFourCascadeSplits() {
            return this._shadowFourCascadeSplits;
        }
        set shadowFourCascadeSplits(e) {
            if (e.x > e.y || e.y > e.z || e.z > 1) throw "DiretionLight:Invalid value.";
            e.cloneTo(this._shadowFourCascadeSplits);
        }
        _addToLightQueue() {
            this._scene._directionLights.add(this);
        }
        _removeFromLightQueue() {
            this._scene._directionLights.remove(this);
        }
    }
    class pa extends nt {
        get range() {
            return this._range;
        }
        set range(e) {
            this._range = e;
        }
        constructor() {
            super(), this._range = 6, this._lightType = e.LightType.Point;
        }
        _addToLightQueue() {
            this._scene._pointLights.add(this);
        }
        _removeFromLightQueue() {
            this._scene._pointLights.remove(this);
        }
        _parse(e, t) {
            super._parse(e, t), this.range = e.range;
        }
    }
    class ga extends nt {
        get spotAngle() {
            return this._spotAngle;
        }
        set spotAngle(e) {
            this._spotAngle = Math.max(Math.min(e, 179), 0);
        }
        get range() {
            return this._range;
        }
        set range(e) {
            this._range = e;
        }
        constructor() {
            super(), this._spotAngle = 30, this._range = 10, this._direction = new n(), this._lightType = e.LightType.Spot;
        }
        _addToLightQueue() {
            this._scene._spotLights.add(this);
        }
        _removeFromLightQueue() {
            this._scene._spotLights.remove(this);
        }
        _parse(e, t) {
            super._parse(e, t), this.range = e.range, this.spotAngle = e.spotAngle;
        }
    }
    class Sa {
        static _createSprite3DInstance(e, t, r) {
            var i;
            switch (e.type) {
              case "Scene3D":
                i = new tr();
                break;

              case "Sprite3D":
                i = new ve();
                break;

              case "MeshSprite3D":
                i = new Rr(), r && e.props.isStatic && r.push(i);
                break;

              case "SkinnedMeshSprite3D":
                i = new ai();
                break;

              case "ShuriKenParticle3D":
                i = new ti();
                break;

              case "Camera":
                i = new ot();
                break;

              case "DirectionLight":
                i = new Ta();
                break;

              case "PointLight":
                i = new pa();
                break;

              case "SpotLight":
                i = new ga();
                break;

              case "TrailSprite3D":
                i = new ci();
                break;

              default:
                throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var a = e.child;
            if (a) for (var n = 0, s = a.length; n < s; n++) {
                var o = Sa._createSprite3DInstance(a[n], t, r);
                i.addChild(o);
            }
            return t[e.instanceID] = i, i;
        }
        static _createComponentInstance(e, r) {
            var i = r[e.instanceID];
            i._parse(e.props, r);
            var a = e.child;
            if (a) for (var n = 0, s = a.length; n < s; n++) Sa._createComponentInstance(a[n], r);
            var o = e.components;
            if (o) for (var l = 0, _ = o.length; l < _; l++) {
                var h = o[l], c = t.ClassUtils.getRegClass(h.type);
                if (c) i.addComponent(c)._parse(h); else console.warn("Unkown component type.");
            }
        }
        static _createNodeByJson02(e, t) {
            var r = {}, i = Sa._createSprite3DInstance(e, r, t);
            return Sa._createComponentInstance(e, r), i;
        }
        static _parse(e, t = null, r = null) {
            var i, a = e.data, n = [];
            switch (e.version) {
              case "LAYAHIERARCHY:02":
                i = Sa._createNodeByJson02(a, n);
                break;

              default:
                i = Sa._createNodeByJson(a, n);
            }
            return Ie.combine(i, n), i;
        }
        static _parseScene(e, t = null, r = null) {
            var i, a = e.data, n = [];
            switch (e.version) {
              case "LAYASCENE3D:02":
                i = Sa._createNodeByJson02(a, n);
                break;

              default:
                i = Sa._createNodeByJson(a, n);
            }
            return Ie.combine(null, n), i;
        }
        static _createNodeByJson(e, r) {
            var i;
            switch (e.type) {
              case "Scene3D":
                i = new tr();
                break;

              case "Sprite3D":
                i = new ve();
                break;

              case "MeshSprite3D":
                i = new Rr(), r && e.props.isStatic && r.push(i);
                break;

              case "SkinnedMeshSprite3D":
                i = new ai();
                break;

              case "ShuriKenParticle3D":
                i = new ti();
                break;

              case "Camera":
                i = new ot();
                break;

              case "DirectionLight":
                i = new Ta();
                break;

              case "PointLight":
                i = new pa();
                break;

              case "SpotLight":
                i = new ga();
                break;

              case "TrailSprite3D":
                i = new ci();
                break;

              default:
                throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var a = e.child;
            if (a) for (var n = 0, s = a.length; n < s; n++) {
                var o = Sa._createNodeByJson(a[n], r);
                i.addChild(o);
            }
            var l = e.components;
            if (l) for (var _ = 0, h = l.length; _ < h; _++) {
                var c = l[_], d = t.ClassUtils.getRegClass(c.type);
                if (d) i.addComponent(d)._parse(c); else console.warn("Unkown component type.");
            }
            return i._parse(e.props, null), i;
        }
    }
    class Ra {
        static parse(e, t, r, i) {
            Ra._mesh = r, Ra._subMeshes = i, Ra._version = t, Ra._readData = e, Ra.READ_DATA(), 
            Ra.READ_BLOCK(), Ra.READ_STRINGS();
            for (var a = 0, n = Ra._BLOCK.count; a < n; a++) {
                Ra._readData.pos = Ra._BLOCK.blockStarts[a];
                var s = Ra._readData.getUint16(), o = Ra._strings[s], l = Ra["READ_" + o];
                if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                l.call(null);
            }
            Ra._strings.length = 0, Ra._readData = null, Ra._version = null, Ra._mesh = null, 
            Ra._subMeshes = null;
        }
        static _readString() {
            return Ra._strings[Ra._readData.getUint16()];
        }
        static READ_DATA() {
            Ra._DATA.offset = Ra._readData.getUint32(), Ra._DATA.size = Ra._readData.getUint32();
        }
        static READ_BLOCK() {
            for (var e = Ra._BLOCK.count = Ra._readData.getUint16(), t = Ra._BLOCK.blockStarts = [], r = Ra._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(Ra._readData.getUint32()), 
            r.push(Ra._readData.getUint32());
        }
        static READ_STRINGS() {
            var e = Ra._readData.getUint32(), t = Ra._readData.getUint16(), r = Ra._readData.pos;
            Ra._readData.pos = e + Ra._DATA.offset;
            for (var i = 0; i < t; i++) Ra._strings[i] = Ra._readData.readUTFString();
            Ra._readData.pos = r;
        }
        static READ_MESH() {
            var r, i = t.LayaGL.instance, a = (Ra._readString(), Ra._readData.__getBuffer()), n = 0, s = Ra._readData.getInt16(), o = Ra._DATA.offset;
            for (r = 0; r < s; r++) {
                var l, _ = o + Ra._readData.getUint32(), h = Ra._readData.getUint32(), c = a.slice(_, _ + h), d = new Float32Array(c), u = Ra._readString();
                switch (Ra._version) {
                  case "LAYAMODEL:0301":
                  case "LAYAMODEL:0400":
                    l = Xe.getVertexDeclaration(u);
                    break;

                  case "LAYAMODEL:0401":
                    l = Xe.getVertexDeclaration(u, !1);
                    break;

                  default:
                    throw new Error("LoadModelV03: unknown version.");
                }
                if (!l) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                var m = new Ye(4 * d.length, i.STATIC_DRAW, !0);
                m.vertexDeclaration = l, m.setData(d.buffer), Ra._mesh._vertexBuffer = m, Ra._mesh._vertexCount += m._byteLength / l.vertexStride, 
                n += 4 * d.length;
            }
            var f = o + Ra._readData.getUint32(), E = Ra._readData.getUint32(), T = new Uint16Array(a.slice(f, f + E)), p = new ze(e.IndexFormat.UInt16, E / 2, i.STATIC_DRAW, !0);
            p.setData(T), Ra._mesh._indexBuffer = p, n += 2 * p.indexCount, Ra._mesh._setBuffer(Ra._mesh._vertexBuffer, p), 
            Ra._mesh._setCPUMemory(n), Ra._mesh._setGPUMemory(n);
            var g = Ra._mesh._boneNames = [], S = Ra._readData.getUint16();
            for (g.length = S, r = 0; r < S; r++) g[r] = Ra._strings[Ra._readData.getUint16()];
            Ra._readData.pos += 8;
            var R = Ra._readData.getUint32(), v = Ra._readData.getUint32(), x = new Float32Array(a.slice(o + R, o + R + v)), I = x.length, A = Ra._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * I);
            for (Ra._mesh._inverseBindPoses = [], r = 0; r < I; r += 16) {
                var L = new y(x[r + 0], x[r + 1], x[r + 2], x[r + 3], x[r + 4], x[r + 5], x[r + 6], x[r + 7], x[r + 8], x[r + 9], x[r + 10], x[r + 11], x[r + 12], x[r + 13], x[r + 14], x[r + 15], new Float32Array(A, 4 * r, 16));
                Ra._mesh._inverseBindPoses[r / 16] = L;
            }
            return !0;
        }
        static READ_SUBMESH() {
            var e = Ra._readData.__getBuffer(), t = new gi(Ra._mesh);
            Ra._readData.getInt16(), Ra._readData.getUint32(), Ra._readData.getUint32();
            var r = Ra._readData.getUint32(), i = Ra._readData.getUint32(), a = Ra._mesh._indexBuffer;
            t._indexBuffer = a, t._setIndexRange(r, i);
            var n = Ra._mesh._vertexBuffer;
            t._vertexBuffer = n;
            var s = Ra._DATA.offset, o = t._subIndexBufferStart, l = t._subIndexBufferCount, _ = t._boneIndicesList, h = Ra._readData.getUint16();
            o.length = h, l.length = h, _.length = h;
            var c = Ra._mesh._skinnedMatrixCaches, d = Ra._subMeshes.length;
            c.length = Ra._mesh._inverseBindPoses.length;
            for (var u = 0; u < h; u++) {
                o[u] = Ra._readData.getUint32(), l[u] = Ra._readData.getUint32();
                for (var m = Ra._readData.getUint32(), f = Ra._readData.getUint32(), E = _[u] = new Uint16Array(e.slice(s + m, s + m + f)), T = E.length, p = 0; p < T; p++) {
                    var g = E[p];
                    c[g] || (c[g] = new Si(d, u, p));
                }
            }
            return Ra._subMeshes.push(t), !0;
        }
    }
    Ra._BLOCK = {
        count: 0
    }, Ra._DATA = {
        offset: 0,
        size: 0
    }, Ra._strings = [];
    class va {
        static parse(e, t, r, i) {
            va._mesh = r, va._subMeshes = i, va._version = t, va._readData = e, va.READ_DATA(), 
            va.READ_BLOCK(), va.READ_STRINGS();
            for (var a = 0, n = va._BLOCK.count; a < n; a++) {
                va._readData.pos = va._BLOCK.blockStarts[a];
                var s = va._readData.getUint16(), o = va._strings[s], l = va["READ_" + o];
                if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                l.call(null);
            }
            va._strings.length = 0, va._readData = null, va._version = null, va._mesh = null, 
            va._subMeshes = null;
        }
        static _readString() {
            return va._strings[va._readData.getUint16()];
        }
        static READ_DATA() {
            va._DATA.offset = va._readData.getUint32(), va._DATA.size = va._readData.getUint32();
        }
        static READ_BLOCK() {
            for (var e = va._BLOCK.count = va._readData.getUint16(), t = va._BLOCK.blockStarts = [], r = va._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(va._readData.getUint32()), 
            r.push(va._readData.getUint32());
        }
        static READ_STRINGS() {
            var e = va._readData.getUint32(), t = va._readData.getUint16(), r = va._readData.pos;
            va._readData.pos = e + va._DATA.offset;
            for (var i = 0; i < t; i++) va._strings[i] = va._readData.readUTFString();
            va._readData.pos = r;
        }
        static READ_MESH() {
            var r, i = t.LayaGL.instance, a = 0, n = (va._readString(), va._readData), s = n.__getBuffer(), o = n.getInt16(), l = va._DATA.offset;
            for (r = 0; r < o; r++) {
                var _, h, c, d = l + n.getUint32(), u = n.getUint32(), m = va._readString(), f = Xe.getVertexDeclaration(m, !1), E = f.vertexStride, T = m.split(","), p = T.length, S = va._mesh;
                switch (va._version) {
                  case "LAYAMODEL:05":
                  case "LAYAMODEL:0501":
                    _ = s.slice(d, d + u * E), h = new Float32Array(_), c = new Uint8Array(_);
                    break;

                  case "LAYAMODEL:COMPRESSION_05":
                  case "LAYAMODEL:COMPRESSION_0501":
                    _ = new ArrayBuffer(E * u), h = new Float32Array(_), c = new Uint8Array(_);
                    var R = n.pos;
                    n.pos = d;
                    for (var v = 0; v < u; v++) for (var x, I = v * E, A = 0; A < p; A++) switch (T[A]) {
                      case "POSITION":
                        h[x = I / 4] = g.convertToNumber(n.getUint16()), h[x + 1] = g.convertToNumber(n.getUint16()), 
                        h[x + 2] = g.convertToNumber(n.getUint16()), I += 12;
                        break;

                      case "NORMAL":
                        h[x = I / 4] = n.getUint8() / 127.5 - 1, h[x + 1] = n.getUint8() / 127.5 - 1, h[x + 2] = n.getUint8() / 127.5 - 1, 
                        I += 12;
                        break;

                      case "COLOR":
                        h[x = I / 4] = n.getUint8() / 255, h[x + 1] = n.getUint8() / 255, h[x + 2] = n.getUint8() / 255, 
                        h[x + 3] = n.getUint8() / 255, I += 16;
                        break;

                      case "UV":
                      case "UV1":
                        h[x = I / 4] = g.convertToNumber(n.getUint16()), h[x + 1] = g.convertToNumber(n.getUint16()), 
                        I += 8;
                        break;

                      case "BLENDWEIGHT":
                        h[x = I / 4] = n.getUint8() / 255, h[x + 1] = n.getUint8() / 255, h[x + 2] = n.getUint8() / 255, 
                        h[x + 3] = n.getUint8() / 255, I += 16;
                        break;

                      case "BLENDINDICES":
                        c[I] = n.getUint8(), c[I + 1] = n.getUint8(), c[I + 2] = n.getUint8(), c[I + 3] = n.getUint8(), 
                        I += 4;
                        break;

                      case "TANGENT":
                        h[x = I / 4] = n.getUint8() / 127.5 - 1, h[x + 1] = n.getUint8() / 127.5 - 1, h[x + 2] = n.getUint8() / 127.5 - 1, 
                        h[x + 3] = n.getUint8() / 127.5 - 1, I += 16;
                    }
                    n.pos = R;
                }
                var L = new Ye(_.byteLength, i.STATIC_DRAW, !0);
                L.vertexDeclaration = f, L.setData(_);
                u = L._byteLength / f.vertexStride;
                S._indexFormat = u > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16, S._vertexBuffer = L, 
                S._vertexCount += u, a += 4 * h.length;
            }
            var C, D = l + n.getUint32(), M = n.getUint32();
            C = S.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(s.slice(D, D + M)) : new Uint16Array(s.slice(D, D + M));
            var O = new ze(S.indexFormat, C.length, i.STATIC_DRAW, !0);
            if (O.setData(C), S._indexBuffer = O, S._setBuffer(S._vertexBuffer, O), a += 2 * O.indexCount, 
            S._setCPUMemory(a), S._setGPUMemory(a), "LAYAMODEL:0501" == va._version || "LAYAMODEL:COMPRESSION_0501" == va._version) {
                var N = S.bounds, b = N.getMin(), P = N.getMax();
                b.setValue(n.getFloat32(), n.getFloat32(), n.getFloat32()), P.setValue(n.getFloat32(), n.getFloat32(), n.getFloat32()), 
                N.setMin(b), N.setMax(P), S.bounds = N;
            }
            var w = S._boneNames = [], V = n.getUint16();
            for (w.length = V, r = 0; r < V; r++) w[r] = va._strings[n.getUint16()];
            var B = n.getUint32(), F = n.getUint32(), U = new Float32Array(s.slice(l + B, l + B + F)), G = U.length, z = S._inverseBindPosesBuffer = new ArrayBuffer(4 * G);
            for (S._inverseBindPoses = [], r = 0; r < G; r += 16) {
                var H = new y(U[r + 0], U[r + 1], U[r + 2], U[r + 3], U[r + 4], U[r + 5], U[r + 6], U[r + 7], U[r + 8], U[r + 9], U[r + 10], U[r + 11], U[r + 12], U[r + 13], U[r + 14], U[r + 15], new Float32Array(z, 4 * r, 16));
                S._inverseBindPoses[r / 16] = H;
            }
            return !0;
        }
        static READ_SUBMESH() {
            var e = va._readData, t = e.__getBuffer(), r = new gi(va._mesh);
            e.getInt16();
            var i = e.getUint32(), a = e.getUint32(), n = va._mesh._indexBuffer;
            r._indexBuffer = n, r._setIndexRange(i, a);
            var s = va._mesh._vertexBuffer;
            r._vertexBuffer = s;
            var o = va._DATA.offset, l = r._subIndexBufferStart, _ = r._subIndexBufferCount, h = r._boneIndicesList, c = e.getUint16();
            l.length = c, _.length = c, h.length = c;
            var d = va._mesh._skinnedMatrixCaches, u = va._subMeshes.length;
            d.length = va._mesh._inverseBindPoses.length;
            for (var m = 0; m < c; m++) {
                l[m] = e.getUint32(), _[m] = e.getUint32();
                for (var f = e.getUint32(), E = e.getUint32(), T = h[m] = new Uint16Array(t.slice(o + f, o + f + E)), p = 0, g = T.length; p < g; p++) {
                    var S = T[p];
                    d[S] || (d[S] = new Si(u, m, p));
                }
            }
            return va._subMeshes.push(r), !0;
        }
    }
    va._BLOCK = {
        count: 0
    }, va._DATA = {
        offset: 0,
        size: 0
    }, va._strings = [];
    class xa {
        static _parse(e, t = null, r = null) {
            var i = new Ri();
            return xa.read(e, i, i._subMeshes), i;
        }
        static read(e, r, i) {
            var a = new t.Byte(e);
            a.pos = 0;
            var n = a.readUTFString();
            switch (n) {
              case "LAYAMODEL:0301":
              case "LAYAMODEL:0400":
              case "LAYAMODEL:0401":
                Ra.parse(a, n, r, i);
                break;

              case "LAYAMODEL:05":
              case "LAYAMODEL:COMPRESSION_05":
              case "LAYAMODEL:0501":
              case "LAYAMODEL:COMPRESSION_0501":
                va.parse(a, n, r, i);
                break;

              default:
                throw new Error("MeshReader: unknown mesh version.");
            }
            r._setSubMeshes(i), "LAYAMODEL:0501" != n && "LAYAMODEL:COMPRESSION_0501" != n && r.calculateBounds();
        }
    }
    var Ia = '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n', Aa = '#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n';
    class La extends Z {
        constructor() {
            super(), this._exposure = 1, this._textureDecodeFormat = t.TextureDecodeFormat.Normal, 
            this._textureHDRParams = new a(1, 0, 0, 1), this.setShaderName("SkyPanoramic");
            var e = this._shaderValues;
            e.setVector(La.TINTCOLOR, new a(.5, .5, .5, .5)), e.setNumber(La.ROTATION, 0), e.setVector(La.TEXTURE_HDR_PARAMS, this._textureHDRParams);
        }
        static __init__() {
            var e = {
                a_Position: Xe.MESH_POSITION0
            }, t = {
                u_TintColor: H.PERIOD_MATERIAL,
                u_TextureHDRParams: H.PERIOD_MATERIAL,
                u_Rotation: H.PERIOD_MATERIAL,
                u_Texture: H.PERIOD_MATERIAL,
                u_ViewProjection: H.PERIOD_CAMERA
            }, r = H.add("SkyPanoramic"), i = new ir(e, t);
            r.addSubShader(i), i.addShaderPass(Aa, Ia);
        }
        get tintColor() {
            return this._shaderValues.getVector(La.TINTCOLOR);
        }
        set tintColor(e) {
            this._shaderValues.setVector(La.TINTCOLOR, e);
        }
        get exposure() {
            return this._exposure;
        }
        set exposure(e) {
            this._exposure !== e && (this._exposure = e, this._textureDecodeFormat == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture._rgbmRange : this._textureHDRParams.x = e);
        }
        get rotation() {
            return this._shaderValues.getNumber(La.ROTATION);
        }
        set rotation(e) {
            this._shaderValues.setNumber(La.ROTATION, e);
        }
        get panoramicTexture() {
            return this._shaderValues.getTexture(La.TEXTURE);
        }
        set panoramicTexture(e) {
            this._shaderValues.setTexture(La.TEXTURE, e);
        }
        get panoramicTextureDecodeFormat() {
            return this._textureDecodeFormat;
        }
        set panoramicTextureDecodeFormat(e) {
            this._textureDecodeFormat !== e && (this._textureDecodeFormat = e, e == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure * t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure);
        }
    }
    La.TINTCOLOR = H.propertyNameToID("u_TintColor"), La.EXPOSURE = H.propertyNameToID("u_Exposure"), 
    La.ROTATION = H.propertyNameToID("u_Rotation"), La.TEXTURE = H.propertyNameToID("u_Texture"), 
    La.TEXTURE_HDR_PARAMS = H.propertyNameToID("u_TextureHDRParams");
    class Ca {
        constructor() {}
        static get enablePhysics() {
            return v._enablePhysics;
        }
        static _cancelLoadByUrl(e) {
            t.Laya.loader.cancelLoadByUrl(e), Ca._innerFirstLevelLoaderManager.cancelLoadByUrl(e), 
            Ca._innerSecondLevelLoaderManager.cancelLoadByUrl(e), Ca._innerThirdLevelLoaderManager.cancelLoadByUrl(e), 
            Ca._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
        }
        static _changeWebGLSize(e, r) {
            t.WebGL.onStageResize(e, r), V.clientWidth = e, V.clientHeight = r;
        }
        static __init__(e, r, i) {
            if (t.Config.isAntialias = i.isAntialias, t.Config.isAlpha = i.isAlpha, t.Config.premultipliedAlpha = i.premultipliedAlpha, 
            t.Config.isStencil = i.isStencil, t.WebGL.enable()) {
                t.RunDriver.changeWebGLSize = Ca._changeWebGLSize, t.Render.is3DMode = !0, t.Laya.init(e, r), 
                t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext, 
                t.LayaGL.instance.createCommandEncoder = function(e = 128, r = 64, i = !1) {
                    return new t.CommandEncoder(this, e, r, i);
                }), i._multiLighting = i.enableMultiLight && t.SystemUtils.supportTextureFormat(t.TextureFormat.R32G32B32A32), 
                _.Shader3D = H, _.Scene3D = tr, _.MeshRenderStaticBatchManager = Wt, _.MeshRenderDynamicBatchManager = Sr, 
                _.SubMeshDynamicBatch = gr, _.Laya3D = Ca, _.Matrix4x4 = y, Ca.enableNative3D(), 
                He.__init__(), Xe.__init__(), qr.__init__(), Qr.__init__(), Lt.__init__(), oi.__init__(), 
                di.__init__(), Vt.__init__(), Ut.__init__(), gr.__init__(), v._bullet = window.Physics3D, 
                v._bullet && (pi.__init__(), mt.__init__(), Tt.__init__(), vt.__init__(), xt.__init__(), 
                ft.__init__(), gt.__init__(), mi.__init__(), Ti.__init__()), Ea.__init__(), st.init(), 
                ee.__init__(), cr.__init__(), ar.__init__(), La.__init__(), Ri.__init__(), vi.__init__(), 
                ve.__init__(), xe.__init__(), Rr.__init__(), ai.__init__(), ti.__init__(), ci.__init__(), 
                k.__init__(), tr.__init__(), Wt.__init__(), Z.__initDefine__(), q.__initDefine__(), 
                K.__initDefine__(), ur.__initDefine__(), mr.__initDefine__(), ni.__initDefine__(), 
                J.__initDefine__(), fr.__initDefine__(), Yr.__initDefine__(), $.__initDefine__(), 
                Nt.__initDefine__(), dr.__initDefine__(), $e.__init__(), t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", La), 
                t.ClassUtils.regClass("Laya.EffectMaterial", J), t.ClassUtils.regClass("Laya.UnlitMaterial", mr), 
                t.ClassUtils.regClass("Laya.BlinnPhongMaterial", K), t.ClassUtils.regClass("Laya.SkyProceduralMaterial", ur), 
                t.ClassUtils.regClass("Laya.PBRStandardMaterial", cr), t.ClassUtils.regClass("Laya.PBRSpecularMaterial", ar), 
                t.ClassUtils.regClass("Laya.SkyBoxMaterial", dr), t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", fr), 
                t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", $), t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", Yr), 
                t.ClassUtils.regClass("Laya.TrailMaterial", ni), t.ClassUtils.regClass("Laya.PhysicsCollider", Ei), 
                t.ClassUtils.regClass("Laya.Rigidbody3D", Ti), t.ClassUtils.regClass("Laya.CharacterController", mi), 
                t.ClassUtils.regClass("Laya.Animator", P), t.ClassUtils.regClass("PhysicsCollider", Ei), 
                t.ClassUtils.regClass("CharacterController", mi), t.ClassUtils.regClass("Animator", P), 
                t.ClassUtils.regClass("Rigidbody3D", Ti), Nt.defaultMaterial = new Nt(), K.defaultMaterial = new K(), 
                J.defaultMaterial = new J(), mr.defaultMaterial = new mr(), Yr.defaultMaterial = new Yr(), 
                ni.defaultMaterial = new ni(), ur.defaultMaterial = new ur(), dr.defaultMaterial = new dr(), 
                fr.defaultMaterial = new fr(), Nt.defaultMaterial.lock = !0, K.defaultMaterial.lock = !0, 
                J.defaultMaterial.lock = !0, mr.defaultMaterial.lock = !0, Yr.defaultMaterial.lock = !0, 
                ni.defaultMaterial.lock = !0, ur.defaultMaterial.lock = !0, dr.defaultMaterial.lock = !0, 
                fr.defaultMaterial.lock = !0, t.Texture2D.__init__(), Dt.__init__(), Ze.__init__(), 
                Ct.__init__(), Ke.__init__(), Je.__init__(), Ce.__init__(), g.__init__();
                var a = t.LoaderManager.createMap;
                a.lh = [ Ca.HIERARCHY, Sa._parse ], a.ls = [ Ca.HIERARCHY, Sa._parseScene ], a.lm = [ Ca.MESH, xa._parse ], 
                a.lmat = [ Ca.MATERIAL, Z._parse ], a.jpg = [ Ca.TEXTURE2D, t.Texture2D._parse ], 
                a.jpeg = [ Ca.TEXTURE2D, t.Texture2D._parse ], a.bmp = [ Ca.TEXTURE2D, t.Texture2D._parse ], 
                a.gif = [ Ca.TEXTURE2D, t.Texture2D._parse ], a.png = [ Ca.TEXTURE2D, t.Texture2D._parse ], 
                a.dds = [ Ca.TEXTURE2D, t.Texture2D._parse ], a.ktx = [ Ca.TEXTURE2D, t.Texture2D._parse ], 
                a.pvr = [ Ca.TEXTURE2D, t.Texture2D._parse ], a.lani = [ Ca.ANIMATIONCLIP, A._parse ], 
                a.lav = [ Ca.AVATAR, j._parse ], a.ltc = [ Ca.TEXTURECUBE, Dt._parse ], a.ltcb = [ Ca.TEXTURECUBEBIN, Dt._parseBin ];
                var n = t.Loader.parserMap;
                n[Ca.HIERARCHY] = Ca._loadHierarchy, n[Ca.MESH] = Ca._loadMesh, n[Ca.MATERIAL] = Ca._loadMaterial, 
                n[Ca.TEXTURECUBE] = Ca._loadTextureCube, n[Ca.TEXTURECUBEBIN] = Ca._loadTextureCubeBin, 
                n[Ca.TEXTURE2D] = Ca._loadTexture2D, n[Ca.ANIMATIONCLIP] = Ca._loadAnimationClip, 
                n[Ca.AVATAR] = Ca._loadAvatar, Ca._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, Ca._eventLoadManagerError), 
                Ca._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Ca._eventLoadManagerError), 
                Ca._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, Ca._eventLoadManagerError), 
                Ca._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Ca._eventLoadManagerError);
            } else alert("Laya3D init error,must support webGL!");
        }
        static enableNative3D() {
            var e = W, r = Ee, i = ii, a = j, n = Ce;
            if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative, 
            e.prototype.setBool = e.prototype.setBoolForNative, e.prototype.getBool = e.prototype.getBoolForNative, 
            e.prototype.setInt = e.prototype.setIntForNative, e.prototype.getInt = e.prototype.getIntForNative, 
            e.prototype.setNumber = e.prototype.setNumberForNative, e.prototype.getNumber = e.prototype.getNumberForNative, 
            e.prototype.setVector = e.prototype.setVectorForNative, e.prototype.getVector = e.prototype.getVectorForNative, 
            e.prototype.setVector2 = e.prototype.setVector2ForNative, e.prototype.getVector2 = e.prototype.getVector2ForNative, 
            e.prototype.setVector3 = e.prototype.setVector3ForNative, e.prototype.getVector3 = e.prototype.getVector3ForNative, 
            e.prototype.setQuaternion = e.prototype.setQuaternionForNative, e.prototype.getQuaternion = e.prototype.getQuaternionForNative, 
            e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative, 
            e.prototype.setBuffer = e.prototype.setBufferForNative, e.prototype.getBuffer = e.prototype.getBufferForNative, 
            e.prototype.setTexture = e.prototype.setTextureForNative, e.prototype.getTexture = e.prototype.getTextureForNative, 
            e.prototype.setAttribute = e.prototype.setAttributeForNative, e.prototype.getAttribute = e.prototype.getAttributeForNative, 
            e.prototype.cloneTo = e.prototype.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative, 
            r.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative, r.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative, 
            r.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative, t.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner.uploadShaderUniformsForNative), 
            t.Render.supportWebGLPlusCulling && (n.renderObjectCulling = Ce.renderObjectCullingNative), 
            t.Render.supportWebGLPlusAnimation) {
                a.prototype._cloneDatasToAnimator = a.prototype._cloneDatasToAnimatorNative;
                var s = A;
                s.prototype._evaluateClipDatasRealTime = s.prototype._evaluateClipDatasRealTimeForNative, 
                i.prototype._computeSkinnedData = i.prototype._computeSkinnedDataForNative;
            }
        }
        static formatRelativePath(e, t) {
            var r;
            if (r = e + t, "." === t.charAt(0)) {
                for (var i = r.split("/"), a = 0, n = i.length; a < n; a++) if (".." == i[a]) {
                    var s = a - 1;
                    s > 0 && ".." !== i[s] && (i.splice(s, 2), a -= 2);
                }
                r = i.join("/");
            }
            return r;
        }
        static _endLoad(e, r = null, i = null) {
            if (i) for (var a = 0, n = i.length; a < n; a++) {
                var s = t.Loader.getRes(i[a]);
                s && s._removeReference();
            }
            e.endLoad(r);
        }
        static _eventLoadManagerError(e) {
            t.Laya.loader.event(t.Event.ERROR, e);
        }
        static _addHierarchyInnerUrls(e, t, r, i, a, n, s = null, o = null) {
            var l = Ca.formatRelativePath(i, a);
            return r && (l += r), e.push({
                url: l,
                type: n,
                constructParams: s,
                propertyParams: o
            }), t.push(l), l;
        }
        static _getSprite3DHierarchyInnerUrls(e, t, r, i, a, n, s, o) {
            var l, _, h = e.props;
            switch (e.type) {
              case "Scene3D":
                var c = h.lightmaps;
                for (l = 0, _ = c.length; l < _; l++) {
                    var d = c[l];
                    if (d.path) d.path = Ca._addHierarchyInnerUrls(a, n, s, o, d.path, Ca.TEXTURE2D, d.constructParams, d.propertyParams); else {
                        var u = d.color;
                        u.path = Ca._addHierarchyInnerUrls(a, n, s, o, u.path, Ca.TEXTURE2D, u.constructParams, u.propertyParams);
                        var m = d.direction;
                        m && (m.path = Ca._addHierarchyInnerUrls(a, n, s, o, m.path, Ca.TEXTURE2D, m.constructParams, m.propertyParams));
                    }
                }
                var f = h.reflectionTexture;
                f && (h.reflection = Ca._addHierarchyInnerUrls(i, n, s, o, f, Ca.TEXTURECUBE));
                var E = h.reflection;
                if (E && (h.reflection = Ca._addHierarchyInnerUrls(a, n, s, o, E, Ca.TEXTURECUBEBIN)), 
                h.sky) {
                    var T = h.sky.material;
                    T && (T.path = Ca._addHierarchyInnerUrls(r, n, s, o, T.path, Ca.MATERIAL));
                }
                break;

              case "Camera":
                var p = h.skyboxMaterial;
                p && (p.path = Ca._addHierarchyInnerUrls(r, n, s, o, p.path, Ca.MATERIAL));
                break;

              case "TrailSprite3D":
              case "MeshSprite3D":
              case "SkinnedMeshSprite3D":
                var g = h.meshPath;
                g && (h.meshPath = Ca._addHierarchyInnerUrls(t, n, s, o, g, Ca.MESH));
                var S = h.materials;
                if (S) for (l = 0, _ = S.length; l < _; l++) S[l].path = Ca._addHierarchyInnerUrls(r, n, s, o, S[l].path, Ca.MATERIAL);
                break;

              case "ShuriKenParticle3D":
                if (h.main) {
                    var R = h.renderer.resources, v = R.mesh, x = R.material;
                    v && (R.mesh = Ca._addHierarchyInnerUrls(t, n, s, o, v, Ca.MESH)), x && (R.material = Ca._addHierarchyInnerUrls(r, n, s, o, x, Ca.MATERIAL));
                } else {
                    var I = h.meshPath;
                    I && (h.meshPath = Ca._addHierarchyInnerUrls(t, n, s, o, I, Ca.MESH)), h.material.path = Ca._addHierarchyInnerUrls(r, n, s, o, h.material.path, Ca.MATERIAL);
                }
                break;

              case "Terrain":
                Ca._addHierarchyInnerUrls(a, n, s, o, h.dataPath, Ca.TERRAINRES);
            }
            var A = e.components;
            if (A) for (var L = 0, C = A.length; L < C; L++) {
                var D = A[L];
                switch (D.type) {
                  case "Animator":
                    D.avatarPath;
                    var M = D.avatar;
                    M && (M.path = Ca._addHierarchyInnerUrls(a, n, s, o, M.path, Ca.AVATAR));
                    var y = D.clipPaths;
                    if (y) for (l = 0, _ = y.length; l < _; l++) y[l] = Ca._addHierarchyInnerUrls(a, n, s, o, y[l], Ca.ANIMATIONCLIP); else {
                        var O = D.layers;
                        for (l = 0; l < O.length; l++) for (var N = O[l].states, b = 0, P = N.length; b < P; b++) {
                            var w = N[b].clipPath;
                            w && (N[b].clipPath = Ca._addHierarchyInnerUrls(a, n, s, o, w, Ca.ANIMATIONCLIP));
                        }
                    }
                    break;

                  case "PhysicsCollider":
                  case "Rigidbody3D":
                  case "CharacterController":
                    var V = D.shapes;
                    for (l = 0; l < V.length; l++) {
                        var B = V[l];
                        if ("MeshColliderShape" === B.type) (v = B.mesh) && (B.mesh = Ca._addHierarchyInnerUrls(t, n, s, o, v, Ca.MESH));
                    }
                }
            }
            var F = e.child;
            for (l = 0, _ = F.length; l < _; l++) Ca._getSprite3DHierarchyInnerUrls(F[l], t, r, i, a, n, s, o);
        }
        static _loadHierarchy(e) {
            e.on(t.Event.LOADED, null, Ca._onHierarchylhLoaded, [ e ]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _onHierarchylhLoaded(e, r) {
            var i = e.url, a = I.getURLVerion(i), n = t.URL.getPath(i), s = [], o = [], l = [], _ = [], h = [];
            Ca._getSprite3DHierarchyInnerUrls(r.data, s, o, l, _, h, a, n);
            var c = s.length + o.length + _.length, d = c + 1, u = 1 / d;
            if (Ca._onProcessChange(e, 0, u, 1), _.length > 0) {
                var m = c / d, f = t.Handler.create(null, Ca._onProcessChange, [ e, u, m ], !1);
                Ca._innerFourthLevelLoaderManager._create(_, !1, t.Handler.create(null, Ca._onHierarchyInnerForthLevResouLoaded, [ e, f, r, h, s, o, l, u + m * _.length, m ]), f, null, null, null, 1, !0);
            } else Ca._onHierarchyInnerForthLevResouLoaded(e, null, r, h, s, o, l, u, m);
        }
        static _onHierarchyInnerForthLevResouLoaded(e, r, i, a, n, s, o, l, _) {
            if (r && r.recover(), o.length > 0) {
                var h = t.Handler.create(null, Ca._onProcessChange, [ e, l, _ ], !1);
                Ca._innerThirdLevelLoaderManager._create(o, !1, t.Handler.create(null, Ca._onHierarchyInnerThirdLevResouLoaded, [ e, h, i, a, n, s, l + _ * s.length, _ ]), r, null, null, null, 1, !0);
            } else Ca._onHierarchyInnerThirdLevResouLoaded(e, null, i, a, n, s, l, _);
        }
        static _onHierarchyInnerThirdLevResouLoaded(e, r, i, a, n, s, o, l) {
            if (r && r.recover(), s.length > 0) {
                var _ = t.Handler.create(null, Ca._onProcessChange, [ e, o, l ], !1);
                Ca._innerSecondLevelLoaderManager._create(s, !1, t.Handler.create(null, Ca._onHierarchyInnerSecondLevResouLoaded, [ e, _, i, a, n, o + l * s.length, l ]), r, null, null, null, 1, !0);
            } else Ca._onHierarchyInnerSecondLevResouLoaded(e, null, i, a, n, o, l);
        }
        static _onHierarchyInnerSecondLevResouLoaded(e, r, i, a, n, s, o) {
            if (r && r.recover(), n.length > 0) {
                var l = t.Handler.create(null, Ca._onProcessChange, [ e, s, o ], !1);
                Ca._innerFirstLevelLoaderManager._create(n, !1, t.Handler.create(null, Ca._onHierarchyInnerFirstLevResouLoaded, [ e, l, i, a ]), r, null, null, null, 1, !0);
            } else Ca._onHierarchyInnerFirstLevResouLoaded(e, null, i, a);
        }
        static _onHierarchyInnerFirstLevResouLoaded(e, t, r, i) {
            t && t.recover(), e._cache = e._createCache;
            var a = "Scene3D" === r.data.type ? Sa._parseScene(r, e._propertyParams, e._constructParams) : Sa._parse(r, e._propertyParams, e._constructParams);
            Ca._endLoad(e, a, i);
        }
        static _loadMesh(e) {
            e.on(t.Event.LOADED, null, Ca._onMeshLmLoaded, [ e ]), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
        }
        static _onMeshLmLoaded(e, t) {
            e._cache = e._createCache;
            var r = xa._parse(t, e._propertyParams, e._constructParams);
            Ca._endLoad(e, r);
        }
        static _loadMaterial(e) {
            e.on(t.Event.LOADED, null, Ca._onMaterilLmatLoaded, [ e ]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _onMaterilLmatLoaded(e, r) {
            var i, a = e.url, n = I.getURLVerion(a), s = t.URL.getPath(a), o = [], l = [];
            r.customProps;
            switch (r.version) {
              case "LAYAMATERIAL:01":
              case "LAYAMATERIAL:02":
                var _, h, c = r.props.textures;
                if (c) for (_ = 0, h = c.length; _ < h; _++) {
                    var d = c[_], u = d.path;
                    u && (i = Ca.formatRelativePath(s, u), n && (i += n), o.push({
                        url: i,
                        constructParams: d.constructParams,
                        propertyParams: d.propertyParams
                    }), l.push(i), d.path = i);
                }
                break;

              default:
                throw new Error("Laya3D:unkonwn version.");
            }
            var m = o.length, f = m + 1, E = 1 / f;
            if (Ca._onProcessChange(e, 0, E, 1), m > 0) {
                var T = t.Handler.create(null, Ca._onProcessChange, [ e, E, m / f ], !1);
                Ca._innerFourthLevelLoaderManager._create(o, !1, t.Handler.create(null, Ca._onMateialTexturesLoaded, [ e, T, r, l ]), T, null, null, null, 1, !0);
            } else Ca._onMateialTexturesLoaded(e, null, r, null);
        }
        static _onMateialTexturesLoaded(e, t, r, i) {
            e._cache = e._createCache;
            var a = Z._parse(r, e._propertyParams, e._constructParams);
            Ca._endLoad(e, a, i), t && t.recover();
        }
        static _loadAvatar(e) {
            e.on(t.Event.LOADED, null, function(t) {
                e._cache = e._createCache;
                var r = j._parse(t, e._propertyParams, e._constructParams);
                Ca._endLoad(e, r);
            }), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _loadAnimationClip(e) {
            e.on(t.Event.LOADED, null, function(t) {
                e._cache = e._createCache;
                var r = A._parse(t, e._propertyParams, e._constructParams);
                Ca._endLoad(e, r);
            }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
        }
        static _loadTexture2D(e) {
            var r, i = e.url, a = i.lastIndexOf(".") + 1, n = i.indexOf("?"), s = -1 == n ? i.length : n;
            switch (i.substr(a, s - a)) {
              case "jpg":
              case "jpeg":
              case "bmp":
              case "gif":
              case "png":
                r = "nativeimage";
                break;

              case "dds":
              case "ktx":
              case "pvr":
                r = t.Loader.BUFFER;
            }
            e.on(t.Event.LOADED, null, function(r) {
                e._cache = e._createCache;
                var i = t.Texture2D._parse(r, e._propertyParams, e._constructParams);
                Ca._endLoad(e, i);
            }), e.load(e.url, r, !1, null, !0);
        }
        static _loadTextureCube(e) {
            e.on(t.Event.LOADED, null, Ca._onTextureCubeLtcLoaded, [ e ]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _loadTextureCubeBin(e) {
            e.on(t.Event.LOADED, null, r => {
                e._cache = e._createCache;
                var i = new t.Byte(r);
                if ("LAYATEXTURECUBE:0000" !== i.readUTFString()) throw "Laya3D:unknow version.";
                var a = i.readUint8(), n = i.getUint8(), s = i.readUint16(), o = i.getUint8(), l = i.getUint8(), _ = i.getUint8(), h = i.getUint8(), c = new Dt(s, a, n > 1);
                c.filterMode = o, c.wrapModeU = l, c.wrapModeV = _, c.anisoLevel = h;
                for (var d = i.pos, u = s, m = 0; m < n; m++) {
                    for (var f = new Array(6), E = u * u * c._getFormatByteCount(), T = 0; T < 6; T++) f[T] = new Uint8Array(r, d, E), 
                    d += E;
                    c.setSixSidePixels(f, m), u /= 2;
                }
                Ca._endLoad(e, c);
            }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
        }
        static _onTextureCubeLtcLoaded(e, r) {
            var i = t.URL.getPath(e.url), a = [ Ca.formatRelativePath(i, r.front), Ca.formatRelativePath(i, r.back), Ca.formatRelativePath(i, r.left), Ca.formatRelativePath(i, r.right), Ca.formatRelativePath(i, r.up), Ca.formatRelativePath(i, r.down) ];
            Ca._onProcessChange(e, 0, 1 / 7, 1);
            var n = t.Handler.create(null, Ca._onProcessChange, [ e, 1 / 7, 6 / 7 ], !1);
            Ca._innerFourthLevelLoaderManager.load(a, t.Handler.create(null, Ca._onTextureCubeImagesLoaded, [ e, a, n ]), n, "nativeimage");
        }
        static _onTextureCubeImagesLoaded(e, r, i) {
            for (var a = new Array(6), n = 0; n < 6; n++) a[n] = t.Loader.getRes(r[n]);
            e._cache = e._createCache;
            var s = Dt._parse(a, e._propertyParams, e._constructParams);
            for (i.recover(), n = 0; n < 6; n++) t.Loader.clearRes(r[n]);
            Ca._endLoad(e, s);
        }
        static _onProcessChange(e, r, i, a) {
            (a = r + a * i) < 1 && e.event(t.Event.PROGRESS, a);
        }
        static init(e, t, r = null, i = null) {
            if (Ca._isInit) i && i.run(); else {
                Ca._isInit = !0, r && r.cloneTo(l._config), r = l._config, Ce.debugFrustumCulling = r.debugFrustumCulling, 
                Ca._editerEnvironment = r._editerEnvironment, tr.octreeCulling = r.octreeCulling, 
                tr.octreeInitialSize = r.octreeInitialSize, tr.octreeInitialCenter = r.octreeInitialCenter, 
                tr.octreeMinNodeSize = r.octreeMinNodeSize, tr.octreeLooseness = r.octreeLooseness;
                var a = window.Physics3D;
                null == a ? (v._enablePhysics = !1, Ca.__init__(e, t, r), i && i.run()) : (v._enablePhysics = !0, 
                a(16 * r.defaultPhysicsMemory, ui._interactive).then(function() {
                    Ca.__init__(e, t, r), i && i.run();
                }));
            }
        }
    }
    Ca.HIERARCHY = "HIERARCHY", Ca.MESH = "MESH", Ca.MATERIAL = "MATERIAL", Ca.TEXTURE2D = "TEXTURE2D", 
    Ca.TEXTURECUBE = "TEXTURECUBE", Ca.TEXTURECUBEBIN = "TEXTURECUBEBIN", Ca.ANIMATIONCLIP = "ANIMATIONCLIP", 
    Ca.AVATAR = "AVATAR", Ca.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Ca.TERRAINRES = "TERRAIN", 
    Ca._innerFirstLevelLoaderManager = new t.LoaderManager(), Ca._innerSecondLevelLoaderManager = new t.LoaderManager(), 
    Ca._innerThirdLevelLoaderManager = new t.LoaderManager(), Ca._innerFourthLevelLoaderManager = new t.LoaderManager(), 
    Ca._isInit = !1, Ca._editerEnvironment = !1, Ca.physicsSettings = new At(), window.Laya3D = Ca;
    class Da extends t.Component {
        constructor() {
            super(...arguments), this._indexInPool = -1;
        }
        get isSingleton() {
            return !1;
        }
        _checkProcessTriggers() {
            var e = Da.prototype;
            return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
        }
        _checkProcessCollisions() {
            var e = Da.prototype;
            return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
        }
        _onAwake() {
            this.onAwake(), this.onStart !== Da.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
        }
        _onEnable() {
            this.owner._scene._addScript(this), this.onEnable();
        }
        _onDisable() {
            this.owner._scene._removeScript(this), this.owner.offAllCaller(this), this.onDisable();
        }
        _onDestroy() {
            var e = this.owner._scripts;
            e.splice(e.indexOf(this), 1);
            var t = this.owner;
            t._needProcessTriggers = !1;
            for (var r = 0, i = e.length; r < i; r++) if (e[r]._checkProcessTriggers()) {
                t._needProcessTriggers = !0;
                break;
            }
            for (t._needProcessCollisions = !1, r = 0, i = e.length; r < i; r++) if (e[r]._checkProcessCollisions()) {
                t._needProcessCollisions = !0;
                break;
            }
            this.onDestroy();
        }
        _isScript() {
            return !0;
        }
        _onAdded() {
            var e = this.owner, t = e._scripts;
            t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()), 
            e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
        }
        onAwake() {}
        onEnable() {}
        onStart() {}
        onTriggerEnter(e) {}
        onTriggerStay(e) {}
        onTriggerExit(e) {}
        onCollisionEnter(e) {}
        onCollisionStay(e) {}
        onCollisionExit(e) {}
        onMouseDown() {}
        onMouseDrag() {}
        onMouseClick() {}
        onMouseUp() {}
        onMouseEnter() {}
        onMouseOver() {}
        onMouseOut() {}
        onUpdate() {}
        onLateUpdate() {}
        onPreRender() {}
        onPostRender() {}
        onDisable() {}
        onDestroy() {}
    }
    class Ma {
        constructor(e, t, r, i) {
            this._datas = [], this._w = e, this._h = t, this._minHeight = r, this._maxHeight = i;
        }
        static creatFromMesh(e, t, r, i) {
            for (var a = [], s = [], o = e.subMeshCount, l = 0; l < o; l++) {
                for (var _ = e.getSubMesh(l), h = _._vertexBuffer, c = h.getFloat32Data(), d = [], u = 0; u < c.length; u += h.vertexDeclaration.vertexStride / 4) {
                    var m = new n(c[u + 0], c[u + 1], c[u + 2]);
                    d.push(m);
                }
                a.push(d);
                var f = _._indexBuffer;
                s.push(f.getData());
            }
            var E = e.bounds, T = E.getMin().x, p = E.getMin().z, g = E.getMax().x, S = E.getMax().z, R = E.getMin().y, v = E.getMax().y, x = g - T, I = S - p, A = i.x = x / (t - 1), L = i.y = I / (r - 1), C = new Ma(t, r, R, v), D = Ma._tempRay, M = D.direction;
            M.x = 0, M.y = -1, M.z = 0;
            var y = v + .1;
            D.origin.y = y;
            for (var O = 0; O < r; O++) {
                var N = p + O * L;
                C._datas[O] = [];
                for (var b = 0; b < t; b++) {
                    var P = T + b * A, w = D.origin;
                    w.x = P, w.z = N;
                    var V = Ma._getPosition(D, a, s);
                    C._datas[O][b] = V === Number.MAX_VALUE ? NaN : y - V;
                }
            }
            return C;
        }
        static createFromImage(e, t, r) {
            for (var i = e.width, a = e.height, n = new Ma(i, a, t, r), s = (r - t) / 254, o = e.getPixels(), l = 0, _ = 0; _ < a; _++) for (var h = n._datas[_] = [], c = 0; c < i; c++) {
                var d = o[l++], u = o[l++], m = o[l++], f = o[l++];
                h[c] = 255 == d && 255 == u && 255 == m && 255 == f ? NaN : (d + u + m) / 3 * s + t;
            }
            return n;
        }
        static _getPosition(e, t, r) {
            for (var i = Number.MAX_VALUE, a = 0; a < t.length; a++) for (var n = t[a], s = r[a], o = 0; o < s.length; o += 3) {
                var l = n[s[o + 0]], _ = n[s[o + 1]], h = n[s[o + 2]], c = Ue.rayIntersectsTriangle(e, l, _, h);
                !isNaN(c) && c < i && (i = c);
            }
            return i;
        }
        get width() {
            return this._w;
        }
        get height() {
            return this._h;
        }
        get maxHeight() {
            return this._maxHeight;
        }
        get minHeight() {
            return this._minHeight;
        }
        _inBounds(e, t) {
            return e >= 0 && e < this._h && t >= 0 && t < this._w;
        }
        getHeight(e, t) {
            return this._inBounds(e, t) ? this._datas[e][t] : NaN;
        }
    }
    Ma._tempRay = new Pe(new n(), new n());
    class ya extends Rr {
        constructor(e, t, r = null) {
            super(e, r), this._heightMap = t, this._cellSize = new i();
        }
        static createFromMesh(e, t, r, i = null) {
            var a = new ya(e, null, i);
            return a._initCreateFromMesh(t, r), a;
        }
        static createFromMeshAndHeightMap(e, t, r, i, a = null) {
            var n = new ya(e, null, a);
            return n._initCreateFromMeshHeightMap(t, r, i), n;
        }
        get minX() {
            var e = this.transform.worldMatrix.elements;
            return this._minX * this._getScaleX() + e[12];
        }
        get minZ() {
            var e = this.transform.worldMatrix.elements;
            return this._minZ * this._getScaleZ() + e[14];
        }
        get width() {
            return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
        }
        get depth() {
            return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
        }
        _disableRotation() {
            var e = this.transform.rotation;
            e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
        }
        _getScaleX() {
            var e = this.transform.worldMatrix.elements, t = e[0], r = e[1], i = e[2];
            return Math.sqrt(t * t + r * r + i * i);
        }
        _getScaleZ() {
            var e = this.transform.worldMatrix.elements, t = e[8], r = e[9], i = e[10];
            return Math.sqrt(t * t + r * r + i * i);
        }
        _initCreateFromMesh(e, t) {
            this._heightMap = Ma.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
            var r = this.meshFilter.sharedMesh.bounds, i = r.getMin();
            r.getMax();
            this._minX = i.x, this._minZ = i.z;
        }
        _initCreateFromMeshHeightMap(e, t, r) {
            var i = this.meshFilter.sharedMesh.bounds;
            this._heightMap = Ma.createFromImage(e, t, r), this._computeCellSize(i);
            var a = i.getMin();
            i.getMax();
            this._minX = a.x, this._minZ = a.z;
        }
        _computeCellSize(e) {
            var t = e.getMin(), r = e.getMax(), i = t.x, a = t.z, n = r.x - i, s = r.z - a;
            this._cellSize.x = n / (this._heightMap.width - 1), this._cellSize.y = s / (this._heightMap.height - 1);
        }
        _update(e) {
            this._disableRotation();
        }
        getHeight(e, t) {
            ya._tempVector3.x = e, ya._tempVector3.y = 0, ya._tempVector3.z = t, this._disableRotation();
            var r = this.transform.worldMatrix;
            r.invert(ya._tempMatrix4x4), n.transformCoordinate(ya._tempVector3, ya._tempMatrix4x4, ya._tempVector3), 
            e = ya._tempVector3.x, t = ya._tempVector3.z;
            var i = (e - this._minX) / this._cellSize.x, a = (t - this._minZ) / this._cellSize.y, s = Math.floor(a), o = Math.floor(i), l = i - o, _ = a - s, h = r.elements, c = h[4], d = h[5], u = h[6], m = Math.sqrt(c * c + d * d + u * u), f = h[13], E = this._heightMap.getHeight(s, o + 1), T = this._heightMap.getHeight(s + 1, o);
            if (isNaN(E) || isNaN(T)) return NaN;
            if (l + _ <= 1) {
                var p = this._heightMap.getHeight(s, o);
                return isNaN(p) ? NaN : (p + l * (E - p) + _ * (T - p)) * m + f;
            }
            var g = this._heightMap.getHeight(s + 1, o + 1);
            return isNaN(g) ? NaN : (g + (1 - l) * (T - g) + (1 - _) * (E - g)) * m + f;
        }
    }
    ya._tempVector3 = new n(), ya._tempMatrix4x4 = new y();
    class Oa {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(12);
        }
        get gradientCount() {
            return this._currentLength / 3;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x, 
            this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, a = this._elements.length; i < a; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new Oa();
            return this.cloneTo(e), e;
        }
    }
    class Na {
        constructor() {}
        render(e) {}
    }
    class ba extends Na {
        constructor() {
            super(), this._shader = null, this._shaderData = new W(), this._linearColor = new ge(), 
            this._bloomTextureTexelSize = new a(), this._shaderThreshold = new a(), this._shaderParams = new a(), 
            this._pyramid = null, this._intensity = 0, this._threshold = 1, this._softKnee = .5, 
            this._diffusion = 7, this._anamorphicRatio = 0, this._dirtIntensity = 0, this._shaderSetting = new a(), 
            this._dirtTileOffset = new a(), this.clamp = 65472, this.color = new ge(1, 1, 1, 1), 
            this.fastMode = !1, this.dirtTexture = null, this._shader = H.find("PostProcessBloom"), 
            this._pyramid = new Array(2 * ba.MAXPYRAMIDSIZE);
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(e) {
            this._intensity = Math.max(e, 0);
        }
        get threshold() {
            return this._threshold;
        }
        set threshold(e) {
            this._threshold = Math.max(e, 0);
        }
        get softKnee() {
            return this._softKnee;
        }
        set softKnee(e) {
            this._softKnee = Math.min(Math.max(e, 0), 1);
        }
        get diffusion() {
            return this._diffusion;
        }
        set diffusion(e) {
            this._diffusion = Math.min(Math.max(e, 1), 10);
        }
        get anamorphicRatio() {
            return this._anamorphicRatio;
        }
        set anamorphicRatio(e) {
            this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
        }
        get dirtIntensity() {
            return this._dirtIntensity;
        }
        set dirtIntensity(e) {
            this._dirtIntensity = Math.max(e, 0);
        }
        render(e) {
            var r = e.command, i = e.camera.viewport;
            this._shaderData.setTexture(ba.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
            var n, s = this._anamorphicRatio, o = s < 0 ? -s : 0, l = s > 0 ? s : 0, _ = Math.floor(i.width / (2 - o)), h = Math.floor(i.height / (2 - l)), c = Math.max(_, h);
            n = Math.log2(c) + this._diffusion - 10;
            var d = Math.floor(n), u = Math.min(Math.max(d, 1), ba.MAXPYRAMIDSIZE), m = .5 + n - d;
            this._shaderData.setNumber(ba.SHADERVALUE_SAMPLESCALE, m);
            var f = ge.gammaToLinearSpace(this.threshold), E = f * this._softKnee + 1e-5;
            this._shaderThreshold.setValue(f, f - E, 2 * E, .25 / E), this._shaderData.setVector(ba.SHADERVALUE_THRESHOLD, this._shaderThreshold);
            var T = ge.gammaToLinearSpace(this.clamp);
            this._shaderParams.setValue(T, 0, 0, 0), this._shaderData.setVector(ba.SHADERVALUE_PARAMS, this._shaderParams);
            for (var p = this.fastMode ? 1 : 0, g = e.source, S = 0; S < u; S++) {
                var R = 2 * S, v = R + 1, x = 0 == S ? ba.SUBSHADER_PREFILTER13 + p : ba.SUBSHADER_DOWNSAMPLE13 + p, I = B.createFromPool(_, h, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                if (I.filterMode = t.FilterMode.Bilinear, this._pyramid[R] = I, S !== u - 1) {
                    var A = B.createFromPool(_, h, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                    A.filterMode = t.FilterMode.Bilinear, this._pyramid[v] = A;
                }
                r.blitScreenTriangle(g, I, null, this._shader, this._shaderData, x), g = I, _ = Math.max(Math.floor(_ / 2), 1), 
                h = Math.max(Math.floor(h / 2), 1);
            }
            var L = this._pyramid[2 * (u - 1)];
            for (S = u - 2; S >= 0; S--) v = (R = 2 * S) + 1, I = this._pyramid[R], A = this._pyramid[v], 
            r.setShaderDataTexture(this._shaderData, ba.SHADERVALUE_BLOOMTEX, I), r.blitScreenTriangle(L, A, null, this._shader, this._shaderData, ba.SUBSHADER_UPSAMPLETENT + p), 
            L = A;
            var C = this._linearColor;
            this.color.toLinear(C);
            var D = Math.pow(2, this._intensity / 10) - 1, M = this._shaderSetting;
            this._shaderSetting.setValue(m, D, this._dirtIntensity, u);
            var y = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture, O = y.width / y.height, N = i.width / i.height, b = this._dirtTileOffset;
            O > N ? b.setValue(N / O, 1, .5 * (1 - b.x), 0) : O < N && b.setValue(1, O / N, 0, .5 * (1 - b.y));
            var P = e.compositeShaderData;
            for (this.fastMode ? P.addDefine(k.SHADERDEFINE_BLOOM_LOW) : P.addDefine(k.SHADERDEFINE_BLOOM), 
            this._bloomTextureTexelSize.setValue(1 / L.width, 1 / L.height, L.width, L.height), 
            P.setVector(k.SHADERVALUE_BLOOM_DIRTTILEOFFSET, b), P.setVector(k.SHADERVALUE_BLOOM_SETTINGS, M), 
            P.setVector(k.SHADERVALUE_BLOOM_COLOR, new a(C.r, C.g, C.b, C.a)), P.setTexture(k.SHADERVALUE_BLOOM_DIRTTEX, y), 
            P.setTexture(k.SHADERVALUE_BLOOMTEX, L), P.setVector(k.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize), 
            S = 0; S < u; S++) v = (R = 2 * S) + 1, B.recoverToPool(this._pyramid[R]), 0 !== S && S !== u - 1 && B.recoverToPool(this._pyramid[v]);
            e.deferredReleaseTextures.push(L);
        }
    }
    ba.SHADERVALUE_MAINTEX = H.propertyNameToID("u_MainTex"), ba.SHADERVALUE_AUTOEXPOSURETEX = H.propertyNameToID("u_AutoExposureTex"), 
    ba.SHADERVALUE_SAMPLESCALE = H.propertyNameToID("u_SampleScale"), ba.SHADERVALUE_THRESHOLD = H.propertyNameToID("u_Threshold"), 
    ba.SHADERVALUE_PARAMS = H.propertyNameToID("u_Params"), ba.SHADERVALUE_BLOOMTEX = H.propertyNameToID("u_BloomTex"), 
    ba.SUBSHADER_PREFILTER13 = 0, ba.SUBSHADER_PREFILTER4 = 1, ba.SUBSHADER_DOWNSAMPLE13 = 2, 
    ba.SUBSHADER_DOWNSAMPLE4 = 3, ba.SUBSHADER_UPSAMPLETENT = 4, ba.SUBSHADER_UPSAMPLEBOX = 5, 
    ba.MAXPYRAMIDSIZE = 16;
    class Pa {
        constructor(e) {
            if (!(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        randomint() {
            var e = this._state0U, t = this._state0L, r = this._state1U, i = this._state1L, a = (i >>> 0) + (t >>> 0), n = r + e + (a / 2 >>> 31) >>> 0, s = a >>> 0;
            this._state0U = r, this._state0L = i;
            var o = 0, l = 0;
            o = (e ^= o = e << 23 | (-512 & t) >>> 9) ^ r, l = (t ^= l = t << 23) ^ i;
            o ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
            return o ^= r >>> 5, l ^= i >>> 5 | (31 & r) << 27, this._state1U = o, this._state1L = l, 
            [ n, s ];
        }
        random() {
            var e = this.randomint(), t = e[0], r = 1023 << 20 | t >>> 12, i = 0 | (e[1] >>> 12 | (4095 & t) << 20);
            return Pa._CONVERTION_BUFFER.setUint32(0, r, !1), Pa._CONVERTION_BUFFER.setUint32(4, i, !1), 
            Pa._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
        }
    }
    Pa._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Pa.defaultRand = new Pa([ 0, Date.now() / 65536, 0, Date.now() % 65536 ]);
    class wa {
        constructor(e, t) {
            this._width = 0, this._height = 0, this._width = e, this._height = t;
        }
        static get fullScreen() {
            return new wa(-1, -1);
        }
        get width() {
            return -1 === this._width ? V.clientWidth : this._width;
        }
        get height() {
            return -1 === this._height ? V.clientHeight : this._height;
        }
    }
    e.AlternateLightQueue = Ot, e.AnimationClip = A, e.AnimationClipParser03 = p, e.AnimationClipParser04 = S, 
    e.AnimationEvent = c, e.AnimationNode = Y, e.AnimationTransform3D = X, e.Animator = P, 
    e.AnimatorControllerLayer = C, e.AnimatorPlayState = L, e.AnimatorState = N, e.AnimatorStateScript = class {
        constructor() {}
        onStateEnter() {}
        onStateUpdate() {}
        onStateExit() {}
    }, e.Avatar = j, e.BaseCamera = Qe, e.BaseMaterial = q, e.BaseRender = kt, e.BaseShape = Pr, 
    e.BatchMark = Ft, e.BlinnPhongMaterial = K, e.BlitScreenQuadCMD = et, e.BloomEffect = ba, 
    e.BoundBox = bt, e.BoundFrustum = Be, e.BoundSphere = Jt, e.Bounds = Pt, e.BoundsOctree = Qt, 
    e.BoundsOctreeNode = Zt, e.BoxColliderShape = ft, e.BoxShape = Vr, e.BufferState = Ge, 
    e.BulletInteractive = ui, e.Burst = Ir, e.Camera = ot, e.CameraCullInfo = Ae, e.CapsuleColliderShape = Et, 
    e.CastShadowList = class extends Te {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
            this._add(e), e._indexInCastShadowList = this.length++;
        }
        remove(e) {
            var t = e._indexInCastShadowList;
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._indexInCastShadowList = t;
            }
            e._indexInCastShadowList = -1;
        }
    }, e.CharacterController = mi, e.CircleShape = Br, e.Cluster = Me, e.ColliderShape = mt, 
    e.Collision = dt, e.CollisionTool = ut, e.CollisionUtils = Ve, e.Color = ge, e.ColorOverLifetime = Lr, 
    e.Command = $e, e.CommandBuffer = it, e.CompoundColliderShape = Tt, e.ConchQuaternion = O, 
    e.ConchVector3 = M, e.ConchVector4 = D, e.ConeColliderShape = pt, e.ConeShape = Fr, 
    e.Config3D = l, e.Constraint3D = class {
        constructor() {}
    }, e.ConstraintComponent = class extends t.Component {
        constructor() {
            super(), this._feedbackEnabled = !1;
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(e) {
            this._btConstraint.IsEnabled = e, super.enabled = e;
        }
        get breakingImpulseThreshold() {
            return this._breakingImpulseThreshold;
        }
        set breakingImpulseThreshold(e) {
            this._btConstraint.BreakingImpulseThreshold = e, this._breakingImpulseThreshold = e;
        }
        get appliedImpulse() {
            return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0), this._feedbackEnabled = !0), 
            this._btConstraint.AppliedImpulse;
        }
        get connectedBody() {
            return this._connectedBody;
        }
        set connectedBody(e) {
            this._connectedBody = e;
        }
        _onDestroy() {
            v._bullet.destroy(this._btConstraint), this._btConstraint = null;
        }
    }, e.ContactPoint = ct, e.ContainmentType = we, e.CylinderColliderShape = gt, e.DefineDatas = F, 
    e.DirectionLight = Ta, e.DirectionLightQueue = yt, e.DynamicBatchManager = Se, e.EffectMaterial = J, 
    e.Emission = Jr, e.ExtendTerrainMaterial = $, e.FloatKeyframe = u, e.FrameOverTime = Cr, 
    e.FrustumCulling = Ce, e.GeometryElement = wt, e.Gradient = xr, e.GradientAngularVelocity = Dr, 
    e.GradientColor = Ar, e.GradientDataInt = Mr, e.GradientDataNumber = yr, e.GradientDataVector2 = Oa, 
    e.GradientMode = vr, e.GradientSize = Or, e.GradientVelocity = Nr, e.HalfFloatUtils = g, 
    e.HeightMap = Ma, e.HeightfieldColliderShape = class {
        constructor() {}
    }, e.HemisphereShape = Ur, e.HitResult = lt, e.ILaya3D = _, e.IndexBuffer3D = ze, 
    e.Input3D = It, e.Keyframe = d, e.KeyframeNode = h, e.KeyframeNodeList = R, e.KeyframeNodeOwner = b, 
    e.Laya3D = Ca, e.LightQueue = Mt, e.LightSprite = nt, e.Lightmap = Kt, e.LoadModelV04 = Ra, 
    e.LoadModelV05 = va, e.Material = Z, e.MathUtils3D = r, e.Matrix3x3 = m, e.Matrix4x4 = y, 
    e.Mesh = Ri, e.MeshColliderShape = St, e.MeshFilter = pr, e.MeshReader = xa, e.MeshRenderDynamicBatchManager = Sr, 
    e.MeshRenderStaticBatchManager = Wt, e.MeshRenderer = Tr, e.MeshSprite3D = Rr, e.MeshSprite3DShaderDeclaration = Er, 
    e.MeshTerrainSprite3D = ya, e.MouseTouch = Oe, e.OctreeMotionList = qt, e.PBRMaterial = ee, 
    e.PBRSpecularMaterial = ar, e.PBRStandardMaterial = cr, e.Physics3D = v, e.Physics3DUtils = _t, 
    e.PhysicsCollider = Ei, e.PhysicsComponent = vt, e.PhysicsSettings = At, e.PhysicsSimulation = xt, 
    e.PhysicsTriggerComponent = fi, e.PhysicsUpdateList = ht, e.Picker = Ue, e.PixelLineData = class {
        constructor() {
            this.startPosition = new n(), this.endPosition = new n(), this.startColor = new ge(), 
            this.endColor = new ge();
        }
        cloneTo(e) {
            this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition), 
            this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
        }
    }, e.PixelLineFilter = Bt, e.PixelLineMaterial = Nt, e.PixelLineRenderer = Xt, e.PixelLineSprite3D = Yt, 
    e.PixelLineVertex = Vt, e.Plane = be, e.Point2PointConstraint = class {
        constructor() {
            this._pivotInA = new n(), this._pivotInB = new n();
        }
        get pivotInA() {
            return this._pivotInA;
        }
        set pivotInA(e) {
            this._pivotInA = e;
        }
        get pivotInB() {
            return this._pivotInB;
        }
        set pivotInB(e) {
            this._pivotInB = e;
        }
        get damping() {
            return this._damping;
        }
        set damping(e) {
            this._damping = e;
        }
        get impulseClamp() {
            return this._impulseClamp;
        }
        set impulseClamp(e) {
            this._impulseClamp = e;
        }
        get tau() {
            return this._tau;
        }
        set tau(e) {
            this._tau = e;
        }
    }, e.PointLight = pa, e.PostProcess = k, e.PostProcessEffect = Na, e.PostProcessRenderContext = w, 
    e.PrimitiveMesh = vi, e.Quaternion = f, e.QuaternionKeyframe = E, e.Rand = Kr, e.RandX = Pa, 
    e.Ray = Pe, e.RenderContext3D = V, e.RenderElement = Gt, e.RenderQueue = jt, e.RenderState = Q, 
    e.RenderTexture = B, e.RenderableSprite3D = xe, e.Rigidbody3D = Ti, e.RotationOverLifetime = br, 
    e.Scene3D = tr, e.Scene3DShaderDeclaration = at, e.Scene3DUtils = Sa, e.SceneManager = class {
        constructor() {}
    }, e.ScreenQuad = Ke, e.ScreenTriangle = Je, e.Script3D = Da, e.SetRenderTargetCMD = tt, 
    e.SetShaderDataTextureCMD = rt, e.Shader3D = H, e.ShaderData = W, e.ShaderDefine = U, 
    e.ShaderInit3D = Ea, e.ShaderInstance = Ee, e.ShaderPass = rr, e.ShaderVariable = fe, 
    e.ShaderVariant = G, e.ShaderVariantCollection = z, e.ShadowCasterPass = er, e.ShadowCullInfo = Le, 
    e.ShadowSliceData = $t, e.ShadowUtils = st, e.ShapeUtils = wr, e.ShuriKenParticle3D = ti, 
    e.ShuriKenParticle3DShaderDeclaration = Xr, e.ShurikenParticleData = $r, e.ShurikenParticleMaterial = Yr, 
    e.ShurikenParticleRenderer = jr, e.ShurikenParticleSystem = ei, e.SimpleSingletonList = pe, 
    e.SingletonList = Te, e.Size = wa, e.SizeOverLifetime = zr, e.SkinnedMeshRenderer = ii, 
    e.SkinnedMeshSprite3D = ai, e.SkinnedMeshSprite3DShaderDeclaration = ri, e.SkyBox = Ze, 
    e.SkyBoxMaterial = dr, e.SkyDome = Ct, e.SkyMesh = je, e.SkyPanoramicMaterial = La, 
    e.SkyProceduralMaterial = ur, e.SkyRenderer = qe, e.SphereColliderShape = Rt, e.SphereShape = Gr, 
    e.SphericalHarmonicsL2 = ye, e.SpotLight = ga, e.Sprite3D = ve, e.StartFrame = Hr, 
    e.StaticBatchManager = Ie, e.StaticPlaneColliderShape = pi, e.SubMesh = gi, e.SubMeshDynamicBatch = gr, 
    e.SubMeshInstanceBatch = Ut, e.SubMeshRenderElement = zt, e.SubMeshStaticBatch = Ht, 
    e.SubShader = ir, e.TextMesh = class {
        get text() {
            return this._text;
        }
        set text(e) {
            this._text = e;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(e) {
            this._fontSize = e;
        }
        get color() {
            return this._color;
        }
        set color(e) {
            this._color = e;
        }
        constructor() {}
        _createVertexBuffer(e) {}
        _resizeVertexBuffer(e) {}
        _addChar() {}
    }, e.TextureCube = Dt, e.TextureGenerator = x, e.TextureMode = si, e.TextureSheetAnimation = Wr, 
    e.Touch = Ne, e.TrailFilter = _i, e.TrailGeometry = li, e.TrailMaterial = ni, e.TrailRenderer = hi, 
    e.TrailSprite3D = ci, e.Transform3D = Re, e.UnlitMaterial = mr, e.Utils3D = I, e.Vector2 = i, 
    e.Vector3 = n, e.Vector3Keyframe = T, e.Vector4 = a, e.VelocityOverLifetime = kr, 
    e.VertexBuffer3D = Ye, e.VertexDeclaration = We, e.VertexElement = ke, e.VertexElementFormat = He, 
    e.VertexMesh = Xe, e.VertexPositionTerrain = di, e.VertexPositionTexture0 = Lt, 
    e.VertexShuriKenParticle = Zr, e.VertexShurikenParticleBillboard = qr, e.VertexShurikenParticleMesh = Qr, 
    e.VertexTrail = oi, e.Viewport = Fe, e.WaterPrimaryMaterial = fr, e.skinnedMatrixCache = Si;
}(window.Laya = window.Laya || {}, Laya);