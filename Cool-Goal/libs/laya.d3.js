! function(o, t, m) {
    m.un, m.uns;
    var _ = m.static,
        d = m.class,
        u = m.getset,
        P = m.__newvec,
        n = laya.webgl.resource.BaseTexture,
        S = laya.utils.Browser,
        i = laya.webgl.utils.Buffer,
        c = laya.webgl.BufferStateBase,
        s = laya.utils.Byte,
        p = laya.utils.ClassUtils,
        a = laya.layagl.CommandEncoder,
        r = laya.components.Component,
        l = m.Config,
        h = (laya.resource.Context,
            laya.events.Event, laya.events.EventDispatcher),
        T = laya.utils.Handler,
        E = (laya.webgl.utils.InlcudeFile,
            laya.layagl.LayaGL),
        f = laya.layagl.LayaGLRunner,
        xt = laya.net.Loader,
        v = laya.net.LoaderManager,
        z = laya.maths.MathUtil,
        e = laya.display.Node,
        g = laya.maths.Point,
        b = laya.renders.Render,
        D = (laya.webgl.resource.RenderTexture2D,
            laya.resource.Resource),
        y = laya.utils.RunDriver,
        x = (laya.webgl.shader.Shader,
            laya.webgl.utils.ShaderCompile),
        I = laya.webgl.utils.ShaderNode,
        R = laya.display.Sprite,
        M = laya.utils.Stat,
        A = laya.webgl.submit.Submit,
        C = laya.webgl.submit.SubmitKey,
        L = laya.webgl.resource.Texture2D,
        O = (laya.utils.Timer,
            laya.net.URL),
        N = laya.webgl.WebGL,
        V = laya.webgl.WebGLContext,
        w = laya.webgl.canvas.WebGLContext2D;
    m.interface("laya.d3.core.IClone"), m.interface("laya.d3.graphics.IVertex"), m.interface("laya.d3.core.scene.IOctreeObject");
    var F = function() {
            function a(t, e, n, i, r) {
                var a;
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 1),
                    (a = r || new Float32Array(4))[0] = t, a[1] = e, a[2] = n, a[3] = i, this.elements = a;
            }
            d(a, "laya.d3.math.Native.ConchQuaternion");
            var t = a.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.scaling = function(t, e) {
                var n = e.elements,
                    i = this.elements;
                n[0] = i[0] * t, n[1] = i[1] * t, n[2] = i[2] * t, n[3] = i[3] * t;
            }, t.normalize = function(t) {
                a._normalizeArray(this.elements, t.elements);
            }, t.length = function() {
                var t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3];
                return Math.sqrt(e * e + n * n + i * i + r * r);
            }, t.rotateX = function(t, e) {
                var n = e.elements,
                    i = this.elements;
                t *= .5;
                var r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = Math.sin(t),
                    h = Math.cos(t);
                n[0] = r * h + s * l, n[1] = a * h + o * l, n[2] = o * h - a * l, n[3] = s * h - r * l;
            }, t.rotateY = function(t, e) {
                var n = e.elements,
                    i = this.elements;
                t *= .5;
                var r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = Math.sin(t),
                    h = Math.cos(t);
                n[0] = r * h - o * l, n[1] = a * h + s * l, n[2] = o * h + r * l, n[3] = s * h - a * l;
            }, t.rotateZ = function(t, e) {
                var n = e.elements,
                    i = this.elements;
                t *= .5;
                var r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = Math.sin(t),
                    h = Math.cos(t);
                n[0] = r * h + a * l, n[1] = a * h - r * l, n[2] = o * h + s * l, n[3] = s * h - o * l;
            }, t.getYawPitchRoll = function(t) {
                U.transformQuat(U.ForwardRH, this, a.TEMPVector31), U.transformQuat(U.Up, this, a.TEMPVector32);
                var e = a.TEMPVector32.elements;
                a.angleTo(U.ZERO, a.TEMPVector31, a.TEMPVector33);
                var n = a.TEMPVector33.elements;
                n[0] == Math.PI / 2 ? (n[1] = a.arcTanAngle(e[2], e[0]), n[2] = 0) : n[0] == -Math.PI / 2 ? (n[1] = a.arcTanAngle(-e[2], -e[0]),
                        n[2] = 0) : (be.createRotationY(-n[1], a.TEMPMatrix0), be.createRotationX(-n[0], a.TEMPMatrix1),
                        U.transformCoordinate(a.TEMPVector32, a.TEMPMatrix0, a.TEMPVector32), U.transformCoordinate(a.TEMPVector32, a.TEMPMatrix1, a.TEMPVector32),
                        n[2] = a.arcTanAngle(e[1], -e[0])), n[1] <= -Math.PI && (n[1] = Math.PI), n[2] <= -Math.PI && (n[2] = Math.PI),
                    n[1] >= Math.PI && n[2] >= Math.PI && (n[1] = 0, n[2] = 0, n[0] = Math.PI - n[0]);
                var i = t.elements;
                i[0] = n[1], i[1] = n[0], i[2] = n[2];
            }, t.invert = function(t) {
                var e = t.elements,
                    n = this.elements,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = i * i + r * r + a * a + o * o,
                    l = s ? 1 / s : 0;
                e[0] = -i * l, e[1] = -r * l, e[2] = -a * l, e[3] = o * l;
            }, t.identity = function() {
                var t = this.elements;
                t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1;
            }, t.fromArray = function(t, e) {
                void 0 === e && (e = 0), this.elements[0] = t[e + 0], this.elements[1] = t[e + 1],
                    this.elements[2] = t[e + 2], this.elements[3] = t[e + 3];
            }, t.cloneTo = function(t) {
                var e, n, i;
                if ((n = this.elements) !== (i = t.elements))
                    for (e = 0; e < 4; ++e) i[e] = n[e];
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t.equals = function(t) {
                var e = this.elements,
                    n = t.elements;
                return $.nearEqual(e[0], n[0]) && $.nearEqual(e[1], n[1]) && $.nearEqual(e[2], n[2]) && $.nearEqual(e[3], n[3]);
            }, t.lengthSquared = function() {
                var t = this.elements[0],
                    e = this.elements[1],
                    n = this.elements[2],
                    i = this.elements[3];
                return t * t + e * e + n * n + i * i;
            }, u(0, t, "x", function() {
                return this.elements[0];
            }, function(t) {
                this.elements[0] = t;
            }), u(0, t, "y", function() {
                return this.elements[1];
            }, function(t) {
                this.elements[1] = t;
            }), u(0, t, "z", function() {
                return this.elements[2];
            }, function(t) {
                this.elements[2] = t;
            }), u(0, t, "w", function() {
                return this.elements[3];
            }, function(t) {
                this.elements[3] = t;
            }), a._dotArray = function(t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
            }, a._normalizeArray = function(t, e) {
                var n = t[0],
                    i = t[1],
                    r = t[2],
                    a = t[3],
                    o = n * n + i * i + r * r + a * a;
                0 < o && (o = 1 / Math.sqrt(o), e[0] = n * o, e[1] = i * o, e[2] = r * o, e[3] = a * o);
            }, a._lerpArray = function(t, e, n, i) {
                var r = 1 - n;
                0 <= a._dotArray(t, e) ? (i[0] = r * t[0] + n * e[0], i[1] = r * t[1] + n * e[1],
                        i[2] = r * t[2] + n * e[2], i[3] = r * t[3] + n * e[3]) : (i[0] = r * t[0] - n * e[0],
                        i[1] = r * t[1] - n * e[1], i[2] = r * t[2] - n * e[2], i[3] = r * t[3] - n * e[3]),
                    a._normalizeArray(i, i);
            }, a.createFromYawPitchRoll = function(t, e, n, i) {
                var r = .5 * n,
                    a = .5 * e,
                    o = .5 * t,
                    s = Math.sin(r),
                    l = Math.cos(r),
                    h = Math.sin(a),
                    u = Math.cos(a),
                    c = Math.sin(o),
                    _ = Math.cos(o),
                    d = i.elements;
                d[0] = _ * h * l + c * u * s, d[1] = c * u * l - _ * h * s, d[2] = _ * u * s - c * h * l,
                    d[3] = _ * u * l + c * h * s;
            }, a.multiply = function(t, e, n) {
                var i = t.elements,
                    r = e.elements,
                    a = n.elements,
                    o = i[0],
                    s = i[1],
                    l = i[2],
                    h = i[3],
                    u = r[0],
                    c = r[1],
                    _ = r[2],
                    d = r[3],
                    f = s * _ - l * c,
                    m = l * u - o * _,
                    p = o * c - s * u,
                    T = o * u + s * c + l * _;
                a[0] = o * d + u * h + f, a[1] = s * d + c * h + m, a[2] = l * d + _ * h + p, a[3] = h * d - T;
            }, a.arcTanAngle = function(t, e) {
                return 0 == t ? 1 == e ? Math.PI / 2 : -Math.PI / 2 : 0 < t ? Math.atan(e / t) : t < 0 ? 0 < e ? Math.atan(e / t) + Math.PI : Math.atan(e / t) - Math.PI : 0;
            }, a.angleTo = function(t, e, n) {
                U.subtract(e, t, a.TEMPVector30), U.normalize(a.TEMPVector30, a.TEMPVector30), n.elements[0] = Math.asin(a.TEMPVector30.y),
                    n.elements[1] = a.arcTanAngle(-a.TEMPVector30.z, -a.TEMPVector30.x);
            }, a.createFromAxisAngle = function(t, e, n) {
                var i = n.elements,
                    r = t.elements;
                e *= .5;
                var a = Math.sin(e);
                i[0] = a * r[0], i[1] = a * r[1], i[2] = a * r[2], i[3] = Math.cos(e);
            }, a.createFromMatrix3x3 = function(t, e) {
                var n, i = e.elements,
                    r = t.elements,
                    a = r[0] + r[4] + r[8];
                if (0 < a) n = Math.sqrt(a + 1), i[3] = .5 * n, n = .5 / n, i[0] = (r[5] - r[7]) * n,
                    i[1] = (r[6] - r[2]) * n, i[2] = (r[1] - r[3]) * n;
                else {
                    var o = 0;
                    r[4] > r[0] && (o = 1), r[8] > r[3 * o + o] && (o = 2);
                    var s = (o + 1) % 3,
                        l = (o + 2) % 3;
                    n = Math.sqrt(r[3 * o + o] - r[3 * s + s] - r[3 * l + l] + 1), i[o] = .5 * n, n = .5 / n,
                        i[3] = (r[3 * s + l] - r[3 * l + s]) * n, i[s] = (r[3 * s + o] + r[3 * o + s]) * n,
                        i[l] = (r[3 * l + o] + r[3 * o + l]) * n;
                }
            }, a.createFromMatrix4x4 = function(t, e) {
                var n, i, r = t.elements,
                    a = e.elements,
                    o = r[0] + r[5] + r[10];
                0 < o ? (n = Math.sqrt(o + 1), a[3] = .5 * n, n = .5 / n, a[0] = (r[6] - r[9]) * n,
                    a[1] = (r[8] - r[2]) * n, a[2] = (r[1] - r[4]) * n) : r[0] >= r[5] && r[0] >= r[10] ? (i = .5 / (n = Math.sqrt(1 + r[0] - r[5] - r[10])),
                    a[0] = .5 * n, a[1] = (r[1] + r[4]) * i, a[2] = (r[2] + r[8]) * i, a[3] = (r[6] - r[9]) * i) : r[5] > r[10] ? (i = .5 / (n = Math.sqrt(1 + r[5] - r[0] - r[10])),
                    a[0] = (r[4] + r[1]) * i, a[1] = .5 * n, a[2] = (r[9] + r[6]) * i, a[3] = (r[8] - r[2]) * i) : (i = .5 / (n = Math.sqrt(1 + r[10] - r[0] - r[5])),
                    a[0] = (r[8] + r[2]) * i, a[1] = (r[9] + r[6]) * i, a[2] = .5 * n, a[3] = (r[1] - r[4]) * i);
            }, a.slerp = function(t, e, n, i) {
                var r, a, o, s, l, h = t.elements,
                    u = e.elements,
                    c = i.elements,
                    _ = h[0],
                    d = h[1],
                    f = h[2],
                    m = h[3],
                    p = u[0],
                    T = u[1],
                    E = u[2],
                    v = u[3];
                return (a = _ * p + d * T + f * E + m * v) < 0 && (a = -a, p = -p, T = -T, E = -E,
                        v = -v), l = 1e-6 < 1 - a ? (r = Math.acos(a), o = Math.sin(r), s = Math.sin((1 - n) * r) / o,
                        Math.sin(n * r) / o) : (s = 1 - n, n), c[0] = s * _ + l * p, c[1] = s * d + l * T,
                    c[2] = s * f + l * E, c[3] = s * m + l * v, c;
            }, a.lerp = function(t, e, n, i) {
                a._lerpArray(t.elements, e.elements, n, i.elements);
            }, a.add = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2], i[3] = r[3] + a[3];
            }, a.dot = function(t, e) {
                return a._dotArray(t.elements, e.elements);
            }, a.rotationLookAt = function(t, e, n) {
                a.lookAt(U.ZERO, t, e, n);
            }, a.lookAt = function(t, e, n, i) {
                Ne.lookAt(t, e, n, a._tempMatrix3x3), a.rotationMatrix(a._tempMatrix3x3, i);
            }, a.invert = function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = t.lengthSquared();
                $.isZero(r) || (r = 1 / r, i[0] = -n[0] * r, i[1] = -n[1] * r, i[2] = -n[2] * r,
                    i[3] = n[3] * r);
            }, a.rotationMatrix = function(t, e) {
                var n = t.elements,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    h = n[6],
                    u = n[7],
                    c = n[8],
                    _ = e.elements,
                    d = NaN,
                    f = NaN,
                    m = i + s + c;
                0 < m ? (d = Math.sqrt(m + 1), _[3] = .5 * d, d = .5 / d, _[0] = (l - u) * d, _[1] = (h - a) * d,
                    _[2] = (r - o) * d) : _[3] = s <= i && c <= i ? (f = .5 / (d = Math.sqrt(1 + i - s - c)),
                    _[0] = .5 * d, _[1] = (r + o) * f, _[2] = (a + h) * f, (l - u) * f) : c < s ? (f = .5 / (d = Math.sqrt(1 + s - i - c)),
                    _[0] = (o + r) * f, _[1] = .5 * d, _[2] = (u + l) * f, (h - a) * f) : (f = .5 / (d = Math.sqrt(1 + c - i - s)),
                    _[0] = (h + a) * f, _[1] = (u + l) * f, _[2] = .5 * d, (r - o) * f);
            }, a.DEFAULT = new a(), _(a, ["TEMPVector30", function() {
                return this.TEMPVector30 = new U();
            }, "TEMPVector31", function() {
                return this.TEMPVector31 = new U();
            }, "TEMPVector32", function() {
                return this.TEMPVector32 = new U();
            }, "TEMPVector33", function() {
                return this.TEMPVector33 = new U();
            }, "TEMPMatrix0", function() {
                return this.TEMPMatrix0 = new be();
            }, "TEMPMatrix1", function() {
                return this.TEMPMatrix1 = new be();
            }, "_tempMatrix3x3", function() {
                return this._tempMatrix3x3 = new Ne();
            }, "NAN", function() {
                return this.NAN = new a(NaN, NaN, NaN, NaN);
            }]), a;
        }(),
        B = function() {
            function t(t, e, n, i) {
                this.elements = null, void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0),
                    void 0 === i && (i = 0);
                var r = this.elements = new Float32Array(4);
                r[0] = t, r[1] = e, r[2] = n, r[3] = i;
            }
            d(t, "laya.d3.math.Native.ConchVector4");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.fromArray = function(t, e) {
                void 0 === e && (e = 0), this.elements[0] = t[e + 0], this.elements[1] = t[e + 1],
                    this.elements[2] = t[e + 2], this.elements[3] = t[e + 3];
            }, e.cloneTo = function(t) {
                var e = t.elements,
                    n = this.elements;
                e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3];
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, e.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }, e.lengthSquared = function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }, u(0, e, "x", function() {
                return this.elements[0];
            }, function(t) {
                this.elements[0] = t;
            }), u(0, e, "y", function() {
                return this.elements[1];
            }, function(t) {
                this.elements[1] = t;
            }), u(0, e, "z", function() {
                return this.elements[2];
            }, function(t) {
                this.elements[2] = t;
            }), u(0, e, "w", function() {
                return this.elements[3];
            }, function(t) {
                this.elements[3] = t;
            }), t.lerp = function(t, e, n, i) {
                var r = i.elements,
                    a = t.elements,
                    o = e.elements,
                    s = a[0],
                    l = a[1],
                    h = a[2],
                    u = a[3];
                r[0] = s + n * (o[0] - s), r[1] = l + n * (o[1] - l), r[2] = h + n * (o[2] - h),
                    r[3] = u + n * (o[3] - u);
            }, t.transformByM4x4 = function(t, e, n) {
                var i = t.elements,
                    r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = e.elements,
                    h = n.elements;
                h[0] = r * l[0] + a * l[4] + o * l[8] + s * l[12], h[1] = r * l[1] + a * l[5] + o * l[9] + s * l[13],
                    h[2] = r * l[2] + a * l[6] + o * l[10] + s * l[14], h[3] = r * l[3] + a * l[7] + o * l[11] + s * l[15];
            }, t.equals = function(t, e) {
                var n = t.elements,
                    i = e.elements;
                return $.nearEqual(Math.abs(n[0]), Math.abs(i[0])) && $.nearEqual(Math.abs(n[1]), Math.abs(i[1])) && $.nearEqual(Math.abs(n[2]), Math.abs(i[2])) && $.nearEqual(Math.abs(n[3]), Math.abs(i[3]));
            }, t.normalize = function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = t.length();
                0 < r && (i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = n[3] * r);
            }, t.add = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2], i[3] = r[3] + a[3];
            }, t.subtract = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = r[0] - a[0], i[1] = r[1] - a[1], i[2] = r[2] - a[2], i[3] = r[3] - a[3];
            }, t.multiply = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = r[0] * a[0], i[1] = r[1] * a[1], i[2] = r[2] * a[2], i[3] = r[3] * a[3];
            }, t.scale = function(t, e, n) {
                var i = n.elements,
                    r = t.elements;
                i[0] = r[0] * e, i[1] = r[1] * e, i[2] = r[2] * e, i[3] = r[3] * e;
            }, t.Clamp = function(t, e, n, i) {
                var r = t.elements,
                    a = r[0],
                    o = r[1],
                    s = r[2],
                    l = r[3],
                    h = e.elements,
                    u = h[0],
                    c = h[1],
                    _ = h[2],
                    d = h[3],
                    f = n.elements,
                    m = f[0],
                    p = f[1],
                    T = f[2],
                    E = f[3],
                    v = i.elements;
                a = (a = m < a ? m : a) < u ? u : a, o = (o = p < o ? p : o) < c ? c : o, s = (s = T < s ? T : s) < _ ? _ : s,
                    l = (l = E < l ? E : l) < d ? d : l, v[0] = a, v[1] = o, v[2] = s, v[3] = l;
            }, t.distanceSquared = function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = n[0] - i[0],
                    a = n[1] - i[1],
                    o = n[2] - i[2],
                    s = n[3] - i[3];
                return r * r + a * a + o * o + s * s;
            }, t.distance = function(t, e) {
                var n = t.elements,
                    i = e.elements,
                    r = n[0] - i[0],
                    a = n[1] - i[1],
                    o = n[2] - i[2],
                    s = n[3] - i[3];
                return Math.sqrt(r * r + a * a + o * o + s * s);
            }, t.dot = function(t, e) {
                var n = t.elements,
                    i = e.elements;
                return n[0] * i[0] + n[1] * i[1] + n[2] * i[2] + n[3] * i[3];
            }, t.min = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = Math.min(r[0], a[0]), i[1] = Math.min(r[1], a[1]), i[2] = Math.min(r[2], a[2]),
                    i[3] = Math.min(r[3], a[3]);
            }, t.max = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements;
                i[0] = Math.max(r[0], a[0]), i[1] = Math.max(r[1], a[1]), i[2] = Math.max(r[2], a[2]),
                    i[3] = Math.max(r[3], a[3]);
            }, _(t, ["ZERO", function() {
                return this.ZERO = new t();
            }, "ONE", function() {
                return this.ONE = new t(1, 1, 1, 1);
            }, "UnitX", function() {
                return this.UnitX = new t(1, 0, 0, 0);
            }, "UnitY", function() {
                return this.UnitY = new t(0, 1, 0, 0);
            }, "UnitZ", function() {
                return this.UnitZ = new t(0, 0, 1, 0);
            }, "UnitW", function() {
                return this.UnitW = new t(0, 0, 0, 1);
            }]), t;
        }(),
        U = function() {
            function o(t, e, n, i) {
                var r;
                this.elements = null, void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0),
                    r = i || new Float32Array(3), (this.elements = r)[0] = t, r[1] = e, r[2] = n;
            }
            d(o, "laya.d3.math.Native.ConchVector3");
            var t = o.prototype;
            return m.imps(t, {
                    "laya.d3.core.IClone": !0
                }), t.setValue = function(t, e, n) {
                    this.elements[0] = t, this.elements[1] = e, this.elements[2] = n;
                }, t.fromArray = function(t, e) {
                    void 0 === e && (e = 0), this.elements[0] = t[e + 0], this.elements[1] = t[e + 1],
                        this.elements[2] = t[e + 2];
                }, t.cloneTo = function(t) {
                    var e = t.elements,
                        n = this.elements;
                    e[0] = n[0], e[1] = n[1], e[2] = n[2];
                }, t.clone = function() {
                    var t = new this.constructor();
                    return this.cloneTo(t), t;
                }, t.toDefault = function() {
                    this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
                }, u(0, t, "x", function() {
                    return this.elements[0];
                }, function(t) {
                    this.elements[0] = t;
                }), u(0, t, "y", function() {
                    return this.elements[1];
                }, function(t) {
                    this.elements[1] = t;
                }), u(0, t, "z", function() {
                    return this.elements[2];
                }, function(t) {
                    this.elements[2] = t;
                }), o.distanceSquared = function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = n[0] - i[0],
                        a = n[1] - i[1],
                        o = n[2] - i[2];
                    return r * r + a * a + o * o;
                }, o.distance = function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = n[0] - i[0],
                        a = n[1] - i[1],
                        o = n[2] - i[2];
                    return Math.sqrt(r * r + a * a + o * o);
                }, o.min = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements;
                    i[0] = Math.min(r[0], a[0]), i[1] = Math.min(r[1], a[1]), i[2] = Math.min(r[2], a[2]);
                }, o.max = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements;
                    i[0] = Math.max(r[0], a[0]), i[1] = Math.max(r[1], a[1]), i[2] = Math.max(r[2], a[2]);
                }, o.transformQuat = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements,
                        o = r[0],
                        s = r[1],
                        l = r[2],
                        h = a[0],
                        u = a[1],
                        c = a[2],
                        _ = a[3],
                        d = _ * o + u * l - c * s,
                        f = _ * s + c * o - h * l,
                        m = _ * l + h * s - u * o,
                        p = -h * o - u * s - c * l;
                    i[0] = d * _ + p * -h + f * -c - m * -u, i[1] = f * _ + p * -u + m * -h - d * -c,
                        i[2] = m * _ + p * -c + d * -u - f * -h;
                }, o.scalarLength = function(t) {
                    var e = t.elements,
                        n = e[0],
                        i = e[1],
                        r = e[2];
                    return Math.sqrt(n * n + i * i + r * r);
                }, o.scalarLengthSquared = function(t) {
                    var e = t.elements,
                        n = e[0],
                        i = e[1],
                        r = e[2];
                    return n * n + i * i + r * r;
                }, o.normalize = function(t, e) {
                    var n = t.elements,
                        i = e.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = r * r + a * a + o * o;
                    0 < s && (s = 1 / Math.sqrt(s), i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s);
                }, o.multiply = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements;
                    i[0] = r[0] * a[0], i[1] = r[1] * a[1], i[2] = r[2] * a[2];
                }, o.scale = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements;
                    i[0] = r[0] * e, i[1] = r[1] * e, i[2] = r[2] * e;
                }, o.lerp = function(t, e, n, i) {
                    var r = i.elements,
                        a = t.elements,
                        o = e.elements,
                        s = a[0],
                        l = a[1],
                        h = a[2];
                    r[0] = s + n * (o[0] - s), r[1] = l + n * (o[1] - l), r[2] = h + n * (o[2] - h);
                }, o.transformV3ToV3 = function(t, e, n) {
                    var i = o._tempVector4;
                    o.transformV3ToV4(t, e, i);
                    var r = i.elements,
                        a = n.elements;
                    a[0] = r[0], a[1] = r[1], a[2] = r[2];
                }, o.transformV3ToV4 = function(t, e, n) {
                    var i = t.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = e.elements,
                        l = n.elements;
                    l[0] = r * s[0] + a * s[4] + o * s[8] + s[12], l[1] = r * s[1] + a * s[5] + o * s[9] + s[13],
                        l[2] = r * s[2] + a * s[6] + o * s[10] + s[14], l[3] = r * s[3] + a * s[7] + o * s[11] + s[15];
                }, o.TransformNormal = function(t, e, n) {
                    var i = t.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = e.elements,
                        l = n.elements;
                    l[0] = r * s[0] + a * s[4] + o * s[8], l[1] = r * s[1] + a * s[5] + o * s[9], l[2] = r * s[2] + a * s[6] + o * s[10];
                }, o.transformCoordinate = function(t, e, n) {
                    var i = t.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = e.elements,
                        l = r * s[3] + a * s[7] + o * s[11] + s[15],
                        h = n.elements;
                    h[0] = r * s[0] + a * s[4] + o * s[8] + s[12] / l, h[1] = r * s[1] + a * s[5] + o * s[9] + s[13] / l,
                        h[2] = r * s[2] + a * s[6] + o * s[10] + s[14] / l;
                }, o.Clamp = function(t, e, n, i) {
                    var r = t.elements,
                        a = r[0],
                        o = r[1],
                        s = r[2],
                        l = e.elements,
                        h = l[0],
                        u = l[1],
                        c = l[2],
                        _ = n.elements,
                        d = _[0],
                        f = _[1],
                        m = _[2],
                        p = i.elements;
                    a = (a = d < a ? d : a) < h ? h : a, o = (o = f < o ? f : o) < u ? u : o, s = (s = m < s ? m : s) < c ? c : s,
                        p[0] = a, p[1] = o, p[2] = s;
                }, o.add = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements;
                    i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2];
                }, o.subtract = function(t, e, n) {
                    var i = n.elements,
                        r = t.elements,
                        a = e.elements;
                    i[0] = r[0] - a[0], i[1] = r[1] - a[1], i[2] = r[2] - a[2];
                }, o.cross = function(t, e, n) {
                    var i = t.elements,
                        r = e.elements,
                        a = n.elements,
                        o = i[0],
                        s = i[1],
                        l = i[2],
                        h = r[0],
                        u = r[1],
                        c = r[2];
                    a[0] = s * c - l * u, a[1] = l * h - o * c, a[2] = o * u - s * h;
                }, o.dot = function(t, e) {
                    var n = t.elements,
                        i = e.elements;
                    return n[0] * i[0] + n[1] * i[1] + n[2] * i[2];
                }, o.equals = function(t, e) {
                    var n = t.elements,
                        i = e.elements;
                    return $.nearEqual(n[0], i[0]) && $.nearEqual(n[1], i[1]) && $.nearEqual(n[2], i[2]);
                }, o.ZERO = new o(0, 0, 0), o.ONE = new o(1, 1, 1), o.NegativeUnitX = new o(-1, 0, 0),
                o.UnitX = new o(1, 0, 0), o.UnitY = new o(0, 1, 0), o.UnitZ = new o(0, 0, 1), o.ForwardRH = new o(0, 0, -1),
                o.ForwardLH = new o(0, 0, 1), o.Up = new o(0, 1, 0), o.NAN = new o(NaN, NaN, NaN),
                _(o, ["_tempVector4", function() {
                    return this._tempVector4 = new B();
                }]), o;
        }(),
        Dt = function() {
            function t(t) {
                this._color = null, this.enbale = !1, this._color = t;
            }
            d(t, "laya.d3.core.particleShuriKen.module.ColorOverLifetime");
            var e = t.prototype;
            return e.cloneTo = function(t) {
                var e = t;
                this._color.cloneTo(e._color), e.enbale = this.enbale;
            }, e.clone = function() {
                var t;
                switch (this._color.type) {
                    case 0:
                        t = Rt.createByConstant(this._color.constant.clone());
                        break;

                    case 1:
                        t = Rt.createByGradient(this._color.gradient.clone());
                        break;

                    case 2:
                        t = Rt.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                        break;

                    case 3:
                        t = Rt.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                }
                var e = new this.constructor(t);
                return e.enbale = this.enbale, e;
            }, u(0, e, "color", function() {
                return this._color;
            }), t;
        }(),
        G = function() {
            function t() {
                this.enable = !1, this.randomDirection = !1;
            }
            d(t, "laya.d3.core.particleShuriKen.module.shape.BaseShape");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e._getShapeBoundBox = function(t) {
                throw new Error("BaseShape: must override it.");
            }, e._getSpeedBoundBox = function(t) {
                throw new Error("BaseShape: must override it.");
            }, e.generatePositionAndDirection = function(t, e, n, i) {
                throw new Error("BaseShape: must override it.");
            }, e._calculateProceduralBounds = function(t, e, n) {
                this._getShapeBoundBox(t);
                var i = t.min,
                    r = t.max;
                Ct.multiply(i, e, i), Ct.multiply(r, e, r);
                var a = new we(new Ct(), new Ct());
                this.randomDirection ? (a.min = new Ct(-1, -1, -1), a.max = new Ct(1, 1, 1)) : this._getSpeedBoundBox(a);
                var o = new we(new Ct(), new Ct()),
                    s = o.min,
                    l = o.max;
                Ct.scale(a.min, n.y, s), Ct.scale(a.max, n.y, l), Ct.add(t.min, s, s), Ct.add(t.max, l, l),
                    Ct.min(t.min, s, t.min), Ct.max(t.max, s, t.max);
                var h = new we(new Ct(), new Ct()),
                    u = h.min,
                    c = h.max;
                Ct.scale(a.min, n.x, u), Ct.scale(a.max, n.x, c), Ct.min(h.min, c, s), Ct.max(h.min, c, l),
                    Ct.min(t.min, s, t.min), Ct.max(t.max, s, t.max);
            }, e.cloneTo = function(t) {
                t.enable = this.enable;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t;
        }(),
        H = function() {
            function e() {
                this._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null,
                    this._referenceCount = 0, this.needsCustomCollisionCallback = !1, this._scale = new Ct(1, 1, 1),
                    this._centerMatrix = new be(), this._localOffset = new Ct(0, 0, 0), this._localRotation = new rt(0, 0, 0, 1);
            }
            d(e, "laya.d3.physics.shape.ColliderShape");
            var t = e.prototype;
            return m.imps(t, {
                    "laya.d3.core.IClone": !0
                }), t._setScale = function(t) {
                    this._compoundParent ? this.updateLocalTransformations() : (e._nativeScale.setValue(t.x, t.y, t.z),
                        this._nativeShape.setLocalScaling(e._nativeScale));
                }, t._addReference = function() {
                    this._referenceCount++;
                }, t._removeReference = function() {
                    this._referenceCount--;
                }, t.updateLocalTransformations = function() {
                    if (this._compoundParent) {
                        var t = e._tempVector30;
                        Ct.multiply(this.localOffset, this._scale, t), e._createAffineTransformation(t, this.localRotation, this._centerMatrix.elements);
                    } else e._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
                }, t.cloneTo = function(t) {
                    var e = t;
                    this._localOffset.cloneTo(e.localOffset), this._localRotation.cloneTo(e.localRotation),
                        e.localOffset = e.localOffset, e.localRotation = e.localRotation;
                }, t.clone = function() {
                    return null;
                }, t.destroy = function() {
                    this._nativeShape && (k._physics3D.destroy(this._nativeShape), this._nativeShape = null);
                }, u(0, t, "type", function() {
                    return this._type;
                }), u(0, t, "localOffset", function() {
                    return this._localOffset;
                }, function(t) {
                    this._localOffset = t, this._compoundParent && this._compoundParent._updateChildTransform(this);
                }), u(0, t, "localRotation", function() {
                    return this._localRotation;
                }, function(t) {
                    this._localRotation = t, this._compoundParent && this._compoundParent._updateChildTransform(this);
                }), e._creatShape = function(t) {
                    var e;
                    switch (t.type) {
                        case "BoxColliderShape":
                            var n = t.size;
                            e = n ? new $e(n[0], n[1], n[2]) : new $e();
                            break;

                        case "SphereColliderShape":
                            e = new We(t.radius);
                            break;

                        case "CapsuleColliderShape":
                            e = new Ze(t.radius, t.height, t.orientation);
                            break;

                        case "MeshColliderShape":
                            var i = new pn();
                            t.mesh && (i.mesh = xt.getRes(t.mesh)), e = i;
                            break;

                        case "ConeColliderShape":
                            e = new yn(t.radius, t.height, t.orientation);
                            break;

                        case "CylinderColliderShape":
                            e = new ln(t.radius, t.height, t.orientation);
                            break;

                        default:
                            throw "unknown shape type.";
                    }
                    if (t.center) {
                        var r = e.localOffset;
                        r.fromArray(t.center), e.localOffset = r;
                    }
                    return e;
                }, e._createAffineTransformation = function(t, e, n) {
                    var i = e.x,
                        r = e.y,
                        a = e.z,
                        o = e.w,
                        s = i + i,
                        l = r + r,
                        h = a + a,
                        u = i * s,
                        c = i * l,
                        _ = i * h,
                        d = r * l,
                        f = r * h,
                        m = a * h,
                        p = o * s,
                        T = o * l,
                        E = o * h;
                    n[0] = 1 - (d + m), n[1] = c + E, n[2] = _ - T, n[3] = 0, n[4] = c - E, n[5] = 1 - (u + m),
                        n[6] = f + p, n[7] = 0, n[8] = _ + T, n[9] = f - p, n[10] = 1 - (u + d), n[11] = 0,
                        n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1;
                }, e.SHAPEORIENTATION_UPX = 0, e.SHAPEORIENTATION_UPY = 1, e.SHAPEORIENTATION_UPZ = 2,
                e.SHAPETYPES_BOX = 0, e.SHAPETYPES_SPHERE = 1, e.SHAPETYPES_CYLINDER = 2, e.SHAPETYPES_CAPSULE = 3,
                e.SHAPETYPES_CONVEXHULL = 4, e.SHAPETYPES_COMPOUND = 5, e.SHAPETYPES_STATICPLANE = 6,
                e.SHAPETYPES_CONE = 7, _(e, ["_tempVector30", function() {
                    return this._tempVector30 = new Ct();
                }, "_nativeScale", function() {
                    return this._nativeScale = new k._physics3D.btVector3(1, 1, 1);
                }, "_nativeVector30", function() {
                    return this._nativeVector30 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativQuaternion0", function() {
                    return this._nativQuaternion0 = new k._physics3D.btQuaternion(0, 0, 0, 1);
                }, "_nativeTransform0", function() {
                    return this._nativeTransform0 = new k._physics3D.btTransform();
                }]), e;
        }(),
        k = function() {
            function w() {}
            return d(w, "Laya3D"), u(1, w, "enbalePhysics", function() {
                    return w._enbalePhysics;
                }), w._cancelLoadByUrl = function(t) {
                    m.loader.cancelLoadByUrl(t), w._innerFirstLevelLoaderManager.cancelLoadByUrl(t),
                        w._innerSecondLevelLoaderManager.cancelLoadByUrl(t), w._innerThirdLevelLoaderManager.cancelLoadByUrl(t),
                        w._innerFourthLevelLoaderManager.cancelLoadByUrl(t);
                }, w._changeWebGLSize = function(t, e) {
                    N.onStageResize(t, e), j.clientWidth = t, j.clientHeight = e;
                }, w.__init__ = function(t, e, n) {
                    if (l.isAntialias = n.isAntialias, l.isAlpha = n.isAlpha, l.premultipliedAlpha = n.premultipliedAlpha,
                        l.isStencil = n.isStencil, N.enable()) {
                        y.changeWebGLSize = w._changeWebGLSize, b.is3DMode = !0, m.init(t, e), b.supportWebGLPlusRendering || (E.instance = N.mainContext,
                                E.instance.createCommandEncoder = function(t, e, n) {
                                    return void 0 === t && (t = 128), void 0 === e && (e = 64), void 0 === n && (n = !1),
                                        new a(this, t, e, n);
                                }), w.enableNative3D(), An.__init__(), Hn.__init__(), li.__init__(), fi.__init__(),
                            _i.__init__(), Cn.__init__(), ei.__init__(), qn.__init__(), ri.__init__(), Zn.__init__(),
                            kn.__init__(), ci.__init__(), Yn.__init__(), Jn.__init__(), $n.__init__(), Qn.__init__(),
                            ni.__init__(), ti.__init__(), zt.__init__(), jn.defaultMaterial.lock = !0, ei.defaultMaterial.lock = !0,
                            Jn.defaultMaterial.lock = !0, qn.defaultMaterial.lock = !0, ri.defaultMaterial.lock = !0,
                            kn.defaultMaterial.lock = !0, Qn.defaultMaterial.lock = !0, Yn.defaultMaterial.lock = !0,
                            Zn.defaultMaterial.lock = !0, ii.defaultMaterial.lock = !0, $n.defaultMaterial.lock = !0,
                            L.__init__(), si.__init__(), mn.__init__(), Sn.__init__(), Ce.__init__(), vt.__init__();
                        var i = v.createMap;
                        i.lh = ["HIERARCHY", An._parse], i.ls = ["HIERARCHY", Gn._parse], i.lm = ["MESH", On._parse],
                            i.lmat = ["MATERIAL", Cn._parse], i.ltc = ["TEXTURECUBE", si._parse], i.jpg = ["TEXTURE2D", L._parse],
                            i.jpeg = ["TEXTURE2D", L._parse], i.bmp = ["TEXTURE2D", L._parse], i.gif = ["TEXTURE2D", L._parse],
                            i.png = ["TEXTURE2D", L._parse], i.dds = ["TEXTURE2D", L._parse], i.ktx = ["TEXTURE2D", L._parse],
                            i.pvr = ["TEXTURE2D", L._parse], i.lani = ["ANIMATIONCLIP", Vn._parse], i.lav = ["AVATAR", Ln._parse],
                            i.thdata = ["TERRAINHEIGHTDATA", Nn._pharse];
                        var r = xt.parserMap;
                        r.HIERARCHY = w._loadHierarchy, r.MESH = w._loadMesh, r.MATERIAL = w._loadMaterial,
                            r.TEXTURECUBE = w._loadTextureCube, r.TEXTURE2D = w._loadTexture2D, r.ANIMATIONCLIP = w._loadAnimationClip,
                            r.AVATAR = w._loadAvatar, w._innerFirstLevelLoaderManager.on("error", null, w._eventLoadManagerError),
                            w._innerSecondLevelLoaderManager.on("error", null, w._eventLoadManagerError), w._innerThirdLevelLoaderManager.on("error", null, w._eventLoadManagerError),
                            w._innerFourthLevelLoaderManager.on("error", null, w._eventLoadManagerError);
                    } else alert("Laya3D init error,must support webGL!");
                }, w.enableNative3D = function() {
                    if (b.isConchApp) {
                        E = o.LayaGLContext;
                        var t = at,
                            e = wn,
                            n = Ln,
                            i = Ce,
                            r = Bn;
                        if (b.supportWebGLPlusRendering && (t.prototype._initData = t.prototype._initDataForNative,
                                t.prototype.setBool = t.prototype.setBoolForNative, t.prototype.getBool = t.prototype.getBoolForNative,
                                t.prototype.setInt = t.prototype.setIntForNative, t.prototype.getInt = t.prototype.getIntForNative,
                                t.prototype.setNumber = t.prototype.setNumberForNative, t.prototype.getNumber = t.prototype.getNumberForNative,
                                t.prototype.setVector = t.prototype.setVectorForNative, t.prototype.getVector = t.prototype.getVectorForNative,
                                t.prototype.setVector2 = t.prototype.setVector2ForNative, t.prototype.getVector2 = t.prototype.getVector2ForNative,
                                t.prototype.setVector3 = t.prototype.setVector3ForNative, t.prototype.getVector3 = t.prototype.getVector3ForNative,
                                t.prototype.setQuaternion = t.prototype.setQuaternionForNative, t.prototype.getQuaternion = t.prototype.getQuaternionForNative,
                                t.prototype.setMatrix4x4 = t.prototype.setMatrix4x4ForNative, t.prototype.getMatrix4x4 = t.prototype.getMatrix4x4ForNative,
                                t.prototype.setBuffer = t.prototype.setBufferForNative, t.prototype.getBuffer = t.prototype.getBufferForNative,
                                t.prototype.setTexture = t.prototype.setTextureForNative, t.prototype.getTexture = t.prototype.getTextureForNative,
                                t.prototype.setAttribute = t.prototype.setAttributeForNative, t.prototype.getAttribute = t.prototype.getAttributeForNative,
                                t.prototype.cloneTo = t.prototype.cloneToForNative, t.prototype.getData = t.prototype.getDataForNative,
                                e.prototype._uniformMatrix2fv = e.prototype._uniformMatrix2fvForNative, e.prototype._uniformMatrix3fv = e.prototype._uniformMatrix3fvForNative,
                                e.prototype._uniformMatrix4fv = e.prototype._uniformMatrix4fvForNative, r.prototype._renderUpdateWithCamera = r.prototype._renderUpdateWithCameraForNative),
                            b.supportWebGLPlusCulling && (i.renderObjectCulling = Ce.renderObjectCullingNative),
                            b.supportWebGLPlusAnimation) {
                            n.prototype._cloneDatasToAnimator = n.prototype._cloneDatasToAnimatorNative, un = o.conchFloatKeyframe,
                                gn = o.conchFloatArrayKeyframe, Dn = o.conchFloatArrayKeyframe, Te = o.conchKeyframeNode,
                                Kt = o.conchKeyframeNodeList;
                            var a = Vn;
                            a.prototype._evaluateClipDatasRealTime = a.prototype._evaluateClipDatasRealTimeForNative;
                        }
                    }
                    N.shaderHighPrecision = !1, E.instance.getShaderPrecisionFormat(35632, 36338).precision ? N.shaderHighPrecision = !0 : N.shaderHighPrecision = !1;
                }, w.formatRelativePath = function(t, e) {
                    var n;
                    if (n = t + e, "." === e.charAt(0)) {
                        for (var i = n.split("/"), r = 0, a = i.length; r < a; r++)
                            if (".." == i[r]) {
                                var o = r - 1;
                                0 < o && ".." !== i[o] && (i.splice(o, 2), r -= 2);
                            }
                        n = i.join("/");
                    }
                    return n;
                }, w._endLoad = function(t, e, n) {
                    if (n)
                        for (var i = 0, r = n.length; i < r; i++) {
                            var a = xt.getRes(n[i]);
                            a && a._removeReference();
                        }
                    t.endLoad(e);
                }, w._eventLoadManagerError = function(t) {
                    m.loader.event("error", t);
                }, w._addHierarchyInnerUrls = function(t, e, n, i, r, a, o, s) {
                    var l = w.formatRelativePath(i, r);
                    return n && (l += n), t.push({
                        url: l,
                        type: a,
                        constructParams: o,
                        propertyParams: s
                    }), e.push(l), l;
                }, w._getSprite3DHierarchyInnerUrls = function(t, e, n, i, r, a, o, s) {
                    var l = 0,
                        h = 0,
                        u = t.props;
                    switch (t.type) {
                        case "Scene3D":
                            var c = u.lightmaps;
                            for (l = 0, h = c.length; l < h; l++) {
                                var _ = c[l];
                                _.path = w._addHierarchyInnerUrls(r, a, o, s, _.path, "TEXTURE2D", _.constructParams, _.propertyParams);
                            }
                            var d = u.reflectionTexture;
                            if (d && (u.reflectionTexture = w._addHierarchyInnerUrls(i, a, o, s, d, "TEXTURECUBE")),
                                u.sky) {
                                var f = u.sky.material;
                                f && (f.path = w._addHierarchyInnerUrls(n, a, o, s, f.path, "MATERIAL"));
                            }
                            break;

                        case "Camera":
                            var m = u.skyboxMaterial;
                            m && (m.path = w._addHierarchyInnerUrls(n, a, o, s, m.path, "MATERIAL"));
                            break;

                        case "TrailSprite3D":
                        case "MeshSprite3D":
                        case "SkinnedMeshSprite3D":
                            var p = u.meshPath;
                            p && (u.meshPath = w._addHierarchyInnerUrls(e, a, o, s, p, "MESH"));
                            var T = u.materials;
                            if (T)
                                for (l = 0, h = T.length; l < h; l++) T[l].path = w._addHierarchyInnerUrls(n, a, o, s, T[l].path, "MATERIAL");
                            break;

                        case "ShuriKenParticle3D":
                            var E = u.meshPath;
                            E && (u.meshPath = w._addHierarchyInnerUrls(e, a, o, s, E, "MESH")), u.material.path = w._addHierarchyInnerUrls(n, a, o, s, u.material.path, "MATERIAL");
                            break;

                        case "Terrain":
                            w._addHierarchyInnerUrls(r, a, o, s, u.dataPath, "TERRAIN");
                    }
                    var v = t.components;
                    if (v)
                        for (var g = 0, S = v.length; g < S; g++) {
                            var y = v[g];
                            switch (y.type) {
                                case "Animator":
                                    y.avatarPath;
                                    var x = y.avatar;
                                    x && (x.path = w._addHierarchyInnerUrls(r, a, o, s, x.path, "AVATAR"));
                                    var D = y.clipPaths;
                                    if (D)
                                        for (l = 0, h = D.length; l < h; l++) D[l] = w._addHierarchyInnerUrls(r, a, o, s, D[l], "ANIMATIONCLIP");
                                    else {
                                        var I = y.layers;
                                        for (l = 0; l < I.length; l++)
                                            for (var R = I[l].states, M = 0, A = R.length; M < A; M++) {
                                                var C = R[M].clipPath;
                                                C && (R[M].clipPath = w._addHierarchyInnerUrls(r, a, o, s, C, "ANIMATIONCLIP"));
                                            }
                                    }
                                    break;

                                case "PhysicsCollider":
                                case "Rigidbody3D":
                                case "CharacterController":
                                    var L = y.shapes;
                                    for (l = 0; l < L.length; l++) {
                                        var O = L[l];
                                        if ("MeshColliderShape" === O.type) {
                                            var N = O.mesh;
                                            N && (O.mesh = w._addHierarchyInnerUrls(e, a, o, s, N, "MESH"));
                                        }
                                    }
                            }
                        }
                    var V = t.child;
                    for (l = 0, h = V.length; l < h; l++) w._getSprite3DHierarchyInnerUrls(V[l], e, n, i, r, a, o, s);
                }, w._loadHierarchy = function(t) {
                    t.on("loaded", null, w._onHierarchylhLoaded, [t]), t.load(t.url, "json", !1, null, !0);
                }, w._onHierarchylhLoaded = function(t, e) {
                    var n = t.url,
                        i = Gt.getURLVerion(n),
                        r = O.getPath(n),
                        a = [],
                        o = [],
                        s = [],
                        l = [],
                        h = [];
                    w._getSprite3DHierarchyInnerUrls(e.data, a, o, s, l, h, i, r);
                    var u = a.length + o.length + l.length,
                        c = u + 1,
                        _ = 1 / c;
                    if (w._onProcessChange(t, 0, _, 1), 0 < l.length) {
                        var d = u / c,
                            f = T.create(null, w._onProcessChange, [t, _, d], !1);
                        w._innerFourthLevelLoaderManager._create(l, !1, T.create(null, w._onHierarchyInnerForthLevResouLoaded, [t, f, e, h, a, o, s, _ + d * l.length, d]), f, null, null, null, 1, !0);
                    } else w._onHierarchyInnerForthLevResouLoaded(t, null, e, h, a, o, s, _, d);
                }, w._onHierarchyInnerForthLevResouLoaded = function(t, e, n, i, r, a, o, s, l) {
                    if (e && e.recover(), 0 < o.length) {
                        var h = T.create(null, w._onProcessChange, [t, s, l], !1);
                        w._innerThirdLevelLoaderManager._create(o, !1, T.create(null, w._onHierarchyInnerThirdLevResouLoaded, [t, h, n, i, r, a, s + l * a.length, l]), e, null, null, null, 1, !0);
                    } else w._onHierarchyInnerThirdLevResouLoaded(t, null, n, i, r, a, s, l);
                }, w._onHierarchyInnerThirdLevResouLoaded = function(t, e, n, i, r, a, o, s) {
                    if (e && e.recover(), 0 < a.length) {
                        var l = T.create(null, w._onProcessChange, [t, o, s], !1);
                        w._innerSecondLevelLoaderManager._create(a, !1, T.create(null, w._onHierarchyInnerSecondLevResouLoaded, [t, l, n, i, r, o + s * a.length, s]), e, null, null, null, 1, !0);
                    } else w._onHierarchyInnerSecondLevResouLoaded(t, null, n, i, r, o, s);
                }, w._onHierarchyInnerSecondLevResouLoaded = function(t, e, n, i, r, a, o) {
                    if (e && e.recover(), 0 < r.length) {
                        var s = T.create(null, w._onProcessChange, [t, a, o], !1);
                        w._innerFirstLevelLoaderManager._create(r, !1, T.create(null, w._onHierarchyInnerFirstLevResouLoaded, [t, s, n, i]), e, null, null, null, 1, !0);
                    } else w._onHierarchyInnerFirstLevResouLoaded(t, null, n, i);
                }, w._onHierarchyInnerFirstLevResouLoaded = function(t, e, n, i) {
                    e && e.recover(), t._cache = t._createCache;
                    var r = "Scene3D" === n.data.type ? Gn._parse(n, t._propertyParams, t._constructParams) : An._parse(n, t._propertyParams, t._constructParams);
                    w._endLoad(t, r, i);
                }, w._loadMesh = function(t) {
                    t.on("loaded", null, w._onMeshLmLoaded, [t]), t.load(t.url, "arraybuffer", !1, null, !0);
                }, w._onMeshLmLoaded = function(t, e) {
                    t._cache = t._createCache;
                    var n = On._parse(e, t._propertyParams, t._constructParams);
                    w._endLoad(t, n);
                }, w._loadMaterial = function(t) {
                    t.on("loaded", null, w._onMaterilLmatLoaded, [t]), t.load(t.url, "json", !1, null, !0);
                }, w._onMaterilLmatLoaded = function(t, e) {
                    var n, i = t.url,
                        r = Gt.getURLVerion(i),
                        a = O.getPath(i),
                        o = [],
                        s = [];
                    e.customProps;
                    switch (e.version) {
                        case "LAYAMATERIAL:01":
                        case "LAYAMATERIAL:02":
                            var l = 0,
                                h = 0,
                                u = e.props.textures;
                            if (u)
                                for (l = 0, h = u.length; l < h; l++) {
                                    var c = u[l],
                                        _ = c.path;
                                    _ && (n = w.formatRelativePath(a, _), r && (n += r), o.push({
                                        url: n,
                                        constructParams: c.constructParams,
                                        propertyParams: c.propertyParams
                                    }), s.push(n), c.path = n);
                                }
                            break;

                        default:
                            throw new Error("Laya3D:unkonwn version.");
                    }
                    var d = o.length,
                        f = d + 1,
                        m = 1 / f;
                    if (w._onProcessChange(t, 0, m, 1), 0 < d) {
                        var p = T.create(null, w._onProcessChange, [t, m, d / f], !1);
                        w._innerFourthLevelLoaderManager._create(o, !1, T.create(null, w._onMateialTexturesLoaded, [t, p, e, s]), p, null, null, null, 1, !0);
                    } else w._onMateialTexturesLoaded(t, null, e, null);
                }, w._onMateialTexturesLoaded = function(t, e, n, i) {
                    t._cache = t._createCache;
                    var r = Cn._parse(n, t._propertyParams, t._constructParams);
                    w._endLoad(t, r, i), e && e.recover();
                }, w._loadAvatar = function(n) {
                    n.on("loaded", null, function(t) {
                        n._cache = n._createCache;
                        var e = Ln._parse(t, n._propertyParams, n._constructParams);
                        w._endLoad(n, e);
                    }), n.load(n.url, "json", !1, null, !0);
                }, w._loadAnimationClip = function(n) {
                    n.on("loaded", null, function(t) {
                        n._cache = n._createCache;
                        var e = Vn._parse(t, n._propertyParams, n._constructParams);
                        w._endLoad(n, e);
                    }), n.load(n.url, "arraybuffer", !1, null, !0);
                }, w._loadTexture2D = function(n) {
                    var t, e = n.url,
                        i = e.lastIndexOf(".") + 1,
                        r = e.indexOf("?"),
                        a = -1 == r ? e.length : r;
                    switch (e.substr(i, a - i)) {
                        case "jpg":
                        case "jpeg":
                        case "bmp":
                        case "gif":
                        case "png":
                            t = "nativeimage";
                            break;

                        case "dds":
                        case "ktx":
                        case "pvr":
                            t = "arraybuffer";
                    }
                    n.on("loaded", null, function(t) {
                        n._cache = n._createCache;
                        var e = L._parse(t, n._propertyParams, n._constructParams);
                        w._endLoad(n, e);
                    }), n.load(n.url, t, !1, null, !0);
                }, w._loadTextureCube = function(t) {
                    t.on("loaded", null, w._onTextureCubeLtcLoaded, [t]), t.load(t.url, "json", !1, null, !0);
                }, w._onTextureCubeLtcLoaded = function(t, e) {
                    var n = O.getPath(t.url),
                        i = [w.formatRelativePath(n, e.front), w.formatRelativePath(n, e.back), w.formatRelativePath(n, e.left), w.formatRelativePath(n, e.right), w.formatRelativePath(n, e.up), w.formatRelativePath(n, e.down)];
                    w._onProcessChange(t, 0, 1 / 7, 1);
                    var r = T.create(null, w._onProcessChange, [t, 1 / 7, 6 / 7], !1);
                    w._innerFourthLevelLoaderManager.load(i, T.create(null, w._onTextureCubeImagesLoaded, [t, i, r]), r, "nativeimage");
                }, w._onTextureCubeImagesLoaded = function(t, e, n) {
                    for (var i = new Array(6), r = 0; r < 6; r++) i[r] = xt.getRes(e[r]);
                    t._cache = t._createCache;
                    var a = si._parse(i, t._propertyParams, t._constructParams);
                    for (n.recover(), r = 0; r < 6; r++) xt.clearRes(e[r]);
                    w._endLoad(t, a);
                }, w._onProcessChange = function(t, e, n, i) {
                    (i = e + i * n) < 1 && t.event("progress", i);
                }, w.init = function(t, e, n, i) {
                    if (!w._isInit) {
                        w._isInit = !0, (n = n || oe._default).cloneTo(w._config), w._editerEnvironment = w._config._editerEnvironment;
                        var r = o.Physics3D;
                        null == r ? (w._enbalePhysics = !1, w.__init__(t, e, w._config), i && i.run()) : (w._enbalePhysics = !0,
                            r(1024 * w._config.defaultPhysicsMemory * 1024).then(function() {
                                w.__init__(t, e, w._config), i && i.run();
                            }));
                    }
                }, w.HIERARCHY = "HIERARCHY", w.MESH = "MESH", w.MATERIAL = "MATERIAL", w.TEXTURE2D = "TEXTURE2D",
                w.TEXTURECUBE = "TEXTURECUBE", w.ANIMATIONCLIP = "ANIMATIONCLIP", w.AVATAR = "AVATAR",
                w.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", w.TERRAINRES = "TERRAIN", w._isInit = !1,
                w._enbalePhysics = !1, w._editerEnvironment = !1, _(w, ["_innerFirstLevelLoaderManager", function() {
                    return this._innerFirstLevelLoaderManager = new v();
                }, "_innerSecondLevelLoaderManager", function() {
                    return this._innerSecondLevelLoaderManager = new v();
                }, "_innerThirdLevelLoaderManager", function() {
                    return this._innerThirdLevelLoaderManager = new v();
                }, "_innerFourthLevelLoaderManager", function() {
                    return this._innerFourthLevelLoaderManager = new v();
                }, "_physics3D", function() {
                    return this._physics3D = o.Physics3D;
                }, "_config", function() {
                    return this._config = new oe();
                }, "physicsSettings", function() {
                    return this.physicsSettings = new tt();
                }]), w;
        }(),
        It = function() {
            function i() {
                this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0,
                    this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
            }
            d(i, "laya.d3.core.particleShuriKen.module.FrameOverTime");
            var t = i.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, e._constant = this._constant, this._overTime.cloneTo(e._overTime),
                    e._constantMin = this._constantMin, e._constantMax = this._constantMax, this._overTimeMin.cloneTo(e._overTimeMin),
                    this._overTimeMax.cloneTo(e._overTimeMax);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "frameOverTimeData", function() {
                return this._overTime;
            }), u(0, t, "constant", function() {
                return this._constant;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "frameOverTimeDataMin", function() {
                return this._overTimeMin;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "frameOverTimeDataMax", function() {
                return this._overTimeMax;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), i.createByConstant = function(t) {
                var e = new i();
                return e._type = 0, e._constant = t, e;
            }, i.createByOverTime = function(t) {
                var e = new i();
                return e._type = 1, e._overTime = t, e;
            }, i.createByRandomTwoConstant = function(t, e) {
                var n = new i();
                return n._type = 2, n._constantMin = t, n._constantMax = e, n;
            }, i.createByRandomTwoOverTime = function(t, e) {
                var n = new i();
                return n._type = 3, n._overTimeMin = t, n._overTimeMax = e, n;
            }, i;
        }(),
        W = function() {
            function t() {
                this.cull = 0, this.blend = 0, this.srcBlend = 0, this.dstBlend = 0, this.srcBlendRGB = 0,
                    this.dstBlendRGB = 0, this.srcBlendAlpha = 0, this.dstBlendAlpha = 0, this.blendConstColor = null,
                    this.blendEquation = 0, this.blendEquationRGB = 0, this.blendEquationAlpha = 0,
                    this.depthTest = 0, this.depthWrite = !1, this.cull = 2, this.blend = 0, this.srcBlend = 1,
                    this.dstBlend = 0, this.srcBlendRGB = 1, this.dstBlendRGB = 0, this.srcBlendAlpha = 1,
                    this.dstBlendAlpha = 0, this.blendConstColor = new At(1, 1, 1, 1), this.blendEquation = 0,
                    this.blendEquationRGB = 0, this.blendEquationAlpha = 0, this.depthTest = 515, this.depthWrite = !0;
            }
            d(t, "laya.d3.core.material.RenderState");
            var e = t.prototype;
            return m.imps(e, {
                    "laya.d3.core.IClone": !0
                }), e.cloneTo = function(t) {
                    var e = t;
                    e.cull = this.cull, e.blend = this.blend, e.srcBlend = this.srcBlend, e.dstBlend = this.dstBlend,
                        e.srcBlendRGB = this.srcBlendRGB, e.dstBlendRGB = this.dstBlendRGB, e.srcBlendAlpha = this.srcBlendAlpha,
                        e.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(e.blendConstColor),
                        e.blendEquation = this.blendEquation, e.blendEquationRGB = this.blendEquationRGB,
                        e.blendEquationAlpha = this.blendEquationAlpha, e.depthTest = this.depthTest, e.depthWrite = this.depthWrite;
                }, e.clone = function() {
                    var t = new this.constructor();
                    return this.cloneTo(t), t;
                }, t.CULL_NONE = 0, t.CULL_FRONT = 1, t.CULL_BACK = 2, t.BLEND_DISABLE = 0, t.BLEND_ENABLE_ALL = 1,
                t.BLEND_ENABLE_SEPERATE = 2, t.BLENDPARAM_ZERO = 0, t.BLENDPARAM_ONE = 1, t.BLENDPARAM_SRC_COLOR = 768,
                t.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, t.BLENDPARAM_DST_COLOR = 774, t.BLENDPARAM_ONE_MINUS_DST_COLOR = 775,
                t.BLENDPARAM_SRC_ALPHA = 770, t.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, t.BLENDPARAM_DST_ALPHA = 772,
                t.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, t.BLENDPARAM_SRC_ALPHA_SATURATE = 776, t.BLENDEQUATION_ADD = 0,
                t.BLENDEQUATION_SUBTRACT = 1, t.BLENDEQUATION_REVERSE_SUBTRACT = 2, t.DEPTHTEST_OFF = 0,
                t.DEPTHTEST_NEVER = 512, t.DEPTHTEST_LESS = 513, t.DEPTHTEST_EQUAL = 514, t.DEPTHTEST_LEQUAL = 515,
                t.DEPTHTEST_GREATER = 516, t.DEPTHTEST_NOTEQUAL = 517, t.DEPTHTEST_GEQUAL = 518,
                t.DEPTHTEST_ALWAYS = 519, t;
        }(),
        X = function() {
            function t(t, e) {
                this.origin = null, this.direction = null, this.origin = t, this.direction = e;
            }
            return d(t, "laya.d3.math.Ray"), t;
        }(),
        Y = function() {
            function t() {
                this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0,
                    this.normal = new Ct(), this.positionOnA = new Ct(), this.positionOnB = new Ct(),
                    this._id = ++this._idCounter;
            }
            return d(t, "laya.d3.physics.ContactPoint"), t;
        }(),
        Z = function() {
            function a() {
                this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0,
                    this._batchRenderElementPool = [];
            }
            d(a, "laya.d3.graphics.StaticBatchManager");
            var t = a.prototype;
            return t._partition = function(t, e, n) {
                for (var i = t[Math.floor((n + e) / 2)]; e <= n;) {
                    for (; this._compare(t[e], i) < 0;) e++;
                    for (; 0 < this._compare(t[n], i);) n--;
                    if (e < n) {
                        var r = t[e];
                        t[e] = t[n], t[n] = r, e++, n--;
                    } else if (e === n) {
                        e++;
                        break;
                    }
                }
                return e;
            }, t._quickSort = function(t, e, n) {
                if (1 < t.length) {
                    var i = this._partition(t, e, n),
                        r = i - 1;
                    e < r && this._quickSort(t, e, r), i < n && this._quickSort(t, i, n);
                }
            }, t._compare = function(t, e) {
                throw "StaticBatch:must override this function.";
            }, t._initStaticBatchs = function(t) {
                throw "StaticBatch:must override this function.";
            }, t._getBatchRenderElementFromPool = function() {
                throw "StaticBatch:must override this function.";
            }, t._addBatchSprite = function(t) {
                this._initBatchSprites.push(t);
            }, t._clear = function() {
                this._batchRenderElementPoolIndex = 0;
            }, t._garbageCollection = function() {
                throw "StaticBatchManager: must override it.";
            }, t.dispose = function() {
                this._staticBatches = null;
            }, a._registerManager = function(t) {
                a._managers.push(t);
            }, a._addToStaticBatchQueue = function(t) {
                t instanceof laya.d3.core.RenderableSprite3D && t.isStatic && t._addToInitStaticBatchManager();
                for (var e = 0, n = t.numChildren; e < n; e++) a._addToStaticBatchQueue(t._children[e]);
            }, a.combine = function(t, e) {
                var n = 0,
                    i = 0;
                if (e)
                    for (n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        r.isStatic && r._addToInitStaticBatchManager();
                    } else t && a._addToStaticBatchQueue(t);
                for (n = 0, i = a._managers.length; n < i; n++) {
                    a._managers[n]._initStaticBatchs(t);
                }
            }, a._managers = [], a;
        }(),
        j = function() {
            function t() {}
            return d(t, "laya.d3.core.render.RenderContext3D"), t.clientWidth = 0, t.clientHeight = 0,
                _(t, ["_instance", function() {
                    return this._instance = new t();
                }]), t;
        }(),
        K = (function() {
            function t() {}
            d(t, "laya.d3.core.GradientMode"), t.Blend = 0, t.Fixed = 1;
        }(), function() {
            function t() {
                this.length = 0, this.elements = [];
            }
            return d(t, "laya.d3.component.SingletonList"), t.prototype._add = function(t) {
                this.length === this.elements.length ? this.elements.push(t) : this.elements[this.length] = t;
            }, t;
        }()),
        q = function() {
            function e() {
                this._batchRenderElementPool = [];
            }
            d(e, "laya.d3.graphics.DynamicBatchManager");
            var t = e.prototype;
            return t._clear = function() {
                this._batchRenderElementPoolIndex = 0;
            }, t._getBatchRenderElementFromPool = function() {
                throw "StaticBatch:must override this function.";
            }, t.dispose = function() {}, e._registerManager = function(t) {
                e._managers.push(t);
            }, e._managers = [], e;
        }(),
        Q = (function() {
            function t() {
                this._damping = NaN, this._impulseClamp = NaN, this._tau = NaN, this._pivotInA = new Ct(),
                    this._pivotInB = new Ct();
            }
            d(t, "laya.d3.physics.constraints.Point2PointConstraint");
            var e = t.prototype;
            u(0, e, "pivotInA", function() {
                return this._pivotInA;
            }, function(t) {
                this._pivotInA = t;
            }), u(0, e, "pivotInB", function() {
                return this._pivotInB;
            }, function(t) {
                this._pivotInB = t;
            }), u(0, e, "damping", function() {
                return this._damping;
            }, function(t) {
                this._damping = t;
            }), u(0, e, "impulseClamp", function() {
                return this._impulseClamp;
            }, function(t) {
                this._impulseClamp = t;
            }), u(0, e, "tau", function() {
                return this._tau;
            }, function(t) {
                this._tau = t;
            });
        }(), function() {
            function t() {
                this._destroyed = !1;
            }
            d(t, "laya.d3.core.GeometryElement");
            var e = t.prototype;
            return m.imps(e, {
                "laya.resource.IDestroy": !0
            }), e._getType = function() {
                throw "GeometryElement:must override it.";
            }, e._prepareRender = function(t) {
                return !0;
            }, e._render = function(t) {
                throw "GeometryElement:must override it.";
            }, e.destroy = function() {
                this._destroyed || (this._destroyed = !0);
            }, u(0, e, "destroyed", function() {
                return this._destroyed;
            }), t._typeCounter = 0, t;
        }()),
        J = function() {
            function t(t, e) {
                this._position = null, this._textureCoordinate0 = null, this._position = t, this._textureCoordinate0 = e;
            }
            d(t, "laya.d3.graphics.Vertex.VertexPositionTexture0");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.graphics.IVertex": !0
            }), u(0, e, "position", function() {
                return this._position;
            }), u(0, e, "textureCoordinate0", function() {
                return this._textureCoordinate0;
            }), u(0, e, "vertexDeclaration", function() {
                return t._vertexDeclaration;
            }), u(1, t, "vertexDeclaration", function() {
                return t._vertexDeclaration;
            }), _(t, ["_vertexDeclaration", function() {
                return this._vertexDeclaration = new ue(20, [new Bt(0, "vector3", 0), new Bt(12, "vector2", 2)]);
            }]), t;
        }(),
        $ = function() {
            function n() {}
            return d(n, "laya.d3.math.MathUtils3D"), n.isZero = function(t) {
                return Math.abs(t) < n.zeroTolerance;
            }, n.nearEqual = function(t, e) {
                return !!n.isZero(t - e);
            }, n.fastInvSqrt = function(t) {
                return n.isZero(t) ? t : 1 / Math.sqrt(t);
            }, _(n, ["zeroTolerance", function() {
                return this.zeroTolerance = 1e-6;
            }, "MaxValue", function() {
                return this.MaxValue = 3.40282347e38;
            }, "MinValue", function() {
                return this.MinValue = -3.40282347e38;
            }]), n;
        }(),
        Rt = function() {
            function i() {
                this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null,
                    this._gradient = null, this._gradientMin = null, this._gradientMax = null;
            }
            d(i, "laya.d3.core.particleShuriKen.module.GradientColor");
            var t = i.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, this._constant.cloneTo(e._constant), this._constantMin.cloneTo(e._constantMin),
                    this._constantMax.cloneTo(e._constantMax), this._gradient.cloneTo(e._gradient),
                    this._gradientMin.cloneTo(e._gradientMin), this._gradientMax.cloneTo(e._gradientMax);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "gradient", function() {
                return this._gradient;
            }), u(0, t, "constant", function() {
                return this._constant;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "gradientMin", function() {
                return this._gradientMin;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "gradientMax", function() {
                return this._gradientMax;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), i.createByConstant = function(t) {
                var e = new i();
                return e._type = 0, e._constant = t, e;
            }, i.createByGradient = function(t) {
                var e = new i();
                return e._type = 1, e._gradient = t, e;
            }, i.createByRandomTwoConstant = function(t, e) {
                var n = new i();
                return n._type = 2, n._constantMin = t, n._constantMax = e, n;
            }, i.createByRandomTwoGradient = function(t, e) {
                var n = new i();
                return n._type = 3, n._gradientMin = t, n._gradientMax = e, n;
            }, i;
        }(),
        tt = (function() {
            function t(t, e) {
                this._width = 0, this._height = 0, this._width = t, this._height = e;
            }
            d(t, "laya.d3.utils.Size");
            var e = t.prototype;
            u(0, e, "width", function() {
                return -1 === this._width ? j.clientWidth : this._width;
            }), u(0, e, "height", function() {
                return -1 === this._height ? j.clientHeight : this._height;
            }), u(1, t, "fullScreen", function() {
                return new t(-1, -1);
            });
        }(), function() {
            function t() {
                this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
            }
            return d(t, "laya.d3.physics.PhysicsSettings"), t;
        }()),
        et = function() {
            function T(t, e) {
                this.normal = null, this.distance = NaN, void 0 === e && (e = 0), this.normal = t,
                    this.distance = e;
            }
            return d(T, "laya.d3.math.Plane"), T.prototype.normalize = function() {
                    var t = this.normal.x,
                        e = this.normal.y,
                        n = this.normal.z,
                        i = 1 / Math.sqrt(t * t + e * e + n * n);
                    this.normal.x = t * i, this.normal.y = e * i, this.normal.z = n * i, this.distance *= i;
                }, T.createPlaneBy3P = function(t, e, n) {
                    var i = e.x - t.x,
                        r = e.y - t.y,
                        a = e.z - t.z,
                        o = n.x - t.x,
                        s = n.y - t.y,
                        l = n.z - t.z,
                        h = r * l - a * s,
                        u = a * o - i * l,
                        c = i * s - r * o,
                        _ = 1 / Math.sqrt(h * h + u * u + c * c),
                        d = h * _,
                        f = u * _,
                        m = c * _;
                    T._TEMPVec3.x = d, T._TEMPVec3.y = f, T._TEMPVec3.z = m;
                    var p = -(d * t.x + f * t.y + m * t.z);
                    return new T(T._TEMPVec3, p);
                }, T.PlaneIntersectionType_Back = 0, T.PlaneIntersectionType_Front = 1, T.PlaneIntersectionType_Intersecting = 2,
                _(T, ["_TEMPVec3", function() {
                    return this._TEMPVec3 = new Ct();
                }]), T;
        }(),
        nt = function() {
            function t() {
                this.ambientColor = null, this.diffuseColor = null, this.specularColor = null;
            }
            return d(t, "laya.d3.terrain.unit.MaterialInfo"), t;
        }(),
        it = function() {
            function e(t, e) {
                this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0,
                    this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null,
                    this._rgbElements = null, this._maxColorRGBKeysCount = t, this._maxColorAlphaKeysCount = e,
                    this._rgbElements = new Float32Array(4 * t), this._alphaElements = new Float32Array(2 * e);
            }
            d(e, "laya.d3.core.Gradient");
            var t = e.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.addColorRGB = function(t, e) {
                if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                    var n = 4 * this._colorRGBKeysCount;
                    this._rgbElements[n] = t, this._rgbElements[n + 1] = e.r, this._rgbElements[n + 2] = e.g,
                        this._rgbElements[n + 3] = e.b, this._colorRGBKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
            }, t.addColorAlpha = function(t, e) {
                if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                    var n = 2 * this._colorAlphaKeysCount;
                    this._alphaElements[n] = t, this._alphaElements[n + 1] = e, this._colorAlphaKeysCount++;
                } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
            }, t.updateColorRGB = function(t, e, n) {
                if (t < this._colorRGBKeysCount) {
                    var i = 4 * t;
                    this._rgbElements[i] = e, this._rgbElements[i + 1] = n.r, this._rgbElements[i + 2] = n.g,
                        this._rgbElements[i + 3] = n.b;
                } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }, t.updateColorAlpha = function(t, e, n) {
                if (t < this._colorAlphaKeysCount) {
                    var i = 2 * t;
                    this._alphaElements[i] = e, this._alphaElements[i + 1] = n;
                } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }, t.cloneTo = function(t) {
                var e = t,
                    n = 0,
                    i = 0;
                e._colorAlphaKeysCount = this._colorAlphaKeysCount;
                var r = e._alphaElements;
                for (r.length = this._alphaElements.length, n = 0, i = this._alphaElements.length; n < i; n++) r[n] = this._alphaElements[n];
                e._colorRGBKeysCount = this._colorRGBKeysCount;
                var a = e._rgbElements;
                for (a.length = this._rgbElements.length, n = 0, i = this._rgbElements.length; n < i; n++) a[n] = this._rgbElements[n];
            }, t.clone = function() {
                var t = new e(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
                return this.cloneTo(t), t;
            }, u(0, t, "colorRGBKeysCount", function() {
                return this._colorRGBKeysCount / 4;
            }), u(0, t, "mode", function() {
                return this._mode;
            }, function(t) {
                this._mode = t;
            }), u(0, t, "colorAlphaKeysCount", function() {
                return this._colorAlphaKeysCount / 2;
            }), u(0, t, "maxColorRGBKeysCount", function() {
                return this._maxColorRGBKeysCount;
            }), u(0, t, "maxColorAlphaKeysCount", function() {
                return this._maxColorAlphaKeysCount;
            }), e;
        }(),
        rt = function() {
            function a(t, e, n, i, r) {
                void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 1),
                    this.x = t, this.y = e, this.z = n, this.w = i;
            }
            d(a, "laya.d3.math.Quaternion");
            var t = a.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.scaling = function(t, e) {
                e.x = this.x * t, e.y = this.y * t, e.z = this.z * t, e.w = this.w * t;
            }, t.normalize = function(t) {
                var e = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                0 < e && (e = 1 / Math.sqrt(e), t.x = this.x * e, t.y = this.y * e, t.z = this.z * e,
                    t.w = this.w * e);
            }, t.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }, t.rotateX = function(t, e) {
                t *= .5;
                var n = Math.sin(t),
                    i = Math.cos(t);
                e.x = this.x * i + this.w * n, e.y = this.y * i + this.z * n, e.z = this.z * i - this.y * n,
                    e.w = this.w * i - this.x * n;
            }, t.rotateY = function(t, e) {
                t *= .5;
                var n = Math.sin(t),
                    i = Math.cos(t);
                e.x = this.x * i - this.z * n, e.y = this.y * i + this.w * n, e.z = this.z * i + this.x * n,
                    e.w = this.w * i - this.y * n;
            }, t.rotateZ = function(t, e) {
                t *= .5;
                var n = Math.sin(t),
                    i = Math.cos(t);
                e.x = this.x * i + this.y * n, e.y = this.y * i - this.x * n, e.z = this.z * i + this.w * n,
                    e.w = this.w * i - this.z * n;
            }, t.getYawPitchRoll = function(t) {
                Ct.transformQuat(Ct._ForwardRH, this, a.TEMPVector31), Ct.transformQuat(Ct._Up, this, a.TEMPVector32);
                var e = a.TEMPVector32;
                a.angleTo(Ct._ZERO, a.TEMPVector31, a.TEMPVector33);
                var n = a.TEMPVector33;
                n.x == Math.PI / 2 ? (n.y = a.arcTanAngle(e.z, e.x), n.z = 0) : n.x == -Math.PI / 2 ? (n.y = a.arcTanAngle(-e.z, -e.x),
                        n.z = 0) : (be.createRotationY(-n.y, a.TEMPMatrix0), be.createRotationX(-n.x, a.TEMPMatrix1),
                        Ct.transformCoordinate(a.TEMPVector32, a.TEMPMatrix0, a.TEMPVector32), Ct.transformCoordinate(a.TEMPVector32, a.TEMPMatrix1, a.TEMPVector32),
                        n.z = a.arcTanAngle(e.y, -e.x)), n.y <= -Math.PI && (n.y = Math.PI), n.z <= -Math.PI && (n.z = Math.PI),
                    n.y >= Math.PI && n.z >= Math.PI && (n.y = 0, n.z = 0, n.x = Math.PI - n.x);
                var i = t;
                i.x = n.y, i.y = n.x, i.z = n.z;
            }, t.invert = function(t) {
                var e = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    a = e * e + n * n + i * i + r * r,
                    o = a ? 1 / a : 0;
                t.x = -e * o, t.y = -n * o, t.z = -i * o, t.w = r * o;
            }, t.identity = function() {
                this.x = 0, this.y = 0, this.z = 0, this.w = 1;
            }, t.fromArray = function(t, e) {
                void 0 === e && (e = 0), this.x = t[e + 0], this.y = t[e + 1], this.z = t[e + 2],
                    this.w = t[e + 3];
            }, t.cloneTo = function(t) {
                this !== t && (t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t.equals = function(t) {
                return $.nearEqual(this.x, t.x) && $.nearEqual(this.y, t.y) && $.nearEqual(this.z, t.z) && $.nearEqual(this.w, t.w);
            }, t.lengthSquared = function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }, t.forNativeElement = function(t) {
                t ? (this.elements = t, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    Lt.rewriteNumProperty(this, "x", 0), Lt.rewriteNumProperty(this, "y", 1), Lt.rewriteNumProperty(this, "z", 2),
                    Lt.rewriteNumProperty(this, "w", 3);
            }, a.createFromYawPitchRoll = function(t, e, n, i) {
                var r = .5 * n,
                    a = .5 * e,
                    o = .5 * t,
                    s = Math.sin(r),
                    l = Math.cos(r),
                    h = Math.sin(a),
                    u = Math.cos(a),
                    c = Math.sin(o),
                    _ = Math.cos(o);
                i.x = _ * h * l + c * u * s, i.y = c * u * l - _ * h * s, i.z = _ * u * s - c * h * l,
                    i.w = _ * u * l + c * h * s;
            }, a.multiply = function(t, e, n) {
                var i = t.x,
                    r = t.y,
                    a = t.z,
                    o = t.w,
                    s = e.x,
                    l = e.y,
                    h = e.z,
                    u = e.w,
                    c = r * h - a * l,
                    _ = a * s - i * h,
                    d = i * l - r * s,
                    f = i * s + r * l + a * h;
                n.x = i * u + s * o + c, n.y = r * u + l * o + _, n.z = a * u + h * o + d, n.w = o * u - f;
            }, a.arcTanAngle = function(t, e) {
                return 0 == t ? 1 == e ? Math.PI / 2 : -Math.PI / 2 : 0 < t ? Math.atan(e / t) : t < 0 ? 0 < e ? Math.atan(e / t) + Math.PI : Math.atan(e / t) - Math.PI : 0;
            }, a.angleTo = function(t, e, n) {
                Ct.subtract(e, t, a.TEMPVector30), Ct.normalize(a.TEMPVector30, a.TEMPVector30),
                    n.x = Math.asin(a.TEMPVector30.y), n.y = a.arcTanAngle(-a.TEMPVector30.z, -a.TEMPVector30.x);
            }, a.createFromAxisAngle = function(t, e, n) {
                e *= .5;
                var i = Math.sin(e);
                n.x = i * t.x, n.y = i * t.y, n.z = i * t.z, n.w = Math.cos(e);
            }, a.createFromMatrix4x4 = function(t, e) {
                var n, i, r = t.elements,
                    a = r[0] + r[5] + r[10];
                0 < a ? (n = Math.sqrt(a + 1), e.w = .5 * n, n = .5 / n, e.x = (r[6] - r[9]) * n,
                    e.y = (r[8] - r[2]) * n, e.z = (r[1] - r[4]) * n) : r[0] >= r[5] && r[0] >= r[10] ? (i = .5 / (n = Math.sqrt(1 + r[0] - r[5] - r[10])),
                    e.x = .5 * n, e.y = (r[1] + r[4]) * i, e.z = (r[2] + r[8]) * i, e.w = (r[6] - r[9]) * i) : r[5] > r[10] ? (i = .5 / (n = Math.sqrt(1 + r[5] - r[0] - r[10])),
                    e.x = (r[4] + r[1]) * i, e.y = .5 * n, e.z = (r[9] + r[6]) * i, e.w = (r[8] - r[2]) * i) : (i = .5 / (n = Math.sqrt(1 + r[10] - r[0] - r[5])),
                    e.x = (r[8] + r[2]) * i, e.y = (r[9] + r[6]) * i, e.z = .5 * n, e.w = (r[1] - r[4]) * i);
            }, a.slerp = function(t, e, n, i) {
                var r, a, o, s, l, h = t.x,
                    u = t.y,
                    c = t.z,
                    _ = t.w,
                    d = e.x,
                    f = e.y,
                    m = e.z,
                    p = e.w;
                return (a = h * d + u * f + c * m + _ * p) < 0 && (a = -a, d = -d, f = -f, m = -m,
                        p = -p), l = 1e-6 < 1 - a ? (r = Math.acos(a), o = Math.sin(r), s = Math.sin((1 - n) * r) / o,
                        Math.sin(n * r) / o) : (s = 1 - n, n), i.x = s * h + l * d, i.y = s * u + l * f,
                    i.z = s * c + l * m, i.w = s * _ + l * p, i;
            }, a.lerp = function(t, e, n, i) {
                var r = 1 - n;
                0 <= a.dot(t, e) ? (i.x = r * t.x + n * e.x, i.y = r * t.y + n * e.y, i.z = r * t.z + n * e.z,
                    i.w = r * t.w + n * e.w) : (i.x = r * t.x - n * e.x, i.y = r * t.y - n * e.y, i.z = r * t.z - n * e.z,
                    i.w = r * t.w - n * e.w), i.normalize(i);
            }, a.add = function(t, e, n) {
                n.x = t.x + e.x, n.y = t.y + e.y, n.z = t.z + e.z, n.w = t.w + e.w;
            }, a.dot = function(t, e) {
                return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w;
            }, a.rotationLookAt = function(t, e, n) {
                a.lookAt(Ct._ZERO, t, e, n);
            }, a.lookAt = function(t, e, n, i) {
                Ne.lookAt(t, e, n, a._tempMatrix3x3), a.rotationMatrix(a._tempMatrix3x3, i);
            }, a.invert = function(t, e) {
                var n = t.lengthSquared();
                $.isZero(n) || (n = 1 / n, e.x = -t.x * n, e.y = -t.y * n, e.z = -t.z * n, e.w = t.w * n);
            }, a.rotationMatrix = function(t, e) {
                var n = t.elements,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    h = n[6],
                    u = n[7],
                    c = n[8],
                    _ = NaN,
                    d = NaN,
                    f = i + s + c;
                0 < f ? (_ = Math.sqrt(f + 1), e.w = .5 * _, _ = .5 / _, e.x = (l - u) * _, e.y = (h - a) * _,
                    e.z = (r - o) * _) : e.w = s <= i && c <= i ? (d = .5 / (_ = Math.sqrt(1 + i - s - c)),
                    e.x = .5 * _, e.y = (r + o) * d, e.z = (a + h) * d, (l - u) * d) : c < s ? (d = .5 / (_ = Math.sqrt(1 + s - i - c)),
                    e.x = (o + r) * d, e.y = .5 * _, e.z = (u + l) * d, (h - a) * d) : (d = .5 / (_ = Math.sqrt(1 + c - i - s)),
                    e.x = (h + a) * d, e.y = (u + l) * d, e.z = .5 * _, (r - o) * d);
            }, a.DEFAULT = new a(), _(a, ["TEMPVector30", function() {
                return this.TEMPVector30 = new Ct();
            }, "TEMPVector31", function() {
                return this.TEMPVector31 = new Ct();
            }, "TEMPVector32", function() {
                return this.TEMPVector32 = new Ct();
            }, "TEMPVector33", function() {
                return this.TEMPVector33 = new Ct();
            }, "TEMPMatrix0", function() {
                return this.TEMPMatrix0 = new be();
            }, "TEMPMatrix1", function() {
                return this.TEMPMatrix1 = new be();
            }, "_tempMatrix3x3", function() {
                return this._tempMatrix3x3 = new Ne();
            }, "NAN", function() {
                return this.NAN = new a(NaN, NaN, NaN, NaN);
            }]), a;
        }(),
        at = function() {
            function i(t) {
                this._runtimeCopyValues = [], this._ownerResource = t, this._initData();
            }
            d(i, "laya.d3.shader.ShaderData");
            var t = i.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.getData = function() {
                return this._data;
            }, t._initData = function() {
                this._data = new Object();
            }, t.getBool = function(t) {
                return this._data[t];
            }, t.setBool = function(t, e) {
                this._data[t] = e;
            }, t.getInt = function(t) {
                return this._data[t];
            }, t.setInt = function(t, e) {
                this._data[t] = e;
            }, t.getNumber = function(t) {
                return this._data[t];
            }, t.setNumber = function(t, e) {
                this._data[t] = e;
            }, t.getVector2 = function(t) {
                return this._data[t];
            }, t.setVector2 = function(t, e) {
                this._data[t] = e;
            }, t.getVector3 = function(t) {
                return this._data[t];
            }, t.setVector3 = function(t, e) {
                this._data[t] = e;
            }, t.getVector = function(t) {
                return this._data[t];
            }, t.setVector = function(t, e) {
                this._data[t] = e;
            }, t.getQuaternion = function(t) {
                return this._data[t];
            }, t.setQuaternion = function(t, e) {
                this._data[t] = e;
            }, t.getMatrix4x4 = function(t) {
                return this._data[t];
            }, t.setMatrix4x4 = function(t, e) {
                this._data[t] = e;
            }, t.getBuffer = function(t) {
                return this._data[t];
            }, t.setBuffer = function(t, e) {
                this._data[t] = e;
            }, t.setTexture = function(t, e) {
                var n = this._data[t];
                this._data[t] = e, this._ownerResource && 0 < this._ownerResource.referenceCount && (n && n._removeReference(),
                    e && e._addReference());
            }, t.getTexture = function(t) {
                return this._data[t];
            }, t.setAttribute = function(t, e) {
                this._data[t] = e;
            }, t.getAttribute = function(t) {
                return this._data[t];
            }, t.getLength = function() {
                return this._data.length;
            }, t.setLength = function(t) {
                this._data.length = t;
            }, t.cloneTo = function(t) {
                var e = t._data;
                for (var n in this._data) {
                    var i = this._data[n];
                    if (null != i)
                        if ("number" == typeof i) e[n] = i;
                        else if ("number" == typeof i && Math.floor(i) == i) e[n] = i;
                    else if ("boolean" == typeof i) e[n] = i;
                    else if (i instanceof laya.d3.math.Vector2) {
                        var r = e[n] || (e[n] = new Lt());
                        i.cloneTo(r), e[n] = r;
                    } else if (i instanceof laya.d3.math.Vector3) {
                        var a = e[n] || (e[n] = new Ct());
                        i.cloneTo(a), e[n] = a;
                    } else if (i instanceof laya.d3.math.Vector4) {
                        var o = e[n] || (e[n] = new At());
                        i.cloneTo(o), e[n] = o;
                    } else if (i instanceof laya.d3.math.Matrix4x4) {
                        var s = e[n] || (e[n] = new be());
                        i.cloneTo(s), e[n] = s;
                    } else i instanceof laya.webgl.resource.BaseTexture && (e[n] = i);
                }
            }, t.cloneToForNative = function(t) {
                var e = t;
                0 < this._int32Data.length - e._int32Data.length && e.needRenewArrayBufferForNative(this._int32Data.length),
                    e._int32Data.set(this._int32Data, 0);
                var n = e._nativeArray,
                    i = this._nativeArray.length;
                n.length = i;
                for (var r = 0; r < i; r++) {
                    var a = this._nativeArray[r];
                    if (a)
                        if ("number" == typeof a) n[r] = a, e.setNumber(r, a);
                        else if ("number" == typeof a && Math.floor(a) == a) n[r] = a,
                        e.setInt(r, a);
                    else if ("boolean" == typeof a) n[r] = a, e.setBool(r, a);
                    else if (a instanceof laya.d3.math.Vector2) {
                        var o = n[r] || (n[r] = new Lt());
                        a.cloneTo(o), n[r] = o, e.setVector2(r, o);
                    } else if (a instanceof laya.d3.math.Vector3) {
                        var s = n[r] || (n[r] = new Ct());
                        a.cloneTo(s), n[r] = s, e.setVector3(r, s);
                    } else if (a instanceof laya.d3.math.Vector4) {
                        var l = n[r] || (n[r] = new At());
                        a.cloneTo(l), n[r] = l, e.setVector(r, l);
                    } else if (a instanceof laya.d3.math.Matrix4x4) {
                        var h = n[r] || (n[r] = new be());
                        a.cloneTo(h), n[r] = h, e.setMatrix4x4(r, h);
                    } else a instanceof laya.webgl.resource.BaseTexture && (n[r] = a, e.setTexture(r, a));
                }
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t._initDataForNative = function() {
                this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [],
                    this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data),
                    this._float32Data = new Float32Array(this._data), E.createArrayBufferRef(this._data, 0, !0);
            }, t.needRenewArrayBufferForNative = function(t) {
                if (t >= this._int32Data.length) {
                    var e = 4 * (t + 1),
                        n = this._int32Data,
                        i = this._data.conchRef,
                        r = this._data._ptrID;
                    this._data = new ArrayBuffer(e), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data),
                        this._data.conchRef = i, this._data._ptrID = r, n && this._int32Data.set(n, 0),
                        conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
                }
            }, t.getDataForNative = function() {
                return this._nativeArray;
            }, t.getIntForNative = function(t) {
                return this._int32Data[t];
            }, t.setIntForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), this._int32Data[t] = e, this._nativeArray[t] = e;
            }, t.getBoolForNative = function(t) {
                return 1 == this._int32Data[t];
            }, t.setBoolForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), this._int32Data[t] = e, this._nativeArray[t] = e;
            }, t.getNumberForNative = function(t) {
                return this._float32Data[t];
            }, t.setNumberForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), this._float32Data[t] = e, this._nativeArray[t] = e;
            }, t.getMatrix4x4ForNative = function(t) {
                return this._nativeArray[t];
            }, t.setMatrix4x4ForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), this._nativeArray[t] = e;
                var n = this.setReferenceForNative(e.elements);
                this._int32Data[t] = n;
            }, t.getVectorForNative = function(t) {
                return this._nativeArray[t];
            }, t.setVectorForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), (this._nativeArray[t] = e).elements || e.forNativeElement();
                var n = this.setReferenceForNative(e.elements);
                this._int32Data[t] = n;
            }, t.getVector2ForNative = function(t) {
                return this._nativeArray[t];
            }, t.setVector2ForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), (this._nativeArray[t] = e).elements || e.forNativeElement();
                var n = this.setReferenceForNative(e.elements);
                this._int32Data[t] = n;
            }, t.getVector3ForNative = function(t) {
                return this._nativeArray[t];
            }, t.setVector3ForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), (this._nativeArray[t] = e).elements || e.forNativeElement();
                var n = this.setReferenceForNative(e.elements);
                this._int32Data[t] = n;
            }, t.getQuaternionForNative = function(t) {
                return this._nativeArray[t];
            }, t.setQuaternionForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), (this._nativeArray[t] = e).elements || e.forNativeElement();
                var n = this.setReferenceForNative(e.elements);
                this._int32Data[t] = n;
            }, t.getBufferForNative = function(t) {
                return this._nativeArray[t];
            }, t.setBufferForNative = function(t, e) {
                this.needRenewArrayBufferForNative(t), this._nativeArray[t] = e;
                var n = this.setReferenceForNative(e);
                this._int32Data[t] = n;
            }, t.getAttributeForNative = function(t) {
                return this._nativeArray[t];
            }, t.setAttributeForNative = function(t, e) {
                (this._nativeArray[t] = e)._ptrID || E.createArrayBufferRef(e, 0, !0), E.syncBufferToRenderThread(e),
                    this._int32Data[t] = e._ptrID;
            }, t.getTextureForNative = function(t) {
                return this._nativeArray[t];
            }, t.setTextureForNative = function(t, e) {
                if (e)
                    if (e._getSource()) {
                        this.needRenewArrayBufferForNative(t), this._nativeArray[t] = e;
                        var n = this._nativeArray[t];
                        this._int32Data[t] = e._getSource().id, this._ownerResource && 0 < this._ownerResource.referenceCount && (n && n._removeReference(),
                            e && e._addReference());
                    } else m.systemTimer.callLater(this, this.setTextureForNative, [t, e]);
            }, t.setReferenceForNative = function(t) {
                this.clearRuntimeCopyArray();
                var e = 0,
                    n = 0;
                return i._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (E.createArrayBufferRefs(t, 0, !0, 0),
                    e = 0, n = t.getPtrID(e)) : (E.createArrayBufferRefs(t, 0, !0, 1), e = t.getRefNum() - 1,
                    n = t.getPtrID(e), this._runtimeCopyValues.push({
                        obj: t,
                        refID: e,
                        ptrID: n
                    })), E.syncBufferToRenderThread(t, e), n;
            }, t.clearRuntimeCopyArray = function() {
                var t = E.getFrameCount();
                if (this._frameCount != t) {
                    this._frameCount = t;
                    for (var e = 0, n = this._runtimeCopyValues.length; e < n; e++) {
                        this._runtimeCopyValues[e].obj.clearRefNum();
                    }
                    this._runtimeCopyValues.length = 0;
                }
            }, i.setRuntimeValueMode = function(t) {
                i._SET_RUNTIME_VALUE_MODE_REFERENCE_ = t;
            }, i._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0, i;
        }(),
        ot = function() {
            function y() {
                this._boundingSphere = null, this._boundingBox = null, this._sizeOfY = null, this._currentLODLevel = 0,
                    this._lastDistanceToEye = NaN, this._originalBoundingSphere = null, this._originalBoundingBox = null,
                    this._originalBoundingBoxCorners = null, this._bUseStrip = !1, this._gridSize = NaN,
                    this._beginGridX = 0, this._beginGridZ = 0, this._LODError = null, y.__init__(),
                    this._currentLODLevel = 0;
            }
            d(y, "laya.d3.terrain.TerrainLeaf");
            var t = y.prototype;
            return t.calcVertextNorml = function(t, e, n, i, r, a) {
                    var o = 0,
                        s = 0;
                    s = -1 * y.getHeightFromTerrainHeightData(t - 1, e - 1, n, i, r), s += -1 * y.getHeightFromTerrainHeightData(t - 1, e, n, i, r),
                        s += -1 * y.getHeightFromTerrainHeightData(t - 1, e + 1, n, i, r), s += 1 * y.getHeightFromTerrainHeightData(t + 1, e - 1, n, i, r),
                        s += 1 * y.getHeightFromTerrainHeightData(t + 1, e, n, i, r), s += 1 * y.getHeightFromTerrainHeightData(t + 1, e + 1, n, i, r),
                        o = -1 * y.getHeightFromTerrainHeightData(t - 1, e - 1, n, i, r), o += -1 * y.getHeightFromTerrainHeightData(t, e - 1, n, i, r),
                        o += -1 * y.getHeightFromTerrainHeightData(t + 1, e - 1, n, i, r), o += 1 * y.getHeightFromTerrainHeightData(t - 1, e + 1, n, i, r),
                        o += 1 * y.getHeightFromTerrainHeightData(t, e + 1, n, i, r), o += 1 * y.getHeightFromTerrainHeightData(t + 1, e + 1, n, i, r),
                        a.x = -s, a.y = 6, a.z = -o, Ct.normalize(a, a);
                }, t.calcVertextNormlUV = function(t, e, n, i, r) {
                    r.x = t / n, r.y = e / i, r.z = e / i;
                }, t.calcVertextBuffer = function(t, e, n, i, r, a, o, s, l, h, u, c) {
                    if (1 == c && !y.__ADAPT_MATRIX__) {
                        y.__ADAPT_MATRIX__ = new be();
                        var _ = new be();
                        be.createRotationY(Math.PI, y.__ADAPT_MATRIX__), be.createTranslate(new Ct(0, 0, (u - 1) * r), _),
                            be.multiply(_, y.__ADAPT_MATRIX__, y.__ADAPT_MATRIX__), y.__ADAPT_MATRIX_INV__ = new be(),
                            y.__ADAPT_MATRIX__.invert(y.__ADAPT_MATRIX_INV__);
                    }
                    this._gridSize = r, this._beginGridX = t * y.CHUNK_GRID_NUM + n, this._beginGridZ = e * y.CHUNK_GRID_NUM + i;
                    for (var d = o * s, f = 2147483647, m = -2147483648, p = new Ct(), T = 0, E = y.LEAF_GRID_NUM + 1; T < E; T++)
                        for (var v = 0, g = y.LEAF_GRID_NUM + 1; v < g; v++) y.__VECTOR3__.x = (this._beginGridX + v) * this._gridSize,
                            y.__VECTOR3__.z = (this._beginGridZ + T) * this._gridSize, y.__VECTOR3__.y = l[(this._beginGridZ + T) * h + (this._beginGridX + v)],
                            f = y.__VECTOR3__.y < f ? y.__VECTOR3__.y : f, m = y.__VECTOR3__.y > m ? y.__VECTOR3__.y : m,
                            y.__ADAPT_MATRIX__ && Ct.transformV3ToV3(y.__VECTOR3__, y.__ADAPT_MATRIX__, y.__VECTOR3__),
                            a[d] = y.__VECTOR3__.x, a[++d] = y.__VECTOR3__.y, a[++d] = y.__VECTOR3__.z, d++,
                            this.calcVertextNormlUV(this._beginGridX + v, this._beginGridZ + T, h, u, p), a[d] = p.x,
                            a[++d] = p.y, a[++d] = p.z, a[++d] = (n + v) / y.CHUNK_GRID_NUM, a[++d] = (i + T) / y.CHUNK_GRID_NUM,
                            a[++d] = this._beginGridX + v, a[++d] = this._beginGridZ + T, d++;
                    this._sizeOfY = new Lt(f - 1, m + 1), this.calcLODErrors(l, h, u), this.calcOriginalBoudingBoxAndSphere();
                }, t.calcSkirtVertextBuffer = function(t, e, n, i, r, a, o, s, l, h, u) {
                    this._gridSize = r, this._beginGridX = t * y.CHUNK_GRID_NUM + n, this._beginGridZ = e * y.CHUNK_GRID_NUM + i;
                    var c = o * s,
                        _ = 0,
                        d = 0,
                        f = y.LEAF_GRID_NUM + 1,
                        m = new Ct(),
                        p = 0,
                        T = 0;
                    for (_ = 0; _ < 2; _++)
                        for (d = 0; d < f; d++) y.__VECTOR3__.x = (this._beginGridX + d) * this._gridSize,
                            y.__VECTOR3__.y = 1 == _ ? l[this._beginGridZ * h + (this._beginGridX + d)] : -this._gridSize,
                            y.__VECTOR3__.z = (this._beginGridZ + 0) * this._gridSize, y.__ADAPT_MATRIX__ && Ct.transformV3ToV3(y.__VECTOR3__, y.__ADAPT_MATRIX__, y.__VECTOR3__),
                            a[c] = y.__VECTOR3__.x, a[++c] = y.__VECTOR3__.y, a[++c] = y.__VECTOR3__.z, c++,
                            p = 0 == _ ? this._beginGridZ - 1 : this._beginGridZ, this.calcVertextNormlUV(this._beginGridX + d, p, h, u, m),
                            a[c] = m.x, a[++c] = m.y, a[++c] = m.z, a[++c] = (n + d) / y.CHUNK_GRID_NUM, a[++c] = (i + 0) / y.CHUNK_GRID_NUM,
                            a[++c] = this._beginGridX + d, a[++c] = p, c++;
                    for (_ = 0; _ < 2; _++)
                        for (d = 0; d < f; d++) y.__VECTOR3__.x = (this._beginGridX + d) * this._gridSize,
                            y.__VECTOR3__.y = 0 == _ ? l[(this._beginGridZ + y.LEAF_GRID_NUM) * h + (this._beginGridX + d)] : -this._gridSize,
                            y.__VECTOR3__.z = (this._beginGridZ + y.LEAF_GRID_NUM) * this._gridSize, y.__ADAPT_MATRIX__ && Ct.transformV3ToV3(y.__VECTOR3__, y.__ADAPT_MATRIX__, y.__VECTOR3__),
                            a[c] = y.__VECTOR3__.x, a[++c] = y.__VECTOR3__.y, a[++c] = y.__VECTOR3__.z, c++,
                            p = 0 == _ ? this._beginGridZ + y.LEAF_GRID_NUM : this._beginGridZ + y.LEAF_GRID_NUM + 1,
                            this.calcVertextNormlUV(this._beginGridX + d, p, h, u, m), a[c] = m.x, a[++c] = m.y,
                            a[++c] = m.z, a[++c] = (n + d) / y.CHUNK_GRID_NUM, a[++c] = (i + y.LEAF_GRID_NUM) / y.CHUNK_GRID_NUM,
                            a[++c] = this._beginGridX + d, a[++c] = p, c++;
                    for (_ = 0; _ < 2; _++)
                        for (d = 0; d < f; d++) y.__VECTOR3__.x = (this._beginGridX + 0) * this._gridSize,
                            y.__VECTOR3__.y = 0 == _ ? l[(this._beginGridZ + d) * h + (this._beginGridX + 0)] : -this._gridSize,
                            y.__VECTOR3__.z = (this._beginGridZ + d) * this._gridSize, y.__ADAPT_MATRIX__ && Ct.transformV3ToV3(y.__VECTOR3__, y.__ADAPT_MATRIX__, y.__VECTOR3__),
                            a[c] = y.__VECTOR3__.x, a[++c] = y.__VECTOR3__.y, a[++c] = y.__VECTOR3__.z, c++,
                            T = 0 == _ ? this._beginGridX : this._beginGridX - 1, this.calcVertextNormlUV(T, this._beginGridZ + d, h, u, m),
                            a[c] = m.x, a[++c] = m.y, a[++c] = m.z, a[++c] = (n + 0) / y.CHUNK_GRID_NUM, a[++c] = (i + d) / y.CHUNK_GRID_NUM,
                            a[++c] = T, a[++c] = this._beginGridZ + d, c++;
                    for (_ = 0; _ < 2; _++)
                        for (d = 0; d < f; d++) y.__VECTOR3__.x = (this._beginGridX + y.LEAF_GRID_NUM) * this._gridSize,
                            y.__VECTOR3__.y = 1 == _ ? l[(this._beginGridZ + d) * h + (this._beginGridX + y.LEAF_GRID_NUM)] : -this._gridSize,
                            y.__VECTOR3__.z = (this._beginGridZ + d) * this._gridSize, y.__ADAPT_MATRIX__ && Ct.transformV3ToV3(y.__VECTOR3__, y.__ADAPT_MATRIX__, y.__VECTOR3__),
                            a[c] = y.__VECTOR3__.x, a[++c] = y.__VECTOR3__.y, a[++c] = y.__VECTOR3__.z, c++,
                            T = 0 == _ ? this._beginGridX + y.LEAF_GRID_NUM + 1 : this._beginGridX + y.LEAF_GRID_NUM,
                            this.calcVertextNormlUV(T, this._beginGridZ + d, h, u, m), a[c] = m.x, a[++c] = m.y,
                            a[++c] = m.z, a[++c] = (n + y.LEAF_GRID_NUM) / y.CHUNK_GRID_NUM, a[++c] = (i + d) / y.CHUNK_GRID_NUM,
                            a[++c] = T, a[++c] = this._beginGridZ + d, c++;
                }, t.calcOriginalBoudingBoxAndSphere = function() {
                    var t = new Ct(this._beginGridX * this._gridSize, this._sizeOfY.x, this._beginGridZ * this._gridSize),
                        e = new Ct((this._beginGridX + y.LEAF_GRID_NUM) * this._gridSize, this._sizeOfY.y, (this._beginGridZ + y.LEAF_GRID_NUM) * this._gridSize);
                    y.__ADAPT_MATRIX__ && (Ct.transformV3ToV3(t, y.__ADAPT_MATRIX__, t), Ct.transformV3ToV3(e, y.__ADAPT_MATRIX__, e)),
                        this._originalBoundingBox = new we(t, e);
                    var n = new Ct();
                    Ct.subtract(e, t, n), Ct.scale(n, .5, n);
                    var i = new Ct();
                    Ct.add(t, n, i), this._originalBoundingSphere = new Tt(i, Ct.scalarLength(n)), this._originalBoundingBoxCorners = P(8, null),
                        this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners), this._boundingBox = new we(new Ct(-.5, -.5, -.5), new Ct(.5, .5, .5)),
                        this._boundingSphere = new Tt(new Ct(0, 0, 0), 1);
                }, t.calcLeafBoudingBox = function(t) {
                    for (var e = 0; e < 8; e++) Ct.transformCoordinate(this._originalBoundingBoxCorners[e], t, Ue._tempBoundBoxCorners[e]);
                    we.createfromPoints(Ue._tempBoundBoxCorners, this._boundingBox);
                }, t.calcLeafBoudingSphere = function(t, e) {
                    Ct.transformCoordinate(this._originalBoundingSphere.center, t, this._boundingSphere.center),
                        this._boundingSphere.radius = this._originalBoundingSphere.radius * e;
                }, t.calcLODErrors = function(t, e, n) {
                    this._LODError = new Float32Array(y._maxLODLevel + 1);
                    for (var i = 1, r = 0, a = y._maxLODLevel + 1; r < a; r++) {
                        for (var o = 0, s = 0, l = y.LEAF_GRID_NUM; s < l; s += i)
                            for (var h = 0, u = y.LEAF_GRID_NUM; h < u; h += i)
                                for (var c = t[(this._beginGridZ + s) * e + (this._beginGridX + h)], _ = t[(this._beginGridZ + s) * e + (this._beginGridX + h) + i], d = t[(this._beginGridZ + s + i) * e + (this._beginGridX + h)], f = t[(this._beginGridZ + s + i) * e + (this._beginGridX + h) + i], m = 0; m < i; m++)
                                    for (var p = m / i, T = 0; T < i; T++) {
                                        var E = T / i,
                                            v = t[(this._beginGridZ + s + m) * e + (this._beginGridX + h) + T],
                                            g = E + p <= 1 ? c + (_ - c) * E + (d - c) * p : f + (d - f) * (1 - E) + (_ - f) * (1 - p),
                                            S = Math.abs(g - v);
                                        o = Math.max(o, S);
                                    }
                        i *= 2, this._LODError[r] = o;
                    }
                }, t.determineLod = function(t, e, n, i) {
                    var r = Ct.distance(t, this._boundingSphere.center),
                        a = y._maxLODLevel;
                    if (!i) {
                        if (this._lastDistanceToEye == r) return this._currentLODLevel;
                        this._lastDistanceToEye > r && (a = this._currentLODLevel);
                    }
                    for (var o = a; 1 <= o; o--)
                        if (Xn.LOD_DISTANCE_FACTOR * this._LODError[o] / r * e < n) {
                            this._currentLODLevel = o;
                            break;
                        }
                    return this._lastDistanceToEye = r, this._currentLODLevel;
                }, y.__init__ = function() {
                    if (!y._bInit) {
                        var t = y.CHUNK_GRID_NUM / y.LEAF_GRID_NUM * (y.CHUNK_GRID_NUM / y.LEAF_GRID_NUM);
                        y._planeLODIndex = P(t);
                        var e = 0,
                            n = 0,
                            i = 0,
                            r = 0,
                            a = 0,
                            o = 0,
                            s = null,
                            l = null;
                        for (e = 0; e < t; e++) y._planeLODIndex[e] = new Array(y._maxLODLevel + 1);
                        for (e = 0, r = y._maxLODLevel + 1; e < r; e++) y._planeLODIndex[0][e] = y.calcPlaneLODIndex(e);
                        for (e = 1; e < t; e++)
                            for (o = e * y.LEAF_PLANE_VERTEXT_COUNT, n = 0, a = y._maxLODLevel + 1; n < a; n++) {
                                for (s = y._planeLODIndex[0][n], l = new Uint16Array(s.length), i = 0; i < s.length; i++) l[i] = s[i] + o;
                                y._planeLODIndex[e][n] = l;
                            }
                        for (y._skirtLODIndex = P(t), e = 0; e < t; e++) y._skirtLODIndex[e] = new Array(y._maxLODLevel + 1);
                        for (e = 0, r = y._maxLODLevel + 1; e < r; e++) y._skirtLODIndex[0][e] = y.calcSkirtLODIndex(e);
                        for (e = 1; e < t; e++)
                            for (o = e * y.LEAF_SKIRT_VERTEXT_COUNT, n = 0, a = y._maxLODLevel + 1; n < a; n++) {
                                for (s = y._skirtLODIndex[0][n], l = new Uint16Array(s.length), i = 0; i < s.length; i++) l[i] = s[i] + o;
                                y._skirtLODIndex[e][n] = l;
                            }
                        y._bInit = !0;
                    }
                }, y.getPlaneLODIndex = function(t, e) {
                    return y._planeLODIndex[t][e];
                }, y.getSkirtLODIndex = function(t, e) {
                    return y._skirtLODIndex[t][e];
                }, y.calcPlaneLODIndex = function(t) {
                    y._maxLODLevel < t && (t = y._maxLODLevel);
                    var e = y.LEAF_GRID_NUM + 1,
                        n = 0,
                        i = null,
                        r = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2, t);
                    i = new Uint16Array(r * r * 6);
                    for (var a = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / r, o = 0; o < y.LEAF_GRID_NUM; o += a)
                        for (var s = 0; s < y.LEAF_GRID_NUM; s += a) i[n] = (o + a) * e + s,
                            i[++n] = o * e + s, i[++n] = o * e + s + a, i[++n] = o * e + s + a, i[++n] = (o + a) * e + s + a,
                            i[++n] = (o + a) * e + s, n++;
                    return i;
                }, y.calcSkirtLODIndex = function(t) {
                    y._maxLODLevel < t && (t = y._maxLODLevel);
                    var e = y.CHUNK_GRID_NUM / y.LEAF_GRID_NUM * (y.CHUNK_GRID_NUM / y.LEAF_GRID_NUM) * y.LEAF_PLANE_VERTEXT_COUNT,
                        n = y.LEAF_GRID_NUM + 1,
                        i = 0,
                        r = null,
                        a = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2, t);
                    r = new Uint16Array(4 * a * 6);
                    for (var o = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / a, s = 0; s < 4; s++) {
                        for (var l = 0; l < y.LEAF_GRID_NUM; l += o) r[i] = e + n + l, r[++i] = e + l, r[++i] = e + l + o,
                            r[++i] = e + l + o, r[++i] = e + n + l + o, r[++i] = e + n + l, i++;
                        e += 2 * n;
                    }
                    return r;
                }, y.getHeightFromTerrainHeightData = function(t, e, n, i, r) {
                    return n[(e = r <= (e = e < 0 ? 0 : e) ? r - 1 : e) * i + (t = i <= (t = t < 0 ? 0 : t) ? i - 1 : t)];
                }, y.CHUNK_GRID_NUM = 64, y.LEAF_GRID_NUM = 32, y.__ADAPT_MATRIX__ = null, y.__ADAPT_MATRIX_INV__ = null,
                y._planeLODIndex = null, y._skirtLODIndex = null, y._bInit = !1, _(y, ["LEAF_PLANE_VERTEXT_COUNT", function() {
                    return this.LEAF_PLANE_VERTEXT_COUNT = (y.LEAF_GRID_NUM + 1) * (y.LEAF_GRID_NUM + 1);
                }, "LEAF_SKIRT_VERTEXT_COUNT", function() {
                    return this.LEAF_SKIRT_VERTEXT_COUNT = 2 * (y.LEAF_GRID_NUM + 1) * 4;
                }, "LEAF_VERTEXT_COUNT", function() {
                    return this.LEAF_VERTEXT_COUNT = y.LEAF_PLANE_VERTEXT_COUNT + y.LEAF_SKIRT_VERTEXT_COUNT;
                }, "LEAF_PLANE_MAX_INDEX_COUNT", function() {
                    return this.LEAF_PLANE_MAX_INDEX_COUNT = y.LEAF_GRID_NUM * y.LEAF_GRID_NUM * 6;
                }, "LEAF_SKIRT_MAX_INDEX_COUNT", function() {
                    return this.LEAF_SKIRT_MAX_INDEX_COUNT = 4 * y.LEAF_GRID_NUM * 6;
                }, "LEAF_MAX_INDEX_COUNT", function() {
                    return this.LEAF_MAX_INDEX_COUNT = y.LEAF_PLANE_MAX_INDEX_COUNT + y.LEAF_SKIRT_MAX_INDEX_COUNT;
                }, "__VECTOR3__", function() {
                    return this.__VECTOR3__ = new Ct();
                }, "_maxLODLevel", function() {
                    return this._maxLODLevel = Math.log2(y.LEAF_GRID_NUM);
                }]), y;
        }(),
        st = function() {
            function t() {}
            return d(t, "laya.d3.graphics.Vertex.VertexShuriKenParticle"), t.PARTICLE_CORNERTEXTURECOORDINATE0 = 0,
                t.PARTICLE_POSITION0 = 1, t.PARTICLE_COLOR0 = 2, t.PARTICLE_TEXTURECOORDINATE0 = 3,
                t.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, t.PARTICLE_DIRECTIONTIME = 5, t.PARTICLE_STARTCOLOR0 = 6,
                t.PARTICLE_ENDCOLOR0 = 7, t.PARTICLE_STARTSIZE = 8, t.PARTICLE_STARTROTATION = 9,
                t.PARTICLE_STARTSPEED = 10, t.PARTICLE_RANDOM0 = 11, t.PARTICLE_RANDOM1 = 12, t.PARTICLE_SIMULATIONWORLDPOSTION = 13,
                t.PARTICLE_SIMULATIONWORLDROTATION = 14, t;
        }(),
        Mt = function() {
            function t(t) {
                this._size = null, this.enbale = !1, this._size = t;
            }
            d(t, "laya.d3.core.particleShuriKen.module.SizeOverLifetime");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                this._size.cloneTo(e._size), e.enbale = this.enbale;
            }, e.clone = function() {
                var t;
                switch (this._size.type) {
                    case 0:
                        t = this._size.separateAxes ? fe.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : fe.createByGradient(this._size.gradient.clone());
                        break;

                    case 1:
                        t = this._size.separateAxes ? fe.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : fe.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                        break;

                    case 2:
                        t = this._size.separateAxes ? fe.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : fe.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                }
                var e = new this.constructor(t);
                return e.enbale = this.enbale, e;
            }, u(0, e, "size", function() {
                return this._size;
            }), t;
        }(),
        lt = function() {
            function t() {
                this.time = NaN;
            }
            d(t, "laya.d3.core.Keyframe");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                t.time = this.time;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t;
        }(),
        At = function() {
            function t(t, e, n, i) {
                this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, void 0 === t && (t = 0),
                    void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = t,
                    this.y = e, this.z = n, this.w = i;
            }
            d(t, "laya.d3.math.Vector4");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.setValue = function(t, e, n, i) {
                this.x = t, this.y = e, this.z = n, this.w = i;
            }, e.fromArray = function(t, e) {
                void 0 === e && (e = 0), this.x = t[e + 0], this.y = t[e + 1], this.z = t[e + 2],
                    this.w = t[e + 3];
            }, e.cloneTo = function(t) {
                var e = t;
                e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, e.length = function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }, e.lengthSquared = function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }, e.forNativeElement = function(t) {
                t ? (this.elements = t, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    Lt.rewriteNumProperty(this, "x", 0), Lt.rewriteNumProperty(this, "y", 1), Lt.rewriteNumProperty(this, "z", 2),
                    Lt.rewriteNumProperty(this, "w", 3);
            }, t.lerp = function(t, e, n, i) {
                var r = t.x,
                    a = t.y,
                    o = t.z,
                    s = t.w;
                i.x = r + n * (e.x - r), i.y = a + n * (e.y - a), i.z = o + n * (e.z - o), i.w = s + n * (e.w - s);
            }, t.transformByM4x4 = function(t, e, n) {
                var i = t.x,
                    r = t.y,
                    a = t.z,
                    o = t.w,
                    s = e.elements;
                n.x = i * s[0] + r * s[4] + a * s[8] + o * s[12], n.y = i * s[1] + r * s[5] + a * s[9] + o * s[13],
                    n.z = i * s[2] + r * s[6] + a * s[10] + o * s[14], n.w = i * s[3] + r * s[7] + a * s[11] + o * s[15];
            }, t.equals = function(t, e) {
                return $.nearEqual(Math.abs(t.x), Math.abs(e.x)) && $.nearEqual(Math.abs(t.y), Math.abs(e.y)) && $.nearEqual(Math.abs(t.z), Math.abs(e.z)) && $.nearEqual(Math.abs(t.w), Math.abs(e.w));
            }, t.normalize = function(t, e) {
                var n = t.length();
                0 < n && (e.x = t.x * n, e.y = t.y * n, e.z = t.z * n, e.w = t.w * n);
            }, t.add = function(t, e, n) {
                n.x = t.x + e.x, n.y = t.y + e.y, n.z = t.z + e.z, n.w = t.w + e.w;
            }, t.subtract = function(t, e, n) {
                n.x = t.x - e.x, n.y = t.y - e.y, n.z = t.z - e.z, n.w = t.w - e.w;
            }, t.multiply = function(t, e, n) {
                n.x = t.x * e.x, n.y = t.y * e.y, n.z = t.z * e.z, n.w = t.w * e.w;
            }, t.scale = function(t, e, n) {
                n.x = t.x * e, n.y = t.y * e, n.z = t.z * e, n.w = t.w * e;
            }, t.Clamp = function(t, e, n, i) {
                var r = t.x,
                    a = t.y,
                    o = t.z,
                    s = t.w,
                    l = e.x,
                    h = e.y,
                    u = e.z,
                    c = e.w,
                    _ = n.x,
                    d = n.y,
                    f = n.z,
                    m = n.w;
                r = (r = _ < r ? _ : r) < l ? l : r, a = (a = d < a ? d : a) < h ? h : a, o = (o = f < o ? f : o) < u ? u : o,
                    s = (s = m < s ? m : s) < c ? c : s, i.x = r, i.y = a, i.z = o, i.w = s;
            }, t.distanceSquared = function(t, e) {
                var n = t.x - e.x,
                    i = t.y - e.y,
                    r = t.z - e.z,
                    a = t.w - e.w;
                return n * n + i * i + r * r + a * a;
            }, t.distance = function(t, e) {
                var n = t.x - e.x,
                    i = t.y - e.y,
                    r = t.z - e.z,
                    a = t.w - e.w;
                return Math.sqrt(n * n + i * i + r * r + a * a);
            }, t.dot = function(t, e) {
                return t.x * e.x + t.y * e.y + t.z * e.z + t.w * e.w;
            }, t.min = function(t, e, n) {
                n.x = Math.min(t.x, e.x), n.y = Math.min(t.y, e.y), n.z = Math.min(t.z, e.z), n.w = Math.min(t.w, e.w);
            }, t.max = function(t, e, n) {
                n.x = Math.max(t.x, e.x), n.y = Math.max(t.y, e.y), n.z = Math.max(t.z, e.z), n.w = Math.max(t.w, e.w);
            }, _(t, ["ZERO", function() {
                return this.ZERO = new t();
            }, "ONE", function() {
                return this.ONE = new t(1, 1, 1, 1);
            }, "UnitX", function() {
                return this.UnitX = new t(1, 0, 0, 0);
            }, "UnitY", function() {
                return this.UnitY = new t(0, 1, 0, 0);
            }, "UnitZ", function() {
                return this.UnitZ = new t(0, 0, 1, 0);
            }, "UnitW", function() {
                return this.UnitW = new t(0, 0, 0, 1);
            }]), t;
        }(),
        ht = function() {
            function t(t) {
                this._counter = 0, this.defines = null, this.defines = t ? (this._counter = t._counter,
                    t.defines.slice()) : (this._counter = 0, []);
            }
            return d(t, "laya.d3.shader.ShaderDefines"), t.prototype.registerDefine = function(t) {
                var e = Math.pow(2, this._counter++);
                return this.defines[e] = t, e;
            }, t;
        }(),
        Ct = function() {
            function r(t, e, n, i) {
                this.x = NaN, this.y = NaN, this.z = NaN, void 0 === t && (t = 0), void 0 === e && (e = 0),
                    void 0 === n && (n = 0), this.x = t, this.y = e, this.z = n;
            }
            d(r, "laya.d3.math.Vector3");
            var t = r.prototype;
            return m.imps(t, {
                    "laya.d3.core.IClone": !0
                }), t.setValue = function(t, e, n) {
                    this.x = t, this.y = e, this.z = n;
                }, t.fromArray = function(t, e) {
                    void 0 === e && (e = 0), this.x = t[e + 0], this.y = t[e + 1], this.z = t[e + 2];
                }, t.cloneTo = function(t) {
                    var e = t;
                    e.x = this.x, e.y = this.y, e.z = this.z;
                }, t.clone = function() {
                    var t = new this.constructor();
                    return this.cloneTo(t), t;
                }, t.toDefault = function() {
                    this.x = 0, this.y = 0, this.z = 0;
                }, t.forNativeElement = function(t) {
                    t ? (this.elements = t, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]),
                        Lt.rewriteNumProperty(this, "x", 0), Lt.rewriteNumProperty(this, "y", 1), Lt.rewriteNumProperty(this, "z", 2);
                }, r.distanceSquared = function(t, e) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z;
                    return n * n + i * i + r * r;
                }, r.distance = function(t, e) {
                    var n = t.x - e.x,
                        i = t.y - e.y,
                        r = t.z - e.z;
                    return Math.sqrt(n * n + i * i + r * r);
                }, r.min = function(t, e, n) {
                    n.x = Math.min(t.x, e.x), n.y = Math.min(t.y, e.y), n.z = Math.min(t.z, e.z);
                }, r.max = function(t, e, n) {
                    n.x = Math.max(t.x, e.x), n.y = Math.max(t.y, e.y), n.z = Math.max(t.z, e.z);
                }, r.transformQuat = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z,
                        o = e.x,
                        s = e.y,
                        l = e.z,
                        h = e.w,
                        u = h * i + s * a - l * r,
                        c = h * r + l * i - o * a,
                        _ = h * a + o * r - s * i,
                        d = -o * i - s * r - l * a;
                    n.x = u * h + d * -o + c * -l - _ * -s, n.y = c * h + d * -s + _ * -o - u * -l,
                        n.z = _ * h + d * -l + u * -s - c * -o;
                }, r.scalarLength = function(t) {
                    var e = t.x,
                        n = t.y,
                        i = t.z;
                    return Math.sqrt(e * e + n * n + i * i);
                }, r.scalarLengthSquared = function(t) {
                    var e = t.x,
                        n = t.y,
                        i = t.z;
                    return e * e + n * n + i * i;
                }, r.normalize = function(t, e) {
                    var n = t.x,
                        i = t.y,
                        r = t.z,
                        a = n * n + i * i + r * r;
                    0 < a && (a = 1 / Math.sqrt(a), e.x = t.x * a, e.y = t.y * a, e.z = t.z * a);
                }, r.multiply = function(t, e, n) {
                    n.x = t.x * e.x, n.y = t.y * e.y, n.z = t.z * e.z;
                }, r.scale = function(t, e, n) {
                    n.x = t.x * e, n.y = t.y * e, n.z = t.z * e;
                }, r.lerp = function(t, e, n, i) {
                    var r = t.x,
                        a = t.y,
                        o = t.z;
                    i.x = r + n * (e.x - r), i.y = a + n * (e.y - a), i.z = o + n * (e.z - o);
                }, r.transformV3ToV3 = function(t, e, n) {
                    var i = r._tempVector4;
                    r.transformV3ToV4(t, e, i), n.x = i.x, n.y = i.y, n.z = i.z;
                }, r.transformV3ToV4 = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z,
                        o = e.elements;
                    n.x = i * o[0] + r * o[4] + a * o[8] + o[12], n.y = i * o[1] + r * o[5] + a * o[9] + o[13],
                        n.z = i * o[2] + r * o[6] + a * o[10] + o[14], n.w = i * o[3] + r * o[7] + a * o[11] + o[15];
                }, r.TransformNormal = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z,
                        o = e.elements;
                    n.x = i * o[0] + r * o[4] + a * o[8], n.y = i * o[1] + r * o[5] + a * o[9], n.z = i * o[2] + r * o[6] + a * o[10];
                }, r.transformCoordinate = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z,
                        o = e.elements,
                        s = i * o[3] + r * o[7] + a * o[11] + o[15];
                    n.x = i * o[0] + r * o[4] + a * o[8] + o[12] / s, n.y = i * o[1] + r * o[5] + a * o[9] + o[13] / s,
                        n.z = i * o[2] + r * o[6] + a * o[10] + o[14] / s;
                }, r.Clamp = function(t, e, n, i) {
                    var r = t.x,
                        a = t.y,
                        o = t.z,
                        s = e.x,
                        l = e.y,
                        h = e.z,
                        u = n.x,
                        c = n.y,
                        _ = n.z;
                    r = (r = u < r ? u : r) < s ? s : r, a = (a = c < a ? c : a) < l ? l : a, o = (o = _ < o ? _ : o) < h ? h : o,
                        i.x = r, i.y = a, i.z = o;
                }, r.add = function(t, e, n) {
                    n.x = t.x + e.x, n.y = t.y + e.y, n.z = t.z + e.z;
                }, r.subtract = function(t, e, n) {
                    n.x = t.x - e.x, n.y = t.y - e.y, n.z = t.z - e.z;
                }, r.cross = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z,
                        o = e.x,
                        s = e.y,
                        l = e.z;
                    n.x = r * l - a * s, n.y = a * o - i * l, n.z = i * s - r * o;
                }, r.dot = function(t, e) {
                    return t.x * e.x + t.y * e.y + t.z * e.z;
                }, r.equals = function(t, e) {
                    return $.nearEqual(t.x, e.x) && $.nearEqual(t.y, e.y) && $.nearEqual(t.z, e.z);
                }, r._ZERO = new r(0, 0, 0), r._ONE = new r(1, 1, 1), r._NegativeUnitX = new r(-1, 0, 0),
                r._UnitX = new r(1, 0, 0), r._UnitY = new r(0, 1, 0), r._UnitZ = new r(0, 0, 1),
                r._ForwardRH = new r(0, 0, -1), r._ForwardLH = new r(0, 0, 1), r._Up = new r(0, 1, 0),
                _(r, ["_tempVector4", function() {
                    return this._tempVector4 = new At();
                }]), r;
        }(),
        Lt = function() {
            function e(t, e) {
                this.x = NaN, this.y = NaN, void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t,
                    this.y = e;
            }
            d(e, "laya.d3.math.Vector2");
            var t = e.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.setValue = function(t, e) {
                this.x = t, this.y = e;
            }, t.fromArray = function(t, e) {
                void 0 === e && (e = 0), this.x = t[e + 0], this.y = t[e + 1];
            }, t.cloneTo = function(t) {
                var e = t;
                e.x = this.x, e.y = this.y;
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t.forNativeElement = function(t) {
                t ? (this.elements = t, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]),
                    e.rewriteNumProperty(this, "x", 0), e.rewriteNumProperty(this, "y", 1);
            }, e.scale = function(t, e, n) {
                n.x = t.x * e, n.y = t.y * e;
            }, e.dot = function(t, e) {
                return t.x * e.x + t.y * e.y;
            }, e.normalize = function(t, e) {
                var n = t.x,
                    i = t.y,
                    r = n * n + i * i;
                0 < r && (r = 1 / Math.sqrt(r), e.x = n * r, e.y = i * r);
            }, e.scalarLength = function(t) {
                var e = t.x,
                    n = t.y;
                return Math.sqrt(e * e + n * n);
            }, e.rewriteNumProperty = function(t, e, n) {
                Object.defineProperty(t, e, {
                    get: function() {
                        return this.elements[n];
                    },
                    set: function(t) {
                        this.elements[n] = t;
                    }
                });
            }, _(e, ["ZERO", function() {
                return this.ZERO = new e(0, 0);
            }, "ONE", function() {
                return this.ONE = new e(1, 1);
            }]), e;
        }(),
        ut = function() {
            function t() {}
            d(t, "laya.d3.component.AnimatorPlayState");
            var e = t.prototype;
            return e._resetPlayState = function(t) {
                this._finish = !1, this._startPlayTime = t, this._elapsedTime = t, this._playEventIndex = 0,
                    this._lastIsFront = !0;
            }, e._cloneTo = function(t) {
                t._finish = this._finish, t._startPlayTime = this._startPlayTime, t._elapsedTime = this._elapsedTime,
                    t._playEventIndex = this._playEventIndex, t._lastIsFront = this._lastIsFront;
            }, u(0, e, "normalizedTime", function() {
                return this._normalizedTime;
            }), u(0, e, "duration", function() {
                return this._duration;
            }), t;
        }(),
        Ot = function() {
            function t(t) {
                this._velocity = null, this.enbale = !1, this.space = 0, this._velocity = t;
            }
            d(t, "laya.d3.core.particleShuriKen.module.VelocityOverLifetime");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                this._velocity.cloneTo(e._velocity), e.enbale = this.enbale, e.space = this.space;
            }, e.clone = function() {
                var t;
                switch (this._velocity.type) {
                    case 0:
                        t = Ee.createByConstant(this._velocity.constant.clone());
                        break;

                    case 1:
                        t = Ee.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                        break;

                    case 2:
                        t = Ee.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                        break;

                    case 3:
                        t = Ee.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                }
                var e = new this.constructor(t);
                return e.enbale = this.enbale, e.space = this.space, e;
            }, u(0, e, "velocity", function() {
                return this._velocity;
            }), t;
        }(),
        ct = function() {
            function t() {}
            return d(t, "laya.d3.loaders.MeshReader"), t.read = function(t, e, n) {
                var i = new s(t);
                i.pos = 0;
                var r = i.readUTFString();
                switch (r) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                    case "LAYAMODEL:0401":
                        ft.parse(i, r, e, n);
                        break;

                    case "LAYAMODEL:05":
                    case "LAYAMODEL:COMPRESSION_05":
                        _t.parse(i, r, e, n);
                        break;

                    default:
                        throw new Error("MeshReader: unknown mesh version.");
                }
                e._setSubMeshes(n);
            }, t;
        }(),
        _t = (function() {
            function t() {}
            d(t, "laya.d3.core.scene.SceneManager");
        }(), function() {
            function t() {}
            d(t, "laya.d3.math.ContainmentType"), t.Disjoint = 0, t.Contains = 1, t.Intersects = 2;
        }(), function() {
            function w() {}
            return d(w, "laya.d3.loaders.LoadModelV05"), w.parse = function(t, e, n, i) {
                    w._mesh = n, w._subMeshes = i, w._version = e, w._readData = t, w.READ_DATA(), w.READ_BLOCK(),
                        w.READ_STRINGS();
                    for (var r = 0, a = w._BLOCK.count; r < a; r++) {
                        w._readData.pos = w._BLOCK.blockStarts[r];
                        var o = w._readData.getUint16(),
                            s = w._strings[o],
                            l = w["READ_" + s];
                        if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                        l.call();
                    }
                    w._mesh._bindPoseIndices = new Uint16Array(w._bindPoseIndices), w._bindPoseIndices.length = 0,
                        w._strings.length = 0, w._readData = null, w._version = null, w._mesh = null, w._subMeshes = null;
                }, w._readString = function() {
                    return w._strings[w._readData.getUint16()];
                }, w.READ_DATA = function() {
                    w._DATA.offset = w._readData.getUint32(), w._DATA.size = w._readData.getUint32();
                }, w.READ_BLOCK = function() {
                    for (var t = w._BLOCK.count = w._readData.getUint16(), e = w._BLOCK.blockStarts = [], n = w._BLOCK.blockLengths = [], i = 0; i < t; i++) e.push(w._readData.getUint32()),
                        n.push(w._readData.getUint32());
                }, w.READ_STRINGS = function() {
                    var t = w._readData.getUint32(),
                        e = w._readData.getUint16(),
                        n = w._readData.pos;
                    w._readData.pos = t + w._DATA.offset;
                    for (var i = 0; i < e; i++) w._strings[i] = w._readData.readUTFString();
                    w._readData.pos = n;
                }, w.READ_MESH = function() {
                    var t = 0,
                        e = 0,
                        n = (w._readString(), w._readData.__getBuffer()),
                        i = w._readData.getInt16(),
                        r = w._DATA.offset;
                    for (t = 0; t < i; t++) {
                        var a = r + w._readData.getUint32(),
                            o = w._readData.getUint32(),
                            s = w._readString(),
                            l = mt.getVertexDeclaration(s, !1),
                            h = l.vertexStride,
                            u = new ArrayBuffer(h * o),
                            c = new Float32Array(u),
                            _ = s.split(","),
                            d = _.length;
                        switch (w._version) {
                            case "LAYAMODEL:05":
                                c = new Float32Array(n.slice(a, a + o * h));
                                break;

                            case "LAYAMODEL:COMPRESSION_05":
                                var f = w._readData.pos;
                                c = new Float32Array(u);
                                var m = new Uint8Array(u);
                                w._readData.pos = a;
                                for (var p = 0; p < o; p++)
                                    for (var T = 0, E = p * h, v = 0; v < d; v++) switch (_[v]) {
                                        case "POSITION":
                                            c[T = E / 4] = vt.convertToNumber(w._readData.getUint16()), c[T + 1] = vt.convertToNumber(w._readData.getUint16()),
                                                c[T + 2] = vt.convertToNumber(w._readData.getUint16()), E += 12;
                                            break;

                                        case "NORMAL":
                                            c[T = E / 4] = w._readData.getUint8() / 127.5 - 1, c[T + 1] = w._readData.getUint8() / 127.5 - 1,
                                                c[T + 2] = w._readData.getUint8() / 127.5 - 1, E += 12;
                                            break;

                                        case "COLOR":
                                            c[T = E / 4] = w._readData.getUint8() / 255, c[T + 1] = w._readData.getUint8() / 255,
                                                c[T + 2] = w._readData.getUint8() / 255, c[T + 3] = w._readData.getUint8() / 255,
                                                E += 16;
                                            break;

                                        case "UV":
                                        case "UV1":
                                            c[T = E / 4] = vt.convertToNumber(w._readData.getUint16()), c[T + 1] = vt.convertToNumber(w._readData.getUint16()),
                                                E += 8;
                                            break;

                                        case "BLENDWEIGHT":
                                            c[T = E / 4] = w._readData.getUint8() / 255, c[T + 1] = w._readData.getUint8() / 255,
                                                c[T + 2] = w._readData.getUint8() / 255, c[T + 3] = w._readData.getUint8() / 255,
                                                E += 16;
                                            break;

                                        case "BLENDINDICES":
                                            m[E] = w._readData.getUint8(), m[E + 1] = w._readData.getUint8(), m[E + 2] = w._readData.getUint8(),
                                                m[E + 3] = w._readData.getUint8(), E += 4;
                                            break;

                                        case "TANGENT":
                                            c[T = E / 4] = w._readData.getUint8() / 127.5 - 1, c[T + 1] = w._readData.getUint8() / 127.5 - 1,
                                                c[T + 2] = w._readData.getUint8() / 127.5 - 1, c[T + 3] = w._readData.getUint8() / 127.5 - 1,
                                                E += 16;
                                    }
                                w._readData.pos = f;
                        }
                        var g = new rn(u.byteLength, 35044, !0);
                        g.vertexDeclaration = l, g.setData(c), w._mesh._vertexBuffers.push(g), w._mesh._vertexCount += g.vertexCount,
                            e += 4 * c.length;
                    }
                    var S = r + w._readData.getUint32(),
                        y = w._readData.getUint32(),
                        x = new Uint16Array(n.slice(S, S + y)),
                        D = new _n("ushort", y / 2, 35044, !0);
                    D.setData(x), w._mesh._indexBuffer = D, w._mesh._setBuffer(w._mesh._vertexBuffers, D),
                        e += 2 * D.indexCount, w._mesh._setCPUMemory(e), w._mesh._setGPUMemory(e);
                    var I = w._mesh._boneNames = [],
                        R = w._readData.getUint16();
                    for (I.length = R, t = 0; t < R; t++) I[t] = w._strings[w._readData.getUint16()];
                    var M = w._readData.getUint32(),
                        A = w._readData.getUint32(),
                        C = new Float32Array(n.slice(r + M, r + M + A)),
                        L = C.length,
                        O = L / 16,
                        N = w._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * L);
                    for (w._mesh._inverseBindPoses = P(O), t = 0; t < L; t += 16) {
                        var V = new be(C[t + 0], C[t + 1], C[t + 2], C[t + 3], C[t + 4], C[t + 5], C[t + 6], C[t + 7], C[t + 8], C[t + 9], C[t + 10], C[t + 11], C[t + 12], C[t + 13], C[t + 14], C[t + 15], new Float32Array(N, 4 * t, 16));
                        w._mesh._inverseBindPoses[t / 16] = V;
                    }
                    return !0;
                }, w.READ_SUBMESH = function() {
                    var t = w._readData.__getBuffer(),
                        e = new Ke(w._mesh),
                        n = w._readData.getInt16(),
                        i = w._readData.getUint32(),
                        r = w._readData.getUint32(),
                        a = w._mesh._indexBuffer;
                    e._indexBuffer = a, e._indexStart = i, e._indexCount = r, e._indices = new Uint16Array(a.getData().buffer, 2 * i, r);
                    var o = w._mesh._vertexBuffers[n];
                    e._vertexBuffer = o;
                    var s = w._DATA.offset,
                        l = e._subIndexBufferStart,
                        h = e._subIndexBufferCount,
                        u = e._boneIndicesList,
                        c = w._readData.getUint16();
                    l.length = c, h.length = c, u.length = c;
                    for (var _ = w._mesh._skinDataPathMarks, d = w._bindPoseIndices, f = w._subMeshes.length, m = 0; m < c; m++) {
                        l[m] = w._readData.getUint32(), h[m] = w._readData.getUint32();
                        for (var p = w._readData.getUint32(), T = w._readData.getUint32(), E = u[m] = new Uint16Array(t.slice(s + p, s + p + T)), v = 0, g = E.length; v < g; v++) {
                            var S = E[v],
                                y = d.indexOf(S); -
                            1 === y ? (E[v] = d.length, d.push(S), _.push([f, m, v])) : E[v] = y;
                        }
                    }
                    return w._subMeshes.push(e), !0;
                }, w._strings = [], w._readData = null, w._version = null, w._mesh = null, w._subMeshes = null,
                w._bindPoseIndices = [], _(w, ["_BLOCK", function() {
                    return this._BLOCK = {
                        count: 0
                    };
                }, "_DATA", function() {
                    return this._DATA = {
                        offset: 0,
                        size: 0
                    };
                }]), w;
        }()),
        dt = function() {
            function t(t, e, n, i) {
                this.r = NaN, this.g = NaN, this.b = NaN, this.a = NaN, void 0 === t && (t = 1),
                    void 0 === e && (e = 1), void 0 === n && (n = 1), void 0 === i && (i = 1), this.r = t,
                    this.g = e, this.b = n, this.a = i;
            }
            d(t, "laya.d3.math.Color");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                e.r = this.r, e.g = this.g, e.b = this.b, e.a = this.a;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, e.forNativeElement = function(t) {
                t ? (this.elements = t, this.elements[0] = this.r, this.elements[1] = this.g, this.elements[2] = this.b,
                        this.elements[3] = this.a) : this.elements = new Float32Array([this.r, this.g, this.b, this.a]),
                    Lt.rewriteNumProperty(this, "r", 0), Lt.rewriteNumProperty(this, "g", 1), Lt.rewriteNumProperty(this, "b", 2),
                    Lt.rewriteNumProperty(this, "a", 3);
            }, _(t, ["RED", function() {
                return this.RED = new t(1, 0, 0, 1);
            }, "GREEN", function() {
                return this.GREEN = new t(0, 1, 0, 1);
            }, "BLUE", function() {
                return this.BLUE = new t(0, 0, 1, 1);
            }, "CYAN", function() {
                return this.CYAN = new t(0, 1, 1, 1);
            }, "YELLOW", function() {
                return this.YELLOW = new t(1, .92, .016, 1);
            }, "MAGENTA", function() {
                return this.MAGENTA = new t(1, 0, 1, 1);
            }, "GRAY", function() {
                return this.GRAY = new t(.5, .5, .5, 1);
            }, "WHITE", function() {
                return this.WHITE = new t(1, 1, 1, 1);
            }, "BLACK", function() {
                return this.BLACK = new t(0, 0, 0, 1);
            }]), t;
        }(),
        ft = function() {
            function D() {}
            return d(D, "laya.d3.loaders.LoadModelV04"), D.parse = function(t, e, n, i) {
                    D._mesh = n, D._subMeshes = i, D._version = e, D._readData = t, D.READ_DATA(), D.READ_BLOCK(),
                        D.READ_STRINGS();
                    for (var r = 0, a = D._BLOCK.count; r < a; r++) {
                        D._readData.pos = D._BLOCK.blockStarts[r];
                        var o = D._readData.getUint16(),
                            s = D._strings[o],
                            l = D["READ_" + s];
                        if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                        l.call();
                    }
                    D._mesh._bindPoseIndices = new Uint16Array(D._bindPoseIndices), D._bindPoseIndices.length = 0,
                        D._strings.length = 0, D._readData = null, D._version = null, D._mesh = null, D._subMeshes = null;
                }, D._readString = function() {
                    return D._strings[D._readData.getUint16()];
                }, D.READ_DATA = function() {
                    D._DATA.offset = D._readData.getUint32(), D._DATA.size = D._readData.getUint32();
                }, D.READ_BLOCK = function() {
                    for (var t = D._BLOCK.count = D._readData.getUint16(), e = D._BLOCK.blockStarts = [], n = D._BLOCK.blockLengths = [], i = 0; i < t; i++) e.push(D._readData.getUint32()),
                        n.push(D._readData.getUint32());
                }, D.READ_STRINGS = function() {
                    var t = D._readData.getUint32(),
                        e = D._readData.getUint16(),
                        n = D._readData.pos;
                    D._readData.pos = t + D._DATA.offset;
                    for (var i = 0; i < e; i++) D._strings[i] = D._readData.readUTFString();
                    D._readData.pos = n;
                }, D.READ_MESH = function() {
                    D._readString();
                    var t = D._readData.__getBuffer(),
                        e = 0,
                        n = 0,
                        i = D._readData.getInt16(),
                        r = D._DATA.offset;
                    for (e = 0; e < i; e++) {
                        var a, o = r + D._readData.getUint32(),
                            s = D._readData.getUint32(),
                            l = new Float32Array(t.slice(o, o + s)),
                            h = D._readString();
                        switch (D._version) {
                            case "LAYAMODEL:0301":
                            case "LAYAMODEL:0400":
                                a = mt.getVertexDeclaration(h);
                                break;

                            case "LAYAMODEL:0401":
                                a = mt.getVertexDeclaration(h, !1);
                                break;

                            default:
                                throw new Error("LoadModelV03: unknown version.");
                        }
                        if (!a) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                        var u = new rn(4 * l.length, 35044, !0);
                        u.vertexDeclaration = a, u.setData(l), D._mesh._vertexBuffers.push(u), D._mesh._vertexCount += u.vertexCount,
                            n += 4 * l.length;
                    }
                    var c = r + D._readData.getUint32(),
                        _ = D._readData.getUint32(),
                        d = new Uint16Array(t.slice(c, c + _)),
                        f = new _n("ushort", _ / 2, 35044, !0);
                    f.setData(d), n += 2 * (D._mesh._indexBuffer = f).indexCount, D._mesh._setBuffer(D._mesh._vertexBuffers, f),
                        D._mesh._setCPUMemory(n), D._mesh._setGPUMemory(n);
                    var m = D._mesh._boneNames = [],
                        p = D._readData.getUint16();
                    for (m.length = p, e = 0; e < p; e++) m[e] = D._strings[D._readData.getUint16()];
                    D._readData.pos += 8;
                    var T = D._readData.getUint32(),
                        E = D._readData.getUint32(),
                        v = new Float32Array(t.slice(r + T, r + T + E)),
                        g = v.length,
                        S = g / 16,
                        y = D._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * g);
                    for (D._mesh._inverseBindPoses = P(S), e = 0; e < g; e += 16) {
                        var x = new be(v[e + 0], v[e + 1], v[e + 2], v[e + 3], v[e + 4], v[e + 5], v[e + 6], v[e + 7], v[e + 8], v[e + 9], v[e + 10], v[e + 11], v[e + 12], v[e + 13], v[e + 14], v[e + 15], new Float32Array(y, 4 * e, 16));
                        D._mesh._inverseBindPoses[e / 16] = x;
                    }
                    return !0;
                }, D.READ_SUBMESH = function() {
                    var t = D._readData.__getBuffer(),
                        e = new Ke(D._mesh),
                        n = D._readData.getInt16();
                    D._readData.getUint32(), D._readData.getUint32();
                    var i = D._readData.getUint32(),
                        r = D._readData.getUint32(),
                        a = D._mesh._indexBuffer;
                    e._indexBuffer = a, e._indexStart = i, e._indexCount = r, e._indices = new Uint16Array(a.getData().buffer, 2 * i, r);
                    var o = D._mesh._vertexBuffers[n];
                    e._vertexBuffer = o;
                    var s = D._DATA.offset,
                        l = e._subIndexBufferStart,
                        h = e._subIndexBufferCount,
                        u = e._boneIndicesList,
                        c = D._readData.getUint16();
                    l.length = c, h.length = c, u.length = c;
                    for (var _ = D._mesh._skinDataPathMarks, d = D._bindPoseIndices, f = D._subMeshes.length, m = 0; m < c; m++) {
                        l[m] = D._readData.getUint32(), h[m] = D._readData.getUint32();
                        for (var p = D._readData.getUint32(), T = D._readData.getUint32(), E = u[m] = new Uint16Array(t.slice(s + p, s + p + T)), v = 0, g = E.length; v < g; v++) {
                            var S = E[v],
                                y = d.indexOf(S); -
                            1 === y ? (E[v] = d.length, d.push(S), _.push([f, m, v])) : E[v] = y;
                        }
                    }
                    return D._subMeshes.push(e), !0;
                }, D._strings = [], D._readData = null, D._version = null, D._mesh = null, D._subMeshes = null,
                D._bindPoseIndices = [], _(D, ["_BLOCK", function() {
                    return this._BLOCK = {
                        count: 0
                    };
                }, "_DATA", function() {
                    return this._DATA = {
                        offset: 0,
                        size: 0
                    };
                }]), D;
        }(),
        mt = function() {
            function h() {}
            return d(h, "laya.d3.graphics.Vertex.VertexMesh"), h.getVertexDeclaration = function(t, e) {
                    void 0 === e && (e = !0);
                    var n = h._vertexDeclarationMap[t + (e ? "_0" : "_1")];
                    if (!n) {
                        for (var i = t.split(","), r = 0, a = [], o = 0, s = i.length; o < s; o++) {
                            var l;
                            switch (i[o]) {
                                case "POSITION":
                                    l = new Bt(r, "vector3", 0), r += 12;
                                    break;

                                case "NORMAL":
                                    l = new Bt(r, "vector3", 3), r += 12;
                                    break;

                                case "COLOR":
                                    l = new Bt(r, "vector4", 1), r += 16;
                                    break;

                                case "UV":
                                    l = new Bt(r, "vector2", 2), r += 8;
                                    break;

                                case "UV1":
                                    l = new Bt(r, "vector2", 7), r += 8;
                                    break;

                                case "BLENDWEIGHT":
                                    l = new Bt(r, "vector4", 6), r += 16;
                                    break;

                                case "BLENDINDICES":
                                    e ? (l = new Bt(r, "vector4", 5), r += 16) : (l = new Bt(r, "byte4", 5), r += 4);
                                    break;

                                case "TANGENT":
                                    l = new Bt(r, "vector4", 4), r += 16;
                                    break;

                                default:
                                    throw "VertexMesh: unknown vertex flag.";
                            }
                            a.push(l);
                        }
                        n = new ue(r, a), h._vertexDeclarationMap[t + (e ? "_0" : "_1")] = n;
                    }
                    return n;
                }, h.MESH_POSITION0 = 0, h.MESH_COLOR0 = 1, h.MESH_TEXTURECOORDINATE0 = 2, h.MESH_NORMAL0 = 3,
                h.MESH_TANGENT0 = 4, h.MESH_BLENDINDICES0 = 5, h.MESH_BLENDWEIGHT0 = 6, h.MESH_TEXTURECOORDINATE1 = 7,
                h.MESH_WORLDMATRIX_ROW0 = 8, h.MESH_WORLDMATRIX_ROW1 = 9, h.MESH_WORLDMATRIX_ROW2 = 10,
                h.MESH_WORLDMATRIX_ROW3 = 11, h.MESH_MVPMATRIX_ROW0 = 12, h.MESH_MVPMATRIX_ROW1 = 13,
                h.MESH_MVPMATRIX_ROW2 = 14, h.MESH_MVPMATRIX_ROW3 = 15, h._vertexDeclarationMap = {},
                _(h, ["instanceWorldMatrixDeclaration", function() {
                    return this.instanceWorldMatrixDeclaration = new ue(64, [new Bt(0, "vector4", 8), new Bt(16, "vector4", 9), new Bt(32, "vector4", 10), new Bt(48, "vector4", 11)]);
                }, "instanceMVPMatrixDeclaration", function() {
                    return this.instanceMVPMatrixDeclaration = new ue(64, [new Bt(0, "vector4", 12), new Bt(16, "vector4", 13), new Bt(32, "vector4", 14), new Bt(48, "vector4", 15)]);
                }]), h;
        }(),
        pt = function() {
            function t() {
                this._destroyed = !1, this._emissionRate = 0, this._bursts = null, this.enbale = !1,
                    this._destroyed = !1, this.emissionRate = 10, this._bursts = [];
            }
            d(t, "laya.d3.core.particleShuriKen.module.Emission");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0,
                "laya.resource.IDestroy": !0
            }), e.destroy = function() {
                this._bursts = null, this._destroyed = !0;
            }, e.getBurstsCount = function() {
                return this._bursts.length;
            }, e.getBurstByIndex = function(t) {
                return this._bursts[t];
            }, e.addBurst = function(t) {
                var e = this._bursts.length;
                if (0 < e)
                    for (var n = 0; n < e; n++) this._bursts[n].time > t.time && this._bursts.splice(n, 0, t);
                this._bursts.push(t);
            }, e.removeBurst = function(t) {
                var e = this._bursts.indexOf(t); -
                1 !== e && this._bursts.splice(e, 1);
            }, e.removeBurstByIndex = function(t) {
                this._bursts.splice(t, 1);
            }, e.clearBurst = function() {
                this._bursts.length = 0;
            }, e.cloneTo = function(t) {
                var e = t,
                    n = e._bursts;
                n.length = this._bursts.length;
                for (var i = 0, r = this._bursts.length; i < r; i++) {
                    var a = n[i];
                    a ? this._bursts[i].cloneTo(a) : n[i] = this._bursts[i].clone();
                }
                e._emissionRate = this._emissionRate, e.enbale = this.enbale;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "destroyed", function() {
                return this._destroyed;
            }), u(0, e, "emissionRate", function() {
                return this._emissionRate;
            }, function(t) {
                if (t < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                this._emissionRate = t;
            }), t;
        }(),
        Tt = function() {
            function u(t, e) {
                this.center = null, this.radius = NaN, this.center = t, this.radius = e;
            }
            d(u, "laya.d3.math.BoundSphere");
            var t = u.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.toDefault = function() {
                this.center.toDefault(), this.radius = 0;
            }, t.intersectsRayDistance = function(t) {
                return Oe.intersectsRayAndSphereRD(t, this);
            }, t.intersectsRayPoint = function(t, e) {
                return Oe.intersectsRayAndSphereRP(t, this, e);
            }, t.cloneTo = function(t) {
                var e = t;
                this.center.cloneTo(e.center), e.radius = this.radius;
            }, t.clone = function() {
                var t = new this.constructor(new Ct(), new Ct());
                return this.cloneTo(t), t;
            }, u.createFromSubPoints = function(t, e, n, i) {
                if (null == t) throw new Error("points");
                if (e < 0 || e >= t.length) throw new Error("start" + e + "Must be in the range [0, " + (t.length - 1) + "]");
                if (n < 0 || e + n > t.length) throw new Error("count" + n + "Must be in the range <= " + t.length + "}");
                var r = e + n,
                    a = u._tempVector3;
                a.x = 0, a.y = 0, a.z = 0;
                for (var o = e; o < r; ++o) Ct.add(t[o], a, a);
                var s = i.center;
                Ct.scale(a, 1 / n, s);
                var l = 0;
                for (o = e; o < r; ++o) {
                    var h = Ct.distanceSquared(s, t[o]);
                    l < h && (l = h);
                }
                i.radius = Math.sqrt(l);
            }, u.createfromPoints = function(t, e) {
                if (null == t) throw new Error("points");
                u.createFromSubPoints(t, 0, t.length, e);
            }, _(u, ["_tempVector3", function() {
                return this._tempVector3 = new Ct();
            }]), u;
        }(),
        Et = function() {
            function t() {
                this.renderType = 0;
            }
            d(t, "laya.d3.core.render.RenderElement");
            var e = t.prototype;
            return e.setTransform = function(t) {
                    this._transform = t;
                }, e.setGeometry = function(t) {
                    this._geometry = t;
                }, e.addToOpaqueRenderQueue = function(t, e) {
                    e.elements.push(this);
                }, e.addToTransparentRenderQueue = function(t, e) {
                    e.elements.push(this), e.lastTransparentBatched = !1, e.lastTransparentRenderElement = this;
                }, e._render = function(t, e, n, i) {
                    var r, a, o, s = Ti._updateMark,
                        l = t.scene,
                        h = t.camera,
                        u = this._transform,
                        c = this._geometry,
                        _ = s !== (t.renderElement = this).render._updateMark || this.renderType !== this.render._updateRenderType;
                    if (_ && (this.render._renderUpdate(t, u), this.render._renderUpdateWithCamera(t, u),
                            this.render._updateMark = s, this.render._updateRenderType = this.renderType), c._prepareRender(t)) {
                        var d, f = this.material._shader.getSubShaderAt(0);
                        if (n)
                            if (i) {
                                var m = f.getFlag(i);
                                if (!m) return;
                                for (var p = n._subShaders, T = 0, E = p.length; T < E; T++) {
                                    var v = p[T];
                                    if (m === v.getFlag(i)) {
                                        d = v._passes;
                                        break;
                                    }
                                }
                                if (!d) return;
                            } else d = n.getSubShaderAt(0)._passes;
                        else d = f._passes;
                        for (var g = 0, S = d.length; g < S; g++) {
                            var y = t.shader = d[g].withCompile(l._defineDatas.value & ~this.material._disablePublicDefineDatas.value, this.render._defineDatas.value, this.material._defineDatas.value),
                                x = y.bind(),
                                D = s !== y._uploadMark,
                                I = y._uploadScene !== l || D;
                            (I || x) && (y.uploadUniforms(y._sceneUniformParamsMap, l._shaderValues, I), y._uploadScene = l);
                            var R = y._uploadRender !== this.render || y._uploadRenderType !== this.renderType || D;
                            (R || x) && (y.uploadUniforms(y._spriteUniformParamsMap, this.render._shaderValues, R),
                                y._uploadRender = this.render, y._uploadRenderType = this.renderType);
                            var M = y._uploadCamera !== h || D;
                            (M || x) && (y.uploadUniforms(y._cameraUniformParamsMap, h._shaderValues, M), y._uploadCamera = h);
                            var A = y._uploadMaterial !== this.material || D;
                            (A || x) && (y.uploadUniforms(y._materialUniformParamsMap, this.material._shaderValues, A),
                                y._uploadMaterial = this.material);
                            var C = this.material._shaderValues;
                            r !== this.material || a !== y ? (y.uploadRenderStateBlendDepth(C), y.uploadRenderStateFrontFace(C, e, u),
                                r = this.material, a = y, o = this.render) : o !== this.render && (y.uploadRenderStateFrontFace(C, e, u),
                                o = this.render), c._render(t), y._uploadMark = s;
                        }
                    }
                    _ && 0 !== this.renderType && this.render._revertBatchRenderUpdate(t), Ti._updateMark++;
                }, e.destroy = function() {
                    this._transform = null, this._geometry = null, this.material = null, this.render = null;
                }, t.RENDERTYPE_NORMAL = 0, t.RENDERTYPE_STATICBATCH = 1, t.RENDERTYPE_INSTANCEBATCH = 2,
                t.RENDERTYPE_VERTEXBATCH = 3, t;
        }(),
        vt = function() {
            function i() {}
            return d(i, "laya.d3.math.HalfFloatUtils"), i.__init__ = function() {
                for (var t = 0; t < 256; ++t) {
                    var e = t - 127;
                    i._shiftTable[256 | t] = e < -27 ? (i._baseTable[0 | t] = 0, i._baseTable[256 | t] = 32768,
                        i._shiftTable[0 | t] = 24) : e < -14 ? (i._baseTable[0 | t] = 1024 >> -e - 14, i._baseTable[256 | t] = 1024 >> -e - 14 | 32768,
                        i._shiftTable[0 | t] = -e - 1, -e - 1) : e <= 15 ? (i._baseTable[0 | t] = e + 15 << 10,
                        i._baseTable[256 | t] = e + 15 << 10 | 32768, i._shiftTable[0 | t] = 13) : e < 128 ? (i._baseTable[0 | t] = 31744,
                        i._baseTable[256 | t] = 64512, i._shiftTable[0 | t] = 24) : (i._baseTable[0 | t] = 31744,
                        i._baseTable[256 | t] = 64512, i._shiftTable[0 | t] = 13);
                }
                for (i._mantissaTable[0] = 0, t = 1; t < 1024; ++t) {
                    var n = t << 13;
                    for (e = 0; 0 == (8388608 & n);) e -= 8388608, n <<= 1;
                    n &= -8388609, e += 947912704, i._mantissaTable[t] = n | e;
                }
                for (t = 1024; t < 2048; ++t) i._mantissaTable[t] = 939524096 + (t - 1024 << 13);
                for (i._exponentTable[0] = 0, t = 1; t < 31; ++t) i._exponentTable[t] = t << 23;
                for (i._exponentTable[31] = 1199570944, i._exponentTable[32] = 2147483648, t = 33; t < 63; ++t) i._exponentTable[t] = 2147483648 + (t - 32 << 23);
                for (i._exponentTable[63] = 3347054592, i._offsetTable[0] = 0, t = 1; t < 64; ++t) i._offsetTable[t] = 32 === t ? 0 : 1024;
            }, i.roundToFloat16Bits = function(t) {
                i._floatView[0] = t;
                var e = i._uint32View[0],
                    n = e >> 23 & 511;
                return i._baseTable[n] + ((8388607 & e) >> i._shiftTable[n]);
            }, i.convertToNumber = function(t) {
                var e = t >> 10;
                return i._uint32View[0] = i._mantissaTable[i._offsetTable[e] + (1023 & t)] + i._exponentTable[e],
                    i._floatView[0];
            }, _(i, ["_buffer", function() {
                return this._buffer = new ArrayBuffer(4);
            }, "_floatView", function() {
                return this._floatView = new Float32Array(i._buffer);
            }, "_uint32View", function() {
                return this._uint32View = new Uint32Array(i._buffer);
            }, "_baseTable", function() {
                return this._baseTable = new Uint32Array(512);
            }, "_shiftTable", function() {
                return this._shiftTable = new Uint32Array(512);
            }, "_mantissaTable", function() {
                return this._mantissaTable = new Uint32Array(2048);
            }, "_exponentTable", function() {
                return this._exponentTable = new Uint32Array(64);
            }, "_offsetTable", function() {
                return this._offsetTable = new Uint32Array(64);
            }]), i;
        }(),
        gt = function() {
            function t() {
                this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = null;
            }
            return d(t, "laya.d3.resource.models.SkyMesh"), t.prototype._render = function(t) {},
                t;
        }(),
        Nt = function() {
            function t(t, e) {
                this._frame = null, this._startFrame = null, this.tiles = null, this.type = 0, this.randomRow = !1,
                    this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, this.enable = !1,
                    this.tiles = new Lt(1, 1), this.type = 0, this.randomRow = !0, this.rowIndex = 0,
                    this.cycles = 1, this.enableUVChannels = 1, this._frame = t, this._startFrame = e;
            }
            d(t, "laya.d3.core.particleShuriKen.module.TextureSheetAnimation");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                this.tiles.cloneTo(e.tiles), e.type = this.type, e.randomRow = this.randomRow, this._frame.cloneTo(e._frame),
                    this._startFrame.cloneTo(e._startFrame), e.cycles = this.cycles, e.enableUVChannels = this.enableUVChannels,
                    e.enable = this.enable;
            }, e.clone = function() {
                var t, e;
                switch (this._frame.type) {
                    case 0:
                        t = It.createByConstant(this._frame.constant);
                        break;

                    case 1:
                        t = It.createByOverTime(this._frame.frameOverTimeData.clone());
                        break;

                    case 2:
                        t = It.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                        break;

                    case 3:
                        t = It.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                }
                switch (this._startFrame.type) {
                    case 0:
                        e = ve.createByConstant(this._startFrame.constant);
                        break;

                    case 1:
                        e = ve.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                }
                var n = new this.constructor(t, e);
                return this.tiles.cloneTo(n.tiles), n.type = this.type, n.randomRow = this.randomRow,
                    n.cycles = this.cycles, n.enableUVChannels = this.enableUVChannels, n.enable = this.enable,
                    n;
            }, u(0, e, "frame", function() {
                return this._frame;
            }), u(0, e, "startFrame", function() {
                return this._startFrame;
            }), t;
        }(),
        St = function() {
            function t() {}
            return d(t, "laya.d3.resource.TextureGenerator"), t.lightAttenTexture = function(t, e, n, i, r, a) {
                var o = t / n,
                    s = 1 / (1 + 25 * o);
                .64 <= o && (1 < o ? s = 0 : s *= 1 - (o - .64) / .36), a[r] = Math.floor(255 * s + .5);
            }, t.haloTexture = function(t, e, n, i, r, a) {
                var o = (t - (n >>= 1)) / n,
                    s = (e - (i >>= 1)) / i,
                    l = o * o + s * s;
                1 < l && (l = 1), a[r] = Math.floor(255 * (1 - l) + .5);
            }, t._generateTexture2D = function(t, e, n, i) {
                var r = 0,
                    a = 0;
                switch (t.format) {
                    case 0:
                        a = 3;
                        break;

                    case 1:
                        a = 4;
                        break;

                    case 2:
                        a = 1;
                        break;

                    default:
                        throw "GeneratedTexture._generateTexture: unkonw texture format.";
                }
                for (var o = new Uint8Array(e * n * a), s = 0; s < n; s++)
                    for (var l = 0; l < e; l++) i(l, s, e, n, r, o),
                        r += a;
                t.setPixels(o);
            }, t;
        }(),
        Vt = function() {
            function n(t, e) {
                this._enableInstancing = !1, this._subShaders = [], this._name = t, this._enableInstancing = e;
            }
            d(n, "laya.d3.shader.Shader3D");
            var t = n.prototype;
            return t.addSubShader = function(t) {
                    this._subShaders.push(t), t._owner = this;
                }, t.getSubShaderAt = function(t) {
                    return this._subShaders[t];
                }, n.propertyNameToID = function(t) {
                    if (null != n._propertyNameMap[t]) return n._propertyNameMap[t];
                    var e = n._propertyNameCounter++;
                    return n._propertyNameMap[t] = e;
                }, n.addInclude = function(t, e) {
                    x.addInclude(t, e);
                }, n.registerPublicDefine = function(t) {
                    var e = Math.pow(2, n._publicCounter++);
                    return n._globleDefines[e] = t, e;
                }, n.compileShader = function(t, e, n, i, r, a) {
                    var o = laya.d3.shader.Shader3D.find(t);
                    if (o) {
                        var s = o.getSubShaderAt(e);
                        if (s) {
                            var l = s._passes[n];
                            l ? N.shaderHighPrecision ? l.withCompile(i, r, a) : l.withCompile(i - laya.d3.shader.Shader3D.SHADERDEFINE_HIGHPRECISION, r, a) : console.warn("Shader3D: unknown passIndex.");
                        } else console.warn("Shader3D: unknown subShaderIndex.");
                    } else console.warn("Shader3D: unknown shader name.");
                }, n.add = function(t, e) {
                    return void 0 === e && (e = !1), laya.d3.shader.Shader3D._preCompileShader[t] = new n(t, e);
                }, n.find = function(t) {
                    return laya.d3.shader.Shader3D._preCompileShader[t];
                }, n.RENDER_STATE_CULL = 0, n.RENDER_STATE_BLEND = 1, n.RENDER_STATE_BLEND_SRC = 2,
                n.RENDER_STATE_BLEND_DST = 3, n.RENDER_STATE_BLEND_SRC_RGB = 4, n.RENDER_STATE_BLEND_DST_RGB = 5,
                n.RENDER_STATE_BLEND_SRC_ALPHA = 6, n.RENDER_STATE_BLEND_DST_ALPHA = 7, n.RENDER_STATE_BLEND_CONST_COLOR = 8,
                n.RENDER_STATE_BLEND_EQUATION = 9, n.RENDER_STATE_BLEND_EQUATION_RGB = 10, n.RENDER_STATE_BLEND_EQUATION_ALPHA = 11,
                n.RENDER_STATE_DEPTH_TEST = 12, n.RENDER_STATE_DEPTH_WRITE = 13, n.PERIOD_CUSTOM = 0,
                n.PERIOD_MATERIAL = 1, n.PERIOD_SPRITE = 2, n.PERIOD_CAMERA = 3, n.PERIOD_SCENE = 4,
                n.SHADERDEFINE_HIGHPRECISION = 0, n._propertyNameCounter = 0, n._propertyNameMap = {},
                n._publicCounter = 0, n._globleDefines = [], n._preCompileShader = {}, n.debugMode = !1,
                n;
        }(),
        yt = function() {
            function t(t) {
                this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = t,
                    this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                    this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }
            d(t, "laya.d3.math.Rand");
            var e = t.prototype;
            return e.getUint = function() {
                return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1],
                    this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8,
                    this.seeds[3];
            }, e.getFloat = function() {
                return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
            }, e.getSignedFloat = function() {
                return 2 * this.getFloat() - 1;
            }, u(0, e, "seed", function() {
                return this.seeds[0];
            }, function(t) {
                this.seeds[0] = t, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                    this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }), t.getFloatFromInt = function(t) {
                return 1 / 8388607 * (8388607 & t);
            }, t.getByteFromInt = function(t) {
                return (8388607 & t) >>> 15;
            }, t;
        }(),
        wt = function() {
            function E() {
                this._currentPSSM = -1, this._shadowMapCount = 3, this._maxDistance = 200, this._ratioOfDistance = 1 / this._shadowMapCount,
                    this._statesDirty = !0, this._shadowMapTextureSize = 1024, this._scene = null, this._PCFType = 0,
                    this._shaderValueLightVP = null, this._spiltDistance = new Array(4), this._globalParallelLightDir = new Ct(0, -1, 0),
                    this._boundingSphere = new Array(4), this._boundingBox = new Array(4), this._frustumPos = new Array(16),
                    this._uniformDistance = new Array(4), this._logDistance = new Array(4), this._dimension = new Array(4),
                    this._tempLookAt3 = new Ct(), this._tempLookAt4 = new At(), this._tempValue = new At(),
                    this._tempPos = new Ct(), this._tempLightUp = new Ct(), this._tempMin = new At(),
                    this._tempMax = new At(), this._tempMatrix44 = new be(), this._splitFrustumCulling = new Me(be.DEFAULT),
                    this._tempScaleMatrix44 = new be(), this._shadowPCFOffset = new Lt(1 / 1024, 1 / 1024),
                    this._shaderValueDistance = new At(), this.cameras = [], this._shaderValueVPs = [];
                var t = 0;
                for (t = 0; t < this._spiltDistance.length; t++) this._spiltDistance[t] = 0;
                for (t = 0; t < this._dimension.length; t++) this._dimension[t] = new Lt();
                for (t = 0; t < this._frustumPos.length; t++) this._frustumPos[t] = new Ct();
                for (t = 0; t < this._boundingBox.length; t++) this._boundingBox[t] = new we(new Ct(), new Ct());
                for (t = 0; t < this._boundingSphere.length; t++) this._boundingSphere[t] = new Tt(new Ct(), 0);
                be.createScaling(new Ct(.5, .5, 1), this._tempScaleMatrix44), this._tempScaleMatrix44.elements[12] = .5,
                    this._tempScaleMatrix44.elements[13] = .5;
            }
            d(E, "laya.d3.shadowMap.ParallelSplitShadowMap");
            var t = E.prototype;
            return t.setInfo = function(t, e, n, i, r, a) {
                3 < r && (this._shadowMapCount = 3), this._scene = t, this._maxDistance = e, this.shadowMapCount = r,
                    this._globalParallelLightDir = n, this._ratioOfDistance = 1 / this._shadowMapCount;
                for (var o = 0; o < this._spiltDistance.length; o++) this._spiltDistance[o] = 0;
                this._shadowMapTextureSize = i, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                    this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this.setPCFType(a), this._statesDirty = !0;
            }, t.setPCFType = function(t) {
                this._PCFType = t;
                var e = this._scene._defineDatas;
                switch (this._PCFType) {
                    case 0:
                        e.add(Gn.SHADERDEFINE_SHADOW_PCF_NO), e.remove(Gn.SHADERDEFINE_SHADOW_PCF1), e.remove(Gn.SHADERDEFINE_SHADOW_PCF2),
                            e.remove(Gn.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 1:
                        e.add(Gn.SHADERDEFINE_SHADOW_PCF1), e.remove(Gn.SHADERDEFINE_SHADOW_PCF_NO), e.remove(Gn.SHADERDEFINE_SHADOW_PCF2),
                            e.remove(Gn.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 2:
                        e.add(Gn.SHADERDEFINE_SHADOW_PCF2), e.remove(Gn.SHADERDEFINE_SHADOW_PCF_NO), e.remove(Gn.SHADERDEFINE_SHADOW_PCF1),
                            e.remove(Gn.SHADERDEFINE_SHADOW_PCF3);
                        break;

                    case 3:
                        e.add(Gn.SHADERDEFINE_SHADOW_PCF3), e.remove(Gn.SHADERDEFINE_SHADOW_PCF_NO), e.remove(Gn.SHADERDEFINE_SHADOW_PCF1),
                            e.remove(Gn.SHADERDEFINE_SHADOW_PCF2);
                }
            }, t.getPCFType = function() {
                return this._PCFType;
            }, t.setFarDistance = function(t) {
                this._maxDistance != t && (this._maxDistance = t, this._statesDirty = !0);
            }, t.getFarDistance = function() {
                return this._maxDistance;
            }, t._beginSampler = function(t, e) {
                if (t < 0 || t > this._shadowMapCount) throw new Error("ParallelSplitShadowMap: beginSample invalid index");
                this._currentPSSM = t, this._update(e);
            }, t.endSampler = function(t) {
                this._currentPSSM = -1;
            }, t._calcAllLightCameraInfo = function(t) {
                if (1 === this._shadowMapCount) this._beginSampler(0, t), this.endSampler(t);
                else
                    for (var e = 0, n = this._shadowMapCount + 1; e < n; e++) this._beginSampler(e, t),
                        this.endSampler(t);
            }, t._recalculate = function(t, e, n) {
                this._calcSplitDistance(t), this._calcBoundingBox(e, n), this._rebuildRenderInfo();
            }, t._update = function(t) {
                var e = t.nearPlane,
                    n = t.fieldOfView,
                    i = t.aspectRatio;
                (this._statesDirty || this.lastNearPlane !== e || this.lastFieldOfView !== n || this.lastAspectRatio !== i) && (this._recalculate(e, n, i),
                    this._uploadShaderValue(), this._statesDirty = !1, this.lastNearPlane = e, this.lastFieldOfView = n,
                    this.lastAspectRatio = i), this._calcLightViewProject(t);
            }, t._uploadShaderValue = function() {
                var t = this._scene._defineDatas;
                switch (this._shadowMapCount) {
                    case 1:
                        t.add(Gn.SHADERDEFINE_SHADOW_PSSM1), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM2), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM3);
                        break;

                    case 2:
                        t.add(Gn.SHADERDEFINE_SHADOW_PSSM2), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM1), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM3);
                        break;

                    case 3:
                        t.add(Gn.SHADERDEFINE_SHADOW_PSSM3), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM1), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM2);
                }
                var e = this._scene._shaderValues;
                switch (e.setVector(Gn.SHADOWDISTANCE, this._shaderValueDistance), e.setBuffer(Gn.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP),
                    e.setVector2(Gn.SHADOWMAPPCFOFFSET, this._shadowPCFOffset), this._shadowMapCount) {
                    case 3:
                        e.setTexture(Gn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(Gn.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget),
                            e.setTexture(Gn.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                        break;

                    case 2:
                        e.setTexture(Gn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(Gn.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                        break;

                    case 1:
                        e.setTexture(Gn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
                }
            }, t._calcSplitDistance = function(t) {
                var e = this._maxDistance,
                    n = 1 / this._shadowMapCount,
                    i = 0;
                for (i = 0; i <= this._shadowMapCount; i++) this._uniformDistance[i] = t + (e - t) * i * n;
                var r = e / t;
                for (i = 0; i <= this._shadowMapCount; i++) {
                    var a = Math.pow(r, i * n);
                    this._logDistance[i] = t * a;
                }
                for (i = 0; i <= this._shadowMapCount; i++) this._spiltDistance[i] = this._uniformDistance[i] * this._ratioOfDistance + this._logDistance[i] * (1 - this._ratioOfDistance);
                this._shaderValueDistance.x = this._spiltDistance[1], this._shaderValueDistance.y = this._spiltDistance[2],
                    this._shaderValueDistance.z = this._spiltDistance[3], this._shaderValueDistance.w = 0;
            }, t._calcBoundingBox = function(t, e) {
                var n, i, r, a, o = 3.1415926 * t / 180,
                    s = Math.tan(o / 2),
                    l = NaN,
                    h = NaN,
                    u = NaN,
                    c = 0;
                for (c = 0; c <= this._shadowMapCount; c++) {
                    h = (l = (u = this._spiltDistance[c]) * s) * e;
                    var _ = this._frustumPos[4 * c + 0];
                    _.x = -h, _.y = -l, _.z = -u, (_ = this._frustumPos[4 * c + 1]).x = h, _.y = -l,
                        _.z = -u, (_ = this._frustumPos[4 * c + 2]).x = -h, _.y = l, _.z = -u, (_ = this._frustumPos[4 * c + 3]).x = h,
                        _.y = l, _.z = -u, (_ = this._dimension[c]).x = h, _.y = l;
                }
                for (c = 1; c <= this._shadowMapCount; c++) n = this._dimension[c], (i = this._boundingBox[c].min).x = -n.x,
                    i.y = -n.y, i.z = -this._spiltDistance[c], (r = this._boundingBox[c].max).x = n.x,
                    r.y = n.y, r.z = -this._spiltDistance[c - 1], (a = this._boundingSphere[c].center).x = .5 * (i.x + r.x),
                    a.y = .5 * (i.y + r.y), a.z = .5 * (i.z + r.z), this._boundingSphere[c].radius = .5 * Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2) + Math.pow(r.z - i.z, 2));
                i = this._boundingBox[0].min, n = this._dimension[this._shadowMapCount], i.x = -n.x,
                    i.y = -n.y, i.z = -this._spiltDistance[this._shadowMapCount], (r = this._boundingBox[0].max).x = n.x,
                    r.y = n.y, r.z = -this._spiltDistance[0], (a = this._boundingSphere[0].center).x = .5 * (i.x + r.x),
                    a.y = .5 * (i.y + r.y), a.z = .5 * (i.z + r.z), this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2) + Math.pow(r.z - i.z, 2));
            }, t.calcSplitFrustum = function(t) {
                0 < this._currentPSSM ? be.createPerspective(3.1416 * t.fieldOfView / 180, t.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : be.createPerspective(3.1416 * t.fieldOfView / 180, t.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44),
                    be.multiply(this._tempMatrix44, t.viewMatrix, this._tempMatrix44), this._splitFrustumCulling.matrix = this._tempMatrix44;
            }, t._rebuildRenderInfo = function() {
                var t = this._shadowMapCount + 1,
                    e = 0;
                for (this.cameras.length = t, e = 0; e < t; e++) {
                    if (!this.cameras[e]) {
                        var n = new Ti();
                        n.name = "lightCamera" + e, n.clearColor = new At(1, 1, 1, 1), this.cameras[e] = n;
                    }
                    var i = this.cameras[e].renderTarget;
                    null != i && i.width == this._shadowMapTextureSize && i.height == this._shadowMapTextureSize || (i && i.destroy(),
                        (i = new oi(this._shadowMapTextureSize, this._shadowMapTextureSize, 1, 0)).filterMode = 0,
                        this.cameras[e].renderTarget = i);
                }
            }, t._calcLightViewProject = function(t) {
                var e = this._boundingSphere[this._currentPSSM],
                    n = t.transform.worldMatrix;
                e.radius;
                e.center.cloneTo(this._tempLookAt3), Ct.transformV3ToV4(this._tempLookAt3, n, this._tempLookAt4);
                var i = this._tempLookAt3,
                    r = this._tempLookAt4;
                i.x = r.x, i.y = r.y, i.z = r.z;
                var a = this._tempLightUp;
                t.transform.worldMatrix.getForward(E._tempVector30);
                var o = E._tempVector30;
                a.x = o.x, a.y = 1, a.z = o.z, Ct.normalize(this._tempLightUp, this._tempLightUp),
                    Ct.scale(this._globalParallelLightDir, 4 * e.radius, this._tempPos), Ct.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
                var s = this.cameras[this._currentPSSM];
                s.transform.position = this._tempPos, s.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
                var l = this._tempMax,
                    h = this._tempMin;
                l.x = l.y = l.z = -1e5, l.w = 1, h.x = h.y = h.z = 1e5, h.w = 1, be.multiply(s.viewMatrix, n, this._tempMatrix44);
                var u = this._tempValue,
                    c = [];
                c.length = 8, this._boundingBox[this._currentPSSM].getCorners(c);
                for (var _ = 0; _ < 8; _++) {
                    var d = c[_];
                    u.x = d.x, u.y = d.y, u.z = d.z, u.w = 1, At.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue),
                        h.x = u.x < h.x ? u.x : h.x, h.y = u.y < h.y ? u.y : h.y, h.z = u.z < h.z ? u.z : h.z,
                        l.x = u.x > l.x ? u.x : l.x, l.y = u.y > l.y ? u.y : l.y, l.z = u.z > l.z ? u.z : l.z;
                }
                At.add(this._tempMax, this._tempMin, this._tempValue), u.x *= .5, u.y *= .5, u.z *= .5,
                    u.w = 1, At.transformByM4x4(this._tempValue, s.transform.worldMatrix, this._tempValue);
                var f = Math.abs(-this._tempMax.z),
                    m = f > this._maxDistance ? f : this._maxDistance;
                Ct.scale(this._globalParallelLightDir, m, this._tempPos);
                var p = this._tempPos;
                p.x = u.x - p.x, p.y = u.y - p.y, p.z = u.z - p.z, s.transform.position = this._tempPos,
                    s.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1), be.createOrthoOffCenter(h.x, l.x, h.y, l.y, 1, m + .5 * (l.z - h.z), s.projectionMatrix);
                var T = s.projectionViewMatrix;
                E.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, T, this._shaderValueVPs[this._currentPSSM]),
                    this._scene._shaderValues.setBuffer(Gn.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
            }, t.setShadowMapTextureSize = function(t) {
                t !== this._shadowMapTextureSize && (this._shadowMapTextureSize = t, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                    this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this._statesDirty = !0);
            }, t.disposeAllRenderTarget = function() {
                for (var t = 0, e = this._shadowMapCount + 1; t < e; t++) this.cameras[t].renderTarget && (this.cameras[t].renderTarget.destroy(),
                    this.cameras[t].renderTarget = null);
            }, u(0, t, "shadowMapCount", function() {
                return this._shadowMapCount;
            }, function(t) {
                if (t = (t = 0 < t ? t : 1) <= 3 ? t : 3, this._shadowMapCount != t) {
                    this._shadowMapCount = t, this._ratioOfDistance = 1 / this._shadowMapCount, this._statesDirty = !0,
                        this._shaderValueLightVP = new Float32Array(16 * t), this._shaderValueVPs.length = t;
                    for (var e = 0; e < t; e++) this._shaderValueVPs[e] = new Float32Array(this._shaderValueLightVP.buffer, 64 * e);
                }
            }), E.multiplyMatrixOutFloat32Array = function(t, e, n) {
                var i, r, a, o, s, l, h;
                for (r = t.elements, a = e.elements, i = 0; i < 4; i++) o = r[i], s = r[i + 4],
                    l = r[i + 8], h = r[i + 12], n[i] = o * a[0] + s * a[1] + l * a[2] + h * a[3], n[i + 4] = o * a[4] + s * a[5] + l * a[6] + h * a[7],
                    n[i + 8] = o * a[8] + s * a[9] + l * a[10] + h * a[11], n[i + 12] = o * a[12] + s * a[13] + l * a[14] + h * a[15];
            }, E.MAX_PSSM_COUNT = 3, _(E, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }]), E;
        }(),
        Pt = (function() {
            function L() {}
            d(L, "laya.d3.resource.models.PrimitiveMesh"), L._createMesh = function(t, e, n) {
                var i = new On(),
                    r = new Ke(i),
                    a = new rn(4 * e.length, 35044, !0);
                a.vertexDeclaration = t, a.setData(e), i._vertexBuffers.push(a), i._vertexCount += a.vertexCount;
                var o = new _n("ushort", n.length, 35044, !0);
                o.setData(n), i._indexBuffer = o;
                var s = P(1, null);
                s[0] = a, i._setBuffer(s, o), r._vertexBuffer = a, r._indexBuffer = o, r._indexStart = 0,
                    r._indexCount = o.indexCount;
                var l = r._subIndexBufferStart,
                    h = r._subIndexBufferCount,
                    u = r._boneIndicesList;
                l.length = 1, h.length = 1, u.length = 1, h[l[0] = 0] = o.indexCount;
                var c = [];
                c.push(r), i._setSubMeshes(c);
                var _ = a._byteLength + o._byteLength;
                return i._setCPUMemory(_), i._setGPUMemory(_), i;
            }, L.createBox = function(t, e, n) {
                void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 1);
                var i = mt.getVertexDeclaration("POSITION,NORMAL,UV"),
                    r = t / 2,
                    a = e / 2,
                    o = n / 2,
                    s = new Float32Array([-r, a, -o, 0, 1, 0, 0, 0, r, a, -o, 0, 1, 0, 1, 0, r, a, o, 0, 1, 0, 1, 1, -r, a, o, 0, 1, 0, 0, 1, -r, -a, -o, 0, -1, 0, 0, 1, r, -a, -o, 0, -1, 0, 1, 1, r, -a, o, 0, -1, 0, 1, 0, -r, -a, o, 0, -1, 0, 0, 0, -r, a, -o, -1, 0, 0, 0, 0, -r, a, o, -1, 0, 0, 1, 0, -r, -a, o, -1, 0, 0, 1, 1, -r, -a, -o, -1, 0, 0, 0, 1, r, a, -o, 1, 0, 0, 1, 0, r, a, o, 1, 0, 0, 0, 0, r, -a, o, 1, 0, 0, 0, 1, r, -a, -o, 1, 0, 0, 1, 1, -r, a, o, 0, 0, 1, 0, 0, r, a, o, 0, 0, 1, 1, 0, r, -a, o, 0, 0, 1, 1, 1, -r, -a, o, 0, 0, 1, 0, 1, -r, a, -o, 0, 0, -1, 1, 0, r, a, -o, 0, 0, -1, 0, 0, r, -a, -o, 0, 0, -1, 0, 1, -r, -a, -o, 0, 0, -1, 1, 1]),
                    l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
                return L._createMesh(i, s, l);
            }, L.createCapsule = function(t, e, n, i) {
                void 0 === t && (t = .5), void 0 === e && (e = 2), void 0 === n && (n = 16), void 0 === i && (i = 32);
                var r = (n + 1) * (i + 1) * 2 + 2 * (i + 1),
                    a = 3 * n * (i + 1) * 2 * 2 + 2 * i * 3,
                    o = mt.getVertexDeclaration("POSITION,NORMAL,UV"),
                    s = o.vertexStride / 4,
                    l = new Float32Array(r * s),
                    h = new Uint16Array(a),
                    u = Math.PI / 2 / n,
                    c = 2 * Math.PI / i,
                    _ = e / 2 - t,
                    d = 0,
                    f = 0,
                    m = 0,
                    p = 0,
                    T = 0,
                    E = 0,
                    v = 0,
                    g = 0;
                for (v = 0; v <= n; v++)
                    for (g = 0; g <= i; g++) d = t * Math.cos(v * u) * Math.cos(g * c + Math.PI),
                        f = t * Math.sin(v * u), m = t * Math.cos(v * u) * Math.sin(g * c + Math.PI), l[p++] = d,
                        l[p++] = f + _, l[p++] = m, l[p++] = d, l[p++] = f, l[p++] = m, l[p++] = 1 - g / i,
                        l[p++] = (1 - v / n) * (Math.PI * t / 2 / (e + Math.PI * t)), v < n && (h[T++] = v * (i + 1) + g + (i + 1),
                            h[T++] = v * (i + 1) + g, h[T++] = v * (i + 1) + g + 1, h[T++] = v * (i + 1) + g + i,
                            h[T++] = v * (i + 1) + g, h[T++] = v * (i + 1) + g + (i + 1));
                for (E += (n + 1) * (i + 1), v = 0; v <= n; v++)
                    for (g = 0; g <= i; g++) d = t * Math.cos(v * u) * Math.cos(g * c + Math.PI),
                        f = t * Math.sin(-v * u), m = t * Math.cos(v * u) * Math.sin(g * c + Math.PI), l[p++] = d,
                        l[p++] = f - _, l[p++] = m, l[p++] = d, l[p++] = f, l[p++] = m, l[p++] = 1 - g / i,
                        l[p++] = (v / n * (Math.PI * t / 2) + (e + Math.PI * t / 2)) / (e + Math.PI * t),
                        v < n && (h[T++] = E + v * (i + 1) + g, h[T++] = E + v * (i + 1) + g + (i + 1),
                            h[T++] = E + v * (i + 1) + g + 1, h[T++] = E + v * (i + 1) + g, h[T++] = E + v * (i + 1) + g + i,
                            h[T++] = E + v * (i + 1) + g + (i + 1));
                for (E += (n + 1) * (i + 1), g = 0; g <= i; g++) d = t * Math.cos(g * c + Math.PI),
                    f = _, m = t * Math.sin(g * c + Math.PI), l[p++] = d, l[p + 8 * (i + 1) - 1] = d,
                    l[p++] = f, l[p + 8 * (i + 1) - 1] = -f, l[p++] = m, l[p + 8 * (i + 1) - 1] = m,
                    l[p++] = d, l[p + 8 * (i + 1) - 1] = d, l[p++] = 0, l[p + 8 * (i + 1) - 1] = 0,
                    l[p++] = m, l[p + 8 * (i + 1) - 1] = m, l[p++] = 1 - 1 * g / i, l[p + 8 * (i + 1) - 1] = 1 - 1 * g / i,
                    l[p++] = Math.PI * t / 2 / (e + Math.PI * t), l[p + 8 * (i + 1) - 1] = (Math.PI * t / 2 + e) / (e + Math.PI * t);
                for (g = 0; g < i; g++) h[T++] = g + E + (i + 1), h[T++] = g + E + 1, h[T++] = g + E,
                    h[T++] = g + E + (i + 1), h[T++] = g + E + (i + 1) + 1, h[T++] = g + E + 1;
                return E += 2 * (i + 1), L._createMesh(o, l, h);
            }, L.createCone = function(t, e, n) {
                void 0 === t && (t = .5), void 0 === e && (e = 1), void 0 === n && (n = 32);
                for (var i = n + 1 + 1 + 2 * (n + 1), r = 6 * n + 3 * n, a = mt.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(i * o), l = new Uint16Array(r), h = 2 * Math.PI / n, u = e / 2, c = 0, _ = 0, d = 0, f = 0, m = 0, p = new Ct(), T = new Ct(0, -1, 0), E = new Ct(0, u, 0), v = new Ct(), g = new Ct(), S = new rt(), y = new Ct(), x = NaN, D = 0, I = 0, R = 0; R <= n; R++) c = R * h,
                    d = Math.cos(c + Math.PI) * t, f = u, m = Math.sin(c + Math.PI) * t, s[D++] = 0,
                    s[D + 8 * (n + 1) - 1] = d, s[D++] = f, s[D + 8 * (n + 1) - 1] = -f, s[D++] = 0,
                    s[D + 8 * (n + 1) - 1] = m, p.x = d, p.y = 0, p.z = m, v.x = d, v.y = -f, v.z = m,
                    Ct.subtract(v, E, g), Ct.normalize(g, g), x = Math.acos(Ct.dot(T, g)), Ct.cross(T, g, y),
                    Ct.normalize(y, y), rt.createFromAxisAngle(y, x, S), Ct.normalize(p, p), Ct.transformQuat(p, S, p),
                    Ct.normalize(p, p), s[D++] = p.x, s[D + 8 * (n + 1) - 1] = p.x, s[D++] = p.y, s[D + 8 * (n + 1) - 1] = p.y,
                    s[D++] = p.z, s[D + 8 * (n + 1) - 1] = p.z, s[D++] = 1 - 1 * R / n, s[D + 8 * (n + 1) - 1] = 1 - 1 * R / n,
                    s[D++] = 0, s[D + 8 * (n + 1) - 1] = 1;
                D += 8 * (n + 1);
                for (var M = 0; M < n; M++) l[I++] = M + _ + (n + 1), l[I++] = M + _ + 1, l[I++] = M + _,
                    l[I++] = M + _ + (n + 1), l[I++] = M + _ + (n + 1) + 1, l[I++] = M + _ + 1;
                _ += 2 * (n + 1);
                for (var A = 0; A <= n; A++) 0 === A && (s[D++] = 0, s[D++] = -u, s[D++] = 0, s[D++] = 0,
                        s[D++] = -1, s[D++] = 0, s[D++] = .5, s[D++] = .5), c = A * h, d = Math.cos(c + Math.PI) * t,
                    f = -u, m = Math.sin(c + Math.PI) * t, s[D++] = d, s[D++] = f, s[D++] = m, s[D++] = 0,
                    s[D++] = -1, s[D++] = 0, s[D++] = .5 + .5 * Math.cos(c), s[D++] = .5 + .5 * Math.sin(c);
                for (var C = 0; C < n; C++) l[I++] = 0 + _, l[I++] = C + 2 + _, l[I++] = C + 1 + _;
                return _ += n + 1 + 1, L._createMesh(a, s, l);
            }, L.createCylinder = function(t, e, n) {
                void 0 === t && (t = .5), void 0 === e && (e = 2), void 0 === n && (n = 32);
                for (var i = n + 1 + 1 + 2 * (n + 1) + (n + 1 + 1), r = 3 * n + 6 * n + 3 * n, a = mt.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(i * o), l = new Uint16Array(r), h = 2 * Math.PI / n, u = e / 2, c = 0, _ = 0, d = 0, f = 0, m = 0, p = 0, T = 0, E = 0; E <= n; E++) 0 === E && (s[p++] = 0,
                        s[p++] = u, s[p++] = 0, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5, s[p++] = .5),
                    c = E * h, d = Math.cos(c) * t, f = u, m = Math.sin(c) * t, s[p++] = d, s[p++] = f,
                    s[p++] = m, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5 + .5 * Math.cos(c),
                    s[p++] = .5 + .5 * Math.sin(c);
                for (var v = 0; v < n; v++) l[T++] = 0, l[T++] = v + 1, l[T++] = v + 2;
                _ += n + 1 + 1;
                for (var g = 0; g <= n; g++) c = g * h, d = Math.cos(c + Math.PI) * t, f = u, m = Math.sin(c + Math.PI) * t,
                    s[p++] = d, s[p + 8 * (n + 1) - 1] = d, s[p++] = f, s[p + 8 * (n + 1) - 1] = -f,
                    s[p++] = m, s[p + 8 * (n + 1) - 1] = m, s[p++] = d, s[p + 8 * (n + 1) - 1] = d,
                    s[p++] = 0, s[p + 8 * (n + 1) - 1] = 0, s[p++] = m, s[p + 8 * (n + 1) - 1] = m,
                    s[p++] = 1 - 1 * g / n, s[p + 8 * (n + 1) - 1] = 1 - 1 * g / n, s[p++] = 0, s[p + 8 * (n + 1) - 1] = 1;
                p += 8 * (n + 1);
                for (var S = 0; S < n; S++) l[T++] = S + _ + (n + 1), l[T++] = S + _ + 1, l[T++] = S + _,
                    l[T++] = S + _ + (n + 1), l[T++] = S + _ + (n + 1) + 1, l[T++] = S + _ + 1;
                _ += 2 * (n + 1);
                for (var y = 0; y <= n; y++) 0 === y && (s[p++] = 0, s[p++] = -u, s[p++] = 0, s[p++] = 0,
                        s[p++] = -1, s[p++] = 0, s[p++] = .5, s[p++] = .5), c = y * h, d = Math.cos(c + Math.PI) * t,
                    f = -u, m = Math.sin(c + Math.PI) * t, s[p++] = d, s[p++] = f, s[p++] = m, s[p++] = 0,
                    s[p++] = -1, s[p++] = 0, s[p++] = .5 + .5 * Math.cos(c), s[p++] = .5 + .5 * Math.sin(c);
                for (var x = 0; x < n; x++) l[T++] = 0 + _, l[T++] = x + 2 + _, l[T++] = x + 1 + _;
                return _ += n + 1 + 1, L._createMesh(a, s, l);
            }, L.createPlane = function(t, e, n, i) {
                void 0 === t && (t = 10), void 0 === e && (e = 10), void 0 === n && (n = 10), void 0 === i && (i = 10);
                for (var r = (n + 1) * (i + 1), a = new Uint16Array(n * i * 2 * 3), o = mt.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(r * s), h = t / 2, u = e / 2, c = t / n, _ = e / i, d = 0, f = 0; f <= i; f++)
                    for (var m = 0; m <= n; m++) l[d++] = m * c - h,
                        l[d++] = 0, l[d++] = f * _ - u, l[d++] = 0, l[d++] = 1, l[d++] = 0, l[d++] = 1 * m / n,
                        l[d++] = 1 * f / i;
                var p = 0;
                for (f = 0; f < i; f++)
                    for (m = 0; m < n; m++) a[p++] = (f + 1) * (n + 1) + m,
                        a[p++] = f * (n + 1) + m, a[p++] = (f + 1) * (n + 1) + m + 1, a[p++] = f * (n + 1) + m,
                        a[p++] = f * (n + 1) + m + 1, a[p++] = (f + 1) * (n + 1) + m + 1;
                return L._createMesh(o, l, a);
            }, L.createQuad = function(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = 1);
                var n = mt.getVertexDeclaration("POSITION,NORMAL,UV"),
                    i = (n.vertexStride, t / 2),
                    r = e / 2,
                    a = new Float32Array([-i, r, 0, 0, 0, 1, 0, 0, i, r, 0, 0, 0, 1, 1, 0, -i, -r, 0, 0, 0, 1, 0, 1, i, -r, 0, 0, 0, 1, 1, 1]),
                    o = new Uint16Array([0, 1, 2, 3, 2, 1]);
                return L._createMesh(n, a, o);
            }, L.createSphere = function(t, e, n) {
                void 0 === t && (t = .5), void 0 === e && (e = 32), void 0 === n && (n = 32);
                for (var i = (e + 1) * (n + 1), r = 3 * e * (n + 1) * 2, a = new Uint16Array(r), o = mt.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(i * s), h = Math.PI / e, u = 2 * Math.PI / n, c = 0, _ = r = i = 0; _ < e + 1; _++)
                    for (var d = Math.sin(_ * h), f = Math.cos(_ * h), m = 0; m < n + 1; m++) {
                        var p = d * Math.sin(m * u + 1 * Math.PI / 2),
                            T = d * Math.cos(m * u + 1 * Math.PI / 2);
                        l[i + 0] = p * t, l[i + 1] = f * t, l[i + 2] = T * t, l[i + 3] = p, l[i + 4] = f,
                            l[i + 5] = T, l[i + 6] = m / n, l[i + 7] = _ / e, i += s, _ != e - 1 && (a[r++] = c + (n + 1),
                                a[r++] = c, a[r++] = c + 1, a[r++] = c + n, a[r++] = c, a[r++] = c + (n + 1), c++);
                    }
                return L._createMesh(o, l, a);
            };
        }(), function() {
            function w() {}
            return d(w, "laya.d3.animation.AnimationClipParser04"), w.READ_DATA = function() {
                    w._DATA.offset = w._reader.getUint32(), w._DATA.size = w._reader.getUint32();
                }, w.READ_BLOCK = function() {
                    for (var t = w._BLOCK.count = w._reader.getUint16(), e = w._BLOCK.blockStarts = [], n = w._BLOCK.blockLengths = [], i = 0; i < t; i++) e.push(w._reader.getUint32()),
                        n.push(w._reader.getUint32());
                }, w.READ_STRINGS = function() {
                    var t = w._reader.getUint32(),
                        e = w._reader.getUint16(),
                        n = w._reader.pos;
                    w._reader.pos = t + w._DATA.offset;
                    for (var i = 0; i < e; i++) w._strings[i] = w._reader.readUTFString();
                    w._reader.pos = n;
                }, w.parse = function(t, e, n) {
                    w._animationClip = t, w._reader = e, w._version = n, w.READ_DATA(), w.READ_BLOCK(),
                        w.READ_STRINGS();
                    for (var i = 0, r = w._BLOCK.count; i < r; i++) {
                        var a = e.getUint16(),
                            o = w._strings[a],
                            s = w["READ_" + o];
                        if (null == s) throw new Error("model file err,no this function:" + a + " " + o);
                        s.call();
                    }
                    w._version = null, w._reader = null, w._animationClip = null;
                }, w.READ_ANIMATIONS = function() {
                    var t, e = 0,
                        n = 0,
                        i = w._reader,
                        r = (i.__getBuffer(), []),
                        a = i.getUint16();
                    for (r.length = a, e = 0; e < a; e++) r[e] = i.getFloat32();
                    var o = w._animationClip;
                    o.name = w._strings[i.getUint16()];
                    var s = o._duration = i.getFloat32();
                    o.islooping = !!i.getByte(), o._frameRate = i.getInt16();
                    var l = i.getInt16(),
                        h = o._nodes;
                    h.count = l;
                    var u = o._nodesMap = {},
                        c = o._nodesDic = {};
                    for (e = 0; e < l; e++) {
                        t = new Te(), h.setNodeByIndex(e, t), t._indexInList = e;
                        var _ = t.type = i.getUint8(),
                            d = i.getUint16();
                        for (t._setOwnerPathCount(d), n = 0; n < d; n++) t._setOwnerPathByIndex(n, w._strings[i.getUint16()]);
                        var f = t._joinOwnerPath("/"),
                            m = u[f];
                        m || (u[f] = m = []), m.push(t), t.propertyOwner = w._strings[i.getUint16()];
                        var p = i.getUint16();
                        for (t._setPropertyCount(p), n = 0; n < p; n++) t._setPropertyByIndex(n, w._strings[i.getUint16()]);
                        var T = f + "." + t.propertyOwner + "." + t._joinProperty(".");
                        (c[T] = t).fullPath = T;
                        var E = i.getUint16();
                        t._setKeyframeCount(E);
                        switch (_) {
                            case 0:
                                break;

                            case 1:
                            case 3:
                            case 4:
                                t.data = b.supportWebGLPlusAnimation ? new U() : new Ct();
                                break;

                            case 2:
                                t.data = b.supportWebGLPlusAnimation ? new F() : new rt();
                                break;

                            default:
                                throw "AnimationClipParser04:unknown type.";
                        }
                        switch (w._version) {
                            case "LAYAANIMATION:04":
                                for (n = 0; n < E; n++) switch (_) {
                                    case 0:
                                        var v = new un();
                                        t._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], v.inTangent = i.getFloat32(),
                                            v.outTangent = i.getFloat32(), v.value = i.getFloat32();
                                        break;

                                    case 1:
                                    case 3:
                                    case 4:
                                        var g = new gn();
                                        if (t._setKeyframeByIndex(n, g), g.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                            for (var S = g.data = new Float32Array(9), y = 0; y < 3; y++) S[y] = i.getFloat32();
                                            for (y = 0; y < 3; y++) S[3 + y] = i.getFloat32();
                                            for (y = 0; y < 3; y++) S[6 + y] = i.getFloat32();
                                        } else {
                                            var x = g.inTangent,
                                                D = g.outTangent,
                                                I = g.value;
                                            x.x = i.getFloat32(), x.y = i.getFloat32(), x.z = i.getFloat32(), D.x = i.getFloat32(),
                                                D.y = i.getFloat32(), D.z = i.getFloat32(), I.x = i.getFloat32(), I.y = i.getFloat32(),
                                                I.z = i.getFloat32();
                                        }
                                        break;

                                    case 2:
                                        var R = new Dn();
                                        if (t._setKeyframeByIndex(n, R), R.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                            for (S = R.data = new Float32Array(12), y = 0; y < 4; y++) S[y] = i.getFloat32();
                                            for (y = 0; y < 4; y++) S[4 + y] = i.getFloat32();
                                            for (y = 0; y < 4; y++) S[8 + y] = i.getFloat32();
                                        } else {
                                            var M = R.inTangent,
                                                A = R.outTangent,
                                                C = R.value;
                                            M.x = i.getFloat32(), M.y = i.getFloat32(), M.z = i.getFloat32(), M.w = i.getFloat32(),
                                                A.x = i.getFloat32(), A.y = i.getFloat32(), A.z = i.getFloat32(), A.w = i.getFloat32(),
                                                C.x = i.getFloat32(), C.y = i.getFloat32(), C.z = i.getFloat32(), C.w = i.getFloat32();
                                        }
                                        break;

                                    default:
                                        throw "AnimationClipParser04:unknown type.";
                                }
                                break;

                            case "LAYAANIMATION:COMPRESSION_04":
                                for (n = 0; n < E; n++) switch (_) {
                                    case 0:
                                        v = new un(), t._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], v.inTangent = vt.convertToNumber(i.getUint16()),
                                            v.outTangent = vt.convertToNumber(i.getUint16()), v.value = vt.convertToNumber(i.getUint16());
                                        break;

                                    case 1:
                                    case 3:
                                    case 4:
                                        if (g = new gn(), t._setKeyframeByIndex(n, g), g.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                            for (S = g.data = new Float32Array(9), y = 0; y < 3; y++) S[y] = vt.convertToNumber(i.getUint16());
                                            for (y = 0; y < 3; y++) S[3 + y] = vt.convertToNumber(i.getUint16());
                                            for (y = 0; y < 3; y++) S[6 + y] = vt.convertToNumber(i.getUint16());
                                        } else x = g.inTangent, D = g.outTangent, I = g.value, x.x = vt.convertToNumber(i.getUint16()),
                                            x.y = vt.convertToNumber(i.getUint16()), x.z = vt.convertToNumber(i.getUint16()),
                                            D.x = vt.convertToNumber(i.getUint16()), D.y = vt.convertToNumber(i.getUint16()),
                                            D.z = vt.convertToNumber(i.getUint16()), I.x = vt.convertToNumber(i.getUint16()),
                                            I.y = vt.convertToNumber(i.getUint16()), I.z = vt.convertToNumber(i.getUint16());
                                        break;

                                    case 2:
                                        if (R = new Dn(), t._setKeyframeByIndex(n, R), R.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                            for (S = R.data = new Float32Array(12), y = 0; y < 4; y++) S[y] = vt.convertToNumber(i.getUint16());
                                            for (y = 0; y < 4; y++) S[4 + y] = vt.convertToNumber(i.getUint16());
                                            for (y = 0; y < 4; y++) S[8 + y] = vt.convertToNumber(i.getUint16());
                                        } else M = R.inTangent, A = R.outTangent, C = R.value, M.x = vt.convertToNumber(i.getUint16()),
                                            M.y = vt.convertToNumber(i.getUint16()), M.z = vt.convertToNumber(i.getUint16()),
                                            M.w = vt.convertToNumber(i.getUint16()), A.x = vt.convertToNumber(i.getUint16()),
                                            A.y = vt.convertToNumber(i.getUint16()), A.z = vt.convertToNumber(i.getUint16()),
                                            A.w = vt.convertToNumber(i.getUint16()), C.x = vt.convertToNumber(i.getUint16()),
                                            C.y = vt.convertToNumber(i.getUint16()), C.z = vt.convertToNumber(i.getUint16()),
                                            C.w = vt.convertToNumber(i.getUint16());
                                        break;

                                    default:
                                        throw "AnimationClipParser04:unknown type.";
                                }
                        }
                    }
                    var L = i.getUint16();
                    for (e = 0; e < L; e++) {
                        var O, N = new ee();
                        N.time = Math.min(s, i.getFloat32()), N.eventName = w._strings[i.getUint16()];
                        var V = i.getUint16();
                        for (0 < V && (N.params = O = []), n = 0; n < V; n++) {
                            switch (i.getByte()) {
                                case 0:
                                    O.push(!!i.getByte());
                                    break;

                                case 1:
                                    O.push(i.getInt32());
                                    break;

                                case 2:
                                    O.push(i.getFloat32());
                                    break;

                                case 3:
                                    O.push(w._strings[i.getUint16()]);
                                    break;

                                default:
                                    throw new Error("unknown type.");
                            }
                        }
                        o.addEvent(N);
                    }
                }, w._animationClip = null, w._reader = null, w._strings = [], w._version = null,
                _(w, ["_BLOCK", function() {
                    return this._BLOCK = {
                        count: 0
                    };
                }, "_DATA", function() {
                    return this._DATA = {
                        offset: 0,
                        size: 0
                    };
                }]), w;
        }()),
        bt = function() {
            function w() {}
            return d(w, "laya.d3.animation.AnimationClipParser03"), w.READ_DATA = function() {
                w._DATA.offset = w._reader.getUint32(), w._DATA.size = w._reader.getUint32();
            }, w.READ_BLOCK = function() {
                for (var t = w._BLOCK.count = w._reader.getUint16(), e = w._BLOCK.blockStarts = [], n = w._BLOCK.blockLengths = [], i = 0; i < t; i++) e.push(w._reader.getUint32()),
                    n.push(w._reader.getUint32());
            }, w.READ_STRINGS = function() {
                var t = w._reader.getUint32(),
                    e = w._reader.getUint16(),
                    n = w._reader.pos;
                w._reader.pos = t + w._DATA.offset;
                for (var i = 0; i < e; i++) w._strings[i] = w._reader.readUTFString();
                w._reader.pos = n;
            }, w.parse = function(t, e) {
                w._animationClip = t;
                (w._reader = e).__getBuffer();
                w.READ_DATA(), w.READ_BLOCK(), w.READ_STRINGS();
                for (var n = 0, i = w._BLOCK.count; n < i; n++) {
                    var r = e.getUint16(),
                        a = w._strings[r],
                        o = w["READ_" + a];
                    if (null == o) throw new Error("model file err,no this function:" + r + " " + a);
                    o.call();
                }
            }, w.READ_ANIMATIONS = function() {
                var t, e = 0,
                    n = 0,
                    i = w._reader,
                    r = (i.__getBuffer(), []),
                    a = i.getUint16();
                for (r.length = a, e = 0; e < a; e++) r[e] = i.getFloat32();
                var o = w._animationClip;
                o.name = w._strings[i.getUint16()];
                var s = o._duration = i.getFloat32();
                o.islooping = !!i.getByte(), o._frameRate = i.getInt16();
                var l = i.getInt16(),
                    h = o._nodes;
                h.count = l;
                var u = o._nodesMap = {},
                    c = o._nodesDic = {};
                for (e = 0; e < l; e++) {
                    t = new Te(), h.setNodeByIndex(e, t), t._indexInList = e;
                    var _ = t.type = i.getUint8(),
                        d = i.getUint16();
                    for (t._setOwnerPathCount(d), n = 0; n < d; n++) t._setOwnerPathByIndex(n, w._strings[i.getUint16()]);
                    var f = t._joinOwnerPath("/"),
                        m = u[f];
                    m || (u[f] = m = []), m.push(t), t.propertyOwner = w._strings[i.getUint16()];
                    var p = i.getUint16();
                    for (t._setPropertyCount(p), n = 0; n < p; n++) t._setPropertyByIndex(n, w._strings[i.getUint16()]);
                    var T = f + "." + t.propertyOwner + "." + t._joinProperty(".");
                    (c[T] = t).fullPath = T;
                    var E = i.getUint16();
                    t._setKeyframeCount(E);
                    switch (_) {
                        case 0:
                            break;

                        case 1:
                        case 3:
                        case 4:
                            t.data = b.supportWebGLPlusAnimation ? new U() : new Ct();
                            break;

                        case 2:
                            t.data = b.supportWebGLPlusAnimation ? new F() : new rt();
                            break;

                        default:
                            throw "AnimationClipParser03:unknown type.";
                    }
                    for (n = 0; n < E; n++) switch (_) {
                        case 0:
                            var v = new un();
                            t._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], v.inTangent = i.getFloat32(),
                                v.outTangent = i.getFloat32(), v.value = i.getFloat32();
                            break;

                        case 1:
                        case 3:
                        case 4:
                            var g = new gn();
                            if (t._setKeyframeByIndex(n, g), g.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                for (var S = g.data = new Float32Array(9), y = 0; y < 3; y++) S[y] = i.getFloat32();
                                for (y = 0; y < 3; y++) S[3 + y] = i.getFloat32();
                                for (y = 0; y < 3; y++) S[6 + y] = i.getFloat32();
                            } else {
                                var x = g.inTangent,
                                    D = g.outTangent,
                                    I = g.value;
                                x.x = i.getFloat32(), x.y = i.getFloat32(), x.z = i.getFloat32(), D.x = i.getFloat32(),
                                    D.y = i.getFloat32(), D.z = i.getFloat32(), I.x = i.getFloat32(), I.y = i.getFloat32(),
                                    I.z = i.getFloat32();
                            }
                            break;

                        case 2:
                            var R = new Dn();
                            if (t._setKeyframeByIndex(n, R), R.time = r[i.getUint16()], b.supportWebGLPlusAnimation) {
                                for (S = R.data = new Float32Array(12), y = 0; y < 4; y++) S[y] = i.getFloat32();
                                for (y = 0; y < 4; y++) S[4 + y] = i.getFloat32();
                                for (y = 0; y < 4; y++) S[8 + y] = i.getFloat32();
                            } else {
                                var M = R.inTangent,
                                    A = R.outTangent,
                                    C = R.value;
                                M.x = i.getFloat32(), M.y = i.getFloat32(), M.z = i.getFloat32(), M.w = i.getFloat32(),
                                    A.x = i.getFloat32(), A.y = i.getFloat32(), A.z = i.getFloat32(), A.w = i.getFloat32(),
                                    C.x = i.getFloat32(), C.y = i.getFloat32(), C.z = i.getFloat32(), C.w = i.getFloat32();
                            }
                            break;

                        default:
                            throw "AnimationClipParser03:unknown type.";
                    }
                }
                var L = i.getUint16();
                for (e = 0; e < L; e++) {
                    var O, N = new ee();
                    N.time = Math.min(s, i.getFloat32()), N.eventName = w._strings[i.getUint16()];
                    var V = i.getUint16();
                    for (0 < V && (N.params = O = []), n = 0; n < V; n++) {
                        switch (i.getByte()) {
                            case 0:
                                O.push(!!i.getByte());
                                break;

                            case 1:
                                O.push(i.getInt32());
                                break;

                            case 2:
                                O.push(i.getFloat32());
                                break;

                            case 3:
                                O.push(w._strings[i.getUint16()]);
                                break;

                            default:
                                throw new Error("unknown type.");
                        }
                    }
                    o.addEvent(N);
                }
            }, w._animationClip = null, w._reader = null, w._strings = [], _(w, ["_BLOCK", function() {
                return this._BLOCK = {
                    count: 0
                };
            }, "_DATA", function() {
                return this._DATA = {
                    offset: 0,
                    size: 0
                };
            }]), w;
        }(),
        Ft = function() {
            function t() {
                this.value = 0;
            }
            d(t, "laya.d3.shader.DefineDatas");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.add = function(t) {
                this.value |= t;
            }, e.remove = function(t) {
                this.value &= ~t;
            }, e.has = function(t) {
                return 0 < (this.value & t);
            }, e.cloneTo = function(t) {
                t.value = this.value;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t;
        }(),
        Bt = function() {
            function t(t, e, n) {
                this.offset = 0, this.elementFormat = null, this.elementUsage = 0, this.offset = t,
                    this.elementFormat = e, this.elementUsage = n;
            }
            return d(t, "laya.d3.graphics.VertexElement"), t;
        }(),
        Ut = function() {
            function b(t, e, n, i) {
                this._datas = null, this._w = 0, this._h = 0, this._minHeight = NaN, this._maxHeight = NaN,
                    this._datas = [], this._w = t, this._h = e, this._minHeight = n, this._maxHeight = i;
            }
            d(b, "laya.d3.core.HeightMap");
            var t = b.prototype;
            return t._inBounds = function(t, e) {
                return 0 <= t && t < this._h && 0 <= e && e < this._w;
            }, t.getHeight = function(t, e) {
                return this._inBounds(t, e) ? this._datas[t][e] : NaN;
            }, u(0, t, "width", function() {
                return this._w;
            }), u(0, t, "height", function() {
                return this._h;
            }), u(0, t, "maxHeight", function() {
                return this._maxHeight;
            }), u(0, t, "minHeight", function() {
                return this._minHeight;
            }), b.creatFromMesh = function(t, e, n, i) {
                for (var r = [], a = [], o = t.subMeshCount, s = 0; s < o; s++) {
                    for (var l = t._getSubMesh(s), h = l._vertexBuffer, u = h.getData(), c = [], _ = 0; _ < u.length; _ += h.vertexDeclaration.vertexStride / 4) {
                        var d = new Ct(u[_ + 0], u[_ + 1], u[_ + 2]);
                        c.push(d);
                    }
                    r.push(c);
                    var f = l._indexBuffer;
                    a.push(f.getData());
                }
                var m = t.boundingBox,
                    p = m.min.x,
                    T = m.min.z,
                    E = m.max.x,
                    v = m.max.z,
                    g = m.min.y,
                    S = m.max.y,
                    y = E - p,
                    x = v - T,
                    D = i.x = y / (e - 1),
                    I = i.y = x / (n - 1),
                    R = new b(e, n, g, S),
                    M = b._tempRay,
                    A = M.direction;
                A.x = 0, A.y = -1, A.z = 0;
                var C = S + .1;
                M.origin.y = C;
                for (var L = 0; L < n; L++) {
                    var O = T + L * I;
                    R._datas[L] = [];
                    for (var N = 0; N < e; N++) {
                        var V = p + N * D,
                            w = M.origin;
                        w.x = V, w.z = O;
                        var P = b._getPosition(M, r, a);
                        R._datas[L][N] = P === Number.MAX_VALUE ? NaN : C - P;
                    }
                }
                return R;
            }, b.createFromImage = function(t, e, n) {
                for (var i = t.width, r = t.height, a = new b(i, r, e, n), o = (n - e) / 254, s = t.getPixels(), l = 0, h = 0; h < r; h++)
                    for (var u = a._datas[h] = [], c = 0; c < i; c++) {
                        var _ = s[l++],
                            d = s[l++],
                            f = s[l++],
                            m = s[l++];
                        u[c] = 255 == _ && 255 == d && 255 == f && 255 == m ? NaN : (_ + d + f) / 3 * o + e;
                    }
                return a;
            }, b._getPosition = function(t, e, n) {
                for (var i = Number.MAX_VALUE, r = 0; r < e.length; r++)
                    for (var a = e[r], o = n[r], s = 0; s < o.length; s += 3) {
                        var l = a[o[s + 0]],
                            h = a[o[s + 1]],
                            u = a[o[s + 2]],
                            c = se.rayIntersectsTriangle(t, l, h, u);
                        !isNaN(c) && c < i && (i = c);
                    }
                return i;
            }, _(b, ["_tempRay", function() {
                return this._tempRay = new X(new Ct(), new Ct());
            }]), b;
        }(),
        zt = function() {
            function s() {}
            return d(s, "laya.d3.shader.ShaderInit3D"), s.__init__ = function() {
                var t, e;
                (s._rangeAttenTex = Gt._buildTexture2D(1024, 1, 2, St.lightAttenTexture)).wrapModeU = 1,
                    s._rangeAttenTex.wrapModeV = 1, s._rangeAttenTex.lock = !0, Vt.SHADERDEFINE_HIGHPRECISION = Vt.registerPublicDefine("HIGHPRECISION"),
                    Gn.SHADERDEFINE_FOG = Vt.registerPublicDefine("FOG"), Gn.SHADERDEFINE_DIRECTIONLIGHT = Vt.registerPublicDefine("DIRECTIONLIGHT"),
                    Gn.SHADERDEFINE_POINTLIGHT = Vt.registerPublicDefine("POINTLIGHT"), Gn.SHADERDEFINE_SPOTLIGHT = Vt.registerPublicDefine("SPOTLIGHT"),
                    Gn.SHADERDEFINE_CAST_SHADOW = Vt.registerPublicDefine("CASTSHADOW"), Gn.SHADERDEFINE_SHADOW_PSSM1 = Vt.registerPublicDefine("SHADOWMAP_PSSM1"),
                    Gn.SHADERDEFINE_SHADOW_PSSM2 = Vt.registerPublicDefine("SHADOWMAP_PSSM2"), Gn.SHADERDEFINE_SHADOW_PSSM3 = Vt.registerPublicDefine("SHADOWMAP_PSSM3"),
                    Gn.SHADERDEFINE_SHADOW_PCF_NO = Vt.registerPublicDefine("SHADOWMAP_PCF_NO"), Gn.SHADERDEFINE_SHADOW_PCF1 = Vt.registerPublicDefine("SHADOWMAP_PCF1"),
                    Gn.SHADERDEFINE_SHADOW_PCF2 = Vt.registerPublicDefine("SHADOWMAP_PCF2"), Gn.SHADERDEFINE_SHADOW_PCF3 = Vt.registerPublicDefine("SHADOWMAP_PCF3"),
                    Gn.SHADERDEFINE_REFLECTMAP = Vt.registerPublicDefine("REFLECTMAP"), Vt.addInclude("Lighting.glsl", "\nstruct DirectionLight {\n\tvec3 Color;\n\tvec3 Direction;\n};\n\nstruct PointLight {\n\tvec3 Color;\n\tvec3 Position;\n\tfloat Range;\n};\n\nstruct SpotLight {\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n\tfloat Spot;\n\tfloat Range;\n};\n\n// Laya中使用衰减纹理\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\n\tfRatio *= fRatio;\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\n}\n\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\n\tvec3 distance = L * invLightRadius;\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\n\treturn attenuation * attenuation;\n}\n\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\n\tfloat attenuationFactor = 30.0;\n\tvec3 distance = L * invLightRadius;\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\n\tattenuation /= 1.0 - attenuationFactor;\n\treturn attenuation;\n}\n\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\n\tmediump vec3 h = normalize(viewDir-lightVec);\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\n\tfloat nh = max (0.0, dot (h,normal));\n\tdiffuseColor=lightColor * ln;\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\n}\n\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec=normalize(light.Direction);\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\n}\n\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec =  pos-light.Position;\n\t//if( length(lightVec) > light.Range )\n\t//\treturn;\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\n\tdiffuseColor *= attenuate;\n\tspecularColor*= attenuate;\n}\n\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec =  pos-light.Position;\n\t//if( length(lightVec) > light.Range)\n\t//\treturn;\n\n\tvec3 normalLightVec=lightVec/length(lightVec);\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\n\tvec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\n\tfloat dl=dot(normalize(light.Direction),normalLightVec);\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\n\tdiffuseColor *=attenuate;\n\tspecularColor *=attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\n\n\t// Build orthonormal basis.\n\tvec3 N = normalize(unitNormal);\n\tvec3 T = normalize(tangent);\n\tvec3 B = normalize(binormal);\n\tmat3 TBN = mat3(T, B, N);\n\n\t// Transform from tangent space to world space.\n\tvec3 bumpedNormal = TBN*normalT;\n\n\treturn bumpedNormal;\n}\n\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\n\tvec3 normalT;\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n\n\tvec3 T = normalize(tangent);\n\tvec3 B = normalize(binormal);\n\tvec3 N = normalize(unitNormal);\n\tmat3 TBN = mat3(T, B, N);\n\n\t// Transform from tangent space to world space.\n\tvec3 bumpedNormal = TBN * normalize(normalT);\n\n\treturn bumpedNormal;\n}\n\nvec3 DecodeLightmap(vec4 color) {\n\treturn color.rgb*color.a*5.0;\n}\n\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\n\ttransTexcoord.y+=1.0;\n\treturn transTexcoord;\n}\n\nvec4 remapGLPositionZ(vec4 position) {\n\tposition.z=position.z * 2.0 - position.w;\n\treturn position;\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\n"),
                    Vt.addInclude("ShadowHelper.glsl", "uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2\t  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n\tres -= res.xxyz * bitMask;\n\treturn res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n\tvec2 texelpos =texcoord / invsize;\n\tvec2 lerps = fract( texelpos );\n\tfloat sourcevals[4];\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tint nPSNum = int(posViewZ>pssmDistance.x);\n\tnPSNum += int(posViewZ>pssmDistance.y);\n\tnPSNum += int(posViewZ>pssmDistance.z);\n\t//真SB,webgl不支持在PS中直接访问数组\n\tmat4 lightVP;\n\tif( nPSNum == 0 )\n\t{\n\t\tlightVP = lightShadowVP[1];\n\t}\n\telse if( nPSNum == 1 )\n\t{\n\t\tlightVP = lightShadowVP[2];\n\t}\n\telse if( nPSNum == 2 )\n\t{\n\t\tlightVP = lightShadowVP[3];\n\t}\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n\t//为了效率，在CPU计算/2.0 + 0.5\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n\tfloat fMyZ = vText.z - zBias;\n\t/*\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\tbool bInFrustum = all( bInFrustumVec );\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\tbool bFrustumTest = all( bFrustumTestVec );\n\tif ( bFrustumTest ) \n\t*/\n\tif( fMyZ <= 1.0 )\n\t{\n\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue = value/4.0;\n\t\t} \n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF2\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n\t\tvec4 color;\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\n\t\t}\n\t\tzdepth = unpackDepth(color);\n\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t}\n\treturn value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tint nPSNum = int(posViewZ>pssmDistance.x);\n\tnPSNum += int(posViewZ>pssmDistance.y);\n\t//真SB,webgl不支持在PS中直接访问数组\n\tmat4 lightVP;\n\tif( nPSNum == 0 )\n\t{\n\t\tlightVP = lightShadowVP[1];\n\t}\n\telse if( nPSNum == 1 )\n\t{\n\t\tlightVP = lightShadowVP[2];\n\t}\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n\t//为了效率，在CPU计算/2.0 + 0.5\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n\tfloat fMyZ = vText.z - zBias;\n\t/*\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\tbool bInFrustum = all( bInFrustumVec );\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\tbool bFrustumTest = all( bFrustumTestVec );\n\tif ( bFrustumTest ) \n\t*/\n\tif( fMyZ <= 1.0 )\n\t{\n\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue = value/4.0;\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF2\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n\t\tvec4 color;\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\n\t\t}\n\t\tzdepth = unpackDepth(color);\n\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t}\n\treturn value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tif( posViewZ < pssmDistance.x )\n\t{\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n\t\tfloat fMyZ = vText.z - zBias;\n\t\t/*\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\t\tbool bInFrustum = all( bInFrustumVec );\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\t\tbool bFrustumTest = all( bFrustumTestVec );\n\t\t*/\n\t\tif ( fMyZ <= 1.0 ) \n\t\t{\n\t\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n\t\t\tvalue = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2\t\t\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO\t\t\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t\t}\n\t}\n\treturn value;\n}"),
                    Vt.addInclude("BRDF.glsl", "struct LayaGI\n{\n\tvec3 diffuse;\n\tvec3 specular;\n};\n\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n\tvec3 halfDir = SafeNormalize(viewDir - lightDir);\n\t\n\tfloat nv = abs(dot(normal, viewDir));\n\t\n\tfloat nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\n\tfloat nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\n\tfloat lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\n\tfloat lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\n\t\n\tfloat diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n\t\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n\t\n\t//#if UNITY_BRDF_GGX\n\tfloat V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\n\tfloat D = GGXTerm(nh, roughness);\n\t\n\tfloat specularTerm = V * D * PI;\n\t\n\tspecularTerm = sqrt(max(0.0001, specularTerm));\n\tspecularTerm = max(0.0, specularTerm * nl);\n\t\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\n\t\n\tvec4 color;\n\tcolor.rgb = diffuseColor * (gi.diffuse + lightColor * diffuseTerm) \n\t\t\t  + specularTerm * lightColor * FresnelTerm (specularColor, lh)\n\t\t\t  + surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\n\t\n\treturn color;\n}"),
                    Vt.addInclude("PBRUtils.glsl", "struct DirectionLight\n{\n\tvec3 Color;\n\tvec3 Direction;\n};\n\nstruct PointLight\n{\n\tvec3 Color;\n\tvec3 Position;\n\tfloat Range;\n};\n\nstruct SpotLight\n{\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n\tfloat SpotAngle;\n\tfloat Range;\n};\n\nvec3 UnpackScaleNormal(in vec2 uv0)\n{\n\t#ifdef NORMALTEXTURE\n\t\tvec3 normalT;\n\t\tvec4 normalMapSample = texture2D(u_NormalTexture, uv0);\n\t\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\n\t\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\n\t\tnormalT.xy *= u_normalScale;\n\t\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n\t\t\n\t\tvec3 T = normalize(v_Tangent);\n\t\tvec3 B = normalize(v_Binormal);\n\t\tvec3 N = normalize(v_Normal);\n\t\tmat3 TBN = mat3(T, B, N);\n\t\t\n\t\tvec3 bumpedNormal = TBN * normalize(normalT);\n\t\treturn bumpedNormal;\n\t#else\n\t\treturn normalize(v_Normal);\n\t#endif\n}\n\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\n\nfloat PI = 3.14159265359;\n\nvec3 FresnelTerm (in vec3 F0, in float cosA)\n{\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\n}\n\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);\n    return mix(F0, F90, t);\n}\n\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\n{\n\treturn perceptualRoughness * perceptualRoughness;\n}\n\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\n{\n\tfloat m = PerceptualRoughnessToRoughness(perceptualRoughness);\n\tfloat sq = max(0.0001, m * m);\n\tfloat n = (2.0 / sq) - 2.0;\n\tn = max(n, 0.0001);\n\treturn n;\n}\n\nfloat RoughnessToPerceptualRoughness(in float roughness)\n{\n\treturn sqrt(roughness);\n}\n\nfloat SmoothnessToRoughness(in float smoothness)\n{\n\treturn (1.0 - smoothness) * (1.0 - smoothness);\n}\n\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\n{\n\treturn (1.0 - smoothness);\n}\n\nvec3 SafeNormalize(in vec3 inVec)\n{\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\n\treturn inVec * (1.0 / sqrt(dp3));\n}\n\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\n{\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n\tfloat lightScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\n\tfloat viewScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\n\n\treturn lightScatter * viewScatter;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n\tfloat a = roughness;\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n\treturn 0.5 / (lambdaV + lambdaL + 0.00001);\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n\treturn 0.31830988618 * a2 / (d * d + 0.0000001);\n}\n\nfloat OneMinusReflectivityFromMetallic(in float metallic)\n{\n\tfloat oneMinusDielectricSpec = DielectricSpecularColor.a;\n\treturn oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nfloat SpecularStrength(vec3 specular)\n{\n    //(SHADER_TARGET < 30)return specular.r; \n    return max (max (specular.r, specular.g), specular.b);\n}\n\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\n{\n\tspecularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\n\toneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n\treturn diffuseColor * oneMinusReflectivity;\n}\n\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\n{\n\toneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\n\treturn diffuseColor * oneMinusReflectivity;\n}\n\nvec4 Occlusion(in vec2 uv0){\n\t#ifdef OCCLUSIONTEXTURE\n\t\tvec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\n\t\tfloat occ = occlusionTextureColor.g;\n\t\tfloat oneMinusT = 1.0 - u_occlusionStrength;\n\t\tfloat lerpOneTo = oneMinusT + occ * u_occlusionStrength;\n\t\treturn occlusionTextureColor * lerpOneTo;\n\t#else\n\t\treturn vec4(1.0);\n\t#endif\n}\n\nvec2 ParallaxOffset(in vec3 viewDir){\n\t#ifdef PARALLAXTEXTURE\n\t\tfloat h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\n\t\th = h * u_parallaxScale - u_parallaxScale / 2.0;\n\t\tvec3 v = viewDir;\n\t\tv.z += 0.42;\n\t\tvec2 offset = h * (v.xy / v.z);\n\t\treturn v_Texcoord0 + offset;\n\t#else\n\t\treturn v_Texcoord0;\n\t#endif\n}\n\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\n\t#ifdef REFLECTMAP\n\t\tvec3 incident = -viewDir;\n\t\tvec3 reflectionVector = reflect(incident, normal);\n\t\tvec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\n\t\treturn reflectionColor * u_ReflectIntensity;\n\t#else\n\t\treturn vec3(0.0);\n\t#endif\n}\n\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\n{\n\tfloat fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\n\tfRatio *= fRatio;\n\treturn 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\n}\n\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\n{\n\t#ifdef ALPHAPREMULTIPLY\n\t\tdiffColor *= alpha;\n\t\toutModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\n\t#else\n\t\toutModifiedAlpha = alpha;\n\t#endif\n\treturn diffColor;\n}\n\n"),
                    Vt.addInclude("PBRStandardLighting.glsl", '#include "PBRUtils.glsl"\n#include "BRDF.glsl"\n\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat oneMinusReflectivity;\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat alpha;\n\t\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\n\t\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n\t\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n\tcolor.a = alpha;\n\treturn color;\n}\n\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n\tvec3 lightVec = normalize(light.Direction);\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n\tfloat distance = dot(lightCoord, lightCoord);\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n\tvec3 lightVec = normalize(pos - light.Position);\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightVec =  pos - light.Position;\n\tvec3 normalLightVec = normalize(lightVec);\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//\t\n//\tfloat distance = dot(lightCoord, lightCoord);\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//\tvec3 lightVec = normalize(pos - light.Position);\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\n{\n\tvec2 mg;\n\t\n\t#ifdef METALLICGLOSSTEXTURE\n\t\tvec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tmg.r = metallicGlossTextureColor.r;\n\t\t\tmg.g = albedoTextureAlpha;\n\t\t#else\n\t\t    mg = metallicGlossTextureColor.ra;\n\t\t#endif\n\t\tmg.g *= u_smoothnessScale;\n\t#else\n\t\tmg.r = u_metallic;\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tmg.g = albedoTextureAlpha * u_smoothnessScale;\n\t\t#else\n\t\t\tmg.g = u_smoothness;\n\t\t#endif\n\t#endif\n\t\n\treturn mg;\n}\n\n'),
                    Vt.addInclude("PBRSpecularLighting.glsl", '#include "PBRUtils.glsl"\n#include "BRDF.glsl"\n\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat oneMinusReflectivity;\n\tvec3 diffuseColor;\n\tfloat alpha;\n\t\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\n\t\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n\t\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n\tcolor.a = alpha;\n\treturn color;\n}\n\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n\tvec3 lightVec = normalize(light.Direction);\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n\tfloat distance = dot(lightCoord, lightCoord);\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n\tvec3 lightVec = normalize(pos - light.Position);\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightVec =  pos - light.Position;\n\tvec3 normalLightVec = normalize(lightVec);\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//\t\n//\tfloat distance = dot(lightCoord, lightCoord);\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//\tvec3 lightVec = normalize(pos - light.Position);\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\n{\n    vec4 sg;\n\t\n\t#ifdef SPECULARTEXTURE\n\t\tvec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tsg.rgb = specularTextureColor.rgb;\n\t\t\tsg.a = albedoTextureAlpha;\n\t\t#else\n\t\t\tsg = specularTextureColor;\n\t\t#endif\n\t\tsg.a *= u_smoothnessScale;\n\t#else\n\t\tsg.rgb = u_SpecularColor.rgb;\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tsg.a = albedoTextureAlpha * u_smoothnessScale;\n\t\t#else\n\t\t\tsg.a = u_smoothness;\n\t\t#endif\n\t#endif\n\t\n    return sg;\n}\n\n');
                var n = {
                        a_Position: 0,
                        a_Color: 1,
                        a_Normal: 3,
                        a_Texcoord0: 2,
                        a_Texcoord1: 7,
                        a_BoneWeights: 6,
                        a_BoneIndices: 5,
                        a_Tangent0: 4,
                        a_MvpMatrix: 12,
                        a_WorldMat: 8
                    },
                    i = {
                        u_Bones: 0,
                        u_DiffuseTexture: 1,
                        u_SpecularTexture: 1,
                        u_NormalTexture: 1,
                        u_AlphaTestValue: 1,
                        u_DiffuseColor: 1,
                        u_MaterialSpecular: 1,
                        u_Shininess: 1,
                        u_TilingOffset: 1,
                        u_WorldMat: 2,
                        u_MvpMatrix: 2,
                        u_LightmapScaleOffset: 2,
                        u_LightMap: 2,
                        u_CameraPos: 3,
                        u_ReflectTexture: 4,
                        u_ReflectIntensity: 4,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4,
                        "u_DirectionLight.Color": 4,
                        "u_DirectionLight.Direction": 4,
                        "u_PointLight.Position": 4,
                        "u_PointLight.Range": 4,
                        "u_PointLight.Color": 4,
                        "u_SpotLight.Position": 4,
                        "u_SpotLight.Direction": 4,
                        "u_SpotLight.Range": 4,
                        "u_SpotLight.Spot": 4,
                        "u_SpotLight.Color": 4,
                        u_AmbientColor: 4,
                        u_shadowMap1: 4,
                        u_shadowMap2: 4,
                        u_shadowMap3: 4,
                        u_shadowPSSMDistance: 4,
                        u_lightShadowVP: 4,
                        u_shadowPCFoffset: 4
                    },
                    r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    };
                t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\n\tattribute vec2 a_Texcoord0;\n\tvarying vec2 v_Texcoord0;\n#endif\n\n#if defined(LIGHTMAP)&&defined(UV1)\n\tattribute vec2 a_Texcoord1;\n#endif\n\n#ifdef LIGHTMAP\n\tuniform vec4 u_LightmapScaleOffset;\n\tvarying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\n\tattribute vec4 a_Color;\n\tvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tattribute vec3 a_Normal;\n\tvarying vec3 v_Normal; \n\tuniform vec3 u_CameraPos;\n\tvarying vec3 v_ViewDir; \n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\tattribute vec4 a_Tangent0;\n\tvarying vec3 v_Tangent;\n\tvarying vec3 v_Binormal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t#ifdef GPU_INSTANCE\n\t\tattribute mat4 a_WorldMat;\n\t#else\n\t\tuniform mat4 u_WorldMat;\n\t#endif\n\tvarying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n\t\t#ifdef TILINGOFFSET\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t\t#else\n\t\t\tv_Texcoord0=a_Texcoord0;\n\t\t#endif\n\t#endif\n\n\t#ifdef LIGHTMAP\n\t\t#ifdef SCALEOFFSETLIGHTINGMAPUV\n\t\t\t#ifdef UV1\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n\t\t\t#else\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n\t\t\t#endif \n\t\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\n\t\t#else\n\t\t\t#ifdef UV1\n\t\t\t\tv_LightMapUV=a_Texcoord1;\n\t\t\t#else\n\t\t\t\tv_LightMapUV=a_Texcoord0;\n\t\t\t#endif \n\t\t#endif \n\t#endif\n\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tv_Color=a_Color;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}',
                    e = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\nuniform vec4 u_DiffuseColor;\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\tvarying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tvarying vec3 v_ViewDir; \n#endif\n\n#ifdef ALPHATEST\n\tuniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\n\tuniform sampler2D u_DiffuseTexture;\n#endif\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n\tvarying vec2 v_Texcoord0;\n#endif\n\n#ifdef LIGHTMAP\n\tvarying vec2 v_LightMapUV;\n\tuniform sampler2D u_LightMap;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tuniform vec3 u_MaterialSpecular;\n\tuniform float u_Shininess;\n\t#ifdef SPECULARMAP \n\t\tuniform sampler2D u_SpecularTexture;\n\t#endif\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\tuniform sampler2D u_NormalTexture;\n\tvarying vec3 v_Tangent;\n\tvarying vec3 v_Binormal;\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#include "ShadowHelper.glsl"\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\nvoid main_castShadow()\n{\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\nvoid main_normal()\n{\n\tvec3 globalDiffuse=u_AmbientColor;\n\t#ifdef LIGHTMAP\t\n\t\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tvec3 normal;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\t\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\n\t\t#else\n\t\t\tnormal = normalize(v_Normal);\n\t\t#endif\n\t\tvec3 viewDir= normalize(v_ViewDir);\n\t#endif\n\t\n\tvec4 mainColor=u_DiffuseColor;\n\t#ifdef DIFFUSEMAP\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n\t\tmainColor=mainColor*difTexColor;\n\t#endif \n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tmainColor=mainColor*v_Color;\n\t#endif \n    \n\t#ifdef ALPHATEST\n\t\tif(mainColor.a<u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n  \n\t\n\tvec3 diffuse = vec3(0.0);\n\tvec3 specular= vec3(0.0);\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tvec3 dif,spe;\n\t\t#ifdef SPECULARMAP\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n\t\t#else\n\t\t\t#ifdef DIFFUSEMAP\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\n\t\t\t#else\n\t\t\t\tvec3 gloss=vec3(1.0);\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n\n\t#ifdef SPOTLIGHT\n\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\n\t#else\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\t#ifdef RECEIVESHADOW\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\n\t\t#else\n\t\t\tgl_FragColor.rgb+=specular;\n\t\t#endif\n\t#endif\n\t  \n\t#ifdef FOG\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}\n\n';
                var a = Vt.add("BLINNPHONG", !0),
                    o = new re(n, i, fi.shaderDefines, ei.shaderDefines);
                a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_Color: 1
                    }, i = {
                        u_MvpMatrix: 2,
                        u_Color: 1
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n\tgl_Position = u_MvpMatrix * a_Position;\n\tv_Color=a_Color;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}',
                    e = "#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nuniform vec4 u_Color;\n\nvoid main()\n{\n  gl_FragColor = v_Color * u_Color; \n}\n\n",
                    a = Vt.add("LineShader"), o = new re(n, i), a.addSubShader(o), o.addShaderPass(t, e),
                    n = {
                        a_Position: 0,
                        a_Normal: 3,
                        a_Tangent0: 4,
                        a_Texcoord0: 2,
                        a_BoneWeights: 6,
                        a_BoneIndices: 5,
                        a_MvpMatrix: 12,
                        a_WorldMat: 8
                    }, i = {
                        u_Bones: 0,
                        u_MvpMatrix: 2,
                        u_WorldMat: 2,
                        u_CameraPos: 3,
                        u_AlphaTestValue: 1,
                        u_AlbedoColor: 1,
                        u_EmissionColor: 1,
                        u_AlbedoTexture: 1,
                        u_NormalTexture: 1,
                        u_ParallaxTexture: 1,
                        u_MetallicGlossTexture: 1,
                        u_OcclusionTexture: 1,
                        u_EmissionTexture: 1,
                        u_metallic: 1,
                        u_smoothness: 1,
                        u_smoothnessScale: 1,
                        u_occlusionStrength: 1,
                        u_normalScale: 1,
                        u_parallaxScale: 1,
                        u_TilingOffset: 1,
                        "u_DirectionLight.Direction": 4,
                        "u_DirectionLight.Color": 4,
                        u_PointLightMatrix: 4,
                        "u_PointLight.Position": 4,
                        "u_PointLight.Range": 4,
                        "u_PointLight.Color": 4,
                        "u_SpotLight.Position": 4,
                        "u_SpotLight.Direction": 4,
                        "u_SpotLight.Range": 4,
                        "u_SpotLight.SpotAngle": 4,
                        "u_SpotLight.Color": 4,
                        u_RangeTexture: 4,
                        u_ReflectTexture: 4,
                        u_ReflectIntensity: 4,
                        u_AmbientColor: 4,
                        u_shadowMap1: 4,
                        u_shadowMap2: 4,
                        u_shadowMap3: 4,
                        u_shadowPSSMDistance: 4,
                        u_lightShadowVP: 4,
                        u_shadowPCFoffset: 4,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_WorldMat;\n#else\n\tuniform mat4 u_WorldMat;\n#endif\n\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n\t  varying vec4 v_lightMVPPos;\n\t  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t \n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0 = a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\t\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n  \n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}',
                    e = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef METALLICGLOSSTEXTURE\n\tuniform sampler2D u_MetallicGlossTexture;\n#endif\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n\tuniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n\tuniform sampler2D u_ParallaxTexture;\n\tuniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n\tuniform sampler2D u_OcclusionTexture;\n\tuniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n\t#ifdef EMISSIONTEXTURE\n\t\tuniform sampler2D u_EmissionTexture;\n\t#endif\n\tuniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n\tuniform samplerCube u_ReflectTexture;\n\tuniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include "PBRStandardLighting.glsl"\n#include "ShadowHelper.glsl"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\n\nvoid main_normal()\n{\t\n\tvec3 viewDir = normalize(v_ViewDir);\n\t\n\tvec2 uv0 = ParallaxOffset(viewDir);\n\t\n\tvec2 mg;\n\tvec4 albedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tvec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\n\t\talbedoColor = abledoTextureColor * u_AlbedoColor;\n\t\tmg = MetallicGloss(abledoTextureColor.a, uv0);\n\t#else\n\t\talbedoColor = u_AlbedoColor;\n\t\tmg = MetallicGloss(1.0, uv0);\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(albedoColor.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n\t\n\tvec3 normal = UnpackScaleNormal(uv0);\n  \n\tLayaGI gi;\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n\tgi.specular = ReflectCubeMap(viewDir, normal);\n  \n\tvec4 color = vec4(0.0);\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tcolor += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef SPOTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef EMISSION\n\t\tvec4 emissionColor = u_EmissionColor;\n\t\t#ifdef EMISSIONTEXTURE\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\n\t\t#endif\n\t\tcolor.rgb += emissionColor.rgb;\n\t#endif\n\t\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\n\t#else\n\t\tgl_FragColor = color;\n\t#endif\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}',
                    a = Vt.add("PBRStandard", !0), o = new re(n, i, fi.shaderDefines, qn.shaderDefines),
                    a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_Normal: 3,
                        a_Tangent0: 4,
                        a_Texcoord0: 2,
                        a_BoneWeights: 6,
                        a_BoneIndices: 5,
                        a_MvpMatrix: 12,
                        a_WorldMat: 8
                    }, i = {
                        u_Bones: 0,
                        u_MvpMatrix: 2,
                        u_WorldMat: 2,
                        u_CameraPos: 3,
                        u_AlphaTestValue: 1,
                        u_AlbedoColor: 1,
                        u_SpecularColor: 1,
                        u_EmissionColor: 1,
                        u_AlbedoTexture: 1,
                        u_NormalTexture: 1,
                        u_ParallaxTexture: 1,
                        u_SpecularTexture: 1,
                        u_OcclusionTexture: 1,
                        u_EmissionTexture: 1,
                        u_smoothness: 1,
                        u_smoothnessScale: 1,
                        u_occlusionStrength: 1,
                        u_normalScale: 1,
                        u_parallaxScale: 1,
                        u_TilingOffset: 1,
                        "u_DirectionLight.Direction": 4,
                        "u_DirectionLight.Color": 4,
                        u_PointLightMatrix: 4,
                        "u_PointLight.Position": 4,
                        "u_PointLight.Range": 4,
                        "u_PointLight.Color": 4,
                        "u_SpotLight.Position": 4,
                        "u_SpotLight.Direction": 4,
                        "u_SpotLight.Range": 4,
                        "u_SpotLight.SpotAngle": 4,
                        "u_SpotLight.Color": 4,
                        u_RangeTexture: 4,
                        u_ReflectTexture: 4,
                        u_ReflectIntensity: 4,
                        u_AmbientColor: 4,
                        u_shadowMap1: 4,
                        u_shadowMap2: 4,
                        u_shadowMap3: 4,
                        u_shadowPSSMDistance: 4,
                        u_lightShadowVP: 4,
                        u_shadowPCFoffset: 4,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_WorldMat;\n#else\n\tuniform mat4 u_WorldMat;\n#endif\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n\t  varying vec4 v_lightMVPPos;\n\t  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t \n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0 = a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\t\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n  \n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}',
                    e = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\nuniform vec4 u_SpecularColor;\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef SPECULARTEXTURE\n\tuniform sampler2D u_SpecularTexture;\n#endif\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n\tuniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n\tuniform sampler2D u_ParallaxTexture;\n\tuniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n\tuniform sampler2D u_OcclusionTexture;\n\tuniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n\t#ifdef EMISSIONTEXTURE\n\t\tuniform sampler2D u_EmissionTexture;\n\t#endif\n\tuniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n\tuniform samplerCube u_ReflectTexture;\n\tuniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include "PBRSpecularLighting.glsl"\n#include "ShadowHelper.glsl"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\n\nvoid main_normal()\n{\t\n\tvec3 viewDir = normalize(v_ViewDir);\n\t\n\tvec2 uv0 = ParallaxOffset(viewDir);\n\t\n\tvec4 sg;\n\tvec4 albedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tvec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\n\t\talbedoColor = albedoTextureColor * u_AlbedoColor;\n\t\tsg = SpecularGloss(albedoTextureColor.a, uv0);\n\t#else\n\t\talbedoColor = u_AlbedoColor;\n\t\tsg = SpecularGloss(1.0, uv0);\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(albedoColor.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n  \n\tvec3 normal = UnpackScaleNormal(uv0);\n\t\n\tLayaGI gi;\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n\tgi.specular = ReflectCubeMap(viewDir, normal);\n\t\n\t//float a = (sg.r+sg.g+sg.b) / 3.0;\n  \n\tvec4 color = vec4(0.0);\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tcolor += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef SPOTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef EMISSION\n\t\tvec4 emissionColor = u_EmissionColor;\n\t\t#ifdef EMISSIONTEXTURE\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\n\t\t#endif\n\t\tcolor.rgb += emissionColor.rgb;\n\t#endif\n\t\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\n\t#else\n\t\tgl_FragColor = color;\n\t#endif\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}\n\n',
                    a = Vt.add("PBRSpecular", !0), o = new re(n, i, fi.shaderDefines, ri.shaderDefines),
                    a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_Color: 1,
                        a_Texcoord0: 2,
                        a_BoneWeights: 6,
                        a_BoneIndices: 5,
                        a_MvpMatrix: 12
                    }, i = {
                        u_Bones: 0,
                        u_AlbedoTexture: 1,
                        u_AlbedoColor: 1,
                        u_TilingOffset: 1,
                        u_AlphaTestValue: 1,
                        u_MvpMatrix: 2,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\n\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\nattribute vec4 a_Color;\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main() {\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tv_Color = a_Color;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}',
                    e = "#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\tvarying vec4 v_Color;\n#endif\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n\tvarying vec2 v_Texcoord0;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALPHATEST\n\tuniform float u_AlphaTestValue;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\nvoid main()\n{\n\tvec4 color =  u_AlbedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\n\t#endif\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tcolor *= v_Color;\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(color.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n\t\n\tgl_FragColor = color;\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t\t#endif\n\t#endif\n\t\n}\n\n",
                    a = Vt.add("Unlit", !0), o = new re(n, i, fi.shaderDefines, kn.shaderDefines), a.addSubShader(o),
                    o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_Texcoord0: 2,
                        a_BoneWeights: 6,
                        a_BoneIndices: 5,
                        a_MvpMatrix: 12
                    }, i = {
                        u_Bones: 0,
                        u_AlbedoTexture: 1,
                        u_AlbedoColor: 1,
                        u_TilingOffset: 1,
                        u_AlphaTestValue: 1,
                        u_MvpMatrix: 2,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\t\t\n\tv_Color = a_Color;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}',
                    e = "#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#ifdef COLOR\n\tvarying vec4 v_Color;\n#endif\nvarying vec2 v_Texcoord0;\n\n#ifdef MAINTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\nvoid main()\n{\n\tvec4 color =  2.0 * u_AlbedoColor;\n\t#ifdef COLOR\n\t\tcolor *= v_Color;\n\t#endif\n\t#ifdef MAINTEXTURE\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\n\t#endif\n\t\n\tgl_FragColor = color;\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t\t#endif\n\t#endif\n}\n\n",
                    a = Vt.add("Effect", !0), o = new re(n, i, fi.shaderDefines, Jn.shaderDefines),
                    a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_CornerTextureCoordinate: 0,
                        a_MeshPosition: 1,
                        a_MeshColor: 2,
                        a_MeshTextureCoordinate: 3,
                        a_ShapePositionStartLifeTime: 4,
                        a_DirectionTime: 5,
                        a_StartColor: 6,
                        a_EndColor: 7,
                        a_StartSize: 8,
                        a_StartRotation0: 9,
                        a_StartSpeed: 10,
                        a_Random0: 11,
                        a_Random1: 12,
                        a_SimulationWorldPostion: 13,
                        a_SimulationWorldRotation: 14
                    }, i = {
                        u_Tintcolor: 1,
                        u_TilingOffset: 1,
                        u_texture: 1,
                        u_WorldPosition: 2,
                        u_WorldRotation: 2,
                        u_PositionScale: 2,
                        u_SizeScale: 2,
                        u_ScalingMode: 2,
                        u_Gravity: 2,
                        u_ThreeDStartRotation: 2,
                        u_StretchedBillboardLengthScale: 2,
                        u_StretchedBillboardSpeedScale: 2,
                        u_SimulationSpace: 2,
                        u_CurrentTime: 2,
                        u_ColorOverLifeGradientAlphas: 2,
                        u_ColorOverLifeGradientColors: 2,
                        u_MaxColorOverLifeGradientAlphas: 2,
                        u_MaxColorOverLifeGradientColors: 2,
                        u_VOLVelocityConst: 2,
                        u_VOLVelocityGradientX: 2,
                        u_VOLVelocityGradientY: 2,
                        u_VOLVelocityGradientZ: 2,
                        u_VOLVelocityConstMax: 2,
                        u_VOLVelocityGradientMaxX: 2,
                        u_VOLVelocityGradientMaxY: 2,
                        u_VOLVelocityGradientMaxZ: 2,
                        u_VOLSpaceType: 2,
                        u_SOLSizeGradient: 2,
                        u_SOLSizeGradientX: 2,
                        u_SOLSizeGradientY: 2,
                        u_SOLSizeGradientZ: 2,
                        u_SOLSizeGradientMax: 2,
                        u_SOLSizeGradientMaxX: 2,
                        u_SOLSizeGradientMaxY: 2,
                        u_SOLSizeGradientMaxZ: 2,
                        u_ROLAngularVelocityConst: 2,
                        u_ROLAngularVelocityConstSeprarate: 2,
                        u_ROLAngularVelocityGradient: 2,
                        u_ROLAngularVelocityGradientX: 2,
                        u_ROLAngularVelocityGradientY: 2,
                        u_ROLAngularVelocityGradientZ: 2,
                        u_ROLAngularVelocityConstMax: 2,
                        u_ROLAngularVelocityConstMaxSeprarate: 2,
                        u_ROLAngularVelocityGradientMax: 2,
                        u_ROLAngularVelocityGradientMaxX: 2,
                        u_ROLAngularVelocityGradientMaxY: 2,
                        u_ROLAngularVelocityGradientMaxZ: 2,
                        u_ROLAngularVelocityGradientMaxW: 2,
                        u_TSACycles: 2,
                        u_TSASubUVLength: 2,
                        u_TSAGradientUVs: 2,
                        u_TSAMaxGradientUVs: 2,
                        u_CameraPosition: 3,
                        u_CameraDirection: 3,
                        u_CameraUp: 3,
                        u_View: 3,
                        u_Projection: 3,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\n#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n\tattribute vec4 a_CornerTextureCoordinate;\n#endif\n#ifdef RENDERMODE_MESH\n\tattribute vec3 a_MeshPosition;\n\tattribute vec4 a_MeshColor;\n\tattribute vec2 a_MeshTextureCoordinate;\n\tvarying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\n#ifdef DIFFUSEMAP\n\tvarying vec2 v_TextureCoordinate;\n#endif\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform vec4 u_WorldRotation;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\n#ifdef STRETCHEDBILLBOARD\n\tuniform vec3 u_CameraPosition;\n#endif\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n#ifdef FOG\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\n{\n\tfloat halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n\tfloat halfYaw = rot.y * 0.5;\n\n\tfloat sinRoll = sin(halfRoll);\n\tfloat cosRoll = cos(halfRoll);\n\tfloat sinPitch = sin(halfPitch);\n\tfloat cosPitch = cos(halfPitch);\n\tfloat sinYaw = sin(halfYaw);\n\tfloat cosYaw = cos(halfYaw);\n\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n\t\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\t\n\tfloat x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n\tfloat xx = quaX * x;\n    float xy = quaX * y;\n\tfloat xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n\t\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\n{\n\tfloat halfAngle = angle * 0.5;\n\tfloat sin = sin(halfAngle);\n\t\n\tfloat quaX = axis.x * sin;\n\tfloat quaY = axis.y * sin;\n\tfloat quaZ = axis.z * sin;\n\tfloat quaW = cos(halfAngle);\n\t\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\t\n\tfloat x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n\tfloat xx = quaX * x;\n    float xy = quaX * y;\n\tfloat xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n\t\n}\n\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n \n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n\tfloat curValue;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientNumber=gradientNumbers[i];\n\t\tfloat key=gradientNumber.x;\n\t\tif(key>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\n\t\t\tfloat lastKey=lastGradientNumber.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn curValue;\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n\tfloat totalValue=0.0;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientNumber=gradientNumbers[i];\n\t\tfloat key=gradientNumber.x;\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\n\t\tfloat lastValue=lastGradientNumber.y;\n\t\t\n\t\tif(key>=normalizedAge){\n\t\t\tfloat lastKey=lastGradientNumber.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\n\t\t}\n\t}\n\treturn totalValue;\n}\n#endif\n\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n\tvec4 overTimeColor;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientAlpha=gradientAlphas[i];\n\t\tfloat alphaKey=gradientAlpha.x;\n\t\tif(alphaKey>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec4 gradientColor=gradientColors[i];\n\t\tfloat colorKey=gradientColor.x;\n\t\tif(colorKey>=normalizedAge)\n\t\t{\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\n\t\t\tfloat lastColorKey=lastGradientColor.x;\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n\tfloat overTimeFrame;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientFrame=gradientFrames[i];\n\t\tfloat key=gradientFrame.x;\n\t\tif(key>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\n\t\t\tfloat lastKey=lastGradientFrame.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn floor(overTimeFrame);\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n\t outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n\t\t\t\t\t\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=lifeVelocity*age;\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMECURVE\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=lifeVelocity*age;\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n\t#endif\n\t\n\tvec3 finalPosition;\n\tif(u_VOLSpaceType==0){\n\t  if(u_ScalingMode!=2)\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\n\t  else\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\n\t}\n\telse{\n\t  if(u_ScalingMode!=2)\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\n\t  else\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\n\t}\n  #else\n\t startPosition=startVelocity*age;\n\t vec3 finalPosition;\n\t if(u_ScalingMode!=2)\n\t   finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\n\t else\n\t   finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n\t#ifdef COLOROVERLIFETIME\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n\t#endif\n\t\n\t#ifdef RANDOMCOLOROVERLIFETIME\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n\t#endif\n\n    return color;\n}\n\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\n{\n\t#ifdef SIZEOVERLIFETIMECURVE\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n\t#endif\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n\t#endif\n\treturn size;\n}\n\n#ifdef RENDERMODE_MESH\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\n{\n\t#ifdef SIZEOVERLIFETIMECURVE\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n\t#endif\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\n\t#endif\n\treturn size;\n}\n#endif\n\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n\t\t#endif\n\t#endif\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n\t\t#endif\n\t#endif\n\treturn rotation;\n}\n\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n\t\t#endif\n\t#endif\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n\t\t#endif\n\t#endif\n\treturn rotation;\n}\n#endif\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n\t#ifdef TEXTURESHEETANIMATIONCURVE\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t    uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t    uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n\treturn uv;\n}\n\nvoid main()\n{\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\n\tvec3 lifeVelocity;\n\tif(normalizedAge<1.0){ \n\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n\t#endif \n\tvec3 gravityVelocity=u_Gravity*age;\n\t\n\tvec4 worldRotation;\n\tif(u_SimulationSpace==0)\n\t\tworldRotation=a_SimulationWorldRotation;\n\telse\n\t\tworldRotation=u_WorldRotation;\n\t\n\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\n   \n   \n   #ifdef SPHERHBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n\t    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n\t\t\t\tfloat c = cos(rot);\n\t\t\t\tfloat s = sin(rot);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#else\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat c = cos(a_StartRotation0.x);\n\t\t\t\tfloat s = sin(a_StartRotation0.x);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#endif\n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n\tvec3 velocity;\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t    if(u_VOLSpaceType==0)\n\t\t  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\n\t    else\n\t\t  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\n    #else\n\t    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\n    #endif\t\n\t\tvec3 cameraUpVector = normalize(velocity);\n\t\tvec3 direction = normalize(center-u_CameraPosition);\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n\t\t\n\t\tsideVector=u_SizeScale.xzy*sideVector;\n\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\n\t\t\n\t    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n\t\t\n\t    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n\t    corner=rotaionZHalfPI*corner;\n\t    corner.y=corner.y-abs(corner.y);\n\t\t\n\t    float speed=length(velocity);//TODO:\n\t    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n\t    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n\t\t\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n\t\t\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef RENDERMODE_MESH\n\t    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t#ifdef ROTATIONOVERLIFETIME\n\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t#ifdef SHAPE\n\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\n\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\n\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\n\t\t\t\t#endif\t\t\n\t\t\t}\n\t\t#else\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\n\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t#ifdef SHAPE\n\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\n\t\t\t\t\t#else\n\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tv_MeshColor=a_MeshColor;\n   #endif\n   \n    gl_Position=u_Projection*u_View*vec4(center,1.0);\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\n\t#ifdef DIFFUSEMAP\n\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n\t\t#endif\n\t\t#ifdef RENDERMODE_MESH\n\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\n\t\t#endif\n\t\t\n\t\t#ifdef TILINGOFFSET\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\n\t\t#endif\n\t#endif\n    v_Discard=0.0;\n\t  \n\t#ifdef FOG\n\t\tv_PositionWorld=center;\n\t#endif\n   }\n   else\n\t{\n\t\tv_Discard=1.0;\n\t}\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\n',
                    e = "#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n#ifdef RENDERMODE_MESH\n\tvarying vec4 v_MeshColor;\n#endif\n\n#ifdef FOG\n\tvarying vec3 v_PositionWorld;\n\tuniform vec3 u_CameraPosition;\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\n\nvoid main()\n{\t\n\t#ifdef RENDERMODE_MESH\n\t\tgl_FragColor=v_MeshColor;\n\t#else\n\t\tgl_FragColor=vec4(1.0);\t\n\t#endif\n\t\t\n\t#ifdef DIFFUSEMAP\n\t\tif(v_Discard!=0.0)\n\t\t\tdiscard;\n\t\t#ifdef TINTCOLOR\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n\t\t#else\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n\t\t#endif\n\t#else\n\t\t#ifdef TINTCOLOR\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\n\t\t#else\n\t\t\tgl_FragColor*=v_Color;\n\t\t#endif\n\t#endif\n\t\n\t#ifdef FOG\n\t\tvec3 toEye=u_CameraPosition-v_PositionWorld;\n\t\tfloat toEyeLength=length(toEye);\n\t\ttoEye/=toEyeLength;\n\t\t\n\t\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n\t\t#endif\n\t#endif\n}",
                    a = Vt.add("PARTICLESHURIKEN"), o = new re(n, i, _i.shaderDefines, Qn.shaderDefines),
                    a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_Position: 0
                    }, i = {
                        u_TintColor: 1,
                        u_Exposure: 1,
                        u_Rotation: 1,
                        u_CubeTexture: 1,
                        u_MvpMatrix: 3
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform float u_Rotation;\nvarying vec3 v_Texcoord;\n\n\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\n{\n\tfloat angle = degrees * 3.141593 / 180.0;\n\tfloat sina=sin(angle);\n\tfloat cosa=cos(angle);\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\n}\n\t\t\nvoid main()\n{\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\n\tgl_Position = (u_MvpMatrix*position).xyww;\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n',
                    e = "#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec3 v_Texcoord;\n\nuniform samplerCube u_CubeTexture;\nuniform float u_Exposure;\nuniform vec4 u_TintColor;\n\n\nvoid main()\n{\t\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\n\tgl_FragColor=vec4(color,1.0);\n}\n\n",
                    a = Vt.add("SkyBox"), o = new re(n, i), a.addSubShader(o), o.addShaderPass(t, e),
                    n = {
                        a_Position: 0
                    }, i = {
                        u_SunSize: 1,
                        u_SunSizeConvergence: 1,
                        u_AtmosphereThickness: 1,
                        u_SkyTint: 1,
                        u_GroundTint: 1,
                        u_Exposure: 1,
                        u_MvpMatrix: 3,
                        "u_DirectionLight.Direction": 4,
                        "u_DirectionLight.Color": 4
                    }, t = "#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\n#define MIE 0.0010             // Mie constant 米氏散射\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\n\nconst float SKY_GROUND_THRESHOLD = 0.02;\nconst float outerRadius = OUTER_RADIUS;\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float innerRadius = 1.0;\nconst float innerRadius2 = 1.0;\nconst float cameraHeight = 0.0001;\n\nconst float HDSundiskIntensityFactor = 15.0;\nconst float simpleSundiskIntensityFactor = 27.0;\n\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\nconst float kmESun = MIE * SUN_BRIGHTNESS;\nconst float km4PI = MIE * 4.0 * 3.14159265;\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float scaleDepth = 0.25;\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\n\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\n\nattribute vec4 a_Position;\n\nuniform mat4 u_MvpMatrix;\nuniform vec3 u_SkyTint;\nuniform vec3 u_GroundTint;\nuniform float u_Exposure;\nuniform float u_AtmosphereThickness;\nuniform DirectionLight u_DirectionLight;\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n#ifdef SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(vec3 light, vec3 ray) \n{\n\tfloat eyeCos = dot(light, ray);\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\n}\n\nfloat scaleAngle(float inCos)\n{\n\tfloat x = 1.0 - inCos;\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\n\nvoid main () {\n\tgl_Position = (u_MvpMatrix*a_Position).xyww;\n\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\n\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\n\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\n\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n\tvec3 eyeRay = normalize(a_Position.xyz);\n\n\tfloat far = 0.0;\n\tvec3 cIn, cOut;\n\tif (eyeRay.y >= 0.0) {// Sky\n\t\t// Calculate the length of the \"atmosphere\"\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat height = innerRadius + cameraHeight;\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\tvec3 frontColor = vec3(0.0);\n\t\t//unrolling this manually to avoid some platform for loop slow\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n\t\tcIn = frontColor * (invWavelength * krESun);\n\t\tcOut = frontColor * kmESun;\n\t} else {// Ground\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\n\t\tvec3 pos = cameraPos + far * eyeRay;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\n\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, pos);\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\n\t\tfloat lightScale = scaleAngle(lightAngle);\n\t\tfloat cameraOffset = depth*cameraScale;\n\t\tfloat temp = lightScale + cameraScale;\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\t// Now loop through the sample rays\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\n\t\tvec3 attenuate;\n\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat scatter = depth*temp - cameraOffset;\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\n\t}\n\n\t#ifdef SUN_HIGH_QUALITY\n\t\tv_Vertex = -a_Position.xyz;\n\t#elif defined(SUN_SIMPLE) \n\t\tv_RayDir = -eyeRay;\n\t#else\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\n\t#endif\n\n\t// if we want to calculate color in vprog:\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\n\n\t\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\n\tfloat lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\n\n\t#ifdef SUN_HIGH_QUALITY \n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n\t#elif defined(SUN_SIMPLE) \n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n",
                    e = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\nconst float MIE_G = -0.990;\nconst float MIE_G2 = 0.9801;\nconst float SKY_GROUND_THRESHOLD = 0.02;\n\nuniform float u_SunSize;\nuniform float u_SunSizeConvergence;\nuniform DirectionLight u_DirectionLight;\n\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n\n#ifdef SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n// Calculates the Mie phase function\nfloat getMiePhase(float eyeCos, float eyeCos2) {\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\n\treturn temp;\n}\n\n// Calculates the sun shape\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\n\t#ifdef SUN_HIGH_QUALITY\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\n\t#else //SUN_SIMPLE\n\t\tvec3 delta = lightPos - ray;\n\t\tfloat dist = length(delta);\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\n\t\treturn spot * spot;\n\t#endif\n}\n\nvoid main() {\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\n\t// if y < 0 [eyeRay.y > 0] - sky\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\n\t#ifdef SUN_HIGH_QUALITY\n\t\tvec3 ray = normalize(v_Vertex);\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\n\t#elif defined(SUN_SIMPLE) \n\t\tvec3 ray = v_RayDir;\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\n\t#else\n\t\tfloat y = v_SkyGroundFactor;\n\t#endif\n\n\t// if we did precalculate color in vprog: just do lerp between them\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\n\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\t\tif (y < 0.0)\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\n\t#endif\n\n\tcol = sqrt(col);//linear space convert to gamma space\n\tgl_FragColor=vec4(col,1.0);\n}\n\n',
                    a = Vt.add("SkyBoxProcedural"), o = new re(n, i, null, Zn.shaderDefines), a.addSubShader(o),
                    o.addShaderPass(t, e), n = {
                        a_Position: 0,
                        a_Normal: 3,
                        a_Texcoord0: 2
                    }, i = {
                        u_MvpMatrix: 2,
                        u_WorldMat: 2,
                        u_CameraPos: 3,
                        u_LightmapScaleOffset: 2,
                        u_LightMap: 2,
                        u_SplatAlphaTexture: 1,
                        u_DiffuseTexture1: 1,
                        u_DiffuseTexture2: 1,
                        u_DiffuseTexture3: 1,
                        u_DiffuseTexture4: 1,
                        u_DiffuseTexture5: 1,
                        u_DiffuseScaleOffset1: 1,
                        u_DiffuseScaleOffset2: 1,
                        u_DiffuseScaleOffset3: 1,
                        u_DiffuseScaleOffset4: 1,
                        u_DiffuseScaleOffset5: 1,
                        u_FogStart: 4,
                        u_FogRange: 4,
                        u_FogColor: 4,
                        "u_DirectionLight.Direction": 4,
                        "u_DirectionLight.Color": 4,
                        "u_PointLight.Position": 4,
                        "u_PointLight.Range": 4,
                        "u_PointLight.Attenuation": 4,
                        "u_PointLight.Color": 4,
                        "u_SpotLight.Position": 4,
                        "u_SpotLight.Direction": 4,
                        "u_SpotLight.Range": 4,
                        "u_SpotLight.Spot": 4,
                        "u_SpotLight.Color": 4,
                        u_AmbientColor: 4,
                        u_shadowMap1: 4,
                        u_shadowMap2: 4,
                        u_shadowMap3: 4,
                        u_shadowPSSMDistance: 4,
                        u_lightShadowVP: 4,
                        u_shadowPCFoffset: 4
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec2 v_Texcoord0;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n\tattribute vec3 a_Normal;\n\tvarying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n\tuniform mat4 u_WorldMat;\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef LIGHTMAP\n\tvarying vec2 v_LightMapUV;\n\tuniform vec4 u_LightmapScaleOffset;\n#endif\n\n#ifdef RECEIVESHADOW\n\tvarying float v_posViewZ;\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n#endif\n\nvoid main()\n{\n\tgl_Position = u_MvpMatrix * a_Position;\n  \n\tv_Texcoord0 = a_Texcoord0;\n  \n\t#ifdef LIGHTMAP\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\n\t#endif\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_Normal = a_Normal;\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}',
                    e = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n\tuniform vec3 u_CameraPos;\n\tvarying vec3 v_Normal;\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#include "ShadowHelper.glsl"\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\nvarying float v_posViewZ;\n\nuniform vec3 u_AmbientColor;\n\nuniform sampler2D u_SplatAlphaTexture;\n\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform sampler2D u_DiffuseTexture5;\n\nuniform vec4 u_DiffuseScaleOffset1;\nuniform vec4 u_DiffuseScaleOffset2;\nuniform vec4 u_DiffuseScaleOffset3;\nuniform vec4 u_DiffuseScaleOffset4;\nuniform vec4 u_DiffuseScaleOffset5;\n\nvarying vec2 v_Texcoord0;\n\n#ifdef LIGHTMAP\n\tuniform sampler2D u_LightMap;\n\tvarying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n\tvec4 splatAlpha = vec4(1.0);\n\t#ifdef ExtendTerrain_DETAIL_NUM1\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM2\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM3\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM4\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM5\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\n\t#endif\n\t\tgl_FragColor.w = splatAlpha.a;\n\t\t\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = v_Normal;\n\tvec3 dif, spe;\n#endif\n\nvec3 diffuse = vec3(0.0);\nvec3 specular= vec3(0.0);\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n\tvec3 toEye;\n\t#ifdef FOG\n\t\ttoEye=u_CameraPos-v_PositionWorld;\n\t\tfloat toEyeLength=length(toEye);\n\t\ttoEye/=toEyeLength;\n\t#else\n\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tLayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n\tLayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n\tLayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n\nvec3 globalDiffuse = u_AmbientColor;\n#ifdef LIGHTMAP\n\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n#endif\n\n#ifdef RECEIVESHADOW\n\tfloat shadowValue = 1.0;\n\t#ifdef SHADOWMAP_PSSM3\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t#endif\n\t#ifdef SHADOWMAP_PSSM2\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t#endif \n\t#ifdef SHADOWMAP_PSSM1\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t#endif\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\n#else\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t#ifdef RECEIVESHADOW\n\t\tgl_FragColor.rgb += specular * shadowValue;\n\t#else\n\t\tgl_FragColor.rgb += specular;\n\t#endif\n#endif\n\n#ifdef FOG\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n\n\n\n\n',
                    a = Vt.add("ExtendTerrain"), o = new re(n, i, Hn.shaderDefines, ti.shaderDefines),
                    a.addSubShader(o), o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_OffsetVector: 1,
                        a_Texcoord0X: 4,
                        a_Texcoord0Y: 3,
                        a_BirthTime: 2
                    }, i = {
                        u_MvpMatrix: 2,
                        u_View: 3,
                        u_Projection: 3,
                        u_TilingOffset: 1,
                        u_MainTexture: 1,
                        u_MainColor: 1,
                        u_CurTime: 2,
                        u_LifeTime: 2,
                        u_WidthCurve: 2,
                        u_WidthCurveKeyLength: 2,
                        u_GradientColorkey: 2,
                        u_GradientAlphakey: 2
                    }, r = {
                        s_Cull: 0,
                        s_Blend: 1,
                        s_BlendSrc: 2,
                        s_BlendDst: 3,
                        s_DepthTest: 12,
                        s_DepthWrite: 13
                    }, t = '#include "Lighting.glsl";\n\nattribute vec3 a_Position;\nattribute vec3 a_OffsetVector;\nattribute vec4 a_Color;\nattribute float a_Texcoord0X;\nattribute float a_Texcoord0Y;\nattribute float a_BirthTime;\n\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nuniform vec4 u_TilingOffset;\n\nuniform float u_CurTime;\nuniform float u_LifeTime;\nuniform vec4 u_WidthCurve[10];\nuniform int u_WidthCurveKeyLength;\n\nuniform vec4 u_GradientColorkey[10];\nuniform vec2 u_GradientAlphakey[10];\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\n\tfloat b = t3 - 2.0 * t2 + t;\n\tfloat c = t3 - t2;\n\tfloat d = -2.0 * t3 + 3.0 * t2;\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\n}\n\nfloat getCurWidth(in float normalizeTime)\n{\n\tfloat width;\n\tif(normalizeTime == 0.0){\n\t\twidth=u_WidthCurve[0].w;\n\t}\n\telse if(normalizeTime >= 1.0){\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\n\t}\n\telse{\n\t\tfor(int i = 0; i < 10; i ++ )\n\t\t{\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\n\t\t\t\twidth=u_WidthCurve[i].w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\n\t\t\t{\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\n\t\t\t\tfloat outTangent = lastFrame.z;\n\t\t\t\tfloat inTangent = nextFrame.y;\n\t\t\t\tfloat value1 = lastFrame.w;\n\t\t\t\tfloat value2 = nextFrame.w;\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn width;\n}\t\n\nvec4 getColorFromGradientByBlend(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n\tvec4 color;\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec4 gradientColor = gradientColors[i];\n\t\tfloat colorKey = gradientColor.x;\n\t\tif(colorKey >= normalizeTime)\n\t\t{\n\t\t\tvec4 lastGradientColor = gradientColors[i-1];\n\t\t\tfloat lastColorKey = lastGradientColor.x;\n\t\t\tfloat age = (normalizeTime - lastColorKey) / (colorKey - lastColorKey);\n\t\t\tcolor.rgb = mix(gradientColors[i-1].yzw, gradientColor.yzw, age);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec2 gradientAlpha = gradientAlphas[i];\n\t\tfloat alphaKey = gradientAlpha.x;\n\t\tif(alphaKey >= normalizeTime)\n\t\t{\n\t\t\tvec2 lastGradientAlpha = gradientAlphas[i-1];\n\t\t\tfloat lastAlphaKey = lastGradientAlpha.x;\n\t\t\tfloat age = (normalizeTime - lastAlphaKey) / (alphaKey - lastAlphaKey);\n\t\t\tcolor.a = mix(lastGradientAlpha.y, gradientAlpha.y, age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec4 getColorFromGradientByFixed(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n\tvec4 color;\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec4 gradientColor = gradientColors[i];\n\t\tif(gradientColor.w >= normalizeTime)\n\t\t{\n\t\t\tcolor.rgb = gradientColor.xyz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec2 gradientAlpha = gradientAlphas[i];\n\t\tif(gradientAlpha.y >= normalizeTime)\n\t\t{\n\t\t\tcolor.a = gradientAlpha.x;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid main()\n{\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\n\t\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\n\t#else\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\n\t#endif\n\t\n\t#ifdef GRADIENTMODE_BLEND\n\t\tv_Color = getColorFromGradientByBlend(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n\t#else\n\t\tv_Color = getColorFromGradientByFixed(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n\t#endif\n\t\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n',
                    e = "#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nuniform sampler2D u_MainTexture;\nuniform vec4 u_MainColor;\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nvoid main()\n{\t\n\tvec4 color = 2.0 * u_MainColor * v_Color;\n\t#ifdef MAINTEXTURE\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\n\t\tcolor *= mainTextureColor;\n\t#endif\n\tgl_FragColor = color;\n}\n\n",
                    a = Vt.add("Trail"), o = new re(n, i, ci.shaderDefines, Yn.shaderDefines), a.addSubShader(o),
                    o.addShaderPass(t, e, r), n = {
                        a_Position: 0,
                        a_Normal: 3,
                        a_Tangent0: 4
                    }, i = {
                        u_MvpMatrix: 2,
                        u_WorldMat: 2,
                        u_CameraPos: 3,
                        u_Time: 4,
                        u_MainTexture: 1,
                        u_NormalTexture: 1,
                        u_HorizonColor: 1,
                        u_WaveScale: 1,
                        u_WaveSpeed: 1
                    }, t = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\nuniform float u_WaveScale;\nuniform vec4 u_WaveSpeed;\nuniform float u_Time;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\nvoid main()\n{\n\tvec4 positionWorld = u_WorldMat * a_Position;\n\tvec4 position = u_MvpMatrix * a_Position;\n\t\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\n\t\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\n\tv_Texcoord1 = temp.wz;\n\t\n\tmat3 worldMat = mat3(u_WorldMat);\n\tv_Normal = worldMat * a_Normal;\n\tv_Tangent = worldMat * a_Tangent0.xyz;\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n\t\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\n\tgl_Position = position;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}',
                    e = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#ifdef MAINTEXTURE\n\tuniform sampler2D u_MainTexture;\n#endif\n\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n#endif\n\nuniform vec4 u_HorizonColor;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n#include "Lighting.glsl"\n\nvoid main()\n{\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\n\t\n\tvec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\n\tvec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\n\t\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\n\tvec3 viewDir = normalize(v_ViewDir);\n\tfloat fresnel = dot(viewDir, normal);\n\t\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\n\t\n\tvec4 color;\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\n\tcolor.a = u_HorizonColor.a;\n\t\n\tgl_FragColor = color;\n}\n\n',
                    a = Vt.add("WaterPrimary"), o = new re(n, i, null, $n.shaderDefines), a.addSubShader(o),
                    o.addShaderPass(t, e);
            }, s._rangeAttenTex = null, s;
        }(),
        Gt = function() {
            function N() {}
            return d(N, "laya.d3.utils.Utils3D"), N._convertToLayaVec3 = function(t, e, n) {
                    e.x = n ? -t.x() : t.x(), e.y = t.y(), e.z = t.z();
                }, N._convertToBulletVec3 = function(t, e, n) {
                    e.setValue(n ? -t.x : t.x, t.y, t.z);
                }, N._rotationTransformScaleSkinAnimation = function(t, e, n, i, r, a, o, s, l, h, u, c) {
                    var _, d, f, m, p, T = N._tempArray16_0,
                        E = N._tempArray16_1,
                        v = N._tempArray16_2,
                        g = i + i,
                        S = r + r,
                        y = a + a,
                        x = i * g,
                        D = r * g,
                        I = r * S,
                        R = a * g,
                        M = a * S,
                        A = a * y,
                        C = o * g,
                        L = o * S,
                        O = o * y;
                    for (T[15] = 1, T[0] = 1 - I - A, T[1] = D + O, T[2] = R - L, T[4] = D - O, T[5] = 1 - x - A,
                        T[6] = M + C, T[8] = R + L, T[9] = M - C, T[10] = 1 - x - I, E[15] = 1, E[0] = s,
                        E[5] = l, E[10] = h, _ = 0; _ < 4; _++) d = T[_], f = T[_ + 4], m = T[_ + 8], p = T[_ + 12],
                        v[_] = d, v[_ + 4] = f, v[_ + 8] = m, v[_ + 12] = d * t + f * e + m * n + p;
                    for (_ = 0; _ < 4; _++) d = v[_], f = v[_ + 4], m = v[_ + 8], p = v[_ + 12], u[_ + c] = d * E[0] + f * E[1] + m * E[2] + p * E[3],
                        u[_ + c + 4] = d * E[4] + f * E[5] + m * E[6] + p * E[7], u[_ + c + 8] = d * E[8] + f * E[9] + m * E[10] + p * E[11],
                        u[_ + c + 12] = d * E[12] + f * E[13] + m * E[14] + p * E[15];
                }, N._createSceneByJsonForMaker = function(t, e, n) {
                    var i = N._createNodeByJsonForMaker(t, e, n);
                    return N._addComponentByJsonForMaker(t, e, n), i;
                }, N._createNodeByJsonForMaker = function(t, e, n) {
                    var i;
                    switch (t.type) {
                        case "Scene3D":
                            i = new Gn();
                            break;

                        case "Sprite3D":
                            i = new An();
                            break;

                        case "MeshSprite3D":
                            i = new li(), e && e.push(i);
                            break;

                        case "SkinnedMeshSprite3D":
                            i = new fi();
                            break;

                        case "ShuriKenParticle3D":
                            i = new _i();
                            break;

                        case "Terrain":
                            i = new Xn();
                            break;

                        case "Camera":
                            i = new Ti();
                            break;

                        case "DirectionLight":
                            i = new ui();
                            break;

                        case "PointLight":
                            i = new mi();
                            break;

                        case "SpotLight":
                            i = new hi();
                            break;

                        case "TrailSprite3D":
                            i = new ci();
                            break;

                        default:
                            var r = p.getClass(t.props.runtime);
                            i = new r();
                    }
                    var a = t.child;
                    if (a)
                        for (var o = 0, s = a.length; o < s; o++) {
                            var l = N._createNodeByJsonForMaker(a[o], e, n);
                            i.addChild(l);
                        }
                    var h = t.compId;
                    i.compId = h, i._parse(t.props), n && (n._idMap[h] = i), N._compIdToNode[h] = i;
                    var u = t.components;
                    if (u)
                        for (var c = 0, _ = u.length; c < _; c++) {
                            var d = u[c];
                            if (!(r = S.window.Laya[d.type])) r = S.window, d.type.split(".").forEach(function(t) {
                                r = r[t];
                            });
                            if ("function" == typeof r) {
                                var f = new r();
                                n && (n._idMap[d.compId] = f, console.log(d.compId));
                            } else console.warn("Utils3D:Unkown component type.");
                        }
                    return i;
                }, N._addComponentByJsonForMaker = function(t, e, n) {
                    var i = t.compId,
                        r = N._compIdToNode[i],
                        a = t.child;
                    if (a)
                        for (var o = 0, s = a.length; o < s; o++) N._addComponentByJsonForMaker(a[o], e, n);
                    var l = t.components;
                    if (l)
                        for (var h = 0, u = l.length; h < u; h++) {
                            var c = l[h];
                            if (!(d = S.window.Laya[c.type])) {
                                var _ = c.type.split("."),
                                    d = S.window;
                                _.forEach(function(t) {
                                    d = d[t];
                                });
                            }
                            if ("function" == typeof d) {
                                var f = n._idMap[c.compId];
                                r.addComponentIntance(f), f._parse(c);
                            } else console.warn("Utils3D:Unkown component type.");
                        }
                }, N._createNodeByJson = function(t, e) {
                    var n;
                    switch (t.type) {
                        case "Scene3D":
                            n = new Gn();
                            break;

                        case "Sprite3D":
                            n = new An();
                            break;

                        case "MeshSprite3D":
                            n = new li(), e && e.push(n);
                            break;

                        case "SkinnedMeshSprite3D":
                            n = new fi();
                            break;

                        case "ShuriKenParticle3D":
                            n = new _i();
                            break;

                        case "Terrain":
                            n = new Xn();
                            break;

                        case "Camera":
                            n = new Ti();
                            break;

                        case "DirectionLight":
                            n = new ui();
                            break;

                        case "PointLight":
                            n = new mi();
                            break;

                        case "SpotLight":
                            n = new hi();
                            break;

                        case "TrailSprite3D":
                            n = new ci();
                            break;

                        default:
                            throw new Error("Utils3D:unidentified class type in (.lh) file.");
                    }
                    var i = t.child;
                    if (i)
                        for (var r = 0, a = i.length; r < a; r++) {
                            var o = N._createNodeByJson(i[r], e);
                            n.addChild(o);
                        }
                    var s = t.components;
                    if (s)
                        for (var l = 0, h = s.length; l < h; l++) {
                            var u = s[l];
                            if (!(_ = S.window.Laya[u.type])) {
                                var c = u.type.split("."),
                                    _ = S.window;
                                c.forEach(function(t) {
                                    _ = _[t];
                                });
                            }
                            if ("function" == typeof _) n.addComponent(_)._parse(u);
                            else console.warn("Unkown component type.");
                        }
                    return n._parse(t.props), n;
                }, N._computeBoneAndAnimationDatasByBindPoseMatrxix = function(t, e, n, i, r, a) {
                    var o, s, l = 0,
                        h = 0,
                        u = t.length;
                    for (o = 0; o < u; l += t[o].keyframeWidth, h += 16, o++) laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(e[l + 0], e[l + 1], e[l + 2], e[l + 3], e[l + 4], e[l + 5], e[l + 6], e[l + 7], e[l + 8], e[l + 9], i, h),
                        0 != o && (s = 16 * t[o].parentIndex, laya.d3.utils.Utils3D.mulMatrixByArray(i, s, i, h, i, h));
                    var c = n.length;
                    for (o = 0; o < c; o++) laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(i, 16 * a[o], n[o], r, 16 * o);
                }, N._computeAnimationDatasByArrayAndMatrixFast = function(t, e, n, i) {
                    for (var r = 0, a = t.length; r < a; r++) laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(e, 16 * i[r], t[r], n, 16 * r);
                }, N._computeBoneAndAnimationDatasByBindPoseMatrxixOld = function(t, e, n, i, r) {
                    var a, o, s = 0,
                        l = 0,
                        h = t.length;
                    for (a = 0; a < h; s += t[a].keyframeWidth, l += 16, a++) laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(e[s + 7], e[s + 8], e[s + 9], e[s + 3], e[s + 4], e[s + 5], e[s + 6], e[s + 0], e[s + 1], e[s + 2], i, l),
                        0 != a && (o = 16 * t[a].parentIndex, laya.d3.utils.Utils3D.mulMatrixByArray(i, o, i, l, i, l));
                    var u = n.length;
                    for (a = 0; a < u; a++) {
                        var c = 16 * a;
                        laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(i, c, n[a], r, c);
                    }
                }, N._computeAnimationDatasByArrayAndMatrixFastOld = function(t, e, n) {
                    for (var i = t.length, r = 0; r < i; r++) {
                        var a = 16 * r;
                        laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(e, a, t[r], n, a);
                    }
                }, N._computeRootAnimationData = function(t, e, n) {
                    for (var i = 0, r = 0, a = 0, o = t.length; i < o; r += t[i].keyframeWidth, a += 16,
                        i++) laya.d3.utils.Utils3D.createAffineTransformationArray(e[r + 0], e[r + 1], e[r + 2], e[r + 3], e[r + 4], e[r + 5], e[r + 6], e[r + 7], e[r + 8], e[r + 9], n, a);
                }, N.transformVector3ArrayByQuat = function(t, e, n, i, r) {
                    var a = t[e],
                        o = t[e + 1],
                        s = t[e + 2],
                        l = n.x,
                        h = n.y,
                        u = n.z,
                        c = n.w,
                        _ = c * a + h * s - u * o,
                        d = c * o + u * a - l * s,
                        f = c * s + l * o - h * a,
                        m = -l * a - h * o - u * s;
                    i[r] = _ * c + m * -l + d * -u - f * -h, i[r + 1] = d * c + m * -h + f * -l - _ * -u,
                        i[r + 2] = f * c + m * -u + _ * -h - d * -l;
                }, N.mulMatrixByArray = function(t, e, n, i, r, a) {
                    var o, s, l, h, u;
                    if (r === n) {
                        for (n = N._tempArray16_3, o = 0; o < 16; ++o) n[o] = r[a + o];
                        i = 0;
                    }
                    for (o = 0; o < 4; o++) s = t[e + o], l = t[e + o + 4], h = t[e + o + 8], u = t[e + o + 12],
                        r[a + o] = s * n[i + 0] + l * n[i + 1] + h * n[i + 2] + u * n[i + 3], r[a + o + 4] = s * n[i + 4] + l * n[i + 5] + h * n[i + 6] + u * n[i + 7],
                        r[a + o + 8] = s * n[i + 8] + l * n[i + 9] + h * n[i + 10] + u * n[i + 11], r[a + o + 12] = s * n[i + 12] + l * n[i + 13] + h * n[i + 14] + u * n[i + 15];
                }, N.mulMatrixByArrayFast = function(t, e, n, i, r, a) {
                    var o, s, l, h, u;
                    for (o = 0; o < 4; o++) s = t[e + o], l = t[e + o + 4], h = t[e + o + 8], u = t[e + o + 12],
                        r[a + o] = s * n[i + 0] + l * n[i + 1] + h * n[i + 2] + u * n[i + 3], r[a + o + 4] = s * n[i + 4] + l * n[i + 5] + h * n[i + 6] + u * n[i + 7],
                        r[a + o + 8] = s * n[i + 8] + l * n[i + 9] + h * n[i + 10] + u * n[i + 11], r[a + o + 12] = s * n[i + 12] + l * n[i + 13] + h * n[i + 14] + u * n[i + 15];
                }, N.mulMatrixByArrayAndMatrixFast = function(t, e, n, i, r) {
                    var a, o, s, l, h, u = n.elements,
                        c = u[0],
                        _ = u[1],
                        d = u[2],
                        f = u[3],
                        m = u[4],
                        p = u[5],
                        T = u[6],
                        E = u[7],
                        v = u[8],
                        g = u[9],
                        S = u[10],
                        y = u[11],
                        x = u[12],
                        D = u[13],
                        I = u[14],
                        R = u[15],
                        M = e,
                        A = e + 4,
                        C = e + 8,
                        L = e + 12,
                        O = r,
                        N = r + 4,
                        V = r + 8,
                        w = r + 12;
                    for (a = 0; a < 4; a++) o = t[M + a], s = t[A + a], l = t[C + a], h = t[L + a],
                        i[O + a] = o * c + s * _ + l * d + h * f, i[N + a] = o * m + s * p + l * T + h * E,
                        i[V + a] = o * v + s * g + l * S + h * y, i[w + a] = o * x + s * D + l * I + h * R;
                }, N.createAffineTransformationArray = function(t, e, n, i, r, a, o, s, l, h, u, c) {
                    var _ = i + i,
                        d = r + r,
                        f = a + a,
                        m = i * _,
                        p = i * d,
                        T = i * f,
                        E = r * d,
                        v = r * f,
                        g = a * f,
                        S = o * _,
                        y = o * d,
                        x = o * f;
                    u[c + 0] = (1 - (E + g)) * s, u[c + 1] = (p + x) * s, u[c + 2] = (T - y) * s, u[c + 3] = 0,
                        u[c + 4] = (p - x) * l, u[c + 5] = (1 - (m + g)) * l, u[c + 6] = (v + S) * l, u[c + 7] = 0,
                        u[c + 8] = (T + y) * h, u[c + 9] = (v - S) * h, u[c + 10] = (1 - (m + E)) * h, u[c + 11] = 0,
                        u[c + 12] = t, u[c + 13] = e, u[c + 14] = n, u[c + 15] = 1;
                }, N.transformVector3ArrayToVector3ArrayCoordinate = function(t, e, n, i, r) {
                    var a = t[e + 0],
                        o = t[e + 1],
                        s = t[e + 2],
                        l = n.elements,
                        h = a * l[3] + o * l[7] + s * l[11] + l[15];
                    i[r] = a * l[0] + o * l[4] + s * l[8] + l[12] / h, i[r + 1] = a * l[1] + o * l[5] + s * l[9] + l[13] / h,
                        i[r + 2] = a * l[2] + o * l[6] + s * l[10] + l[14] / h;
                }, N.transformLightingMapTexcoordArray = function(t, e, n, i, r) {
                    i[r + 0] = t[e + 0] * n.x + n.z, i[r + 1] = 1 - ((1 - t[e + 1]) * n.y + n.w);
                }, N.getURLVerion = function(t) {
                    var e = t.indexOf("?");
                    return 0 <= e ? t.substr(e) : null;
                }, N._createAffineTransformationArray = function(t, e, n, i) {
                    var r = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = r + r,
                        h = a + a,
                        u = o + o,
                        c = r * l,
                        _ = r * h,
                        d = r * u,
                        f = a * h,
                        m = a * u,
                        p = o * u,
                        T = s * l,
                        E = s * h,
                        v = s * u,
                        g = n.x,
                        S = n.y,
                        y = n.z;
                    i[0] = (1 - (f + p)) * g, i[1] = (_ + v) * g, i[2] = (d - E) * g, i[3] = 0, i[4] = (_ - v) * S,
                        i[5] = (1 - (c + p)) * S, i[6] = (m + T) * S, i[7] = 0, i[8] = (d + E) * y, i[9] = (m - T) * y,
                        i[10] = (1 - (c + f)) * y, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1;
                }, N._mulMatrixArray = function(t, e, n, i) {
                    var r, a, o, s, l, h = e.elements,
                        u = h[0],
                        c = h[1],
                        _ = h[2],
                        d = h[3],
                        f = h[4],
                        m = h[5],
                        p = h[6],
                        T = h[7],
                        E = h[8],
                        v = h[9],
                        g = h[10],
                        S = h[11],
                        y = h[12],
                        x = h[13],
                        D = h[14],
                        I = h[15],
                        R = i,
                        M = i + 4,
                        A = i + 8,
                        C = i + 12;
                    for (r = 0; r < 4; r++) a = t[r], o = t[r + 4], s = t[r + 8], l = t[r + 12], n[R + r] = a * u + o * c + s * _ + l * d,
                        n[M + r] = a * f + o * m + s * p + l * T, n[A + r] = a * E + o * v + s * g + l * S,
                        n[C + r] = a * y + o * x + s * D + l * I;
                }, N.arcTanAngle = function(t, e) {
                    return 0 == t ? 1 == e ? Math.PI / 2 : -Math.PI / 2 : 0 < t ? Math.atan(e / t) : t < 0 ? 0 < e ? Math.atan(e / t) + Math.PI : Math.atan(e / t) - Math.PI : 0;
                }, N.angleTo = function(t, e, n) {
                    Ct.subtract(e, t, rt.TEMPVector30), Ct.normalize(rt.TEMPVector30, rt.TEMPVector30),
                        n.x = Math.asin(rt.TEMPVector30.y), n.y = N.arcTanAngle(-rt.TEMPVector30.z, -rt.TEMPVector30.x);
                }, N.transformQuat = function(t, e, n) {
                    var i = e,
                        r = t.x,
                        a = t.y,
                        o = t.z,
                        s = i[0],
                        l = i[1],
                        h = i[2],
                        u = i[3],
                        c = u * r + l * o - h * a,
                        _ = u * a + h * r - s * o,
                        d = u * o + s * a - l * r,
                        f = -s * r - l * a - h * o;
                    n.x = c * u + f * -s + _ * -h - d * -l, n.y = _ * u + f * -l + d * -s - c * -h,
                        n.z = d * u + f * -h + c * -l - _ * -s;
                }, N.quaternionWeight = function(t, e, n) {
                    n.x = t.x * e, n.y = t.y * e, n.z = t.z * e, n.w = t.w;
                }, N.quaternionConjugate = function(t, e) {
                    e.x = -t.x, e.y = -t.y, e.z = -t.z, e.w = t.w;
                }, N.scaleWeight = function(t, e, n) {
                    var i = t.x,
                        r = t.y,
                        a = t.z;
                    n.x = 0 < i ? Math.pow(Math.abs(i), e) : -Math.pow(Math.abs(i), e), n.y = 0 < r ? Math.pow(Math.abs(r), e) : -Math.pow(Math.abs(r), e),
                        n.z = 0 < a ? Math.pow(Math.abs(a), e) : -Math.pow(Math.abs(a), e);
                }, N.scaleBlend = function(t, e, n, i) {
                    var r = N._tempVector3_0,
                        a = N._tempVector3_1;
                    N.scaleWeight(t, 1 - n, r), N.scaleWeight(e, n, a);
                    var o = .5 < n ? e : t;
                    i.x = 0 < o.x ? Math.abs(r.x * a.x) : -Math.abs(r.x * a.x), i.y = 0 < o.y ? Math.abs(r.y * a.y) : -Math.abs(r.y * a.y),
                        i.z = 0 < o.z ? Math.abs(r.z * a.z) : -Math.abs(r.z * a.z);
                }, N.matrix4x4MultiplyFFF = function(t, e, n) {
                    var i, r, a, o, s;
                    if (n === e)
                        for (e = new Float32Array(16), i = 0; i < 16; ++i) e[i] = n[i];
                    var l = e[0],
                        h = e[1],
                        u = e[2],
                        c = e[3],
                        _ = e[4],
                        d = e[5],
                        f = e[6],
                        m = e[7],
                        p = e[8],
                        T = e[9],
                        E = e[10],
                        v = e[11],
                        g = e[12],
                        S = e[13],
                        y = e[14],
                        x = e[15];
                    for (i = 0; i < 4; i++) r = t[i], a = t[i + 4], o = t[i + 8], s = t[i + 12], n[i] = r * l + a * h + o * u + s * c,
                        n[i + 4] = r * _ + a * d + o * f + s * m, n[i + 8] = r * p + a * T + o * E + s * v,
                        n[i + 12] = r * g + a * S + o * y + s * x;
                }, N.matrix4x4MultiplyFFFForNative = function(t, e, n) {
                    E.instance.matrix4x4Multiply(t, e, n);
                }, N.matrix4x4MultiplyMFM = function(t, e, n) {
                    N.matrix4x4MultiplyFFF(t.elements, e, n.elements);
                }, N._buildTexture2D = function(t, e, n, i, r) {
                    void 0 === r && (r = !1);
                    var a = new L(t, e, n, r, !0);
                    return a.anisoLevel = 1, a.filterMode = 0, St._generateTexture2D(a, t, e, i), a;
                }, N._drawBound = function(t, e, n) {
                    t.lineCount + 12 > t.maxLineCount && (t.maxLineCount += 12);
                    var i = N._tempVector3_0,
                        r = N._tempVector3_1,
                        a = e.min,
                        o = e.max;
                    i.setValue(a.x, a.y, a.z), r.setValue(o.x, a.y, a.z), t.addLine(i, r, n, n), i.setValue(a.x, a.y, a.z),
                        r.setValue(a.x, a.y, o.z), t.addLine(i, r, n, n), i.setValue(o.x, a.y, a.z), r.setValue(o.x, a.y, o.z),
                        t.addLine(i, r, n, n), i.setValue(a.x, a.y, o.z), r.setValue(o.x, a.y, o.z), t.addLine(i, r, n, n),
                        i.setValue(a.x, a.y, a.z), r.setValue(a.x, o.y, a.z), t.addLine(i, r, n, n), i.setValue(a.x, a.y, o.z),
                        r.setValue(a.x, o.y, o.z), t.addLine(i, r, n, n), i.setValue(o.x, a.y, a.z), r.setValue(o.x, o.y, a.z),
                        t.addLine(i, r, n, n), i.setValue(o.x, a.y, o.z), r.setValue(o.x, o.y, o.z), t.addLine(i, r, n, n),
                        i.setValue(a.x, o.y, a.z), r.setValue(o.x, o.y, a.z), t.addLine(i, r, n, n), i.setValue(a.x, o.y, a.z),
                        r.setValue(a.x, o.y, o.z), t.addLine(i, r, n, n), i.setValue(o.x, o.y, a.z), r.setValue(o.x, o.y, o.z),
                        t.addLine(i, r, n, n), i.setValue(a.x, o.y, o.z), r.setValue(o.x, o.y, o.z), t.addLine(i, r, n, n);
                }, N._tempArray16_0 = new Float32Array(16), N._tempArray16_1 = new Float32Array(16),
                N._tempArray16_2 = new Float32Array(16), N._tempArray16_3 = new Float32Array(16),
                _(N, ["_tempVector3_0", function() {
                    return this._tempVector3_0 = new Ct();
                }, "_tempVector3_1", function() {
                    return this._tempVector3_1 = new Ct();
                }, "_tempVector3_2", function() {
                    return this._tempVector3_2 = new Ct();
                }, "_tempColor0", function() {
                    return this._tempColor0 = new dt();
                }, "_compIdToNode", function() {
                    return this._compIdToNode = new Object();
                }]), N;
        }(),
        Ht = function() {
            function t() {
                this._currentLength = 0, this._elements = null, this._elements = new Float32Array(8);
            }
            d(t, "laya.d3.core.particleShuriKen.module.GradientDataNumber");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.add = function(t, e) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== t && (t = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = t, this._elements[this._currentLength++] = e) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
            }, e.getKeyByIndex = function(t) {
                return this._elements[2 * t];
            }, e.getValueByIndex = function(t) {
                return this._elements[2 * t + 1];
            }, e.getAverageValue = function() {
                for (var t = 0, e = this._currentLength - 2; t < e; t += 2) {
                    this._elements[t + 1];
                    this._elements[t + 3], this._elements[t + 2] - this._elements[t];
                }
                return 0;
            }, e.cloneTo = function(t) {
                var e = t;
                e._currentLength = this._currentLength;
                var n = e._elements;
                n.length = this._elements.length;
                for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "gradientCount", function() {
                return this._currentLength / 2;
            }), t;
        }(),
        kt = function() {
            function t() {}
            return d(t, "laya.d3.core.pixelLine.PixelLineVertex"), u(0, t.prototype, "vertexDeclaration", function() {
                return t._vertexDeclaration;
            }), u(1, t, "vertexDeclaration", function() {
                return t._vertexDeclaration;
            }), _(t, ["_vertexDeclaration", function() {
                return this._vertexDeclaration = new ue(28, [new Bt(0, "vector3", 0), new Bt(12, "vector4", 1)]);
            }]), t;
        }(),
        Wt = function() {
            function t() {
                this._hitResultsPoolIndex = 0, this._contactPonintsPoolIndex = 0, this._collisions = {},
                    this._hitResultsPool = [], this._contactPointsPool = [], this._collisionsPool = [];
            }
            d(t, "laya.d3.physics.CollisionTool");
            var e = t.prototype;
            return e.getHitResult = function() {
                var t = this._hitResultsPool[this._hitResultsPoolIndex++];
                return t || (t = new de(), this._hitResultsPool.push(t)), t;
            }, e.recoverAllHitResultsPool = function() {
                this._hitResultsPoolIndex = 0;
            }, e.getContactPoints = function() {
                var t = this._contactPointsPool[this._contactPonintsPoolIndex++];
                return t || (t = new Y(), this._contactPointsPool.push(t)), t;
            }, e.recoverAllContactPointsPool = function() {
                this._contactPonintsPoolIndex = 0;
            }, e.getCollision = function(t, e) {
                var n, i = t.id,
                    r = e.id,
                    a = this._collisions[i];
                return a && (n = a[r]), n || (a || (a = {}, this._collisions[i] = a), (n = 0 === this._collisionsPool.length ? new he() : this._collisionsPool.pop())._colliderA = t,
                    n._colliderB = e, a[r] = n), n;
            }, e.recoverCollision = function(t) {
                var e = t._colliderA.id,
                    n = t._colliderB.id;
                this._collisions[e][n] = null, this._collisionsPool.push(t);
            }, e.garbageCollection = function() {
                for (var t in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0,
                        this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                    var e = this._collisionsPool[t],
                        n = !0;
                    for (var i in e) e[i] ? n = !1 : delete e[i];
                    n && delete this._collisionsPool[t];
                }
            }, t;
        }(),
        Xt = function() {
            function p() {
                this._scene = null, this._eventList = [], this._multiTouchEnabled = !0, this._mouseTouch = new ne(),
                    this._touchPool = [], this._touches = new Je();
            }
            d(p, "laya.d3.Input3D");
            var t = p.prototype;
            return t.__init__ = function(t, e) {
                this._scene = e;
                var n = this._eventList;
                t.oncontextmenu = function(t) {
                    return !1;
                }, t.addEventListener("mousedown", function(t) {
                    t.preventDefault(), n.push(t);
                }), t.addEventListener("mouseup", function(t) {
                    t.preventDefault(), n.push(t);
                }, !0), t.addEventListener("mousemove", function(t) {
                    t.preventDefault(), n.push(t);
                }, !0), t.addEventListener("touchstart", function(t) {
                    t.preventDefault(), n.push(t);
                }), t.addEventListener("touchend", function(t) {
                    t.preventDefault(), n.push(t);
                }, !0), t.addEventListener("touchmove", function(t) {
                    t.preventDefault(), n.push(t);
                }, !0), t.addEventListener("touchcancel", function(t) {
                    n.push(t);
                }, !0);
            }, t.touchCount = function() {
                return this._touches.length;
            }, t._getTouch = function(t) {
                var e = this._touchPool[t];
                return e || (e = new le(), (this._touchPool[t] = e)._identifier = t), e;
            }, t._mouseTouchDown = function() {
                var t = this._mouseTouch,
                    e = t.sprite;
                if (t._pressedSprite = e, t._pressedLoopCount = M.loopCount, e) {
                    var n = e._scripts;
                    if (n)
                        for (var i = 0, r = n.length; i < r; i++) n[i].onMouseDown();
                }
            }, t._mouseTouchUp = function() {
                var t = 0,
                    e = 0,
                    n = this._mouseTouch,
                    i = n._pressedSprite;
                n._pressedSprite = null, n._pressedLoopCount = -1;
                var r = n.sprite;
                if (r && r === i) {
                    var a = r._scripts;
                    if (a)
                        for (t = 0, e = a.length; t < e; t++) a[t].onMouseClick();
                }
                if (i) {
                    var o = i._scripts;
                    if (o)
                        for (t = 0, e = o.length; t < e; t++) o[t].onMouseUp();
                }
            }, t._mouseTouchRayCast = function(t) {
                var e = p._tempHitResult0,
                    n = p._tempVector20,
                    i = p._tempRay0;
                e.succeeded = !1;
                var r = this._mouseTouch.mousePositionX,
                    a = this._mouseTouch.mousePositionY;
                n.x = r, n.y = a;
                for (var o = t.length - 1; 0 <= o; o--) {
                    var s = t[o],
                        l = s.viewport;
                    if (n.x >= l.x && n.y >= l.y && n.x <= l.width && n.y <= l.height)
                        if (s.viewportPointToRay(n, i),
                            this._scene._physicsSimulation.rayCast(i, e) || 0 === s.clearFlag || 1 === s.clearFlag) break;
                }
                var h = this._mouseTouch,
                    u = h.sprite;
                if (e.succeeded) {
                    var c = e.collider.owner,
                        _ = (h.sprite = c)._scripts;
                    if (u !== c && _)
                        for (var d = 0, f = _.length; d < f; d++) _[d].onMouseEnter();
                } else h.sprite = null;
                if (u && u !== c) {
                    var m = u._scripts;
                    if (m)
                        for (d = 0, f = m.length; d < f; d++) m[d].onMouseOut();
                }
            }, t._changeTouches = function(t, e) {
                for (var n = 0, i = 0, r = this._touches.length, a = 0, o = t.length; a < o; a++) {
                    var s = t[a],
                        l = s.identifier;
                    if (this._multiTouchEnabled || 0 === l) {
                        var h = this._getTouch(l),
                            u = h._position,
                            c = p._tempPoint;
                        c.setTo(s.pageX, s.pageY), m.stage._canvasTransform.invertTransformPoint(c);
                        var _ = c.x,
                            d = c.y;
                        switch (e) {
                            case 0:
                                this._touches.add(h), n += _, i += d;
                                break;

                            case 1:
                                this._touches.remove(h), n -= _, i -= d;
                                break;

                            case 2:
                                n = _ - u.x, i = d - u.y;
                        }
                        u.x = _, u.y = d;
                    }
                }
                var f = this._touches.length;
                this._mouseTouch.mousePositionY = 0 === f ? this._mouseTouch.mousePositionX = 0 : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * r + n) / f,
                    (this._mouseTouch.mousePositionY * r + i) / f);
            }, t._update = function() {
                var t, e = 0,
                    n = 0,
                    i = 0;
                t = this._eventList.length;
                var r = this._scene._cameraPool;
                if (0 < t) {
                    for (e = 0; e < t; e++) {
                        var a = this._eventList[e];
                        switch (a.type) {
                            case "mousedown":
                                this._mouseTouchDown();
                                break;

                            case "mouseup":
                                this._mouseTouchUp();
                                break;

                            case "mousemove":
                                var o = p._tempPoint;
                                o.setTo(a.pageX, a.pageY), m.stage._canvasTransform.invertTransformPoint(o), this._mouseTouch.mousePositionX = o.x,
                                    this._mouseTouch.mousePositionY = o.y, this._mouseTouchRayCast(r);
                                break;

                            case "touchstart":
                                var s = this._touches.length;
                                this._changeTouches(a.changedTouches, 0), this._mouseTouchRayCast(r), 0 === s && this._mouseTouchDown();
                                break;

                            case "touchend":
                            case "touchcancel":
                                this._changeTouches(a.changedTouches, 1), 0 === this._touches.length && this._mouseTouchUp();
                                break;

                            case "touchmove":
                                this._changeTouches(a.changedTouches, 2), this._mouseTouchRayCast(r);
                                break;

                            default:
                                throw "Input3D:unkonwn event type.";
                        }
                    }
                    this._eventList.length = 0;
                }
                var l = this._mouseTouch,
                    h = l._pressedSprite;
                if (h && M.loopCount > l._pressedLoopCount) {
                    var u = h._scripts;
                    if (u)
                        for (n = 0, i = u.length; n < i; n++) u[n].onMouseDrag();
                }
                var c = l.sprite;
                if (c) {
                    var _ = c._scripts;
                    if (_)
                        for (n = 0, i = _.length; n < i; n++) _[n].onMouseOver();
                }
            }, t.getTouch = function(t) {
                return t < this._touches.length ? this._touches.elements[t] : null;
            }, u(0, t, "multiTouchEnabled", function() {
                return this._multiTouchEnabled;
            }, function(t) {
                this._multiTouchEnabled = t;
            }), _(p, ["_tempPoint", function() {
                return this._tempPoint = new g();
            }, "_tempVector20", function() {
                return this._tempVector20 = new Lt();
            }, "_tempRay0", function() {
                return this._tempRay0 = new X(new Ct(), new Ct());
            }, "_tempHitResult0", function() {
                return this._tempHitResult0 = new de();
            }]), p;
        }(),
        Yt = function() {
            function U() {}
            return d(U, "laya.d3.core.particleShuriKen.ShurikenParticleData"), U._getStartLifetimeFromGradient = function(t, e) {
                for (var n = 1, i = t.gradientCount; n < i; n++) {
                    var r = t.getKeyByIndex(n);
                    if (e <= r) {
                        var a = t.getKeyByIndex(n - 1),
                            o = (e - a) / (r - a);
                        return z.lerp(t.getValueByIndex(n - 1), t.getValueByIndex(n), o);
                    }
                }
                throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
            }, U._randomInvertRoationArray = function(t, e, n, i, r) {
                var a = NaN;
                i ? (i.seed = r[6], a = i.getFloat(), r[6] = i.seed) : a = Math.random(), e.z = a < n ? (e.x = -t.x,
                    e.y = -t.y, -t.z) : (e.x = t.x, e.y = t.y, t.z);
            }, U._randomInvertRoation = function(t, e, n, i) {
                var r = NaN;
                return n ? (n.seed = i[6], r = n.getFloat(), i[6] = n.seed) : r = Math.random(),
                    r < e && (t = -t), t;
            }, U.create = function(t, e, n) {
                var i = t.autoRandomSeed,
                    r = t._rand,
                    a = t._randomSeeds;
                switch (t.startColorType) {
                    case 0:
                        var o = t.startColorConstant;
                        U.startColor.x = o.x, U.startColor.y = o.y, U.startColor.z = o.z, U.startColor.w = o.w;
                        break;

                    case 2:
                        i ? At.lerp(t.startColorConstantMin, t.startColorConstantMax, Math.random(), U.startColor) : (r.seed = a[3],
                            At.lerp(t.startColorConstantMin, t.startColorConstantMax, r.getFloat(), U.startColor),
                            a[3] = r.seed);
                }
                var s = t.colorOverLifetime;
                if (s && s.enbale) {
                    var l = s.color;
                    switch (l.type) {
                        case 0:
                            U.startColor.x = U.startColor.x * l.constant.x, U.startColor.y = U.startColor.y * l.constant.y,
                                U.startColor.z = U.startColor.z * l.constant.z, U.startColor.w = U.startColor.w * l.constant.w;
                            break;

                        case 2:
                            var h = NaN;
                            i ? h = Math.random() : (r.seed = a[10], h = r.getFloat(), a[10] = r.seed);
                            var u = l.constantMin,
                                c = l.constantMax;
                            U.startColor.x = U.startColor.x * z.lerp(u.x, c.x, h), U.startColor.y = U.startColor.y * z.lerp(u.y, c.y, h),
                                U.startColor.z = U.startColor.z * z.lerp(u.z, c.z, h), U.startColor.w = U.startColor.w * z.lerp(u.w, c.w, h);
                    }
                }
                var _ = U.startSize;
                switch (t.startSizeType) {
                    case 0:
                        if (t.threeDStartSize) {
                            var d = t.startSizeConstantSeparate;
                            _[0] = d.x, _[1] = d.y, _[2] = d.z;
                        } else _[0] = _[1] = _[2] = t.startSizeConstant;
                        break;

                    case 2:
                        if (t.threeDStartSize) {
                            var f = t.startSizeConstantMinSeparate,
                                m = t.startSizeConstantMaxSeparate;
                            i ? (_[0] = z.lerp(f.x, m.x, Math.random()), _[1] = z.lerp(f.y, m.y, Math.random()),
                                _[2] = z.lerp(f.z, m.z, Math.random())) : (r.seed = a[4], _[0] = z.lerp(f.x, m.x, r.getFloat()),
                                _[1] = z.lerp(f.y, m.y, r.getFloat()), _[2] = z.lerp(f.z, m.z, r.getFloat()), a[4] = r.seed);
                        } else i ? _[0] = _[1] = _[2] = z.lerp(t.startSizeConstantMin, t.startSizeConstantMax, Math.random()) : (r.seed = a[4],
                            _[0] = _[1] = _[2] = z.lerp(t.startSizeConstantMin, t.startSizeConstantMax, r.getFloat()),
                            a[4] = r.seed);
                }
                var p = t.sizeOverLifetime;
                if (p && p.enbale && 1 === p.size.type) {
                    var T = p.size;
                    if (T.separateAxes) i ? (_[0] = _[0] * z.lerp(T.constantMinSeparate.x, T.constantMaxSeparate.x, Math.random()),
                        _[1] = _[1] * z.lerp(T.constantMinSeparate.y, T.constantMaxSeparate.y, Math.random()),
                        _[2] = _[2] * z.lerp(T.constantMinSeparate.z, T.constantMaxSeparate.z, Math.random())) : (r.seed = a[11],
                        _[0] = _[0] * z.lerp(T.constantMinSeparate.x, T.constantMaxSeparate.x, r.getFloat()),
                        _[1] = _[1] * z.lerp(T.constantMinSeparate.y, T.constantMaxSeparate.y, r.getFloat()),
                        _[2] = _[2] * z.lerp(T.constantMinSeparate.z, T.constantMaxSeparate.z, r.getFloat()),
                        a[11] = r.seed);
                    else {
                        var E = NaN;
                        i ? E = z.lerp(T.constantMin, T.constantMax, Math.random()) : (r.seed = a[11], E = z.lerp(T.constantMin, T.constantMax, r.getFloat()),
                            a[11] = r.seed), _[0] = _[0] * E, _[1] = _[1] * E, _[2] = _[2] * E;
                    }
                }
                var v = e.renderMode;
                if (1 !== v) switch (t.startRotationType) {
                    case 0:
                        if (t.threeDStartRotation) {
                            var g = t.startRotationConstantSeparate,
                                S = U._tempVector30;
                            U._randomInvertRoationArray(g, S, t.randomizeRotationDirection, i ? null : r, a),
                                U.startRotation[0] = S.x, U.startRotation[1] = S.y, U.startRotation[2] = 4 !== v ? -S.z : S.z;
                        } else U.startRotation[0] = U._randomInvertRoation(t.startRotationConstant, t.randomizeRotationDirection, i ? null : r, a),
                            U.startRotation[1] = 0, U.startRotation[2] = 0;
                        break;

                    case 2:
                        if (t.threeDStartRotation) {
                            var y = t.startRotationConstantMinSeparate,
                                x = t.startRotationConstantMaxSeparate,
                                D = U._tempVector30;
                            i ? (D.x = z.lerp(y.x, x.x, Math.random()), D.y = z.lerp(y.y, x.y, Math.random()),
                                    D.z = z.lerp(y.z, x.z, Math.random())) : (r.seed = a[5], D.x = z.lerp(y.x, x.x, r.getFloat()),
                                    D.y = z.lerp(y.y, x.y, r.getFloat()), D.z = z.lerp(y.z, x.z, r.getFloat()), a[5] = r.seed),
                                U._randomInvertRoationArray(D, D, t.randomizeRotationDirection, i ? null : r, a),
                                U.startRotation[0] = D.x, U.startRotation[1] = D.y, U.startRotation[2] = 4 !== v ? -D.z : D.z;
                        } else i ? U.startRotation[0] = U._randomInvertRoation(z.lerp(t.startRotationConstantMin, t.startRotationConstantMax, Math.random()), t.randomizeRotationDirection, i ? null : r, a) : (r.seed = a[5],
                            U.startRotation[0] = U._randomInvertRoation(z.lerp(t.startRotationConstantMin, t.startRotationConstantMax, r.getFloat()), t.randomizeRotationDirection, i ? null : r, a),
                            a[5] = r.seed);
                }
                switch (t.startLifetimeType) {
                    case 0:
                        U.startLifeTime = t.startLifetimeConstant;
                        break;

                    case 1:
                        U.startLifeTime = U._getStartLifetimeFromGradient(t.startLifeTimeGradient, t.emissionTime);
                        break;

                    case 2:
                        i ? U.startLifeTime = z.lerp(t.startLifetimeConstantMin, t.startLifetimeConstantMax, Math.random()) : (r.seed = a[7],
                            U.startLifeTime = z.lerp(t.startLifetimeConstantMin, t.startLifetimeConstantMax, r.getFloat()),
                            a[7] = r.seed);
                        break;

                    case 3:
                        var I = t.emissionTime;
                        i ? U.startLifeTime = z.lerp(U._getStartLifetimeFromGradient(t.startLifeTimeGradientMin, I), U._getStartLifetimeFromGradient(t.startLifeTimeGradientMax, I), Math.random()) : (r.seed = a[7],
                            U.startLifeTime = z.lerp(U._getStartLifetimeFromGradient(t.startLifeTimeGradientMin, I), U._getStartLifetimeFromGradient(t.startLifeTimeGradientMax, I), r.getFloat()),
                            a[7] = r.seed);
                }
                switch (t.startSpeedType) {
                    case 0:
                        U.startSpeed = t.startSpeedConstant;
                        break;

                    case 2:
                        i ? U.startSpeed = z.lerp(t.startSpeedConstantMin, t.startSpeedConstantMax, Math.random()) : (r.seed = a[8],
                            U.startSpeed = z.lerp(t.startSpeedConstantMin, t.startSpeedConstantMax, r.getFloat()),
                            a[8] = r.seed);
                }
                var R = t.textureSheetAnimation;
                if (R && R.enable) {
                    var M = R.tiles,
                        A = M.x,
                        C = M.y,
                        L = 1 / A,
                        O = 1 / C,
                        N = 0,
                        V = R.startFrame;
                    switch (V.type) {
                        case 0:
                            N = V.constant;
                            break;

                        case 1:
                            i ? N = z.lerp(V.constantMin, V.constantMax, Math.random()) : (r.seed = a[14], N = z.lerp(V.constantMin, V.constantMax, r.getFloat()),
                                a[14] = r.seed);
                    }
                    var w = R.frame;
                    switch (w.type) {
                        case 0:
                            N += w.constant;
                            break;

                        case 2:
                            i ? N += z.lerp(w.constantMin, w.constantMax, Math.random()) : (r.seed = a[15],
                                N += z.lerp(w.constantMin, w.constantMax, r.getFloat()), a[15] = r.seed);
                    }
                    var P = 0;
                    switch (R.type) {
                        case 0:
                            P = Math.floor(N / A);
                            break;

                        case 1:
                            R.randomRow ? i ? P = Math.floor(Math.random() * C) : (r.seed = a[13], P = Math.floor(r.getFloat() * C),
                                a[13] = r.seed) : P = R.rowIndex;
                    }
                    var b = Math.floor(N % A);
                    (U.startUVInfo = U.startUVInfo)[0] = L, U.startUVInfo[1] = O, U.startUVInfo[2] = b * L,
                        U.startUVInfo[3] = P * O;
                } else(U.startUVInfo = U.startUVInfo)[0] = 1, U.startUVInfo[1] = 1, U.startUVInfo[2] = 0,
                    U.startUVInfo[3] = 0;
                switch (t.simulationSpace) {
                    case 0:
                        var F = n.position;
                        U.simulationWorldPostion[0] = F.x, U.simulationWorldPostion[1] = F.y, U.simulationWorldPostion[2] = F.z;
                        var B = n.rotation;
                        U.simulationWorldRotation[0] = B.x, U.simulationWorldRotation[1] = B.y, U.simulationWorldRotation[2] = B.z,
                            U.simulationWorldRotation[3] = B.w;
                        break;

                    case 1:
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
            }, U.startLifeTime = NaN, U.startSpeed = NaN, _(U, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempQuaternion", function() {
                return this._tempQuaternion = new rt();
            }, "startColor", function() {
                return this.startColor = new At();
            }, "startSize", function() {
                return this.startSize = new Float32Array(3);
            }, "startRotation", function() {
                return this.startRotation = new Float32Array(3);
            }, "startUVInfo", function() {
                return this.startUVInfo = new Float32Array(4);
            }, "simulationWorldPostion", function() {
                return this.simulationWorldPostion = new Float32Array(3);
            }, "simulationWorldRotation", function() {
                return this.simulationWorldRotation = new Float32Array(4);
            }]), U;
        }(),
        Zt = function() {
            function c(t, e, n, i) {
                this._octree = null, this._parent = null, this._children = null, this._isContaion = !1,
                    this.baseLength = 0, this._bounds = new we(new Ct(), new Ct()), this._objects = [],
                    this.center = new Ct(), this._setValues(t, e, n, i);
            }
            d(c, "laya.d3.core.scene.BoundsOctreeNode");
            var t = c.prototype;
            return t._setValues = function(t, e, n, i) {
                this._octree = t, this._parent = e, this.baseLength = n, i.cloneTo(this.center);
                var r = this._bounds.min,
                    a = this._bounds.max,
                    o = t._looseness * n / 2;
                r.setValue(i.x - o, i.y - o, i.z - o), a.setValue(i.x + o, i.y + o, i.z + o);
            }, t._getChildBound = function(t) {
                if (null != this._children && this._children[t]) return this._children[t]._bounds;
                var e = this.baseLength / 4,
                    n = this.baseLength / 2 * this._octree._looseness / 2,
                    i = c._tempBoundBox,
                    r = i.min,
                    a = i.max;
                switch (t) {
                    case 0:
                        r.x = this.center.x - e - n, r.y = this.center.y + e - n, r.z = this.center.z - e - n,
                            a.x = this.center.x - e + n, a.y = this.center.y + e + n, a.z = this.center.z - e + n;
                        break;

                    case 1:
                        r.x = this.center.x + e - n, r.y = this.center.y + e - n, r.z = this.center.z - e - n,
                            a.x = this.center.x + e + n, a.y = this.center.y + e + n, a.z = this.center.z - e + n;
                        break;

                    case 2:
                        r.x = this.center.x - e - n, r.y = this.center.y + e - n, r.z = this.center.z + e - n,
                            a.x = this.center.x - e + n, a.y = this.center.y + e + n, a.z = this.center.z + e + n;
                        break;

                    case 3:
                        r.x = this.center.x + e - n, r.y = this.center.y + e - n, r.z = this.center.z + e - n,
                            a.x = this.center.x + e + n, a.y = this.center.y + e + n, a.z = this.center.z + e + n;
                        break;

                    case 4:
                        r.x = this.center.x - e - n, r.y = this.center.y - e - n, r.z = this.center.z - e - n,
                            a.x = this.center.x - e + n, a.y = this.center.y - e + n, a.z = this.center.z - e + n;
                        break;

                    case 5:
                        r.x = this.center.x + e - n, r.y = this.center.y - e - n, r.z = this.center.z - e - n,
                            a.x = this.center.x + e + n, a.y = this.center.y - e + n, a.z = this.center.z - e + n;
                        break;

                    case 6:
                        r.x = this.center.x - e - n, r.y = this.center.y - e - n, r.z = this.center.z + e - n,
                            a.x = this.center.x - e + n, a.y = this.center.y - e + n, a.z = this.center.z + e + n;
                        break;

                    case 7:
                        r.x = this.center.x + e - n, r.y = this.center.y - e - n, r.z = this.center.z + e - n,
                            a.x = this.center.x + e + n, a.y = this.center.y - e + n, a.z = this.center.z + e + n;
                }
                return i;
            }, t._getChildCenter = function(t) {
                if (null != this._children) return this._children[t].center;
                var e = this.baseLength / 4,
                    n = c._tempVector30;
                switch (t) {
                    case 0:
                        n.x = this.center.x - e, n.y = this.center.y + e, n.z = this.center.z - e;
                        break;

                    case 1:
                        n.x = this.center.x + e, n.y = this.center.y + e, n.z = this.center.z - e;
                        break;

                    case 2:
                        n.x = this.center.x - e, n.y = this.center.y + e, n.z = this.center.z + e;
                        break;

                    case 3:
                        n.x = this.center.x + e, n.y = this.center.y + e, n.z = this.center.z + e;
                        break;

                    case 4:
                        n.x = this.center.x - e, n.y = this.center.y - e, n.z = this.center.z - e;
                        break;

                    case 5:
                        n.x = this.center.x + e, n.y = this.center.y - e, n.z = this.center.z - e;
                        break;

                    case 6:
                        n.x = this.center.x - e, n.y = this.center.y - e, n.z = this.center.z + e;
                        break;

                    case 7:
                        n.x = this.center.x + e, n.y = this.center.y - e, n.z = this.center.z + e;
                }
                return n;
            }, t._getChild = function(t) {
                var e = this.baseLength / 4;
                switch (this._children || (this._children = P(8, null)), t) {
                    case 0:
                        return this._children[0] || (this._children[0] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x + -e, this.center.y + e, this.center.z - e)));

                    case 1:
                        return this._children[1] || (this._children[1] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x + e, this.center.y + e, this.center.z - e)));

                    case 2:
                        return this._children[2] || (this._children[2] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x - e, this.center.y + e, this.center.z + e)));

                    case 3:
                        return this._children[3] || (this._children[3] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x + e, this.center.y + e, this.center.z + e)));

                    case 4:
                        return this._children[4] || (this._children[4] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x - e, this.center.y - e, this.center.z - e)));

                    case 5:
                        return this._children[5] || (this._children[5] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x + e, this.center.y - e, this.center.z - e)));

                    case 6:
                        return this._children[6] || (this._children[6] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x - e, this.center.y - e, this.center.z + e)));

                    case 7:
                        return this._children[7] || (this._children[7] = new c(this._octree, this, this.baseLength / 2, new Ct(this.center.x + e, this.center.y - e, this.center.z + e)));

                    default:
                        throw "BoundsOctreeNode: unknown index.";
                }
            }, t._shouldMerge = function() {
                for (var t = this._objects.length, e = 0; e < 8; e++) {
                    var n = this._children[e];
                    if (n) {
                        if (null != n._children) return !1;
                        t += n._objects.length;
                    }
                }
                return t <= 8;
            }, t._mergeChildren = function() {
                for (var t = 0; t < 8; t++) {
                    var e = this._children[t];
                    if (e) {
                        e._parent = null;
                        for (var n = e._objects, i = n.length - 1; 0 <= i; i--) {
                            var r = n[i];
                            this._objects.push(r), r._setOctreeNode(this);
                        }
                    }
                }
                this._children = null;
            }, t._merge = function() {
                if (null === this._children) {
                    var t = this._parent;
                    t && t._shouldMerge() && (t._mergeChildren(), t._merge());
                }
            }, t._checkAddNode = function(t) {
                if (null == this._children) {
                    if (this._objects.length < 8 || this.baseLength / 2 < this._octree._minSize) return this;
                    for (var e = this._objects.length - 1; 0 <= e; e--) {
                        var n = this._objects[e],
                            i = this._bestFitChild(n.boundingSphere.center);
                        c._encapsulates(this._getChildBound(i), n.boundingBox) && (this._objects.splice(this._objects.indexOf(n), 1),
                            this._getChild(i)._add(n));
                    }
                }
                var r = this._bestFitChild(t.boundingSphere.center);
                return c._encapsulates(this._getChildBound(r), t.boundingBox) ? this._getChild(r)._checkAddNode(t) : this;
            }, t._add = function(t) {
                var e = this._checkAddNode(t);
                e._objects.push(t), t._setOctreeNode(e);
            }, t._remove = function(t) {
                var e = this._objects.indexOf(t);
                this._objects.splice(e, 1), t._setOctreeNode(null), this._merge();
            }, t._addUp = function(t) {
                return 1 === Oe.boxContainsBox(this._bounds, t.boundingBox) ? (this._add(t), !0) : !!this._parent && this._parent._addUp(t);
            }, t._getCollidingWithFrustum = function(t, e, n, i) {
                if (n) {
                    var r = e.containsBoundBox(this._bounds);
                    if (M.octreeNodeCulling++, 0 === r) return;
                    n = 2 === r;
                }
                this._isContaion = !n;
                for (var a = t.camera, o = t.scene, s = 0, l = this._objects.length; s < l; s++) {
                    var h = this._objects[s];
                    if (a._isLayerVisible(h._owner.layer) && h._enable) {
                        if (n && (M.frustumCulling++, !h._needRender(e))) continue;
                        h._distanceForSort = Ct.distance(h.boundingSphere.center, i);
                        for (var u = h._renderElements, c = 0, _ = u.length; c < _; c++) {
                            var d = u[c],
                                f = o._getRenderQueue(d.material.renderQueue);
                            f.isTransparent ? d.addToTransparentRenderQueue(t, f) : d.addToOpaqueRenderQueue(t, f);
                        }
                    }
                }
                if (null != this._children)
                    for (s = 0; s < 8; s++) {
                        var m = this._children[s];
                        m && m._getCollidingWithFrustum(t, e, n, i);
                    }
            }, t._getCollidingWithBoundBox = function(t, e, n) {
                if (e) {
                    var i = Oe.boxContainsBox(this._bounds, t);
                    if (0 === i) return;
                    e = 2 === i;
                }
                if (e)
                    for (var r = 0, a = this._objects.length; r < a; r++) {
                        var o = this._objects[r];
                        Oe.intersectsBoxAndBox(o.boundingBox, t) && n.push(o);
                    }
                if (null != this._children)
                    for (r = 0; r < 8; r++) {
                        this._children[r]._getCollidingWithBoundBox(t, e, n);
                    }
            }, t._bestFitChild = function(t) {
                return (t.x <= this.center.x ? 0 : 1) + (t.y >= this.center.y ? 0 : 4) + (t.z <= this.center.z ? 0 : 2);
            }, t._update = function(t) {
                if (1 === Oe.boxContainsBox(this._bounds, t.boundingBox)) {
                    var e = this._checkAddNode(t);
                    if (e !== t._getOctreeNode()) {
                        e._objects.push(t), t._setOctreeNode(e);
                        var n = this._objects.indexOf(t);
                        this._objects.splice(n, 1), this._merge();
                    }
                    return !0;
                }
                if (this._parent) {
                    var i = this._parent._addUp(t);
                    return i && (n = this._objects.indexOf(t), this._objects.splice(n, 1), this._merge()),
                        i;
                }
                return !1;
            }, t.add = function(t) {
                return !!c._encapsulates(this._bounds, t.boundingBox) && (this._add(t), !0);
            }, t.remove = function(t) {
                return t._getOctreeNode() === this && (this._remove(t), !0);
            }, t.update = function(t) {
                return t._getOctreeNode() === this && this._update(t);
            }, t.shrinkIfPossible = function(t) {
                if (this.baseLength < 2 * t) return this;
                for (var e = -1, n = 0, i = this._objects.length; n < i; n++) {
                    var r = this._objects[n],
                        a = this._bestFitChild(r.boundingSphere.center);
                    if (0 != n && a != e) return this;
                    var o = this._getChildBound(a);
                    if (!c._encapsulates(o, r.boundingBox)) return this;
                    0 == n && (e = a);
                }
                if (null == this._children) {
                    if (-1 != e) {
                        var s = this._getChildCenter(e);
                        this._setValues(this._octree, null, this.baseLength / 2, s);
                    }
                    return this;
                }
                var l = !1;
                for (n = 0, i = this._children.length; n < i; n++) {
                    var h = this._children[n];
                    if (h && h.hasAnyObjects()) {
                        if (l) return this;
                        if (0 <= e && e != n) return this;
                        l = !0, e = n;
                    }
                }
                if (-1 == e) return this;
                var u = this._children[e];
                return u._parent = null, u;
            }, t.hasAnyObjects = function() {
                if (0 < this._objects.length) return !0;
                if (null != this._children)
                    for (var t = 0; t < 8; t++) {
                        var e = this._children[t];
                        if (e && e.hasAnyObjects()) return !0;
                    }
                return !1;
            }, t.getCollidingWithBoundBox = function(t, e) {
                this._getCollidingWithBoundBox(t, !0, e);
            }, t.getCollidingWithRay = function(t, e, n) {
                void 0 === n && (n = Number.MAX_VALUE);
                var i = Oe.intersectsRayAndBoxRD(t, this._bounds);
                if (!(-1 == i || n < i)) {
                    for (var r = 0, a = this._objects.length; r < a; r++) {
                        var o = this._objects[r]; -
                        1 !== (i = Oe.intersectsRayAndBoxRD(t, o.boundingBox)) && i <= n && e.push(o);
                    }
                    if (null != this._children)
                        for (r = 0; r < 8; r++) {
                            this._children[r].getCollidingWithRay(t, e, n);
                        }
                }
            }, t.getCollidingWithFrustum = function(t) {
                var e = t.camera.transform.position,
                    n = t.camera.boundFrustum;
                this._getCollidingWithFrustum(t, n, !0, e);
            }, t.isCollidingWithBoundBox = function(t) {
                if (!Oe.intersectsBoxAndBox(this._bounds, t)) return !1;
                for (var e = 0, n = this._objects.length; e < n; e++) {
                    var i = this._objects[e];
                    if (Oe.intersectsBoxAndBox(i.boundingBox, t)) return !0;
                }
                if (null != this._children)
                    for (e = 0; e < 8; e++) {
                        if (this._children[e].isCollidingWithBoundBox(t)) return !0;
                    }
                return !1;
            }, t.isCollidingWithRay = function(t, e) {
                void 0 === e && (e = Number.MAX_VALUE);
                var n = Oe.intersectsRayAndBoxRD(t, this._bounds);
                if (-1 == n || e < n) return !1;
                for (var i = 0, r = this._objects.length; i < r; i++) {
                    var a = this._objects[i];
                    if (-1 !== (n = Oe.intersectsRayAndBoxRD(t, a.boundingBox)) && n <= e) return !0;
                }
                if (null != this._children)
                    for (i = 0; i < 8; i++) {
                        if (this._children[i].isCollidingWithRay(t, e)) return !0;
                    }
                return !1;
            }, t.getBound = function() {
                return this._bounds;
            }, t.drawAllBounds = function(t, e, n) {
                if (null !== this._children || 0 != this._objects.length) {
                    e++;
                    var i = c._tempColor0;
                    if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
                    else {
                        var r = n ? e / n : 0;
                        i.r = 1 - r, i.g = r, i.b = 0;
                    }
                    if (i.a = .3, Gt._drawBound(t, this._bounds, i), null != this._children)
                        for (var a = 0; a < 8; a++) {
                            var o = this._children[a];
                            o && o.drawAllBounds(t, e, n);
                        }
                }
            }, t.drawAllObjects = function(t, e, n) {
                e++;
                var i = c._tempColor0;
                if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
                else {
                    var r = n ? e / n : 0;
                    i.r = 1 - r, i.g = r, i.b = 0;
                }
                i.a = 1;
                for (var a = 0, o = this._objects.length; a < o; a++) Gt._drawBound(t, this._objects[a].boundingBox, i);
                if (null != this._children)
                    for (a = 0; a < 8; a++) {
                        var s = this._children[a];
                        s && s.drawAllObjects(t, e, n);
                    }
            }, c._encapsulates = function(t, e) {
                return 1 == Oe.boxContainsBox(t, e);
            }, c._NUM_OBJECTS_ALLOWED = 8, _(c, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }, "_tempColor0", function() {
                return this._tempColor0 = new dt();
            }, "_tempBoundBox", function() {
                return this._tempBoundBox = new we(new Ct(), new Ct());
            }]), c;
        }(),
        jt = (function() {
            function t() {
                this._currentLength = 0, this._elements = null, this._elements = new Float32Array(12);
            }
            d(t, "laya.d3.core.particleShuriKen.module.GradientDataVector2");
            var e = t.prototype;
            m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.add = function(t, e) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== t && (t = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = t, this._elements[this._currentLength++] = e.x,
                    this._elements[this._currentLength++] = e.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
            }, e.cloneTo = function(t) {
                var e = t;
                e._currentLength = this._currentLength;
                var n = e._elements;
                n.length = this._elements.length;
                for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "gradientCount", function() {
                return this._currentLength / 3;
            });
        }(), function() {
            function t(t, e, n, i) {
                this._position = null, this._normal = null, this._textureCoord0 = null, this._textureCoord1 = null,
                    this._position = t, this._normal = e, this._textureCoord0 = n, this._textureCoord1 = i;
            }
            d(t, "laya.d3.graphics.Vertex.VertexPositionTerrain");
            var e = t.prototype;
            return m.imps(e, {
                    "laya.d3.graphics.IVertex": !0
                }), u(0, e, "normal", function() {
                    return this._normal;
                }), u(0, e, "position", function() {
                    return this._position;
                }), u(0, e, "textureCoord0", function() {
                    return this._textureCoord0;
                }), u(0, e, "textureCoord1", function() {
                    return this._textureCoord1;
                }), u(0, e, "vertexDeclaration", function() {
                    return t._vertexDeclaration;
                }), u(1, t, "vertexDeclaration", function() {
                    return t._vertexDeclaration;
                }), t.TERRAIN_POSITION0 = 0, t.TERRAIN_NORMAL0 = 1, t.TERRAIN_TEXTURECOORDINATE0 = 2,
                t.TERRAIN_TEXTURECOORDINATE1 = 3, _(t, ["_vertexDeclaration", function() {
                    return this._vertexDeclaration = new ue(40, [new Bt(0, "vector3", 0), new Bt(12, "vector3", 1), new Bt(24, "vector2", 2), new Bt(32, "vector2", 3)]);
                }]), t;
        }()),
        Kt = function() {
            function t() {
                this._nodes = [];
            }
            d(t, "laya.d3.animation.KeyframeNodeList");
            var e = t.prototype;
            return e.getNodeByIndex = function(t) {
                return this._nodes[t];
            }, e.setNodeByIndex = function(t, e) {
                this._nodes[t] = e;
            }, u(0, e, "count", function() {
                return this._nodes.length;
            }, function(t) {
                this._nodes.length = t;
            }), t;
        }(),
        qt = function() {
            function i(t, e, n, i) {
                this._initialSize = NaN, this._rootNode = null, this._looseness = NaN, this._minSize = NaN,
                    this.count = 0, this._motionObjects = new cn(), t < n && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + n + " Adjusted to: " + t),
                        n = t), this._initialSize = t, this._minSize = n, this._looseness = Math.min(Math.max(i, 1), 2),
                    this._rootNode = new Zt(this, null, t, e);
            }
            d(i, "laya.d3.core.scene.BoundsOctree");
            var t = i.prototype;
            return t._getMaxDepth = function(t, e) {
                e++;
                var n = t._children;
                if (null != n)
                    for (var i = e, r = 0, a = n.length; r < a; r++) {
                        var o = n[r];
                        o && (e = Math.max(this._getMaxDepth(o, i), e));
                    }
                return e;
            }, t._grow = function(t) {
                var e = 0 <= t.x ? 1 : -1,
                    n = 0 <= t.y ? 1 : -1,
                    i = 0 <= t.z ? 1 : -1,
                    r = this._rootNode,
                    a = this._rootNode.baseLength / 2,
                    o = 2 * this._rootNode.baseLength,
                    s = this._rootNode.center,
                    l = new Ct(s.x + e * a, s.y + n * a, s.z + i * a);
                if (this._rootNode = new Zt(this, null, o, l), r.hasAnyObjects()) {
                    for (var h = this._rootNode._bestFitChild(r.center), u = P(8, null), c = 0; c < 8; c++) c == h && (r._parent = this._rootNode,
                        u[c] = r);
                    this._rootNode._children = u;
                }
            }, t.add = function(t) {
                for (var e = 0; !this._rootNode.add(t);) {
                    var n = i._tempVector30;
                    if (Ct.subtract(t.boundingSphere.center, this._rootNode.center, n), this._grow(n),
                        20 < ++e) throw "Aborted Add operation as it seemed to be going on forever (" + (e - 1) + ") attempts at growing the octree.";
                }
                this.count++;
            }, t.remove = function(t) {
                var e = t._getOctreeNode().remove(t);
                return e && this.count--, e;
            }, t.update = function(t) {
                var e = 0,
                    n = t._getOctreeNode();
                if (n) {
                    for (; !n._update(t);)
                        if (this._grow(t.boundingSphere.center), 20 < ++e) throw "Aborted Add operation as it seemed to be going on forever (" + (e - 1) + ") attempts at growing the octree.";
                    return !0;
                }
                return !1;
            }, t.shrinkRootIfPossible = function() {
                this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
            }, t.addMotionObject = function(t) {
                this._motionObjects.add(t);
            }, t.removeMotionObject = function(t) {
                this._motionObjects.remove(t);
            }, t.updateMotionObjects = function() {
                for (var t = this._motionObjects.elements, e = 0, n = this._motionObjects.length; e < n; e++) {
                    var i = t[e];
                    this.update(i), i._setIndexInMotionList(-1);
                }
                this._motionObjects.length = 0;
            }, t.isCollidingWithBoundBox = function(t) {
                return this._rootNode.isCollidingWithBoundBox(t);
            }, t.isCollidingWithRay = function(t, e) {
                return void 0 === e && (e = Number.MAX_VALUE), this._rootNode.isCollidingWithRay(t, e);
            }, t.getCollidingWithBoundBox = function(t, e) {
                this._rootNode.getCollidingWithBoundBox(t, e);
            }, t.getCollidingWithRay = function(t, e, n) {
                void 0 === n && (n = Number.MAX_VALUE), this._rootNode.getCollidingWithRay(t, e, n);
            }, t.getCollidingWithFrustum = function(t) {
                this._rootNode.getCollidingWithFrustum(t);
            }, t.getMaxBounds = function() {
                return this._rootNode.getBound();
            }, t.drawAllBounds = function(t) {
                var e = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllBounds(t, -1, e);
            }, t.drawAllObjects = function(t) {
                var e = this._getMaxDepth(this._rootNode, -1);
                this._rootNode.drawAllObjects(t, -1, e);
            }, _(i, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }]), i;
        }(),
        Qt = function() {
            function t(t) {
                this._owner = null, this._sharedMesh = null, this._owner = t;
            }
            d(t, "laya.d3.core.MeshFilter");
            var e = t.prototype;
            return e._getMeshDefine = function(t) {
                for (var e = 0, n = 0, i = t._subMeshCount; n < i; n++)
                    for (var r = t._getSubMesh(n)._vertexBuffer._vertexDeclaration.vertexElements, a = 0, o = r.length; a < o; a++) {
                        switch (r[a].elementUsage) {
                            case 1:
                                e |= li.SHADERDEFINE_COLOR;
                                break;

                            case 2:
                                e |= li.SHADERDEFINE_UV0;
                                break;

                            case 7:
                                e |= li.SHADERDEFINE_UV1;
                        }
                    }
                return e;
            }, e.destroy = function() {
                this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
            }, u(0, e, "sharedMesh", function() {
                return this._sharedMesh;
            }, function(t) {
                if (this._sharedMesh !== t) {
                    var e = this._owner._render._defineDatas,
                        n = this._sharedMesh;
                    n && (n._removeReference(), e.remove(this._getMeshDefine(n))), t._addReference(),
                        this._sharedMesh = t, e.add(this._getMeshDefine(t)), this._owner._render._changeRenderObjectsByMesh(t);
                }
                this._owner._render._onMeshChange(t);
            }), t;
        }(),
        Jt = function() {
            function t(t) {
                this._minVertexDistance = NaN, this._widthMultiplier = NaN, this._time = NaN, this._widthCurve = null,
                    this._colorGradient = null, this._textureMode = 0, this._trialGeometry = null, this._totalLength = 0,
                    this._owner = null, this._curtime = 0, this._trailRenderElementIndex = 0, this._lastPosition = new Ct(),
                    this.alignment = 0, this._owner = t, this._initDefaultData(), this.addRenderElement();
            }
            d(t, "laya.d3.core.trail.TrailFilter");
            var e = t.prototype;
            return e.addRenderElement = function() {
                var t = this._owner._render,
                    e = t._renderElements,
                    n = t.sharedMaterials[0];
                n || (n = Yn.defaultMaterial);
                var i = new Et();
                i.setTransform(this._owner._transform), i.render = t, i.material = n, this._trialGeometry = new nn(this),
                    i.setGeometry(this._trialGeometry), e.push(i);
            }, e._update = function(t) {
                var e = this._owner._render;
                this._curtime += t.scene.timer._delta / 1e3, e._shaderValues.setNumber(ci.CURTIME, this._curtime);
                var n = this._owner.transform.position,
                    i = e._renderElements[0]._geometry;
                i._updateDisappear(), i._updateTrail(t.camera, this._lastPosition, n), i._updateVertexBufferUV(),
                    n.cloneTo(this._lastPosition);
            }, e._initDefaultData = function() {
                this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = 0;
                var t = [],
                    e = new un();
                e.time = 0, e.inTangent = 0, e.outTangent = 0, e.value = 1, t.push(e);
                var n = new un();
                n.time = 1, n.inTangent = 0, n.outTangent = 0, n.value = 1, t.push(n), this.widthCurve = t;
                var i = new it(2, 2);
                i.mode = 0, i.addColorRGB(0, dt.WHITE), i.addColorRGB(1, dt.WHITE), i.addColorAlpha(0, 1),
                    i.addColorAlpha(1, 1), this.colorGradient = i;
            }, e.destroy = function() {
                this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null,
                    this._colorGradient = null;
            }, u(0, e, "widthMultiplier", function() {
                return this._widthMultiplier;
            }, function(t) {
                this._widthMultiplier = t;
            }), u(0, e, "time", function() {
                return this._time;
            }, function(t) {
                this._time = t, this._owner._render._shaderValues.setNumber(ci.LIFETIME, t);
            }), u(0, e, "widthCurve", function() {
                return this._widthCurve;
            }, function(t) {
                this._widthCurve = t;
                var e, n = new Float32Array(4 * t.length),
                    i = 0,
                    r = 0;
                for (i = 0, e = t.length; i < e; i++) n[r++] = t[i].time, n[r++] = t[i].inTangent,
                    n[r++] = t[i].outTangent, n[r++] = t[i].value;
                this._owner._render._shaderValues.setBuffer(ci.WIDTHCURVE, n), this._owner._render._shaderValues.setInt(ci.WIDTHCURVEKEYLENGTH, t.length);
            }), u(0, e, "minVertexDistance", function() {
                return this._minVertexDistance;
            }, function(t) {
                this._minVertexDistance = t;
            }), u(0, e, "colorGradient", function() {
                return this._colorGradient;
            }, function(t) {
                this._colorGradient = t, this._owner._render._shaderValues.setBuffer(ci.GRADIENTCOLORKEY, t._rgbElements),
                    this._owner._render._shaderValues.setBuffer(ci.GRADIENTALPHAKEY, t._alphaElements),
                    0 == t.mode ? this._owner._render._defineDatas.add(ci.SHADERDEFINE_GRADIENTMODE_BLEND) : this._owner._render._defineDatas.remove(ci.SHADERDEFINE_GRADIENTMODE_BLEND);
            }), u(0, e, "textureMode", function() {
                return this._textureMode;
            }, function(t) {
                this._textureMode = t;
            }), t.ALIGNMENT_VIEW = 0, t.ALIGNMENT_TRANSFORM_Z = 1, t;
        }(),
        $t = function() {
            function t() {}
            d(t, "laya.d3.core.trail.VertexTrail");
            var e = t.prototype;
            return m.imps(e, {
                    "laya.d3.graphics.IVertex": !0
                }), u(0, e, "vertexDeclaration", function() {
                    return t._vertexDeclaration1;
                }), u(1, t, "vertexDeclaration1", function() {
                    return t._vertexDeclaration1;
                }), u(1, t, "vertexDeclaration2", function() {
                    return t._vertexDeclaration2;
                }), t.TRAIL_POSITION0 = 0, t.TRAIL_OFFSETVECTOR = 1, t.TRAIL_TIME0 = 2, t.TRAIL_TEXTURECOORDINATE0Y = 3,
                t.TRAIL_TEXTURECOORDINATE0X = 4, _(t, ["_vertexDeclaration1", function() {
                    return this._vertexDeclaration1 = new ue(32, [new Bt(0, "vector3", 0), new Bt(12, "vector3", 1), new Bt(24, "single", 2), new Bt(28, "single", 3)]);
                }, "_vertexDeclaration2", function() {
                    return this._vertexDeclaration2 = new ue(4, [new Bt(0, "single", 4)]);
                }]), t;
        }(),
        te = function() {
            function t(t, e, n) {
                this._time = NaN, this._minCount = 0, this._maxCount = 0, this._time = t, this._minCount = e,
                    this._maxCount = n;
            }
            d(t, "laya.d3.core.particleShuriKen.module.Burst");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                e._time = this._time, e._minCount = this._minCount, e._maxCount = this._maxCount;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "time", function() {
                return this._time;
            }), u(0, e, "minCount", function() {
                return this._minCount;
            }), u(0, e, "maxCount", function() {
                return this._maxCount;
            }), t;
        }(),
        ee = function() {
            function t() {
                this.time = NaN, this.eventName = null, this.params = null;
            }
            return d(t, "laya.d3.animation.AnimationEvent"), t;
        }(),
        ne = (function() {
            function t() {
                this._nativeConstraint = null, this._simulation = null, this.rigidbodyA = null,
                    this.rigidbodyB = null;
            }
            d(t, "laya.d3.physics.Constraint3D");
        }(), function() {
            function t() {
                this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0,
                    this.mousePositionY = 0;
            }
            return d(t, "laya.d3.MouseTouch"), t;
        }()),
        ie = function() {
            function t() {
                this._currentLength = 0, this._elements = null, this._elements = new Float32Array(8);
            }
            d(t, "laya.d3.core.particleShuriKen.module.GradientDataInt");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.add = function(t, e) {
                this._currentLength < 8 ? (6 === this._currentLength && 1 !== t && (t = 1, console.log("Warning:the forth key is  be force set to 1.")),
                    this._elements[this._currentLength++] = t, this._elements[this._currentLength++] = e) : console.log("Warning:data count must lessEqual than 4");
            }, e.cloneTo = function(t) {
                var e = t;
                e._currentLength = this._currentLength;
                var n = e._elements;
                n.length = this._elements.length;
                for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "gradientCount", function() {
                return this._currentLength / 2;
            }), t;
        }(),
        re = function() {
            function t(t, e, n, i) {
                this._attributeMap = null, this._uniformMap = null, this._publicDefines = null,
                    this._publicDefinesMap = null, this._spriteDefines = null, this._spriteDefinesMap = null,
                    this._materialDefines = null, this._materialDefinesMap = null, this._owner = null,
                    this._flags = {}, this._passes = [], this._publicDefines = [], this._publicDefinesMap = {},
                    this._spriteDefines = [], this._spriteDefinesMap = {}, this._materialDefines = [],
                    this._materialDefinesMap = {}, this._addDefines(this._publicDefines, this._publicDefinesMap, Vt._globleDefines),
                    n && this._addDefines(this._spriteDefines, this._spriteDefinesMap, n.defines), i && this._addDefines(this._materialDefines, this._materialDefinesMap, i.defines),
                    this._attributeMap = t, this._uniformMap = e;
            }
            d(t, "laya.d3.shader.SubShader");
            var e = t.prototype;
            return e._addDefines = function(t, e, n) {
                for (var i in n) {
                    var r = n[i],
                        a = parseInt(i);
                    e[t[a] = r] = a;
                }
            }, e.getMaterialDefineByName = function(t) {
                return this._materialDefinesMap[t];
            }, e.setFlag = function(t, e) {
                e ? this._flags[t] = e : delete this._flags[t];
            }, e.getFlag = function(t) {
                return this._flags[t];
            }, e.addShaderPass = function(t, e, n) {
                var i = new je(this, t, e, n);
                return this._passes.push(i), i;
            }, t;
        }(),
        ae = function() {
            function h() {
                this._type = 0, this._separateAxes = !1, this._constant = NaN, this._constantSeparate = null,
                    this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null,
                    this._gradientW = null, this._constantMin = NaN, this._constantMax = NaN, this._constantMinSeparate = null,
                    this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null,
                    this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null,
                    this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null,
                    this._gradientWMin = null, this._gradientWMax = null;
            }
            d(h, "laya.d3.core.particleShuriKen.module.GradientAngularVelocity");
            var t = h.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, e._separateAxes = this._separateAxes, e._constant = this._constant,
                    this._constantSeparate.cloneTo(e._constantSeparate), this._gradient.cloneTo(e._gradient),
                    this._gradientX.cloneTo(e._gradientX), this._gradientY.cloneTo(e._gradientY), this._gradientZ.cloneTo(e._gradientZ),
                    e._constantMin = this._constantMin, e._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(e._constantMinSeparate),
                    this._constantMaxSeparate.cloneTo(e._constantMaxSeparate), this._gradientMin.cloneTo(e._gradientMin),
                    this._gradientMax.cloneTo(e._gradientMax), this._gradientXMin.cloneTo(e._gradientXMin),
                    this._gradientXMax.cloneTo(e._gradientXMax), this._gradientYMin.cloneTo(e._gradientYMin),
                    this._gradientYMax.cloneTo(e._gradientYMax), this._gradientZMin.cloneTo(e._gradientZMin),
                    this._gradientZMax.cloneTo(e._gradientZMax);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "gradientZ", function() {
                return this._gradientZ;
            }), u(0, t, "constant", function() {
                return this._constant;
            }), u(0, t, "gradient", function() {
                return this._gradient;
            }), u(0, t, "separateAxes", function() {
                return this._separateAxes;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "constantSeparate", function() {
                return this._constantSeparate;
            }), u(0, t, "gradientX", function() {
                return this._gradientX;
            }), u(0, t, "gradientY", function() {
                return this._gradientY;
            }), u(0, t, "gradientW", function() {
                return this._gradientW;
            }), u(0, t, "gradientMin", function() {
                return this._gradientMin;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "gradientMax", function() {
                return this._gradientMax;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), u(0, t, "gradientWMin", function() {
                return this._gradientWMin;
            }), u(0, t, "constantMinSeparate", function() {
                return this._constantMinSeparate;
            }), u(0, t, "constantMaxSeparate", function() {
                return this._constantMaxSeparate;
            }), u(0, t, "gradientXMin", function() {
                return this._gradientXMin;
            }), u(0, t, "gradientXMax", function() {
                return this._gradientXMax;
            }), u(0, t, "gradientWMax", function() {
                return this._gradientWMax;
            }), u(0, t, "gradientYMin", function() {
                return this._gradientYMin;
            }), u(0, t, "gradientYMax", function() {
                return this._gradientYMax;
            }), u(0, t, "gradientZMin", function() {
                return this._gradientZMin;
            }), u(0, t, "gradientZMax", function() {
                return this._gradientZMax;
            }), h.createByConstant = function(t) {
                var e = new h();
                return e._type = 0, e._separateAxes = !1, e._constant = t, e;
            }, h.createByConstantSeparate = function(t) {
                var e = new h();
                return e._type = 0, e._separateAxes = !0, e._constantSeparate = t, e;
            }, h.createByGradient = function(t) {
                var e = new h();
                return e._type = 1, e._separateAxes = !1, e._gradient = t, e;
            }, h.createByGradientSeparate = function(t, e, n) {
                var i = new h();
                return i._type = 1, i._separateAxes = !0, i._gradientX = t, i._gradientY = e, i._gradientZ = n,
                    i;
            }, h.createByRandomTwoConstant = function(t, e) {
                var n = new h();
                return n._type = 2, n._separateAxes = !1, n._constantMin = t, n._constantMax = e,
                    n;
            }, h.createByRandomTwoConstantSeparate = function(t, e) {
                var n = new h();
                return n._type = 2, n._separateAxes = !0, n._constantMinSeparate = t, n._constantMaxSeparate = e,
                    n;
            }, h.createByRandomTwoGradient = function(t, e) {
                var n = new h();
                return n._type = 3, n._separateAxes = !1, n._gradientMin = t, n._gradientMax = e,
                    n;
            }, h.createByRandomTwoGradientSeparate = function(t, e, n, i, r, a, o, s) {
                var l = new h();
                return l._type = 3, l._separateAxes = !0, l._gradientXMin = t, l._gradientXMax = e,
                    l._gradientYMin = n, l._gradientYMax = i, l._gradientZMin = r, l._gradientZMax = a,
                    l._gradientWMin = o, l._gradientWMax = s, l;
            }, h;
        }(),
        oe = function() {
            function e() {
                this._defaultPhysicsMemory = 16, this._editerEnvironment = !1, this.isAntialias = !0,
                    this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.octreeCulling = !1,
                    this.octreeInitialSize = 64, this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25,
                    this.debugFrustumCulling = !1, this.octreeInitialCenter = new Ct(0, 0, 0);
            }
            d(e, "Config3D");
            var t = e.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._defaultPhysicsMemory = this._defaultPhysicsMemory, e._editerEnvironment = this._editerEnvironment,
                    e.isAntialias = this.isAntialias, e.isAlpha = this.isAlpha, e.premultipliedAlpha = this.premultipliedAlpha,
                    e.isStencil = this.isStencil, e.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(e.octreeInitialCenter),
                    e.octreeMinNodeSize = this.octreeMinNodeSize, e.octreeLooseness = this.octreeLooseness,
                    e.debugFrustumCulling = this.debugFrustumCulling;
            }, t.clone = function() {
                var t = new e();
                return this.cloneTo(t), t;
            }, u(0, t, "defaultPhysicsMemory", function() {
                return this._defaultPhysicsMemory;
            }, function(t) {
                if (t < 16) throw "defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = t;
            }), _(e, ["_default", function() {
                return this._default = new e();
            }]), e;
        }(),
        se = (function() {
            function r(t) {
                if (this._state0U = NaN, this._state0L = NaN, this._state1U = NaN, this._state1L = NaN, !(t instanceof Array) || 4 !== t.length) throw new Error("Rand:Seed must be an array with 4 numbers");
                this._state0U = 0 | t[0], this._state0L = 0 | t[1], this._state1U = 0 | t[2], this._state1L = 0 | t[3];
            }
            d(r, "laya.d3.math.RandX");
            var t = r.prototype;
            t.randomint = function() {
                var t = this._state0U,
                    e = this._state0L,
                    n = this._state1U,
                    i = this._state1L,
                    r = (i >>> 0) + (e >>> 0),
                    a = n + t + (r / 2 >>> 31) >>> 0,
                    o = r >>> 0,
                    s = 0,
                    l = 0;
                s = (t ^= s = t << 23 | (-512 & e) >>> 9) ^ (this._state0U = n), l = (e ^= l = e << 23) ^ (this._state0L = i);
                s ^= t >>> 18, l ^= e >>> 18 | (262143 & t) << 14;
                return s ^= n >>> 5, l ^= i >>> 5 | (31 & n) << 27, this._state1U = s, this._state1L = l, [a, o];
            }, t.random = function() {
                var t = this.randomint(),
                    e = t[0],
                    n = 1023 << 20 | e >>> 12,
                    i = 0 | (t[1] >>> 12 | (4095 & e) << 20);
                return r._CONVERTION_BUFFER.setUint32(0, n, !1), r._CONVERTION_BUFFER.setUint32(4, i, !1),
                    yt._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
            }, _(r, ["_CONVERTION_BUFFER", function() {
                return this._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8));
            }, "defaultRand", function() {
                return this.defaultRand = new yt([0, Date.now() / 65536, 0, Date.now() % 65536]);
            }]);
        }(), function() {
            function m() {}
            return d(m, "laya.d3.utils.Picker"), m.calculateCursorRay = function(t, e, n, i, r, a) {
                var o = t.x,
                    s = t.y,
                    l = m._tempVector30,
                    h = l;
                h.x = o, h.y = s, h.z = e.minDepth;
                var u = m._tempVector31,
                    c = u;
                c.x = o, c.y = s, c.z = e.maxDepth;
                var _ = a.origin,
                    d = m._tempVector32;
                e.unprojectFromWVP(l, n, i, r, _), e.unprojectFromWVP(u, n, i, r, d);
                var f = a.direction;
                f.x = d.x - _.x, f.y = d.y - _.y, f.z = d.z - _.z, Ct.normalize(a.direction, a.direction);
            }, m.rayIntersectsTriangle = function(t, e, n, i) {
                var r = m._tempVector30,
                    a = m._tempVector31;
                Ct.subtract(n, e, r), Ct.subtract(i, e, a);
                var o, s = m._tempVector32;
                if (Ct.cross(t.direction, a, s), (o = Ct.dot(r, s)) > -Number.MIN_VALUE && o < Number.MIN_VALUE) return Number.NaN;
                var l, h = 1 / o,
                    u = m._tempVector33;
                if (Ct.subtract(t.origin, e, u), l = Ct.dot(u, s), (l *= h) < 0 || 1 < l) return Number.NaN;
                var c, _, d = m._tempVector34;
                return Ct.cross(u, r, d), c = Ct.dot(t.direction, d), (c *= h) < 0 || 1 < l + c ? Number.NaN : (_ = Ct.dot(a, d),
                    (_ *= h) < 0 ? Number.NaN : _);
            }, _(m, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }, "_tempVector32", function() {
                return this._tempVector32 = new Ct();
            }, "_tempVector33", function() {
                return this._tempVector33 = new Ct();
            }, "_tempVector34", function() {
                return this._tempVector34 = new Ct();
            }]), m;
        }()),
        le = function() {
            function t() {
                this._indexInList = -1, this._identifier = -1, this._position = new Lt();
            }
            d(t, "laya.d3.Touch");
            var e = t.prototype;
            return m.imps(e, {
                "laya.resource.ISingletonElement": !0
            }), e._getIndexInList = function() {
                return this._indexInList;
            }, e._setIndexInList = function(t) {
                this._indexInList = t;
            }, u(0, e, "identifier", function() {
                return this._identifier;
            }), u(0, e, "position", function() {
                return this._position;
            }), t;
        }(),
        he = (function() {
            function t() {
                this.startPosition = new Ct(), this.endPosition = new Ct(), this.startColor = new dt(),
                    this.endColor = new dt();
            }
            d(t, "laya.d3.core.pixelLine.PixelLineData"), t.prototype.cloneTo = function(t) {
                this.startPosition.cloneTo(t.startPosition), this.endPosition.cloneTo(t.endPosition),
                    this.startColor.cloneTo(t.startColor), this.endColor.cloneTo(t.endColor);
            };
        }(), function() {
            function t() {
                this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1,
                    this.contacts = [];
            }
            return d(t, "laya.d3.physics.Collision"), t.prototype._setUpdateFrame = function(t) {
                this._lastUpdateFrame = this._updateFrame, this._updateFrame = t;
            }, t;
        }()),
        ue = function() {
            function l(t, e) {
                this._id = 0, this._vertexStride = 0, this._vertexElementsDic = null, this._shaderValues = null,
                    this._defineDatas = null, this.vertexElements = null, this._id = ++l._uniqueIDCounter,
                    this._defineDatas = new Ft(), this._vertexElementsDic = {}, this._vertexStride = t;
                var n = (this.vertexElements = e).length;
                this._shaderValues = new at(null);
                for (var i = 0; i < n; i++) {
                    var r = e[i],
                        a = r.elementUsage;
                    this._vertexElementsDic[a] = r;
                    var o = new Int32Array(5),
                        s = Ie.getElementInfos(r.elementFormat);
                    o[0] = s[0], o[1] = s[1], o[2] = s[2], o[3] = this._vertexStride, o[4] = r.offset,
                        this._shaderValues.setAttribute(a, o);
                }
            }
            d(l, "laya.d3.graphics.VertexDeclaration");
            var t = l.prototype;
            return t.getVertexElementByUsage = function(t) {
                return this._vertexElementsDic[t];
            }, t.unBinding = function() {}, u(0, t, "id", function() {
                return this._id;
            }), u(0, t, "vertexStride", function() {
                return this._vertexStride;
            }), l._uniqueIDCounter = 1, l;
        }(),
        ce = function() {
            function t() {
                this._material = null, this._mesh = mn.instance;
            }
            d(t, "laya.d3.resource.models.SkyRenderer");
            var e = t.prototype;
            return e._isAvailable = function() {
                return this._material && this._mesh;
            }, e._render = function(t) {
                if (this._material && this._mesh) {
                    var e = E.instance,
                        n = t.scene,
                        i = t.camera;
                    V.setCullFace(e, !1), V.setDepthFunc(e, 515), V.setDepthMask(e, !1);
                    var r = t.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0, 0, this._material._defineDatas.value),
                        a = r.bind(),
                        o = M.loopCount !== r._uploadMark,
                        s = r._uploadScene !== n || o;
                    (s || a) && (r.uploadUniforms(r._sceneUniformParamsMap, n._shaderValues, s), r._uploadScene = n);
                    var l = r._uploadCamera !== i || o;
                    (l || a) && (r.uploadUniforms(r._cameraUniformParamsMap, i._shaderValues, l), r._uploadCamera = i);
                    var h = r._uploadMaterial !== this._material || o;
                    (h || a) && (r.uploadUniforms(r._materialUniformParamsMap, this._material._shaderValues, h),
                        r._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(t),
                        V.setDepthFunc(e, 513), V.setDepthMask(e, !0);
                }
            }, e.destroy = function() {
                this._material && (this._material._removeReference(), this._material = null);
            }, u(0, e, "material", function() {
                return this._material;
            }, function(t) {
                this._material !== t && (this._material && this._material._removeReference(), t && t._addReference(),
                    this._material = t);
            }), u(0, e, "mesh", function() {
                return this._mesh;
            }, function(t) {
                this._mesh !== t && (this._mesh = t);
            }), t;
        }(),
        _e = (function() {
            function t() {}
            d(t, "laya.d3.animation.AnimatorStateScript");
            var e = t.prototype;
            e.onStateEnter = function() {}, e.onStateUpdate = function() {}, e.onStateExit = function() {};
        }(), function() {
            function t() {
                this.updateMark = -1, this.indexInList = -1, this.batched = !1;
            }
            return d(t, "laya.d3.core.render.BatchMark"), t;
        }()),
        de = function() {
            function t() {
                this.succeeded = !1, this.collider = null, this.hitFraction = 0, this.point = new Ct(),
                    this.normal = new Ct();
            }
            return d(t, "laya.d3.physics.HitResult"), t;
        }(),
        fe = function() {
            function s() {
                this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null,
                    this._gradientY = null, this._gradientZ = null, this._constantMin = NaN, this._constantMax = NaN,
                    this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null,
                    this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null,
                    this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                    this._gradientZMax = null;
            }
            d(s, "laya.d3.core.particleShuriKen.module.GradientSize");
            var t = s.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.getMaxSizeInGradient = function() {
                var t = 0,
                    e = 0,
                    n = -Number.MAX_VALUE;
                switch (this._type) {
                    case 0:
                        if (this._separateAxes) {
                            for (t = 0, e = this._gradientX.gradientCount; t < e; t++) n = Math.max(n, this._gradientX.getValueByIndex(t));
                            for (t = 0, e = this._gradientY.gradientCount; t < e; t++) n = Math.max(n, this._gradientY.getValueByIndex(t));
                        } else
                            for (t = 0, e = this._gradient.gradientCount; t < e; t++) n = Math.max(n, this._gradient.getValueByIndex(t));
                        break;

                    case 1:
                        n = this._separateAxes ? (n = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x),
                            n = Math.max(n, this._constantMinSeparate.y), Math.max(n, this._constantMaxSeparate.y)) : Math.max(this._constantMin, this._constantMax);
                        break;

                    case 2:
                        if (this._separateAxes) {
                            for (t = 0, e = this._gradientXMin.gradientCount; t < e; t++) n = Math.max(n, this._gradientXMin.getValueByIndex(t));
                            for (t = 0, e = this._gradientXMax.gradientCount; t < e; t++) n = Math.max(n, this._gradientXMax.getValueByIndex(t));
                            for (t = 0, e = this._gradientYMin.gradientCount; t < e; t++) n = Math.max(n, this._gradientYMin.getValueByIndex(t));
                            for (t = 0, e = this._gradientZMax.gradientCount; t < e; t++) n = Math.max(n, this._gradientZMax.getValueByIndex(t));
                        } else {
                            for (t = 0, e = this._gradientMin.gradientCount; t < e; t++) n = Math.max(n, this._gradientMin.getValueByIndex(t));
                            for (t = 0, e = this._gradientMax.gradientCount; t < e; t++) n = Math.max(n, this._gradientMax.getValueByIndex(t));
                        }
                }
                return n;
            }, t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, e._separateAxes = this._separateAxes, this._gradient.cloneTo(e._gradient),
                    this._gradientX.cloneTo(e._gradientX), this._gradientY.cloneTo(e._gradientY), this._gradientZ.cloneTo(e._gradientZ),
                    e._constantMin = this._constantMin, e._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(e._constantMinSeparate),
                    this._constantMaxSeparate.cloneTo(e._constantMaxSeparate), this._gradientMin.cloneTo(e._gradientMin),
                    this._gradientMax.cloneTo(e._gradientMax), this._gradientXMin.cloneTo(e._gradientXMin),
                    this._gradientXMax.cloneTo(e._gradientXMax), this._gradientYMin.cloneTo(e._gradientYMin),
                    this._gradientYMax.cloneTo(e._gradientYMax), this._gradientZMin.cloneTo(e._gradientZMin),
                    this._gradientZMax.cloneTo(e._gradientZMax);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "gradientZ", function() {
                return this._gradientZ;
            }), u(0, t, "gradient", function() {
                return this._gradient;
            }), u(0, t, "separateAxes", function() {
                return this._separateAxes;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "gradientMin", function() {
                return this._gradientMin;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "gradientX", function() {
                return this._gradientX;
            }), u(0, t, "gradientY", function() {
                return this._gradientY;
            }), u(0, t, "gradientMax", function() {
                return this._gradientMax;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), u(0, t, "constantMinSeparate", function() {
                return this._constantMinSeparate;
            }), u(0, t, "constantMaxSeparate", function() {
                return this._constantMaxSeparate;
            }), u(0, t, "gradientXMin", function() {
                return this._gradientXMin;
            }), u(0, t, "gradientXMax", function() {
                return this._gradientXMax;
            }), u(0, t, "gradientYMin", function() {
                return this._gradientYMin;
            }), u(0, t, "gradientYMax", function() {
                return this._gradientYMax;
            }), u(0, t, "gradientZMin", function() {
                return this._gradientZMin;
            }), u(0, t, "gradientZMax", function() {
                return this._gradientZMax;
            }), s.createByGradient = function(t) {
                var e = new s();
                return e._type = 0, e._separateAxes = !1, e._gradient = t, e;
            }, s.createByGradientSeparate = function(t, e, n) {
                var i = new s();
                return i._type = 0, i._separateAxes = !0, i._gradientX = t, i._gradientY = e, i._gradientZ = n,
                    i;
            }, s.createByRandomTwoConstant = function(t, e) {
                var n = new s();
                return n._type = 1, n._separateAxes = !1, n._constantMin = t, n._constantMax = e,
                    n;
            }, s.createByRandomTwoConstantSeparate = function(t, e) {
                var n = new s();
                return n._type = 1, n._separateAxes = !0, n._constantMinSeparate = t, n._constantMaxSeparate = e,
                    n;
            }, s.createByRandomTwoGradient = function(t, e) {
                var n = new s();
                return n._type = 2, n._separateAxes = !1, n._gradientMin = t, n._gradientMax = e,
                    n;
            }, s.createByRandomTwoGradientSeparate = function(t, e, n, i, r, a) {
                var o = new s();
                return o._type = 2, o._separateAxes = !0, o._gradientXMin = t, o._gradientXMax = e,
                    o._gradientYMin = n, o._gradientYMax = i, o._gradientZMin = r, o._gradientZMax = a,
                    o;
            }, s;
        }(),
        me = function() {
            function t() {
                this.alphaMap = null, this.detailID = null, this.normalMap = null;
            }
            return d(t, "laya.d3.terrain.unit.ChunkInfo"), t;
        }(),
        pe = function() {
            function t() {
                this.textureID = -1;
            }
            return d(t, "laya.d3.shader.ShaderVariable"), t;
        }(),
        Te = function() {
            function t() {
                this._indexInList = 0, this.type = 0, this.fullPath = null, this.propertyOwner = null,
                    this.data = null, this._ownerPath = [], this._propertys = [], this._keyFrames = [];
            }
            d(t, "laya.d3.animation.KeyframeNode");
            var e = t.prototype;
            return e._setOwnerPathCount = function(t) {
                this._ownerPath.length = t;
            }, e._setOwnerPathByIndex = function(t, e) {
                this._ownerPath[t] = e;
            }, e._joinOwnerPath = function(t) {
                return this._ownerPath.join(t);
            }, e._setPropertyCount = function(t) {
                this._propertys.length = t;
            }, e._setPropertyByIndex = function(t, e) {
                this._propertys[t] = e;
            }, e._joinProperty = function(t) {
                return this._propertys.join(t);
            }, e._setKeyframeCount = function(t) {
                this._keyFrames.length = t;
            }, e._setKeyframeByIndex = function(t, e) {
                this._keyFrames[t] = e;
            }, e.getOwnerPathByIndex = function(t) {
                return this._ownerPath[t];
            }, e.getPropertyByIndex = function(t) {
                return this._propertys[t];
            }, e.getKeyframeByIndex = function(t) {
                return this._keyFrames[t];
            }, u(0, e, "ownerPathCount", function() {
                return this._ownerPath.length;
            }), u(0, e, "propertyCount", function() {
                return this._propertys.length;
            }), u(0, e, "keyFramesCount", function() {
                return this._keyFrames.length;
            }), t;
        }(),
        Ee = function() {
            function s() {
                this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null,
                    this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null,
                    this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null,
                    this._gradientZMin = null, this._gradientZMax = null;
            }
            d(s, "laya.d3.core.particleShuriKen.module.GradientVelocity");
            var t = s.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, this._constant.cloneTo(e._constant), this._gradientX.cloneTo(e._gradientX),
                    this._gradientY.cloneTo(e._gradientY), this._gradientZ.cloneTo(e._gradientZ), this._constantMin.cloneTo(e._constantMin),
                    this._constantMax.cloneTo(e._constantMax), this._gradientXMin.cloneTo(e._gradientXMin),
                    this._gradientXMax.cloneTo(e._gradientXMax), this._gradientYMin.cloneTo(e._gradientYMin),
                    this._gradientYMax.cloneTo(e._gradientYMax), this._gradientZMin.cloneTo(e._gradientZMin),
                    this._gradientZMax.cloneTo(e._gradientZMax);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "gradientZ", function() {
                return this._gradientZ;
            }), u(0, t, "constant", function() {
                return this._constant;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "gradientXMax", function() {
                return this._gradientXMax;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "gradientX", function() {
                return this._gradientX;
            }), u(0, t, "gradientY", function() {
                return this._gradientY;
            }), u(0, t, "gradientXMin", function() {
                return this._gradientXMin;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), u(0, t, "gradientYMin", function() {
                return this._gradientYMin;
            }), u(0, t, "gradientYMax", function() {
                return this._gradientYMax;
            }), u(0, t, "gradientZMin", function() {
                return this._gradientZMin;
            }), u(0, t, "gradientZMax", function() {
                return this._gradientZMax;
            }), s.createByConstant = function(t) {
                var e = new s();
                return e._type = 0, e._constant = t, e;
            }, s.createByGradient = function(t, e, n) {
                var i = new s();
                return i._type = 1, i._gradientX = t, i._gradientY = e, i._gradientZ = n, i;
            }, s.createByRandomTwoConstant = function(t, e) {
                var n = new s();
                return n._type = 2, n._constantMin = t, n._constantMax = e, n;
            }, s.createByRandomTwoGradient = function(t, e, n, i, r, a) {
                var o = new s();
                return o._type = 3, o._gradientXMin = t, o._gradientXMax = e, o._gradientYMin = n,
                    o._gradientYMax = i, o._gradientZMin = r, o._gradientZMax = a, o;
            }, s;
        }(),
        ve = function() {
            function i() {
                this._type = 0, this._constant = NaN, this._constantMin = NaN, this._constantMax = NaN;
            }
            d(i, "laya.d3.core.particleShuriKen.module.StartFrame");
            var t = i.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.cloneTo = function(t) {
                var e = t;
                e._type = this._type, e._constant = this._constant, e._constantMin = this._constantMin,
                    e._constantMax = this._constantMax;
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "constant", function() {
                return this._constant;
            }), u(0, t, "type", function() {
                return this._type;
            }), u(0, t, "constantMin", function() {
                return this._constantMin;
            }), u(0, t, "constantMax", function() {
                return this._constantMax;
            }), i.createByConstant = function(t) {
                var e = new i();
                return e._type = 0, e._constant = t, e;
            }, i.createByRandomTwoConstant = function(t, e) {
                var n = new i();
                return n._type = 1, n._constantMin = t, n._constantMax = e, n;
            }, i;
        }(),
        ge = function() {
            function h(t, e, n, i) {
                this._children = [], this.transform = new He(this, t, e, n, i);
            }
            d(h, "laya.d3.animation.AnimationNode");
            var t = h.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.addChild = function(t) {
                t._parent = this, t.transform.setParent(this.transform), this._children.push(t);
            }, t.removeChild = function(t) {
                var e = this._children.indexOf(t); -
                1 !== e && this._children.splice(e, 1);
            }, t.getChildByName = function(t) {
                for (var e = 0, n = this._children.length; e < n; e++) {
                    var i = this._children[e];
                    if (i.name === t) return i;
                }
                return null;
            }, t.getChildByIndex = function(t) {
                return this._children[t];
            }, t.getChildCount = function() {
                return this._children.length;
            }, t.cloneTo = function(t) {
                var e = t;
                e.name = this.name;
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var r = this._children[n],
                        a = r.clone();
                    e.addChild(a);
                    var o = r.transform,
                        s = a.transform,
                        l = s.localPosition,
                        h = s.localRotation,
                        u = s.localScale;
                    o.localPosition.cloneTo(l), o.localRotation.cloneTo(h), o.localScale.cloneTo(u),
                        s.localPosition = l, s.localRotation = h, s.localScale = u;
                }
            }, t.clone = function() {
                var t = new h();
                return this.cloneTo(t), t;
            }, t._cloneNative = function(t, e, n, i, r, a, o) {
                var s = o._nativeCurCloneCount;
                r[s] = a;
                var l = new h(new Float32Array(t.buffer, 3 * s * 4, 3), new Float32Array(e.buffer, 4 * s * 4, 4), new Float32Array(n.buffer, 3 * s * 4, 3), new Float32Array(i.buffer, 16 * s * 4, 16));
                return l._worldMatrixIndex = s, this._cloneToNative(l, t, e, n, i, r, s, o), l;
            }, t._cloneToNative = function(t, e, n, i, r, a, o, s) {
                var l = t;
                l.name = this.name;
                for (var h = 0, u = this._children.length; h < u; h++) {
                    var c = this._children[h];
                    s._nativeCurCloneCount++;
                    var _ = c._cloneNative(e, n, i, r, a, o, s);
                    l.addChild(_);
                    var d = c.transform,
                        f = _.transform,
                        m = f.localPosition,
                        p = f.localRotation,
                        T = f.localScale;
                    d.localPosition.cloneTo(m), d.localRotation.cloneTo(p), d.localScale.cloneTo(T),
                        f.localPosition = m, f.localRotation = p, f.localScale = T;
                }
            }, h;
        }(),
        Se = function() {
            function a(t, e, n, i) {
                this.minDepth = 0, this.maxDepth = 1, this.x = t, this.y = e, this.width = n, this.height = i;
            }
            d(a, "laya.d3.math.Viewport");
            var t = a.prototype;
            return t.project = function(t, e, n) {
                Ct.transformV3ToV3(t, e, n);
                var i = e.elements,
                    r = t.x * i[3] + t.y * i[7] + t.z * i[11] + i[15];
                1 !== r && (n.x = n.x / r, n.y = n.y / r, n.z = n.z / r), n.x = .5 * (n.x + 1) * this.width + this.x,
                    n.y = .5 * (1 - n.y) * this.height + this.y, n.z = n.z * (this.maxDepth - this.minDepth) + this.minDepth;
            }, t.project1 = function(t, e, n) {
                var i = Ct._tempVector4;
                Ct.transformV3ToV4(t, e, i);
                var r = i.w;
                r < .1 && -1e-6 < r && (r = 1e-6), i.x /= r, i.y /= r, i.z /= r, n.x = (i.x + 1) * this.width / 2 + this.x,
                    n.y = (1 - i.y) * this.height / 2 + this.y, n.z = i.w;
            }, t.unprojectFromMat = function(t, e, n) {
                var i = e.elements;
                n.x = (t.x - this.x) / this.width * 2 - 1, n.y = -((t.y - this.y) / this.height * 2 - 1);
                var r = (this.maxDepth - this.minDepth) / 2;
                n.z = (t.z - this.minDepth - r) / r;
                var a = n.x * i[3] + n.y * i[7] + n.z * i[11] + i[15];
                Ct.transformV3ToV3(n, e, n), 1 !== a && (n.x = n.x / a, n.y = n.y / a, n.z = n.z / a);
            }, t.unprojectFromWVP = function(t, e, n, i, r) {
                be.multiply(e, n, a._tempMatrix4x4), i && be.multiply(a._tempMatrix4x4, i, a._tempMatrix4x4),
                    a._tempMatrix4x4.invert(a._tempMatrix4x4), this.unprojectFromMat(t, a._tempMatrix4x4, r);
            }, t.cloneTo = function(t) {
                t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.minDepth = this.minDepth,
                    t.maxDepth = this.maxDepth;
            }, _(a, ["_tempMatrix4x4", function() {
                return this._tempMatrix4x4 = new be();
            }]), a;
        }(),
        ye = function() {
            function t() {
                this.diffuseTexture = null, this.normalTexture = null, this.scale = null, this.offset = null;
            }
            return d(t, "laya.d3.terrain.unit.DetailTextureInfo"), t;
        }(),
        xe = (function() {
            function m(t, e) {
                this.extents = null, this.transformation = null, this.extents = t, this.transformation = e;
            }
            d(m, "laya.d3.math.OrientedBoundBox");
            var t = m.prototype;
            t.getCorners = function(t) {
                m._tempV30.x = this.extents.x, m._tempV30.y = m._tempV30.z = 0, m._tempV31.y = this.extents.y,
                    m._tempV31.x = m._tempV31.z = 0, m._tempV32.z = this.extents.z, m._tempV32.x = m._tempV32.y = 0,
                    Ct.TransformNormal(m._tempV30, this.transformation, m._tempV30), Ct.TransformNormal(m._tempV31, this.transformation, m._tempV31),
                    Ct.TransformNormal(m._tempV32, this.transformation, m._tempV32);
                var e = m._tempV33;
                this.transformation.getTranslationVector(e), t.length = 8, Ct.add(e, m._tempV30, m._tempV34),
                    Ct.add(m._tempV34, m._tempV31, m._tempV34), Ct.add(m._tempV34, m._tempV32, t[0]),
                    Ct.add(e, m._tempV30, m._tempV34), Ct.add(m._tempV34, m._tempV31, m._tempV34), Ct.subtract(m._tempV34, m._tempV32, t[1]),
                    Ct.subtract(e, m._tempV30, m._tempV34), Ct.add(m._tempV34, m._tempV31, m._tempV34),
                    Ct.subtract(m._tempV34, m._tempV32, t[2]), Ct.subtract(e, m._tempV30, m._tempV34),
                    Ct.add(m._tempV34, m._tempV31, m._tempV34), Ct.add(m._tempV34, m._tempV32, t[3]),
                    Ct.add(e, m._tempV30, m._tempV34), Ct.subtract(m._tempV34, m._tempV31, m._tempV34),
                    Ct.add(m._tempV34, m._tempV32, t[4]), Ct.add(e, m._tempV30, m._tempV34), Ct.subtract(m._tempV34, m._tempV31, m._tempV34),
                    Ct.subtract(m._tempV34, m._tempV32, t[5]), Ct.subtract(e, m._tempV30, m._tempV34),
                    Ct.subtract(m._tempV34, m._tempV31, m._tempV34), Ct.subtract(m._tempV34, m._tempV32, t[6]),
                    Ct.subtract(e, m._tempV30, m._tempV34), Ct.subtract(m._tempV34, m._tempV31, m._tempV34),
                    Ct.add(m._tempV34, m._tempV32, t[7]);
            }, t.transform = function(t) {
                be.multiply(this.transformation, t, this.transformation);
            }, t.scale = function(t) {
                Ct.multiply(this.extents, t, this.extents);
            }, t.translate = function(t) {
                this.transformation.getTranslationVector(m._tempV30), Ct.add(m._tempV30, t, m._tempV31),
                    this.transformation.setTranslationVector(m._tempV31);
            }, t.Size = function(t) {
                Ct.scale(this.extents, 2, t);
            }, t.getSize = function(t) {
                m._tempV30.x = this.extents.x, m._tempV31.y = this.extents.y, m._tempV32.z = this.extents.z,
                    Ct.TransformNormal(m._tempV30, this.transformation, m._tempV30), Ct.TransformNormal(m._tempV31, this.transformation, m._tempV31),
                    Ct.TransformNormal(m._tempV31, this.transformation, m._tempV32), t.x = Ct.scalarLength(m._tempV30),
                    t.y = Ct.scalarLength(m._tempV31), t.z = Ct.scalarLength(m._tempV32);
            }, t.getSizeSquared = function(t) {
                m._tempV30.x = this.extents.x, m._tempV31.y = this.extents.y, m._tempV32.z = this.extents.z,
                    Ct.TransformNormal(m._tempV30, this.transformation, m._tempV30), Ct.TransformNormal(m._tempV31, this.transformation, m._tempV31),
                    Ct.TransformNormal(m._tempV31, this.transformation, m._tempV32), t.x = Ct.scalarLengthSquared(m._tempV30),
                    t.y = Ct.scalarLengthSquared(m._tempV31), t.z = Ct.scalarLengthSquared(m._tempV32);
            }, t.getCenter = function(t) {
                this.transformation.getTranslationVector(t);
            }, t.containsPoint = function(t) {
                var e = this.extents.x,
                    n = this.extents.y,
                    i = this.extents.z;
                this.transformation.invert(m._tempM0), Ct.transformCoordinate(t, m._tempM0, m._tempV30);
                var r = Math.abs(m._tempV30.x),
                    a = Math.abs(m._tempV30.y),
                    o = Math.abs(m._tempV30.z);
                return $.nearEqual(r, e) && $.nearEqual(a, n) && $.nearEqual(o, i) ? 2 : r < e && a < n && o < i ? 1 : 0;
            }, t.containsPoints = function(t) {
                var e = this.extents.x,
                    n = this.extents.y,
                    i = this.extents.z;
                this.transformation.invert(m._tempM0);
                for (var r = !0, a = !1, o = 0; o < t.length; o++) {
                    Ct.transformCoordinate(t[o], m._tempM0, m._tempV30);
                    var s = Math.abs(m._tempV30.x),
                        l = Math.abs(m._tempV30.y),
                        h = Math.abs(m._tempV30.z);
                    $.nearEqual(s, e) && $.nearEqual(l, n) && $.nearEqual(h, i) && (a = !0), s < e && l < n && h < i ? a = !0 : r = !1;
                }
                return r ? 1 : a ? 2 : 0;
            }, t.containsSphere = function(t, e) {
                void 0 === e && (e = !1);
                var n = this.extents.x,
                    i = this.extents.y,
                    r = this.extents.z,
                    a = t.radius;
                this.transformation.invert(m._tempM0), Ct.transformCoordinate(t.center, m._tempM0, m._tempV30);
                var o = NaN;
                if (o = e ? a : (Ct.scale(Ct._UnitX, a, m._tempV31), Ct.TransformNormal(m._tempV31, m._tempM0, m._tempV31),
                        Ct.scalarLength(m._tempV31)), Ct.scale(this.extents, -1, m._tempV32), Ct.Clamp(m._tempV30, m._tempV32, this.extents, m._tempV33),
                    o * o < Ct.distanceSquared(m._tempV30, m._tempV33)) return 0;
                var s = m._tempV30.x,
                    l = m._tempV30.y,
                    h = m._tempV30.z,
                    u = m._tempV32.x,
                    c = m._tempV32.y,
                    _ = m._tempV32.z;
                return u + o <= s && s <= n - o && o < n - u && c + o <= l && l <= i - o && o < i - c && _ + o <= h && h <= r - o && o < r - _ ? 1 : 2;
            }, t.containsOrientedBoundBox = function(t) {
                var e = 0,
                    n = 0;
                t.getCorners(m._corners);
                var i = this.containsPoints(m._corners);
                if (0 != i) return i;
                m._sizeAe[0] = this.extents.x, m._sizeAe[1] = this.extents.y, m._sizeAe[2] = this.extents.z,
                    t.extents.cloneTo(m._tempV35), m._sizeBe[0] = m._tempV35.x, m._sizeBe[1] = m._tempV35.y,
                    m._sizeBe[2] = m._tempV35.z, m._getRows(this.transformation, m._rows1), m._getRows(t.transformation, m._rows2);
                var r = NaN;
                for (e = 0; e < 4; e++)
                    for (n = 0; n < 4; n++) 3 == e || 3 == n ? (m._tempM0.setElementByRowColumn(e, n, 0),
                        m._tempM1.setElementByRowColumn(e, n, 0)) : (r = Ct.dot(m._rows1[e], m._rows2[n]),
                        m._tempM0.setElementByRowColumn(e, n, r), m._tempM1.setElementByRowColumn(e, n, Math.abs(r)));
                for (t.getCenter(m._tempV34), this.getCenter(m._tempV36), Ct.subtract(m._tempV34, m._tempV36, m._tempV30),
                    m._tempV31.x = Ct.dot(m._tempV30, m._rows1[0]), m._tempV31.y = Ct.dot(m._tempV30, m._rows1[1]),
                    m._tempV31.z = Ct.dot(m._tempV30, m._rows1[2]), m._vsepAe[0] = m._tempV31.x, m._vsepAe[1] = m._tempV31.y,
                    m._vsepAe[2] = m._tempV31.z, e = 0; e < 3; e++)
                    if (m._tempV32.x = m._tempM1.getElementByRowColumn(e, 0),
                        m._tempV32.y = m._tempM1.getElementByRowColumn(e, 1), m._tempV32.z = m._tempM1.getElementByRowColumn(e, 2),
                        m._sizeAe[e] + Ct.dot(m._tempV35, m._tempV32) < Math.abs(m._vsepAe[e])) return 0;
                for (n = 0; n < 3; n++)
                    if (m._tempV32.x = m._tempM1.getElementByRowColumn(0, n),
                        m._tempV32.y = m._tempM1.getElementByRowColumn(1, n), m._tempV32.z = m._tempM1.getElementByRowColumn(2, n),
                        m._tempV33.x = m._tempM0.getElementByRowColumn(0, n), m._tempV33.y = m._tempM0.getElementByRowColumn(1, n),
                        m._tempV33.z = m._tempM0.getElementByRowColumn(2, n), Ct.dot(this.extents, m._tempV32) + m._sizeBe[n] < Math.abs(Ct.dot(m._tempV31, m._tempV33))) return 0;
                for (e = 0; e < 3; e++)
                    for (n = 0; n < 3; n++) {
                        var a = (e + 1) % 3,
                            o = (e + 2) % 3,
                            s = (n + 1) % 3,
                            l = (n + 2) % 3;
                        if (m._sizeAe[a] * m._tempM1.getElementByRowColumn(o, n) + m._sizeAe[o] * m._tempM1.getElementByRowColumn(a, n) + (m._sizeBe[s] * m._tempM1.getElementByRowColumn(e, l) + m._sizeBe[l] * m._tempM1.getElementByRowColumn(e, s)) < Math.abs(m._vsepAe[o] * m._tempM0.getElementByRowColumn(a, n) - m._vsepAe[a] * m._tempM0.getElementByRowColumn(o, n))) return 0;
                    }
                return 2;
            }, t.containsLine = function(t, e) {
                m._corners[0] = t, m._corners[1] = e;
                var n = this.containsPoints(m._corners);
                if (0 != n) return n;
                var i = this.extents.x,
                    r = this.extents.y,
                    a = this.extents.z;
                this.transformation.invert(m._tempM0), Ct.transformCoordinate(t, m._tempM0, m._tempV30),
                    Ct.transformCoordinate(e, m._tempM0, m._tempV31), Ct.add(m._tempV30, m._tempV31, m._tempV32),
                    Ct.scale(m._tempV32, .5, m._tempV32), Ct.subtract(m._tempV30, m._tempV32, m._tempV33);
                var o = m._tempV33.x,
                    s = m._tempV33.y,
                    l = m._tempV33.z,
                    h = m._tempV34.x = Math.abs(m._tempV33.x),
                    u = m._tempV34.y = Math.abs(m._tempV33.y),
                    c = m._tempV34.z = Math.abs(m._tempV33.z),
                    _ = m._tempV32.x,
                    d = m._tempV32.y,
                    f = m._tempV32.z;
                return Math.abs(_) > i + h ? 0 : Math.abs(d) > r + u ? 0 : Math.abs(f) > a + c ? 0 : Math.abs(d * l - f * s) > r * c + a * u ? 0 : Math.abs(_ * l - f * o) > i * c + a * h ? 0 : Math.abs(_ * s - d * o) > i * u + r * h ? 0 : 2;
            }, t.containsBoundBox = function(t) {
                var e = 0,
                    n = 0,
                    i = t.min,
                    r = t.max;
                t.getCorners(m._corners);
                var a = this.containsPoints(m._corners);
                if (0 != a) return a;
                Ct.subtract(r, i, m._tempV30), Ct.scale(m._tempV30, .5, m._tempV30), Ct.add(i, m._tempV30, m._tempV30),
                    Ct.subtract(r, m._tempV30, m._tempV31), m._sizeAe[0] = this.extents.x, m._sizeAe[1] = this.extents.y,
                    m._sizeAe[2] = this.extents.z, m._sizeBe[0] = m._tempV31.x, m._sizeBe[1] = m._tempV31.y,
                    m._sizeBe[2] = m._tempV31.z, m._getRows(this.transformation, m._rows1), this.transformation.invert(m._tempM0);
                for (e = 0; e < 3; e++)
                    for (n = 0; n < 3; n++) m._tempM1.setElementByRowColumn(e, n, Math.abs(m._tempM0.getElementByRowColumn(e, n)));
                for (this.getCenter(m._tempV35), Ct.subtract(m._tempV30, m._tempV35, m._tempV32),
                    m._tempV31.x = Ct.dot(m._tempV32, m._rows1[0]), m._tempV31.y = Ct.dot(m._tempV32, m._rows1[1]),
                    m._tempV31.z = Ct.dot(m._tempV32, m._rows1[2]), m._vsepAe[0] = m._tempV31.x, m._vsepAe[1] = m._tempV31.y,
                    m._vsepAe[2] = m._tempV31.z, e = 0; e < 3; e++)
                    if (m._tempV33.x = m._tempM1.getElementByRowColumn(e, 0),
                        m._tempV33.y = m._tempM1.getElementByRowColumn(e, 1), m._tempV33.z = m._tempM1.getElementByRowColumn(e, 2),
                        m._sizeAe[e] + Ct.dot(m._tempV31, m._tempV33) < Math.abs(m._vsepAe[e])) return 0;
                for (n = 0; n < 3; n++)
                    if (m._tempV33.x = m._tempM1.getElementByRowColumn(0, n),
                        m._tempV33.y = m._tempM1.getElementByRowColumn(1, n), m._tempV33.z = m._tempM1.getElementByRowColumn(2, n),
                        m._tempV34.x = m._tempM0.getElementByRowColumn(0, n), m._tempV34.y = m._tempM0.getElementByRowColumn(1, n),
                        m._tempV34.z = m._tempM0.getElementByRowColumn(2, n), Ct.dot(this.extents, m._tempV33) + m._sizeBe[n] < Math.abs(Ct.dot(m._tempV31, m._tempV34))) return 0;
                for (e = 0; e < 3; e++)
                    for (n = 0; n < 3; n++) {
                        var o = (e + 1) % 3,
                            s = (e + 2) % 3,
                            l = (n + 1) % 3,
                            h = (n + 2) % 3;
                        if (m._sizeAe[o] * m._tempM1.getElementByRowColumn(s, n) + m._sizeAe[s] * m._tempM1.getElementByRowColumn(o, n) + (m._sizeBe[l] * m._tempM1.getElementByRowColumn(e, h) + m._sizeBe[h] * m._tempM1.getElementByRowColumn(e, l)) < Math.abs(m._vsepAe[s] * m._tempM0.getElementByRowColumn(o, n) - m._vsepAe[o] * m._tempM0.getElementByRowColumn(s, n))) return 0;
                    }
                return 2;
            }, t.intersectsRay = function(t, e) {
                Ct.scale(this.extents, -1, m._tempV30), this.transformation.invert(m._tempM0), Ct.TransformNormal(t.direction, m._tempM0, m._ray.direction),
                    Ct.transformCoordinate(t.origin, m._tempM0, m._ray.origin), m._boxBound1.min = m._tempV30,
                    m._boxBound1.max = this.extents;
                var n = Oe.intersectsRayAndBoxRP(m._ray, m._boxBound1, e);
                return -1 !== n && Ct.transformCoordinate(e, this.transformation, e), n;
            }, t._getLocalCorners = function(t) {
                t.length = 8, m._tempV30.x = this.extents.x, m._tempV31.y = this.extents.y, m._tempV32.z = this.extents.z,
                    Ct.add(m._tempV30, m._tempV31, m._tempV33), Ct.add(m._tempV33, m._tempV32, t[0]),
                    Ct.add(m._tempV30, m._tempV31, m._tempV33), Ct.subtract(m._tempV33, m._tempV32, t[1]),
                    Ct.subtract(m._tempV31, m._tempV30, m._tempV33), Ct.subtract(m._tempV33, m._tempV30, t[2]),
                    Ct.subtract(m._tempV31, m._tempV30, m._tempV33), Ct.add(m._tempV33, m._tempV32, t[3]),
                    Ct.subtract(m._tempV30, m._tempV31, m._tempV33), Ct.add(m._tempV33, m._tempV32, t[4]),
                    Ct.subtract(m._tempV30, m._tempV31, m._tempV33), Ct.subtract(m._tempV33, m._tempV32, t[5]),
                    Ct.scale(t[0], -1, t[6]), Ct.subtract(m._tempV32, m._tempV30, m._tempV33), Ct.subtract(m._tempV33, m._tempV31, t[7]);
            }, t.equals = function(t) {
                return this.extents == t.extents && this.transformation == t.transformation;
            }, t.cloneTo = function(t) {
                var e = t;
                this.extents.cloneTo(e.extents), this.transformation.cloneTo(e.transformation);
            }, m.createByBoundBox = function(t, e) {
                var n = t.min,
                    i = t.max;
                Ct.subtract(i, n, m._tempV30), Ct.scale(m._tempV30, .5, m._tempV30), Ct.add(n, m._tempV30, m._tempV31),
                    Ct.subtract(i, m._tempV31, m._tempV32), be.translation(m._tempV31, m._tempM0);
                var r = m._tempV32.clone(),
                    a = m._tempM0.clone();
                e.extents = r, e.transformation = a;
            }, m.createByMinAndMaxVertex = function(t, e) {
                return Ct.subtract(e, t, m._tempV30), Ct.scale(m._tempV30, .5, m._tempV30), Ct.add(t, m._tempV30, m._tempV31),
                    Ct.subtract(e, m._tempV31, m._tempV32), be.translation(m._tempV31, m._tempM0), new m(m._tempV32, m._tempM0);
            }, m._getRows = function(t, e) {
                e.length = 3;
                var n = t.elements;
                e[0].x = n[0], e[0].y = n[1], e[0].z = n[2], e[1].x = n[4], e[1].y = n[5], e[1].z = n[6],
                    e[2].x = n[8], e[2].y = n[9], e[2].z = n[10];
            }, m.getObbtoObbMatrix4x4 = function(t, e, n, i) {
                var r = t.transformation,
                    a = e.transformation;
                if (n) {
                    m._getRows(r, m._rows1), m._getRows(a, m._rows2);
                    for (var o = 0; o < 3; o++)
                        for (var s = 0; s < 3; s++) i.setElementByRowColumn(o, s, Ct.dot(m._rows2[o], m._rows1[s]));
                    e.getCenter(m._tempV30), t.getCenter(m._tempV31), Ct.subtract(m._tempV30, m._tempV31, m._tempV32);
                    var l = i.elements;
                    l[12] = Ct.dot(m._tempV32, m._rows1[0]), l[13] = Ct.dot(m._tempV32, m._rows1[1]),
                        l[14] = Ct.dot(m._tempV32, m._rows1[2]), l[15] = 1;
                } else r.invert(m._tempM0), be.multiply(a, m._tempM0, i);
            }, m.merge = function(t, e, n) {
                var i = t.extents,
                    r = t.transformation;
                m.getObbtoObbMatrix4x4(t, e, n, m._tempM0), e._getLocalCorners(m._corners), Ct.transformCoordinate(m._corners[0], m._tempM0, m._corners[0]),
                    Ct.transformCoordinate(m._corners[1], m._tempM0, m._corners[1]), Ct.transformCoordinate(m._corners[2], m._tempM0, m._corners[2]),
                    Ct.transformCoordinate(m._corners[3], m._tempM0, m._corners[3]), Ct.transformCoordinate(m._corners[4], m._tempM0, m._corners[4]),
                    Ct.transformCoordinate(m._corners[5], m._tempM0, m._corners[5]), Ct.transformCoordinate(m._corners[6], m._tempM0, m._corners[6]),
                    Ct.transformCoordinate(m._corners[7], m._tempM0, m._corners[7]), Ct.scale(i, -1, m._boxBound1.min),
                    i.cloneTo(m._boxBound1.max), we.createfromPoints(m._corners, m._boxBound2), we.merge(m._boxBound2, m._boxBound1, m._boxBound3);
                var a = m._boxBound3.min,
                    o = m._boxBound3.max;
                Ct.subtract(o, a, m._tempV30), Ct.scale(m._tempV30, .5, m._tempV30), Ct.add(a, m._tempV30, m._tempV32),
                    Ct.subtract(o, m._tempV32, i), Ct.transformCoordinate(m._tempV32, r, m._tempV33);
            }, _(m, ["_tempV30", function() {
                return this._tempV30 = new Ct();
            }, "_tempV31", function() {
                return this._tempV31 = new Ct();
            }, "_tempV32", function() {
                return this._tempV32 = new Ct();
            }, "_tempV33", function() {
                return this._tempV33 = new Ct();
            }, "_tempV34", function() {
                return this._tempV34 = new Ct();
            }, "_tempV35", function() {
                return this._tempV35 = new Ct();
            }, "_tempV36", function() {
                return this._tempV36 = new Ct();
            }, "_tempM0", function() {
                return this._tempM0 = new be();
            }, "_tempM1", function() {
                return this._tempM1 = new be();
            }, "_corners", function() {
                return this._corners = [new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct()];
            }, "_rows1", function() {
                return this._rows1 = [new Ct(), new Ct(), new Ct()];
            }, "_rows2", function() {
                return this._rows2 = [new Ct(), new Ct(), new Ct()];
            }, "_ray", function() {
                return this._ray = new X(new Ct(), new Ct());
            }, "_boxBound1", function() {
                return this._boxBound1 = new we(new Ct(), new Ct());
            }, "_boxBound2", function() {
                return this._boxBound2 = new we(new Ct(), new Ct());
            }, "_boxBound3", function() {
                return this._boxBound3 = new we(new Ct(), new Ct());
            }, "_vsepAe", function() {
                return this._vsepAe = new Float32Array();
            }, "_sizeBe", function() {
                return this._sizeBe = new Float32Array();
            }, "_sizeAe", function() {
                return this._sizeAe = new Float32Array();
            }]);
        }(), function() {
            function t(t) {
                void 0 === t && (t = !1), this.isTransparent = t, this.elements = [];
            }
            d(t, "laya.d3.core.render.RenderQueue");
            var e = t.prototype;
            return e._compare = function(t, e) {
                var n = t.material.renderQueue - e.material.renderQueue;
                return 0 !== n ? n : (this.isTransparent ? e.render._distanceForSort - t.render._distanceForSort : t.render._distanceForSort - e.render._distanceForSort) + e.render.sortingFudge - t.render.sortingFudge;
            }, e._partitionRenderObject = function(t, e) {
                for (var n = this.elements[Math.floor((e + t) / 2)]; t <= e;) {
                    for (; this._compare(this.elements[t], n) < 0;) t++;
                    for (; 0 < this._compare(this.elements[e], n);) e--;
                    if (t < e) {
                        var i = this.elements[t];
                        this.elements[t] = this.elements[e], this.elements[e] = i, t++, e--;
                    } else if (t === e) {
                        t++;
                        break;
                    }
                }
                return t;
            }, e._quickSort = function(t, e) {
                if (1 < this.elements.length) {
                    var n = this._partitionRenderObject(t, e),
                        i = n - 1;
                    t < i && this._quickSort(t, i), n < e && this._quickSort(n, e);
                }
            }, e._render = function(t, e, n, i) {
                for (var r = 0, a = this.elements.length; r < a; r++) this.elements[r]._render(t, e, n, i);
            }, e.clear = function() {
                this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
            }, t;
        }()),
        De = (function() {
            function t() {}
            d(t, "laya.d3.core.TextureMode"), t.Stretch = 0, t.Tile = 1;
        }(), function() {
            function t() {}
            d(t, "laya.d3.physics.shape.HeightfieldColliderShape");
        }(), function() {
            function r() {}
            return d(r, "laya.d3.core.particleShuriKen.module.shape.ShapeUtils"), r._randomPointUnitArcCircle = function(t, e, n) {
                var i = NaN;
                i = n ? n.getFloat() * t : Math.random() * t, e.x = Math.cos(i), e.y = Math.sin(i);
            }, r._randomPointInsideUnitArcCircle = function(t, e, n) {
                r._randomPointUnitArcCircle(t, e, n);
                var i = NaN;
                i = n ? Math.pow(n.getFloat(), .5) : Math.pow(Math.random(), .5), e.x = e.x * i,
                    e.y = e.y * i;
            }, r._randomPointUnitCircle = function(t, e) {
                var n = NaN;
                n = e ? e.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, t.x = Math.cos(n),
                    t.y = Math.sin(n);
            }, r._randomPointInsideUnitCircle = function(t, e) {
                r._randomPointUnitCircle(t);
                var n = NaN;
                n = e ? Math.pow(e.getFloat(), .5) : Math.pow(Math.random(), .5), t.x = t.x * n,
                    t.y = t.y * n;
            }, r._randomPointUnitSphere = function(t, e) {
                var n = NaN,
                    i = NaN;
                i = e ? (n = t.z = 2 * e.getFloat() - 1, e.getFloat() * Math.PI * 2) : (n = t.z = 2 * Math.random() - 1,
                    Math.random() * Math.PI * 2);
                var r = Math.sqrt(1 - n * n);
                t.x = r * Math.cos(i), t.y = r * Math.sin(i);
            }, r._randomPointInsideUnitSphere = function(t, e) {
                r._randomPointUnitSphere(t);
                var n = NaN;
                n = e ? Math.pow(e.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3), t.x = t.x * n,
                    t.y = t.y * n, t.z = t.z * n;
            }, r._randomPointInsideHalfUnitBox = function(t, e) {
                t.z = e ? (t.x = e.getFloat() - .5, t.y = e.getFloat() - .5, e.getFloat() - .5) : (t.x = Math.random() - .5,
                    t.y = Math.random() - .5, Math.random() - .5);
            }, r;
        }()),
        Ie = function() {
            function n() {}
            return d(n, "laya.d3.graphics.VertexElementFormat"), n.getElementInfos = function(t) {
                    var e = n._elementInfos[t];
                    if (e) return e;
                    throw "VertexElementFormat: this vertexElementFormat is not implement.";
                }, n.Single = "single", n.Vector2 = "vector2", n.Vector3 = "vector3", n.Vector4 = "vector4",
                n.Color = "color", n.Byte4 = "byte4", n.Short2 = "short2", n.Short4 = "short4",
                n.NormalizedShort2 = "normalizedshort2", n.NormalizedShort4 = "normalizedshort4",
                n.HalfVector2 = "halfvector2", n.HalfVector4 = "halfvector4", _(n, ["_elementInfos", function() {
                    return this._elementInfos = {
                        single: [1, 5126, 0],
                        vector2: [2, 5126, 0],
                        vector3: [3, 5126, 0],
                        vector4: [4, 5126, 0],
                        color: [4, 5126, 0],
                        byte4: [4, 5121, 0],
                        short2: [2, 5126, 0],
                        short4: [4, 5126, 0],
                        normalizedshort2: [2, 5126, 0],
                        normalizedshort4: [4, 5126, 0],
                        halfvector2: [2, 5126, 0],
                        halfvector4: [4, 5126, 0]
                    };
                }]), n;
        }(),
        Re = function() {
            function t(t) {
                this._angularVelocity = null, this.enbale = !1, this._angularVelocity = t;
            }
            d(t, "laya.d3.core.particleShuriKen.module.RotationOverLifetime");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.cloneTo = function(t) {
                var e = t;
                this._angularVelocity.cloneTo(e._angularVelocity), e.enbale = this.enbale;
            }, e.clone = function() {
                var t;
                switch (this._angularVelocity.type) {
                    case 0:
                        t = this._angularVelocity.separateAxes ? ae.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : ae.createByConstant(this._angularVelocity.constant);
                        break;

                    case 1:
                        t = this._angularVelocity.separateAxes ? ae.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : ae.createByGradient(this._angularVelocity.gradient.clone());
                        break;

                    case 2:
                        t = this._angularVelocity.separateAxes ? ae.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : ae.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                        break;

                    case 3:
                        t = this._angularVelocity.separateAxes ? ae.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : ae.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                }
                var e = new this.constructor(t);
                return e.enbale = this.enbale, e;
            }, u(0, e, "angularVelocity", function() {
                return this._angularVelocity;
            }), t;
        }(),
        Me = function() {
            function h(t) {
                this._matrix = null, this._near = null, this._far = null, this._left = null, this._right = null,
                    this._top = null, this._bottom = null, this._matrix = t, this._near = new et(new Ct()),
                    this._far = new et(new Ct()), this._left = new et(new Ct()), this._right = new et(new Ct()),
                    this._top = new et(new Ct()), this._bottom = new et(new Ct()), h._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }
            d(h, "laya.d3.math.BoundFrustum");
            var t = h.prototype;
            return t.equalsBoundFrustum = function(t) {
                return this._matrix.equalsOtherMatrix(t.matrix);
            }, t.equalsObj = function(t) {
                if (t instanceof laya.d3.math.BoundFrustum) {
                    var e = t;
                    return this.equalsBoundFrustum(e);
                }
                return !1;
            }, t.getPlane = function(t) {
                switch (t) {
                    case 0:
                        return this._near;

                    case 1:
                        return this._far;

                    case 2:
                        return this._left;

                    case 3:
                        return this._right;

                    case 4:
                        return this._top;

                    case 5:
                        return this._bottom;

                    default:
                        return null;
                }
            }, t.getCorners = function(t) {
                h._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(t[0]), h._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(t[1]),
                    h._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(t[2]), h._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(t[3]),
                    h._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(t[4]), h._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(t[5]),
                    h._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(t[6]), h._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(t[7]);
            }, t.containsPoint = function(t) {
                for (var e = et.PlaneIntersectionType_Front, n = et.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            n = Oe.intersectsPlaneAndPoint(this._near, t);
                            break;

                        case 1:
                            n = Oe.intersectsPlaneAndPoint(this._far, t);
                            break;

                        case 2:
                            n = Oe.intersectsPlaneAndPoint(this._left, t);
                            break;

                        case 3:
                            n = Oe.intersectsPlaneAndPoint(this._right, t);
                            break;

                        case 4:
                            n = Oe.intersectsPlaneAndPoint(this._top, t);
                            break;

                        case 5:
                            n = Oe.intersectsPlaneAndPoint(this._bottom, t);
                    }
                    switch (n) {
                        case et.PlaneIntersectionType_Back:
                            return 0;

                        case et.PlaneIntersectionType_Intersecting:
                            e = et.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (e) {
                    case et.PlaneIntersectionType_Intersecting:
                        return 2;

                    default:
                        return 1;
                }
            }, t.containsBoundBox = function(t) {
                for (var e = h._tempV30, n = h._tempV31, i = t.min, r = t.max, a = 1, o = 0; o < 6; o++) {
                    var s = this.getPlane(o),
                        l = s.normal;
                    if (0 <= l.x ? (e.x = r.x, n.x = i.x) : (e.x = i.x, n.x = r.x), 0 <= l.y ? (e.y = r.y,
                            n.y = i.y) : (e.y = i.y, n.y = r.y), 0 <= l.z ? (e.z = r.z, n.z = i.z) : (e.z = i.z,
                            n.z = r.z), Oe.intersectsPlaneAndPoint(s, e) === et.PlaneIntersectionType_Back) return 0;
                    Oe.intersectsPlaneAndPoint(s, n) === et.PlaneIntersectionType_Back && (a = 2);
                }
                return a;
            }, t.containsBoundSphere = function(t) {
                for (var e = et.PlaneIntersectionType_Front, n = et.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                    switch (i) {
                        case 0:
                            n = Oe.intersectsPlaneAndSphere(this._near, t);
                            break;

                        case 1:
                            n = Oe.intersectsPlaneAndSphere(this._far, t);
                            break;

                        case 2:
                            n = Oe.intersectsPlaneAndSphere(this._left, t);
                            break;

                        case 3:
                            n = Oe.intersectsPlaneAndSphere(this._right, t);
                            break;

                        case 4:
                            n = Oe.intersectsPlaneAndSphere(this._top, t);
                            break;

                        case 5:
                            n = Oe.intersectsPlaneAndSphere(this._bottom, t);
                    }
                    switch (n) {
                        case et.PlaneIntersectionType_Back:
                            return 0;

                        case et.PlaneIntersectionType_Intersecting:
                            e = et.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (e) {
                    case et.PlaneIntersectionType_Intersecting:
                        return 2;

                    default:
                        return 1;
                }
            }, u(0, t, "top", function() {
                return this._top;
            }), u(0, t, "matrix", function() {
                return this._matrix;
            }, function(t) {
                this._matrix = t, h._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }), u(0, t, "near", function() {
                return this._near;
            }), u(0, t, "far", function() {
                return this._far;
            }), u(0, t, "left", function() {
                return this._left;
            }), u(0, t, "right", function() {
                return this._right;
            }), u(0, t, "bottom", function() {
                return this._bottom;
            }), h._getPlanesFromMatrix = function(t, e, n, i, r, a, o) {
                var s = t.elements,
                    l = s[0],
                    h = s[1],
                    u = s[2],
                    c = s[3],
                    _ = s[4],
                    d = s[5],
                    f = s[6],
                    m = s[7],
                    p = s[8],
                    T = s[9],
                    E = s[10],
                    v = s[11],
                    g = s[12],
                    S = s[13],
                    y = s[14],
                    x = s[15],
                    D = e.normal;
                D.x = c + u, D.y = m + f, D.z = v + E, e.distance = x + y, e.normalize();
                var I = n.normal;
                I.x = c - u, I.y = m - f, I.z = v - E, n.distance = x - y, n.normalize();
                var R = i.normal;
                R.x = c + l, R.y = m + _, R.z = v + p, i.distance = x + g, i.normalize();
                var M = r.normal;
                M.x = c - l, M.y = m - _, M.z = v - p, r.distance = x - g, r.normalize();
                var A = a.normal;
                A.x = c - h, A.y = m - d, A.z = v - T, a.distance = x - S, a.normalize();
                var C = o.normal;
                C.x = c + h, C.y = m + d, C.z = v + T, o.distance = x + S, o.normalize();
            }, h._get3PlaneInterPoint = function(t, e, n) {
                var i = t.normal,
                    r = e.normal,
                    a = n.normal;
                Ct.cross(r, a, h._tempV30), Ct.cross(a, i, h._tempV31), Ct.cross(i, r, h._tempV32);
                var o = Ct.dot(i, h._tempV30),
                    s = Ct.dot(r, h._tempV31),
                    l = Ct.dot(a, h._tempV32);
                return Ct.scale(h._tempV30, -t.distance / o, h._tempV33), Ct.scale(h._tempV31, -e.distance / s, h._tempV34),
                    Ct.scale(h._tempV32, -n.distance / l, h._tempV35), Ct.add(h._tempV33, h._tempV34, h._tempV36),
                    Ct.add(h._tempV35, h._tempV36, h._tempV37), h._tempV37;
            }, _(h, ["_tempV30", function() {
                return this._tempV30 = new Ct();
            }, "_tempV31", function() {
                return this._tempV31 = new Ct();
            }, "_tempV32", function() {
                return this._tempV32 = new Ct();
            }, "_tempV33", function() {
                return this._tempV33 = new Ct();
            }, "_tempV34", function() {
                return this._tempV34 = new Ct();
            }, "_tempV35", function() {
                return this._tempV35 = new Ct();
            }, "_tempV36", function() {
                return this._tempV36 = new Ct();
            }, "_tempV37", function() {
                return this._tempV37 = new Ct();
            }]), h;
        }(),
        Ae = function() {
            function t() {
                this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1,
                    this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null,
                    this.crossFixedValue = null;
            }
            return d(t, "laya.d3.component.KeyframeNodeOwner"), t.prototype.saveCrossFixedValue = function() {
                var t = this.propertyOwner;
                if (t) switch (this.type) {
                    case 0:
                        for (var e = this.property, n = e.length - 1, i = 0; i < n && (t = t[e[i]]); i++);
                        this.crossFixedValue = t[e[n]];
                        break;

                    case 1:
                        var r = t.localPosition;
                        this.crossFixedValue || (this.crossFixedValue = new Ct()), this.crossFixedValue.x = r.x,
                            this.crossFixedValue.y = r.y, this.crossFixedValue.z = r.z;
                        break;

                    case 2:
                        var a = t.localRotation;
                        this.crossFixedValue || (this.crossFixedValue = new rt()), this.crossFixedValue.x = a.x,
                            this.crossFixedValue.y = a.y, this.crossFixedValue.z = a.z, this.crossFixedValue.w = a.w;
                        break;

                    case 3:
                        var o = t.localScale;
                        this.crossFixedValue || (this.crossFixedValue = new Ct()), this.crossFixedValue.x = o.x,
                            this.crossFixedValue.y = o.y, this.crossFixedValue.z = o.z;
                        break;

                    case 4:
                        var s = t.localRotationEuler;
                        this.crossFixedValue || (this.crossFixedValue = new Ct()), this.crossFixedValue.x = s.x,
                            this.crossFixedValue.y = s.y, this.crossFixedValue.z = s.z;
                        break;

                    default:
                        throw "Animator:unknown type.";
                }
            }, t;
        }(),
        Ce = function() {
            function g() {}
            return d(g, "laya.d3.graphics.FrustumCulling"), g.__init__ = function() {
                b.supportWebGLPlusCulling && (g._cullingBufferLength = 0, g._cullingBuffer = new Float32Array(4096));
            }, g._drawTraversalCullingBound = function(t, e) {
                t.length;
                for (var n = t.elements, i = 0, r = t.length; i < r; i++) {
                    var a = g._tempColor0;
                    a.r = 0, a.g = 1, a.b = 0, a.a = 1, Gt._drawBound(e, n[i].boundingBox, a);
                }
            }, g._traversalCulling = function(t, e, n, i) {
                for (var r = i.length, a = i.elements, o = t.boundFrustum, s = t._transform.position, l = 0; l < r; l++) {
                    var h = a[l];
                    if (t._isLayerVisible(h._owner._layer) && h._enable)
                        if (M.frustumCulling++, !t.useOcclusionCulling || h._needRender(o)) {
                            h._visible = !0, h._distanceForSort = Ct.distance(h.boundingSphere.center, s);
                            for (var u = h._renderElements, c = 0, _ = u.length; c < _; c++) {
                                var d = u[c],
                                    f = e._getRenderQueue(d.material.renderQueue);
                                f.isTransparent ? d.addToTransparentRenderQueue(n, f) : d.addToOpaqueRenderQueue(n, f);
                            }
                        } else h._visible = !1;
                    else h._visible = !1;
                }
            }, g.renderObjectCulling = function(t, e, n, i) {
                var r = 0,
                    a = 0,
                    o = e._opaqueQueue,
                    s = e._transparentQueue;
                o.clear(), s.clear();
                var l = Z._managers;
                for (r = 0, a = l.length; r < a; r++) l[r]._clear();
                var h = q._managers;
                for (r = 0, a = h.length; r < a; r++) h[r]._clear();
                var u = e._octree;
                if (u ? (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(n)) : g._traversalCulling(t, e, n, i),
                    k._config.debugFrustumCulling) {
                    var c = e._debugTool;
                    c.clear(), u ? (u.drawAllBounds(c), u.drawAllObjects(c)) : g._drawTraversalCullingBound(i, c);
                }
                var _ = o.elements.length;
                0 < _ && o._quickSort(0, _ - 1), 0 < (_ = s.elements.length) && s._quickSort(0, _ - 1);
            }, g.renderObjectCullingNative = function(t, e, n, i) {
                var r = 0,
                    a = 0,
                    o = 0,
                    s = 0,
                    l = e._opaqueQueue,
                    h = e._transparentQueue;
                l.clear(), h.clear();
                var u = Z._managers;
                for (r = 0, a = u.length; r < a; r++) u[r]._clear();
                var c = q._managers;
                for (r = 0, a = c.length; r < a; r++) c[r]._clear();
                var _ = i.length,
                    d = i.elements;
                for (r = 0; r < _; r++) d[r].boundingSphere;
                t.boundFrustum;
                g.cullingNative(t._boundFrustumBuffer, g._cullingBuffer, e._cullingBufferIndices, _, e._cullingBufferResult);
                var f = n.camera._transform.position;
                for (r = 0; r < _; r++) {
                    var m = d[r];
                    if (t._isLayerVisible(m._owner._layer) && m._enable && e._cullingBufferResult[r]) {
                        m._visible = !0, m._distanceForSort = Ct.distance(m.boundingSphere.center, f);
                        var p = m._renderElements;
                        for (o = 0, s = p.length; o < s; o++) {
                            var T = p[o],
                                E = e._getRenderQueue(T.material.renderQueue);
                            E.isTransparent ? T.addToTransparentRenderQueue(n, E) : T.addToOpaqueRenderQueue(n, E);
                        }
                    } else m._visible = !1;
                }
                var v = l.elements.length;
                0 < v && l._quickSort(0, v - 1), 0 < (v = h.elements.length) && h._quickSort(0, v - 1);
            }, g.cullingNative = function(t, e, n, i, r) {
                return E.instance.culling(t, e, n, i, r);
            }, g._cullingBufferLength = 0, g._cullingBuffer = null, _(g, ["_tempColor0", function() {
                return this._tempColor0 = new dt();
            }]), g;
        }(),
        Le = function() {
            function t(t) {
                this._defaultState = null, this._statesMap = {}, this.playOnWake = !0, this._playType = -1,
                    this._crossMark = 0, this._crossDuration = -1, this._crossNodesOwnersIndicesMap = {},
                    this._crossNodesOwnersCount = 0, this._crossNodesOwners = [], this._currentPlayState = null,
                    this._states = [], this._playStateInfo = new ut(), this._crossPlayStateInfo = new ut(),
                    this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], this.name = t,
                    this.defaultWeight = 1, this.blendingMode = laya.d3.component.AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            }
            d(t, "laya.d3.component.AnimatorControllerLayer");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e.getAnimatorState = function(t) {
                var e = this._statesMap[t];
                return e || null;
            }, e.destroy = function() {
                this._statesMap = null, this._states = null, this._playStateInfo = null, this._crossPlayStateInfo = null,
                    this._defaultState = null;
            }, e.cloneTo = function(t) {
                var e = t;
                e.name = this.name, e.blendingMode = this.blendingMode, e.defaultWeight = this.defaultWeight,
                    e.playOnWake = this.playOnWake;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "defaultState", function() {
                return this._defaultState;
            }, function(t) {
                this._defaultState = t, this._statesMap[t.name] = t;
            }), t.BLENDINGMODE_OVERRIDE = 0, t.BLENDINGMODE_ADDTIVE = 1, t;
        }(),
        Oe = function() {
            function H() {}
            return d(H, "laya.d3.math.CollisionUtils"), H.distancePlaneToPoint = function(t, e) {
                return Ct.dot(t.normal, e) - t.distance;
            }, H.distanceBoxToPoint = function(t, e) {
                var n = t.min,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.max,
                    s = o.x,
                    l = o.y,
                    h = o.z,
                    u = e.x,
                    c = e.y,
                    _ = e.z,
                    d = 0;
                return u < i && (d += (i - u) * (i - u)), s < u && (d += (s - u) * (s - u)), c < r && (d += (r - c) * (r - c)),
                    l < c && (d += (l - c) * (l - c)), _ < a && (d += (a - _) * (a - _)), h < _ && (d += (h - _) * (h - _)),
                    Math.sqrt(d);
            }, H.distanceBoxToBox = function(t, e) {
                var n = t.min,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.max,
                    s = o.x,
                    l = o.y,
                    h = o.z,
                    u = e.min,
                    c = u.x,
                    _ = u.y,
                    d = u.z,
                    f = e.max,
                    m = f.x,
                    p = f.y,
                    T = f.z,
                    E = 0,
                    v = NaN;
                return m < i ? E += (v = i - m) * v : s < c && (E += (v = c - s) * v), p < r ? E += (v = r - p) * v : l < _ && (E += (v = _ - l) * v),
                    T < a ? E += (v = a - T) * v : h < d && (E += (v = d - h) * v), Math.sqrt(E);
            }, H.distanceSphereToPoint = function(t, e) {
                var n = Math.sqrt(Ct.distanceSquared(t.center, e));
                return n -= t.radius, Math.max(n, 0);
            }, H.distanceSphereToSphere = function(t, e) {
                var n = Math.sqrt(Ct.distanceSquared(t.center, e.center));
                return n -= t.radius + e.radius, Math.max(n, 0);
            }, H.intersectsRayAndTriangleRD = function(t, e, n, i, r) {
                var a = t.origin,
                    o = a.x,
                    s = a.y,
                    l = a.z,
                    h = t.direction,
                    u = h.x,
                    c = h.y,
                    _ = h.z,
                    d = e.x,
                    f = e.y,
                    m = e.z,
                    p = n.x,
                    T = n.y,
                    E = n.z,
                    v = i.x,
                    g = i.y,
                    S = i.z,
                    y = H._tempV30.x,
                    x = H._tempV30.y,
                    D = H._tempV30.z;
                y = p - d, x = T - f, D = E - m;
                var I = H._tempV31.x,
                    R = H._tempV31.y,
                    M = H._tempV31.z;
                I = v - d, R = g - f, M = S - m;
                var A = H._tempV32.x,
                    C = H._tempV32.y,
                    L = H._tempV32.z,
                    O = y * (A = c * M - _ * R) + x * (C = _ * I - u * M) + D * (L = u * R - c * I);
                if ($.isZero(O)) return 0, !1;
                var N = 1 / O,
                    V = H._tempV33.x,
                    w = H._tempV33.y,
                    P = H._tempV33.z,
                    b = (V = o - d) * A + (w = s - f) * C + (P = l - m) * L;
                if ((b *= N) < 0 || 1 < b) return 0, !1;
                var F = H._tempV34.x,
                    B = H._tempV34.y,
                    U = H._tempV34.z,
                    z = u * (F = w * D - P * x) + c * (B = P * y - V * D) + _ * (U = V * x - w * y);
                if ((z *= N) < 0 || 1 < b + z) return 0, !1;
                var G = I * F + R * B + M * U;
                return (G *= N) < 0 ? (0, !1) : (G, !0);
            }, H.intersectsRayAndTriangleRP = function(t, e, n, i, r) {
                return H.intersectsRayAndTriangleRD(t, e, n, i, NaN) ? (Ct.scale(t.direction, NaN, H._tempV30),
                    Ct.add(t.origin, H._tempV30, r), !0) : (r = Ct._ZERO, !1);
            }, H.intersectsRayAndPoint = function(t, e) {
                Ct.subtract(t.origin, e, H._tempV30);
                var n = Ct.dot(H._tempV30, t.direction),
                    i = Ct.dot(H._tempV30, H._tempV30) - $.zeroTolerance;
                return !(0 < i && 0 < n) && !(n * n - i < 0);
            }, H.intersectsRayAndRay = function(t, e, n) {
                var i = t.origin,
                    r = i.x,
                    a = i.y,
                    o = i.z,
                    s = t.direction,
                    l = s.x,
                    h = s.y,
                    u = s.z,
                    c = e.origin,
                    _ = c.x,
                    d = c.y,
                    f = c.z,
                    m = e.direction,
                    p = m.x,
                    T = m.y,
                    E = m.z;
                Ct.cross(s, m, H._tempV30);
                var v = H._tempV30,
                    g = Ct.scalarLength(H._tempV30);
                if ($.isZero(g) && $.nearEqual(_, r) && $.nearEqual(d, a) && $.nearEqual(f, o)) return Ct._ZERO, !0;
                g *= g;
                var S = _ - r,
                    y = d - a,
                    x = f - o,
                    D = p,
                    I = T,
                    R = E,
                    M = v.x,
                    A = v.y,
                    C = v.z,
                    L = (S * I * C + y * R * M + x * D * A - S * R * A - y * D * C - x * I * M) / g;
                I = h, R = u, D = l;
                Ct.scale(s, L, H._tempV30), Ct.scale(m, L, H._tempV31), Ct.add(i, H._tempV30, H._tempV32),
                    Ct.add(c, H._tempV31, H._tempV33);
                var O = H._tempV32,
                    N = H._tempV33;
                return $.nearEqual(N.x, O.x) && $.nearEqual(N.y, O.y) && $.nearEqual(N.z, O.z) ? (H._tempV32, !0) : (Ct._ZERO, !1);
            }, H.intersectsPlaneAndTriangle = function(t, e, n, i) {
                var r = H.intersectsPlaneAndPoint(t, e),
                    a = H.intersectsPlaneAndPoint(t, n),
                    o = H.intersectsPlaneAndPoint(t, i);
                return r == et.PlaneIntersectionType_Front && a == et.PlaneIntersectionType_Front && o == et.PlaneIntersectionType_Front ? et.PlaneIntersectionType_Front : r == et.PlaneIntersectionType_Back && a == et.PlaneIntersectionType_Back && o == et.PlaneIntersectionType_Back ? et.PlaneIntersectionType_Back : et.PlaneIntersectionType_Intersecting;
            }, H.intersectsRayAndPlaneRD = function(t, e, n) {
                var i = e.normal,
                    r = Ct.dot(i, t.direction);
                if ($.isZero(r)) return 0, !1;
                var a = Ct.dot(i, t.origin);
                return !((-e.distance - a) / r < 0) || (0, !1);
            }, H.intersectsRayAndPlaneRP = function(t, e, n) {
                return H.intersectsRayAndPlaneRD(t, e, NaN) ? (Ct.scale(t.direction, NaN, H._tempV30),
                    Ct.add(t.origin, H._tempV30, H._tempV31), H._tempV31, !0) : (Ct._ZERO, !1);
            }, H.intersectsRayAndBoxRD = function(t, e) {
                var n = t.origin,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.direction,
                    s = o.x,
                    l = o.y,
                    h = o.z,
                    u = e.min,
                    c = u.x,
                    _ = u.y,
                    d = u.z,
                    f = e.max,
                    m = f.x,
                    p = f.y,
                    T = f.z,
                    E = 0,
                    v = $.MaxValue;
                if ($.isZero(s)) {
                    if (i < c || m < i) return -1;
                } else {
                    var g = 1 / s,
                        S = (c - i) * g,
                        y = (m - i) * g;
                    if (y < S) {
                        var x = S;
                        S = y, y = x;
                    }
                    if (E = Math.max(S, E), (v = Math.min(y, v)) < E) return -1;
                }
                if ($.isZero(l)) {
                    if (r < _ || p < r) return -1;
                } else {
                    var D = 1 / l,
                        I = (_ - r) * D,
                        R = (p - r) * D;
                    if (R < I) {
                        var M = I;
                        I = R, R = M;
                    }
                    if (E = Math.max(I, E), (v = Math.min(R, v)) < E) return -1;
                }
                if ($.isZero(h)) {
                    if (a < d || T < a) return -1;
                } else {
                    var A = 1 / h,
                        C = (d - a) * A,
                        L = (T - a) * A;
                    if (L < C) {
                        var O = C;
                        C = L, L = O;
                    }
                    if (E = Math.max(C, E), (v = Math.min(L, v)) < E) return -1;
                }
                return E;
            }, H.intersectsRayAndBoxRP = function(t, e, n) {
                var i = H.intersectsRayAndBoxRD(t, e);
                return -1 === i ? Ct._ZERO.cloneTo(n) : (Ct.scale(t.direction, i, H._tempV30), Ct.add(t.origin, H._tempV30, H._tempV31),
                    H._tempV31.cloneTo(n)), i;
            }, H.intersectsRayAndSphereRD = function(t, e) {
                var n = e.radius;
                Ct.subtract(t.origin, e.center, H._tempV30);
                var i = Ct.dot(H._tempV30, t.direction),
                    r = Ct.dot(H._tempV30, H._tempV30) - n * n;
                if (0 < r && 0 < i) return -1;
                var a = i * i - r;
                if (a < 0) return -1;
                var o = -i - Math.sqrt(a);
                return o < 0 && (o = 0), o;
            }, H.intersectsRayAndSphereRP = function(t, e, n) {
                var i = H.intersectsRayAndSphereRD(t, e);
                return -1 === i ? Ct._ZERO.cloneTo(n) : (Ct.scale(t.direction, i, H._tempV30), Ct.add(t.origin, H._tempV30, H._tempV31),
                    H._tempV31.cloneTo(n)), i;
            }, H.intersectsSphereAndTriangle = function(t, e, n, i) {
                var r = t.center,
                    a = t.radius;
                return H.closestPointPointTriangle(r, e, n, i, H._tempV30), Ct.subtract(H._tempV30, r, H._tempV31),
                    Ct.dot(H._tempV31, H._tempV31) <= a * a;
            }, H.intersectsPlaneAndPoint = function(t, e) {
                var n = Ct.dot(t.normal, e) + t.distance;
                return 0 < n ? et.PlaneIntersectionType_Front : n < 0 ? et.PlaneIntersectionType_Back : et.PlaneIntersectionType_Intersecting;
            }, H.intersectsPlaneAndPlane = function(t, e) {
                Ct.cross(t.normal, e.normal, H._tempV30);
                var n = Ct.dot(H._tempV30, H._tempV30);
                return !$.isZero(n);
            }, H.intersectsPlaneAndPlaneRL = function(t, e, n) {
                var i = t.normal,
                    r = e.normal;
                Ct.cross(i, r, H._tempV34);
                var a = Ct.dot(H._tempV34, H._tempV34);
                return !$.isZero(a) && (Ct.scale(r, t.distance, H._tempV30), Ct.scale(i, e.distance, H._tempV31),
                    Ct.subtract(H._tempV30, H._tempV31, H._tempV32), Ct.cross(H._tempV32, H._tempV34, H._tempV33),
                    Ct.normalize(H._tempV34, H._tempV34), new X(H._tempV33, H._tempV34), !0);
            }, H.intersectsPlaneAndBox = function(t, e) {
                var n = t.distance,
                    i = t.normal,
                    r = i.x,
                    a = i.y,
                    o = i.z,
                    s = e.min,
                    l = s.x,
                    h = s.y,
                    u = s.z,
                    c = e.max,
                    _ = c.x,
                    d = c.y,
                    f = c.z;
                H._tempV30.x = 0 < r ? l : _, H._tempV30.y = 0 < a ? h : d, H._tempV30.z = 0 < o ? u : f,
                    H._tempV31.x = 0 < r ? _ : l, H._tempV31.y = 0 < a ? d : h, H._tempV31.z = 0 < o ? f : u;
                var m = Ct.dot(i, H._tempV30);
                return 0 < m + n ? et.PlaneIntersectionType_Front : (m = Ct.dot(i, H._tempV31)) + n < 0 ? et.PlaneIntersectionType_Back : et.PlaneIntersectionType_Intersecting;
            }, H.intersectsPlaneAndSphere = function(t, e) {
                var n = e.radius,
                    i = Ct.dot(t.normal, e.center) + t.distance;
                return n < i ? et.PlaneIntersectionType_Front : i < -n ? et.PlaneIntersectionType_Back : et.PlaneIntersectionType_Intersecting;
            }, H.intersectsBoxAndBox = function(t, e) {
                var n = t.min,
                    i = t.max,
                    r = e.min,
                    a = e.max;
                return !(n.x > a.x || r.x > i.x) && (!(n.y > a.y || r.y > i.y) && !(n.z > a.z || r.z > i.z));
            }, H.intersectsBoxAndSphere = function(t, e) {
                var n = e.center,
                    i = e.radius;
                return Ct.Clamp(n, t.min, t.max, H._tempV30), Ct.distanceSquared(n, H._tempV30) <= i * i;
            }, H.intersectsSphereAndSphere = function(t, e) {
                var n = t.radius + e.radius;
                return Ct.distanceSquared(t.center, e.center) <= n * n;
            }, H.boxContainsPoint = function(t, e) {
                var n = t.min,
                    i = t.max;
                return n.x <= e.x && i.x >= e.x && n.y <= e.y && i.y >= e.y && n.z <= e.z && i.z >= e.z ? 1 : 0;
            }, H.boxContainsBox = function(t, e) {
                var n = t.min,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.max,
                    s = o.x,
                    l = o.y,
                    h = o.z,
                    u = e.min,
                    c = u.x,
                    _ = u.y,
                    d = u.z,
                    f = e.max,
                    m = f.x,
                    p = f.y,
                    T = f.z;
                return s < c || m < i ? 0 : l < _ || p < r ? 0 : h < d || T < a ? 0 : i <= c && m <= s && r <= _ && p <= l && a <= d && T <= h ? 1 : 2;
            }, H.boxContainsSphere = function(t, e) {
                var n = t.min,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.max,
                    s = o.x,
                    l = o.y,
                    h = o.z,
                    u = e.center,
                    c = u.x,
                    _ = u.y,
                    d = u.z,
                    f = e.radius;
                return Ct.Clamp(u, n, o, H._tempV30), f * f < Ct.distanceSquared(u, H._tempV30) ? 0 : i + f <= c && c <= s - f && f < s - i && r + f <= _ && _ <= l - f && f < l - r && a + f <= d && d <= h - f && f < h - a ? 1 : 2;
            }, H.sphereContainsPoint = function(t, e) {
                return Ct.distanceSquared(e, t.center) <= t.radius * t.radius ? 1 : 0;
            }, H.sphereContainsTriangle = function(t, e, n, i) {
                var r = H.sphereContainsPoint(t, e),
                    a = H.sphereContainsPoint(t, n),
                    o = H.sphereContainsPoint(t, i);
                return 1 == r && 1 == a && 1 == o ? 1 : H.intersectsSphereAndTriangle(t, e, n, i) ? 2 : 0;
            }, H.sphereContainsBox = function(t, e) {
                var n = t.center,
                    i = n.x,
                    r = n.y,
                    a = n.z,
                    o = t.radius,
                    s = e.min,
                    l = s.x,
                    h = s.y,
                    u = s.z,
                    c = e.max,
                    _ = c.x,
                    d = c.y,
                    f = c.z,
                    m = H._tempV30;
                m.x, m.y, m.z;
                if (!H.intersectsBoxAndSphere(e, t)) return 0;
                var p = o * o;
                return i - l, r - d, a - f, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - _,
                    r - d, a - f, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - _, r - h, a - f,
                        Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - l, r - h, a - f, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - l,
                            r - d, a - u, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - _, r - d, a - u,
                                Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - _, r - h, a - u, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : (i - l,
                                    r - h, a - u, Ct.scalarLengthSquared(H._tempV30) > p ? 2 : 1)))))));
            }, H.sphereContainsSphere = function(t, e) {
                var n = t.radius,
                    i = e.radius,
                    r = Ct.distance(t.center, e.center);
                return n + i < r ? 0 : n - i < r ? 2 : 1;
            }, H.closestPointPointTriangle = function(t, e, n, i, r) {
                Ct.subtract(n, e, H._tempV30), Ct.subtract(i, e, H._tempV31), Ct.subtract(t, e, H._tempV32),
                    Ct.subtract(t, n, H._tempV33), Ct.subtract(t, i, H._tempV34);
                var a = Ct.dot(H._tempV30, H._tempV32),
                    o = Ct.dot(H._tempV31, H._tempV32),
                    s = Ct.dot(H._tempV30, H._tempV33),
                    l = Ct.dot(H._tempV31, H._tempV33),
                    h = Ct.dot(H._tempV30, H._tempV34),
                    u = Ct.dot(H._tempV31, H._tempV34);
                if (a <= 0 && o <= 0) e.cloneTo(r);
                else if (0 <= s && l <= s) n.cloneTo(r);
                else {
                    var c = a * l - s * o;
                    if (c <= 0 && 0 <= a && s <= 0) {
                        var _ = a / (a - s);
                        return Ct.scale(H._tempV30, _, r), void Ct.add(e, r, r);
                    }
                    if (0 <= u && h <= u) i.cloneTo(r);
                    else {
                        var d = h * o - a * u;
                        if (d <= 0 && 0 <= o && u <= 0) {
                            var f = o / (o - u);
                            return Ct.scale(H._tempV31, f, r), void Ct.add(e, r, r);
                        }
                        var m = s * u - h * l;
                        if (m <= 0 && 0 <= l - s && 0 <= h - u) {
                            var p = (l - s) / (l - s + (h - u));
                            return Ct.subtract(i, n, r), Ct.scale(r, p, r), void Ct.add(n, r, r);
                        }
                        var T = 1 / (m + d + c),
                            E = d * T,
                            v = c * T;
                        Ct.scale(H._tempV30, E, H._tempV35), Ct.scale(H._tempV31, v, H._tempV36), Ct.add(H._tempV35, H._tempV36, r),
                            Ct.add(e, r, r);
                    }
                }
            }, H.closestPointPlanePoint = function(t, e, n) {
                var i = t.normal,
                    r = Ct.dot(i, e) - t.distance;
                Ct.scale(i, r, H._tempV30), Ct.subtract(e, H._tempV30, n);
            }, H.closestPointBoxPoint = function(t, e, n) {
                Ct.max(e, t.min, H._tempV30), Ct.min(H._tempV30, t.max, n);
            }, H.closestPointSpherePoint = function(t, e, n) {
                var i = t.center;
                Ct.subtract(e, i, n), Ct.normalize(n, n), Ct.scale(n, t.radius, n), Ct.add(n, i, n);
            }, H.closestPointSphereSphere = function(t, e, n) {
                var i = t.center;
                Ct.subtract(e.center, i, n), Ct.normalize(n, n), Ct.scale(n, t.radius, n), Ct.add(n, i, n);
            }, _(H, ["_tempV30", function() {
                return this._tempV30 = new Ct();
            }, "_tempV31", function() {
                return this._tempV31 = new Ct();
            }, "_tempV32", function() {
                return this._tempV32 = new Ct();
            }, "_tempV33", function() {
                return this._tempV33 = new Ct();
            }, "_tempV34", function() {
                return this._tempV34 = new Ct();
            }, "_tempV35", function() {
                return this._tempV35 = new Ct();
            }, "_tempV36", function() {
                return this._tempV36 = new Ct();
            }]), H;
        }(),
        Ne = function() {
            function l() {
                var t = this.elements = new Float32Array(9);
                t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0,
                    t[8] = 1;
            }
            d(l, "laya.d3.math.Matrix3x3");
            var t = l.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.determinant = function() {
                var t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = t[3],
                    a = t[4],
                    o = t[5],
                    s = t[6],
                    l = t[7],
                    h = t[8];
                return e * (h * a - o * l) + n * (-h * r + o * s) + i * (l * r - a * s);
            }, t.translate = function(t, e) {
                var n = e.elements,
                    i = this.elements,
                    r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = i[4],
                    h = i[5],
                    u = i[6],
                    c = i[7],
                    _ = i[8],
                    d = t.x,
                    f = t.y;
                n[0] = r, n[1] = a, n[2] = o, n[3] = s, n[4] = l, n[5] = h, n[6] = d * r + f * s + u,
                    n[7] = d * a + f * l + c, n[8] = d * o + f * h + _;
            }, t.rotate = function(t, e) {
                var n = e.elements,
                    i = this.elements,
                    r = i[0],
                    a = i[1],
                    o = i[2],
                    s = i[3],
                    l = i[4],
                    h = i[5],
                    u = i[6],
                    c = i[7],
                    _ = i[8],
                    d = Math.sin(t),
                    f = Math.cos(t);
                n[0] = f * r + d * s, n[1] = f * a + d * l, n[2] = f * o + d * h, n[3] = f * s - d * r,
                    n[4] = f * l - d * a, n[5] = f * h - d * o, n[6] = u, n[7] = c, n[8] = _;
            }, t.scale = function(t, e) {
                var n = e.elements,
                    i = this.elements,
                    r = t.x,
                    a = t.y;
                n[0] = r * i[0], n[1] = r * i[1], n[2] = r * i[2], n[3] = a * i[3], n[4] = a * i[4],
                    n[5] = a * i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8];
            }, t.invert = function(t) {
                var e = t.elements,
                    n = this.elements,
                    i = n[0],
                    r = n[1],
                    a = n[2],
                    o = n[3],
                    s = n[4],
                    l = n[5],
                    h = n[6],
                    u = n[7],
                    c = n[8],
                    _ = c * s - l * u,
                    d = -c * o + l * h,
                    f = u * o - s * h,
                    m = i * _ + r * d + a * f;
                m || (t = null), m = 1 / m, e[0] = _ * m, e[1] = (-c * r + a * u) * m, e[2] = (l * r - a * s) * m,
                    e[3] = d * m, e[4] = (c * i - a * h) * m, e[5] = (-l * i + a * o) * m, e[6] = f * m,
                    e[7] = (-u * i + r * h) * m, e[8] = (s * i - r * o) * m;
            }, t.transpose = function(t) {
                var e = t.elements,
                    n = this.elements;
                if (t === this) {
                    var i = n[1],
                        r = n[2],
                        a = n[5];
                    e[1] = n[3], e[2] = n[6], e[3] = i, e[5] = n[7], e[6] = r, e[7] = a;
                } else e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7],
                    e[6] = n[2], e[7] = n[5], e[8] = n[8];
            }, t.identity = function() {
                var t = this.elements;
                t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0,
                    t[8] = 1;
            }, t.cloneTo = function(t) {
                var e, n, i;
                if ((n = this.elements) !== (i = t.elements))
                    for (e = 0; e < 9; ++e) i[e] = n[e];
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, l.createFromTranslation = function(t, e) {
                e.elements;
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = t.x, e[7] = t.y,
                    e[8] = 1;
            }, l.createFromRotation = function(t, e) {
                var n = e.elements,
                    i = Math.sin(t),
                    r = Math.cos(t);
                n[0] = r, n[1] = i, n[2] = 0, n[3] = -i, n[4] = r, n[5] = 0, n[6] = 0, n[7] = 0,
                    n[8] = 1;
            }, l.createFromScaling = function(t, e) {
                var n = e.elements;
                n[0] = t.x, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = t.y, n[5] = 0, n[6] = 0, n[7] = 0,
                    n[8] = 1;
            }, l.createFromMatrix4x4 = function(t, e) {
                e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[4], e[4] = t[5], e[5] = t[6], e[6] = t[8],
                    e[7] = t[9], e[8] = t[10];
            }, l.multiply = function(t, e, n) {
                var i = n.elements,
                    r = t.elements,
                    a = e.elements,
                    o = r[0],
                    s = r[1],
                    l = r[2],
                    h = r[3],
                    u = r[4],
                    c = r[5],
                    _ = r[6],
                    d = r[7],
                    f = r[8],
                    m = a[0],
                    p = a[1],
                    T = a[2],
                    E = a[3],
                    v = a[4],
                    g = a[5],
                    S = a[6],
                    y = a[7],
                    x = a[8];
                i[0] = m * o + p * h + T * _, i[1] = m * s + p * u + T * d, i[2] = m * l + p * c + T * f,
                    i[3] = E * o + v * h + g * _, i[4] = E * s + v * u + g * d, i[5] = E * l + v * c + g * f,
                    i[6] = S * o + y * h + x * _, i[7] = S * s + y * u + x * d, i[8] = S * l + y * c + x * f;
            }, l.lookAt = function(t, e, n, i) {
                Ct.subtract(t, e, l._tempV30), Ct.normalize(l._tempV30, l._tempV30), Ct.cross(n, l._tempV30, l._tempV31),
                    Ct.normalize(l._tempV31, l._tempV31), Ct.cross(l._tempV30, l._tempV31, l._tempV32);
                var r = l._tempV30,
                    a = l._tempV31,
                    o = l._tempV32,
                    s = i.elements;
                s[0] = a.x, s[3] = a.y, s[6] = a.z, s[1] = o.x, s[4] = o.y, s[7] = o.z, s[2] = r.x,
                    s[5] = r.y, s[8] = r.z;
            }, l.DEFAULT = new l(), _(l, ["_tempV30", function() {
                return this._tempV30 = new Ct();
            }, "_tempV31", function() {
                return this._tempV31 = new Ct();
            }, "_tempV32", function() {
                return this._tempV32 = new Ct();
            }]), l;
        }(),
        Ve = function() {
            function t() {}
            return d(t, "laya.d3.utils.Physics3DUtils"), t.setColliderCollision = function(t, e, n) {},
                t.getIColliderCollision = function(t, e) {
                    return !1;
                }, t.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, t.COLLISIONFILTERGROUP_STATICFILTER = 2,
                t.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, t.COLLISIONFILTERGROUP_DEBRISFILTER = 8,
                t.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, t.COLLISIONFILTERGROUP_CHARACTERFILTER = 32,
                t.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, t.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128,
                t.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, t.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512,
                t.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, t.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048,
                t.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, t.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192,
                t.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, t.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768,
                t.COLLISIONFILTERGROUP_ALLFILTER = -1, _(t, ["gravity", function() {
                    return this.gravity = new Ct(0, -9.81, 0);
                }]), t;
        }(),
        we = function() {
            function r(t, e) {
                this.min = null, this.max = null, this.min = t, this.max = e;
            }
            d(r, "laya.d3.math.BoundBox");
            var t = r.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t._rotateExtents = function(t, e, n) {
                var i = t.x,
                    r = t.y,
                    a = t.z,
                    o = e.elements;
                n.x = Math.abs(o[0] * i) + Math.abs(o[4] * r) + Math.abs(o[8] * a), n.y = Math.abs(o[1] * i) + Math.abs(o[5] * r) + Math.abs(o[9] * a),
                    n.z = Math.abs(o[2] * i) + Math.abs(o[6] * r) + Math.abs(o[10] * a);
            }, t.getCorners = function(t) {
                t.length = 8;
                var e = this.min.x,
                    n = this.min.y,
                    i = this.min.z,
                    r = this.max.x,
                    a = this.max.y,
                    o = this.max.z;
                t[0] = new Ct(e, a, o), t[1] = new Ct(r, a, o), t[2] = new Ct(r, n, o), t[3] = new Ct(e, n, o),
                    t[4] = new Ct(e, a, i), t[5] = new Ct(r, a, i), t[6] = new Ct(r, n, i), t[7] = new Ct(e, n, i);
            }, t.getCenter = function(t) {
                Ct.add(this.min, this.max, t), Ct.scale(t, .5, t);
            }, t.getExtent = function(t) {
                Ct.subtract(this.max, this.min, t), Ct.scale(t, .5, t);
            }, t.setCenterAndExtent = function(t, e) {
                Ct.subtract(t, e, this.min), Ct.add(t, e, this.max);
            }, t.tranform = function(t, e) {
                var n = r._tempVector30,
                    i = r._tempVector31;
                this.getCenter(n), this.getExtent(i), Ct.transformCoordinate(n, t, n), this._rotateExtents(i, t, i),
                    e.setCenterAndExtent(n, i);
            }, t.toDefault = function() {
                this.min.toDefault(), this.max.toDefault();
            }, t.cloneTo = function(t) {
                var e = t;
                this.min.cloneTo(e.min), this.max.cloneTo(e.max);
            }, t.clone = function() {
                var t = new this.constructor(new Ct(), new Ct());
                return this.cloneTo(t), t;
            }, r.createfromPoints = function(t, e) {
                if (null == t) throw new Error("points");
                var n = e.min,
                    i = e.max;
                n.x = Number.MAX_VALUE, n.y = Number.MAX_VALUE, n.z = Number.MAX_VALUE, i.x = -Number.MAX_VALUE,
                    i.y = -Number.MAX_VALUE, i.z = -Number.MAX_VALUE;
                for (var r = 0, a = t.length; r < a; ++r) Ct.min(n, t[r], n), Ct.max(i, t[r], i);
            }, r.merge = function(t, e, n) {
                Ct.min(t.min, e.min, n.min), Ct.max(t.max, e.max, n.max);
            }, _(r, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }]), r;
        }(),
        Pe = function() {
            function t() {
                this.speed = 1, this.clipStart = 0, this.clipEnd = 1, this._nodeOwners = [];
            }
            d(t, "laya.d3.component.AnimatorState");
            var e = t.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e._resetFrameIndices = function() {
                for (var t = 0, e = this._currentFrameIndices.length; t < e; t++) this._currentFrameIndices[t] = -1;
            }, e.addScript = function(t) {
                var e = new t();
                return this._scripts = this._scripts || [], this._scripts.push(e), e;
            }, e.getScript = function(t) {
                if (this._scripts)
                    for (var e = 0, n = this._scripts.length; e < n; e++) {
                        var i = this._scripts[e];
                        if (m.__typeof(i, t)) return i;
                    }
                return null;
            }, e.getScripts = function(t) {
                var e;
                if (this._scripts)
                    for (var n = 0, i = this._scripts.length; n < i; n++) {
                        var r = this._scripts[n];
                        m.__typeof(r, t) && (e = e || []).push(r);
                    }
                return e;
            }, e.cloneTo = function(t) {
                var e = t;
                e.name = this.name, e.speed = this.speed, e.clipStart = this.clipStart, e.clipEnd = this.clipEnd,
                    e.clip = this._clip;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "clip", function() {
                return this._clip;
            }, function(t) {
                this._clip = t, this._currentFrameIndices = new Int16Array(t._nodes.count), this._resetFrameIndices();
            }), t;
        }(),
        be = (function() {
            function t() {
                this._vertices = null, this._vertexBuffer = null, this._text = null, this._fontSize = 0,
                    this._color = null;
            }
            d(t, "laya.d3.text.TextMesh");
            var e = t.prototype;
            e._createVertexBuffer = function(t) {}, e._resizeVertexBuffer = function(t) {},
                e._addChar = function() {}, u(0, e, "text", function() {
                    return this._text;
                }, function(t) {
                    this._text = t;
                }), u(0, e, "fontSize", function() {
                    return this._fontSize;
                }, function(t) {
                    this._fontSize = t;
                }), u(0, e, "color", function() {
                    return this._color;
                }, function(t) {
                    this._color = t;
                }), t._indexBuffer = null;
        }(), function() {
            function x(t, e, n, i, r, a, o, s, l, h, u, c, _, d, f, m, p) {
                void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 0),
                    void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === o && (o = 0), void 0 === s && (s = 0),
                    void 0 === l && (l = 0), void 0 === h && (h = 0), void 0 === u && (u = 1), void 0 === c && (c = 0),
                    void 0 === _ && (_ = 0), void 0 === d && (d = 0), void 0 === f && (f = 0), void 0 === m && (m = 1);
                var T = this.elements = p || new Float32Array(16);
                T[0] = t, T[1] = e, T[2] = n, T[3] = i, T[4] = r, T[5] = a, T[6] = o, T[7] = s,
                    T[8] = l, T[9] = h, T[10] = u, T[11] = c, T[12] = _, T[13] = d, T[14] = f, T[15] = m;
            }
            d(x, "laya.d3.math.Matrix4x4");
            var t = x.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t.setRotation = function(t) {
                var e = t.x,
                    n = t.y,
                    i = t.z,
                    r = t.w,
                    a = e * e,
                    o = n * n,
                    s = i * i,
                    l = e * n,
                    h = i * r,
                    u = i * e,
                    c = n * r,
                    _ = n * i,
                    d = e * r,
                    f = this.elements;
                f[0] = 1 - 2 * (o + s), f[1] = 2 * (l + h), f[2] = 2 * (u - c), f[4] = 2 * (l - h),
                    f[5] = 1 - 2 * (s + a), f[6] = 2 * (_ + d), f[8] = 2 * (u + c), f[9] = 2 * (_ - d),
                    f[10] = 1 - 2 * (o + a);
            }, t.setPosition = function(t) {
                var e = this.elements;
                e[12] = t.x, e[13] = t.y, e[14] = t.z;
            }, t.getElementByRowColumn = function(t, e) {
                if (t < 0 || 3 < t) throw new Error("row", "Rows and columns for matrices run from 0 to 3, inclusive.");
                if (e < 0 || 3 < e) throw new Error("column", "Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * t + e];
            }, t.setElementByRowColumn = function(t, e, n) {
                if (t < 0 || 3 < t) throw new Error("row", "Rows and columns for matrices run from 0 to 3, inclusive.");
                if (e < 0 || 3 < e) throw new Error("column", "Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * t + e] = n;
            }, t.equalsOtherMatrix = function(t) {
                var e = this.elements,
                    n = t.elements;
                return $.nearEqual(e[0], n[0]) && $.nearEqual(e[1], n[1]) && $.nearEqual(e[2], n[2]) && $.nearEqual(e[3], n[3]) && $.nearEqual(e[4], n[4]) && $.nearEqual(e[5], n[5]) && $.nearEqual(e[6], n[6]) && $.nearEqual(e[7], n[7]) && $.nearEqual(e[8], n[8]) && $.nearEqual(e[9], n[9]) && $.nearEqual(e[10], n[10]) && $.nearEqual(e[11], n[11]) && $.nearEqual(e[12], n[12]) && $.nearEqual(e[13], n[13]) && $.nearEqual(e[14], n[14]) && $.nearEqual(e[15], n[15]);
            }, t.decomposeTransRotScale = function(t, e, n) {
                var i = x._tempMatrix4x4;
                return this.decomposeTransRotMatScale(t, i, n) ? (rt.createFromMatrix4x4(i, e), !0) : (e.identity(), !1);
            }, t.decomposeTransRotMatScale = function(t, e, n) {
                var i = this.elements,
                    r = t,
                    a = e.elements,
                    o = n;
                r.x = i[12], r.y = i[13], r.z = i[14];
                var s = i[0],
                    l = i[1],
                    h = i[2],
                    u = i[4],
                    c = i[5],
                    _ = i[6],
                    d = i[8],
                    f = i[9],
                    m = i[10],
                    p = o.x = Math.sqrt(s * s + l * l + h * h),
                    T = o.y = Math.sqrt(u * u + c * c + _ * _),
                    E = o.z = Math.sqrt(d * d + f * f + m * m);
                if ($.isZero(p) || $.isZero(T) || $.isZero(E)) return a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0,
                    a[0] = a[5] = a[10] = a[15] = 1, !1;
                var v = x._tempVector0;
                v.x = d / E, v.y = f / E, v.z = m / E;
                var g = x._tempVector1;
                g.x = s / p, g.y = l / p, g.z = h / p;
                var S = x._tempVector2;
                Ct.cross(v, g, S);
                var y = x._tempVector1;
                return Ct.cross(S, v, y), a[3] = a[7] = a[11] = a[12] = a[13] = a[14] = 0, a[15] = 1,
                    a[0] = y.x, a[1] = y.y, a[2] = y.z, a[4] = S.x, a[5] = S.y, a[6] = S.z, a[8] = v.x,
                    a[9] = v.y, a[10] = v.z, a[0] * s + a[1] * l + a[2] * h < 0 && (o[0] = -p), a[4] * u + a[5] * c + a[6] * _ < 0 && (o[1] = -T),
                    a[8] * d + a[9] * f + a[10] * m < 0 && (o[2] = -E), !0;
            }, t.decomposeYawPitchRoll = function(t) {
                var e = Math.asin(-this.elements[9]);
                t.y = e, Math.cos(e) > $.zeroTolerance ? (t.z = Math.atan2(this.elements[1], this.elements[5]),
                    t.x = Math.atan2(this.elements[8], this.elements[10])) : (t.z = Math.atan2(-this.elements[4], this.elements[0]),
                    t.x = 0);
            }, t.normalize = function() {
                var t = this.elements,
                    e = t[0],
                    n = t[1],
                    i = t[2],
                    r = Math.sqrt(e * e + n * n + i * i);
                if (!r) return t[0] = 0, t[1] = 0, void(t[2] = 0);
                1 != r && (r = 1 / r, t[0] = e * r, t[1] = n * r, t[2] = i * r);
            }, t.transpose = function() {
                var t, e;
                return e = (t = this.elements)[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8],
                    t[8] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[7],
                    t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
            }, t.invert = function(t) {
                var e = this.elements,
                    n = t.elements,
                    i = e[0],
                    r = e[1],
                    a = e[2],
                    o = e[3],
                    s = e[4],
                    l = e[5],
                    h = e[6],
                    u = e[7],
                    c = e[8],
                    _ = e[9],
                    d = e[10],
                    f = e[11],
                    m = e[12],
                    p = e[13],
                    T = e[14],
                    E = e[15],
                    v = i * l - r * s,
                    g = i * h - a * s,
                    S = i * u - o * s,
                    y = r * h - a * l,
                    x = r * u - o * l,
                    D = a * u - o * h,
                    I = c * p - _ * m,
                    R = c * T - d * m,
                    M = c * E - f * m,
                    A = _ * T - d * p,
                    C = _ * E - f * p,
                    L = d * E - f * T,
                    O = v * L - g * C + S * A + y * M - x * R + D * I;
                0 !== Math.abs(O) && (O = 1 / O, n[0] = (l * L - h * C + u * A) * O, n[1] = (a * C - r * L - o * A) * O,
                    n[2] = (p * D - T * x + E * y) * O, n[3] = (d * x - _ * D - f * y) * O, n[4] = (h * M - s * L - u * R) * O,
                    n[5] = (i * L - a * M + o * R) * O, n[6] = (T * S - m * D - E * g) * O, n[7] = (c * D - d * S + f * g) * O,
                    n[8] = (s * C - l * M + u * I) * O, n[9] = (r * M - i * C - o * I) * O, n[10] = (m * x - p * S + E * v) * O,
                    n[11] = (_ * S - c * x - f * v) * O, n[12] = (l * R - s * A - h * I) * O, n[13] = (i * A - r * R + a * I) * O,
                    n[14] = (p * g - m * y - T * v) * O, n[15] = (c * y - _ * g + d * v) * O);
            }, t.identity = function() {
                var t = this.elements;
                t[1] = t[2] = t[3] = t[4] = t[6] = t[7] = t[8] = t[9] = t[11] = t[12] = t[13] = t[14] = 0,
                    t[0] = t[5] = t[10] = t[15] = 1;
            }, t.cloneTo = function(t) {
                var e, n, i;
                if ((n = this.elements) !== (i = t.elements))
                    for (e = 0; e < 16; ++e) i[e] = n[e];
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t.getTranslationVector = function(t) {
                var e = this.elements;
                t.x = e[12], t.y = e[13], t.z = e[14];
            }, t.setTranslationVector = function(t) {
                var e = this.elements,
                    n = t;
                e[12] = n.x, e[13] = n.y, e[14] = n.z;
            }, t.getForward = function(t) {
                var e = this.elements;
                t.x = -e[8], t.y = -e[9], t.z = -e[10];
            }, t.setForward = function(t) {
                var e = this.elements;
                e[8] = -t.x, e[9] = -t.y, e[10] = -t.z;
            }, x.createRotationX = function(t, e) {
                var n = e.elements,
                    i = Math.sin(t),
                    r = Math.cos(t);
                n[1] = n[2] = n[3] = n[4] = n[7] = n[8] = n[11] = n[12] = n[13] = n[14] = 0, n[0] = n[15] = 1,
                    n[5] = n[10] = r, n[6] = i, n[9] = -i;
            }, x.createRotationY = function(t, e) {
                var n = e.elements,
                    i = Math.sin(t),
                    r = Math.cos(t);
                n[1] = n[3] = n[4] = n[6] = n[7] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[5] = n[15] = 1,
                    n[0] = n[10] = r, n[2] = -i, n[8] = i;
            }, x.createRotationZ = function(t, e) {
                var n = e.elements,
                    i = Math.sin(t),
                    r = Math.cos(t);
                n[2] = n[3] = n[6] = n[7] = n[8] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[10] = n[15] = 1,
                    n[0] = n[5] = r, n[1] = i, n[4] = -i;
            }, x.createRotationYawPitchRoll = function(t, e, n, i) {
                rt.createFromYawPitchRoll(t, e, n, x._tempQuaternion), x.createRotationQuaternion(x._tempQuaternion, i);
            }, x.createRotationAxis = function(t, e, n) {
                var i = t.x,
                    r = t.y,
                    a = t.z,
                    o = Math.cos(e),
                    s = Math.sin(e),
                    l = i * i,
                    h = r * r,
                    u = a * a,
                    c = i * r,
                    _ = i * a,
                    d = r * a,
                    f = n.elements;
                f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + o * (1 - l),
                    f[1] = c - o * c + s * a, f[2] = _ - o * _ - s * r, f[4] = c - o * c - s * a, f[5] = h + o * (1 - h),
                    f[6] = d - o * d + s * i, f[8] = _ - o * _ + s * r, f[9] = d - o * d - s * i, f[10] = u + o * (1 - u);
            }, x.createRotationQuaternion = function(t, e) {
                var n = e.elements,
                    i = t.x,
                    r = t.y,
                    a = t.z,
                    o = t.w,
                    s = i * i,
                    l = r * r,
                    h = a * a,
                    u = i * r,
                    c = a * o,
                    _ = a * i,
                    d = r * o,
                    f = r * a,
                    m = i * o;
                n[3] = n[7] = n[11] = n[12] = n[13] = n[14] = 0, n[15] = 1, n[0] = 1 - 2 * (l + h),
                    n[1] = 2 * (u + c), n[2] = 2 * (_ - d), n[4] = 2 * (u - c), n[5] = 1 - 2 * (h + s),
                    n[6] = 2 * (f + m), n[8] = 2 * (_ + d), n[9] = 2 * (f - m), n[10] = 1 - 2 * (l + s);
            }, x.createTranslate = function(t, e) {
                var n = e.elements;
                n[4] = n[8] = n[1] = n[9] = n[2] = n[6] = n[3] = n[7] = n[11] = 0, n[0] = n[5] = n[10] = n[15] = 1,
                    n[12] = t.x, n[13] = t.y, n[14] = t.z;
            }, x.createScaling = function(t, e) {
                var n = e.elements;
                n[0] = t.x, n[5] = t.y, n[10] = t.z, n[1] = n[4] = n[8] = n[12] = n[9] = n[13] = n[2] = n[6] = n[14] = n[3] = n[7] = n[11] = 0,
                    n[15] = 1;
            }, x.multiply = function(t, e, n) {
                var i, r, a, o, s, l, h, u;
                if (r = n.elements, a = t.elements, r === (o = e.elements))
                    for (o = new Float32Array(16),
                        i = 0; i < 16; ++i) o[i] = r[i];
                var c = o[0],
                    _ = o[1],
                    d = o[2],
                    f = o[3],
                    m = o[4],
                    p = o[5],
                    T = o[6],
                    E = o[7],
                    v = o[8],
                    g = o[9],
                    S = o[10],
                    y = o[11],
                    x = o[12],
                    D = o[13],
                    I = o[14],
                    R = o[15];
                for (i = 0; i < 4; i++) s = a[i], l = a[i + 4], h = a[i + 8], u = a[i + 12], r[i] = s * c + l * _ + h * d + u * f,
                    r[i + 4] = s * m + l * p + h * T + u * E, r[i + 8] = s * v + l * g + h * S + u * y,
                    r[i + 12] = s * x + l * D + h * I + u * R;
            }, x.multiplyForNative = function(t, e, n) {
                E.instance.matrix4x4Multiply(t.elements, e.elements, n.elements);
            }, x.createFromQuaternion = function(t, e) {
                var n = e.elements,
                    i = t.x,
                    r = t.y,
                    a = t.z,
                    o = t.w,
                    s = i + i,
                    l = r + r,
                    h = a + a,
                    u = i * s,
                    c = r * s,
                    _ = r * l,
                    d = a * s,
                    f = a * l,
                    m = a * h,
                    p = o * s,
                    T = o * l,
                    E = o * h;
                n[0] = 1 - _ - m, n[1] = c + E, n[2] = d - T, n[3] = 0, n[4] = c - E, n[5] = 1 - u - m,
                    n[6] = f + p, n[7] = 0, n[8] = d + T, n[9] = f - p, n[10] = 1 - u - _, n[11] = 0,
                    n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1;
            }, x.createAffineTransformation = function(t, e, n, i) {
                var r = i.elements,
                    a = e.x,
                    o = e.y,
                    s = e.z,
                    l = e.w,
                    h = a + a,
                    u = o + o,
                    c = s + s,
                    _ = a * h,
                    d = a * u,
                    f = a * c,
                    m = o * u,
                    p = o * c,
                    T = s * c,
                    E = l * h,
                    v = l * u,
                    g = l * c,
                    S = n.x,
                    y = n.y,
                    x = n.z;
                r[0] = (1 - (m + T)) * S, r[1] = (d + g) * S, r[2] = (f - v) * S, r[3] = 0, r[4] = (d - g) * y,
                    r[5] = (1 - (_ + T)) * y, r[6] = (p + E) * y, r[7] = 0, r[8] = (f + v) * x, r[9] = (p - E) * x,
                    r[10] = (1 - (_ + m)) * x, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1;
            }, x.createLookAt = function(t, e, n, i) {
                var r = i.elements,
                    a = x._tempVector0,
                    o = x._tempVector1,
                    s = x._tempVector2;
                Ct.subtract(t, e, s), Ct.normalize(s, s), Ct.cross(n, s, a), Ct.normalize(a, a),
                    Ct.cross(s, a, o), i.identity(), r[0] = a.x, r[4] = a.y, r[8] = a.z, r[1] = o.x,
                    r[5] = o.y, r[9] = o.z, r[2] = s.x, r[6] = s.y, r[10] = s.z, r[12] = -Ct.dot(a, t),
                    r[13] = -Ct.dot(o, t), r[14] = -Ct.dot(s, t);
            }, x.createPerspective = function(t, e, n, i, r) {
                var a = 1 / Math.tan(.5 * t),
                    o = n / (a / e),
                    s = n / a;
                x.createPerspectiveOffCenter(-o, o, -s, s, n, i, r);
            }, x.createPerspectiveOffCenter = function(t, e, n, i, r, a, o) {
                var s = o.elements,
                    l = a / (a - r);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0, s[0] = 2 * r / (e - t),
                    s[5] = 2 * r / (i - n), s[8] = (t + e) / (e - t), s[9] = (i + n) / (i - n), s[10] = -l,
                    s[11] = -1, s[14] = -r * l;
            }, x.createOrthoOffCenter = function(t, e, n, i, r, a, o) {
                var s = o.elements,
                    l = 1 / (a - r);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0, s[15] = 1, s[0] = 2 / (e - t),
                    s[5] = 2 / (i - n), s[10] = -l, s[12] = (t + e) / (t - e), s[13] = (i + n) / (n - i),
                    s[14] = -r * l;
            }, x.billboard = function(t, e, n, i, r, a) {
                Ct.subtract(t, e, x._tempVector0);
                var o = Ct.scalarLengthSquared(x._tempVector0);
                $.isZero(o) ? (Ct.scale(r, -1, x._tempVector1), x._tempVector1.cloneTo(x._tempVector0)) : Ct.scale(x._tempVector0, 1 / Math.sqrt(o), x._tempVector0),
                    Ct.cross(i, x._tempVector0, x._tempVector2), Ct.normalize(x._tempVector2, x._tempVector2),
                    Ct.cross(x._tempVector0, x._tempVector2, x._tempVector3);
                var s = x._tempVector2,
                    l = x._tempVector3,
                    h = x._tempVector0,
                    u = t,
                    c = a.elements;
                c[0] = s.x, c[1] = s.y, c[2] = s.z, c[3] = 0, c[4] = l.x, c[5] = l.y, c[6] = l.z,
                    c[7] = 0, c[8] = h.x, c[9] = h.y, c[10] = h.z, c[11] = 0, c[12] = u.x, c[13] = u.y,
                    c[14] = u.z, c[15] = 1;
            }, x.translation = function(t, e) {
                var n = e.elements;
                n[0] = n[5] = n[10] = n[15] = 1, n[12] = t.x, n[13] = t.y, n[14] = t.z;
            }, _(x, ["_tempMatrix4x4", function() {
                return this._tempMatrix4x4 = new x();
            }, "_tempVector0", function() {
                return this._tempVector0 = new Ct();
            }, "_tempVector1", function() {
                return this._tempVector1 = new Ct();
            }, "_tempVector2", function() {
                return this._tempVector2 = new Ct();
            }, "_tempVector3", function() {
                return this._tempVector3 = new Ct();
            }, "_tempQuaternion", function() {
                return this._tempQuaternion = new rt();
            }, "DEFAULT", function() {
                return this.DEFAULT = new x();
            }, "ZERO", function() {
                return this.ZERO = new x(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            }]), x;
        }()),
        Fe = function() {
            function A(t, e) {
                this._nativeDiscreteDynamicsWorld = null, this._nativeCollisionWorld = null, this._nativeDispatcher = null,
                    this._nativeCollisionConfiguration = null, this._nativeBroadphase = null, this._nativeSolverInfo = null,
                    this._nativeDispatchInfo = null, this._nativeClosestRayResultCallback = null, this._nativeAllHitsRayResultCallback = null,
                    this._nativeClosestConvexResultCallback = null, this._nativeAllConvexResultCallback = null,
                    this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60,
                    this._gravity = new Ct(0, -10, 0), this._nativeVector3Zero = new k._physics3D.btVector3(0, 0, 0),
                    this._nativeDefaultQuaternion = new k._physics3D.btQuaternion(0, 0, 0, -1), this._collisionsUtils = new Wt(),
                    this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new tn(),
                    this._characters = [], void 0 === e && (e = 0), this.maxSubSteps = t.maxSubSteps,
                    this.fixedTimeStep = t.fixedTimeStep;
                var n = k._physics3D;
                this._nativeCollisionConfiguration = new n.btDefaultCollisionConfiguration(), this._nativeDispatcher = new n.btCollisionDispatcher(this._nativeCollisionConfiguration),
                    this._nativeBroadphase = new n.btDbvtBroadphase(), this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new n.btGhostPairCallback());
                var i = t.flags;
                if (1 & i) this._nativeCollisionWorld = new n.btCollisionWorld(this._nativeDispatcher, this._nativeBroadphase, this._nativeCollisionConfiguration);
                else {
                    if (2 & i) throw "PhysicsSimulation:SoftBody processing is not yet available";
                    var r = new n.btSequentialImpulseConstraintSolver();
                    this._nativeDiscreteDynamicsWorld = new n.btDiscreteDynamicsWorld(this._nativeDispatcher, this._nativeBroadphase, r, this._nativeCollisionConfiguration),
                        this._nativeCollisionWorld = this._nativeDiscreteDynamicsWorld;
                }
                this._nativeDiscreteDynamicsWorld && (this._nativeSolverInfo = this._nativeDiscreteDynamicsWorld.getSolverInfo(),
                        this._nativeDispatchInfo = this._nativeDiscreteDynamicsWorld.getDispatchInfo()),
                    this._nativeClosestRayResultCallback = new n.ClosestRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                    this._nativeAllHitsRayResultCallback = new n.AllHitsRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                    this._nativeClosestConvexResultCallback = new n.ClosestConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                    this._nativeAllConvexResultCallback = new n.AllConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                    n._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a);
            }
            d(A, "laya.d3.physics.PhysicsSimulation");
            var t = A.prototype;
            return t._simulate = function(t) {
                    this._updatedRigidbodies = 0, this._nativeDiscreteDynamicsWorld ? this._nativeDiscreteDynamicsWorld.stepSimulation(t, this.maxSubSteps, this.fixedTimeStep) : this._nativeCollisionWorld.PerformDiscreteCollisionDetection();
                }, t._destroy = function() {
                    var t = k._physics3D;
                    this._nativeDiscreteDynamicsWorld ? (t.destroy(this._nativeDiscreteDynamicsWorld),
                            this._nativeDiscreteDynamicsWorld = null) : (t.destroy(this._nativeCollisionWorld),
                            this._nativeCollisionWorld = null), t.destroy(this._nativeBroadphase), this._nativeBroadphase = null,
                        t.destroy(this._nativeDispatcher), this._nativeDispatcher = null, t.destroy(this._nativeCollisionConfiguration),
                        this._nativeCollisionConfiguration = null;
                }, t._addPhysicsCollider = function(t, e, n) {
                    this._nativeCollisionWorld.addCollisionObject(t._nativeColliderObject, e, n);
                }, t._removePhysicsCollider = function(t) {
                    this._nativeCollisionWorld.removeCollisionObject(t._nativeColliderObject);
                }, t._addRigidBody = function(t, e, n) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeCollisionWorld.addRigidBody(t._nativeColliderObject, e, n);
                }, t._removeRigidBody = function(t) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeCollisionWorld.removeRigidBody(t._nativeColliderObject);
                }, t._addCharacter = function(t, e, n) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeCollisionWorld.addCollisionObject(t._nativeColliderObject, e, n), this._nativeCollisionWorld.addAction(t._nativeKinematicCharacter);
                }, t._removeCharacter = function(t) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeCollisionWorld.removeCollisionObject(t._nativeColliderObject), this._nativeCollisionWorld.removeAction(t._nativeKinematicCharacter);
                }, t.raycastFromTo = function(t, e, n, i, r) {
                    void 0 === i && (i = Ve.COLLISIONFILTERGROUP_ALLFILTER), void 0 === r && (r = Ve.COLLISIONFILTERGROUP_ALLFILTER);
                    var a = this._nativeClosestRayResultCallback,
                        o = A._nativeTempVector30,
                        s = A._nativeTempVector31;
                    if (o.setValue(-t.x, t.y, t.z), s.setValue(-e.x, e.y, e.z), a.set_m_rayFromWorld(o),
                        a.set_m_rayToWorld(s), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(r),
                        a.set_m_collisionObject(null), a.set_m_closestHitFraction(1), this._nativeCollisionWorld.rayTest(o, s, a),
                        a.hasHit()) {
                        if (n) {
                            n.succeeded = !0, n.collider = Be._physicObjectsMap[a.get_m_collisionObject().getUserIndex()],
                                n.hitFraction = a.get_m_closestHitFraction();
                            var l = a.get_m_hitPointWorld(),
                                h = n.point;
                            h.x = -l.x(), h.y = l.y(), h.z = l.z();
                            var u = a.get_m_hitNormalWorld(),
                                c = n.normal;
                            c.x = -u.x(), c.y = u.y(), c.z = u.z();
                        }
                        return !0;
                    }
                    return n && (n.succeeded = !1), !1;
                }, t.raycastAllFromTo = function(t, e, n, i, r) {
                    void 0 === i && (i = Ve.COLLISIONFILTERGROUP_ALLFILTER), void 0 === r && (r = Ve.COLLISIONFILTERGROUP_ALLFILTER);
                    var a = this._nativeAllHitsRayResultCallback,
                        o = A._nativeTempVector30,
                        s = A._nativeTempVector31;
                    n.length = 0, o.setValue(-t.x, t.y, t.z), s.setValue(-e.x, e.y, e.z), a.set_m_rayFromWorld(o),
                        a.set_m_rayToWorld(s), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(r);
                    var l = a.get_m_collisionObjects(),
                        h = a.get_m_hitPointWorld(),
                        u = a.get_m_hitNormalWorld(),
                        c = a.get_m_hitFractions();
                    l.clear(), h.clear(), u.clear(), c.clear(), this._nativeCollisionWorld.rayTest(o, s, a);
                    var _ = l.size();
                    if (0 < _) {
                        this._collisionsUtils.recoverAllHitResultsPool();
                        for (var d = 0; d < _; d++) {
                            var f = this._collisionsUtils.getHitResult();
                            n.push(f), f.succeeded = !0, f.collider = Be._physicObjectsMap[l.at(d).getUserIndex()],
                                f.hitFraction = c.at(d);
                            var m = h.at(d),
                                p = f.point;
                            p.x = -m.x(), p.y = m.y(), p.z = m.z();
                            var T = u.at(d),
                                E = f.normal;
                            E.x = -T.x(), E.y = T.y(), E.z = T.z();
                        }
                        return !0;
                    }
                    return !1;
                }, t.rayCast = function(t, e, n, i, r) {
                    void 0 === n && (n = 2147483647), void 0 === i && (i = Ve.COLLISIONFILTERGROUP_ALLFILTER),
                        void 0 === r && (r = Ve.COLLISIONFILTERGROUP_ALLFILTER);
                    var a = t.origin,
                        o = A._tempVector30;
                    return Ct.normalize(t.direction, o), Ct.scale(o, n, o), Ct.add(a, o, o), this.raycastFromTo(a, o, e, i, r);
                }, t.rayCastAll = function(t, e, n, i, r) {
                    void 0 === n && (n = 2147483647), void 0 === i && (i = Ve.COLLISIONFILTERGROUP_ALLFILTER),
                        void 0 === r && (r = Ve.COLLISIONFILTERGROUP_ALLFILTER);
                    var a = t.origin,
                        o = A._tempVector30;
                    return Ct.normalize(t.direction, o), Ct.scale(o, n, o), Ct.add(a, o, o), this.raycastAllFromTo(a, o, e, i, r);
                }, t.shapeCast = function(t, e, n, i, r, a, o, s, l) {
                    void 0 === o && (o = Ve.COLLISIONFILTERGROUP_ALLFILTER), void 0 === s && (s = Ve.COLLISIONFILTERGROUP_ALLFILTER),
                        void 0 === l && (l = 0);
                    var h = this._nativeClosestConvexResultCallback,
                        u = A._nativeTempVector30,
                        c = A._nativeTempVector31,
                        _ = A._nativeTempQuaternion0,
                        d = A._nativeTempQuaternion1,
                        f = A._nativeTempTransform0,
                        m = A._nativeTempTransform1,
                        p = t._nativeShape;
                    if (u.setValue(-e.x, e.y, e.z), c.setValue(-n.x, n.y, n.z), h.set_m_collisionFilterGroup(o),
                        h.set_m_collisionFilterMask(s), f.setOrigin(u), m.setOrigin(c), r ? (_.setValue(-r.x, r.y, r.z, -r.w),
                            f.setRotation(_)) : f.setRotation(this._nativeDefaultQuaternion), a ? (d.setValue(-a.x, a.y, a.z, -a.w),
                            m.setRotation(d)) : m.setRotation(this._nativeDefaultQuaternion), h.set_m_hitCollisionObject(null),
                        h.set_m_closestHitFraction(1), this._nativeCollisionWorld.convexSweepTest(p, f, m, h, l),
                        h.hasHit()) {
                        if (i) {
                            i.succeeded = !0, i.collider = Be._physicObjectsMap[h.get_m_hitCollisionObject().getUserIndex()],
                                i.hitFraction = h.get_m_closestHitFraction();
                            var T = h.get_m_hitPointWorld(),
                                E = h.get_m_hitNormalWorld(),
                                v = i.point,
                                g = i.normal;
                            v.x = -T.x(), v.y = T.y(), v.z = T.z(), g.x = -E.x(), g.y = E.y(), g.z = E.z();
                        }
                        return !0;
                    }
                    return i && (i.succeeded = !1), !1;
                }, t.shapeCastAll = function(t, e, n, i, r, a, o, s, l) {
                    void 0 === o && (o = Ve.COLLISIONFILTERGROUP_ALLFILTER), void 0 === s && (s = Ve.COLLISIONFILTERGROUP_ALLFILTER),
                        void 0 === l && (l = 0);
                    var h = this._nativeAllConvexResultCallback,
                        u = A._nativeTempVector30,
                        c = A._nativeTempVector31,
                        _ = A._nativeTempQuaternion0,
                        d = A._nativeTempQuaternion1,
                        f = A._nativeTempTransform0,
                        m = A._nativeTempTransform1,
                        p = t._nativeShape;
                    i.length = 0, u.setValue(-e.x, e.y, e.z), c.setValue(-n.x, n.y, n.z), h.set_m_collisionFilterGroup(o),
                        h.set_m_collisionFilterMask(s), f.setOrigin(u), m.setOrigin(c), r ? (_.setValue(-r.x, r.y, r.z, -r.w),
                            f.setRotation(_)) : f.setRotation(this._nativeDefaultQuaternion), a ? (d.setValue(-a.x, a.y, a.z, -a.w),
                            m.setRotation(d)) : m.setRotation(this._nativeDefaultQuaternion);
                    var T = h.get_m_collisionObjects();
                    T.clear(), this._nativeCollisionWorld.convexSweepTest(p, f, m, h, l);
                    var E = T.size();
                    if (0 < E) {
                        for (var v = h.get_m_hitPointWorld(), g = h.get_m_hitNormalWorld(), S = h.get_m_hitFractions(), y = 0; y < E; y++) {
                            var x = this._collisionsUtils.getHitResult();
                            i.push(x), x.succeeded = !0, x.collider = Be._physicObjectsMap[T.at(y).getUserIndex()],
                                x.hitFraction = S.at(y);
                            var D = v.at(y),
                                I = x.point;
                            I.x = -D.x(), I.y = D.y(), I.z = D.z();
                            var R = g.at(y),
                                M = x.normal;
                            M.x = -R.x(), M.y = R.y(), M.z = R.z();
                        }
                        return !0;
                    }
                    return !1;
                }, t.addConstraint = function(t, e) {
                    if (void 0 === e && (e = !1), !this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeDiscreteDynamicsWorld.addConstraint(t._nativeConstraint, e), t._simulation = this;
                }, t.removeConstraint = function(t) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeDiscreteDynamicsWorld.removeConstraint(t._nativeConstraint);
                }, t._updatePhysicsTransformFromRender = function() {
                    for (var t = this._physicsUpdateList.elements, e = 0, n = this._physicsUpdateList.length; e < n; e++) {
                        var i = t[e];
                        i._derivePhysicsTransformation(!1), i._inPhysicUpdateListIndex = -1;
                    }
                    this._physicsUpdateList.length = 0;
                }, t._updateCharacters = function() {
                    for (var t = 0, e = this._characters.length; t < e; t++) {
                        var n = this._characters[t];
                        n._updateTransformComponent(n._nativeColliderObject.getWorldTransform());
                    }
                }, t._updateCollisions = function() {
                    this._collisionsUtils.recoverAllContactPointsPool();
                    var t = this._currentFrameCollisions;
                    this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0,
                        this._previousFrameCollisions = t;
                    for (var e = M.loopCount, n = this._nativeDispatcher.getNumManifolds(), i = 0; i < n; i++) {
                        var r = this._nativeDispatcher.getManifoldByIndexInternal(i),
                            a = Be._physicObjectsMap[r.getBody0().getUserIndex()],
                            o = Be._physicObjectsMap[r.getBody1().getUserIndex()],
                            s = null,
                            l = !1,
                            h = null;
                        if ((a.isTrigger || o.isTrigger) && (a.owner._needProcessTriggers || o.owner._needProcessTriggers))
                            for (var u = r.getNumContacts(), c = 0; c < u; c++) {
                                var _ = r.getContactPoint(c),
                                    d = _.getDistance();
                                if (d <= 0) {
                                    h = (s = this._collisionsUtils.getCollision(a, o)).contacts, (l = s._updateFrame !== e) && (s._isTrigger = !0,
                                        h.length = 0);
                                    break;
                                }
                            } else if ((a.owner._needProcessCollisions || o.owner._needProcessCollisions) && (a._enableProcessCollisions || o._enableProcessCollisions))
                                for (u = r.getNumContacts(),
                                    c = 0; c < u; c++)
                                    if ((d = (_ = r.getContactPoint(c)).getDistance()) <= 0) {
                                        var f = this._collisionsUtils.getContactPoints();
                                        f.colliderA = a, f.colliderB = o, f.distance = d;
                                        var m = _.get_m_normalWorldOnB(),
                                            p = f.normal;
                                        p.x = -m.x(), p.y = m.y(), p.z = m.z();
                                        var T = _.get_m_positionWorldOnA(),
                                            E = f.positionOnA;
                                        E.x = -T.x(), E.y = T.y(), E.z = T.z();
                                        var v = _.get_m_positionWorldOnB(),
                                            g = f.positionOnB;
                                        g.x = -v.x(), g.y = v.y(), g.z = v.z(), s || (h = (s = this._collisionsUtils.getCollision(a, o)).contacts,
                                            (l = s._updateFrame !== e) && (s._isTrigger = !1, h.length = 0)), h.push(f);
                                    }
                        s && l && (this._currentFrameCollisions.push(s), s._setUpdateFrame(e));
                    }
                }, t._eventScripts = function() {
                    for (var t = M.loopCount, e = 0, n = this._currentFrameCollisions.length; e < n; e++) {
                        var i = this._currentFrameCollisions[e],
                            r = i._colliderA,
                            a = i._colliderB;
                        if (!r.destroyed && !a.destroyed)
                            if (t - i._lastUpdateFrame == 1) {
                                var o = r.owner,
                                    s = o._scripts;
                                if (s)
                                    if (i._isTrigger) {
                                        if (o._needProcessTriggers)
                                            for (var l = 0, h = s.length; l < h; l++) s[l].onTriggerStay(a);
                                    } else if (o._needProcessCollisions)
                                    for (l = 0, h = s.length; l < h; l++) i.other = a,
                                        s[l].onCollisionStay(i);
                                var u = a.owner,
                                    c = u._scripts;
                                if (c)
                                    if (i._isTrigger) {
                                        if (u._needProcessTriggers)
                                            for (l = 0, h = c.length; l < h; l++) c[l].onTriggerStay(r);
                                    } else if (u._needProcessCollisions)
                                    for (l = 0, h = c.length; l < h; l++) i.other = r,
                                        c[l].onCollisionStay(i);
                            } else {
                                if (s = (o = r.owner)._scripts)
                                    if (i._isTrigger) {
                                        if (o._needProcessTriggers)
                                            for (l = 0, h = s.length; l < h; l++) s[l].onTriggerEnter(a);
                                    } else if (o._needProcessCollisions)
                                    for (l = 0, h = s.length; l < h; l++) i.other = a,
                                        s[l].onCollisionEnter(i);
                                if (c = (u = a.owner)._scripts)
                                    if (i._isTrigger) {
                                        if (u._needProcessTriggers)
                                            for (l = 0, h = c.length; l < h; l++) c[l].onTriggerEnter(r);
                                    } else if (u._needProcessCollisions)
                                    for (l = 0, h = c.length; l < h; l++) i.other = r,
                                        c[l].onCollisionEnter(i);
                            }
                    }
                    for (e = 0, n = this._previousFrameCollisions.length; e < n; e++) {
                        var _ = this._previousFrameCollisions[e],
                            d = _._colliderA,
                            f = _._colliderB;
                        if (!d.destroyed && !f.destroyed && t - _._updateFrame == 1) {
                            if (this._collisionsUtils.recoverCollision(_), s = (o = d.owner)._scripts)
                                if (_._isTrigger) {
                                    if (o._needProcessTriggers)
                                        for (l = 0, h = s.length; l < h; l++) s[l].onTriggerExit(f);
                                } else if (o._needProcessCollisions)
                                for (l = 0, h = s.length; l < h; l++) _.other = f,
                                    s[l].onCollisionExit(_);
                            if (c = (u = f.owner)._scripts)
                                if (_._isTrigger) {
                                    if (u._needProcessTriggers)
                                        for (l = 0, h = c.length; l < h; l++) c[l].onTriggerExit(d);
                                } else if (u._needProcessCollisions)
                                for (l = 0, h = c.length; l < h; l++) _.other = d,
                                    c[l].onCollisionExit(_);
                        }
                    }
                }, t.clearForces = function() {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeDiscreteDynamicsWorld.clearForces();
                }, u(0, t, "gravity", function() {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    return this._gravity;
                }, function(t) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._gravity = t;
                    var e = A._nativeTempVector30;
                    e.setValue(-t.x, t.y, t.z), this._nativeDiscreteDynamicsWorld.setGravity(e);
                }), u(0, t, "continuousCollisionDetection", function() {
                    return this._nativeDispatchInfo.get_m_useContinuous();
                }, function(t) {
                    this._nativeDispatchInfo.set_m_useContinuous(t);
                }), u(0, t, "speculativeContactRestitution", function() {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                    return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution();
                }, function(t) {
                    if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                    this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(t);
                }), A.createConstraint = function() {}, A.PHYSICSENGINEFLAGS_NONE = 0, A.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1,
                A.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2, A.PHYSICSENGINEFLAGS_MULTITHREADED = 4,
                A.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, A.SOLVERMODE_RANDMIZE_ORDER = 1,
                A.SOLVERMODE_FRICTION_SEPARATE = 2, A.SOLVERMODE_USE_WARMSTARTING = 4, A.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16,
                A.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, A.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64,
                A.SOLVERMODE_CACHE_FRIENDLY = 128, A.SOLVERMODE_SIMD = 256, A.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
                A.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, A.disableSimulation = !1,
                _(A, ["_nativeTempVector30", function() {
                    return this._nativeTempVector30 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeTempVector31", function() {
                    return this._nativeTempVector31 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeTempQuaternion0", function() {
                    return this._nativeTempQuaternion0 = new k._physics3D.btQuaternion(0, 0, 0, 1);
                }, "_nativeTempQuaternion1", function() {
                    return this._nativeTempQuaternion1 = new k._physics3D.btQuaternion(0, 0, 0, 1);
                }, "_nativeTempTransform0", function() {
                    return this._nativeTempTransform0 = new k._physics3D.btTransform();
                }, "_nativeTempTransform1", function() {
                    return this._nativeTempTransform1 = new k._physics3D.btTransform();
                }, "_tempVector30", function() {
                    return this._tempVector30 = new Ct();
                }]), A;
        }(),
        Be = function(e) {
            function f(t, e) {
                this._restitution = 0, this._friction = .5, this._rollingFriction = 0, this._ccdMotionThreshold = 0,
                    this._ccdSweptSphereRadius = 0, this._colliderShape = null, this._transformFlag = 2147483647,
                    this._enableProcessCollisions = !0, this._inPhysicUpdateListIndex = -1, this.canScaleShape = !0,
                    f.__super.call(this), this._collisionGroup = 1, this._canCollideWith = Ve.COLLISIONFILTERGROUP_ALLFILTER,
                    this._collisionGroup = t, this._canCollideWith = e, f._physicObjectsMap[this.id] = this;
            }
            d(f, "laya.d3.physics.PhysicsComponent", e);
            var t = f.prototype;
            return t._isValid = function() {
                    return this._simulation && this._colliderShape && this._enabled;
                }, t._parse = function(t) {
                    null != t.collisionGroup && (this.collisionGroup = t.collisionGroup), null != t.canCollideWith && (this.canCollideWith = t.canCollideWith),
                        null != t.ccdMotionThreshold && (this.ccdMotionThreshold = t.ccdMotionThreshold),
                        null != t.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = t.ccdSweptSphereRadius);
                }, t._parseShape = function(t) {
                    var e = t.length;
                    if (1 === e) {
                        var n = H._creatShape(t[0]);
                        this.colliderShape = n;
                    } else {
                        for (var i = new an(), r = 0; r < e; r++) n = H._creatShape(t[r]), i.addChildShape(n);
                        this.colliderShape = i;
                    }
                }, t._onScaleChange = function(t) {
                    this._colliderShape._setScale(t);
                }, t._setTransformFlag = function(t, e) {
                    e ? this._transformFlag |= t : this._transformFlag &= ~t;
                }, t._getTransformFlag = function(t) {
                    return 0 != (this._transformFlag & t);
                }, t._addToSimulation = function() {}, t._removeFromSimulation = function() {},
                t._derivePhysicsTransformation = function(t) {
                    this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(), t);
                }, t._innerDerivePhysicsTransformation = function(t, e) {
                    var n = this.owner._transform,
                        i = n.rotation;
                    if (e || this._getTransformFlag(8)) {
                        var r = this._colliderShape.localOffset,
                            a = n.position,
                            o = f._nativeVector30;
                        if (0 !== r.x || 0 !== r.y || 0 !== r.z) {
                            var s = f._tempVector30;
                            f.physicVector3TransformQuat(r, i.x, i.y, i.z, i.w, s), Ct.add(a, s, s), o.setValue(-s.x, s.y, s.z);
                        } else o.setValue(-a.x, a.y, a.z);
                        t.setOrigin(o), this._setTransformFlag(8, !1);
                    }
                    if (e || this._getTransformFlag(16)) {
                        var l = this._colliderShape.localRotation,
                            h = f._nativeQuaternion0;
                        if (0 !== l.x || 0 !== l.y || 0 !== l.z || 1 !== l.w) {
                            var u = f._tempQuaternion0;
                            f.physicQuaternionMultiply(i.x, i.y, i.z, i.w, l, u), h.setValue(-u.x, u.y, u.z, -u.w);
                        } else h.setValue(-i.x, i.y, i.z, -i.w);
                        t.setRotation(h), this._setTransformFlag(16, !1);
                    }
                    (e || this._getTransformFlag(32)) && (this._onScaleChange(n.scale), this._setTransformFlag(32, !1));
                }, t._updateTransformComponent = function(t) {
                    var e = this._colliderShape.localOffset,
                        n = this._colliderShape.localRotation,
                        i = this.owner._transform,
                        r = i.position,
                        a = i.rotation,
                        o = t.getOrigin(),
                        s = t.getRotation(),
                        l = -s.x(),
                        h = s.y(),
                        u = s.z(),
                        c = -s.w();
                    if (0 !== e.x || 0 !== e.y || 0 !== e.z) {
                        var _ = f._tempVector30;
                        f.physicVector3TransformQuat(e, l, h, u, c, _), r.x = -o.x() - _.x, r.y = o.y() - _.y,
                            r.z = o.z() - _.z;
                    } else r.x = -o.x(), r.y = o.y(), r.z = o.z();
                    if (i.position = r, 0 !== n.x || 0 !== n.y || 0 !== n.z || 1 !== n.w) {
                        var d = f._tempQuaternion0;
                        n.invert(d), f.physicQuaternionMultiply(l, h, u, c, d, a);
                    } else a.x = l, a.y = h, a.z = u, a.w = c;
                    i.rotation = a;
                }, t._onEnable = function() {
                    this._simulation = this.owner._scene.physicsSimulation, this._nativeColliderObject.setContactProcessingThreshold(1e30),
                        this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0),
                            this._addToSimulation());
                }, t._onDisable = function() {
                    this._colliderShape && this._enabled && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)),
                        this._simulation = null;
                }, t._onShapeChange = function(t) {
                    var e = this._nativeColliderObject,
                        n = e.getCollisionFlags();
                    t.needsCustomCollisionCallback ? 0 == (8 & n) && e.setCollisionFlags(8 | n) : 0 < (8 & n) && e.setCollisionFlags(8 ^ n);
                }, t._onAdded = function() {
                    this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction,
                        this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold,
                        this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on("transformchanged", this, this._onTransformChanged);
                }, t._onDestroy = function() {
                    var t = k._physics3D;
                    delete f._physicObjectsMap[this.id], t.destroy(this._nativeColliderObject), this._colliderShape.destroy(),
                        e.prototype._onDestroy.call(this), this._nativeColliderObject = null, this._colliderShape = null,
                        this._simulation = null, this.owner.transform.off("transformchanged", this, this._onTransformChanged);
                }, t._onTransformChanged = function(t) {
                    f._addUpdateList && (t &= 56) && (this._transformFlag |= t, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
                }, t._cloneTo = function(t) {
                    var e = t;
                    e.restitution = this._restitution, e.friction = this._friction, e.rollingFriction = this._rollingFriction,
                        e.ccdMotionThreshold = this._ccdMotionThreshold, e.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                        e.collisionGroup = this._collisionGroup, e.canCollideWith = this._canCollideWith,
                        e.canScaleShape = this.canScaleShape, this._colliderShape && (e.colliderShape = this._colliderShape.clone());
                }, u(0, t, "isActive", function() {
                    return !!this._nativeColliderObject && this._nativeColliderObject.isActive();
                }), u(0, t, "restitution", function() {
                    return this._restitution;
                }, function(t) {
                    this._restitution = t, this._nativeColliderObject && this._nativeColliderObject.setRestitution(t);
                }), u(0, t, "friction", function() {
                    return this._friction;
                }, function(t) {
                    this._friction = t, this._nativeColliderObject && this._nativeColliderObject.setFriction(t);
                }), u(0, t, "rollingFriction", function() {
                    return this._nativeColliderObject.getRollingFriction();
                }, function(t) {
                    this._rollingFriction = t, this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(t);
                }), u(0, t, "ccdMotionThreshold", function() {
                    return this._ccdMotionThreshold;
                }, function(t) {
                    this._ccdMotionThreshold = t, this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(t);
                }), u(0, t, "ccdSweptSphereRadius", function() {
                    return this._ccdSweptSphereRadius;
                }, function(t) {
                    this._ccdSweptSphereRadius = t, this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(t);
                }), u(0, t, "collisionGroup", function() {
                    return this._collisionGroup;
                }, function(t) {
                    this._collisionGroup !== t && (this._collisionGroup = t, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                        this._addToSimulation()));
                }), u(0, t, "simulation", function() {
                    return this._simulation;
                }), u(0, t, "colliderShape", function() {
                    return this._colliderShape;
                }, function(t) {
                    var e = this._colliderShape;
                    if (e && (e._attatched = !1, e._attatchedCollisionObject = null), this._colliderShape = t) {
                        if (t._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                        if (t._attatched = !0, (t._attatchedCollisionObject = this)._nativeColliderObject) {
                            this._nativeColliderObject.setCollisionShape(t._nativeShape);
                            var n = this._simulation && this._enabled;
                            n && e && this._removeFromSimulation(), this._onShapeChange(t), n && (this._derivePhysicsTransformation(!0),
                                this._addToSimulation());
                        }
                    } else this._simulation && this._enabled && e && this._removeFromSimulation();
                }), u(0, t, "enabled", e.prototype._$get_enabled, function(t) {
                    this._simulation && this._colliderShape && (t ? (this._derivePhysicsTransformation(!0),
                        this._addToSimulation()) : this._removeFromSimulation()), m.superSet(r, this, "enabled", t);
                }), u(0, t, "canCollideWith", function() {
                    return this._canCollideWith;
                }, function(t) {
                    this._canCollideWith !== t && (this._canCollideWith = t, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                        this._addToSimulation()));
                }), f._createAffineTransformationArray = function(t, e, n, i, r, a, o, s, l) {
                    var h = i + i,
                        u = r + r,
                        c = a + a,
                        _ = i * h,
                        d = i * u,
                        f = i * c,
                        m = r * u,
                        p = r * c,
                        T = a * c,
                        E = o * h,
                        v = o * u,
                        g = o * c,
                        S = s[0],
                        y = s[1],
                        x = s[2];
                    l[0] = (1 - (m + T)) * S, l[1] = (d + g) * S, l[2] = (f - v) * S, l[3] = 0, l[4] = (d - g) * y,
                        l[5] = (1 - (_ + T)) * y, l[6] = (p + E) * y, l[7] = 0, l[8] = (f + v) * x, l[9] = (p - E) * x,
                        l[10] = (1 - (_ + m)) * x, l[11] = 0, l[12] = t, l[13] = e, l[14] = n, l[15] = 1;
                }, f.physicVector3TransformQuat = function(t, e, n, i, r, a) {
                    var o = t.x,
                        s = t.y,
                        l = t.z,
                        h = r * o + n * l - i * s,
                        u = r * s + i * o - e * l,
                        c = r * l + e * s - n * o,
                        _ = -e * o - n * s - i * l;
                    a.x = h * r + _ * -e + u * -i - c * -n, a.y = u * r + _ * -n + c * -e - h * -i,
                        a.z = c * r + _ * -i + h * -n - u * -e;
                }, f.physicQuaternionMultiply = function(t, e, n, i, r, a) {
                    var o = r.x,
                        s = r.y,
                        l = r.z,
                        h = r.w,
                        u = e * l - n * s,
                        c = n * o - t * l,
                        _ = t * s - e * o,
                        d = t * o + e * s + n * l;
                    a.x = t * h + o * i + u, a.y = e * h + s * i + c, a.z = n * h + l * i + _, a.w = i * h - d;
                }, f.ACTIVATIONSTATE_ACTIVE_TAG = 1, f.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, f.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3,
                f.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, f.ACTIVATIONSTATE_DISABLE_SIMULATION = 5,
                f.COLLISIONFLAGS_STATIC_OBJECT = 1, f.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, f.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4,
                f.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, f.COLLISIONFLAGS_CHARACTER_OBJECT = 16,
                f.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, f.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64,
                f._physicObjectsMap = {}, f._addUpdateList = !0, _(f, ["_tempVector30", function() {
                    return this._tempVector30 = new Ct();
                }, "_tempQuaternion0", function() {
                    return this._tempQuaternion0 = new rt();
                }, "_tempQuaternion1", function() {
                    return this._tempQuaternion1 = new rt();
                }, "_tempMatrix4x40", function() {
                    return this._tempMatrix4x40 = new be();
                }, "_nativeVector30", function() {
                    return this._nativeVector30 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeQuaternion0", function() {
                    return this._nativeQuaternion0 = new k._physics3D.btQuaternion(0, 0, 0, 1);
                }]), f;
        }(r),
        Ue = function(t) {
            function a(t) {
                if (this._indexInList = -1, this._indexInCastShadowList = -1, this._visible = !0,
                    this._indexInOctreeMotionList = -1, this._updateMark = -1, this._updateRenderType = -1,
                    this._isPartOfStaticBatch = !1, this._staticBatch = null, a.__super.call(this),
                    this._id = ++a._uniqueIDCounter, this._indexInCastShadowList = -1, this._boundingBox = new we(new Ct(), new Ct()),
                    this._boundingBoxCenter = new Ct(), this._boundingSphere = new Tt(new Ct(), 0),
                    b.supportWebGLPlusCulling) {
                    var e = Ce._cullingBufferLength;
                    this._cullingBufferIndex = e;
                    var n = Ce._cullingBuffer,
                        i = e + 5;
                    if (i >= n.length) {
                        var r = n;
                        (n = Ce._cullingBuffer = new Float32Array(n.length + 4096)).set(r, 0);
                    }
                    n[e] = 1, Ce._cullingBufferLength = i;
                }
                this._boundingSphereNeedChange = !0, this._boundingBoxNeedChange = !0, this._boundingBoxCenterNeedChange = !0,
                    this._sharedMaterials = [], this._renderElements = [], this._owner = t, this._enable = !0,
                    this._materialsInstance = [], this._shaderValues = new at(null), this._defineDatas = new Ft(),
                    this.lightmapIndex = -1, this._castShadow = !1, this.receiveShadow = !1, this.sortingFudge = 0,
                    t && this._owner.transform.on("transformchanged", this, this._onWorldMatNeedChange);
            }
            d(a, "laya.d3.core.render.BaseRender", h);
            var e = a.prototype;
            return m.imps(e, {
                    "laya.resource.ISingletonElement": !0,
                    "laya.d3.core.scene.IOctreeObject": !0
                }), e._getOctreeNode = function() {
                    return this._octreeNode;
                }, e._setOctreeNode = function(t) {
                    this._octreeNode = t;
                }, e._getIndexInMotionList = function() {
                    return this._indexInOctreeMotionList;
                }, e._setIndexInMotionList = function(t) {
                    this._indexInOctreeMotionList = t;
                }, e._changeMaterialReference = function(t, e) {
                    t && t._removeReference(), e._addReference();
                }, e._getInstanceMaterial = function(t, e) {
                    var n = new t.constructor();
                    return t.cloneTo(n), n.name = n.name + "(Instance)", this._materialsInstance[e] = !0,
                        this._changeMaterialReference(this._sharedMaterials[e], n), this._sharedMaterials[e] = n;
                }, e._applyLightMapParams = function() {
                    if (this._scene && 0 <= this._lightmapIndex) {
                        var t = this._scene.getlightmaps();
                        this._lightmapIndex < t.length ? (this._defineDatas.add(Hn.SAHDERDEFINE_LIGHTMAP),
                            this._shaderValues.setTexture(Hn.LIGHTMAP, t[this._lightmapIndex])) : this._defineDatas.remove(Hn.SAHDERDEFINE_LIGHTMAP);
                    } else this._defineDatas.remove(Hn.SAHDERDEFINE_LIGHTMAP);
                }, e._onWorldMatNeedChange = function(t) {
                    this._boundingSphereNeedChange = !0, this._boundingBoxNeedChange = !0, this._boundingBoxCenterNeedChange = !0,
                        this._octreeNode && (t &= 56) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
                }, e._calculateBoundingSphere = function() {
                    throw "BaseRender: must override it.";
                }, e._calculateBoundingBox = function() {
                    throw "BaseRender: must override it.";
                }, e._getIndexInList = function() {
                    return this._indexInList;
                }, e._setIndexInList = function(t) {
                    this._indexInList = t;
                }, e._setBelongScene = function(t) {
                    this._scene !== t && (this._scene = t, this._applyLightMapParams());
                }, e._needRender = function(t) {
                    return !0;
                }, e._renderUpdate = function(t, e) {}, e._renderUpdateWithCamera = function(t, e) {},
                e._revertBatchRenderUpdate = function(t) {}, e._destroy = function() {
                    -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this),
                        this.offAll();
                    var t = 0,
                        e = 0;
                    for (t = 0, e = this._renderElements.length; t < e; t++) this._renderElements[t].destroy();
                    for (t = 0, e = this._sharedMaterials.length; t < e; t++) this._sharedMaterials[t].destroyed || this._sharedMaterials[t]._removeReference();
                    this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._boundingBox = null,
                        this._boundingBoxCenter = null, this._boundingSphere = null, this._lightmapScaleOffset = null;
                }, u(0, e, "boundingSphere", function() {
                    return this._boundingSphereNeedChange && (this._calculateBoundingSphere(), this._boundingSphereNeedChange = !1),
                        this._boundingSphere;
                }), u(0, e, "id", function() {
                    return this._id;
                }), u(0, e, "material", function() {
                    var t = this._sharedMaterials[0];
                    if (t && !this._materialsInstance[0]) {
                        var e = this._getInstanceMaterial(t, 0),
                            n = this._renderElements[0];
                        n && (n.material = e);
                    }
                    return this._sharedMaterials[0];
                }, function(t) {
                    this.sharedMaterial = t;
                }), u(0, e, "isPartOfStaticBatch", function() {
                    return this._isPartOfStaticBatch;
                }), u(0, e, "sharedMaterial", function() {
                    return this._sharedMaterials[0];
                }, function(t) {
                    var e = this._sharedMaterials[0];
                    if (e !== t) {
                        this._sharedMaterials[0] = t, this._materialsInstance[0] = !1, this._changeMaterialReference(e, t);
                        var n = this._renderElements[0];
                        n && (n.material = t);
                    }
                }), u(0, e, "lightmapIndex", function() {
                    return this._lightmapIndex;
                }, function(t) {
                    this._lightmapIndex !== t && (this._lightmapIndex = t, this._applyLightMapParams());
                }), u(0, e, "lightmapScaleOffset", function() {
                    return this._lightmapScaleOffset;
                }, function(t) {
                    this._lightmapScaleOffset = t, this._shaderValues.setVector(Hn.LIGHTMAPSCALEOFFSET, t),
                        this._defineDatas.add(Hn.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                }), u(0, e, "castShadow", function() {
                    return this._castShadow;
                }, function(t) {
                    this._castShadow !== t && (this._owner.activeInHierarchy && (t ? this._scene._addShadowCastRenderObject(this) : this._scene._removeShadowCastRenderObject(this)),
                        this._castShadow = t);
                }), u(0, e, "enable", function() {
                    return this._enable;
                }, function(t) {
                    this._enable = !!t;
                }), u(0, e, "materials", function() {
                    for (var t = 0, e = this._sharedMaterials.length; t < e; t++)
                        if (!this._materialsInstance[t]) {
                            var n = this._getInstanceMaterial(this._sharedMaterials[t], t),
                                i = this._renderElements[t];
                            i && (i.material = n);
                        }
                    return this._sharedMaterials.slice();
                }, function(t) {
                    this.sharedMaterials = t;
                }), u(0, e, "sharedMaterials", function() {
                    return this._sharedMaterials.slice();
                }, function(t) {
                    if (!t) throw new Error("BaseRender: shadredMaterials value can't be null.");
                    var e = t.length;
                    this._materialsInstance.length = e;
                    for (var n = 0; n < e; n++) {
                        var i = this._sharedMaterials[n];
                        if (i !== t[n]) {
                            this._materialsInstance[n] = !1, this._changeMaterialReference(i, t[n]);
                            var r = this._renderElements[n];
                            r && (r.material = t[n]);
                        }
                    }
                    this._sharedMaterials = t;
                }), u(0, e, "boundingBox", function() {
                    return this._boundingBoxNeedChange && (this._calculateBoundingBox(), this._boundingBoxNeedChange = !1),
                        this._boundingBox;
                }), u(0, e, "boundingBoxCenter", function() {
                    if (this._boundingBoxCenterNeedChange) {
                        var t = this.boundingBox;
                        Ct.add(t.min, t.max, this._boundingBoxCenter), Ct.scale(this._boundingBoxCenter, .5, this._boundingBoxCenter),
                            this._boundingBoxCenterNeedChange = !1;
                    }
                    return this._boundingBoxCenter;
                }), u(0, e, "receiveShadow", function() {
                    return this._receiveShadow;
                }, function(t) {
                    this._receiveShadow !== t && ((this._receiveShadow = t) ? this._defineDatas.add(Hn.SHADERDEFINE_RECEIVE_SHADOW) : this._defineDatas.remove(Hn.SHADERDEFINE_RECEIVE_SHADOW));
                }), a._uniqueIDCounter = 0, _(a, ["_tempBoundBoxCorners", function() {
                    return this._tempBoundBoxCorners = [new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct(), new Ct()];
                }]), a;
        }(),
        ze = (function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.component.Script3D", r);
            var n = e.prototype;
            n._checkProcessTriggers = function() {
                    var t = laya.d3.component.Script3D.prototype;
                    return this.onTriggerEnter !== t.onTriggerEnter || (this.onTriggerStay !== t.onTriggerStay || this.onTriggerExit !== t.onTriggerExit);
                }, n._checkProcessCollisions = function() {
                    var t = laya.d3.component.Script3D.prototype;
                    return this.onCollisionEnter !== t.onCollisionEnter || (this.onCollisionStay !== t.onCollisionStay || this.onCollisionExit !== t.onCollisionExit);
                }, n._onAwake = function() {
                    this.onAwake(), this.onStart !== laya.d3.component.Script3D.prototype.onStart && m.startTimer.callLater(this, this.onStart);
                }, n._onEnable = function() {
                    this.owner._scene._scriptPool.add(this);
                    var t = laya.d3.component.Script3D.prototype;
                    this.onKeyDown !== t.onKeyDown && m.stage.on("keydown", this, this.onKeyDown), this.onKeyPress !== t.onKeyPress && m.stage.on("keypress", this, this.onKeyUp),
                        this.onKeyUp !== t.onKeyUp && m.stage.on("keyup", this, this.onKeyUp);
                }, n._onDisable = function() {
                    this.owner._scene._scriptPool.remove(this), this.owner.offAllCaller(this), m.stage.offAllCaller(this);
                }, n._isScript = function() {
                    return !0;
                }, n._onAdded = function() {
                    var t = this.owner,
                        e = t._scripts;
                    e || (t._scripts = e = []), e.push(this), t._needProcessCollisions || (t._needProcessCollisions = this._checkProcessCollisions()),
                        t._needProcessTriggers || (t._needProcessTriggers = this._checkProcessTriggers());
                }, n._onDestroy = function() {
                    var t = this.owner._scripts;
                    t.splice(t.indexOf(this), 1);
                    var e = this.owner;
                    e._needProcessTriggers = !1;
                    for (var n = 0, i = t.length; n < i; n++)
                        if (t[n]._checkProcessTriggers()) {
                            e._needProcessTriggers = !0;
                            break;
                        }
                    for (e._needProcessCollisions = !1, n = 0, i = t.length; n < i; n++)
                        if (t[n]._checkProcessCollisions()) {
                            e._needProcessCollisions = !0;
                            break;
                        }
                    this.onDestroy();
                }, n.onAwake = function() {}, n.onEnable = function() {}, n.onStart = function() {},
                n.onTriggerEnter = function(t) {}, n.onTriggerStay = function(t) {}, n.onTriggerExit = function(t) {},
                n.onCollisionEnter = function(t) {}, n.onCollisionStay = function(t) {}, n.onCollisionExit = function(t) {},
                n.onMouseDown = function() {}, n.onMouseDrag = function() {}, n.onMouseClick = function() {},
                n.onMouseUp = function() {}, n.onMouseEnter = function() {}, n.onMouseOver = function() {},
                n.onMouseOut = function() {}, n.onKeyDown = function(t) {}, n.onKeyPress = function(t) {},
                n.onKeyUp = function(t) {}, n.onUpdate = function() {}, n.onLateUpdate = function() {},
                n.onPreRender = function() {}, n.onPostRender = function() {}, n.onDisable = function() {},
                n.onDestroy = function() {}, u(0, n, "isSingleton", function() {
                    return !1;
                });
        }(), function(t) {
            function o(t) {
                this._owner = null, this._children = null, this._parent = null, this._dummy = null,
                    this._transformFlag = 0, o.__super.call(this), this._localPosition = new Ct(0, 0, 0),
                    this._localRotation = new rt(0, 0, 0, 1), this._localScale = new Ct(1, 1, 1), this._localRotationEuler = new Ct(0, 0, 0),
                    this._localMatrix = new be(), this._position = new Ct(0, 0, 0), this._rotation = new rt(0, 0, 0, 1),
                    this._scale = new Ct(1, 1, 1), this._rotationEuler = new Ct(0, 0, 0), this._worldMatrix = new be(),
                    this._owner = t, this._children = [], this._setTransformFlag(7, !1), this._setTransformFlag(248, !0);
            }
            d(o, "laya.d3.core.Transform3D", h);
            var e = o.prototype;
            return e._setTransformFlag = function(t, e) {
                    e ? this._transformFlag |= t : this._transformFlag &= ~t;
                }, e._getTransformFlag = function(t) {
                    return 0 != (this._transformFlag & t);
                }, e._setParent = function(t) {
                    if (this._parent !== t) {
                        if (this._parent) {
                            var e = this._parent._children,
                                n = e.indexOf(this);
                            e.splice(n, 1);
                        }
                        t && (t._children.push(this), t && this._onWorldTransform()), this._parent = t;
                    }
                }, e._updateLocalMatrix = function() {
                    be.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix);
                }, e._onWorldPositionRotationTransform = function() {
                    if (!(this._getTransformFlag(64) && this._getTransformFlag(8) && this._getTransformFlag(16) && this._getTransformFlag(128))) {
                        this._setTransformFlag(216, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldPositionRotationTransform();
                    }
                }, e._onWorldPositionScaleTransform = function() {
                    if (!this._getTransformFlag(64) || !this._getTransformFlag(8) || !this._getTransformFlag(32)) {
                        this._setTransformFlag(104, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldPositionScaleTransform();
                    }
                }, e._onWorldPositionTransform = function() {
                    if (!this._getTransformFlag(64) || !this._getTransformFlag(8)) {
                        this._setTransformFlag(72, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldPositionTransform();
                    }
                }, e._onWorldRotationTransform = function() {
                    if (!this._getTransformFlag(64) || !this._getTransformFlag(16) || !this._getTransformFlag(128)) {
                        this._setTransformFlag(208, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldPositionRotationTransform();
                    }
                }, e._onWorldScaleTransform = function() {
                    if (!this._getTransformFlag(64) || !this._getTransformFlag(32)) {
                        this._setTransformFlag(96, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldPositionScaleTransform();
                    }
                }, e._onWorldTransform = function() {
                    if (!(this._getTransformFlag(64) && this._getTransformFlag(8) && this._getTransformFlag(16) && this._getTransformFlag(128) && this._getTransformFlag(32))) {
                        this._setTransformFlag(248, !0), this.event("transformchanged", this._transformFlag);
                        for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldTransform();
                    }
                }, e.translate = function(t, e) {
                    void 0 === e && (e = !0), e ? (be.createFromQuaternion(this.localRotation, o._tempMatrix0),
                        Ct.transformCoordinate(t, o._tempMatrix0, o._tempVector30), Ct.add(this.localPosition, o._tempVector30, this._localPosition),
                        this.localPosition = this._localPosition) : (Ct.add(this.position, t, this._position),
                        this.position = this._position);
                }, e.rotate = function(t, e, n) {
                    var i;
                    void 0 === e && (e = !0), void 0 === n && (n = !0), i = n ? t : (Ct.scale(t, Math.PI / 180, o._tempVector30),
                            o._tempVector30), rt.createFromYawPitchRoll(i.y, i.x, i.z, o._tempQuaternion0),
                        e ? (rt.multiply(this._localRotation, o._tempQuaternion0, this._localRotation),
                            this.localRotation = this._localRotation) : (rt.multiply(o._tempQuaternion0, this.rotation, this._rotation),
                            this.rotation = this._rotation);
                }, e.getForward = function(t) {
                    var e = this.worldMatrix.elements;
                    t.x = -e[8], t.y = -e[9], t.z = -e[10];
                }, e.getUp = function(t) {
                    var e = this.worldMatrix.elements;
                    t.x = e[4], t.y = e[5], t.z = e[6];
                }, e.getRight = function(t) {
                    var e = this.worldMatrix.elements;
                    t.x = e[0], t.y = e[1], t.z = e[2];
                }, e.lookAt = function(t, e, n) {
                    var i;
                    if (void 0 === n && (n = !1), n) {
                        if (i = this._localPosition, Math.abs(i.x - t.x) < $.zeroTolerance && Math.abs(i.y - t.y) < $.zeroTolerance && Math.abs(i.z - t.z) < $.zeroTolerance) return;
                        rt.lookAt(this._localPosition, t, e, this._localRotation), this._localRotation.invert(this._localRotation),
                            this.localRotation = this._localRotation;
                    } else {
                        var r = this.position;
                        if (i = r, Math.abs(i.x - t.x) < $.zeroTolerance && Math.abs(i.y - t.y) < $.zeroTolerance && Math.abs(i.z - t.z) < $.zeroTolerance) return;
                        rt.lookAt(r, t, e, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
                    }
                }, u(0, e, "_isFrontFaceInvert", function() {
                    var t = this.scale,
                        e = t.x < 0;
                    return t.y < 0 && (e = !e), t.z < 0 && (e = !e), e;
                }), u(0, e, "owner", function() {
                    return this._owner;
                }), u(0, e, "localPositionY", function() {
                    return this._localPosition.y;
                }, function(t) {
                    this._localPosition.y = t, this.localPosition = this._localPosition;
                }), u(0, e, "localScaleX", function() {
                    return this._localScale.x;
                }, function(t) {
                    this._localScale.x = t, this.localScale = this._localScale;
                }), u(0, e, "worldNeedUpdate", function() {
                    return this._getTransformFlag(64);
                }), u(0, e, "localPositionX", function() {
                    return this._localPosition.x;
                }, function(t) {
                    this._localPosition.x = t, this.localPosition = this._localPosition;
                }), u(0, e, "localPosition", function() {
                    return this._localPosition;
                }, function(t) {
                    this._localPosition !== t && t.cloneTo(this._localPosition), this._setTransformFlag(4, !0),
                        this._onWorldPositionTransform();
                }), u(0, e, "localPositionZ", function() {
                    return this._localPosition.z;
                }, function(t) {
                    this._localPosition.z = t, this.localPosition = this._localPosition;
                }), u(0, e, "localRotationX", function() {
                    return this.localRotation.x;
                }, function(t) {
                    this._localRotation.x = t, this.localRotation = this._localRotation;
                }), u(0, e, "localRotationY", function() {
                    return this.localRotation.y;
                }, function(t) {
                    this._localRotation.y = t, this.localRotation = this._localRotation;
                }), u(0, e, "localRotationZ", function() {
                    return this.localRotation.z;
                }, function(t) {
                    this._localRotation.z = t, this.localRotation = this._localRotation;
                }), u(0, e, "localRotationW", function() {
                    return this.localRotation.w;
                }, function(t) {
                    this._localRotation.w = t, this.localRotation = this._localRotation;
                }), u(0, e, "localRotation", function() {
                    if (this._getTransformFlag(1)) {
                        var t = this._localRotationEuler;
                        rt.createFromYawPitchRoll(t.y / o._angleToRandin, t.x / o._angleToRandin, t.z / o._angleToRandin, this._localRotation),
                            this._setTransformFlag(1, !1);
                    }
                    return this._localRotation;
                }, function(t) {
                    this._localRotation !== t && t.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation),
                        this._setTransformFlag(6, !0), this._setTransformFlag(1, !1), this._onWorldRotationTransform();
                }), u(0, e, "localScaleY", function() {
                    return this._localScale.y;
                }, function(t) {
                    this._localScale.y = t, this.localScale = this._localScale;
                }), u(0, e, "localScaleZ", function() {
                    return this._localScale.z;
                }, function(t) {
                    this._localScale.z = t, this.localScale = this._localScale;
                }), u(0, e, "position", function() {
                    if (this._getTransformFlag(8)) {
                        if (null != this._parent) {
                            var t = this._parent.position;
                            Ct.multiply(this._localPosition, this._parent.scale, o._tempVector30), Ct.transformQuat(o._tempVector30, this._parent.rotation, o._tempVector30),
                                Ct.add(t, o._tempVector30, this._position);
                        } else this._localPosition.cloneTo(this._position);
                        this._setTransformFlag(8, !1);
                    }
                    return this._position;
                }, function(t) {
                    if (null != this._parent) {
                        Ct.subtract(t, this._parent.position, this._localPosition);
                        var e = this._parent.scale,
                            n = e.x,
                            i = e.y,
                            r = e.z;
                        if (1 !== n || 1 !== i || 1 !== r) {
                            var a = o._tempVector30;
                            a.x = 1 / n, a.y = 1 / i, a.z = 1 / r, Ct.multiply(this._localPosition, a, this._localPosition);
                        }
                        this._parent.rotation.invert(o._tempQuaternion0), Ct.transformQuat(this._localPosition, o._tempQuaternion0, this._localPosition);
                    } else t.cloneTo(this._localPosition);
                    this.localPosition = this._localPosition, this._position !== t && t.cloneTo(this._position),
                        this._setTransformFlag(8, !1);
                }), u(0, e, "localRotationEulerY", function() {
                    return this.localRotationEuler.y;
                }, function(t) {
                    this._localRotationEuler.y = t, this.localRotationEuler = this._localRotationEuler;
                }), u(0, e, "localScale", function() {
                    return this._localScale;
                }, function(t) {
                    this._localScale !== t && t.cloneTo(this._localScale), this._setTransformFlag(4, !0),
                        this._onWorldScaleTransform();
                }), u(0, e, "localRotationEulerX", function() {
                    return this.localRotationEuler.x;
                }, function(t) {
                    this._localRotationEuler.x = t, this.localRotationEuler = this._localRotationEuler;
                }), u(0, e, "localRotationEulerZ", function() {
                    return this.localRotationEuler.z;
                }, function(t) {
                    this._localRotationEuler.z = t, this.localRotationEuler = this._localRotationEuler;
                }), u(0, e, "localRotationEuler", function() {
                    if (this._getTransformFlag(2)) {
                        this._localRotation.getYawPitchRoll(o._tempVector30);
                        var t = o._tempVector30,
                            e = this._localRotationEuler;
                        e.x = t.y * o._angleToRandin, e.y = t.x * o._angleToRandin, e.z = t.z * o._angleToRandin,
                            this._setTransformFlag(2, !1);
                    }
                    return this._localRotationEuler;
                }, function(t) {
                    this._localRotationEuler !== t && t.cloneTo(this._localRotationEuler), this._setTransformFlag(2, !1),
                        this._setTransformFlag(5, !0), this._onWorldRotationTransform();
                }), u(0, e, "localMatrix", function() {
                    return this._getTransformFlag(4) && (this._updateLocalMatrix(), this._setTransformFlag(4, !1)),
                        this._localMatrix;
                }, function(t) {
                    this._localMatrix !== t && t.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale),
                        this._setTransformFlag(4, !1), this._onWorldTransform();
                }), u(0, e, "rotation", function() {
                    return this._getTransformFlag(16) && (null != this._parent ? rt.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation),
                        this._setTransformFlag(16, !1)), this._rotation;
                }, function(t) {
                    null != this._parent ? (this._parent.rotation.invert(o._tempQuaternion0), rt.multiply(o._tempQuaternion0, t, this._localRotation)) : t.cloneTo(this._localRotation),
                        this.localRotation = this._localRotation, t !== this._rotation && t.cloneTo(this._rotation),
                        this._setTransformFlag(16, !1);
                }), u(0, e, "scale", function() {
                    return this._getTransformFlag(32) && (null !== this._parent ? Ct.multiply(this._parent.scale, this._localScale, this._scale) : this._localScale.cloneTo(this._scale),
                        this._setTransformFlag(32, !1)), this._scale;
                }, function(t) {
                    if (null !== this._parent) {
                        var e = this._parent.scale,
                            n = o._tempVector30;
                        n.x = 1 / e.x, n.y = 1 / e.y, n.z = 1 / e.z, Ct.multiply(t, o._tempVector30, this._localScale);
                    } else t.cloneTo(this._localScale);
                    this.localScale = this._localScale, this._scale !== t && t.cloneTo(this._scale),
                        this._setTransformFlag(32, !1);
                }), u(0, e, "rotationEuler", function() {
                    if (this._getTransformFlag(128)) {
                        this.rotation.getYawPitchRoll(o._tempVector30);
                        var t = o._tempVector30,
                            e = this._rotationEuler;
                        e.x = t.y * o._angleToRandin, e.y = t.x * o._angleToRandin, e.z = t.z * o._angleToRandin,
                            this._setTransformFlag(128, !1);
                    }
                    return this._rotationEuler;
                }, function(t) {
                    rt.createFromYawPitchRoll(t.y / o._angleToRandin, t.x / o._angleToRandin, t.z / o._angleToRandin, this._rotation),
                        this.rotation = this._rotation, this._rotationEuler !== t && t.cloneTo(this._rotationEuler),
                        this._setTransformFlag(128, !1);
                }), u(0, e, "worldMatrix", function() {
                    return this._getTransformFlag(64) && (null != this._parent ? be.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
                        this._setTransformFlag(64, !1)), this._worldMatrix;
                }, function(t) {
                    null === this._parent ? t.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix),
                            be.multiply(this._localMatrix, t, this._localMatrix)), this.localMatrix = this._localMatrix,
                        this._worldMatrix !== t && t.cloneTo(this._worldMatrix), this._setTransformFlag(64, !1);
                }), o.TRANSFORM_LOCALQUATERNION = 1, o.TRANSFORM_LOCALEULER = 2, o.TRANSFORM_LOCALMATRIX = 4,
                o.TRANSFORM_WORLDPOSITION = 8, o.TRANSFORM_WORLDQUATERNION = 16, o.TRANSFORM_WORLDSCALE = 32,
                o.TRANSFORM_WORLDMATRIX = 64, o.TRANSFORM_WORLDEULER = 128, _(o, ["_tempVector30", function() {
                    return this._tempVector30 = new Ct();
                }, "_tempVector31", function() {
                    return this._tempVector31 = new Ct();
                }, "_tempVector32", function() {
                    return this._tempVector32 = new Ct();
                }, "_tempVector33", function() {
                    return this._tempVector33 = new Ct();
                }, "_tempQuaternion0", function() {
                    return this._tempQuaternion0 = new rt();
                }, "_tempMatrix0", function() {
                    return this._tempMatrix0 = new be();
                }, "_angleToRandin", function() {
                    return this._angleToRandin = 180 / Math.PI;
                }]), o;
        }()),
        Ge = function(t) {
            function x() {
                this._linkAvatarSpritesData = {}, this._keyframeNodeOwners = [], this._linkAvatarSprites = [],
                    this._renderableSprites = [], this.cullingMode = 2, x.__super.call(this), this._controllerLayers = [],
                    this._linkSprites = {}, this._speed = 1, this._keyframeNodeOwnerMap = {}, this._updateMark = 0;
            }
            d(x, "laya.d3.component.Animator", r);
            var e = x.prototype;
            return e._linkToSprites = function(t) {
                    for (var e in t) {
                        for (var n = this.owner, i = t[e], r = 0, a = i.length; r < a; r++) {
                            var o = i[r];
                            if ("" === o) break;
                            if (!(n = n.getChildByName(o))) break;
                        }
                        n && this.linkSprite3DToAvatarNode(e, n);
                    }
                }, e._addKeyframeNodeOwner = function(t, e, n) {
                    var i = e._indexInList,
                        r = e.fullPath,
                        a = this._keyframeNodeOwnerMap[r];
                    if (a) a.referenceCount++, t[i] = a;
                    else {
                        for (var o = n, s = 0, l = e.propertyCount; s < l && (o = o[e.getPropertyByIndex(s)]); s++);
                        (a = this._keyframeNodeOwnerMap[r] = new Ae()).fullPath = r, a.indexInList = this._keyframeNodeOwners.length,
                            a.referenceCount = 1, a.propertyOwner = n;
                        var h = e.propertyCount,
                            u = P(h);
                        for (s = 0; s < h; s++) u[s] = e.getPropertyByIndex(s);
                        if (a.property = u, a.type = e.type, o)
                            if (0 === e.type) a.defaultValue = o;
                            else {
                                var c = new o.constructor();
                                o.cloneTo(c), a.defaultValue = c;
                            }
                        this._keyframeNodeOwners.push(a), t[i] = a;
                    }
                }, e._removeKeyframeNodeOwner = function(t, e) {
                    var n = e.fullPath,
                        i = this._keyframeNodeOwnerMap[n];
                    i && (i.referenceCount--, 0 === i.referenceCount && (delete this._keyframeNodeOwnerMap[n],
                        this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(i), 1)), t[e._indexInList] = null);
                }, e._getOwnersByClip = function(t) {
                    var e = t._clip._nodes,
                        n = e.count,
                        i = t._nodeOwners;
                    i.length = n;
                    for (var r = 0; r < n; r++) {
                        for (var a = e.getNodeByIndex(r), o = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, s = 0, l = a.ownerPathCount; s < l; s++) {
                            var h = a.getOwnerPathByIndex(s);
                            if ("" === h) break;
                            if (!(o = o.getChildByName(h))) break;
                        }
                        if (o) {
                            var u = a.propertyOwner;
                            u && (o = o[u]), o && this._addKeyframeNodeOwner(i, a, o);
                        }
                    }
                }, e._getAvatarOwnersAndInitDatasAsync = function() {
                    for (var t = 0, e = this._controllerLayers.length; t < e; t++)
                        for (var n = this._controllerLayers[t]._states, i = 0, r = n.length; i < r; i++) this._getOwnersByClip(n[i]);
                    for (var a in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                        var o = this._linkAvatarSpritesData[a];
                        if (o)
                            for (var s = 0, l = o.length; s < l; s++) this._isLinkSpriteToAnimationNode(o[s], a, !0);
                    }
                }, e._updatePlayer = function(t, e, n, i) {
                    var r = t._clip._duration * (t.clipEnd - t.clipStart),
                        a = e._elapsedTime,
                        o = a + n;
                    e._lastElapsedTime = a;
                    var s = (e._elapsedTime = o) / r,
                        l = (e._normalizedTime = s) % 1;
                    e._normalizedPlayTime = l < 0 ? l + 1 : l, e._duration = r;
                    var h = t._scripts;
                    if (!i && r <= o) {
                        if (e._finish = !0, e._elapsedTime = r, e._normalizedPlayTime = 1, h)
                            for (var u = 0, c = h.length; u < c; u++) h[u].onStateExit();
                    } else if (h)
                        for (u = 0, c = h.length; u < c; u++) h[u].onStateUpdate();
                }, e._eventScript = function(t, e, n, i, r) {
                    if (r)
                        for (var a = e.length; n < a; n++) {
                            var o = e[n];
                            if (!(o.time <= i)) break;
                            for (var s = 0, l = t.length; s < l; s++) {
                                var h = t[s],
                                    u = h[o.eventName];
                                u && u.apply(h, o.params);
                            }
                        } else
                            for (; 0 <= n && (o = e[n]).time >= i; n--)
                                for (s = 0, l = t.length; s < l; s++)(u = (h = t[s])[o.eventName]) && u.apply(h, o.params);
                    return n;
                }, e._updateEventScript = function(t, e) {
                    var n = this.owner._scripts;
                    if (n) {
                        var i = t._clip,
                            r = i._events,
                            a = i._duration,
                            o = e._elapsedTime,
                            s = o % a,
                            l = Math.abs(Math.floor(o / a) - Math.floor(e._lastElapsedTime / a)),
                            h = e._elapsedTime >= e._lastElapsedTime;
                        if (e._lastIsFront !== h && (h ? e._playEventIndex++ : e._playEventIndex--, e._lastIsFront = h),
                            0 == l) e._playEventIndex = this._eventScript(n, r, e._playEventIndex, s, h);
                        else if (h) {
                            this._eventScript(n, r, e._playEventIndex, a, !0);
                            for (var u = 0, c = l - 1; u < c; u++) this._eventScript(n, r, 0, a, !0);
                            e._playEventIndex = this._eventScript(n, r, 0, s, !0);
                        } else {
                            this._eventScript(n, r, e._playEventIndex, 0, !1);
                            var _ = r.length - 1;
                            for (u = 0, c = l - 1; u < c; u++) this._eventScript(n, r, _, 0, !1);
                            e._playEventIndex = this._eventScript(n, r, _, s, !1);
                        }
                    }
                }, e._updateClipDatas = function(t, e, n, i) {
                    var r = t._clip,
                        a = r._duration,
                        o = t.clipStart * a + n._normalizedPlayTime * n._duration,
                        s = t._currentFrameIndices,
                        l = n._elapsedTime > n._lastElapsedTime;
                    r._evaluateClipDatasRealTime(r._nodes, o, s, e, l);
                }, e._applyFloat = function(t, e, n, i, r, a, o) {
                    if (n.updateMark === this._updateMark)
                        if (i) t[e] += r * o;
                        else {
                            var s = t[e];
                            t[e] = s + r * (o - s);
                        }
                    else if (a) t[e] = i ? n.defaultValue + o : o;
                    else if (i) t[e] = n.defaultValue + r * o;
                    else {
                        var l = n.defaultValue;
                        t[e] = l + r * (o - l);
                    }
                }, e._applyPositionAndRotationEuler = function(t, e, n, i, r, a) {
                    if (t.updateMark === this._updateMark)
                        if (e) a.x += n * r.x, a.y += n * r.y, a.z += n * r.z;
                        else {
                            var o = a.x,
                                s = a.y,
                                l = a.z;
                            a.x = o + n * (r.x - o), a.y = s + n * (r.y - s), a.z = l + n * (r.z - l);
                        }
                    else if (i)
                        if (e) {
                            var h = t.defaultValue;
                            a.x = h.x + r.x, a.y = h.y + r.y, a.z = h.z + r.z;
                        } else a.x = r.x, a.y = r.y, a.z = r.z;
                    else if (h = t.defaultValue, e) a.x = h.x + n * r.x,
                        a.y = h.y + n * r.y, a.z = h.z + n * r.z;
                    else {
                        var u = h.x,
                            c = h.y,
                            _ = h.z;
                        a.x = u + n * (r.x - u), a.y = c + n * (r.y - c), a.z = _ + n * (r.z - _);
                    }
                }, e._applyRotation = function(t, e, n, i, r, a) {
                    if (t.updateMark === this._updateMark)
                        if (e) {
                            var o = x._tempQuaternion1;
                            Gt.quaternionWeight(r, n, o), o.normalize(o), rt.multiply(a, o, a);
                        } else rt.lerp(a, r, n, a);
                    else if (i)
                        if (e) {
                            var s = t.defaultValue;
                            rt.multiply(s, r, a);
                        } else a.x = r.x, a.y = r.y, a.z = r.z, a.w = r.w;
                    else s = t.defaultValue, e ? (o = x._tempQuaternion1,
                        Gt.quaternionWeight(r, n, o), o.normalize(o), rt.multiply(s, o, a)) : rt.lerp(s, r, n, a);
                }, e._applyScale = function(t, e, n, i, r, a) {
                    if (t.updateMark === this._updateMark)
                        if (e) {
                            var o = x._tempVector31;
                            Gt.scaleWeight(r, n, o), a.x = a.x * o.x, a.y = a.y * o.y, a.z = a.z * o.z;
                        } else Gt.scaleBlend(a, r, n, a);
                    else if (i)
                        if (e) {
                            var s = t.defaultValue;
                            a.x = s.x * r.x, a.y = s.y * r.y, a.z = s.z * r.z;
                        } else a.x = r.x, a.y = r.y, a.z = r.z;
                    else s = t.defaultValue, e ? (o = x._tempVector31,
                        Gt.scaleWeight(r, n, o), a.x = s.x * o.x, a.y = s.y * o.y, a.z = s.z * o.z) : Gt.scaleBlend(s, r, n, a);
                }, e._applyCrossData = function(t, e, n, i, r, a, o) {
                    var s = t.propertyOwner;
                    if (s) {
                        switch (t.type) {
                            case 0:
                                for (var l = t.property, h = l.length - 1, u = 0; u < h && (s = s[l[u]]); u++);
                                var c = r + o * (a - r);
                                this._applyFloat(s, l[h], t, e, n, i, c);
                                break;

                            case 1:
                                var _ = s.localPosition,
                                    d = x._tempVector30,
                                    f = r.x,
                                    m = r.y,
                                    p = r.z;
                                d.x = f + o * (a.x - f), d.y = m + o * (a.y - m), d.z = p + o * (a.z - p), this._applyPositionAndRotationEuler(t, e, n, i, d, _),
                                    s.localPosition = _;
                                break;

                            case 2:
                                var T = s.localRotation,
                                    E = x._tempQuaternion0;
                                rt.lerp(r, a, o, E), this._applyRotation(t, e, n, i, E, T), s.localRotation = T;
                                break;

                            case 3:
                                var v = s.localScale,
                                    g = x._tempVector30;
                                Gt.scaleBlend(r, a, o, g), this._applyScale(t, e, n, i, g, v), s.localScale = v;
                                break;

                            case 4:
                                var S = s.localRotationEuler,
                                    y = x._tempVector30;
                                f = r.x, m = r.y, p = r.z, y.x = f + o * (a.x - f), y.y = m + o * (a.y - m), y.z = p + o * (a.z - p),
                                    this._applyPositionAndRotationEuler(t, e, n, i, y, S), s.localRotationEuler = S;
                        }
                        t.updateMark = this._updateMark;
                    }
                }, e._setClipDatasToNode = function(t, e, n, i) {
                    for (var r = t._clip._nodes, a = t._nodeOwners, o = 0, s = r.count; o < s; o++) {
                        var l = a[o];
                        if (l) {
                            var h = l.propertyOwner;
                            if (h) {
                                switch (l.type) {
                                    case 0:
                                        for (var u = l.property, c = u.length - 1, _ = 0; _ < c && (h = h[u[_]]); _++);
                                        this._applyFloat(h, u[c], l, e, n, i, r.getNodeByIndex(o).data);
                                        break;

                                    case 1:
                                        var d = h.localPosition;
                                        this._applyPositionAndRotationEuler(l, e, n, i, r.getNodeByIndex(o).data, d), h.localPosition = d;
                                        break;

                                    case 2:
                                        var f = h.localRotation;
                                        this._applyRotation(l, e, n, i, r.getNodeByIndex(o).data, f), h.localRotation = f;
                                        break;

                                    case 3:
                                        var m = h.localScale;
                                        this._applyScale(l, e, n, i, r.getNodeByIndex(o).data, m), h.localScale = m;
                                        break;

                                    case 4:
                                        var p = h.localRotationEuler;
                                        this._applyPositionAndRotationEuler(l, e, n, i, r.getNodeByIndex(o).data, p), h.localRotationEuler = p;
                                }
                                l.updateMark = this._updateMark;
                            }
                        }
                    }
                }, e._setCrossClipDatasToNode = function(t, e, n, i, r) {
                    for (var a = t._crossNodesOwners, o = t._crossNodesOwnersCount, s = t.blendingMode !== Le.BLENDINGMODE_OVERRIDE, l = t.defaultWeight, h = t._destCrossClipNodeIndices, u = n._clip._nodes, c = n._nodeOwners, _ = t._srcCrossClipNodeIndices, d = e._nodeOwners, f = e._clip._nodes, m = 0; m < o; m++) {
                        var p = a[m];
                        if (p) {
                            var T = _[m],
                                E = h[m],
                                v = -1 !== T ? f.getNodeByIndex(T).data : c[E].defaultValue,
                                g = -1 !== E ? u.getNodeByIndex(E).data : d[T].defaultValue;
                            this._applyCrossData(p, s, l, r, v, g, i);
                        }
                    }
                }, e._setFixedCrossClipDatasToNode = function(t, e, n, i) {
                    for (var r = t._crossNodesOwners, a = t._crossNodesOwnersCount, o = t.blendingMode !== Le.BLENDINGMODE_OVERRIDE, s = t.defaultWeight, l = t._destCrossClipNodeIndices, h = e._clip._nodes, u = 0; u < a; u++) {
                        var c = r[u];
                        if (c) {
                            var _ = l[u],
                                d = c.crossFixedValue,
                                f = -1 !== _ ? h.getNodeByIndex(_).data : c.defaultValue;
                            this._applyCrossData(c, o, s, i, d, f, n);
                        }
                    }
                }, e._revertDefaultKeyframeNodes = function(t) {
                    for (var e = t._nodeOwners, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        if (r) {
                            var a = r.propertyOwner;
                            if (a) switch (r.type) {
                                case 0:
                                    for (var o = r.property, s = o.length - 1, l = 0; l < s && (a = a[o[l]]); l++);
                                    a[o[s]] = r.defaultValue;
                                    break;

                                case 1:
                                    var h = a.localPosition,
                                        u = r.defaultValue;
                                    h.x = u.x, h.y = u.y, h.z = u.z, a.localPosition = h;
                                    break;

                                case 2:
                                    var c = a.localRotation,
                                        _ = r.defaultValue;
                                    c.x = _.x, c.y = _.y, c.z = _.z, c.w = _.w, a.localRotation = c;
                                    break;

                                case 3:
                                    var d = a.localScale;
                                    u = r.defaultValue, d.x = u.x, d.y = u.y, d.z = u.z, a.localScale = d;
                                    break;

                                case 4:
                                    var f = a.localRotationEuler;
                                    u = r.defaultValue, f.x = u.x, f.y = u.y, f.z = u.z, a.localRotationEuler = f;
                                    break;

                                default:
                                    throw "Animator:unknown type.";
                            }
                        }
                    }
                }, e._removeClip = function(t, e, n, i) {
                    var r = i._clip;
                    r._removeReference(), t.splice(n, 1), delete e[i.name];
                    for (var a = t[n], o = r._nodes, s = a._nodeOwners, l = 0, h = o.count; l < h; l++) this._removeKeyframeNodeOwner(s, o.getNodeByIndex(l));
                }, e._isLinkSpriteToAnimationNodeData = function(t, e, n) {
                    var i = this._linkAvatarSpritesData[e];
                    n ? (i || (this._linkAvatarSpritesData[e] = i = []), i.push(t)) : i.splice(t, 1);
                }, e._isLinkSpriteToAnimationNode = function(t, e, n) {
                    if (this._avatar) {
                        var i = this._avatarNodeMap[e];
                        if (i)
                            if (n) {
                                t._transform._dummy = i.transform, this._linkAvatarSprites.push(t);
                                var r = i.transform,
                                    a = t.transform;
                                if (!a.owner.isStatic && r) {
                                    var o = a.worldMatrix,
                                        s = this.owner._transform._parent;
                                    if (s) Gt.matrix4x4MultiplyMFM(s.worldMatrix, r.getWorldMatrix(), o);
                                    else
                                        for (var l = o.elements, h = r.getWorldMatrix(), u = 0; u < 16; u++) l[u] = h[u];
                                    a.worldMatrix = o;
                                }
                            } else t._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(t), 1);
                    }
                }, e._onAdded = function() {
                    var t = this.owner._parent;
                    this.owner._setHierarchyAnimator(this, t ? t._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
                }, e._onDestroy = function() {
                    for (var t = 0, e = this._controllerLayers.length; t < e; t++)
                        for (var n = this._controllerLayers[t]._states, i = 0, r = n.length; i < r; i++) n[i]._clip._removeReference();
                    var a = this.owner._parent;
                    this.owner._clearHierarchyAnimator(this, a ? a._hierarchyAnimator : null);
                }, e._onEnableInScene = function() {
                    this.owner._scene._animatorPool.add(this);
                }, e._onDisableInScene = function() {
                    this.owner._scene._animatorPool.remove(this);
                }, e._onEnable = function() {
                    for (var t = 0, e = this._controllerLayers.length; t < e; t++) {
                        if (this._controllerLayers[t].playOnWake) this.getDefaultState(t) && this.play(null, t, 0);
                    }
                }, e._handleSpriteOwnersBySprite = function(t, e, n) {
                    for (var i = 0, r = this._controllerLayers.length; i < r; i++)
                        for (var a = this._controllerLayers[i]._states, o = 0, s = a.length; o < s; o++) {
                            var l = a[o],
                                h = l._clip,
                                u = e.join("/"),
                                c = h._nodesMap[u];
                            if (c)
                                for (var _ = l._nodeOwners, d = 0, f = c.length; d < f; d++) t ? this._addKeyframeNodeOwner(_, c[d], n) : this._removeKeyframeNodeOwner(_, c[d]);
                        }
                }, e._updateAvatarNodesToSprite = function() {
                    for (var t = 0, e = this._linkAvatarSprites.length; t < e; t++) {
                        var n = this._linkAvatarSprites[t],
                            i = n.transform._dummy,
                            r = n.transform;
                        if (!r.owner.isStatic && i) {
                            var a = r.worldMatrix,
                                o = this.owner._transform;
                            Gt.matrix4x4MultiplyMFM(o.worldMatrix, i.getWorldMatrix(), a), r.worldMatrix = a;
                        }
                    }
                }, e._parse = function(t) {
                    var e = t.avatar;
                    if (e) {
                        this.avatar = xt.getRes(e.path);
                        var n = e.linkSprites;
                        this._linkSprites = n, this._linkToSprites(n);
                    }
                    t.clipPaths;
                    for (var i = t.playOnWake, r = t.layers, a = 0; a < r.length; a++) {
                        var o = r[a],
                            s = new Le(o.name);
                        s.defaultWeight = 0 === a ? 1 : o.weight;
                        var l = o.blendingMode;
                        l && (s.blendingMode = l), this.addControllerLayer(s);
                        for (var h = o.states, u = 0, c = h.length; u < c; u++) {
                            var _ = h[u],
                                d = _.clipPath;
                            if (d) {
                                var f, m = _.name;
                                if (f = xt.getRes(d)) {
                                    var p = new Pe();
                                    p.name = m, p.clip = f, this.addState(p, a), 0 === u && (this.getControllerLayer(a).defaultState = p);
                                }
                            }
                        }
                        void 0 !== i && (s.playOnWake = i);
                    }
                    var T = t.cullingMode;
                    void 0 !== T && (this.cullingMode = T);
                }, e._update = function() {
                    if (0 !== this._speed) {
                        var t = !1;
                        if (2 === this.cullingMode) {
                            t = !1;
                            for (var e = 0, n = this._renderableSprites.length; e < n; e++)
                                if (this._renderableSprites[e]._render._visible) {
                                    t = !0;
                                    break;
                                }
                        } else t = !0;
                        this._updateMark++;
                        var i = this.owner._scene.timer,
                            r = i._delta / 1e3,
                            a = i.scale;
                        for (e = 0, n = this._controllerLayers.length; e < n; e++) {
                            var o = this._controllerLayers[e],
                                s = o._playStateInfo,
                                l = o._crossPlayStateInfo;
                            switch (d = o.blendingMode !== Le.BLENDINGMODE_OVERRIDE, o._playType) {
                                case 0:
                                    var h = o._currentPlayState,
                                        u = h._clip,
                                        c = this._speed * h.speed,
                                        _ = s._finish;
                                    if (_ || this._updatePlayer(h, s, r * c, u.islooping), t) {
                                        var d = o.blendingMode !== Le.BLENDINGMODE_OVERRIDE;
                                        this._updateClipDatas(h, d, s, a * c), this._setClipDatasToNode(h, d, o.defaultWeight, 0 === e),
                                            _ || this._updateEventScript(h, s);
                                    }
                                    break;

                                case 1:
                                    u = (h = o._currentPlayState)._clip;
                                    var f = o._crossPlayState,
                                        m = f._clip,
                                        p = o._crossDuration,
                                        T = l._startPlayTime,
                                        E = m._duration - T,
                                        v = E < p ? E / p : 1,
                                        g = this._speed * f.speed;
                                    this._updatePlayer(f, l, r * v * g, m.islooping);
                                    var S = (l._elapsedTime - T) / v / p;
                                    1 <= S ? t && (this._updateClipDatas(f, d, l, a * g), this._setClipDatasToNode(f, d, o.defaultWeight, 0 === e),
                                            o._playType = 0, o._currentPlayState = f, l._cloneTo(s)) : (s._finish || (c = this._speed * h.speed,
                                                this._updatePlayer(h, s, r * c, u.islooping), t && this._updateClipDatas(h, d, s, a * c)),
                                            t && (this._updateClipDatas(f, d, l, a * v * g), this._setCrossClipDatasToNode(o, h, f, S, 0 === e))),
                                        t && (this._updateEventScript(h, s), this._updateEventScript(f, l));
                                    break;

                                case 2:
                                    m = (f = o._crossPlayState)._clip, p = o._crossDuration, T = l._startPlayTime, v = (E = m._duration - T) < p ? E / p : 1,
                                        g = this._speed * f.speed, this._updatePlayer(f, l, r * v * g, m.islooping), t && (1 <= (S = (l._elapsedTime - T) / v / p) ? (this._updateClipDatas(f, d, l, a * g),
                                                this._setClipDatasToNode(f, d, 1, 0 === e), o._playType = 0, o._currentPlayState = f,
                                                l._cloneTo(s)) : (this._updateClipDatas(f, d, l, a * v * g), this._setFixedCrossClipDatasToNode(o, f, S, 0 === e)),
                                            this._updateEventScript(f, l));
                            }
                        }
                        t && this._avatar && (b.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices),
                            this._updateAvatarNodesToSprite());
                    }
                }, e._cloneTo = function(t) {
                    var e = t;
                    e.avatar = this.avatar;
                    for (var n = 0, i = this._controllerLayers.length; n < i; n++) {
                        var r = this._controllerLayers[n];
                        e.addControllerLayer(r.clone());
                        for (var a = r._states, o = 0, s = a.length; o < s; o++) {
                            var l = a[o].clone();
                            e.addState(l, n), 0 == o && (e.getControllerLayer(n).defaultState = l);
                        }
                    }
                    e._linkSprites = this._linkSprites, e._linkToSprites(this._linkSprites);
                }, e.getDefaultState = function(t) {
                    return void 0 === t && (t = 0), this._controllerLayers[t].defaultState;
                }, e.addState = function(t, e) {
                    void 0 === e && (e = 0);
                    var n = t.name,
                        i = this._controllerLayers[e],
                        r = i._statesMap,
                        a = i._states;
                    if (r[n]) throw "Animator:this stat's name has exist.";
                    r[n] = t, a.push(t), t._clip._addReference(), this._avatar, this._getOwnersByClip(t);
                }, e.removeState = function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = this._controllerLayers[e], i = n._states, r = n._statesMap, a = -1, o = 0, s = i.length; o < s; o++)
                        if (i[o] === t) {
                            a = o;
                            break;
                        } -
                    1 !== a && this._removeClip(i, r, a, t);
                }, e.addControllerLayer = function(t) {
                    this._controllerLayers.push(t);
                }, e.getControllerLayer = function(t) {
                    return void 0 === t && (t = 0), this._controllerLayers[t];
                }, e.getCurrentAnimatorPlayState = function(t) {
                    return void 0 === t && (t = 0), this._controllerLayers[t]._playStateInfo;
                }, e.play = function(t, e, n) {
                    void 0 === e && (e = 0), void 0 === n && (n = Number.NEGATIVE_INFINITY);
                    var i = this._controllerLayers[e],
                        r = i.defaultState;
                    if (!t && !r) throw new Error("Animator:must have  default clip value,please set clip property.");
                    var a = i._currentPlayState,
                        o = i._playStateInfo,
                        s = t ? i._statesMap[t] : r,
                        l = s._clip._duration;
                    a !== s ? (n !== Number.NEGATIVE_INFINITY ? o._resetPlayState(l * n) : o._resetPlayState(0),
                        null !== a && a !== s && this._revertDefaultKeyframeNodes(a), i._playType = 0, i._currentPlayState = s) : n !== Number.NEGATIVE_INFINITY && (o._resetPlayState(l * n),
                        i._playType = 0);
                    var h = s._scripts;
                    if (h)
                        for (var u = 0, c = h.length; u < c; u++) h[u].onStateEnter();
                }, e.crossFade = function(t, e, n, i) {
                    void 0 === n && (n = 0), void 0 === i && (i = Number.NEGATIVE_INFINITY);
                    var r = this._controllerLayers[n],
                        a = r._statesMap[t];
                    if (a) {
                        var o = r._playType;
                        if (-1 === o) return void this.play(t, n, i);
                        var s = r._crossPlayStateInfo,
                            l = r._crossNodesOwners,
                            h = r._crossNodesOwnersIndicesMap,
                            u = r._currentPlayState,
                            c = a._nodeOwners,
                            _ = r._destCrossClipNodeIndices,
                            d = a._clip,
                            f = d._nodes,
                            m = d._nodesDic;
                        switch (o) {
                            case 0:
                                var p = u._nodeOwners,
                                    T = r._srcCrossClipNodeIndices,
                                    E = u._clip,
                                    v = E._nodes,
                                    g = E._nodesDic;
                                r._playType = 1;
                                for (var S = ++r._crossMark, y = r._crossNodesOwnersCount = 0, x = 0, D = v.count; x < D; x++) {
                                    var I = v.getNodeByIndex(x),
                                        R = I._indexInList,
                                        M = p[R];
                                    if (M) {
                                        var A = I.fullPath;
                                        T[y] = R;
                                        var C = m[A];
                                        _[y] = C ? C._indexInList : -1, h[A] = S, l[y] = M, y++;
                                    }
                                }
                                for (x = 0, D = f.count; x < D; x++) {
                                    var L = (C = f.getNodeByIndex(x))._indexInList,
                                        O = c[L];
                                    if (O) {
                                        var N = C.fullPath;
                                        g[N] || (T[y] = -1, _[y] = L, h[N] = S, l[y] = O, y++);
                                    }
                                }
                                break;

                            case 1:
                            case 2:
                                for (r._playType = 2, x = 0, D = l.length; x < D; x++) {
                                    var V = l[x];
                                    V.saveCrossFixedValue(), C = m[V.fullPath], _[x] = C ? C._indexInList : -1;
                                }
                                for (y = r._crossNodesOwnersCount, S = r._crossMark, x = 0, D = f.count; x < D; x++)(O = c[L = (C = f.getNodeByIndex(x))._indexInList]) && h[N = C.fullPath] !== S && (_[y] = L,
                                    h[N] = S, V = c[L], (l[y] = V).saveCrossFixedValue(), y++);
                        }
                        r._crossNodesOwnersCount = y, r._crossPlayState = a, r._crossDuration = u._clip._duration * e,
                            i !== Number.NEGATIVE_INFINITY ? s._resetPlayState(d._duration * i) : s._resetPlayState(0);
                    }
                    var w = a._scripts;
                    if (w)
                        for (x = 0, D = w.length; x < D; x++) w[x].onStateEnter();
                }, e.linkSprite3DToAvatarNode = function(t, e) {
                    return this._isLinkSpriteToAnimationNodeData(e, t, !0), this._isLinkSpriteToAnimationNode(e, t, !0), !0;
                }, e.unLinkSprite3DToAvatarNode = function(t) {
                    if (t._hierarchyAnimator !== this) throw "Animator:sprite3D must belong to this Animator";
                    var e = t.transform._dummy;
                    if (e) {
                        var n = e._owner.name;
                        return this._isLinkSpriteToAnimationNodeData(t, n, !1), this._isLinkSpriteToAnimationNode(t, n, !1), !0;
                    }
                    return !1;
                }, e._updateAnimationNodeWorldMatix = function(t, e, n, i, r) {
                    E.instance.updateAnimationNodeWorldMatix(t, e, n, r, i);
                }, u(0, e, "avatar", function() {
                    return this._avatar;
                }, function(t) {
                    if (this._avatar !== t)
                        if (this._avatar = t) this._getAvatarOwnersAndInitDatasAsync(),
                            this.owner._changeHierarchyAnimatorAvatar(this, t);
                        else {
                            var e = this.owner._parent;
                            this.owner._changeHierarchyAnimatorAvatar(this, e ? e._hierarchyAnimator._avatar : null);
                        }
                }), u(0, e, "speed", function() {
                    return this._speed;
                }, function(t) {
                    this._speed = t;
                }), x._update = function(t) {
                    for (var e = t._animatorPool, n = e.elements, i = 0, r = e.length; i < r; i++) {
                        var a = n[i];
                        a && a.enabled && a._update();
                    }
                }, x._tempVector3Array0 = new Float32Array(3), x._tempVector3Array1 = new Float32Array(3),
                x._tempQuaternionArray0 = new Float32Array(4), x._tempQuaternionArray1 = new Float32Array(4),
                x.CULLINGMODE_ALWAYSANIMATE = 0, x.CULLINGMODE_CULLCOMPLETELY = 2, _(x, ["_tempVector30", function() {
                    return this._tempVector30 = new Ct();
                }, "_tempVector31", function() {
                    return this._tempVector31 = new Ct();
                }, "_tempQuaternion0", function() {
                    return this._tempQuaternion0 = new rt();
                }, "_tempQuaternion1", function() {
                    return this._tempQuaternion1 = new rt();
                }]), x;
        }(),
        He = function(t) {
            function a(t, e, n, i, r) {
                a.__super.call(this), this._owner = t, this._children = [], this._localMatrix = new Float32Array(16),
                    b.supportWebGLPlusAnimation ? (this._localPosition = new U(0, 0, 0, e), this._localRotation = new F(0, 0, 0, 1, n),
                        this._localScale = new U(0, 0, 0, i), this._worldMatrix = r) : (this._localPosition = new Ct(),
                        this._localRotation = new rt(), this._localScale = new Ct(), this._worldMatrix = new Float32Array(16)),
                    this._localQuaternionUpdate = !1, this._locaEulerlUpdate = !1, this._localUpdate = !1,
                    this._worldUpdate = !0;
            }
            d(a, "laya.d3.animation.AnimationTransform3D", h);
            var e = a.prototype;
            return e._getlocalMatrix = function() {
                return this._localUpdate && (Gt._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix),
                    this._localUpdate = !1), this._localMatrix;
            }, e._onWorldTransform = function() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0;
                    for (var t = 0, e = this._children.length; t < e; t++) this._children[t]._onWorldTransform();
                }
            }, e.getWorldMatrix = function() {
                if (!b.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent) Gt.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                    else {
                        var t = this._worldMatrix;
                        t[1] = t[2] = t[3] = t[4] = t[6] = t[7] = t[8] = t[9] = t[11] = t[12] = t[13] = t[14] = 0,
                            t[0] = t[5] = t[10] = t[15] = 1;
                    }
                    this._worldUpdate = !1;
                }
                return this._worldMatrix;
            }, e.setParent = function(t) {
                if (this._parent !== t) {
                    if (this._parent) {
                        var e = this._parent._children,
                            n = e.indexOf(this);
                        e.splice(n, 1);
                    }
                    t && (t._children.push(this), t && this._onWorldTransform()), this._parent = t;
                }
            }, u(0, e, "localPosition", function() {
                return this._localPosition;
            }, function(t) {
                this._localPosition = t, this._localUpdate = !0, this._onWorldTransform();
            }), u(0, e, "localRotation", function() {
                if (this._localQuaternionUpdate) {
                    var t = this._localRotationEuler;
                    rt.createFromYawPitchRoll(t.y / a._angleToRandin, t.x / a._angleToRandin, t.z / a._angleToRandin, this._localRotation),
                        this._localQuaternionUpdate = !1;
                }
                return this._localRotation;
            }, function(t) {
                this._localRotation = t, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1,
                    this._localUpdate = !0, this._onWorldTransform();
            }), u(0, e, "localScale", function() {
                return this._localScale;
            }, function(t) {
                this._localScale = t, this._localUpdate = !0, this._onWorldTransform();
            }), u(0, e, "localRotationEuler", function() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(a._tempVector3);
                    var t = a._tempVector3,
                        e = this._localRotationEuler;
                    e.x = t.y * a._angleToRandin, e.y = t.x * a._angleToRandin, e.z = t.z * a._angleToRandin,
                        this._locaEulerlUpdate = !1;
                }
                return this._localRotationEuler;
            }, function(t) {
                this._localRotationEuler = t, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0,
                    this._localUpdate = !0, this._onWorldTransform();
            }), _(a, ["_tempVector3", function() {
                return this._tempVector3 = new Ct();
            }, "_angleToRandin", function() {
                return this._angleToRandin = 180 / Math.PI;
            }]), a;
        }(),
        ke = (function(t) {
            function e() {
                this._nativeConstraint = null, this._breakingImpulseThreshold = NaN, this._connectedBody = null,
                    this._feedbackEnabled = !1, e.__super.call(this);
            }
            d(e, "laya.d3.physics.constraints.ConstraintComponent", r);
            var n = e.prototype;
            n._onDestroy = function() {
                k._physics3D.destroy(this._nativeConstraint), this._nativeConstraint = null;
            }, u(0, n, "breakingImpulseThreshold", function() {
                return this._breakingImpulseThreshold;
            }, function(t) {
                this._nativeConstraint.BreakingImpulseThreshold = t, this._breakingImpulseThreshold = t;
            }), u(0, n, "enabled", function() {
                return m.superGet(r, this, "enabled");
            }, function(t) {
                this._nativeConstraint.IsEnabled = t, m.superSet(r, this, "enabled", t);
            }), u(0, n, "appliedImpulse", function() {
                return this._feedbackEnabled || (this._nativeConstraint.EnableFeedback(!0), this._feedbackEnabled = !0),
                    this._nativeConstraint.AppliedImpulse;
            }), u(0, n, "connectedBody", function() {
                return this._connectedBody;
            }, function(t) {
                this._connectedBody = t;
            });
        }(), function(n) {
            function u() {
                this.angle = NaN, this.radius = NaN, this.length = NaN, this.emitType = 0, u.__super.call(this),
                    this.angle = 25 / 180 * Math.PI, this.radius = 1, this.length = 5, this.emitType = 0,
                    this.randomDirection = !1;
            }
            d(u, "laya.d3.core.particleShuriKen.module.shape.ConeShape", n);
            var t = u.prototype;
            return t._getShapeBoundBox = function(t) {
                var e = this.radius + this.length * Math.sin(this.angle),
                    n = this.length * Math.cos(this.angle),
                    i = t.min;
                i.x = i.y = -e, i.z = 0;
                var r = t.max;
                r.x = r.y = e, r.z = n;
            }, t._getSpeedBoundBox = function(t) {
                var e = Math.sin(this.angle),
                    n = t.min;
                n.x = n.y = -e, n.z = 0;
                var i = t.max;
                i.x = i.y = e, i.z = 1;
            }, t.generatePositionAndDirection = function(t, e, n, i) {
                var r, a = u._tempPositionPoint,
                    o = NaN,
                    s = NaN,
                    l = Math.cos(this.angle),
                    h = Math.sin(this.angle);
                switch (this.emitType) {
                    case 0:
                        n ? (n.seed = i[16], De._randomPointInsideUnitCircle(u._tempPositionPoint, n), i[16] = n.seed) : De._randomPointInsideUnitCircle(u._tempPositionPoint),
                            o = a.x, s = a.y, t.x = o * this.radius, t.y = s * this.radius, t.z = 0, this.randomDirection ? (n ? (n.seed = i[17],
                                    De._randomPointInsideUnitCircle(u._tempDirectionPoint, n), i[17] = n.seed) : De._randomPointInsideUnitCircle(u._tempDirectionPoint),
                                r = u._tempDirectionPoint, e.x = r.x * h, e.y = r.y * h) : (e.x = o * h, e.y = s * h),
                            e.z = l;
                        break;

                    case 1:
                        n ? (n.seed = i[16], De._randomPointUnitCircle(u._tempPositionPoint, n), i[16] = n.seed) : De._randomPointUnitCircle(u._tempPositionPoint),
                            o = a.x, s = a.y, t.x = o * this.radius, t.y = s * this.radius, t.z = 0, this.randomDirection ? (n ? (n.seed = i[17],
                                    De._randomPointInsideUnitCircle(u._tempDirectionPoint, n), i[17] = n.seed) : De._randomPointInsideUnitCircle(u._tempDirectionPoint),
                                r = u._tempDirectionPoint, e.x = r.x * h, e.y = r.y * h) : (e.x = o * h, e.y = s * h),
                            e.z = l;
                        break;

                    case 2:
                        n ? (n.seed = i[16], De._randomPointInsideUnitCircle(u._tempPositionPoint, n)) : De._randomPointInsideUnitCircle(u._tempPositionPoint),
                            o = a.x, s = a.y, t.x = o * this.radius, t.y = s * this.radius, t.z = 0, e.x = o * h,
                            e.y = s * h, e.z = l, Ct.normalize(e, e), n ? (Ct.scale(e, this.length * n.getFloat(), e),
                                i[16] = n.seed) : Ct.scale(e, this.length * Math.random(), e), Ct.add(t, e, t),
                            this.randomDirection && (n ? (n.seed = i[17], De._randomPointUnitSphere(e, n), i[17] = n.seed) : De._randomPointUnitSphere(e));
                        break;

                    case 3:
                        n ? (n.seed = i[16], De._randomPointUnitCircle(u._tempPositionPoint, n)) : De._randomPointUnitCircle(u._tempPositionPoint),
                            o = a.x, s = a.y, t.x = o * this.radius, t.y = s * this.radius, t.z = 0, e.x = o * h,
                            e.y = s * h, e.z = l, Ct.normalize(e, e), n ? (Ct.scale(e, this.length * n.getFloat(), e),
                                i[16] = n.seed) : Ct.scale(e, this.length * Math.random(), e), Ct.add(t, e, t),
                            this.randomDirection && (n ? (n.seed = i[17], De._randomPointUnitSphere(e, n), i[17] = n.seed) : De._randomPointUnitSphere(e));
                        break;

                    default:
                        throw new Error("ConeShape:emitType is invalid.");
                }
            }, t.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.angle = this.angle, e.radius = this.radius, e.length = this.length, e.emitType = this.emitType,
                    e.randomDirection = this.randomDirection;
            }, _(u, ["_tempPositionPoint", function() {
                return this._tempPositionPoint = new Lt();
            }, "_tempDirectionPoint", function() {
                return this._tempDirectionPoint = new Lt();
            }]), u;
        }(G)),
        We = function(t) {
            function e(t) {
                e.__super.call(this), void 0 === t && (t = .5), this._radius = t, this._type = 1,
                    this._nativeShape = new k._physics3D.btSphereShape(t);
            }
            d(e, "laya.d3.physics.shape.SphereColliderShape", H);
            var n = e.prototype;
            return n.clone = function() {
                var t = new e(this._radius);
                return this.cloneTo(t), t;
            }, u(0, n, "radius", function() {
                return this._radius;
            }), e;
        }(),
        Xe = function(n) {
            function a() {
                this.radius = NaN, this.arc = NaN, this.emitFromEdge = !1, a.__super.call(this),
                    this.radius = 1, this.arc = 2 * Math.PI, this.emitFromEdge = !1, this.randomDirection = !1;
            }
            d(a, "laya.d3.core.particleShuriKen.module.shape.CircleShape", n);
            var t = a.prototype;
            return t._getShapeBoundBox = function(t) {
                var e = t.min;
                e.x = e.z = -this.radius, e.y = 0;
                var n = t.max;
                n.x = n.z = this.radius, n.y = 0;
            }, t._getSpeedBoundBox = function(t) {
                var e = t.min;
                e.x = e.y = -1, e.z = 0;
                var n = t.max;
                n.x = n.y = 1, n.z = 0;
            }, t.generatePositionAndDirection = function(t, e, n, i) {
                var r = a._tempPositionPoint;
                n ? (n.seed = i[16], this.emitFromEdge ? De._randomPointUnitArcCircle(this.arc, a._tempPositionPoint, n) : De._randomPointInsideUnitArcCircle(this.arc, a._tempPositionPoint, n),
                        i[16] = n.seed) : this.emitFromEdge ? De._randomPointUnitArcCircle(this.arc, a._tempPositionPoint) : De._randomPointInsideUnitArcCircle(this.arc, a._tempPositionPoint),
                    t.x = -r.x, t.y = r.y, t.z = 0, Ct.scale(t, this.radius, t), this.randomDirection ? n ? (n.seed = i[17],
                        De._randomPointUnitSphere(e, n), i[17] = n.seed) : De._randomPointUnitSphere(e) : t.cloneTo(e);
            }, t.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.radius = this.radius, e.arc = this.arc, e.emitFromEdge = this.emitFromEdge, e.randomDirection = this.randomDirection;
            }, _(a, ["_tempPositionPoint", function() {
                return this._tempPositionPoint = new Lt();
            }]), a;
        }(G),
        Ye = function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.CastShadowList", K);
            var n = e.prototype;
            return n.add = function(t) {
                if (-1 !== t._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
                this._add(t), t._indexInCastShadowList = this.length++;
            }, n.remove = function(t) {
                var e = t._indexInCastShadowList;
                if (this.length--, e !== this.length) {
                    var n = this.elements[this.length];
                    (this.elements[e] = n)._indexInCastShadowList = e;
                }
                t._indexInCastShadowList = -1;
            }, e;
        }(),
        Ze = function(n) {
            function i(t, e, n) {
                switch (i.__super.call(this), void 0 === t && (t = .5), void 0 === e && (e = 1.25),
                    void 0 === n && (n = 1), this._radius = t, this._length = e, this._orientation = n,
                    this._type = 3, n) {
                    case 0:
                        this._nativeShape = new k._physics3D.btCapsuleShapeX(t, e - 2 * t);
                        break;

                    case 1:
                        this._nativeShape = new k._physics3D.btCapsuleShape(t, e - 2 * t);
                        break;

                    case 2:
                        this._nativeShape = new k._physics3D.btCapsuleShapeZ(t, e - 2 * t);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
            }
            d(i, "laya.d3.physics.shape.CapsuleColliderShape", n);
            var t = i.prototype;
            return t._setScale = function(t) {
                var e = i._tempVector30;
                switch (this.orientation) {
                    case 0:
                        e.x = t.x, e.y = e.z = Math.max(t.y, t.z);
                        break;

                    case 1:
                        e.y = t.y, e.x = e.z = Math.max(t.x, t.z);
                        break;

                    case 2:
                        e.z = t.z, e.x = e.y = Math.max(t.x, t.y);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
                n.prototype._setScale.call(this, e);
            }, t.clone = function() {
                var t = new i(this._radius, this._length, this._orientation);
                return this.cloneTo(t), t;
            }, u(0, t, "radius", function() {
                return this._radius;
            }), u(0, t, "length", function() {
                return this._length;
            }), u(0, t, "orientation", function() {
                return this._orientation;
            }), _(i, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }]), i;
        }(H),
        je = function(t) {
            function l(t, e, n, i) {
                this._renderState = new W(), this._owner = t, this._cacheSharders = [], this._publicValidDefine = 0,
                    this._spriteValidDefine = 0, this._materialValidDefine = 0, this._validDefineMap = {},
                    l.__super.call(this, e, n, null, this._validDefineMap);
                var r = this._owner._publicDefinesMap,
                    a = this._owner._spriteDefinesMap,
                    o = this._owner._materialDefinesMap;
                for (var s in this._validDefineMap) null != r[s] ? this._publicValidDefine |= r[s] : null != a[s] ? this._spriteValidDefine |= a[s] : null != o[s] && (this._materialValidDefine |= o[s]);
                this._stateMap = i;
            }
            d(l, "laya.d3.shader.ShaderPass", x);
            var e = l.prototype;
            return e._definesToNameDic = function(t, e) {
                for (var n = {}, i = 1, r = 0; r < 32 && !(t < (i = 1 << r)); r++) {
                    t & i && (n[e[i]] = "");
                }
                return n;
            }, e._compileToTree = function(t, e, n, i, r) {
                var a, o, s, l, h, u, c, _ = 0,
                    d = 0,
                    f = 0,
                    m = 0;
                for (d = n; d < e.length; d++)
                    if (!((s = e[d]).length < 1) && 0 !== (_ = s.indexOf("//"))) {
                        if (0 <= _ && (s = s.substr(0, _)), a = c || new I(i), c = null, 0 <= (_ = (a.text = s).indexOf("#"))) {
                            for (l = "#", m = _ + 1, f = s.length; m < f; m++) {
                                var p = s.charAt(m);
                                if (" " === p || "\t" === p || "?" === p) break;
                                l += p;
                            }
                            switch (a.name = l) {
                                case "#ifdef":
                                case "#ifndef":
                                    if (a.setParent(t), t = a, r)
                                        for (u = s.substr(m).split(x._splitToWordExps3), m = 0; m < u.length; m++)(s = u[m]).length && (r[s] = !0);
                                    continue;

                                case "#if":
                                case "#elif":
                                    if (a.setParent(t), t = a, r)
                                        for (u = s.substr(m).split(x._splitToWordExps3), m = 0; m < u.length; m++)(s = u[m]).length && "defined" != s && (r[s] = !0);
                                    continue;

                                case "#else":
                                    o = (t = t.parent).childs[t.childs.length - 1], a.setParent(t), t = a;
                                    continue;

                                case "#endif":
                                    o = (t = t.parent).childs[t.childs.length - 1], a.setParent(t);
                                    continue;

                                case "#include":
                                    u = x.splitToWords(s, null);
                                    var T = x.includes[u[1]];
                                    if (!T) throw "ShaderCompile error no this include file:" + u[1];
                                    if ((_ = u[0].indexOf("?")) < 0) {
                                        a.setParent(t), s = T.getWith("with" == u[2] ? u[3] : null), this._compileToTree(a, s.split("\n"), 0, i, r),
                                            a.text = "";
                                        continue;
                                    }
                                    a.setCondition(u[0].substr(_ + 1), 1), a.text = T.getWith("with" == u[2] ? u[3] : null);
                                    break;

                                case "#import":
                                    h = (u = x.splitToWords(s, null))[1], i.push({
                                        node: a,
                                        file: x.includes[h],
                                        ofs: a.text.length
                                    });
                                    continue;
                            }
                        } else {
                            if ((o = t.childs[t.childs.length - 1]) && !o.name) {
                                0 < i.length && x.splitToWords(s, o), c = a, o.text += "\n" + s;
                                continue;
                            }
                            0 < i.length && x.splitToWords(s, a);
                        }
                        a.setParent(t);
                    }
            }, e.withCompile = function(t, e, n) {
                var i, r, a;
                if (t &= this._publicValidDefine, e &= this._spriteValidDefine, n &= this._materialValidDefine,
                    r = this._cacheSharders[t])
                    if (a = r[e]) {
                        if (i = a[n]) return i;
                    } else a = r[e] = [];
                else a = (r = this._cacheSharders[t] = [])[e] = [];
                var o, s = this._definesToNameDic(t, this._owner._publicDefines),
                    l = this._definesToNameDic(e, this._owner._spriteDefines),
                    h = this._definesToNameDic(n, this._owner._materialDefines);
                if (Vt.debugMode) {
                    var u = "";
                    for (o in s) u += o + " ";
                    var c = "";
                    for (o in l) c += o + " ";
                    var _ = "";
                    for (o in h) _ += o + " ";
                    N.shaderHighPrecision || (t += Vt.SHADERDEFINE_HIGHPRECISION), console.log("%cShader3DDebugMode---(Name:" + this._owner._owner._name + " PassIndex:" + this._owner._passes.indexOf(this) + " PublicDefine:" + t + " SpriteDefine:" + e + " MaterialDefine:" + n + " PublicDefineGroup:" + u + " SpriteDefineGroup:" + c + "MaterialDefineGroup: " + _ + ")---ShaderCompile3DDebugMode", "color:green");
                }
                var d = {},
                    f = "";
                if (s)
                    for (o in s) f += "#define " + o + "\n", d[o] = !0;
                if (l)
                    for (o in l) f += "#define " + o + "\n", d[o] = !0;
                if (h)
                    for (o in h) f += "#define " + o + "\n", d[o] = !0;
                var m = this._VS.toscript(d, []),
                    p = "";
                0 == m[0].indexOf("#version") && (p = m[0] + "\n", m.shift());
                var T = this._PS.toscript(d, []),
                    E = "";
                return 0 == T[0].indexOf("#version") && (E = T[0] + "\n", T.shift()), i = new wn(p + f + m.join("\n"), E + f + T.join("\n"), this._owner._attributeMap, this._owner._uniformMap, this),
                    a[n] = i;
            }, u(0, e, "renderState", function() {
                return this._renderState;
            }), l;
        }(),
        Ke = function(t) {
            function e(t) {
                this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null,
                    this._subIndexBufferCount = null, this._skinAnimationDatas = null, this._indexInMesh = 0,
                    this._vertexStart = 0, this._indexStart = 0, this._indexCount = 0, this._indices = null,
                    this._vertexBuffer = null, this._indexBuffer = null, this._id = 0, e.__super.call(this),
                    this._id = ++e._uniqueIDCounter, this._mesh = t, this._boneIndicesList = [], this._subIndexBufferStart = [],
                    this._subIndexBufferCount = [];
            }
            d(e, "laya.d3.resource.models.SubMesh", t);
            var n = e.prototype;
            return n._getType = function() {
                return e._type;
            }, n._render = function(t) {
                this._mesh._bufferState.bind();
                var e = t.renderElement.render._skinnedData;
                if (e)
                    for (var n = e[this._indexInMesh], i = this._boneIndicesList.length, r = 0; r < i; r++) t.shader.uploadCustomUniform(fi.BONES, n[r]),
                        E.instance.drawElements(4, this._subIndexBufferCount[r], 5123, 2 * this._subIndexBufferStart[r]);
                else E.instance.drawElements(4, this._indexCount, 5123, 2 * this._indexStart);
                M.trianglesFaces += this._indexCount / 3, M.renderBatches++;
            }, n.getIndices = function() {
                return this._indices;
            }, n.destroy = function() {
                this._destroyed || (t.prototype.destroy.call(this), this._indexBuffer.destroy(),
                    this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null,
                    this._subIndexBufferCount = null, this._skinAnimationDatas = null);
            }, e._uniqueIDCounter = 0, _(e, ["_type", function() {
                return this._type = Q._typeCounter++;
            }]), e;
        }(Q),
        qe = function(e) {
            function Y(t) {
                Y.__super.call(this), this._tempRotationMatrix = new be(), this._uvLength = new Lt(),
                    this._bufferState = new sn(), this._firstActiveElement = 0, this._firstNewElement = 0,
                    this._firstFreeElement = 0, this._firstRetiredElement = 0, this._owner = t, this._ownerRender = t.particleRenderer,
                    this._boundingBoxCorners = P(8, null), this._boundingSphere = new Tt(new Ct(), Number.MAX_VALUE),
                    this._boundingBox = new we(new Ct(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new Ct(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)),
                    this._currentTime = 0, this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1,
                    this._burstsIndex = 0, this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0,
                    this._simulateUpdate = !1, this._bufferMaxParticles = 1, this.duration = 5, this.looping = !0,
                    this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0,
                    this.startDelayMax = 0, this._startLifetimeType = 0, this._startLifetimeConstant = 5,
                    this._startLifeTimeGradient = new Ht(), this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 5,
                    this._startLifeTimeGradientMin = new Ht(), this._startLifeTimeGradientMax = new Ht(),
                    this._maxStartLifetime = 5, this.startSpeedType = 0, this.startSpeedConstant = 5,
                    this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 5, this.threeDStartSize = !1,
                    this.startSizeType = 0, this.startSizeConstant = 1, this.startSizeConstantSeparate = new Ct(1, 1, 1),
                    this.startSizeConstantMin = 0, this.startSizeConstantMax = 1, this.startSizeConstantMinSeparate = new Ct(0, 0, 0),
                    this.startSizeConstantMaxSeparate = new Ct(1, 1, 1), this.threeDStartRotation = !1,
                    this.startRotationType = 0, this.startRotationConstant = 0, this.startRotationConstantSeparate = new Ct(0, 0, 0),
                    this.startRotationConstantMin = 0, this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = new Ct(0, 0, 0),
                    this.startRotationConstantMaxSeparate = new Ct(0, 0, 0), this.randomizeRotationDirection = 0,
                    this.startColorType = 0, this.startColorConstant = new At(1, 1, 1, 1), this.startColorConstantMin = new At(1, 1, 1, 1),
                    this.startColorConstantMax = new At(1, 1, 1, 1), this.gravityModifier = 0, this.simulationSpace = 1,
                    this.scaleMode = 0, this.playOnAwake = !0, this._rand = new yt(0), this.autoRandomSeed = !0,
                    this.randomSeed = new Uint32Array(1), this._randomSeeds = new Uint32Array(Y._RANDOMOFFSET.length),
                    this.isPerformanceMode = !0, this._emission = new pt(), this._emission.enbale = !0;
            }
            d(Y, "laya.d3.core.particleShuriKen.ShurikenParticleSystem", e);
            var t = Y.prototype;
            return m.imps(t, {
                "laya.d3.core.IClone": !0
            }), t._getVertexBuffer = function(t) {
                return void 0 === t && (t = 0), 0 === t ? this._vertexBuffer : null;
            }, t._getIndexBuffer = function() {
                return this._indexBuffer;
            }, t._generateBoundingSphere = function() {
                var t = this._boundingSphere.center;
                t.x = 0, t.y = 0, t.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
            }, t._generateBoundingBox = function() {
                var t = this._owner.particleRenderer,
                    e = this._boundingBox.min,
                    n = this._boundingBox.max,
                    i = 0,
                    r = 0,
                    a = NaN;
                switch (this.startLifetimeType) {
                    case 0:
                        a = this.startLifetimeConstant;
                        break;

                    case 1:
                        a = -Number.MAX_VALUE;
                        var o = o;
                        for (i = 0, r = o.gradientCount; i < r; i++) a = Math.max(a, o.getValueByIndex(i));
                        break;

                    case 2:
                        a = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        a = -Number.MAX_VALUE;
                        var s = s;
                        for (i = 0, r = s.gradientCount; i < r; i++) a = Math.max(a, s.getValueByIndex(i));
                        var l = l;
                        for (i = 0, r = l.gradientCount; i < r; i++) a = Math.max(a, l.getValueByIndex(i));
                }
                var h, u, c, _, d = NaN,
                    f = NaN;
                switch (this.startSpeedType) {
                    case 0:
                        d = f = this.startSpeedConstant;
                        break;

                    case 1:
                        break;

                    case 2:
                        d = this.startLifetimeConstantMin, f = this.startLifetimeConstantMax;
                }
                this._shape && this._shape.enable || (h = u = Ct._ZERO, c = Ct._ZERO, _ = Ct._UnitZ);
                var m, p, T = new Ct(c.x * d, c.y * d, c.z * d),
                    E = new Ct(_.x * f, _.y * f, _.z * f);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) {
                    var v = this._velocityOverLifetime.velocity;
                    switch (v.type) {
                        case 0:
                            v.constant;
                            break;

                        case 1:
                            new Ct(v.gradientX.getAverageValue(), v.gradientY.getAverageValue(), v.gradientZ.getAverageValue());
                            break;

                        case 2:
                            v.constantMin, v.constantMax;
                            break;

                        case 3:
                            new Ct(v.gradientXMin.getAverageValue(), v.gradientYMin.getAverageValue(), v.gradientZMin.getAverageValue()),
                                new Ct(v.gradientXMax.getAverageValue(), v.gradientYMax.getAverageValue(), v.gradientZMax.getAverageValue());
                    }
                }
                var g, S, y = this._owner.transform,
                    x = y.position,
                    D = Y._tempVector39,
                    I = t.renderMode;
                switch (this.scaleMode) {
                    case 0:
                        var R = y.scale;
                        m = R, D.x = R.x, D.y = R.z, D.z = R.y, 1 === I && (p = R);
                        break;

                    case 1:
                        var M = y.localScale;
                        m = M, D.x = M.x, D.y = M.z, D.z = M.y, 1 === I && (p = M);
                        break;

                    case 2:
                        m = y.scale, D.x = D.y = D.z = 1, 1 === I && (p = Ct._ONE);
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enbale || (g = new Ct(T.x * a, T.y * a, T.z * a),
                    S = new Ct(E.x * a, E.y * a, E.z * a), 2 != this.scaleMode ? (Ct.add(h, g, e), Ct.multiply(m, e, e),
                        Ct.add(u, S, n), Ct.multiply(m, n, n)) : (Ct.multiply(m, h, e), Ct.add(e, g, e),
                        Ct.multiply(m, u, n), Ct.add(n, S, n))), this.simulationSpace) {
                    case 0:
                        break;

                    case 1:
                        Ct.add(e, x, e), Ct.add(n, x, n);
                }
                var A = NaN,
                    C = NaN;
                switch (this.startSizeType) {
                    case 0:
                        if (this.threeDStartSize) {
                            var L = L;
                            A = Math.max(L.x, L.y), 1 === I && (C = L.y);
                        } else A = this.startSizeConstant, 1 === I && (C = this.startSizeConstant);
                        break;

                    case 1:
                        break;

                    case 2:
                        if (this.threeDStartSize) {
                            var O = O;
                            A = Math.max(O.x, O.y), 1 === I && (C = O.y);
                        } else A = this.startSizeConstantMax, 1 === I && (C = this.startSizeConstantMax);
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enbale) {
                    this._sizeOverLifetime.size;
                    A *= this._sizeOverLifetime.size.getMaxSizeInGradient();
                }
                var N = Y._tempVector30,
                    V = NaN,
                    w = NaN;
                switch (I) {
                    case 0:
                        V = A * Y.halfKSqrtOf2, Ct.scale(D, A, N), Ct.subtract(e, N, e), Ct.add(n, N, n);
                        break;

                    case 1:
                        var P = Y._tempVector31,
                            b = Y._tempVector32,
                            F = Y._tempVector33,
                            B = Y._tempVector34;
                        this._velocityOverLifetime && this._velocityOverLifetime.enbale || (Ct.multiply(p, E, b),
                            Ct.multiply(p, T, F));
                        var U = C * t.stretchedBillboardLengthScale,
                            z = Ct.scalarLength(b) * t.stretchedBillboardSpeedScale + U,
                            G = Ct.scalarLength(F) * t.stretchedBillboardSpeedScale + U,
                            H = Y._tempVector35,
                            k = Y._tempVector36;
                        Ct.normalize(b, H), Ct.scale(H, z, B), Ct.subtract(S, B, B), Ct.normalize(F, k),
                            Ct.scale(k, G, P), Ct.add(g, P, P), V = A * Y.halfKSqrtOf2, Ct.scale(D, V, N);
                        var W = Y._tempVector37,
                            X = Y._tempVector38;
                        Ct.scale(H, .5, W), Ct.scale(k, .5, X), Ct.multiply(W, D, W), Ct.multiply(X, D, X),
                            Ct.add(e, X, e), Ct.min(e, B, e), Ct.subtract(e, N, e), Ct.subtract(n, W, n), Ct.max(n, P, n),
                            Ct.add(n, N, n);
                        break;

                    case 2:
                        w = .5 * (A *= Math.cos(.7853981633974483)), N.x = D.x * w, N.y = D.z * w, Ct.subtract(e, N, e),
                            Ct.add(n, N, n);
                        break;

                    case 3:
                        w = .5 * (A *= Math.cos(.7853981633974483)), Ct.scale(D, w, N), Ct.subtract(e, N, e),
                            Ct.add(n, N, n);
                }
                this._boundingBox.getCorners(this._boundingBoxCorners);
            }, t._updateEmission = function() {
                if (this.isAlive)
                    if (this._simulateUpdate) this._simulateUpdate = !1;
                    else {
                        var t = this._startUpdateLoopCount === M.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                        t = Math.min(Y._maxElapsedTime, t), this._updateParticles(t);
                    }
            }, t._updateParticles = function(t) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += t,
                    this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += t,
                    this._totalDelayTime < this._playStartDelay || this._emission.enbale && this._isEmitting && !this._isPaused && this._advanceTime(t, this._currentTime));
            }, t._updateParticlesSimulationRestart = function(t) {
                this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0,
                    this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = t, this._emissionTime = 0,
                    this._totalDelayTime = 0;
                var e = this._currentTime = t;
                e < this._playStartDelay ? this._totalDelayTime = e : this._emission.enbale && this._advanceTime(t, t);
            }, t._retireActiveParticles = function() {
                for (; this._firstActiveElement != this._firstNewElement;) {
                    var t = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride,
                        e = t + this._timeIndex;
                    if (this._currentTime - this._vertices[e] + 1e-4 < this._vertices[t + this._startLifeTimeIndex]) break;
                    this._vertices[e] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
                }
            }, t._freeRetiredParticles = function() {
                for (; this._firstRetiredElement != this._firstActiveElement;) {
                    var t = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && t < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
                }
            }, t._burst = function(t, e) {
                for (var n = 0, i = this._emission._bursts, r = i.length; this._burstsIndex < r; this._burstsIndex++) {
                    var a = i[this._burstsIndex],
                        o = a.time;
                    if (!(t <= o && o < e)) break;
                    var s = 0;
                    this.autoRandomSeed ? s = z.lerp(a.minCount, a.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0],
                            s = z.lerp(a.minCount, a.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed),
                        n += s;
                }
                return n;
            }, t._advanceTime = function(t, e) {
                var n = 0,
                    i = this._emissionTime;
                this._emissionTime += t;
                var r = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (r = Math.min(this.maxParticles - this.aliveParticleCount, r), n = 0; n < r; n++) this.emit(e);
                        return this._isPlaying = !1, void this.stop();
                    }
                    r += this._burst(i, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0,
                        r += this._burst(0, this._emissionTime);
                } else r += this._burst(i, this._emissionTime);
                for (r = Math.min(this.maxParticles - this.aliveParticleCount, r), n = 0; n < r; n++) this.emit(e);
                var a = this.emission.emissionRate;
                if (0 < a) {
                    var o = 1 / a;
                    for (this._frameRateTime += o, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= e && this.emit(this._frameRateTime);) this._frameRateTime += o;
                    this._frameRateTime = Math.floor(e / o) * o;
                }
            }, t._initBufferDatas = function() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy());
                var t = this._ownerRender,
                    e = t.renderMode;
                if (-1 !== e && 0 < this.maxParticles) {
                    var n, i, r = 0,
                        a = 0,
                        o = 0,
                        s = 0,
                        l = 0,
                        h = 0,
                        u = 0,
                        c = t.mesh;
                    if (4 === e) {
                        if (c) {
                            if (1 < c._vertexBuffers.length) throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
                            i = Mn.vertexDeclaration, this._floatCountPerVertex = i.vertexStride / 4, this._startLifeTimeIndex = 12,
                                this._timeIndex = 16, this._vertexStride = c._vertexBuffers[0].vertexCount;
                            var _ = this._bufferMaxParticles * this._vertexStride,
                                d = _ % 65535;
                            if (1 < Math.floor(_ / 65535) + 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            h = i.vertexStride * d, this._vertexBuffer = new rn(h, 35048), this._vertexBuffer.vertexDeclaration = i,
                                this._vertices = new Float32Array(this._floatCountPerVertex * d), this._indexStride = c._indexBuffer.indexCount;
                            var f = c._indexBuffer.getData(),
                                m = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new _n("ushort", m, 35044), n = new Uint16Array(m), u = h + 2 * m,
                                r = s = 0; r < this._bufferMaxParticles; r++) {
                                var p = r * this._vertexStride;
                                for (a = 0, o = f.length; a < o; a++) n[s++] = p + f[a];
                            }
                            this._indexBuffer.setData(n), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                                this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                        }
                    } else {
                        for (i = In.vertexDeclaration, this._floatCountPerVertex = i.vertexStride / 4, this._startLifeTimeIndex = 7,
                            this._timeIndex = 11, this._vertexStride = 4, h = i.vertexStride * this._bufferMaxParticles * this._vertexStride,
                            this._vertexBuffer = new rn(h, 35048), this._vertexBuffer.vertexDeclaration = i,
                            this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride),
                            r = 0; r < this._bufferMaxParticles; r++) l = r * this._floatCountPerVertex * this._vertexStride,
                            this._vertices[l] = -.5, this._vertices[l + 1] = -.5, this._vertices[l + 2] = 0,
                            this._vertices[l + 3] = 1, l += this._floatCountPerVertex, this._vertices[l] = .5,
                            this._vertices[l + 1] = -.5, this._vertices[l + 2] = 1, this._vertices[l + 3] = 1,
                            l += this._floatCountPerVertex, this._vertices[l] = .5, this._vertices[l + 1] = .5,
                            this._vertices[l + 2] = 1, this._vertices[l + 3] = 0, l += this._floatCountPerVertex,
                            this._vertices[l] = -.5, this._vertices[l + 1] = .5, this._vertices[l + 2] = 0,
                            this._vertices[l + 3] = 0;
                        for (this._indexStride = 6, this._indexBuffer = new _n("ushort", 6 * this._bufferMaxParticles, 35044),
                            n = new Uint16Array(6 * this._bufferMaxParticles), r = 0; r < this._bufferMaxParticles; r++) {
                            s = 6 * r;
                            var T = r * this._vertexStride,
                                E = T + 2;
                            n[s++] = T, n[s++] = E, n[s++] = T + 1, n[s++] = T, n[s++] = T + 3, n[s++] = E;
                        }
                        this._indexBuffer.setData(n), u = h + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(),
                            this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer),
                            this._bufferState.unBind();
                    }
                    D._addMemory(u, u);
                }
            }, t.destroy = function() {
                e.prototype.destroy.call(this);
                var t = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                D._addMemory(-t, -t), this._bufferState.destroy(), this._vertexBuffer.destroy(),
                    this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null,
                    this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null,
                    this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null,
                    this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null,
                    this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null,
                    this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null,
                    this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null,
                    this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null,
                    this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
            }, t.emit = function(t) {
                var e = Y._tempPosition,
                    n = Y._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(e, n) : this._shape.generatePositionAndDirection(e, n, this._rand, this._randomSeeds) : (e.x = e.y = e.z = 0,
                    n.x = n.y = 0, n.z = 1), this.addParticle(e, n, t);
            }, t.addParticle = function(t, e, n) {
                Ct.normalize(e, e);
                var i = this._firstFreeElement + 1;
                if (i >= this._bufferMaxParticles && (i = 0), i === this._firstRetiredElement) return !1;
                if (Yt.create(this, this._ownerRender, this._owner.transform), this._currentTime - n >= Yt.startLifeTime) return !0;
                var r = NaN,
                    a = NaN,
                    o = NaN,
                    s = NaN,
                    l = NaN,
                    h = NaN,
                    u = NaN,
                    c = this._velocityOverLifetime && this._velocityOverLifetime.enbale;
                if (c) {
                    var _ = this._velocityOverLifetime.velocity.type;
                    2 === _ || 3 === _ ? this.autoRandomSeed ? (r = Math.random(), a = Math.random(),
                        o = Math.random()) : (this._rand.seed = this._randomSeeds[9], r = this._rand.getFloat(),
                        a = this._rand.getFloat(), o = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : c = !1;
                } else c = !1;
                var d = this._colorOverLifetime && this._colorOverLifetime.enbale;
                d ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? s = Math.random() : (this._rand.seed = this._randomSeeds[10],
                    s = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : d = !1 : d = !1;
                var f = this._sizeOverLifetime && this._sizeOverLifetime.enbale;
                f ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? l = Math.random() : (this._rand.seed = this._randomSeeds[11],
                    l = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : f = !1 : f = !1;
                var m = this._rotationOverLifetime && this._rotationOverLifetime.enbale;
                if (m) {
                    var p = this._rotationOverLifetime.angularVelocity.type;
                    2 === p || 3 === p ? this.autoRandomSeed ? h = Math.random() : (this._rand.seed = this._randomSeeds[12],
                        h = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : m = !1;
                } else m = !1;
                var T = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                T ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? u = Math.random() : (this._rand.seed = this._randomSeeds[15],
                    u = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : T = !1 : T = !1;
                var E, v = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride,
                    g = Yt.startUVInfo[0],
                    S = Yt.startUVInfo[1],
                    y = Yt.startUVInfo[2],
                    x = Yt.startUVInfo[3],
                    D = 0,
                    I = 0,
                    R = 0,
                    M = 0,
                    A = 0,
                    C = this._ownerRender;
                if (4 === C.renderMode) {
                    var L = C.mesh._vertexBuffers[0];
                    E = L.getData();
                    var O = L.vertexDeclaration;
                    I = O.getVertexElementByUsage(0).offset / 4;
                    var N = O.getVertexElementByUsage(1);
                    R = N ? N.offset / 4 : -1;
                    var V = O.getVertexElementByUsage(2);
                    M = V ? V.offset / 4 : -1, D = O.vertexStride / 4, A = 0;
                } else {
                    this._vertices[v + 2] = y, this._vertices[v + 3] = x + S;
                    var w = v + this._floatCountPerVertex;
                    this._vertices[w + 2] = y + g, this._vertices[w + 3] = x + S;
                    var P = w + this._floatCountPerVertex;
                    this._vertices[P + 2] = y + g, this._vertices[P + 3] = x;
                    var b = P + this._floatCountPerVertex;
                    this._vertices[b + 2] = y, this._vertices[b + 3] = x;
                }
                for (var F = v, B = v + this._floatCountPerVertex * this._vertexStride; F < B; F += this._floatCountPerVertex) {
                    var U = 0;
                    if (4 === C.renderMode) {
                        U = F;
                        var z = D * A++,
                            G = z + I;
                        this._vertices[U++] = E[G++], this._vertices[U++] = E[G++], this._vertices[U++] = E[G],
                            this._vertices[U++] = -1 === R ? (this._vertices[U++] = 1, this._vertices[U++] = 1,
                                this._vertices[U++] = 1) : (G = z + R, this._vertices[U++] = E[G++], this._vertices[U++] = E[G++],
                                this._vertices[U++] = E[G++], E[G]), this._vertices[U++] = -1 === M ? this._vertices[U++] = 0 : (G = z + M,
                                this._vertices[U++] = y + E[G++] * g, x + E[G] * S);
                    } else U = F + 4;
                    switch (this._vertices[U++] = t.x, this._vertices[U++] = t.y, this._vertices[U++] = t.z,
                        this._vertices[U++] = Yt.startLifeTime, this._vertices[U++] = e.x, this._vertices[U++] = e.y,
                        this._vertices[U++] = e.z, this._vertices[U++] = n, this._vertices[U++] = Yt.startColor.x,
                        this._vertices[U++] = Yt.startColor.y, this._vertices[U++] = Yt.startColor.z, this._vertices[U++] = Yt.startColor.w,
                        this._vertices[U++] = Yt.startSize[0], this._vertices[U++] = Yt.startSize[1], this._vertices[U++] = Yt.startSize[2],
                        this._vertices[U++] = Yt.startRotation[0], this._vertices[U++] = Yt.startRotation[1],
                        this._vertices[U++] = Yt.startRotation[2], this._vertices[U++] = Yt.startSpeed,
                        d && (this._vertices[U + 1] = s), f && (this._vertices[U + 2] = l), m && (this._vertices[U + 3] = h),
                        T && (this._vertices[U + 4] = u), c && (this._vertices[U + 5] = r, this._vertices[U + 6] = a,
                            this._vertices[U + 7] = o), this.simulationSpace) {
                        case 0:
                            U += 8, this._vertices[U++] = Yt.simulationWorldPostion[0], this._vertices[U++] = Yt.simulationWorldPostion[1],
                                this._vertices[U++] = Yt.simulationWorldPostion[2], this._vertices[U++] = Yt.simulationWorldRotation[0],
                                this._vertices[U++] = Yt.simulationWorldRotation[1], this._vertices[U++] = Yt.simulationWorldRotation[2],
                                this._vertices[U++] = Yt.simulationWorldRotation[3];
                            break;

                        case 1:
                            break;

                        default:
                            throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                }
                return this._firstFreeElement = i, !0;
            }, t.addNewParticlesToVertexBuffer = function() {
                var t = 0;
                this._firstNewElement < this._firstFreeElement ? (t = this._firstNewElement * this._vertexStride * this._floatCountPerVertex,
                        this._vertexBuffer.setData(this._vertices, t, t, (this._firstFreeElement - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex)) : (t = this._firstNewElement * this._vertexStride * this._floatCountPerVertex,
                        this._vertexBuffer.setData(this._vertices, t, t, (this._bufferMaxParticles - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex),
                        0 < this._firstFreeElement && this._vertexBuffer.setData(this._vertices, 0, 0, this._firstFreeElement * this._vertexStride * this._floatCountPerVertex)),
                    this._firstNewElement = this._firstFreeElement;
            }, t._getType = function() {
                return Y._type;
            }, t._prepareRender = function(t) {
                return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(),
                    this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
            }, t._render = function(t) {
                this._bufferState.bind();
                var e = 0,
                    n = E.instance;
                this._firstActiveElement < this._firstFreeElement ? (e = (this._firstFreeElement - this._firstActiveElement) * this._indexStride,
                    n.drawElements(4, e, 5123, 2 * this._firstActiveElement * this._indexStride), M.trianglesFaces += e / 3,
                    M.renderBatches++) : (e = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride,
                    n.drawElements(4, e, 5123, 2 * this._firstActiveElement * this._indexStride), M.trianglesFaces += e / 3,
                    M.renderBatches++, 0 < this._firstFreeElement && (e = this._firstFreeElement * this._indexStride,
                        n.drawElements(4, e, 5123, 0), M.trianglesFaces += e / 3, M.renderBatches++));
            }, t.play = function() {
                if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1,
                    this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed)
                    for (var t = 0, e = this._randomSeeds.length; t < e; t++) this._randomSeeds[t] = this.randomSeed[0] + Y._RANDOMOFFSET[t];
                switch (this.startDelayType) {
                    case 0:
                        this._playStartDelay = this.startDelay;
                        break;

                    case 1:
                        this.autoRandomSeed ? this._playStartDelay = z.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2],
                            this._playStartDelay = z.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()),
                            this._randomSeeds[2] = this._rand.seed);
                        break;

                    default:
                        throw new Error("Utils3D: startDelayType is invalid.");
                }
                this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = M.loopCount;
            }, t.pause = function() {
                this._isPaused = !0;
            }, t.simulate = function(t, e) {
                void 0 === e && (e = !0), this._simulateUpdate = !0, e ? this._updateParticlesSimulationRestart(t) : (this._isPaused = !1,
                    this._updateParticles(t)), this.pause();
            }, t.stop = function() {
                this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
            }, t.cloneTo = function(t) {
                var e = t;
                e.duration = this.duration, e.looping = this.looping, e.prewarm = this.prewarm,
                    e.startDelayType = this.startDelayType, e.startDelay = this.startDelay, e.startDelayMin = this.startDelayMin,
                    e.startDelayMax = this.startDelayMax, e._maxStartLifetime = this._maxStartLifetime,
                    e.startLifetimeType = this.startLifetimeType, e.startLifetimeConstant = this.startLifetimeConstant,
                    this.startLifeTimeGradient.cloneTo(e.startLifeTimeGradient), e.startLifetimeConstantMin = this.startLifetimeConstantMin,
                    e.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(e.startLifeTimeGradientMin),
                    this.startLifeTimeGradientMax.cloneTo(e.startLifeTimeGradientMax), e.startSpeedType = this.startSpeedType,
                    e.startSpeedConstant = this.startSpeedConstant, e.startSpeedConstantMin = this.startSpeedConstantMin,
                    e.startSpeedConstantMax = this.startSpeedConstantMax, e.threeDStartSize = this.threeDStartSize,
                    e.startSizeType = this.startSizeType, e.startSizeConstant = this.startSizeConstant,
                    this.startSizeConstantSeparate.cloneTo(e.startSizeConstantSeparate), e.startSizeConstantMin = this.startSizeConstantMin,
                    e.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(e.startSizeConstantMinSeparate),
                    this.startSizeConstantMaxSeparate.cloneTo(e.startSizeConstantMaxSeparate), e.threeDStartRotation = this.threeDStartRotation,
                    e.startRotationType = this.startRotationType, e.startRotationConstant = this.startRotationConstant,
                    this.startRotationConstantSeparate.cloneTo(e.startRotationConstantSeparate), e.startRotationConstantMin = this.startRotationConstantMin,
                    e.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(e.startRotationConstantMinSeparate),
                    this.startRotationConstantMaxSeparate.cloneTo(e.startRotationConstantMaxSeparate),
                    e.randomizeRotationDirection = this.randomizeRotationDirection, e.startColorType = this.startColorType,
                    this.startColorConstant.cloneTo(e.startColorConstant), this.startColorConstantMin.cloneTo(e.startColorConstantMin),
                    this.startColorConstantMax.cloneTo(e.startColorConstantMax), e.gravityModifier = this.gravityModifier,
                    e.simulationSpace = this.simulationSpace, e.scaleMode = this.scaleMode, e.playOnAwake = this.playOnAwake,
                    e.maxParticles = this.maxParticles, this._emission && (e._emission = this._emission.clone()),
                    this.shape && (e.shape = this.shape.clone()), this.velocityOverLifetime && (e.velocityOverLifetime = this.velocityOverLifetime.clone()),
                    this.colorOverLifetime && (e.colorOverLifetime = this.colorOverLifetime.clone()),
                    this.sizeOverLifetime && (e.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (e.rotationOverLifetime = this.rotationOverLifetime.clone()),
                    this.textureSheetAnimation && (e.textureSheetAnimation = this.textureSheetAnimation.clone()),
                    e.isPerformanceMode = this.isPerformanceMode, e._isEmitting = this._isEmitting,
                    e._isPlaying = this._isPlaying, e._isPaused = this._isPaused, e._playStartDelay = this._playStartDelay,
                    e._frameRateTime = this._frameRateTime, e._emissionTime = this._emissionTime, e._totalDelayTime = this._totalDelayTime,
                    e._burstsIndex = this._burstsIndex;
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, t, "maxParticles", function() {
                return this._bufferMaxParticles - 1;
            }, function(t) {
                var e = t + 1;
                e !== this._bufferMaxParticles && (this._bufferMaxParticles = e, this._initBufferDatas());
            }), u(0, t, "isEmitting", function() {
                return this._isEmitting;
            }), u(0, t, "isAlive", function() {
                return !!(this._isPlaying || 0 < this.aliveParticleCount);
            }), u(0, t, "shape", function() {
                return this._shape;
            }, function(t) {
                this._shape !== t && (t && t.enable ? this._owner._render._defineDatas.add(_i.SHADERDEFINE_SHAPE) : this._owner._render._defineDatas.remove(_i.SHADERDEFINE_SHAPE),
                    this._shape = t);
            }), u(0, t, "rotationOverLifetime", function() {
                return this._rotationOverLifetime;
            }, function(t) {
                var e = this._owner._render._defineDatas,
                    n = this._owner._render._shaderValues;
                if (t) {
                    var i = t.angularVelocity;
                    if (!i) return;
                    var r = i.separateAxes,
                        a = i.type;
                    if (t.enbale) switch (r ? e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIME),
                        a) {
                        case 0:
                            e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;

                        case 2:
                            e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            break;

                        case 3:
                            e.add(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    } else e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIME), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                        e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                        e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (a) {
                        case 0:
                            r ? n.setVector3(_i.ROLANGULARVELOCITYCONSTSEPRARATE, i.constantSeparate) : n.setNumber(_i.ROLANGULARVELOCITYCONST, i.constant);
                            break;

                        case 1:
                            r ? (n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTX, i.gradientX._elements), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTY, i.gradientY._elements),
                                n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTZ, i.gradientZ._elements)) : n.setBuffer(_i.ROLANGULARVELOCITYGRADIENT, i.gradient._elements);
                            break;

                        case 2:
                            r ? (n.setVector3(_i.ROLANGULARVELOCITYCONSTSEPRARATE, i.constantMinSeparate), n.setVector3(_i.ROLANGULARVELOCITYCONSTMAXSEPRARATE, i.constantMaxSeparate)) : (n.setNumber(_i.ROLANGULARVELOCITYCONST, i.constantMin),
                                n.setNumber(_i.ROLANGULARVELOCITYCONSTMAX, i.constantMax));
                            break;

                        case 3:
                            r ? (n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTX, i.gradientXMin._elements), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTXMAX, i.gradientXMax._elements),
                                n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTY, i.gradientYMin._elements), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTYMAX, i.gradientYMax._elements),
                                n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTZ, i.gradientZMin._elements), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTZMAX, i.gradientZMax._elements)) : (n.setBuffer(_i.ROLANGULARVELOCITYGRADIENT, i.gradientMin._elements),
                                n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTMAX, i.gradientMax._elements));
                    }
                } else e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIME), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                    e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                    e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), e.remove(_i.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES),
                    n.setVector(_i.ROLANGULARVELOCITYCONSTSEPRARATE, null), n.setVector(_i.ROLANGULARVELOCITYCONSTMAXSEPRARATE, null),
                    n.setNumber(_i.ROLANGULARVELOCITYCONST, void 0), n.setNumber(_i.ROLANGULARVELOCITYCONSTMAX, void 0),
                    n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTX, null), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTXMAX, null),
                    n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTY, null), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTYMAX, null),
                    n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTZ, null), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTZMAX, null),
                    n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTWMAX, null), n.setBuffer(_i.ROLANGULARVELOCITYGRADIENT, null),
                    n.setBuffer(_i.ROLANGULARVELOCITYGRADIENTMAX, null);
                this._rotationOverLifetime = t;
            }), u(0, t, "emission", function() {
                return this._emission;
            }), u(0, t, "emissionTime", function() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime;
            }), u(0, t, "aliveParticleCount", function() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
            }), u(0, t, "isPlaying", function() {
                return this._isPlaying;
            }), u(0, t, "isPaused", function() {
                return this._isPaused;
            }), u(0, t, "startLifetimeType", function() {
                return this._startLifetimeType;
            }, function(t) {
                var e = 0,
                    n = 0;
                switch (this.startLifetimeType) {
                    case 0:
                        this._maxStartLifetime = this.startLifetimeConstant;
                        break;

                    case 1:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var i = i;
                        for (e = 0, n = i.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(e));
                        break;

                    case 2:
                        this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var r = r;
                        for (e = 0, n = r.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, r.getValueByIndex(e));
                        var a = a;
                        for (e = 0, n = a.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(e));
                }
                this._startLifetimeType = t;
            }), u(0, t, "startLifetimeConstant", function() {
                return this._startLifetimeConstant;
            }, function(t) {
                0 === this._startLifetimeType && (this._maxStartLifetime = t), this._startLifetimeConstant = t;
            }), u(0, t, "startLifetimeConstantMin", function() {
                return this._startLifetimeConstantMin;
            }, function(t) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(t, this._startLifetimeConstantMax)),
                    this._startLifetimeConstantMin = t;
            }), u(0, t, "startLifeTimeGradient", function() {
                return this._startLifeTimeGradient;
            }, function(t) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var e = 0, n = t.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, t.getValueByIndex(e));
                }
                this._startLifeTimeGradient = t;
            }), u(0, t, "startLifetimeConstantMax", function() {
                return this._startLifetimeConstantMax;
            }, function(t) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, t)),
                    this._startLifetimeConstantMax = t;
            }), u(0, t, "startLifeTimeGradientMin", function() {
                return this._startLifeTimeGradientMin;
            }, function(t) {
                if (3 === this._startLifetimeType) {
                    var e = 0,
                        n = 0;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, e = 0, n = t.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, t.getValueByIndex(e));
                    for (e = 0, n = this._startLifeTimeGradientMax.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(e));
                }
                this._startLifeTimeGradientMin = t;
            }), u(0, t, "startLifeTimeGradientMax", function() {
                return this._startLifeTimeGradientMax;
            }, function(t) {
                if (3 === this._startLifetimeType) {
                    var e = 0,
                        n = 0;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, e = 0, n = this._startLifeTimeGradientMin.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(e));
                    for (e = 0, n = t.gradientCount; e < n; e++) this._maxStartLifetime = Math.max(this._maxStartLifetime, t.getValueByIndex(e));
                }
                this._startLifeTimeGradientMax = t;
            }), u(0, t, "velocityOverLifetime", function() {
                return this._velocityOverLifetime;
            }, function(t) {
                var e = this._owner._render._defineDatas,
                    n = this._owner._render._shaderValues;
                if (t) {
                    var i = t.velocity,
                        r = i.type;
                    if (t.enbale) switch (r) {
                        case 0:
                            e.add(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            e.add(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;

                        case 2:
                            e.add(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;

                        case 3:
                            e.add(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    } else e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                        e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (r) {
                        case 0:
                            n.setVector3(_i.VOLVELOCITYCONST, i.constant);
                            break;

                        case 1:
                            n.setBuffer(_i.VOLVELOCITYGRADIENTX, i.gradientX._elements), n.setBuffer(_i.VOLVELOCITYGRADIENTY, i.gradientY._elements),
                                n.setBuffer(_i.VOLVELOCITYGRADIENTZ, i.gradientZ._elements);
                            break;

                        case 2:
                            n.setVector3(_i.VOLVELOCITYCONST, i.constantMin), n.setVector3(_i.VOLVELOCITYCONSTMAX, i.constantMax);
                            break;

                        case 3:
                            n.setBuffer(_i.VOLVELOCITYGRADIENTX, i.gradientXMin._elements), n.setBuffer(_i.VOLVELOCITYGRADIENTXMAX, i.gradientXMax._elements),
                                n.setBuffer(_i.VOLVELOCITYGRADIENTY, i.gradientYMin._elements), n.setBuffer(_i.VOLVELOCITYGRADIENTYMAX, i.gradientYMax._elements),
                                n.setBuffer(_i.VOLVELOCITYGRADIENTZ, i.gradientZMin._elements), n.setBuffer(_i.VOLVELOCITYGRADIENTZMAX, i.gradientZMax._elements);
                    }
                    n.setInt(_i.VOLSPACETYPE, t.space);
                } else e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                    e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), e.remove(_i.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE),
                    n.setVector(_i.VOLVELOCITYCONST, null), n.setBuffer(_i.VOLVELOCITYGRADIENTX, null),
                    n.setBuffer(_i.VOLVELOCITYGRADIENTY, null), n.setBuffer(_i.VOLVELOCITYGRADIENTZ, null),
                    n.setVector(_i.VOLVELOCITYCONST, null), n.setVector(_i.VOLVELOCITYCONSTMAX, null),
                    n.setBuffer(_i.VOLVELOCITYGRADIENTX, null), n.setBuffer(_i.VOLVELOCITYGRADIENTXMAX, null),
                    n.setBuffer(_i.VOLVELOCITYGRADIENTY, null), n.setBuffer(_i.VOLVELOCITYGRADIENTYMAX, null),
                    n.setBuffer(_i.VOLVELOCITYGRADIENTZ, null), n.setBuffer(_i.VOLVELOCITYGRADIENTZMAX, null),
                    n.setInt(_i.VOLSPACETYPE, void 0);
                this._velocityOverLifetime = t;
            }), u(0, t, "colorOverLifetime", function() {
                return this._colorOverLifetime;
            }, function(t) {
                var e = this._owner._render._defineDatas,
                    n = this._owner._render._shaderValues;
                if (t) {
                    var i = t.color;
                    if (t.enbale) switch (i.type) {
                        case 1:
                            e.add(_i.SHADERDEFINE_COLOROVERLIFETIME);
                            break;

                        case 3:
                            e.add(_i.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    } else e.remove(_i.SHADERDEFINE_COLOROVERLIFETIME), e.remove(_i.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (i.type) {
                        case 1:
                            var r = i.gradient;
                            n.setBuffer(_i.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), n.setBuffer(_i.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements);
                            break;

                        case 3:
                            var a = i.gradientMin,
                                o = i.gradientMax;
                            n.setBuffer(_i.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), n.setBuffer(_i.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements),
                                n.setBuffer(_i.MAXCOLOROVERLIFEGRADIENTALPHAS, o._alphaElements), n.setBuffer(_i.MAXCOLOROVERLIFEGRADIENTCOLORS, o._rgbElements);
                    }
                } else e.remove(_i.SHADERDEFINE_COLOROVERLIFETIME), e.remove(_i.SHADERDEFINE_RANDOMCOLOROVERLIFETIME),
                    n.setBuffer(_i.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), n.setBuffer(_i.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements),
                    n.setBuffer(_i.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), n.setBuffer(_i.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements),
                    n.setBuffer(_i.MAXCOLOROVERLIFEGRADIENTALPHAS, o._alphaElements), n.setBuffer(_i.MAXCOLOROVERLIFEGRADIENTCOLORS, o._rgbElements);
                this._colorOverLifetime = t;
            }), u(0, t, "sizeOverLifetime", function() {
                return this._sizeOverLifetime;
            }, function(t) {
                var e = this._owner._render._defineDatas,
                    n = this._owner._render._shaderValues;
                if (t) {
                    var i = t.size,
                        r = i.separateAxes,
                        a = i.type;
                    if (t.enbale) switch (a) {
                        case 0:
                            r ? e.add(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : e.add(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;

                        case 2:
                            r ? e.add(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : e.add(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                    } else e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVE), e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                        e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (a) {
                        case 0:
                            r ? (n.setBuffer(_i.SOLSIZEGRADIENTX, i.gradientX._elements), n.setBuffer(_i.SOLSIZEGRADIENTY, i.gradientY._elements),
                                n.setBuffer(_i.SOLSizeGradientZ, i.gradientZ._elements)) : n.setBuffer(_i.SOLSIZEGRADIENT, i.gradient._elements);
                            break;

                        case 2:
                            r ? (n.setBuffer(_i.SOLSIZEGRADIENTX, i.gradientXMin._elements), n.setBuffer(_i.SOLSIZEGRADIENTXMAX, i.gradientXMax._elements),
                                n.setBuffer(_i.SOLSIZEGRADIENTY, i.gradientYMin._elements), n.setBuffer(_i.SOLSIZEGRADIENTYMAX, i.gradientYMax._elements),
                                n.setBuffer(_i.SOLSizeGradientZ, i.gradientZMin._elements), n.setBuffer(_i.SOLSizeGradientZMAX, i.gradientZMax._elements)) : (n.setBuffer(_i.SOLSIZEGRADIENT, i.gradientMin._elements),
                                n.setBuffer(_i.SOLSizeGradientMax, i.gradientMax._elements));
                    }
                } else e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVE), e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                    e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), e.remove(_i.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE),
                    n.setBuffer(_i.SOLSIZEGRADIENTX, null), n.setBuffer(_i.SOLSIZEGRADIENTXMAX, null),
                    n.setBuffer(_i.SOLSIZEGRADIENTY, null), n.setBuffer(_i.SOLSIZEGRADIENTYMAX, null),
                    n.setBuffer(_i.SOLSizeGradientZ, null), n.setBuffer(_i.SOLSizeGradientZMAX, null),
                    n.setBuffer(_i.SOLSIZEGRADIENT, null), n.setBuffer(_i.SOLSizeGradientMax, null);
                this._sizeOverLifetime = t;
            }), u(0, t, "textureSheetAnimation", function() {
                return this._textureSheetAnimation;
            }, function(t) {
                var e = this._owner._render._defineDatas,
                    n = this._owner._render._shaderValues;
                if (t) {
                    var i = t.frame,
                        r = i.type;
                    if (t.enable) switch (r) {
                        case 1:
                            e.add(_i.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;

                        case 3:
                            e.add(_i.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    } else e.remove(_i.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), e.remove(_i.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === r || 3 === r) {
                        n.setNumber(_i.TEXTURESHEETANIMATIONCYCLES, t.cycles);
                        var a = t.tiles,
                            o = this._uvLength;
                        o.x = 1 / a.x, o.y = 1 / a.y, n.setVector2(_i.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                    }
                    switch (r) {
                        case 1:
                            n.setBuffer(_i.TEXTURESHEETANIMATIONGRADIENTUVS, i.frameOverTimeData._elements);
                            break;

                        case 3:
                            n.setBuffer(_i.TEXTURESHEETANIMATIONGRADIENTUVS, i.frameOverTimeDataMin._elements),
                                n.setBuffer(_i.TEXTURESHEETANIMATIONGRADIENTMAXUVS, i.frameOverTimeDataMax._elements);
                    }
                } else e.remove(_i.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), e.remove(_i.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE),
                    n.setNumber(_i.TEXTURESHEETANIMATIONCYCLES, void 0), n.setVector(_i.TEXTURESHEETANIMATIONSUBUVLENGTH, null),
                    n.setBuffer(_i.TEXTURESHEETANIMATIONGRADIENTUVS, null), n.setBuffer(_i.TEXTURESHEETANIMATIONGRADIENTMAXUVS, null);
                this._textureSheetAnimation = t;
            }), Y.halfKSqrtOf2 = .71, _(Y, ["_RANDOMOFFSET", function() {
                return this._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]);
            }, "_maxElapsedTime", function() {
                return this._maxElapsedTime = 1 / 3;
            }, "_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }, "_tempVector32", function() {
                return this._tempVector32 = new Ct();
            }, "_tempVector33", function() {
                return this._tempVector33 = new Ct();
            }, "_tempVector34", function() {
                return this._tempVector34 = new Ct();
            }, "_tempVector35", function() {
                return this._tempVector35 = new Ct();
            }, "_tempVector36", function() {
                return this._tempVector36 = new Ct();
            }, "_tempVector37", function() {
                return this._tempVector37 = new Ct();
            }, "_tempVector38", function() {
                return this._tempVector38 = new Ct();
            }, "_tempVector39", function() {
                return this._tempVector39 = new Ct();
            }, "_tempPosition", function() {
                return this._tempPosition = new Ct();
            }, "_tempDirection", function() {
                return this._tempDirection = new Ct();
            }, "_type", function() {
                return this._type = Q._typeCounter++;
            }]), Y;
        }(Q),
        Qe = function(t) {
            function e() {
                this._instanceBatchOpaqueMarks = [], this._vertexBatchOpaqueMarks = [], this._cacheBufferStates = [],
                    e.__super.call(this), fn.instance = new fn(), this._updateCountMark = 0;
            }
            d(e, "laya.d3.graphics.MeshRenderDynamicBatchManager", t);
            var n = e.prototype;
            return n.getInstanceBatchOpaquaMark = function(t, e, n, i) {
                var r = this._instanceBatchOpaqueMarks[t] || (this._instanceBatchOpaqueMarks[t] = []),
                    a = r[e ? 0 : 1] || (r[e ? 0 : 1] = []),
                    o = a[n] || (a[n] = []);
                return o[i] || (o[i] = new _e());
            }, n.getVertexBatchOpaquaMark = function(t, e, n, i) {
                var r = this._vertexBatchOpaqueMarks[t] || (this._vertexBatchOpaqueMarks[t] = []),
                    a = r[e ? 0 : 1] || (r[e ? 0 : 1] = []),
                    o = a[n] || (a[n] = []);
                return o[i] || (o[i] = new _e());
            }, n._getBufferState = function(t) {
                var e = this._cacheBufferStates[t.id];
                if (!e) {
                    var n = fn.instance;
                    (e = new sn()).bind();
                    var i = n._vertexBuffer;
                    i.vertexDeclaration = t, e.applyVertexBuffer(i), e.applyIndexBuffer(n._indexBuffer),
                        e.unBind(), this._cacheBufferStates[t.id] = e;
                }
                return e;
            }, n._getBatchRenderElementFromPool = function() {
                var t = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return t || (t = new Rn(), (this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = t).vertexBatchElementList = [],
                    t.instanceBatchElementList = []), t;
            }, n._clear = function() {
                t.prototype._clear.call(this), this._updateCountMark++;
            }, _(e, ["instance", function() {
                return this.instance = new e();
            }]), e;
        }(q),
        Je = (function(t) {
            function n(t, e) {
                n.__super.call(this), this._normal = t, this._offset = e, this._type = 6, n._nativeNormal.setValue(-t.x, t.y, t.z),
                    this._nativeShape = new k._physics3D.btStaticPlaneShape(n._nativeNormal, e);
            }
            d(n, "laya.d3.physics.shape.StaticPlaneColliderShape", H), n.prototype.clone = function() {
                var t = new n(this._normal, this._offset);
                return this.cloneTo(t), t;
            }, _(n, ["_nativeNormal", function() {
                return this._nativeNormal = new k._physics3D.btVector3(0, 0, 0);
            }]);
        }(), function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.component.SimpleSingletonList", K);
            var n = e.prototype;
            return n.add = function(t) {
                if (-1 !== t._getIndexInList()) throw "SimpleSingletonList:" + t + " has  in  SingletonList.";
                this._add(t), t._setIndexInList(this.length++);
            }, n.remove = function(t) {
                var e = t._getIndexInList();
                if (this.length--, e !== this.length) {
                    var n = this.elements[this.length];
                    (this.elements[e] = n)._setIndexInList(e);
                }
                t._setIndexInList(-1);
            }, e;
        }()),
        $e = function(t) {
            function i(t, e, n) {
                i.__super.call(this), void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === n && (n = 1),
                    this._sizeX = t, this._sizeY = e, this._sizeZ = n, this._type = 0, i._nativeSize.setValue(t / 2, e / 2, n / 2),
                    this._nativeShape = new k._physics3D.btBoxShape(i._nativeSize);
            }
            d(i, "laya.d3.physics.shape.BoxColliderShape", H);
            var e = i.prototype;
            return e.clone = function() {
                var t = new i(this._sizeX, this._sizeY, this._sizeZ);
                return this.cloneTo(t), t;
            }, u(0, e, "sizeX", function() {
                return this._sizeX;
            }), u(0, e, "sizeY", function() {
                return this._sizeY;
            }), u(0, e, "sizeZ", function() {
                return this._sizeZ;
            }), _(i, ["_nativeSize", function() {
                return this._nativeSize = new k._physics3D.btVector3(0, 0, 0);
            }]), i;
        }(),
        tn = function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.physics.PhysicsUpdateList", K);
            var n = e.prototype;
            return n.add = function(t) {
                if (-1 !== t._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                this._add(t), t._inPhysicUpdateListIndex = this.length++;
            }, n.remove = function(t) {
                var e = t._inPhysicUpdateListIndex;
                if (this.length--, e !== this.length) {
                    var n = this.elements[this.length];
                    (this.elements[e] = n)._inPhysicUpdateListIndex = e;
                }
                t._inPhysicUpdateListIndex = -1;
            }, e;
        }(),
        en = function(t) {
            function w(t, e, n) {
                w.__super.call(this), this._bufferState = new sn(), this._batchID = w._batchIDCounter++,
                    this._batchElements = [], this._currentBatchVertexCount = 0, this._currentBatchIndexCount = 0,
                    this._vertexDeclaration = n, this.batchOwner = t, this.number = e;
            }
            d(w, "laya.d3.graphics.SubMeshStaticBatch", Q);
            var e = w.prototype;
            return m.imps(e, {
                "laya.resource.IDispose": !0
            }), e._getStaticBatchBakedVertexs = function(t, e, n, i, r, a) {
                var o, s = a._vertexBuffers[0],
                    l = s.vertexDeclaration,
                    h = l.getVertexElementByUsage(0).offset / 4,
                    u = l.getVertexElementByUsage(3),
                    c = u ? u.offset / 4 : -1,
                    _ = l.getVertexElementByUsage(1),
                    d = _ ? _.offset / 4 : -1,
                    f = l.getVertexElementByUsage(2),
                    m = f ? f.offset / 4 : -1,
                    p = l.getVertexElementByUsage(7),
                    T = p ? p.offset / 4 : -1,
                    E = l.getVertexElementByUsage(4),
                    v = E ? E.offset / 4 : -1,
                    g = l.vertexStride / 4,
                    S = s.getData();
                n ? (n.worldMatrix.invert(w._tempMatrix4x40), o = w._tempMatrix4x41, be.multiply(w._tempMatrix4x40, i.worldMatrix, o)) : o = i.worldMatrix;
                var y = w._tempQuaternion0;
                o.decomposeTransRotScale(w._tempVector30, y, w._tempVector31);
                for (var x = r.lightmapScaleOffset, D = a.vertexCount, I = 0; I < D; I++) {
                    var R = I * g,
                        M = 18 * (I + e);
                    Gt.transformVector3ArrayToVector3ArrayCoordinate(S, R + h, o, t, M + 0), -1 !== c && Gt.transformVector3ArrayByQuat(S, R + c, y, t, M + 3);
                    var A = 0,
                        C = 0,
                        L = M + 6;
                    if (-1 !== d) {
                        var O = R + d;
                        for (A = 0, C = 4; A < C; A++) t[L + A] = S[O + A];
                    } else
                        for (A = 0, C = 4; A < C; A++) t[L + A] = 1;
                    if (-1 !== m) {
                        var N = R + m;
                        t[M + 10] = S[N], t[M + 11] = S[N + 1];
                    }
                    if (x && (-1 !== T ? Gt.transformLightingMapTexcoordArray(S, R + T, x, t, M + 12) : Gt.transformLightingMapTexcoordArray(S, R + m, x, t, M + 12)), -1 !== v) {
                        var V = R + v;
                        t[M + 14] = S[V], t[M + 15] = S[V + 1], t[M + 16] = S[V + 2], t[M + 17] = S[V + 3];
                    }
                }
                return D;
            }, e.addTest = function(t) {
                var e = t.meshFilter.sharedMesh.vertexCount;
                return !(65535 < this._currentBatchVertexCount + e);
            }, e.add = function(t) {
                var e = t._render._staticBatch;
                e && e.remove(t);
                var n = t.meshFilter.sharedMesh,
                    i = n.vertexCount;
                this._batchElements.push(t);
                var r = t._render;
                r._isPartOfStaticBatch = !0, r._staticBatch = this;
                for (var a = r._renderElements, o = 0, s = a.length; o < s; o++) a[o].staticBatch = this;
                this._currentBatchIndexCount += n._indexBuffer.indexCount, this._currentBatchVertexCount += i;
            }, e.remove = function(t) {
                var e = t.meshFilter.sharedMesh,
                    n = this._batchElements.indexOf(t);
                if (-1 !== n) {
                    this._batchElements.splice(n, 1);
                    t._render;
                    for (var i = t._render._renderElements, r = 0, a = i.length; r < a; r++) i[r].staticBatch = null;
                    var o = e.vertexCount;
                    this._currentBatchIndexCount = this._currentBatchIndexCount - e._indexBuffer.indexCount,
                        this._currentBatchVertexCount = this._currentBatchVertexCount - o, t._render._isPartOfStaticBatch = !1;
                }
            }, e.finishInit = function() {
                this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy());
                var t = 0,
                    e = 0,
                    n = this.batchOwner,
                    i = this._vertexDeclaration.vertexStride / 4,
                    r = new Float32Array(i * this._currentBatchVertexCount),
                    a = new Uint16Array(this._currentBatchIndexCount);
                this._vertexBuffer = new rn(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, 35044),
                    this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new _n("ushort", this._currentBatchIndexCount, 35044);
                for (var o = 0, s = this._batchElements.length; o < s; o++) {
                    for (var l = this._batchElements[o], h = l.meshFilter.sharedMesh, u = this._getStaticBatchBakedVertexs(r, t, n ? n._transform : null, l._transform, l._render, h), c = h._indexBuffer.getData(), _ = t, d = e + c.length, f = l._render._renderElements, m = 0, p = h.subMeshCount; m < p; m++) {
                        var T = h._subMeshes[m],
                            E = e + T._indexStart,
                            v = f[m];
                        v.staticBatchIndexStart = E, v.staticBatchIndexEnd = E + T._indexCount;
                    }
                    a.set(c, e);
                    var g = 0;
                    if (n ? l._transform._isFrontFaceInvert !== n.transform._isFrontFaceInvert : l._transform._isFrontFaceInvert)
                        for (g = e; g < d; g += 3) {
                            a[g] = _ + a[g];
                            var S = a[g + 1],
                                y = a[g + 2];
                            a[g + 1] = _ + y, a[g + 2] = _ + S;
                        } else
                            for (g = e; g < d; g += 3) a[g] = _ + a[g], a[g + 1] = _ + a[g + 1], a[g + 2] = _ + a[g + 2];
                    e += c.length, t += u;
                }
                this._vertexBuffer.setData(r), this._indexBuffer.setData(a);
                var x = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                D._addGPUMemory(x), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                    this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
            }, e._render = function(t) {
                this._bufferState.bind();
                for (var e = t.renderElement.staticBatchElementList, n = 0, i = 0, r = e.length, a = 1; a < r; a++) {
                    if (e[a - 1].staticBatchIndexEnd !== e[a].staticBatchIndexStart) {
                        var o = e[n].staticBatchIndexStart,
                            s = e[i].staticBatchIndexEnd - o;
                        E.instance.drawElements(4, s, 5123, 2 * o), n = ++i, M.trianglesFaces += s / 3;
                    } else i++;
                }
                o = e[n].staticBatchIndexStart, s = e[i].staticBatchIndexEnd - o, E.instance.drawElements(4, s, 5123, 2 * o),
                    M.renderBatches++, M.savedRenderBatches += r - 1, M.trianglesFaces += s / 3;
            }, e.dispose = function() {
                var t = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                D._addGPUMemory(-t), this._batchElements = null, this.batchOwner = null, this._vertexDeclaration = null,
                    this._bufferState.destroy(), this._vertexBuffer.destroy(), this._indexBuffer.destroy(),
                    this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = null;
            }, w.maxBatchVertexCount = 65535, w._batchIDCounter = 0, _(w, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }, "_tempQuaternion0", function() {
                return this._tempQuaternion0 = new rt();
            }, "_tempMatrix4x40", function() {
                return this._tempMatrix4x40 = new be();
            }, "_tempMatrix4x41", function() {
                return this._tempMatrix4x41 = new be();
            }]), w;
        }(),
        nn = function(e) {
            function l(t) {
                this._floatCountPerVertices1 = 8, this._floatCountPerVertices2 = 1, this._increaseSegementCount = 128,
                    this._activeIndex = 0, this._endIndex = 0, this._needAddFirstVertex = !1, this._isTempEndVertex = !1,
                    this._subBirthTime = null, this._subDistance = null, this._segementCount = 0, this._vertices1 = null,
                    this._vertices2 = null, this._vertexBuffer1 = null, this._vertexBuffer2 = null,
                    this._owner = null, l.__super.call(this), this._lastFixedVertexPosition = new Ct(),
                    this._bufferState = new sn(), this._owner = t, this._resizeData(this._increaseSegementCount, this._bufferState);
            }
            d(l, "laya.d3.core.trail.TrailGeometry", e);
            var t = l.prototype;
            return t._resizeData = function(t, e) {
                this._segementCount = this._increaseSegementCount, this._subBirthTime = new Float32Array(t),
                    this._subDistance = new Float32Array(t);
                var n = 2 * t,
                    i = $t.vertexDeclaration1,
                    r = $t.vertexDeclaration2,
                    a = [],
                    o = n * i.vertexStride,
                    s = n * r.vertexStride,
                    l = o + s;
                this._vertices1 = new Float32Array(n * this._floatCountPerVertices1), this._vertexBuffer1 = new rn(o, 35044, !1),
                    this._vertexBuffer1.vertexDeclaration = i, this._vertices2 = new Float32Array(n * this._floatCountPerVertices2),
                    this._vertexBuffer2 = new rn(s, 35048, !1), this._vertexBuffer2.vertexDeclaration = r,
                    a.push(this._vertexBuffer1), a.push(this._vertexBuffer2), e.bind(), e.applyVertexBuffers(a),
                    e.unBind(), D._addMemory(l, l);
            }, t._resetData = function() {
                var t = this._endIndex - this._activeIndex;
                t == this._segementCount && (this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy(),
                        this._segementCount += this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState)),
                    this._vertexBuffer1.setData(this._vertices1, 0, 2 * this._floatCountPerVertices1 * this._activeIndex, 2 * this._floatCountPerVertices1 * t),
                    this._vertexBuffer2.setData(this._vertices2, 0, 2 * this._floatCountPerVertices2 * this._activeIndex, 2 * this._floatCountPerVertices2 * t);
                var e = 4 * this._activeIndex,
                    n = new Float32Array(this._subDistance.buffer, e, t),
                    i = new Float32Array(this._subBirthTime.buffer, e, t);
                this._subDistance.set(n, 0), this._subBirthTime.set(i, 0), this._endIndex = t, this._activeIndex = 0;
            }, t._updateTrail = function(t, e, n) {
                Ct.equals(e, n) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(t, n) : this._addTrailByNextPosition(t, n));
            }, t._addTrailByFirstPosition = function(t, e) {
                this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0,
                    this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, e.cloneTo(this._lastFixedVertexPosition),
                    this._needAddFirstVertex = !0;
            }, t._addTrailByNextPosition = function(t, e) {
                var n = l._tempVector30,
                    i = l._tempVector31;
                Ct.subtract(e, this._lastFixedVertexPosition, n);
                var r = l._tempVector32;
                switch (this._owner.alignment) {
                    case 0:
                        t.transform.getForward(r), Ct.cross(n, r, i);
                        break;

                    case 1:
                        this._owner._owner.transform.getForward(r), Ct.cross(n, r, i);
                }
                Ct.normalize(i, i), Ct.scale(i, this._owner.widthMultiplier / 2, i);
                var a = Ct.scalarLength(n),
                    o = 0,
                    s = NaN;
                this._needAddFirstVertex && (this._updateVerticesByPositionData(e, i, this._endIndex - 1),
                    this._needAddFirstVertex = !1), a - this._owner.minVertexDistance >= $.zeroTolerance ? (this._isTempEndVertex ? (o = this._endIndex - 1,
                    s = a - this._subDistance[o], this._updateVerticesByPosition(e, i, a, o), this._owner._totalLength += s) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(e, i, a, this._endIndex), this._owner._totalLength += a,
                    this._endIndex++), e.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (o = this._endIndex - 1,
                    s = a - this._subDistance[o], this._updateVerticesByPosition(e, i, a, o), this._owner._totalLength += s) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(e, i, a, this._endIndex), this._owner._totalLength += a,
                    this._endIndex++), this._isTempEndVertex = !0);
            }, t._updateVerticesByPositionData = function(t, e, n) {
                var i = 2 * this._floatCountPerVertices1 * n,
                    r = this._owner._curtime;
                this._vertices1[i] = t.x, this._vertices1[i + 1] = t.y, this._vertices1[i + 2] = t.z,
                    this._vertices1[i + 3] = -e.x, this._vertices1[i + 4] = -e.y, this._vertices1[i + 5] = -e.z,
                    this._vertices1[i + 6] = r, this._vertices1[i + 7] = 1, this._vertices1[i + 8] = t.x,
                    this._vertices1[i + 9] = t.y, this._vertices1[i + 10] = t.z, this._vertices1[i + 11] = e.x,
                    this._vertices1[i + 12] = e.y, this._vertices1[i + 13] = e.z, this._vertices1[i + 14] = r,
                    this._vertices1[i + 15] = 0;
                var a = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1, i, i, a);
            }, t._updateVerticesByPosition = function(t, e, n, i) {
                this._updateVerticesByPositionData(t, e, i), this._subDistance[i] = n, this._subBirthTime[i] = this._owner._curtime;
            }, t._updateVertexBufferUV = function() {
                for (var t = this._endIndex, e = 0, n = this._activeIndex, i = t; n < i; n++) {
                    n !== this._activeIndex && (e += this._subDistance[n]);
                    var r = NaN;
                    r = 0 == this._owner.textureMode ? 1 - e / this._owner._totalLength : 1 - (this._owner._totalLength - e),
                        this._vertices2[2 * n] = r, this._vertices2[2 * n + 1] = r;
                }
                var a = 2 * this._activeIndex;
                this._vertexBuffer2.setData(this._vertices2, a, a, 2 * t - a);
            }, t._updateDisappear = function() {
                for (var t = this._endIndex, e = this._activeIndex; e < t && this._owner._curtime - this._subBirthTime[e] >= this._owner.time + $.zeroTolerance; e++) {
                    var n = e + 1;
                    if (n !== t && (this._owner._totalLength -= this._subDistance[n]), this._isTempEndVertex && n === t - 1) {
                        this._floatCountPerVertices1;
                        var i = this._lastFixedVertexPosition;
                        i.x = this._vertices1[0], i.y = this._vertices1[1], i.z = this._vertices1[2], this._isTempEndVertex = !1;
                    }
                    this._activeIndex++;
                }
            }, t._getType = function() {
                return l._type;
            }, t._prepareRender = function(t) {
                return 1 < this._endIndex - this._activeIndex;
            }, t._render = function(t) {
                this._bufferState.bind();
                var e = 2 * this._activeIndex,
                    n = 2 * this._endIndex - e;
                E.instance.drawArrays(5, e, n), M.renderBatches++, M.trianglesFaces += n - 2;
            }, t.destroy = function() {
                e.prototype.destroy.call(this);
                var t = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                D._addMemory(-t, -t), this._bufferState.destroy(), this._vertexBuffer1.destroy(),
                    this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null,
                    this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null,
                    this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null;
            }, _(l, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }, "_tempVector32", function() {
                return this._tempVector32 = new Ct();
            }, "_type", function() {
                return this._type = Q._typeCounter++;
            }]), l;
        }(Q),
        rn = function(t) {
            function r(t, e, n, i) {
                if (this._vertexCount = 0, this._canRead = !1, this._dataType = 0, this._vertexDeclaration = null,
                    void 0 === n && (n = !1), void 0 === i && (i = 0), r.__super.call(this), this._vertexCount = -1,
                    this._bufferUsage = e, this._bufferType = 34962, this._canRead = n, this._dataType = i,
                    this._byteLength = t, this.bind(), E.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage),
                    n) switch (i) {
                    case 0:
                        this._buffer = new Float32Array(t / 4);
                        break;

                    case 1:
                        this._buffer = new Uint8Array(t);
                }
            }
            d(r, "laya.d3.graphics.VertexBuffer3D", t);
            var e = r.prototype;
            return e.bind = function() {
                return i._bindedVertexBuffer !== this._glBuffer && (E.instance.bindBuffer(34962, this._glBuffer),
                    i._bindedVertexBuffer = this._glBuffer, !0);
            }, e.setData = function(t, e, n, i) {
                if (void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 4294967295),
                    this.bind(), 0 !== n || 4294967295 !== i) switch (this._dataType) {
                    case 0:
                        t = new Float32Array(t.buffer, 4 * n, i);
                        break;

                    case 1:
                        t = new Uint8Array(t.buffer, n, i);
                }
                switch (this._dataType) {
                    case 0:
                        E.instance.bufferSubData(this._bufferType, 4 * e, t);
                        break;

                    case 1:
                        E.instance.bufferSubData(this._bufferType, e, t);
                }
                this._canRead && this._buffer.set(t, e);
            }, e.getData = function() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }, e.destroy = function() {
                t.prototype.destroy.call(this), this._buffer = null, this._vertexDeclaration = null;
            }, u(0, e, "vertexDeclaration", function() {
                return this._vertexDeclaration;
            }, function(t) {
                this._vertexDeclaration !== t && (this._vertexDeclaration = t, this._vertexCount = t ? this._byteLength / t.vertexStride : -1);
            }), u(0, e, "vertexCount", function() {
                return this._vertexCount;
            }), u(0, e, "canRead", function() {
                return this._canRead;
            }), r.DATATYPE_FLOAT32ARRAY = 0, r.DATATYPE_UINT8ARRAY = 1, r;
        }(i),
        an = function(i) {
            function r() {
                r.__super.call(this), this._childColliderShapes = [], this._type = 5, this._nativeShape = new k._physics3D.btCompoundShape();
            }
            d(r, "laya.d3.physics.shape.CompoundColliderShape", i);
            var t = r.prototype;
            return t._clearChildShape = function(t) {
                t._attatched = !1, t._compoundParent = null, t._indexInCompound = -1;
            }, t._addReference = function() {}, t._removeReference = function() {}, t._updateChildTransform = function(t) {
                var e = t.localOffset,
                    n = t.localRotation,
                    i = H._nativeVector30,
                    r = H._nativQuaternion0,
                    a = H._nativeTransform0;
                i.setValue(-e.x, e.y, e.z), r.setValue(-n.x, n.y, n.z, -n.w), a.setOrigin(i), a.setRotation(r),
                    this._nativeShape.updateChildTransform(t._indexInCompound, a, !0);
            }, t.addChildShape = function(t) {
                if (t._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
                t._attatched = !0, t._compoundParent = this, t._indexInCompound = this._childColliderShapes.length,
                    this._childColliderShapes.push(t);
                var e = t.localOffset,
                    n = t.localRotation;
                r._nativeOffset.setValue(-e.x, e.y, e.z), r._nativRotation.setValue(-n.x, n.y, n.z, -n.w),
                    r._nativeTransform.setOrigin(r._nativeOffset), r._nativeTransform.setRotation(r._nativRotation);
                var i = this._nativeShape.getLocalScaling();
                this._nativeShape.setLocalScaling(r._nativeVector3One), this._nativeShape.addChildShape(r._nativeTransform, t._nativeShape),
                    this._nativeShape.setLocalScaling(i), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
            }, t.removeChildShape = function(t) {
                if (t._compoundParent === this) {
                    var e = t._indexInCompound;
                    this._clearChildShape(t);
                    var n = this._childColliderShapes[this._childColliderShapes.length - 1];
                    n._indexInCompound = e, this._childColliderShapes[e] = n, this._childColliderShapes.pop(),
                        this._nativeShape.removeChildShapeByIndex(e);
                }
            }, t.clearChildShape = function() {
                for (var t = 0, e = this._childColliderShapes.length; t < e; t++) this._clearChildShape(this._childColliderShapes[t]),
                    this._nativeShape.removeChildShapeByIndex(0);
                this._childColliderShapes.length = 0;
            }, t.getChildShapeCount = function() {
                return this._childColliderShapes.length;
            }, t.cloneTo = function(t) {
                var e = t;
                e.clearChildShape();
                for (var n = 0, i = this._childColliderShapes.length; n < i; n++) e.addChildShape(this._childColliderShapes[n].clone());
            }, t.clone = function() {
                var t = new r();
                return this.cloneTo(t), t;
            }, t.destroy = function() {
                i.prototype.destroy.call(this);
                for (var t = 0, e = this._childColliderShapes.length; t < e; t++) {
                    var n = this._childColliderShapes[t];
                    0 === n._referenceCount && n.destroy();
                }
            }, _(r, ["_nativeVector3One", function() {
                return this._nativeVector3One = new k._physics3D.btVector3(1, 1, 1);
            }, "_nativeTransform", function() {
                return this._nativeTransform = new k._physics3D.btTransform();
            }, "_nativeOffset", function() {
                return this._nativeOffset = new k._physics3D.btVector3(0, 0, 0);
            }, "_nativRotation", function() {
                return this._nativRotation = new k._physics3D.btQuaternion(0, 0, 0, 1);
            }]), r;
        }(H),
        on = function(t) {
            function i(t, e) {
                this._floatCountPerVertices = 7, this._owner = null, this._vertexBuffer = null,
                    this._vertices = null, this._maxLineCount = 0, this._lineCount = 0, i.__super.call(this),
                    this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE, this._bufferState = new sn();
                var n = 2 * e;
                this._owner = t, this._maxLineCount = e, this._vertices = new Float32Array(n * this._floatCountPerVertices),
                    this._vertexBuffer = new rn(kt.vertexDeclaration.vertexStride * n, 35044, !1), this._vertexBuffer.vertexDeclaration = kt.vertexDeclaration,
                    this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                    this._bufferState.unBind();
            }
            d(i, "laya.d3.core.pixelLine.PixelLineFilter", t);
            var e = i.prototype;
            return e._resizeLineData = function(t) {
                var e = 2 * t,
                    n = this._vertices;
                this._vertexBuffer.destroy(), this._maxLineCount = t;
                var i = e * this._floatCountPerVertices;
                this._vertices = new Float32Array(i), this._vertexBuffer = new rn(kt.vertexDeclaration.vertexStride * e, 35044, !1),
                    this._vertexBuffer.vertexDeclaration = kt.vertexDeclaration, i < n.length ? (this._vertices.set(new Float32Array(n.buffer, 0, i)),
                        this._vertexBuffer.setData(this._vertices, 0, 0, i)) : (this._vertices.set(n), this._vertexBuffer.setData(this._vertices, 0, 0, n.length)),
                    this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                    this._bufferState.unBind();
            }, e._updateLineVertices = function(t, e, n, i, r) {
                this._vertices[t + 0] = e.x, this._vertices[t + 1] = e.y, this._vertices[t + 2] = e.z,
                    this._vertices[t + 3] = i.r, this._vertices[t + 4] = i.g, this._vertices[t + 5] = i.b,
                    this._vertices[t + 6] = i.a, this._vertices[t + 7] = n.x, this._vertices[t + 8] = n.y,
                    this._vertices[t + 9] = n.z, this._vertices[t + 10] = r.r, this._vertices[t + 11] = r.g,
                    this._vertices[t + 12] = r.b, this._vertices[t + 13] = r.a, this._minUpdate = Math.min(this._minUpdate, t),
                    this._maxUpdate = Math.max(this._maxUpdate, t + 2 * this._floatCountPerVertices);
            }, e._removeLineData = function(t) {
                var e = 2 * this._floatCountPerVertices,
                    n = t + 1,
                    i = t * e,
                    r = new Float32Array(this._vertices.buffer, n * e * 4, (this._lineCount - n) * e);
                this._vertices.set(r, i), this._minUpdate = i, this._maxUpdate = i + 2 * this._floatCountPerVertices,
                    this._lineCount--;
            }, e._updateLineData = function(t, e, n, i, r) {
                var a = t * (2 * this._floatCountPerVertices);
                this._updateLineVertices(a, e, n, i, r);
            }, e._updateLineDatas = function(t, e) {
                for (var n = 2 * this._floatCountPerVertices, i = e.length, r = 0; r < i; r++) {
                    var a = e[r];
                    this._updateLineVertices((t + r) * n, a.startPosition, a.endPosition, a.startColor, a.endColor);
                }
            }, e._getLineData = function(t, e) {
                var n = e.startPosition,
                    i = e.startColor,
                    r = e.endPosition,
                    a = e.endColor,
                    o = this._vertices,
                    s = t * this._floatCountPerVertices * 2;
                n.x = o[s + 0], n.y = o[s + 1], n.z = o[s + 2], i.r = o[s + 3], i.g = o[s + 4],
                    i.b = o[s + 5], i.a = o[s + 6], r.x = o[s + 7], r.y = o[s + 8], r.z = o[s + 9],
                    a.r = o[s + 10], a.g = o[s + 11], a.b = o[s + 12], a.a = o[s + 13];
            }, e._prepareRender = function(t) {
                return !0;
            }, e._render = function(t) {
                this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices, this._minUpdate, this._minUpdate, this._maxUpdate - this._minUpdate),
                    this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), 0 < this._lineCount && (this._bufferState.bind(),
                    E.instance.drawArrays(1, 0, 2 * this._lineCount), M.renderBatches++);
            }, e.destroy = function() {
                this._destroyed || (t.prototype.destroy.call(this), this._bufferState.destroy(),
                    this._vertexBuffer.destroy(), this._bufferState = null, this._vertexBuffer = null,
                    this._vertices = null);
            }, i;
        }(Q),
        sn = function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.core.BufferState", c);
            var n = e.prototype;
            return n.applyVertexBuffer = function(t) {
                if (c._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var e = E.instance,
                    n = t.vertexDeclaration,
                    i = null;
                for (var r in i = b.supportWebGLPlusRendering ? n._shaderValues._nativeArray : n._shaderValues.getData(),
                        t.bind(), i) {
                    var a = parseInt(r),
                        o = i[r];
                    e.enableVertexAttribArray(a), e.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]);
                }
            }, n.applyVertexBuffers = function(t) {
                if (c._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                for (var e = E.instance, n = 0, i = t.length; n < i; n++) {
                    var r = t[n],
                        a = r.vertexDeclaration,
                        o = null;
                    for (var s in o = b.supportWebGLPlusRendering ? a._shaderValues._nativeArray : a._shaderValues.getData(),
                            r.bind(), o) {
                        var l = parseInt(s),
                            h = o[s];
                        e.enableVertexAttribArray(l), e.vertexAttribPointer(l, h[0], h[1], !!h[2], h[3], h[4]);
                    }
                }
            }, n.applyInstanceVertexBuffer = function(t) {
                if (V._angleInstancedArrays) {
                    if (c._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                    var e = E.instance,
                        n = t.vertexDeclaration,
                        i = null;
                    for (var r in i = b.supportWebGLPlusRendering ? n._shaderValues._nativeArray : n._shaderValues.getData(),
                            t.bind(), i) {
                        var a = parseInt(r),
                            o = i[r];
                        e.enableVertexAttribArray(a), e.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]),
                            V._angleInstancedArrays.vertexAttribDivisorANGLE(a, 1);
                    }
                }
            }, n.applyIndexBuffer = function(t) {
                if (c._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== t && (t._bindForVAO(), this._bindedIndexBuffer = t);
            }, e;
        }(),
        ln = function(t) {
            function i(t, e, n) {
                switch (this._radius = 1, this._height = .5, i.__super.call(this), void 0 === t && (t = .5),
                    void 0 === e && (e = 1), void 0 === n && (n = 1), this._radius = t, this._height = e,
                    this._orientation = n, this._type = 2, n) {
                    case 0:
                        i._nativeSize.setValue(e / 2, t, t), this._nativeShape = new k._physics3D.btCylinderShapeX(i._nativeSize);
                        break;

                    case 1:
                        i._nativeSize.setValue(t, e / 2, t), this._nativeShape = new k._physics3D.btCylinderShape(i._nativeSize);
                        break;

                    case 2:
                        i._nativeSize.setValue(t, t, e / 2), this._nativeShape = new k._physics3D.btCylinderShapeZ(i._nativeSize);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
            }
            d(i, "laya.d3.physics.shape.CylinderColliderShape", H);
            var e = i.prototype;
            return e.clone = function() {
                var t = new i(this._radius, this._height, this._orientation);
                return this.cloneTo(t), t;
            }, u(0, e, "radius", function() {
                return this._radius;
            }), u(0, e, "height", function() {
                return this._height;
            }), u(0, e, "orientation", function() {
                return this._orientation;
            }), _(i, ["_nativeSize", function() {
                return this._nativeSize = new k._physics3D.btVector3(0, 0, 0);
            }]), i;
        }(),
        hn = function(t) {
            function e() {
                this.maxInstanceCount = 1024, e.__super.call(this), this.instanceWorldMatrixData = new Float32Array(16 * this.maxInstanceCount),
                    this.instanceMVPMatrixData = new Float32Array(16 * this.maxInstanceCount), this.instanceWorldMatrixBuffer = new rn(4 * this.instanceWorldMatrixData.length, 35048),
                    this.instanceMVPMatrixBuffer = new rn(4 * this.instanceMVPMatrixData.length, 35048),
                    this.instanceWorldMatrixBuffer.vertexDeclaration = mt.instanceWorldMatrixDeclaration,
                    this.instanceMVPMatrixBuffer.vertexDeclaration = mt.instanceMVPMatrixDeclaration;
            }
            return d(e, "laya.d3.graphics.SubMeshInstanceBatch", Q), e.prototype._render = function(t) {
                var e = t.renderElement,
                    n = e.instanceSubMesh,
                    i = e.instanceBatchElementList.length,
                    r = n._indexCount;
                n._mesh._instanceBufferState.bind(), V._angleInstancedArrays.drawElementsInstancedANGLE(4, r, 5123, 2 * n._indexStart, i),
                    M.renderBatches++, M.savedRenderBatches += i - 1, M.trianglesFaces += r * i / 3;
            }, _(e, ["instance", function() {
                return this.instance = new e();
            }]), e;
        }(),
        un = function(n) {
            function t() {
                t.__super.call(this);
            }
            return d(t, "laya.d3.core.FloatKeyframe", n), t.prototype.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.inTangent = this.inTangent, e.outTangent = this.outTangent, e.value = this.value;
            }, t;
        }(lt),
        cn = function(t) {
            function e() {
                e.__super.call(this);
            }
            d(e, "laya.d3.core.scene.OctreeMotionList", K);
            var n = e.prototype;
            return n.add = function(t) {
                if (-1 !== t._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
                this._add(t), t._setIndexInMotionList(this.length++);
            }, n.remove = function(t) {
                var e = t._getIndexInMotionList();
                if (this.length--, e !== this.length) {
                    var n = this.elements[this.length];
                    (this.elements[e] = n)._inPhysicUpdateListIndex = e;
                }
                t._setIndexInMotionList(-1);
            }, e;
        }(),
        _n = function(t) {
            function o(t, e, n, i) {
                this._indexType = null, this._indexTypeByteCount = 0, this._indexCount = 0, this._canRead = !1,
                    void 0 === n && (n = 35044), void 0 === i && (i = !1), o.__super.call(this), this._indexType = t,
                    this._indexCount = e, this._bufferUsage = n, this._bufferType = 34963, this._canRead = i;
                var r;
                if ("ushort" == t) this._indexTypeByteCount = 2;
                else {
                    if ("ubyte" != t) throw new Error("unidentification index type.");
                    this._indexTypeByteCount = 1;
                }
                r = this._indexTypeByteCount * e, this._byteLength = r;
                var a = c._curBindedBufferState;
                a ? a._bindedIndexBuffer === this ? E.instance.bufferData(this._bufferType, r, this._bufferUsage) : (a.unBind(),
                    this.bind(), E.instance.bufferData(this._bufferType, r, this._bufferUsage), a.bind()) : (this.bind(),
                    E.instance.bufferData(this._bufferType, r, this._bufferUsage)), i && ("ushort" == t ? this._buffer = new Uint16Array(e) : "ubyte" == t && (this._buffer = new Uint8Array(e)));
            }
            d(o, "laya.d3.graphics.IndexBuffer3D", t);
            var e = o.prototype;
            return e._bindForVAO = function() {
                if (!c._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
                E.instance.bindBuffer(34963, this._glBuffer);
            }, e.bind = function() {
                if (c._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
                return i._bindedIndexBuffer !== this._glBuffer && (E.instance.bindBuffer(34963, this._glBuffer),
                    i._bindedIndexBuffer = this._glBuffer, !0);
            }, e.setData = function(t, e, n, i) {
                void 0 === e && (e = 0), void 0 === n && (n = 0), void 0 === i && (i = 4294967295);
                var r = 0;
                "ushort" == this._indexType ? (r = 2, 0 === n && 4294967295 === i || (t = new Uint16Array(t.buffer, n * r, i))) : "ubyte" == this._indexType && (r = 1,
                    0 === n && 4294967295 === i || (t = new Uint8Array(t.buffer, n * r, i)));
                var a = c._curBindedBufferState;
                if (a ? a._bindedIndexBuffer === this ? E.instance.bufferSubData(this._bufferType, e * r, t) : (a.unBind(),
                        this.bind(), E.instance.bufferSubData(this._bufferType, e * r, t), a.bind()) : (this.bind(),
                        E.instance.bufferSubData(this._bufferType, e * r, t)), this._canRead)
                    if (0 !== e || 0 !== n || 4294967295 !== i) {
                        var o = this._buffer.length - e;
                        o < i && (i = o);
                        for (var s = 0; s < i; s++) this._buffer[e + s] = t[s];
                    } else this._buffer = t;
            }, e.getData = function() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }, e.destroy = function() {
                t.prototype.destroy.call(this), this._buffer = null;
            }, u(0, e, "indexType", function() {
                return this._indexType;
            }), u(0, e, "indexTypeByteCount", function() {
                return this._indexTypeByteCount;
            }), u(0, e, "indexCount", function() {
                return this._indexCount;
            }), u(0, e, "canRead", function() {
                return this._canRead;
            }), o.INDEXTYPE_UBYTE = "ubyte", o.INDEXTYPE_USHORT = "ushort", o;
        }(i),
        dn = function(t) {
            function r() {
                this._opaqueBatchMarks = [], r.__super.call(this), this._updateCountMark = 0;
            }
            d(r, "laya.d3.graphics.MeshRenderStaticBatchManager", t);
            var e = r.prototype;
            return e._compare = function(t, e) {
                var n = t._render,
                    i = e._render,
                    r = t.meshFilter.sharedMesh,
                    a = e.meshFilter.sharedMesh,
                    o = n.lightmapIndex - i.lightmapIndex;
                if (0 !== o) return o;
                var s = (n.receiveShadow ? 1 : 0) - (i.receiveShadow ? 1 : 0);
                if (0 !== s) return s;
                var l = n.sharedMaterial.id - i.sharedMaterial.id;
                if (0 !== l) return l;
                var h = r._vertexBuffers[0].vertexDeclaration.id - a._vertexBuffers[0].vertexDeclaration.id;
                return 0 === h ? a._indexBuffer.indexCount - r._indexBuffer.indexCount : h;
            }, e._getBatchRenderElementFromPool = function() {
                var t = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return t || (t = new Rn(), (this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = t).staticBatchElementList = []),
                    t;
            }, e._getStaticBatch = function(t, e) {
                var n = t ? t.id : 0,
                    i = this._staticBatches[n];
                return i || (i = this._staticBatches[n] = []), i[e] || (i[e] = new en(t, e, r._verDec));
            }, e._initStaticBatchs = function(t) {
                this._quickSort(this._initBatchSprites, 0, this._initBatchSprites.length - 1);
                for (var e, n = !1, i = 0, r = 0, a = this._initBatchSprites.length; r < a; r++) {
                    var o = this._initBatchSprites[r];
                    if (n) e.addTest(o) ? e.add(o) : (n = !1, i++);
                    else r !== a - 1 && ((e = this._getStaticBatch(t, i)).add(o),
                        n = !0);
                }
                for (var s in this._staticBatches) {
                    var l = this._staticBatches[s];
                    for (r = 0, a = l.length; r < a; r++) l[r].finishInit();
                }
                this._initBatchSprites.length = 0;
            }, e._destroyRenderSprite = function(t) {
                var e = t._render._staticBatch;
                if (e.remove(t), 0 === e._batchElements.length) {
                    var n = e.batchOwner,
                        i = n ? n.id : 0,
                        r = this._staticBatches[i];
                    r[e.number] = null, e.dispose();
                    for (var a = !0, o = 0; o < r.length; o++) r[o] && (a = !1);
                    a && delete this._staticBatches[i];
                }
            }, e._clear = function() {
                t.prototype._clear.call(this), this._updateCountMark++;
            }, e._garbageCollection = function() {
                for (var t in this._staticBatches)
                    for (var e = this._staticBatches[t], n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        0 === r._batchElements.length && (r.dispose(), e.splice(n, 1), n--, 0 === --i && delete this._staticBatches[t]);
                    }
            }, e.getBatchOpaquaMark = function(t, e, n, i) {
                var r = this._opaqueBatchMarks[t] || (this._opaqueBatchMarks[t] = []),
                    a = r[e] || (r[e] = []),
                    o = a[n] || (a[n] = []);
                return o[i] || (o[i] = new _e());
            }, _(r, ["_verDec", function() {
                return this._verDec = mt.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
            }, "instance", function() {
                return this.instance = new r();
            }]), r;
        }(Z),
        fn = function(t) {
            function n() {
                this._vertices = null, this._indices = null, this._positionOffset = 0, this._normalOffset = 0,
                    this._colorOffset = 0, this._uv0Offset = 0, this._uv1Offset = 0, this._sTangentOffset = 0,
                    this._vertexBuffer = null, this._indexBuffer = null, n.__super.call(this), this._bufferState = new sn();
                var t = 32e3 * mt.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride;
                this._vertices = new Float32Array(t / 4), this._vertexBuffer = new rn(t, 35048),
                    this._indices = new Int16Array(32e3), this._indexBuffer = new _n("ushort", this._indices.length, 35048);
                var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                D._addMemory(e, e);
            }
            d(n, "laya.d3.graphics.SubMeshDynamicBatch", Q);
            var e = n.prototype;
            return e._getBatchVertices = function(t, e, n, i, r, a) {
                    var o = t.vertexStride / 4,
                        s = a._vertexBuffer.getData(),
                        l = (r.render.lightmapScaleOffset,
                            r._dynamicMultiSubMesh),
                        h = r._dynamicVertexCount;
                    r._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, h);
                    for (var u = r._dynamicWorldPositions, c = r._dynamicWorldNormals, _ = a._indices, d = 0; d < h; d++) {
                        var f = (l ? _[d] : d) * o,
                            m = (d + n) * o,
                            p = 3 * d,
                            T = m + this._positionOffset;
                        e[T] = u[p], e[T + 1] = u[p + 1], e[T + 2] = u[p + 2], -1 !== this._normalOffset && (e[T = m + this._normalOffset] = c[p],
                            e[T + 1] = c[p + 1], e[T + 2] = c[p + 2]), -1 !== this._colorOffset && (T = m + this._colorOffset,
                            p = f + this._colorOffset, e[T] = s[p], e[T + 1] = s[p + 1], e[T + 2] = s[p + 2],
                            e[T + 3] = s[p + 3]), -1 !== this._uv0Offset && (T = m + this._uv0Offset, p = f + this._uv0Offset,
                            e[T] = s[p], e[T + 1] = s[p + 1]), -1 !== this._sTangentOffset && (T = m + this._sTangentOffset,
                            p = f + this._sTangentOffset, e[T] = s[p], e[T + 1] = s[p + 1], e[T + 2] = s[p + 2],
                            e[T + 3] = s[p + 3], T = m + this._sTangentOffset, p = f + this._sTangentOffset,
                            e[T] = s[p], e[T + 1] = s[p + 1], e[T + 2] = s[p + 2], e[T + 3] = s[p + 3]);
                    }
                }, e._getBatchIndices = function(t, e, n, i, r, a) {
                    var o = r._indices,
                        s = 0,
                        l = 0,
                        h = 0,
                        u = i._isFrontFaceInvert;
                    if (a)
                        if (u)
                            for (s = 0, l = o.length; s < l; s += 3) {
                                var c = n + s;
                                t[h = e + s] = c, t[h + 1] = c + 2, t[h + 2] = c + 1;
                            } else
                                for (s = l, l = o.length; s < l; s += 3) c = n + s, t[h = e + s] = c, t[h + 1] = c + 1,
                                    t[h + 2] = c + 2;
                        else if (u)
                        for (s = 0, l = o.length; s < l; s += 3) t[h = e + s] = n + o[s],
                            t[h + 1] = n + o[s + 2], t[h + 2] = n + o[s + 1];
                    else
                        for (s = l, l = o.length; s < l; s += 3) t[h = e + s] = n + o[s],
                            t[h + 1] = n + o[s + 1], t[h + 2] = n + o[s + 2];
                }, e._flush = function(t, e) {
                    this._vertexBuffer.setData(this._vertices, 0, 0, t * (this._vertexBuffer.vertexDeclaration.vertexStride / 4)),
                        this._indexBuffer.setData(this._indices, 0, 0, e), E.instance.drawElements(4, e, 5123, 0);
                }, e._prepareRender = function(t) {
                    var e = t.renderElement.vertexBatchVertexDeclaration;
                    this._bufferState = Qe.instance._getBufferState(e), this._positionOffset = e.getVertexElementByUsage(0).offset / 4;
                    var n = e.getVertexElementByUsage(3);
                    this._normalOffset = n ? n.offset / 4 : -1;
                    var i = e.getVertexElementByUsage(1);
                    this._colorOffset = i ? i.offset / 4 : -1;
                    var r = e.getVertexElementByUsage(2);
                    this._uv0Offset = r ? r.offset / 4 : -1;
                    var a = e.getVertexElementByUsage(7);
                    this._uv1Offset = a ? a.offset / 4 : -1;
                    var o = e.getVertexElementByUsage(4);
                    return this._sTangentOffset = o ? o.offset / 4 : -1, !0;
                }, e._render = function(t) {
                    this._bufferState.bind();
                    for (var e = t.renderElement, n = e.vertexBatchVertexDeclaration, i = e.vertexBatchElementList, r = 0, a = 0, o = (n.vertexStride,
                            0), s = i.length, l = 0; l < s; l++) {
                        var h = i[l],
                            u = h._geometry,
                            c = u._indexCount;
                        32e3 < a + c && (this._flush(r, a), o++, M.trianglesFaces += a / 3, r = a = 0);
                        var _ = h._transform;
                        this._getBatchVertices(n, this._vertices, r, _, h, u), this._getBatchIndices(this._indices, a, r, _, u, h._dynamicMultiSubMesh),
                            r += h._dynamicVertexCount, a += c;
                    }
                    this._flush(r, a), o++, M.renderBatches += o, M.savedRenderBatches += s - o, M.trianglesFaces += a / 3;
                }, n.maxAllowVertexCount = 10, n.maxAllowAttribueCount = 900, n.maxIndicesCount = 32e3,
                n.instance = null, n;
        }(),
        mn = function(t) {
            function r() {
                r.__super.call(this);
                var t = new Float32Array([-.5, .5, -.5, .5, .5, -.5, .5, .5, .5, -.5, .5, .5, -.5, -.5, -.5, .5, -.5, -.5, .5, -.5, .5, -.5, -.5, .5]),
                    e = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0]),
                    n = mt.getVertexDeclaration("POSITION");
                this._vertexBuffer = new rn(8 * n.vertexStride, 35044, !1), this._vertexBuffer.vertexDeclaration = n,
                    this._indexBuffer = new _n("ubyte", 36, 35044, !1), this._vertexBuffer.setData(t),
                    this._indexBuffer.setData(e);
                var i = new sn();
                i.bind(), i.applyVertexBuffer(this._vertexBuffer), i.applyIndexBuffer(this._indexBuffer),
                    i.unBind(), this._bufferState = i;
            }
            return d(r, "laya.d3.resource.models.SkyBox", gt), r.prototype._render = function(t) {
                E.instance.drawElements(4, 36, 5121, 0), M.trianglesFaces += 12, M.renderBatches++;
            }, r.__init__ = function() {
                r.instance = new r();
            }, r.instance = null, r;
        }(),
        pn = function(n) {
            function e() {
                this._mesh = null, this._convex = !1, e.__super.call(this);
            }
            d(e, "laya.d3.physics.shape.MeshColliderShape", n);
            var t = e.prototype;
            return t._setScale = function(t) {
                this._compoundParent ? this.updateLocalTransformations() : (H._nativeScale.setValue(t.x, t.y, t.z),
                    this._nativeShape.setLocalScaling(H._nativeScale), this._nativeShape.updateBound());
            }, t.cloneTo = function(t) {
                var e = t;
                e.convex = this._convex, e.mesh = this._mesh, n.prototype.cloneTo.call(this, t);
            }, t.clone = function() {
                var t = new e();
                return this.cloneTo(t), t;
            }, t.destroy = function() {
                this._nativeShape && (k._physics3D.destroy(this._nativeShape), this._nativeShape = null);
            }, u(0, t, "mesh", function() {
                return this._mesh;
            }, function(t) {
                if (this._mesh !== t) {
                    var e = k._physics3D;
                    this._mesh && e.destroy(this._nativeShape), t && (this._nativeShape = new e.btGImpactMeshShape(t._getPhysicMesh()),
                        this._nativeShape.updateBound()), this._mesh = t;
                }
            }), u(0, t, "convex", function() {
                return this._convex;
            }, function(t) {
                this._convex = t;
            }), e;
        }(H),
        Tn = function(n) {
            function t() {
                this.radius = NaN, this.emitFromShell = !1, t.__super.call(this), this.radius = 1,
                    this.emitFromShell = !1, this.randomDirection = !1;
            }
            d(t, "laya.d3.core.particleShuriKen.module.shape.HemisphereShape", n);
            var e = t.prototype;
            return e._getShapeBoundBox = function(t) {
                var e = t.min;
                e.x = e.y = e.z = -this.radius;
                var n = t.max;
                n.x = n.y = this.radius, n.z = 0;
            }, e._getSpeedBoundBox = function(t) {
                var e = t.min;
                e.x = e.y = -1, e.z = 0;
                var n = t.max;
                n.x = n.y = n.z = 1;
            }, e.generatePositionAndDirection = function(t, e, n, i) {
                n ? (n.seed = i[16], this.emitFromShell ? De._randomPointUnitSphere(t, n) : De._randomPointInsideUnitSphere(t, n),
                        i[16] = n.seed) : this.emitFromShell ? De._randomPointUnitSphere(t) : De._randomPointInsideUnitSphere(t),
                    Ct.scale(t, this.radius, t);
                var r = t.z;
                r < 0 && (t.z = -1 * r), this.randomDirection ? n ? (n.seed = i[17], De._randomPointUnitSphere(e, n),
                    i[17] = n.seed) : De._randomPointUnitSphere(e) : t.cloneTo(e);
            }, e.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.radius = this.radius, e.emitFromShell = this.emitFromShell, e.randomDirection = this.randomDirection;
            }, t;
        }(G),
        En = function(t) {
            function h(t, e, n, i, r, a, o, s) {
                this._owner = null, this._gridSize = NaN, this.memorySize = 0, this._numberVertices = 0,
                    this._maxNumberIndices = 0, this._currentNumberIndices = 0, this._numberTriangle = 0,
                    this._vertexBuffer = null, this._indexBuffer = null, this._indexArrayBuffer = null,
                    this._boundingBoxCorners = null, this._leafs = null, this._leafNum = 0, this._terrainHeightData = null,
                    this._terrainHeightDataWidth = 0, this._terrainHeightDataHeight = 0, this._chunkOffsetX = 0,
                    this._chunkOffsetZ = 0, this._cameraCoordinateInverse = !1, this._cameraPos = null,
                    this._currentLOD = 0, this._perspectiveFactor = NaN, this._LODTolerance = 0, this._boundingSphere = null,
                    this._boundingBox = null, h.__super.call(this), this._bufferState = new sn(), this._owner = t,
                    this._cameraPos = new Ct(), this._chunkOffsetX = e, this._chunkOffsetZ = n, this._gridSize = i,
                    this._terrainHeightData = r, this._terrainHeightDataWidth = a, this._terrainHeightDataHeight = o,
                    this._leafNum = ot.CHUNK_GRID_NUM / ot.LEAF_GRID_NUM * (ot.CHUNK_GRID_NUM / ot.LEAF_GRID_NUM),
                    this._leafs = P(this._leafNum), this._cameraCoordinateInverse = s;
                for (var l = 0; l < this._leafNum; l++) this._leafs[l] = new ot();
                this.recreateResource();
            }
            d(h, "laya.d3.terrain.TerrainFilter", Q);
            var e = h.prototype;
            return e.recreateResource = function() {
                this._currentNumberIndices = 0, this._numberTriangle = 0;
                var t = ot.LEAF_VERTEXT_COUNT,
                    e = ot.LEAF_MAX_INDEX_COUNT;
                this._numberVertices = t * this._leafNum, this._maxNumberIndices = e * this._leafNum,
                    this._indexArrayBuffer = new Uint16Array(this._maxNumberIndices);
                var n = jt.vertexDeclaration,
                    i = n.vertexStride / 4,
                    r = new Float32Array(this._numberVertices * i),
                    a = ot.CHUNK_GRID_NUM / ot.LEAF_GRID_NUM,
                    o = 0,
                    s = 0,
                    l = 0;
                for (o = 0; o < this._leafNum; o++) s = o % a, l = Math.floor(o / a), this._leafs[o].calcVertextBuffer(this._chunkOffsetX, this._chunkOffsetZ, s * ot.LEAF_GRID_NUM, l * ot.LEAF_GRID_NUM, this._gridSize, r, o * ot.LEAF_PLANE_VERTEXT_COUNT, i, this._terrainHeightData, this._terrainHeightDataWidth, this._terrainHeightDataHeight, this._cameraCoordinateInverse);
                for (o = 0; o < this._leafNum; o++) s = o % a, l = Math.floor(o / a), this._leafs[o].calcSkirtVertextBuffer(this._chunkOffsetX, this._chunkOffsetZ, s * ot.LEAF_GRID_NUM, l * ot.LEAF_GRID_NUM, this._gridSize, r, this._leafNum * ot.LEAF_PLANE_VERTEXT_COUNT + o * ot.LEAF_SKIRT_VERTEXT_COUNT, i, this._terrainHeightData, this._terrainHeightDataWidth, this._terrainHeightDataHeight);
                this.assembleIndexInit(), this._vertexBuffer = new rn(n.vertexStride * this._numberVertices, 35044, !1),
                    this._vertexBuffer.vertexDeclaration = n, this._indexBuffer = new _n("ushort", this._maxNumberIndices, 35044, !1),
                    this._vertexBuffer.setData(r), this._indexBuffer.setData(this._indexArrayBuffer),
                    this.memorySize = 2 * (this._vertexBuffer._byteLength + this._indexBuffer._byteLength),
                    this.calcOriginalBoudingBoxAndSphere(), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                    this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
            }, e.setLODLevel = function(t) {
                if (4 != t.length) return !0;
                var e = (t[0] + 1 << 24) + (t[1] + 1 << 16) + (t[2] + 1 << 8) + (t[3] + 1);
                return this._currentLOD != e && (this._currentLOD = e, !0);
            }, e.assembleIndexInit = function() {
                this._currentNumberIndices = 0;
                for (var t = this._numberTriangle = 0, e = 0; e < this._leafNum; e++) {
                    var n = ot.getPlaneLODIndex(e, 0);
                    this._indexArrayBuffer.set(n, t), t += n.length;
                    var i = ot.getSkirtLODIndex(e, 0);
                    this._indexArrayBuffer.set(i, t), t += i.length, this._currentNumberIndices += n.length + i.length;
                }
                this._numberTriangle = this._currentNumberIndices / 3;
            }, e.isNeedAssemble = function(t, e) {
                var n = Math.min(t.viewport.width, t.viewport.height) / (2 * Math.tan(Math.PI * t.fieldOfView / 180));
                return this._perspectiveFactor != n ? (this._perspectiveFactor = n, 1) : this._LODTolerance != Xn.LOD_TOLERANCE_VALUE ? (this._LODTolerance = Xn.LOD_TOLERANCE_VALUE,
                    1) : 0 == Ct.equals(e, this._cameraPos) ? (this._cameraPos.x = e.x, this._cameraPos.y = e.y,
                    this._cameraPos.z = e.z, 2) : 0;
            }, e.assembleIndex = function(t, e) {
                var n = this.isNeedAssemble(t, e);
                if (0 < n) {
                    for (var i = 0; i < this._leafNum; i++) h._TEMP_ARRAY_BUFFER[i] = this._leafs[i].determineLod(e, this._perspectiveFactor, Xn.LOD_TOLERANCE_VALUE, 1 == n);
                    if (this.setLODLevel(h._TEMP_ARRAY_BUFFER)) {
                        this._currentNumberIndices = 0;
                        var r = this._numberTriangle = 0;
                        for (i = 0; i < this._leafNum; i++) {
                            var a = h._TEMP_ARRAY_BUFFER[i],
                                o = ot.getPlaneLODIndex(i, a);
                            this._indexArrayBuffer.set(o, r), r += o.length;
                            var s = ot.getSkirtLODIndex(i, a);
                            this._indexArrayBuffer.set(s, r), r += s.length, this._currentNumberIndices += o.length + s.length;
                        }
                        return this._numberTriangle = this._currentNumberIndices / 3, !0;
                    }
                }
                return !1;
            }, e.calcOriginalBoudingBoxAndSphere = function() {
                for (var t = new Lt(2147483647, -2147483647), e = 0; e < this._leafNum; e++) t.x = this._leafs[e]._sizeOfY.x < t.x ? this._leafs[e]._sizeOfY.x : t.x,
                    t.y = this._leafs[e]._sizeOfY.y > t.y ? this._leafs[e]._sizeOfY.y : t.y;
                var n = new Ct(this._chunkOffsetX * ot.CHUNK_GRID_NUM * this._gridSize, t.x, this._chunkOffsetZ * ot.CHUNK_GRID_NUM * this._gridSize),
                    i = new Ct((this._chunkOffsetX + 1) * ot.CHUNK_GRID_NUM * this._gridSize, t.y, (this._chunkOffsetZ + 1) * ot.CHUNK_GRID_NUM * this._gridSize);
                ot.__ADAPT_MATRIX__ && (Ct.transformV3ToV3(n, ot.__ADAPT_MATRIX__, n), Ct.transformV3ToV3(i, ot.__ADAPT_MATRIX__, i)),
                    this._boundingBox = new we(n, i);
                var r = new Ct();
                Ct.subtract(i, n, r), Ct.scale(r, .5, r);
                var a = new Ct();
                Ct.add(n, r, a), this._boundingSphere = new Tt(a, Ct.scalarLength(r)), this._boundingBoxCorners = P(8, null),
                    this._boundingBox.getCorners(this._boundingBoxCorners);
            }, e.calcLeafBoudingBox = function(t) {
                for (var e = 0; e < this._leafNum; e++) this._leafs[e].calcLeafBoudingBox(t);
            }, e.calcLeafBoudingSphere = function(t, e) {
                for (var n = 0; n < this._leafNum; n++) this._leafs[n].calcLeafBoudingSphere(t, e);
            }, e._getVertexBuffer = function(t) {
                return void 0 === t && (t = 0), 0 == t ? this._vertexBuffer : null;
            }, e._getIndexBuffer = function() {
                return this._indexBuffer;
            }, e._getType = function() {
                return h._type;
            }, e._prepareRender = function(t) {
                return !0;
            }, e._render = function(t) {
                this._bufferState.bind(), E.instance.drawElements(Xn.RENDER_LINE_MODEL ? 1 : 4, this._currentNumberIndices, 5123, 0),
                    M.trianglesFaces += this._numberTriangle, M.renderBatches++;
            }, e.destroy = function() {
                this._owner = null, this._bufferState.destroy(), this._vertexBuffer && this._vertexBuffer.destroy(),
                    this._indexBuffer && this._indexBuffer.destroy();
            }, _(h, ["_TEMP_ARRAY_BUFFER", function() {
                return this._TEMP_ARRAY_BUFFER = new Uint32Array(ot.CHUNK_GRID_NUM / ot.LEAF_GRID_NUM * ot.CHUNK_GRID_NUM / ot.LEAF_GRID_NUM);
            }, "_type", function() {
                return this._type = Q._typeCounter++;
            }]), h;
        }(),
        vn = function(n) {
            function t() {
                this.radius = NaN, this.emitFromShell = !1, t.__super.call(this), this.radius = 1,
                    this.emitFromShell = !1, this.randomDirection = !1;
            }
            d(t, "laya.d3.core.particleShuriKen.module.shape.SphereShape", n);
            var e = t.prototype;
            return e._getShapeBoundBox = function(t) {
                var e = t.min;
                e.x = e.y = e.z = -this.radius;
                var n = t.max;
                n.x = n.y = n.z = this.radius;
            }, e._getSpeedBoundBox = function(t) {
                var e = t.min;
                e.x = e.y = e.z = -1;
                var n = t.max;
                n.x = n.y = n.z = 1;
            }, e.generatePositionAndDirection = function(t, e, n, i) {
                n ? (n.seed = i[16], this.emitFromShell ? De._randomPointUnitSphere(t, n) : De._randomPointInsideUnitSphere(t, n),
                        i[16] = n.seed) : this.emitFromShell ? De._randomPointUnitSphere(t) : De._randomPointInsideUnitSphere(t),
                    Ct.scale(t, this.radius, t), this.randomDirection ? n ? (n.seed = i[17], De._randomPointUnitSphere(e, n),
                        i[17] = n.seed) : De._randomPointUnitSphere(e) : t.cloneTo(e);
            }, e.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.radius = this.radius, e.emitFromShell = this.emitFromShell, e.randomDirection = this.randomDirection;
            }, t;
        }(G),
        gn = function(n) {
            function t() {
                t.__super.call(this), this.inTangent = new Ct(), this.outTangent = new Ct(), this.value = new Ct();
            }
            return d(t, "laya.d3.core.Vector3Keyframe", n), t.prototype.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                this.inTangent.cloneTo(e.inTangent), this.outTangent.cloneTo(e.outTangent), this.value.cloneTo(e.value);
            }, t;
        }(lt),
        Sn = function(t) {
            function g(t, e) {
                this._stacks = 0, this._slices = 0, g.__super.call(this), void 0 === t && (t = 48),
                    void 0 === e && (e = 48), this._stacks = t, this._slices = e;
                for (var n = J.vertexDeclaration, i = n.vertexStride / 4, r = (this._stacks + 1) * (this._slices + 1), a = 3 * this._stacks * (this._slices + 1) * 2, o = new Float32Array(r * i), s = new Uint16Array(a), l = Math.PI / this._stacks, h = 2 * Math.PI / this._slices, u = 0, c = 0, _ = 0, d = 0; d < this._stacks + 1; d++)
                    for (var f = Math.sin(d * l), m = Math.cos(d * l), p = 0; p < this._slices + 1; p++) {
                        var T = f * Math.sin(p * h),
                            E = f * Math.cos(p * h);
                        o[c + 0] = T * g._radius, o[c + 1] = m * g._radius, o[c + 2] = E * g._radius, o[c + 3] = -p / this._slices + .75,
                            o[c + 4] = d / this._stacks, c += i, d != this._stacks - 1 && (s[_++] = u + 1, s[_++] = u,
                                s[_++] = u + (this._slices + 1), s[_++] = u + (this._slices + 1), s[_++] = u, s[_++] = u + this._slices,
                                u++);
                    }
                this._vertexBuffer = new rn(4 * o.length, 35044, !1), this._vertexBuffer.vertexDeclaration = n,
                    this._indexBuffer = new _n("ushort", s.length, 35044, !1), this._vertexBuffer.setData(o),
                    this._indexBuffer.setData(s);
                var v = new sn();
                v.bind(), v.applyVertexBuffer(this._vertexBuffer), v.applyIndexBuffer(this._indexBuffer),
                    v.unBind(), this._bufferState = v;
            }
            d(g, "laya.d3.resource.models.SkyDome", gt);
            var e = g.prototype;
            return e._render = function(t) {
                var e = this._indexBuffer.indexCount;
                E.instance.drawElements(4, e, 5123, 0), M.trianglesFaces += e / 3, M.renderBatches++;
            }, u(0, e, "stacks", function() {
                return this._stacks;
            }), u(0, e, "slices", function() {
                return this._slices;
            }), g.__init__ = function() {
                g.instance = new g();
            }, g._radius = 1, g.instance = null, g;
        }(),
        yn = function(t) {
            function i(t, e, n) {
                switch (this._radius = 1, this._height = .5, i.__super.call(this), void 0 === t && (t = .5),
                    void 0 === e && (e = 1), void 0 === n && (n = 1), this._radius = t, this._height = e,
                    this._orientation = n, this._type = 2, n) {
                    case 0:
                        this._nativeShape = new k._physics3D.btConeShapeX(t, e);
                        break;

                    case 1:
                        this._nativeShape = new k._physics3D.btConeShape(t, e);
                        break;

                    case 2:
                        this._nativeShape = new k._physics3D.btConeShapeZ(t, e);
                        break;

                    default:
                        throw "ConeColliderShape:unknown orientation.";
                }
            }
            d(i, "laya.d3.physics.shape.ConeColliderShape", H);
            var e = i.prototype;
            return e.clone = function() {
                var t = new i(this._radius, this._height, this._orientation);
                return this.cloneTo(t), t;
            }, u(0, e, "radius", function() {
                return this._radius;
            }), u(0, e, "height", function() {
                return this._height;
            }), u(0, e, "orientation", function() {
                return this._orientation;
            }), i;
        }(),
        xn = function(n) {
            function t() {
                this.x = NaN, this.y = NaN, this.z = NaN, t.__super.call(this), this.x = 1, this.y = 1,
                    this.z = 1, this.randomDirection = !1;
            }
            d(t, "laya.d3.core.particleShuriKen.module.shape.BoxShape", n);
            var e = t.prototype;
            return e._getShapeBoundBox = function(t) {
                var e = t.min;
                e.x = .5 * -this.x, e.y = .5 * -this.y, e.z = .5 * -this.z;
                var n = t.max;
                n.x = .5 * this.x, n.y = .5 * this.y, n.z = .5 * this.z;
            }, e._getSpeedBoundBox = function(t) {
                var e = t.min;
                e.x = 0, e.y = 0, e.z = 0;
                var n = t.max;
                n.x = 0, n.y = 1, n.z = 0;
            }, e.generatePositionAndDirection = function(t, e, n, i) {
                n ? (n.seed = i[16], De._randomPointInsideHalfUnitBox(t, n), i[16] = n.seed) : De._randomPointInsideHalfUnitBox(t),
                    t.x = this.x * t.x, t.y = this.y * t.y, t.z = this.z * t.z, this.randomDirection ? n ? (n.seed = i[17],
                        De._randomPointUnitSphere(e, n), i[17] = n.seed) : De._randomPointUnitSphere(e) : (e.x = 0,
                        e.y = 0, e.z = 1);
            }, e.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                e.x = this.x, e.y = this.y, e.z = this.z, e.randomDirection = this.randomDirection;
            }, t;
        }(G),
        Dn = function(n) {
            function t() {
                t.__super.call(this), this.inTangent = new At(), this.outTangent = new At(), this.value = new rt();
            }
            return d(t, "laya.d3.core.QuaternionKeyframe", n), t.prototype.cloneTo = function(t) {
                n.prototype.cloneTo.call(this, t);
                var e = t;
                this.inTangent.cloneTo(e.inTangent), this.outTangent.cloneTo(e.outTangent), this.value.cloneTo(e.value);
            }, t;
        }(lt),
        In = function(t) {
            function f(t, e, n, i, r, a, o, s, l, h, u, c, _, d) {
                this._cornerTextureCoordinate = null, this._positionStartLifeTime = null, this._velocity = null,
                    this._startColor = null, this._startSize = null, this._startRotation0 = null, this._startRotation1 = null,
                    this._startRotation2 = null, this._startLifeTime = NaN, this._time = NaN, this._startSpeed = NaN,
                    this._randoms0 = null, this._randoms1 = null, this._simulationWorldPostion = null,
                    f.__super.call(this), this._cornerTextureCoordinate = t, this._positionStartLifeTime = e,
                    this._velocity = n, this._startColor = i, this._startSize = r, this._startRotation0 = a,
                    this._startRotation1 = o, this._startRotation2 = s, this._startLifeTime = l, this._time = h,
                    this._startSpeed = u, this._randoms0 = this.random0, this._randoms1 = this.random1,
                    this._simulationWorldPostion = d;
            }
            d(f, "laya.d3.graphics.Vertex.VertexShurikenParticleBillboard", st);
            var e = f.prototype;
            return u(0, e, "cornerTextureCoordinate", function() {
                return this._cornerTextureCoordinate;
            }), u(0, e, "random1", function() {
                return this._randoms1;
            }), u(0, e, "startRotation2", function() {
                return this._startRotation2;
            }), u(0, e, "positionStartLifeTime", function() {
                return this._positionStartLifeTime;
            }), u(0, e, "velocity", function() {
                return this._velocity;
            }), u(0, e, "random0", function() {
                return this._randoms0;
            }), u(0, e, "startSize", function() {
                return this._startSize;
            }), u(0, e, "startColor", function() {
                return this._startColor;
            }), u(0, e, "startRotation0", function() {
                return this._startRotation0;
            }), u(0, e, "startRotation1", function() {
                return this._startRotation1;
            }), u(0, e, "startLifeTime", function() {
                return this._startLifeTime;
            }), u(0, e, "time", function() {
                return this._time;
            }), u(0, e, "startSpeed", function() {
                return this._startSpeed;
            }), u(0, e, "simulationWorldPostion", function() {
                return this._simulationWorldPostion;
            }), u(1, f, "vertexDeclaration", function() {
                return f._vertexDeclaration;
            }, laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration), _(f, ["_vertexDeclaration", function() {
                return this._vertexDeclaration = new ue(152, [new Bt(0, "vector4", 0), new Bt(16, "vector4", 4), new Bt(32, "vector4", 5), new Bt(48, "vector4", 6), new Bt(64, "vector3", 8), new Bt(76, "vector3", 9), new Bt(88, "single", 10), new Bt(92, "vector4", 11), new Bt(108, "vector4", 12), new Bt(124, "vector3", 13), new Bt(136, "vector4", 14)]);
            }]), f;
        }(),
        Rn = function(t) {
            function e() {
                e.__super.call(this), this._dynamicWorldPositionNormalNeedUpdate = !0;
            }
            d(e, "laya.d3.core.render.SubMeshRenderElement", t);
            var n = e.prototype;
            return n._onWorldMatrixChanged = function() {
                this._dynamicWorldPositionNormalNeedUpdate = !0;
            }, n._computeWorldPositionsAndNormals = function(t, e, n, i) {
                if (this._dynamicWorldPositionNormalNeedUpdate) {
                    for (var r = this._geometry, a = r._vertexBuffer, o = a.vertexDeclaration.vertexStride / 4, s = a.getData(), l = this._transform.worldMatrix, h = this._transform.rotation, u = r._indices, c = 0; c < i; c++) {
                        var _ = (n ? u[c] : c) * o,
                            d = 3 * c;
                        Gt.transformVector3ArrayToVector3ArrayCoordinate(s, _ + t, l, this._dynamicWorldPositions, d), -1 !== e && Gt.transformVector3ArrayByQuat(s, _ + e, h, this._dynamicWorldNormals, d);
                    }
                    this._dynamicWorldPositionNormalNeedUpdate = !1;
                }
            }, n.setTransform = function(t) {
                this._transform !== t && (this._transform && this._transform.off("transformchanged", this, this._onWorldMatrixChanged),
                    t && t.on("transformchanged", this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0,
                    this._transform = t);
            }, n.setGeometry = function(t) {
                if (this._geometry !== t) {
                    var e = t,
                        n = e._mesh;
                    if (n) {
                        var i = 1 < n._subMeshCount,
                            r = i ? e._indexCount : n._vertexCount;
                        if (r <= 10) {
                            var a = 3 * r;
                            this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(a),
                                this._dynamicWorldNormals = new Float32Array(a), this._dynamicVertexCount = r, this._dynamicMultiSubMesh = i;
                        } else this._dynamicVertexBatch = !1;
                    }
                    this._geometry = t;
                }
            }, n.addToOpaqueRenderQueue = function(t, e) {
                var n = this.staticBatch,
                    i = e.elements;
                if (n) {
                    var r = dn.instance,
                        a = r.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, n._batchID);
                    if (r._updateCountMark === a.updateMark) {
                        var o = a.indexInList;
                        if (a.batched) i[o].staticBatchElementList.push(this);
                        else {
                            var s = i[o],
                                l = s.render,
                                h = r._getBatchRenderElementFromPool();
                            h.renderType = 1, h.setGeometry(n), h.material = s.material;
                            var u = n.batchOwner,
                                c = u ? u._transform : null;
                            h.setTransform(c), h.render = l;
                            var _ = h.staticBatchElementList;
                            _.length = 0, _.push(s), _.push(this), i[o] = h, a.batched = !0;
                        }
                    } else a.updateMark = r._updateCountMark, a.indexInList = i.length, a.batched = !1,
                        i.push(this);
                } else if (this.material._shader._enableInstancing && V._angleInstancedArrays) {
                    var d = this._geometry,
                        f = Qe.instance,
                        m = f.getInstanceBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, d._id);
                    if (f._updateCountMark === m.updateMark) {
                        var p = m.indexInList;
                        if (m.batched) {
                            var T = i[p].instanceBatchElementList;
                            T.length === hn.instance.maxInstanceCount ? (m.updateMark = f._updateCountMark,
                                m.indexInList = i.length, m.batched = !1, i.push(this)) : T.push(this);
                        } else {
                            var E = i[p],
                                v = E.render,
                                g = f._getBatchRenderElementFromPool();
                            g.renderType = 2, g.setGeometry(hn.instance), g.material = E.material, g.setTransform(null),
                                g.render = v, g.instanceSubMesh = d;
                            var S = g.instanceBatchElementList;
                            S.length = 0, S.push(E), S.push(this), i[p] = g, m.batched = !0;
                        }
                    } else m.updateMark = f._updateCountMark, m.indexInList = i.length, m.batched = !1,
                        i.push(this);
                } else if (this._dynamicVertexBatch) {
                    var y = this._geometry._vertexBuffer.vertexDeclaration,
                        x = Qe.instance,
                        D = x.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, y.id);
                    if (x._updateCountMark === D.updateMark) {
                        var I = D.indexInList;
                        if (D.batched) i[I].vertexBatchElementList.push(this);
                        else {
                            var R = i[I],
                                M = R.render,
                                A = x._getBatchRenderElementFromPool();
                            A.renderType = 3, A.setGeometry(fn.instance), A.material = R.material, A.setTransform(null),
                                A.render = M, A.vertexBatchVertexDeclaration = y;
                            var C = A.vertexBatchElementList;
                            C.length = 0, C.push(R), C.push(this), i[I] = A, D.batched = !0;
                        }
                    } else D.updateMark = x._updateCountMark, D.indexInList = i.length, D.batched = !1,
                        i.push(this);
                } else i.push(this);
            }, n.addToTransparentRenderQueue = function(t, e) {
                var n = this.staticBatch,
                    i = e.elements;
                if (n) {
                    var r = dn.instance,
                        a = e.lastTransparentRenderElement;
                    if (a) {
                        var o = a.render;
                        if (a._geometry._getType() !== this._geometry._getType() || a.staticBatch !== n || a.material !== this.material || o.receiveShadow !== this.render.receiveShadow || o.lightmapIndex !== this.render.lightmapIndex) i.push(this),
                            e.lastTransparentBatched = !1;
                        else {
                            if (e.lastTransparentBatched) i[i.length - 1].staticBatchElementList.push(this);
                            else {
                                var s = r._getBatchRenderElementFromPool();
                                s.renderType = 1, s.setGeometry(n), s.material = a.material;
                                var l = n.batchOwner,
                                    h = l ? l._transform : null;
                                s.setTransform(h), s.render = this.render;
                                var u = s.staticBatchElementList;
                                u.length = 0, u.push(a), u.push(this), i[i.length - 1] = s;
                            }
                            e.lastTransparentBatched = !0;
                        }
                    } else i.push(this), e.lastTransparentBatched = !1;
                } else if (this.material._shader._enableInstancing && V._angleInstancedArrays) {
                    var c = this._geometry,
                        _ = Qe.instance,
                        d = e.lastTransparentRenderElement;
                    if (d) {
                        var f = d.render;
                        if (d._geometry._getType() !== this._geometry._getType() || d._geometry !== c || d.material !== this.material || f.receiveShadow !== this.render.receiveShadow || f.lightmapIndex !== this.render.lightmapIndex) i.push(this),
                            e.lastTransparentBatched = !1;
                        else {
                            if (e.lastTransparentBatched) i[i.length - 1].instanceBatchElementList.push(this);
                            else {
                                var m = _._getBatchRenderElementFromPool();
                                m.renderType = 2, m.setGeometry(hn.instance), m.material = d.material, m.setTransform(null),
                                    m.render = this.render, m.instanceSubMesh = c;
                                var p = m.instanceBatchElementList;
                                p.length = 0, p.push(d), p.push(this), i[i.length - 1] = m;
                            }
                            e.lastTransparentBatched = !0;
                        }
                    } else i.push(this), e.lastTransparentBatched = !1;
                } else if (this._dynamicVertexBatch) {
                    var T = this._geometry._vertexBuffer.vertexDeclaration,
                        E = Qe.instance,
                        v = e.lastTransparentRenderElement;
                    if (v) {
                        var g = v.render;
                        if (v._geometry._getType() !== this._geometry._getType() || v._geometry._vertexBuffer._vertexDeclaration !== T || v.material !== this.material || g.receiveShadow !== this.render.receiveShadow || g.lightmapIndex !== this.render.lightmapIndex) i.push(this),
                            e.lastTransparentBatched = !1;
                        else {
                            if (e.lastTransparentBatched) i[i.length - 1].vertexBatchElementList.push(this);
                            else {
                                var S = E._getBatchRenderElementFromPool();
                                S.renderType = 3, S.setGeometry(fn.instance), S.material = v.material, S.setTransform(null),
                                    S.render = this.render, S.vertexBatchVertexDeclaration = T;
                                var y = S.vertexBatchElementList;
                                y.length = 0, y.push(v), y.push(this), i[i.length - 1] = S;
                            }
                            e.lastTransparentBatched = !0;
                        }
                    } else i.push(this), e.lastTransparentBatched = !1;
                } else i.push(this);
                e.lastTransparentRenderElement = this;
            }, n.destroy = function() {
                t.prototype.destroy.call(this), this._dynamicWorldPositions = null, this._dynamicWorldNormals = null,
                    this.staticBatch = null, this.staticBatchElementList = null, this.vertexBatchElementList = null,
                    this.vertexBatchVertexDeclaration = null;
            }, e._maxInstanceCount = 1024, _(e, ["_instanceMatrixData", function() {
                return this._instanceMatrixData = new Float32Array(16 * e._maxInstanceCount);
            }, "_instanceMatrixBuffer", function() {
                return this._instanceMatrixBuffer = new rn(4 * e._instanceMatrixData.length, 35048);
            }]), e;
        }(Et),
        Mn = function(t) {
            function f(t, e, n, i, r, a, o, s, l, h, u, c, _, d) {
                this._cornerTextureCoordinate = null, this._positionStartLifeTime = null, this._velocity = null,
                    this._startColor = null, this._startSize = null, this._startRotation0 = null, this._startRotation1 = null,
                    this._startRotation2 = null, this._startLifeTime = NaN, this._time = NaN, this._startSpeed = NaN,
                    this._randoms0 = null, this._randoms1 = null, this._simulationWorldPostion = null,
                    f.__super.call(this), this._cornerTextureCoordinate = t, this._positionStartLifeTime = e,
                    this._velocity = n, this._startColor = i, this._startSize = r, this._startRotation0 = a,
                    this._startRotation1 = o, this._startRotation2 = s, this._startLifeTime = l, this._time = h,
                    this._startSpeed = u, this._randoms0 = this.random0, this._randoms1 = this.random1,
                    this._simulationWorldPostion = d;
            }
            d(f, "laya.d3.graphics.Vertex.VertexShurikenParticleMesh", st);
            var e = f.prototype;
            return u(0, e, "cornerTextureCoordinate", function() {
                return this._cornerTextureCoordinate;
            }), u(0, e, "velocity", function() {
                return this._velocity;
            }), u(0, e, "position", function() {
                return this._positionStartLifeTime;
            }), u(0, e, "random0", function() {
                return this._randoms0;
            }), u(0, e, "startSize", function() {
                return this._startSize;
            }), u(0, e, "startColor", function() {
                return this._startColor;
            }), u(0, e, "startRotation0", function() {
                return this._startRotation0;
            }), u(0, e, "startRotation1", function() {
                return this._startRotation1;
            }), u(0, e, "random1", function() {
                return this._randoms1;
            }), u(0, e, "startRotation2", function() {
                return this._startRotation2;
            }), u(0, e, "startLifeTime", function() {
                return this._startLifeTime;
            }), u(0, e, "time", function() {
                return this._time;
            }), u(0, e, "startSpeed", function() {
                return this._startSpeed;
            }), u(0, e, "simulationWorldPostion", function() {
                return this._simulationWorldPostion;
            }), u(1, f, "vertexDeclaration", function() {
                return f._vertexDeclaration;
            }, laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration), _(f, ["_vertexDeclaration", function() {
                return this._vertexDeclaration = new ue(172, [new Bt(0, "vector3", 1), new Bt(12, "vector4", 2), new Bt(28, "vector2", 3), new Bt(36, "vector4", 4), new Bt(52, "vector4", 5), new Bt(68, "vector4", 6), new Bt(84, "vector3", 8), new Bt(96, "vector3", 9), new Bt(108, "single", 10), new Bt(112, "vector4", 11), new Bt(128, "vector4", 12), new Bt(144, "vector3", 13), new Bt(156, "vector4", 14)]);
            }]), f;
        }(),
        An = function(e) {
            function n(t, e) {
                this._needProcessCollisions = !1, this._needProcessTriggers = !1, n.__super.call(this),
                    void 0 === e && (e = !1), this._id = ++n._uniqueIDCounter, this._transform = new ze(this),
                    this._isStatic = e, this.layer = 0, this.name = t || "New Sprite3D";
            }
            d(n, "laya.d3.core.Sprite3D", e);
            var t = n.prototype;
            return m.imps(t, {
                "laya.resource.ICreateResource": !0,
                "laya.d3.core.IClone": !0
            }), t._setCreateURL = function(t) {
                this._url = O.formatURL(t);
            }, t._changeAnimatorsToLinkSprite3D = function(t, e, n) {
                var i = this.getComponent(Ge);
                if (i && (i.avatar || t._changeAnimatorToLinkSprite3DNoAvatar(i, e, n)), this._parent && this._parent instanceof laya.d3.core.Sprite3D) {
                    n.unshift(this._parent.name);
                    var r = this._parent;
                    r._hierarchyAnimator && r._changeAnimatorsToLinkSprite3D(t, e, n);
                }
            }, t._setHierarchyAnimator = function(t, e) {
                this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t.avatar);
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var r = this._children[n];
                    r._hierarchyAnimator == e && r._setHierarchyAnimator(t, e);
                }
            }, t._clearHierarchyAnimator = function(t, e) {
                this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e ? e.avatar : null);
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var r = this._children[n];
                    r._hierarchyAnimator == t && r._clearHierarchyAnimator(t, e);
                }
            }, t._changeHierarchyAnimatorAvatar = function(t, e) {
                this._changeAnimatorAvatar(e);
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var r = this._children[n];
                    r._hierarchyAnimator == t && r._changeHierarchyAnimatorAvatar(t, e);
                }
            }, t._changeAnimatorToLinkSprite3DNoAvatar = function(t, e, n) {
                t._handleSpriteOwnersBySprite(e, n, this);
                for (var i = 0, r = this._children.length; i < r; i++) {
                    var a = this._children[i],
                        o = n.length;
                    n.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(t, e, n), n.splice(o, 1);
                }
            }, t._changeHierarchyAnimator = function(t) {
                this._hierarchyAnimator = t;
            }, t._changeAnimatorAvatar = function(t) {}, t._onAdded = function() {
                if (this._parent instanceof laya.d3.core.Sprite3D) {
                    var t = this._parent;
                    this.transform._setParent(t.transform), t._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(t._hierarchyAnimator, null),
                        t._changeAnimatorsToLinkSprite3D(this, !0, [this.name]));
                }
                e.prototype._onAdded.call(this);
            }, t._onRemoved = function() {
                if (e.prototype._onRemoved.call(this), this._parent instanceof laya.d3.core.Sprite3D) {
                    var t = this._parent;
                    this.transform._setParent(null), t._hierarchyAnimator && (this._hierarchyAnimator == t._hierarchyAnimator && this._clearHierarchyAnimator(t._hierarchyAnimator, null),
                        t._changeAnimatorsToLinkSprite3D(this, !1, [this.name]));
                }
            }, t._parse = function(t) {
                if (void 0 !== t.isStatic && (this._isStatic = t.isStatic), void 0 !== t.active && (this.active = t.active),
                    null != t.name && (this.name = t.name), void 0 !== t.position) {
                    var e = this.transform.localPosition;
                    e.fromArray(t.position), this.transform.localPosition = e;
                }
                if (void 0 !== t.rotationEuler) {
                    var n = this.transform.localRotationEuler;
                    n.fromArray(t.rotationEuler), this.transform.localRotationEuler = n;
                }
                if (void 0 !== t.rotation) {
                    var i = this.transform.localRotation;
                    i.fromArray(t.rotation), this.transform.localRotation = i;
                }
                if (void 0 !== t.scale) {
                    var r = this.transform.localScale;
                    r.fromArray(t.scale), this.transform.localScale = r;
                }
                null != t.layer && (this.layer = t.layer);
            }, t.cloneTo = function(t) {
                if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                for (var e = t, n = 0, i = this._children.length; n < i; n++) e.addChild(this._children[n].clone());
                e.name = this.name, e.destroyed = this.destroyed, e.active = this.active;
                var r = e.transform.localPosition;
                this.transform.localPosition.cloneTo(r), e.transform.localPosition = r;
                var a = e.transform.localRotation;
                this.transform.localRotation.cloneTo(a), e.transform.localRotation = a;
                var o = e.transform.localScale;
                this.transform.localScale.cloneTo(o), e.transform.localScale = o, e._isStatic = this._isStatic,
                    e.layer = this.layer, this._cloneTo(e);
            }, t.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, t.destroy = function(t) {
                void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                    this._transform = null, this._scripts = null, this._url && xt.clearRes(this._url));
            }, u(0, t, "id", function() {
                return this._id;
            }), u(0, t, "url", function() {
                return this._url;
            }), u(0, t, "layer", function() {
                return this._layer;
            }, function(t) {
                if (this._layer !== t) {
                    if (!(0 <= t && t <= 30)) throw new Error("Layer value must be 0-30.");
                    this._layer = t;
                }
            }), u(0, t, "transform", function() {
                return this._transform;
            }), u(0, t, "isStatic", function() {
                return this._isStatic;
            }), n._parse = function(t, e, n) {
                var i = t.data,
                    r = [],
                    a = Gt._createNodeByJson(i, r);
                return Z.combine(a, r), a;
            }, n.__init__ = function() {}, n.instantiate = function(t, e, n, i, r) {
                void 0 === n && (n = !0);
                var a = t.clone();
                e && e.addChild(a);
                var o = a.transform;
                if (n) {
                    var s = o.worldMatrix;
                    t.transform.worldMatrix.cloneTo(s), o.worldMatrix = s;
                } else i && (o.position = i), r && (o.rotation = r);
                return a;
            }, n.load = function(t, e) {
                m.loader.create(t, e, null, "HIERARCHY");
            }, n._uniqueIDCounter = 0, _(n, ["WORLDMATRIX", function() {
                return this.WORLDMATRIX = Vt.propertyNameToID("u_WorldMat");
            }, "MVPMATRIX", function() {
                return this.MVPMATRIX = Vt.propertyNameToID("u_MvpMatrix");
            }]), n;
        }(e),
        Cn = function(r) {
            function e() {
                e.__super.call(this), this._defineDatas = new Ft(), this._disablePublicDefineDatas = new Ft(),
                    this._shaderValues = new at(this), this.renderQueue = 2e3, this._alphaTest = !1;
            }
            d(e, "laya.d3.core.material.BaseMaterial", r);
            var t = e.prototype;
            return m.imps(t, {
                    "laya.d3.core.IClone": !0
                }), t._removeTetxureReference = function() {
                    var t = this._shaderValues.getData();
                    for (var e in t) {
                        var n = t[e];
                        n && n instanceof laya.webgl.resource.BaseTexture && n._removeReference();
                    }
                }, t._addReference = function(t) {
                    void 0 === t && (t = 1), r.prototype._addReference.call(this, t);
                    var e = this._shaderValues.getData();
                    for (var n in e) {
                        var i = e[n];
                        i && i instanceof laya.webgl.resource.BaseTexture && i._addReference();
                    }
                }, t._removeReference = function(t) {
                    void 0 === t && (t = 1), r.prototype._removeReference.call(this, t), this._removeTetxureReference();
                }, t._disposeResource = function() {
                    0 < this._referenceCount && this._removeTetxureReference(), this._shaderValues = null;
                }, t.setShaderName = function(t) {
                    if (this._shader = Vt._preCompileShader[t], !this._shader) throw new Error("BaseMaterial: unknown shader name.");
                }, t.cloneTo = function(t) {
                    var e = t;
                    e.name = this.name, e.renderQueue = this.renderQueue, this._disablePublicDefineDatas.cloneTo(e._disablePublicDefineDatas),
                        this._defineDatas.cloneTo(e._defineDatas), this._shaderValues.cloneTo(e._shaderValues);
                }, t.clone = function() {
                    var t = new this.constructor();
                    return this.cloneTo(t), t;
                }, u(0, t, "alphaTestValue", function() {
                    return this._shaderValues.getNumber(e.ALPHATESTVALUE);
                }, function(t) {
                    this._shaderValues.setNumber(e.ALPHATESTVALUE, t);
                }), u(0, t, "alphaTest", function() {
                    return this._alphaTest;
                }, function(t) {
                    (this._alphaTest = t) ? this._defineDatas.add(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST): this._defineDatas.remove(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
                }), e.load = function(t, e) {
                    m.loader.create(t, e, null, "MATERIAL");
                }, e.__init__ = function() {
                    e.SHADERDEFINE_ALPHATEST = e.shaderDefines.registerDefine("ALPHATEST");
                }, e._parse = function(t, e, n) {
                    var i, r = t,
                        a = r.props,
                        o = a.type.split("."),
                        s = S.window;
                    if (o.forEach(function(t) {
                            s = s[t];
                        }), "function" != typeof s) throw "_getSprite3DHierarchyInnerUrls 错误: " + t.type + " 不是类";
                    switch (i = new s(), r.version) {
                        case "LAYAMATERIAL:01":
                        case "LAYAMATERIAL:02":
                            var l = 0,
                                h = 0;
                            for (var u in a) switch (u) {
                                case "vectors":
                                    var c = a[u];
                                    for (l = 0, h = c.length; l < h; l++) {
                                        var _ = c[l],
                                            d = _.value;
                                        switch (d.length) {
                                            case 2:
                                                i[_.name] = new Lt(d[0], d[1]);
                                                break;

                                            case 3:
                                                i[_.name] = new Ct(d[0], d[1], d[2]);
                                                break;

                                            case 4:
                                                i[_.name] = new At(d[0], d[1], d[2], d[3]);
                                                break;

                                            default:
                                                throw new Error("BaseMaterial:unkonwn color length.");
                                        }
                                    }
                                    break;

                                case "textures":
                                    var f = a[u];
                                    for (l = 0, h = f.length; l < h; l++) {
                                        var m = f[l],
                                            p = m.path;
                                        p && (i[m.name] = xt.getRes(p));
                                    }
                                    break;

                                case "defines":
                                    var T = a[u];
                                    for (l = 0, h = T.length; l < h; l++) {
                                        var E = i._shader.getSubShaderAt(0).getMaterialDefineByName(T[l]);
                                        i._defineDatas.add(E);
                                    }
                                    break;

                                case "renderStates":
                                    var v = a[u][0],
                                        g = i;
                                    g.blend = v.blend, g.cull = v.cull, g.depthTest = v.depthTest, g.depthWrite = v.depthWrite,
                                        g.blendSrc = v.srcBlend, g.blendDst = v.dstBlend;
                                    break;

                                case "cull":
                                    i.cull = a[u];
                                    break;

                                case "blend":
                                    i.blend = a[u];
                                    break;

                                case "depthWrite":
                                    i.depthWrite = a[u];
                                    break;

                                case "srcBlend":
                                    i.blendSrc = a[u];
                                    break;

                                case "dstBlend":
                                    i.blendDst = a[u];
                                    break;

                                default:
                                    i[u] = a[u];
                            }
                            break;

                        default:
                            throw new Error("BaseMaterial:unkonwn version.");
                    }
                    return i;
                }, e.RENDERQUEUE_OPAQUE = 2e3, e.RENDERQUEUE_ALPHATEST = 2450, e.RENDERQUEUE_TRANSPARENT = 3e3,
                e.SHADERDEFINE_ALPHATEST = 0, _(e, ["ALPHATESTVALUE", function() {
                    return this.ALPHATESTVALUE = Vt.propertyNameToID("u_AlphaTestValue");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht();
                }]), e;
        }(D),
        Ln = function(t) {
            function a() {
                this._rootNode = null, this._nativeNodeCount = 0, this._nativeCurCloneCount = 0,
                    a.__super.call(this);
            }
            d(a, "laya.d3.core.Avatar", D);
            var e = a.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e._initCloneToAnimator = function(t, e) {
                for (var n = 0, i = (e._avatarNodeMap[t.name] = t).getChildCount(); n < i; n++) this._initCloneToAnimator(t.getChildByIndex(n), e);
            }, e._parseNode = function(t, e) {
                var n = t.props.name;
                e.name = n;
                var i = t.props,
                    r = e.transform,
                    a = r.localPosition,
                    o = r.localRotation,
                    s = r.localScale;
                a.fromArray(i.translate), o.fromArray(i.rotation), s.fromArray(i.scale), r.localPosition = a,
                    r.localRotation = o, r.localScale = s;
                for (var l = t.child, h = 0, u = l.length; h < u; h++) {
                    var c = l[h],
                        _ = new ge(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                    e.addChild(_), b.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(c, _);
                }
            }, e._cloneDatasToAnimator = function(t) {
                var e;
                e = this._rootNode.clone();
                var n = this._rootNode.transform,
                    i = e.transform,
                    r = i.localPosition,
                    a = i.localRotation,
                    o = i.localScale;
                n.localPosition.cloneTo(r), n.localRotation.cloneTo(a), n.localScale.cloneTo(o),
                    i.localPosition = r, i.localRotation = a, i.localScale = o, t._avatarNodeMap = {},
                    this._initCloneToAnimator(e, t);
            }, e.cloneTo = function(t) {
                var e = t,
                    n = this._rootNode.clone();
                e._rootNode = n;
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, e._cloneDatasToAnimatorNative = function(t) {
                var e = new Float32Array(3 * this._nativeNodeCount),
                    n = new Float32Array(4 * this._nativeNodeCount),
                    i = new Float32Array(3 * this._nativeNodeCount),
                    r = new Float32Array(16 * this._nativeNodeCount),
                    a = new Int16Array(this._nativeNodeCount);
                t._animationNodeLocalPositions = e, t._animationNodeLocalRotations = n, t._animationNodeLocalScales = i,
                    t._animationNodeWorldMatrixs = r, t._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
                var o = this._rootNode._cloneNative(e, n, i, r, a, -1, this),
                    s = this._rootNode.transform,
                    l = o.transform,
                    h = l.localPosition,
                    u = l.localRotation,
                    c = l.localScale;
                s.localPosition.cloneTo(h), s.localRotation.cloneTo(u), s.localScale.cloneTo(c),
                    l.localPosition = h, l.localRotation = u, l.localScale = c, t._avatarNodeMap = {},
                    this._initCloneToAnimator(o, t);
            }, a._parse = function(t, e, n) {
                var i = new a();
                if (i._rootNode = new ge(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)),
                    b.supportWebGLPlusAnimation && i._nativeNodeCount++, t.version) {
                    var r = t.rootNode;
                    r && i._parseNode(r, i._rootNode);
                }
                return i;
            }, a.load = function(t, e) {
                m.loader.create(t, e, null, "AVATAR");
            }, a;
        }(),
        On = function(t) {
            function c() {
                this._nativeTriangleMesh = null, this._boundingBox = null, this._boundingSphere = null,
                    this._subMeshCount = 0, this._positions = null, this._subMeshes = null, this._vertexBuffers = null,
                    this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null,
                    this._inverseBindPosesBuffer = null, this._bindPoseIndices = null, this._skinDataPathMarks = null,
                    this._vertexCount = 0, this._bufferState = new sn(), this._instanceBufferState = new sn(),
                    c.__super.call(this), this._subMeshes = [], this._vertexBuffers = [], this._skinDataPathMarks = [];
            }
            d(c, "laya.d3.resource.models.Mesh", D);
            var e = c.prototype;
            return m.imps(e, {
                "laya.d3.core.IClone": !0
            }), e._generateBoundingObject = function() {
                this._boundingSphere = new Tt(new Ct(), 0), Tt.createfromPoints(this._positions, this._boundingSphere),
                    this._boundingBox = new we(new Ct(), new Ct()), we.createfromPoints(this._positions, this._boundingBox);
            }, e._getPositions = function() {
                var t, e, n, i, r, a = [],
                    o = 0,
                    s = 0,
                    l = 0,
                    h = this._vertexBuffers.length;
                for (o = 0; o < h; o++) {
                    for (n = (t = this._vertexBuffers[o]).vertexDeclaration.vertexElements, s = 0; s < n.length; s++)
                        if ("vector3" === (i = n[s]).elementFormat && 0 === i.elementUsage) {
                            e = i;
                            break;
                        }
                    for (r = t.getData(), s = 0; s < r.length; s += t.vertexDeclaration.vertexStride / 4) l = s + e.offset / 4,
                        a.push(new Ct(r[l + 0], r[l + 1], r[l + 2]));
                }
                return a;
            }, e._setSubMeshes = function(t) {
                this._subMeshes = t, this._subMeshCount = t.length;
                for (var e = 0; e < this._subMeshCount; e++) t[e]._indexInMesh = e;
                this._positions = this._getPositions(), this._generateBoundingObject();
            }, e._getSubMesh = function(t) {
                return this._subMeshes[t];
            }, e._setBuffer = function(t, e) {
                var n = this._bufferState;
                n.bind(), n.applyVertexBuffers(t), n.applyIndexBuffer(e), n.unBind();
                var i = this._instanceBufferState;
                i.bind(), i.applyVertexBuffers(t), i.applyInstanceVertexBuffer(hn.instance.instanceWorldMatrixBuffer),
                    i.applyInstanceVertexBuffer(hn.instance.instanceMVPMatrixBuffer), i.applyIndexBuffer(e),
                    i.unBind();
            }, e._disposeResource = function() {
                for (var t = 0, e = this._subMeshes.length; t < e; t++) this._subMeshes[t].destroy();
                for (this._nativeTriangleMesh && k._physics3D.destroy(this._nativeTriangleMesh),
                    t = 0, e = this._vertexBuffers.length; t < e; t++) this._vertexBuffers[t].destroy();
                this._indexBuffer.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), this._bufferState.destroy(),
                    this._instanceBufferState.destroy(), this._bufferState = null, this._instanceBufferState = null,
                    this._vertexBuffers = null, this._indexBuffer = null, this._subMeshes = null, this._nativeTriangleMesh = null,
                    this._vertexBuffers = null, this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null;
            }, e._getPhysicMesh = function() {
                if (!this._nativeTriangleMesh) {
                    for (var t = new k._physics3D.btTriangleMesh(), e = c._nativeTempVector30, n = c._nativeTempVector31, i = c._nativeTempVector32, r = this._getPositions(), a = this._indexBuffer.getData(), o = 0, s = a.length; o < s; o += 3) {
                        var l = r[a[o]],
                            h = r[a[o + 1]],
                            u = r[a[o + 2]];
                        Gt._convertToBulletVec3(l, e, !0), Gt._convertToBulletVec3(h, n, !0), Gt._convertToBulletVec3(u, i, !0),
                            t.addTriangle(e, n, i, !0);
                    }
                    this._nativeTriangleMesh = t;
                }
                return this._nativeTriangleMesh;
            }, e.cloneTo = function(t) {
                for (var e = t, n = 0; n < this._vertexBuffers.length; n++) {
                    var i = this._vertexBuffers[n],
                        r = new rn(i._byteLength, i.bufferUsage, i.canRead);
                    r.vertexDeclaration = i.vertexDeclaration, r.setData(i.getData().slice()), e._vertexBuffers.push(r),
                        e._vertexCount += r.vertexCount;
                }
                var a = this._indexBuffer,
                    o = new _n("ushort", a.indexCount, a.bufferUsage, a.canRead);
                o.setData(a.getData().slice()), e._indexBuffer = o, e._setBuffer(e._vertexBuffers, o),
                    e._setCPUMemory(this.cpuMemory), e._setGPUMemory(this.gpuMemory);
                var s = this._boneNames,
                    l = e._boneNames = P(s.length);
                for (n = 0; n < s.length; n++) l[n] = s[n];
                var h = this._inverseBindPoses,
                    u = e._inverseBindPoses = P(h.length);
                for (n = 0; n < h.length; n++) u[n] = h[n];
                for (e._bindPoseIndices = new Uint16Array(this._bindPoseIndices), n = 0; n < this._skinDataPathMarks.length; n++) e._skinDataPathMarks[n] = this._skinDataPathMarks[n].slice();
                for (n = 0; n < this.subMeshCount; n++) {
                    var c = this._subMeshes[n],
                        _ = c._subIndexBufferStart,
                        d = c._subIndexBufferCount,
                        f = c._boneIndicesList,
                        m = new Ke(e);
                    m._subIndexBufferStart.length = _.length, m._subIndexBufferCount.length = d.length,
                        m._boneIndicesList.length = f.length;
                    for (var p = 0; p < _.length; p++) m._subIndexBufferStart[p] = _[p];
                    for (p = 0; p < d.length; p++) m._subIndexBufferCount[p] = d[p];
                    for (p = 0; p < f.length; p++) m._boneIndicesList[p] = new Uint16Array(f[p]);
                    m._indexBuffer = o, m._indexStart = c._indexStart, m._indexCount = c._indexCount,
                        m._indices = new Uint16Array(o.getData().buffer, 2 * c._indexStart, c._indexCount);
                    var T = e._vertexBuffers[0];
                    m._vertexBuffer = T, e._subMeshes.push(m);
                }
                e._setSubMeshes(e._subMeshes);
            }, e.clone = function() {
                var t = new this.constructor();
                return this.cloneTo(t), t;
            }, u(0, e, "inverseAbsoluteBindPoses", function() {
                return this._inverseBindPoses;
            }), u(0, e, "vertexCount", function() {
                return this._vertexCount;
            }), u(0, e, "subMeshCount", function() {
                return this._subMeshCount;
            }), u(0, e, "boundingBox", function() {
                return this._boundingBox;
            }), u(0, e, "boundingSphere", function() {
                return this._boundingSphere;
            }), c._parse = function(t, e, n) {
                var i = new c();
                return ct.read(t, i, i._subMeshes), i;
            }, c.load = function(t, e) {
                m.loader.create(t, e, null, "MESH");
            }, _(c, ["_nativeTempVector30", function() {
                return this._nativeTempVector30 = new k._physics3D.btVector3(0, 0, 0);
            }, "_nativeTempVector31", function() {
                return this._nativeTempVector31 = new k._physics3D.btVector3(0, 0, 0);
            }, "_nativeTempVector32", function() {
                return this._nativeTempVector32 = new k._physics3D.btVector3(0, 0, 0);
            }]), c;
        }(),
        Nn = function(t) {
            function l(t, e, n, i) {
                this._terrainHeightData = null, this._width = 0, this._height = 0, this._bitType = 0,
                    this._value = NaN, l.__super.call(this), this._width = t, this._height = e, this._bitType = n,
                    this._value = i;
            }
            return d(l, "laya.d3.terrain.TerrainHeightData", D), l._pharse = function(t, e, n) {
                var i, r = new l(n[0], n[1], n[2], n[3]),
                    a = NaN;
                8 == r._bitType ? (i = new Uint8Array(t), a = 1 / 255) : 16 == r._bitType && (i = new Int16Array(t),
                    a = 1 / 32766), r._terrainHeightData = new Float32Array(r._height * r._width);
                for (var o = 0, s = r._height * r._width; o < s; o++) r._terrainHeightData[o] = i[o] * a * r._value / 2;
            }, l.load = function(t, e, n, i, r, a) {
                m.loader.create(t, e, null, "TERRAINHEIGHTDATA", [n, i, r, a], null, 1, !1);
            }, l;
        }(),
        Vn = function(t) {
            function x() {
                x.__super.call(this), this._nodes = new Kt(), this._events = [];
            }
            d(x, "laya.d3.animation.AnimationClip", D);
            var e = x.prototype;
            return e.duration = function() {
                return this._duration;
            }, e._hermiteInterpolate = function(t, e, n, i) {
                var r = t.outTangent,
                    a = e.inTangent;
                if (Number.isFinite(r) && Number.isFinite(a)) {
                    var o = n * n,
                        s = o * n,
                        l = s - 2 * o + n,
                        h = s - o,
                        u = -2 * s + 3 * o;
                    return (2 * s - 3 * o + 1) * t.value + l * r * i + h * a * i + u * e.value;
                }
                return t.value;
            }, e._hermiteInterpolateVector3 = function(t, e, n, i, r) {
                var a = t.value,
                    o = t.outTangent,
                    s = e.value,
                    l = e.inTangent,
                    h = n * n,
                    u = h * n,
                    c = 2 * u - 3 * h + 1,
                    _ = u - 2 * h + n,
                    d = u - h,
                    f = -2 * u + 3 * h,
                    m = o.x,
                    p = l.x;
                Number.isFinite(m) && Number.isFinite(p) ? r.x = c * a.x + _ * m * i + d * p * i + f * s.x : r.x = a.x,
                    m = o.y, p = l.y, Number.isFinite(m) && Number.isFinite(p) ? r.y = c * a.y + _ * m * i + d * p * i + f * s.y : r.y = a.y,
                    m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? r.z = c * a.z + _ * m * i + d * p * i + f * s.z : r.z = a.z;
            }, e._hermiteInterpolateQuaternion = function(t, e, n, i, r) {
                var a = t.value,
                    o = t.outTangent,
                    s = e.value,
                    l = e.inTangent,
                    h = n * n,
                    u = h * n,
                    c = 2 * u - 3 * h + 1,
                    _ = u - 2 * h + n,
                    d = u - h,
                    f = -2 * u + 3 * h,
                    m = o.x,
                    p = l.x;
                Number.isFinite(m) && Number.isFinite(p) ? r.x = c * a.x + _ * m * i + d * p * i + f * s.x : r.x = a.x,
                    m = o.y, p = l.y, Number.isFinite(m) && Number.isFinite(p) ? r.y = c * a.y + _ * m * i + d * p * i + f * s.y : r.y = a.y,
                    m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? r.z = c * a.z + _ * m * i + d * p * i + f * s.z : r.z = a.z,
                    m = o.w, p = l.w, Number.isFinite(m) && Number.isFinite(p) ? r.w = c * a.w + _ * m * i + d * p * i + f * s.w : r.w = a.w;
            }, e._evaluateClipDatasRealTime = function(t, e, n, i, r) {
                for (var a = 0, o = t.count; a < o; a++) {
                    var s = t.getNodeByIndex(a),
                        l = s.type,
                        h = 0,
                        u = s._keyFrames,
                        c = u.length,
                        _ = n[a];
                    if (r)
                        for (-1 !== _ && e < u[_].time && (_ = -1, n[a] = _), h = _ + 1; h < c && !(u[h].time > e);) _++,
                            h++, n[a] = _;
                    else
                        for ((h = _ + 1) !== c && e > u[h].time && (_ = c - 1, n[a] = _),
                            h = _ + 1; - 1 < _ && !(u[_].time < e);) _--, h--, n[a] = _;
                    var d = h === c;
                    switch (l) {
                        case 0:
                            if (-1 !== _) {
                                var f = u[_];
                                if (d) s.data = f.value;
                                else {
                                    var m = u[h],
                                        p = m.time - f.time,
                                        T = NaN;
                                    T = 0 !== p ? (e - f.time) / p : 0, s.data = this._hermiteInterpolate(f, m, T, p);
                                }
                            } else s.data = u[0].value;
                            i && (s.data -= u[0].value);
                            break;

                        case 1:
                        case 4:
                            var E = s.data;
                            if (this._evaluateFrameNodeVector3DatasRealTime(u, _, d, e, E), i) {
                                var v = u[0].value;
                                E.x -= v.x, E.y -= v.y, E.z -= v.z;
                            }
                            break;

                        case 2:
                            var g = s.data;
                            if (this._evaluateFrameNodeQuaternionDatasRealTime(u, _, d, e, g), i) {
                                var S = x._tempQuaternion0,
                                    y = u[0].value;
                                Gt.quaternionConjugate(y, S), rt.multiply(S, g, g);
                            }
                            break;

                        case 3:
                            E = s.data, this._evaluateFrameNodeVector3DatasRealTime(u, _, d, e, E), i && (v = u[0].value,
                                E.x /= v.x, E.y /= v.y, E.z /= v.z);
                            break;

                        default:
                            throw "AnimationClip:unknown node type.";
                    }
                }
            }, e._evaluateClipDatasRealTimeForNative = function(t, e, n, i) {
                E.instance.evaluateClipDatasRealTime(t._nativeObj, e, n, i);
            }, e._evaluateFrameNodeVector3DatasRealTime = function(t, e, n, i, r) {
                if (-1 !== e) {
                    var a = t[e];
                    if (n) {
                        var o = a.value;
                        r.x = o.x, r.y = o.y, r.z = o.z;
                    } else {
                        var s = t[e + 1],
                            l = NaN,
                            h = a.time,
                            u = s.time - h;
                        l = 0 !== u ? (i - h) / u : 0, this._hermiteInterpolateVector3(a, s, l, u, r);
                    }
                } else {
                    var c = t[0].value;
                    r.x = c.x, r.y = c.y, r.z = c.z;
                }
            }, e._evaluateFrameNodeQuaternionDatasRealTime = function(t, e, n, i, r) {
                if (-1 !== e) {
                    var a = t[e];
                    if (n) {
                        var o = a.value;
                        r.x = o.x, r.y = o.y, r.z = o.z, r.w = o.w;
                    } else {
                        var s = t[e + 1],
                            l = NaN,
                            h = a.time,
                            u = s.time - h;
                        l = 0 !== u ? (i - h) / u : 0, this._hermiteInterpolateQuaternion(a, s, l, u, r);
                    }
                } else {
                    var c = t[0].value;
                    r.x = c.x, r.y = c.y, r.z = c.z, r.w = c.w;
                }
            }, e._binarySearchEventIndex = function(t) {
                for (var e = 0, n = this._events.length - 1, i = 0; e <= n;) {
                    i = Math.floor((e + n) / 2);
                    var r = this._events[i].time;
                    if (r == t) return i;
                    t < r ? n = i - 1 : e = i + 1;
                }
                return e;
            }, e.addEvent = function(t) {
                var e = this._binarySearchEventIndex(t.time);
                this._events.splice(e, 0, t);
            }, e._disposeResource = function() {
                this._nodes = null, this._nodesMap = null;
            }, x._parse = function(t, e, n) {
                var i = new x(),
                    r = new s(t),
                    a = r.readUTFString();
                switch (a) {
                    case "LAYAANIMATION:03":
                        bt.parse(i, r);
                        break;

                    case "LAYAANIMATION:04":
                    case "LAYAANIMATION:COMPRESSION_04":
                        Pt.parse(i, r, a);
                        break;

                    default:
                        throw "unknown animationClip version.";
                }
                return i;
            }, x.load = function(t, e) {
                m.loader.create(t, e, null, "ANIMATIONCLIP");
            }, _(x, ["_tempQuaternion0", function() {
                return this._tempQuaternion0 = new rt();
            }]), x;
        }(),
        wn = function(t) {
            function a(t, e, n, i, r) {
                this._stateParamsMap = [], this._uploadMark = -1, this._uploadRenderType = -1, a.__super.call(this),
                    this._vs = t, this._ps = e, this._attributeMap = n, this._uniformMap = i, this._shaderPass = r,
                    this._create(), this.lock = !0;
            }
            d(a, "laya.d3.shader.ShaderInstance", D);
            var e = a.prototype;
            return e._create = function() {
                var t = E.instance;
                for (var e in this._program = t.createProgram(), this._vshader = this._createShader(t, this._vs, 35633),
                        this._pshader = this._createShader(t, this._ps, 35632), t.attachShader(this._program, this._vshader),
                        t.attachShader(this._program, this._pshader), this._attributeMap) t.bindAttribLocation(this._program, this._attributeMap[e], e);
                if (t.linkProgram(this._program), !b.isConchApp && Vt.debugMode && !t.getProgramParameter(this._program, 35714)) throw t.getProgramInfoLog(this._program);
                var n = [],
                    i = [],
                    r = [],
                    a = [],
                    o = [];
                this._customUniformParamsMap = [];
                var s = t.getProgramParameter(this._program, 35718);
                V.useProgram(t, this._program);
                var l, h = this._curActTexIndex = 0,
                    u = 0;
                for (h = 0; h < s; h++) {
                    var c = t.getActiveUniform(this._program, h),
                        _ = c.name;
                    (l = new pe()).location = t.getUniformLocation(this._program, _), 0 < _.indexOf("[0]") ? (l.name = _ = _.substr(0, _.length - 3),
                        l.isArray = !0) : (l.name = _, l.isArray = !1), l.type = c.type, this._addShaderUnifiormFun(l);
                    var d = this._uniformMap[_];
                    if (null != d) switch (l.dataOffset = Vt.propertyNameToID(_), d) {
                        case 0:
                            o.push(l);
                            break;

                        case 1:
                            a.push(l);
                            break;

                        case 2:
                            r.push(l);
                            break;

                        case 3:
                            i.push(l);
                            break;

                        case 4:
                            n.push(l);
                            break;

                        default:
                            throw new Error("Shader3D: period is unkonw.");
                    }
                }
                for (this._sceneUniformParamsMap = E.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0),
                    h = 0, u = n.length; h < u; h++) this._sceneUniformParamsMap.addShaderUniform(n[h]);
                for (this._cameraUniformParamsMap = E.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0),
                    h = 0, u = i.length; h < u; h++) this._cameraUniformParamsMap.addShaderUniform(i[h]);
                for (this._spriteUniformParamsMap = E.instance.createCommandEncoder(4 * r.length * 5 + 4, 64, !0),
                    h = 0, u = r.length; h < u; h++) this._spriteUniformParamsMap.addShaderUniform(r[h]);
                for (this._materialUniformParamsMap = E.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0),
                    h = 0, u = a.length; h < u; h++) this._materialUniformParamsMap.addShaderUniform(a[h]);
                for (this._customUniformParamsMap.length = o.length, h = 0, u = o.length; h < u; h++) {
                    var f = o[h];
                    this._customUniformParamsMap[f.dataOffset] = f;
                }
                var m = this._shaderPass._stateMap;
                for (var p in m) this._stateParamsMap[m[p]] = Vt.propertyNameToID(p);
            }, e._getRenderState = function(t, e) {
                var n = this._stateParamsMap[e];
                return null == n ? null : t[n];
            }, e._disposeResource = function() {
                E.instance.deleteShader(this._vshader), E.instance.deleteShader(this._pshader),
                    E.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null,
                    this._setGPUMemory(0), this._curActTexIndex = 0;
            }, e._addShaderUnifiormFun = function(t) {
                var e = E.instance;
                t.caller = this;
                var n = t.isArray;
                switch (t.type) {
                    case 35670:
                        t.fun = this._uniform1i, t.uploadedValue = new Array(1);
                        break;

                    case 5124:
                        t.fun = n ? this._uniform1iv : this._uniform1i, t.uploadedValue = new Array(1);
                        break;

                    case 5126:
                        t.fun = n ? this._uniform1fv : this._uniform1f, t.uploadedValue = new Array(1);
                        break;

                    case 35664:
                        t.fun = n ? this._uniform_vec2v : this._uniform_vec2, t.uploadedValue = new Array(2);
                        break;

                    case 35665:
                        t.fun = n ? this._uniform_vec3v : this._uniform_vec3, t.uploadedValue = new Array(3);
                        break;

                    case 35666:
                        t.fun = n ? this._uniform_vec4v : this._uniform_vec4, t.uploadedValue = new Array(4);
                        break;

                    case 35674:
                        t.fun = this._uniformMatrix2fv;
                        break;

                    case 35675:
                        t.fun = this._uniformMatrix3fv;
                        break;

                    case 35676:
                        t.fun = n ? this._uniformMatrix4fv : this._uniformMatrix4f;
                        break;

                    case 35678:
                        e.uniform1i(t.location, this._curActTexIndex), t.textureID = V._glTextureIDs[this._curActTexIndex++],
                            t.fun = this._uniform_sampler2D;
                        break;

                    case 35679:
                        e.uniform1i(t.location, this._curActTexIndex), t.textureID = V._glTextureIDs[this._curActTexIndex++],
                            t.fun = this._uniform_sampler3D;
                        break;

                    case 35680:
                        e.uniform1i(t.location, this._curActTexIndex), t.textureID = V._glTextureIDs[this._curActTexIndex++],
                            t.fun = this._uniform_samplerCube;
                        break;

                    default:
                        throw new Error("compile shader err!");
                }
            }, e._createShader = function(t, e, n) {
                var i = t.createShader(n);
                if (t.shaderSource(i, e), t.compileShader(i), Vt.debugMode && !t.getShaderParameter(i, 35713)) throw t.getShaderInfoLog(i);
                return i;
            }, e._uniform1f = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e ? (E.instance.uniform1f(t.location, n[0] = e), 1) : 0;
            }, e._uniform1fv = function(t, e) {
                if (e.length < 4) {
                    var n = t.uploadedValue;
                    return n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] ? (E.instance.uniform1fv(t.location, e),
                        n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], 1) : 0;
                }
                return E.instance.uniform1fv(t.location, e), 1;
            }, e._uniform_vec2 = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e.x || n[1] !== e.y ? (E.instance.uniform2f(t.location, n[0] = e.x, n[1] = e.y),
                    1) : 0;
            }, e._uniform_vec2v = function(t, e) {
                if (e.length < 2) {
                    var n = t.uploadedValue;
                    return n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] ? (E.instance.uniform2fv(t.location, e),
                        n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], 1) : 0;
                }
                return E.instance.uniform2fv(t.location, e), 1;
            }, e._uniform_vec3 = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e.x || n[1] !== e.y || n[2] !== e.z ? (E.instance.uniform3f(t.location, n[0] = e.x, n[1] = e.y, n[2] = e.z),
                    1) : 0;
            }, e._uniform_vec3v = function(t, e) {
                return E.instance.uniform3fv(t.location, e), 1;
            }, e._uniform_vec4 = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w ? (E.instance.uniform4f(t.location, n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w),
                    1) : 0;
            }, e._uniform_vec4v = function(t, e) {
                return E.instance.uniform4fv(t.location, e), 1;
            }, e._uniformMatrix2fv = function(t, e) {
                return E.instance.uniformMatrix2fv(t.location, !1, e), 1;
            }, e._uniformMatrix3fv = function(t, e) {
                return E.instance.uniformMatrix3fv(t.location, !1, e), 1;
            }, e._uniformMatrix4f = function(t, e) {
                var n = e.elements;
                return E.instance.uniformMatrix4fv(t.location, !1, n), 1;
            }, e._uniformMatrix4fv = function(t, e) {
                return E.instance.uniformMatrix4fv(t.location, !1, e), 1;
            }, e._uniform1i = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e ? (E.instance.uniform1i(t.location, n[0] = e), 1) : 0;
            }, e._uniform1iv = function(t, e) {
                return E.instance.uniform1iv(t.location, e), 1;
            }, e._uniform_ivec2 = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e[0] || n[1] !== e[1] ? (E.instance.uniform2i(t.location, n[0] = e[0], n[1] = e[1]),
                    1) : 0;
            }, e._uniform_ivec2v = function(t, e) {
                return E.instance.uniform2iv(t.location, e), 1;
            }, e._uniform_vec3i = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] ? (E.instance.uniform3i(t.location, n[0] = e[0], n[1] = e[1], n[2] = e[2]),
                    1) : 0;
            }, e._uniform_vec3vi = function(t, e) {
                return E.instance.uniform3iv(t.location, e), 1;
            }, e._uniform_vec4i = function(t, e) {
                var n = t.uploadedValue;
                return n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] ? (E.instance.uniform4i(t.location, n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3]),
                    1) : 0;
            }, e._uniform_vec4vi = function(t, e) {
                return E.instance.uniform4iv(t.location, e), 1;
            }, e._uniform_sampler2D = function(t, e) {
                var n = e._getSource() || e.defaulteTexture._getSource(),
                    i = E.instance;
                return V.activeTexture(i, t.textureID), V.bindTexture(i, 3553, n), 0;
            }, e._uniform_sampler3D = function(t, e) {
                var n = e._getSource() || e.defaulteTexture._getSource(),
                    i = E.instance;
                return V.activeTexture(i, t.textureID), V.bindTexture(i, 32879, n), 0;
            }, e._uniform_samplerCube = function(t, e) {
                var n = e._getSource() || e.defaulteTexture._getSource(),
                    i = E.instance;
                return V.activeTexture(i, t.textureID), V.bindTexture(i, 34067, n), 0;
            }, e.bind = function() {
                return V.useProgram(E.instance, this._program);
            }, e.uploadUniforms = function(t, e, n) {
                M.shaderCall += f.uploadShaderUniforms(E.instance, t, e, n);
            }, e.uploadRenderStateBlendDepth = function(t) {
                var e = E.instance,
                    n = this._shaderPass.renderState,
                    i = t.getData(),
                    r = this._getRenderState(i, 13),
                    a = this._getRenderState(i, 12),
                    o = this._getRenderState(i, 1);
                switch (null == r && (r = n.depthWrite), null == a && (a = n.depthTest), null == o && (o = n.blend),
                    V.setDepthMask(e, r), 0 === a ? V.setDepthTest(e, !1) : (V.setDepthTest(e, !0),
                        V.setDepthFunc(e, a)), o) {
                    case 0:
                        V.setBlend(e, !1);
                        break;

                    case 1:
                        V.setBlend(e, !0);
                        var s = this._getRenderState(i, 2);
                        null == s && (s = n.srcBlend);
                        var l = this._getRenderState(i, 3);
                        null == l && (l = n.dstBlend), V.setBlendFunc(e, s, l);
                        break;

                    case 2:
                        V.setBlend(e, !0);
                        var h = this._getRenderState(i, 4);
                        null == h && (h = n.srcBlendRGB);
                        var u = this._getRenderState(i, 5);
                        null == u && (u = n.dstBlendRGB);
                        var c = this._getRenderState(i, 6);
                        null == c && (c = n.srcBlendAlpha);
                        var _ = this._getRenderState(i, 7);
                        null == _ && (_ = n.dstBlendAlpha), V.setBlendFuncSeperate(e, h, u, c, _);
                }
            }, e.uploadRenderStateFrontFace = function(t, e, n) {
                var i = E.instance,
                    r = this._shaderPass.renderState,
                    a = t.getData(),
                    o = this._getRenderState(a, 0);
                null == o && (o = r.cull);
                var s = 0;
                switch (o) {
                    case 0:
                        V.setCullFace(i, !1);
                        break;

                    case 1:
                        V.setCullFace(i, !0), s = e ? n && n._isFrontFaceInvert ? 2305 : 2304 : n && n._isFrontFaceInvert ? 2304 : 2305,
                            V.setFrontFace(i, s);
                        break;

                    case 2:
                        V.setCullFace(i, !0), s = e ? n && n._isFrontFaceInvert ? 2304 : 2305 : n && n._isFrontFaceInvert ? 2305 : 2304,
                            V.setFrontFace(i, s);
                }
            }, e.uploadCustomUniform = function(t, e) {
                M.shaderCall += f.uploadCustomUniform(E.instance, this._customUniformParamsMap, t, e);
            }, e._uniformMatrix2fvForNative = function(t, e) {
                return E.instance.uniformMatrix2fvEx(t.location, !1, e), 1;
            }, e._uniformMatrix3fvForNative = function(t, e) {
                return E.instance.uniformMatrix3fvEx(t.location, !1, e), 1;
            }, e._uniformMatrix4fvForNative = function(t, e) {
                return E.instance.uniformMatrix4fvEx(t.location, !1, e), 1;
            }, a;
        }(),
        Pn = (function(t) {
            function r() {
                this._version = NaN, this._cameraCoordinateInverse = !1, this._gridSize = NaN, this._chunkNumX = 0,
                    this._chunkNumZ = 0, this._heightDataX = 0, this._heightDataZ = 0, this._heightDataBitType = 0,
                    this._heightDataValue = NaN, this._heightDataUrl = null, this._detailTextureInfos = null,
                    this._chunkInfos = null, this._heightData = null, this._materialInfo = null, this._alphaMaps = null,
                    this._normalMaps = null, r.__super.call(this);
            }
            d(r, "laya.d3.terrain.TerrainRes", D);
            var e = r.prototype;
            e.parseData = function(t) {
                var e = t[0],
                    n = t[1];
                if (this._version = e.version, 1 == this._version) {
                    this._cameraCoordinateInverse = e.cameraCoordinateInverse, this._gridSize = e.gridSize,
                        this._chunkNumX = e.chunkNumX, this._chunkNumZ = e.chunkNumZ;
                    var i = e.heightData;
                    if (this._heightDataX = i.numX, this._heightDataZ = i.numZ, this._heightDataBitType = i.bitType,
                        this._heightDataValue = i.value, this._heightDataUrl = n[i.url], this._materialInfo = new nt(),
                        e.material) {
                        var r = e.material.ambient,
                            a = e.material.diffuse,
                            o = e.material.specular;
                        this._materialInfo.ambientColor = new Ct(r[0], r[1], r[2]), this._materialInfo.diffuseColor = new Ct(a[0], a[1], a[2]),
                            this._materialInfo.specularColor = new At(o[0], o[1], o[2], o[3]);
                    }
                    var s = e.detailTexture;
                    this._detailTextureInfos = P(s.length);
                    for (var l = 0; l < s.length; l++) {
                        var h = s[l],
                            u = new ye();
                        u.diffuseTexture = n[h.diffuse], u.normalTexture = h.normal ? n[h.normal] : null,
                            h.scale ? u.scale = new Lt(h.scale[0], h.scale[1]) : u.scale = new Lt(1, 1), h.offset ? u.offset = new Lt(h.offset[0], h.offset[1]) : u.offset = new Lt(0, 0),
                            this._detailTextureInfos[l] = u;
                    }
                    var c = e.alphaMap;
                    for (this._alphaMaps = P(c.length), l = 0; l < this._alphaMaps.length; l++) this._alphaMaps[l] = e.alphaMap[l];
                    var _ = e.normalMap;
                    for (this._normalMaps = P(_.length), l = 0; l < this._normalMaps.length; l++) this._normalMaps[l] = e.normalMap[l];
                    var d = e.chunkInfo;
                    if (this._chunkNumX * this._chunkNumZ != d.length) return alert("terrain data error"), !1;
                    for (this._chunkInfos = P(d.length), l = 0; l < d.length; l++) {
                        var f = d[l],
                            m = new me(),
                            p = f.alphaMap.length,
                            T = f.detailID.length;
                        if (p != T) return alert("terrain chunk data error"), !1;
                        m.alphaMap = P(p), m.detailID = P(T), m.normalMap = n[this._normalMaps[f.normalMap]];
                        for (var E = 0; E < p; E++) {
                            m.alphaMap[E] = n[this._alphaMaps[f.alphaMap[E]]];
                            var v = f.detailID[E],
                                g = v.length;
                            m.detailID[E] = new Uint8Array(g);
                            for (var S = 0; S < g; S++) m.detailID[E][S] = v[S];
                        }
                        this._chunkInfos[l] = m;
                    }
                    this._heightData = xt.getRes(this._heightDataUrl), this.onLoadTerrainComplete(this._heightData);
                }
                return !0;
            }, e.onLoadTerrainComplete = function(t) {}, r._parse = function(t, e, n) {
                var i = new r();
                return i.parseData(t), i;
            }, r.load = function(t, e) {
                m.loader.create(t, e, null, "TERRAIN", null, null, 1, !1);
            };
        }(), function(t) {
            function e(t) {
                this._finalGravity = new Ct(), this._tempRotationMatrix = new be(), e.__super.call(this, t),
                    this._defaultBoundBox = new we(new Ct(), new Ct()), this._renderMode = -1, this.stretchedBillboardCameraSpeedScale = 0,
                    this.stretchedBillboardSpeedScale = 0, this.stretchedBillboardLengthScale = 1;
            }
            d(e, "laya.d3.core.particleShuriKen.ShurikenParticleRenderer", t);
            var n = e.prototype;
            return n._calculateBoundingBox = function() {
                var t = this._boundingBox.min;
                t.x = -Number.MAX_VALUE, t.y = -Number.MAX_VALUE, t.z = -Number.MAX_VALUE;
                var e = this._boundingBox.min;
                e.x = Number.MAX_VALUE, e.y = Number.MAX_VALUE, e.z = Number.MAX_VALUE;
            }, n._calculateBoundingSphere = function() {
                var t = this._owner.particleSystem._boundingSphere,
                    e = NaN,
                    n = this._owner.transform,
                    i = n.scale,
                    r = Math.abs(i.x),
                    a = Math.abs(i.y),
                    o = Math.abs(i.z);
                if (e = a <= r && o <= r ? r : o <= a ? a : o, Ct.transformCoordinate(t.center, n.worldMatrix, this._boundingSphere.center),
                    this._boundingSphere.radius = t.radius * e, b.supportWebGLPlusCulling) {
                    var s = this._boundingSphere.center,
                        l = Ce._cullingBuffer;
                    l[this._cullingBufferIndex + 1] = s.x, l[this._cullingBufferIndex + 2] = s.y, l[this._cullingBufferIndex + 3] = s.z,
                        l[this._cullingBufferIndex + 4] = this._boundingSphere.radius;
                }
            }, n._needRender = function(t) {
                return !t || 0 !== t.containsBoundSphere(this.boundingSphere) && !!this._owner.particleSystem.isAlive;
            }, n._renderUpdate = function(t, e) {
                var n = this._owner.particleSystem,
                    i = this._shaderValues,
                    r = this._owner.transform;
                switch (n.simulationSpace) {
                    case 0:
                        break;

                    case 1:
                        i.setVector3(_i.WORLDPOSITION, r.position), i.setQuaternion(_i.WORLDROTATION, r.rotation);
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
                switch (n.scaleMode) {
                    case 0:
                        var a = r.scale;
                        i.setVector3(_i.POSITIONSCALE, a), i.setVector3(_i.SIZESCALE, a);
                        break;

                    case 1:
                        var o = r.localScale;
                        i.setVector3(_i.POSITIONSCALE, o), i.setVector3(_i.SIZESCALE, o);
                        break;

                    case 2:
                        i.setVector3(_i.POSITIONSCALE, r.scale), i.setVector3(_i.SIZESCALE, Ct._ONE);
                }
                Ct.scale(Ve.gravity, n.gravityModifier, this._finalGravity), i.setVector3(_i.GRAVITY, this._finalGravity),
                    i.setInt(_i.SIMULATIONSPACE, n.simulationSpace), i.setBool(_i.THREEDSTARTROTATION, n.threeDStartRotation),
                    i.setInt(_i.SCALINGMODE, n.scaleMode), i.setNumber(_i.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale),
                    i.setNumber(_i.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale),
                    i.setNumber(_i.CURRENTTIME, n._currentTime);
            }, n._destroy = function() {
                t.prototype._destroy.call(this), this._mesh && (this._mesh._removeReference(), this._mesh = null);
            }, u(0, n, "boundingBox", function() {
                return this._owner.particleSystem.isAlive ? (this._boundingBoxNeedChange && (this._calculateBoundingBox(),
                    this._boundingBoxNeedChange = !1), this._boundingBox) : this._defaultBoundBox;
            }), u(0, n, "renderMode", function() {
                return this._renderMode;
            }, function(t) {
                if (this._renderMode !== t) {
                    var e = this._defineDatas;
                    switch (this._renderMode) {
                        case 0:
                            e.remove(_i.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;

                        case 1:
                            e.remove(_i.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;

                        case 2:
                            e.remove(_i.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;

                        case 3:
                            e.remove(_i.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;

                        case 4:
                            e.remove(_i.SHADERDEFINE_RENDERMODE_MESH);
                    }
                    switch (this._renderMode = t) {
                        case 0:
                            e.add(_i.SHADERDEFINE_RENDERMODE_BILLBOARD);
                            break;

                        case 1:
                            e.add(_i.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                            break;

                        case 2:
                            e.add(_i.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                            break;

                        case 3:
                            e.add(_i.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                            break;

                        case 4:
                            e.add(_i.SHADERDEFINE_RENDERMODE_MESH);
                            break;

                        default:
                            throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                    }
                    this._owner.particleSystem._initBufferDatas();
                }
            }), u(0, n, "mesh", function() {
                return this._mesh;
            }, function(t) {
                this._mesh !== t && (this._mesh && this._mesh._removeReference(), (this._mesh = t) && t._addReference(),
                    this._owner.particleSystem._initBufferDatas());
            }), e;
        }(Ue)),
        bn = function(e) {
            function n(t, e) {
                this._isTrigger = !1, n.__super.call(this, t, e);
            }
            d(n, "laya.d3.physics.PhysicsTriggerComponent", e);
            var t = n.prototype;
            return t._onAdded = function() {
                e.prototype._onAdded.call(this), this.isTrigger = this._isTrigger;
            }, t._cloneTo = function(t) {
                e.prototype._cloneTo.call(this, t), t.isTrigger = this._isTrigger;
            }, u(0, t, "isTrigger", function() {
                return this._isTrigger;
            }, function(t) {
                if (this._isTrigger = t, this._nativeColliderObject) {
                    var e = this._nativeColliderObject.getCollisionFlags();
                    t ? 0 == (4 & e) && this._nativeColliderObject.setCollisionFlags(4 | e) : 0 != (4 & e) && this._nativeColliderObject.setCollisionFlags(4 ^ e);
                }
            }), n;
        }(Be),
        Fn = (function(n) {
            function r(t, e, n, i) {
                this._maxSlope = 45, this._jumpSpeed = 10, this._fallSpeed = 55, this._upAxis = new Ct(0, 1, 0),
                    this._gravity = new Ct(0, 3 * -9.8, 0), void 0 === t && (t = .1), void 0 === n && (n = 1),
                    void 0 === i && (i = Ve.COLLISIONFILTERGROUP_ALLFILTER), this._stepHeight = t, e && (this._upAxis = e),
                    r.__super.call(this, n, i);
            }
            d(r, "laya.d3.physics.CharacterController", n);
            var t = r.prototype;
            t._constructCharacter = function() {
                var t = k._physics3D;
                this._nativeKinematicCharacter && t.destroy(this._nativeKinematicCharacter);
                var e = r._nativeTempVector30;
                e.setValue(this._upAxis.x, this._upAxis.y, this._upAxis.z), this._nativeKinematicCharacter = new t.btKinematicCharacterController(this._nativeColliderObject, this._colliderShape._nativeShape, this._stepHeight, e),
                    this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed,
                    this.gravity = this._gravity;
            }, t._onShapeChange = function(t) {
                n.prototype._onShapeChange.call(this, t), this._constructCharacter();
            }, t._onAdded = function() {
                var t = new k._physics3D.btPairCachingGhostObject();
                t.setUserIndex(this.id), t.setCollisionFlags(16), this._nativeColliderObject = t,
                    this._colliderShape && this._constructCharacter(), n.prototype._onAdded.call(this);
            }, t._addToSimulation = function() {
                this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
            }, t._removeFromSimulation = function() {
                this._simulation._removeCharacter(this);
                var t = this._simulation._characters;
                t.splice(t.indexOf(this), 1);
            }, t._cloneTo = function(t) {
                n.prototype._cloneTo.call(this, t);
                var e = t;
                e.stepHeight = this._stepHeight, e.upAxis = this._upAxis, e.maxSlope = this._maxSlope,
                    e.jumpSpeed = this._jumpSpeed, e.fallSpeed = this._fallSpeed, e.gravity = this._gravity;
            }, t._onDestroy = function() {
                k._physics3D.destroy(this._nativeKinematicCharacter), n.prototype._onDestroy.call(this),
                    this._nativeKinematicCharacter = null;
            }, t.move = function(t) {
                var e = Be._nativeVector30;
                e.setValue(-t.x, t.y, t.z), this._nativeKinematicCharacter.setWalkDirection(e);
            }, t.jump = function(t) {
                if (t) {
                    var e = Be._nativeVector30;
                    Gt._convertToBulletVec3(t, e, !0), this._nativeKinematicCharacter.jump(e);
                } else this._nativeKinematicCharacter.jump();
            }, u(0, t, "fallSpeed", function() {
                return this._fallSpeed;
            }, function(t) {
                this._fallSpeed = t, this._nativeKinematicCharacter.setFallSpeed(t);
            }), u(0, t, "stepHeight", function() {
                return this._stepHeight;
            }, function(t) {
                this._stepHeight = t, this._constructCharacter();
            }), u(0, t, "jumpSpeed", function() {
                return this._jumpSpeed;
            }, function(t) {
                this._jumpSpeed = t, this._nativeKinematicCharacter.setJumpSpeed(t);
            }), u(0, t, "gravity", function() {
                return this._gravity;
            }, function(t) {
                this._gravity = t;
                var e = r._nativeTempVector30;
                e.setValue(-t.x, t.y, t.z), this._nativeKinematicCharacter.setGravity(e);
            }), u(0, t, "maxSlope", function() {
                return this._maxSlope;
            }, function(t) {
                this._maxSlope = t, this._nativeKinematicCharacter.setMaxSlope(t / 180 * Math.PI);
            }), u(0, t, "isGrounded", function() {
                return this._nativeKinematicCharacter.onGround();
            }), u(0, t, "upAxis", function() {
                return this._upAxis;
            }, function(t) {
                this._upAxis = t, this._constructCharacter();
            }), r.UPAXIS_X = 0, r.UPAXIS_Y = 1, r.UPAXIS_Z = 2, _(r, ["_nativeTempVector30", function() {
                return this._nativeTempVector30 = new k._physics3D.btVector3(0, 0, 0);
            }]);
        }(Be), function(t) {
            function e(t) {
                this._terrainSprite3DOwner = null, this._projectionViewWorldMatrix = null, e.__super.call(this, t),
                    this._terrainSprite3DOwner = t, this._projectionViewWorldMatrix = new be();
            }
            d(e, "laya.d3.terrain.TerrainRender", t);
            var n = e.prototype;
            return n._calculateBoundingSphere = function() {
                var t = this._terrainSprite3DOwner.terrainFilter;
                if (null == t) this._boundingSphere.toDefault();
                else {
                    var e = t._boundingSphere,
                        n = NaN,
                        i = this._terrainSprite3DOwner.transform,
                        r = i.scale;
                    if (n = r.x >= r.y && r.x >= r.z ? r.x : r.y >= r.z ? r.y : r.z, Ct.transformCoordinate(e.center, i.worldMatrix, this._boundingSphere.center),
                        this._boundingSphere.radius = e.radius * n, t.calcLeafBoudingSphere(i.worldMatrix, n),
                        b.supportWebGLPlusCulling) {
                        var a = this._boundingSphere.center,
                            o = Ce._cullingBuffer;
                        o[this._cullingBufferIndex + 1] = a.x, o[this._cullingBufferIndex + 2] = a.y, o[this._cullingBufferIndex + 3] = a.z,
                            o[this._cullingBufferIndex + 4] = this._boundingSphere.radius;
                    }
                }
            }, n._needRender = function(t) {
                return !t || 0 !== t.containsBoundSphere(this.boundingSphere);
            }, n._calculateBoundingBox = function() {
                var t = this._terrainSprite3DOwner.terrainFilter;
                if (null == t) this._boundingBox.toDefault();
                else {
                    for (var e = this._terrainSprite3DOwner.transform.worldMatrix, n = t._boundingBoxCorners, i = 0; i < 8; i++) Ct.transformCoordinate(n[i], e, Ue._tempBoundBoxCorners[i]);
                    we.createfromPoints(Ue._tempBoundBoxCorners, this._boundingBox), t.calcLeafBoudingBox(e);
                }
            }, n._renderUpdate = function(t, e) {
                this._shaderValues.setMatrix4x4(An.WORLDMATRIX, e.worldMatrix);
            }, n._renderUpdateWithCamera = function(t, e) {
                var n = t.projectionViewMatrix;
                be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix);
            }, n._destroy = function() {
                t.prototype._destroy.call(this), this._terrainSprite3DOwner = null;
            }, e;
        }(Ue)),
        Bn = function(t) {
            function e(t) {
                e.__super.call(this, t), this._projectionViewWorldMatrix = new be();
            }
            d(e, "laya.d3.core.MeshRenderer", t);
            var n = e.prototype;
            return n._onMeshChange = function(t) {
                this._boundingSphereNeedChange = !0, this._boundingBoxNeedChange = !0, this._boundingBoxCenterNeedChange = !0;
            }, n._calculateBoundingSphereByInitSphere = function(t) {
                var e = NaN,
                    n = this._owner.transform,
                    i = n.scale,
                    r = i.x;
                r || (r = -r);
                var a = i.y;
                a || (a = -a);
                var o = i.z;
                if (o || (o = -o), e = a <= r && o <= r ? r : o <= a ? a : o, Ct.transformCoordinate(t.center, n.worldMatrix, this._boundingSphere.center),
                    this._boundingSphere.radius = t.radius * e, b.supportWebGLPlusCulling) {
                    var s = this._boundingSphere.center,
                        l = Ce._cullingBuffer;
                    l[this._cullingBufferIndex + 1] = s.x, l[this._cullingBufferIndex + 2] = s.y, l[this._cullingBufferIndex + 3] = s.z,
                        l[this._cullingBufferIndex + 4] = this._boundingSphere.radius;
                }
            }, n._calculateBoundBoxByInitCorners = function(t) {
                var e = this._owner.transform.worldMatrix;
                t.tranform(e, this._boundingBox);
            }, n._calculateBoundingSphere = function() {
                var t = this._owner.meshFilter.sharedMesh;
                null == t || null == t.boundingSphere ? this._boundingSphere.toDefault() : this._calculateBoundingSphereByInitSphere(t.boundingSphere);
            }, n._calculateBoundingBox = function() {
                var t = this._owner.meshFilter.sharedMesh;
                null == t || null == t.boundingBox ? this._boundingBox.toDefault() : this._calculateBoundBoxByInitCorners(t.boundingBox);
            }, n._changeRenderObjectsByMesh = function(t) {
                var e = t.subMeshCount;
                this._renderElements.length = e;
                for (var n = 0; n < e; n++) {
                    var i = this._renderElements[n];
                    if (!i) {
                        var r = this.sharedMaterials[n];
                        (i = this._renderElements[n] = new Rn()).setTransform(this._owner._transform), i.render = this,
                            i.material = r || ei.defaultMaterial;
                    }
                    i.setGeometry(t._getSubMesh(n));
                }
            }, n._needRender = function(t) {
                return !t || 0 !== t.containsBoundBox(this.boundingBox);
            }, n._renderUpdate = function(t, e) {
                var n = t.renderElement;
                switch (n.renderType) {
                    case 0:
                        this._shaderValues.setMatrix4x4(An.WORLDMATRIX, e.worldMatrix);
                        break;

                    case 1:
                        this._oriDefineValue = this._defineDatas.value, e ? this._shaderValues.setMatrix4x4(An.WORLDMATRIX, e.worldMatrix) : this._shaderValues.setMatrix4x4(An.WORLDMATRIX, be.DEFAULT),
                            this._defineDatas.add(li.SHADERDEFINE_UV1), this._defineDatas.remove(Hn.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                        break;

                    case 3:
                        this._shaderValues.setMatrix4x4(An.WORLDMATRIX, be.DEFAULT);
                        break;

                    case 2:
                        for (var i = hn.instance.instanceWorldMatrixData, r = n.instanceBatchElementList, a = r.length, o = 0; o < a; o++) i.set(r[o]._transform.worldMatrix.elements, 16 * o);
                        hn.instance.instanceWorldMatrixBuffer.setData(i, 0, 0, 16 * a), this._defineDatas.add(li.SHADERDEFINE_GPU_INSTANCE);
                }
            }, n._renderUpdateWithCamera = function(t, e) {
                var n = t.projectionViewMatrix,
                    i = t.renderElement;
                switch (i.renderType) {
                    case 0:
                    case 1:
                    case 3:
                        e ? (be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(An.MVPMATRIX, n);
                        break;

                    case 2:
                        for (var r = hn.instance.instanceMVPMatrixData, a = i.instanceBatchElementList, o = a.length, s = 0; s < o; s++) {
                            var l = a[s]._transform.worldMatrix;
                            Gt.mulMatrixByArray(n.elements, 0, l.elements, 0, r, 16 * s);
                        }
                        hn.instance.instanceMVPMatrixBuffer.setData(r, 0, 0, 16 * o);
                }
            }, n._renderUpdateWithCameraForNative = function(t, e) {
                var n = t.projectionViewMatrix,
                    i = t.renderElement;
                switch (i.renderType) {
                    case 0:
                        e ? (be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(An.MVPMATRIX, n);
                        break;

                    case 1:
                    case 3:
                        var r = at._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                        at.setRuntimeValueMode(!1), e ? (be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix),
                                this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(An.MVPMATRIX, n),
                            at.setRuntimeValueMode(r);
                        break;

                    case 2:
                        for (var a = hn.instance.instanceMVPMatrixData, o = i.instanceBatchElementList, s = o.length, l = 0; l < s; l++) {
                            var h = o[l]._transform.worldMatrix;
                            Gt.mulMatrixByArray(n.elements, 0, h.elements, 0, a, 16 * l);
                        }
                        hn.instance.instanceMVPMatrixBuffer.setData(a, 0, 0, 16 * s);
                }
            }, n._revertBatchRenderUpdate = function(t) {
                switch (t.renderElement.renderType) {
                    case 1:
                        this._defineDatas.value = this._oriDefineValue;
                        break;

                    case 2:
                        this._defineDatas.remove(li.SHADERDEFINE_GPU_INSTANCE);
                }
            }, n._destroy = function() {
                this._isPartOfStaticBatch && dn.instance._destroyRenderSprite(this._owner), t.prototype._destroy.call(this);
            }, _(e, ["_tempVector30", function() {
                return this._tempVector30 = new Ct();
            }, "_tempVector31", function() {
                return this._tempVector31 = new Ct();
            }]), e;
        }(Ue),
        Un = function(n) {
            function e(t) {
                this._projectionViewWorldMatrix = new be(), e.__super.call(this, t);
            }
            d(e, "laya.d3.core.trail.TrailRenderer", n);
            var t = e.prototype;
            return t._calculateBoundingBox = function() {
                var t = this._boundingBox.min;
                t.x = -Number.MAX_VALUE, t.y = -Number.MAX_VALUE, t.z = -Number.MAX_VALUE;
                var e = this._boundingBox.min;
                e.x = Number.MAX_VALUE, e.y = Number.MAX_VALUE, e.z = Number.MAX_VALUE;
            }, t._calculateBoundingSphere = function() {
                if (this._owner.transform.position.cloneTo(this._boundingSphere.center), this._boundingSphere.radius = Number.MAX_VALUE,
                    b.isConchApp) {
                    var t = this._boundingSphere.center,
                        e = Ce._cullingBuffer;
                    e[this._cullingBufferIndex + 1] = t.x, e[this._cullingBufferIndex + 2] = t.y, e[this._cullingBufferIndex + 3] = t.z,
                        e[this._cullingBufferIndex + 4] = this._boundingSphere.radius;
                }
            }, t._needRender = function(t) {
                return !0;
            }, t._renderUpdate = function(t, e) {
                n.prototype._renderUpdate.call(this, t, e), this._owner.trailFilter._update(t);
            }, t._renderUpdateWithCamera = function(t, e) {
                var n = t.projectionViewMatrix;
                e ? (be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(An.MVPMATRIX, n);
            }, e;
        }(Ue),
        zn = function(t) {
            function e(t) {
                this._projectionViewWorldMatrix = null, e.__super.call(this, t), this._projectionViewWorldMatrix = new be();
            }
            d(e, "laya.d3.core.pixelLine.PixelLineRenderer", Ue);
            var n = e.prototype;
            return n._calculateBoundingBox = function() {
                var t = this._boundingBox.min;
                t.x = -Number.MAX_VALUE, t.y = -Number.MAX_VALUE, t.z = -Number.MAX_VALUE;
                var e = this._boundingBox.max;
                e.x = Number.MAX_VALUE, e.y = Number.MAX_VALUE, e.z = Number.MAX_VALUE;
            }, n._calculateBoundingSphere = function() {
                var t = this._boundingSphere.center;
                t.x = 0, t.y = 0, t.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
            }, n._renderUpdateWithCamera = function(t, e) {
                var n = t.projectionViewMatrix,
                    i = this._shaderValues;
                if (e) {
                    var r = e.worldMatrix;
                    i.setMatrix4x4(An.WORLDMATRIX, r), be.multiply(n, r, this._projectionViewWorldMatrix),
                        i.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix);
                } else i.setMatrix4x4(An.WORLDMATRIX, be.DEFAULT), i.setMatrix4x4(An.MVPMATRIX, n);
            }, e;
        }(),
        Gn = function(e) {
            function n() {
                this._reflectionMode = 1, this._enableLightCount = 3, this.enableLight = !0, this._time = 0,
                    n.__super.call(this), this._lights = [], this._skyRenderer = new ce(), this._input = new Xt(),
                    this._timer = m.timer, this._collsionTestList = [], this._renders = new Je(), this._opaqueQueue = new xe(!1),
                    this._transparentQueue = new xe(!0), this._cameraPool = [], this._animatorPool = new Je(),
                    this._scriptPool = new Je(), this._castShadowRenders = new Ye(), this.currentCreationLayer = Math.pow(2, 0),
                    this._key = new C(), this._pickIdToSprite = new Object(), k._enbalePhysics && (this._physicsSimulation = new Fe(k.physicsSettings)),
                    this._lightmaps = [], this._defineDatas = new Ft(), this._shaderValues = new at(null),
                    this.parallelSplitShadowMaps = [], this.enableFog = !1, this.fogStart = 300, this.fogRange = 1e3,
                    this.fogColor = new Ct(.7, .7, .7), this.ambientColor = new Ct(.212, .227, .259),
                    this.reflectionIntensity = 1, N.shaderHighPrecision && this._defineDatas.add(Vt.SHADERDEFINE_HIGHPRECISION),
                    b.supportWebGLPlusCulling && (this._cullingBufferIndices = new Int32Array(1024),
                        this._cullingBufferResult = new Int32Array(1024)), this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.RANGEATTENUATIONTEXTURE, zt._rangeAttenTex),
                    this._scene = this, k._enbalePhysics && !Fe.disableSimulation && this._input.__init__(b.canvas, this);
                var t = k._config;
                if (t.octreeCulling && (this._octree = new qt(t.octreeInitialSize, t.octreeInitialCenter, t.octreeMinNodeSize, t.octreeLooseness)),
                    k._config.debugFrustumCulling) {
                    this._debugTool = new di();
                    var e = new jn();
                    e.renderQueue = 3e3, e.alphaTest = !1, e.depthWrite = !1, e.cull = 2, e.blend = 1,
                        e.blendSrc = 770, e.blendDst = 771, e.depthTest = 513, this._debugTool.pixelLineRenderer.sharedMaterial = e;
                }
            }
            d(n, "laya.d3.core.scene.Scene3D", e);
            var t = n.prototype;
            return m.imps(t, {
                    "laya.webgl.submit.ISubmit": !0,
                    "laya.resource.ICreateResource": !0
                }), t._allotPickColorByID = function(t, e) {
                    var n = Math.floor(t / 65025);
                    t -= 255 * n * 255;
                    var i = Math.floor(t / 255),
                        r = t -= 255 * i;
                    e.x = n / 255, e.y = i / 255, e.z = r / 255, e.w = 1;
                }, t._searchIDByPickColor = function(t) {
                    return 255 * t.x * 255 + 255 * t.y + t.z;
                }, t._setLightmapToChildNode = function(t) {
                    t instanceof laya.d3.core.RenderableSprite3D && t._render._applyLightMapParams();
                    for (var e = t._children, n = 0, i = e.length; n < i; n++) this._setLightmapToChildNode(e[n]);
                }, t._update = function() {
                    var t = this.timer._delta / 1e3;
                    this._time += t, this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.TIME, this._time);
                    var e = this._physicsSimulation;
                    k._enbalePhysics && !Fe.disableSimulation && (e._updatePhysicsTransformFromRender(),
                            Be._addUpdateList = !1, e._simulate(t), e._updateCharacters(), Be._addUpdateList = !0,
                            e._updateCollisions(), e._eventScripts(), this._input._update()), this._updateScript(),
                        Ge._update(this), this._lateUpdateScript();
                }, t._binarySearchIndexInCameraPool = function(t) {
                    for (var e = 0, n = this._cameraPool.length - 1, i = 0; e <= n;) {
                        i = Math.floor((e + n) / 2);
                        var r = this._cameraPool[i]._renderingOrder;
                        if (r == t._renderingOrder) return i;
                        r > t._renderingOrder ? n = i - 1 : e = i + 1;
                    }
                    return e;
                }, t._setCreateURL = function(t) {
                    this._url = O.formatURL(t);
                }, t._getGroup = function() {
                    return this._group;
                }, t._setGroup = function(t) {
                    this._group = t;
                }, t._updateScript = function() {
                    for (var t = this._scriptPool, e = t.elements, n = 0, i = t.length; n < i; n++) {
                        var r = e[n];
                        r && r.enabled && r.onUpdate();
                    }
                }, t._lateUpdateScript = function() {
                    for (var t = this._scriptPool, e = t.elements, n = 0, i = t.length; n < i; n++) {
                        var r = e[n];
                        r && r.enabled && r.onLateUpdate();
                    }
                }, t._preRenderScript = function() {
                    for (var t = this._scriptPool, e = t.elements, n = 0, i = t.length; n < i; n++) {
                        var r = e[n];
                        r && r.enabled && r.onPreRender();
                    }
                }, t._postRenderScript = function() {
                    for (var t = this._scriptPool, e = t.elements, n = 0, i = t.length; n < i; n++) {
                        var r = e[n];
                        r && r.enabled && r.onPostRender();
                    }
                }, t._prepareSceneToRender = function() {
                    var t = this._lights.length;
                    if (0 < t)
                        for (var e = 0, n = 0; n < t && !(this._lights[n]._prepareToScene() && ++e >= this._enableLightCount); n++);
                }, t._addCamera = function(t) {
                    for (var e = this._binarySearchIndexInCameraPool(t), n = t._renderingOrder, i = this._cameraPool.length; e < i && this._cameraPool[e]._renderingOrder <= n;) e++;
                    this._cameraPool.splice(e, 0, t);
                }, t._removeCamera = function(t) {
                    this._cameraPool.splice(this._cameraPool.indexOf(t), 1);
                }, t._preCulling = function(t, e) {
                    Ce.renderObjectCulling(e, this, t, this._renders);
                }, t._clear = function(t, e) {
                    var n = e.viewport,
                        i = e.camera,
                        r = i.renderTarget,
                        a = n.width,
                        o = n.height,
                        s = n.x,
                        l = i._getCanvasHeight() - n.y - o;
                    t.viewport(s, l, a, o);
                    var h = 0,
                        u = i.clearFlag;
                    switch (1 !== u || i.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (u = 0),
                        u) {
                        case 0:
                            var c = i.clearColor;
                            if (t.enable(3089), t.scissor(s, l, a, o), c ? t.clearColor(c.x, c.y, c.z, c.w) : t.clearColor(0, 0, 0, 0),
                                r) switch (h = 16384, r.depthStencilFormat) {
                                case 0:
                                    h |= 256;
                                    break;

                                case 1:
                                    h |= 1024;
                                    break;

                                case 2:
                                    h |= 256, h |= 1024;
                            } else h = 16640;
                            V.setDepthMask(t, !0), t.clear(h), t.disable(3089);
                            break;

                        case 1:
                        case 2:
                            if (t.enable(3089), t.scissor(s, l, a, o), r) switch (r.depthStencilFormat) {
                                case 0:
                                    h = 256;
                                    break;

                                case 1:
                                    h = 1024;
                                    break;

                                case 2:
                                    h = 1280;
                            } else h = 256;
                            V.setDepthMask(t, !0), t.clear(h), t.disable(3089);
                            break;

                        case 3:
                            break;

                        default:
                            throw new Error("BaseScene:camera clearFlag invalid.");
                    }
                }, t._renderScene = function(t, e, n, i) {
                    var r = e.camera;
                    r.transform.position;
                    if (r.renderTarget ? this._opaqueQueue._render(e, !0, n, i) : this._opaqueQueue._render(e, !1, n, i),
                        1 === r.clearFlag && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(e) : this._skyRenderer._isAvailable() && this._skyRenderer._render(e)),
                        r.renderTarget ? this._transparentQueue._render(e, !0, n, i) : this._transparentQueue._render(e, !1, n, i),
                        k._config.debugFrustumCulling)
                        for (var a = this._debugTool._render._renderElements, o = 0, s = a.length; o < s; o++) a[o]._render(e, !1, n, i);
                }, t._parse = function(t) {
                    var e = t.lightmaps;
                    if (e) {
                        var n = e.length,
                            i = this._lightmaps;
                        i.length = n;
                        for (var r = 0; r < n; r++) i[r] = xt.getRes(e[r].path);
                        this.setlightmaps(i);
                    }
                    var a = t.ambientColor;
                    if (a) {
                        var o = this.ambientColor;
                        o.fromArray(a), this.ambientColor = o;
                    }
                    var s = t.sky;
                    if (s) switch (this._skyRenderer.material = xt.getRes(s.material.path), s.mesh) {
                        case "SkyBox":
                            this._skyRenderer.mesh = mn.instance;
                            break;

                        case "SkyDome":
                            this._skyRenderer.mesh = Sn.instance;
                            break;

                        default:
                            this.skyRenderer.mesh = mn.instance;
                    }
                    var l = t.reflectionTexture;
                    l && (this.customReflection = xt.getRes(l)), this.enableFog = t.enableFog, this.fogStart = t.fogStart,
                        this.fogRange = t.fogRange;
                    var h = t.fogColor;
                    if (h) {
                        var u = this.fogColor;
                        u.fromArray(h), this.fogColor = u;
                    }
                }, t._onActive = function() {
                    laya.display.Node.prototype._onActive.call(this), m.stage._scene3Ds.push(this);
                }, t._onInActive = function() {
                    laya.display.Node.prototype._onInActive.call(this);
                    var t = m.stage._scene3Ds;
                    t.splice(t.indexOf(this), 1);
                }, t._addLight = function(t) {
                    this._lights.indexOf(t) < 0 && this._lights.push(t);
                }, t._removeLight = function(t) {
                    var e = this._lights.indexOf(t);
                    0 <= e && this._lights.splice(e, 1);
                }, t._addRenderObject = function(t) {
                    if (this._octree) this._octree.add(t);
                    else if (this._renders.add(t), b.supportWebGLPlusCulling) {
                        var e = t._getIndexInList(),
                            n = this._cullingBufferIndices.length;
                        if (n <= e) {
                            var i = this._cullingBufferIndices,
                                r = this._cullingBufferResult;
                            this._cullingBufferIndices = new Int32Array(n + 1024), this._cullingBufferResult = new Int32Array(n + 1024),
                                this._cullingBufferIndices.set(i, 0), this._cullingBufferResult.set(r, 0);
                        }
                        this._cullingBufferIndices[e] = t._cullingBufferIndex;
                    }
                }, t._removeRenderObject = function(t) {
                    var e;
                    this._octree ? this._octree.remove(t) : (b.supportWebGLPlusCulling && (e = this._renders.elements[this._renders.length - 1]),
                        this._renders.remove(t), b.supportWebGLPlusCulling && (this._cullingBufferIndices[e._getIndexInList()] = e._cullingBufferIndex));
                }, t._addShadowCastRenderObject = function(t) {
                    this._octree || this._castShadowRenders.add(t);
                }, t._removeShadowCastRenderObject = function(t) {
                    this._octree || this._castShadowRenders.remove(t);
                }, t._getRenderQueue = function(t) {
                    return t < 3e3 ? this._opaqueQueue : this._transparentQueue;
                }, t.setlightmaps = function(t) {
                    this._lightmaps = t;
                    for (var e = 0, n = this._children.length; e < n; e++) this._setLightmapToChildNode(this._children[e]);
                }, t.getlightmaps = function() {
                    return this._lightmaps;
                }, t.destroy = function(t) {
                    void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                        this._skyRenderer.destroy(), this._skyRenderer = null, this._lights = null, this._lightmaps = null,
                        this._renderTargetTexture = null, this._shaderValues = null, this._renders = null,
                        this._castShadowRenders = null, this._cameraPool = null, this._octree = null, this.parallelSplitShadowMaps = null,
                        this._physicsSimulation && this._physicsSimulation._destroy(), xt.clearRes(this.url));
                }, t.render = function(t, e, n) {
                    t._curSubmit = A.RENDERBASE, 0 < this._children.length && t.addRenderObject(this);
                }, t.renderSubmit = function() {
                    E.instance;
                    this._prepareSceneToRender();
                    var t, e, n = 0;
                    for (n = 0, e = (t = this._cameraPool.length) - 1; n < t; n++) {
                        b.supportWebGLPlusRendering && at.setRuntimeValueMode(n == e);
                        var i = this._cameraPool[n];
                        i.enableRender && i.render();
                    }
                    return w.set2DRenderConfig(), 1;
                }, t.getRenderType = function() {
                    return 0;
                }, t.releaseRender = function() {}, t.reUse = function(t, e) {
                    return 0;
                }, u(0, t, "fogColor", function() {
                    return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.FOGCOLOR);
                }, function(t) {
                    this._shaderValues.setVector3(laya.d3.core.scene.Scene3D.FOGCOLOR, t);
                }), u(0, t, "enableFog", function() {
                    return this._enableFog;
                }, function(t) {
                    this._enableFog !== t && ((this._enableFog = t) ? this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG) : this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG));
                }), u(0, t, "url", function() {
                    return this._url;
                }), u(0, t, "fogStart", function() {
                    return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGSTART);
                }, function(t) {
                    this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGSTART, t);
                }), u(0, t, "reflectionIntensity", function() {
                    return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY);
                }, function(t) {
                    t = Math.max(Math.min(t, 1), 0), this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY, t);
                }), u(0, t, "skyRenderer", function() {
                    return this._skyRenderer;
                }), u(0, t, "fogRange", function() {
                    return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGRANGE);
                }, function(t) {
                    this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGRANGE, t);
                }), u(0, t, "ambientColor", function() {
                    return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.AMBIENTCOLOR);
                }, function(t) {
                    this._shaderValues.setVector3(laya.d3.core.scene.Scene3D.AMBIENTCOLOR, t);
                }), u(0, t, "customReflection", function() {
                    return this._shaderValues.getTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE);
                }, function(t) {
                    this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE, t),
                        t ? this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP) : this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP);
                }), u(0, t, "physicsSimulation", function() {
                    return this._physicsSimulation;
                }), u(0, t, "reflectionMode", function() {
                    return this._reflectionMode;
                }, function(t) {
                    this._reflectionMode = t;
                }), u(0, t, "timer", function() {
                    return this._timer;
                }, function(t) {
                    this._timer = t;
                }), u(0, t, "input", function() {
                    return this._input;
                }), n._parse = function(t, e, n) {
                    var i = t.data,
                        r = [],
                        a = Gt._createNodeByJson(i, r);
                    return Z.combine(null, r), a;
                }, n.load = function(t, e) {
                    m.loader.create(t, e, null, "HIERARCHY");
                }, n.REFLECTIONMODE_SKYBOX = 0, n.REFLECTIONMODE_CUSTOM = 1, n.SHADERDEFINE_FOG = 0,
                n.SHADERDEFINE_DIRECTIONLIGHT = 0, n.SHADERDEFINE_POINTLIGHT = 0, n.SHADERDEFINE_SPOTLIGHT = 0,
                n.SHADERDEFINE_CAST_SHADOW = 0, n.SHADERDEFINE_SHADOW_PSSM1 = 0, n.SHADERDEFINE_SHADOW_PSSM2 = 0,
                n.SHADERDEFINE_SHADOW_PSSM3 = 0, n.SHADERDEFINE_SHADOW_PCF_NO = 0, n.SHADERDEFINE_SHADOW_PCF1 = 0,
                n.SHADERDEFINE_SHADOW_PCF2 = 0, n.SHADERDEFINE_SHADOW_PCF3 = 0, n.SHADERDEFINE_REFLECTMAP = 0,
                _(n, ["FOGCOLOR", function() {
                    return this.FOGCOLOR = Vt.propertyNameToID("u_FogColor");
                }, "FOGSTART", function() {
                    return this.FOGSTART = Vt.propertyNameToID("u_FogStart");
                }, "FOGRANGE", function() {
                    return this.FOGRANGE = Vt.propertyNameToID("u_FogRange");
                }, "LIGHTDIRECTION", function() {
                    return this.LIGHTDIRECTION = Vt.propertyNameToID("u_DirectionLight.Direction");
                }, "LIGHTDIRCOLOR", function() {
                    return this.LIGHTDIRCOLOR = Vt.propertyNameToID("u_DirectionLight.Color");
                }, "POINTLIGHTPOS", function() {
                    return this.POINTLIGHTPOS = Vt.propertyNameToID("u_PointLight.Position");
                }, "POINTLIGHTRANGE", function() {
                    return this.POINTLIGHTRANGE = Vt.propertyNameToID("u_PointLight.Range");
                }, "POINTLIGHTATTENUATION", function() {
                    return this.POINTLIGHTATTENUATION = Vt.propertyNameToID("u_PointLight.Attenuation");
                }, "POINTLIGHTCOLOR", function() {
                    return this.POINTLIGHTCOLOR = Vt.propertyNameToID("u_PointLight.Color");
                }, "SPOTLIGHTPOS", function() {
                    return this.SPOTLIGHTPOS = Vt.propertyNameToID("u_SpotLight.Position");
                }, "SPOTLIGHTDIRECTION", function() {
                    return this.SPOTLIGHTDIRECTION = Vt.propertyNameToID("u_SpotLight.Direction");
                }, "SPOTLIGHTSPOTANGLE", function() {
                    return this.SPOTLIGHTSPOTANGLE = Vt.propertyNameToID("u_SpotLight.Spot");
                }, "SPOTLIGHTRANGE", function() {
                    return this.SPOTLIGHTRANGE = Vt.propertyNameToID("u_SpotLight.Range");
                }, "SPOTLIGHTCOLOR", function() {
                    return this.SPOTLIGHTCOLOR = Vt.propertyNameToID("u_SpotLight.Color");
                }, "SHADOWDISTANCE", function() {
                    return this.SHADOWDISTANCE = Vt.propertyNameToID("u_shadowPSSMDistance");
                }, "SHADOWLIGHTVIEWPROJECT", function() {
                    return this.SHADOWLIGHTVIEWPROJECT = Vt.propertyNameToID("u_lightShadowVP");
                }, "SHADOWMAPPCFOFFSET", function() {
                    return this.SHADOWMAPPCFOFFSET = Vt.propertyNameToID("u_shadowPCFoffset");
                }, "SHADOWMAPTEXTURE1", function() {
                    return this.SHADOWMAPTEXTURE1 = Vt.propertyNameToID("u_shadowMap1");
                }, "SHADOWMAPTEXTURE2", function() {
                    return this.SHADOWMAPTEXTURE2 = Vt.propertyNameToID("u_shadowMap2");
                }, "SHADOWMAPTEXTURE3", function() {
                    return this.SHADOWMAPTEXTURE3 = Vt.propertyNameToID("u_shadowMap3");
                }, "AMBIENTCOLOR", function() {
                    return this.AMBIENTCOLOR = Vt.propertyNameToID("u_AmbientColor");
                }, "REFLECTIONTEXTURE", function() {
                    return this.REFLECTIONTEXTURE = Vt.propertyNameToID("u_ReflectTexture");
                }, "REFLETIONINTENSITY", function() {
                    return this.REFLETIONINTENSITY = Vt.propertyNameToID("u_ReflectIntensity");
                }, "TIME", function() {
                    return this.TIME = Vt.propertyNameToID("u_Time");
                }, "ANGLEATTENUATIONTEXTURE", function() {
                    return this.ANGLEATTENUATIONTEXTURE = Vt.propertyNameToID("u_AngleTexture");
                }, "RANGEATTENUATIONTEXTURE", function() {
                    return this.RANGEATTENUATIONTEXTURE = Vt.propertyNameToID("u_RangeTexture");
                }, "POINTLIGHTMATRIX", function() {
                    return this.POINTLIGHTMATRIX = Vt.propertyNameToID("u_PointLightMatrix");
                }, "SPOTLIGHTMATRIX", function() {
                    return this.SPOTLIGHTMATRIX = Vt.propertyNameToID("u_SpotLightMatrix");
                }]), n;
        }(R),
        Hn = function(n) {
            function e(t) {
                this.pickColor = null, this._render = null, e.__super.call(this, t);
            }
            d(e, "laya.d3.core.RenderableSprite3D", n);
            var t = e.prototype;
            return t._onInActive = function() {
                    laya.display.Node.prototype._onInActive.call(this);
                    var t = this._scene;
                    t._removeRenderObject(this._render), this._render.castShadow && t._removeShadowCastRenderObject(this._render);
                }, t._onActive = function() {
                    laya.display.Node.prototype._onActive.call(this);
                    var t = this._scene;
                    t._addRenderObject(this._render), this._render.castShadow && t._addShadowCastRenderObject(this._render);
                }, t._onActiveInScene = function() {
                    if (laya.display.Node.prototype._onActiveInScene.call(this), k._editerEnvironment) {
                        var t = this._scene,
                            e = new At();
                        t._allotPickColorByID(this.id, e), (t._pickIdToSprite[this.id] = this)._render._shaderValues.setVector(laya.d3.core.RenderableSprite3D.PICKCOLOR, e);
                    }
                }, t._addToInitStaticBatchManager = function() {}, t._setBelongScene = function(t) {
                    laya.display.Node.prototype._setBelongScene.call(this, t), this._render._setBelongScene(t);
                }, t._setUnBelongScene = function() {
                    this._render._defineDatas.remove(laya.d3.core.RenderableSprite3D.SAHDERDEFINE_LIGHTMAP),
                        laya.display.Node.prototype._setUnBelongScene.call(this);
                }, t._changeHierarchyAnimator = function(t) {
                    if (this._hierarchyAnimator) {
                        var e = this._hierarchyAnimator._renderableSprites;
                        e.splice(e.indexOf(this), 1);
                    }
                    t && t._renderableSprites.push(this), n.prototype._changeHierarchyAnimator.call(this, t);
                }, t.destroy = function(t) {
                    void 0 === t && (t = !0), n.prototype.destroy.call(this, t), this._render._destroy(),
                        this._render = null;
                }, e.__init__ = function() {
                    e.SHADERDEFINE_RECEIVE_SHADOW = e.shaderDefines.registerDefine("RECEIVESHADOW"),
                        e.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = e.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV"),
                        e.SAHDERDEFINE_LIGHTMAP = e.shaderDefines.registerDefine("LIGHTMAP");
                }, e.SHADERDEFINE_RECEIVE_SHADOW = 0, e.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = 0,
                e.SAHDERDEFINE_LIGHTMAP = 0, _(e, ["LIGHTMAPSCALEOFFSET", function() {
                    return this.LIGHTMAPSCALEOFFSET = Vt.propertyNameToID("u_LightmapScaleOffset");
                }, "LIGHTMAP", function() {
                    return this.LIGHTMAP = Vt.propertyNameToID("u_LightMap");
                }, "PICKCOLOR", function() {
                    return this.PICKCOLOR = Vt.propertyNameToID("u_PickColor");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht();
                }]), e;
        }(An),
        kn = function(t) {
            function n() {
                this._albedoIntensity = 1, this._enableVertexColor = !1, this._albedoColor = new At(1, 1, 1, 1),
                    n.__super.call(this), this.setShaderName("Unlit"), this._shaderValues.setVector(n.ALBEDOCOLOR, new At(1, 1, 1, 1)),
                    this.renderMode = 0;
            }
            d(n, "laya.d3.core.material.UnlitMaterial", Cn);
            var e = n.prototype;
            return u(0, e, "_ColorB", function() {
                    return this._albedoColor.z;
                }, function(t) {
                    this._albedoColor.z = t, this.albedoColor = this._albedoColor;
                }), u(0, e, "_ColorR", function() {
                    return this._albedoColor.x;
                }, function(t) {
                    this._albedoColor.x = t, this.albedoColor = this._albedoColor;
                }), u(0, e, "albedoColorA", function() {
                    return this._ColorA;
                }, function(t) {
                    this._ColorA = t;
                }), u(0, e, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, e, "_ColorG", function() {
                    return this._albedoColor.y;
                }, function(t) {
                    this._albedoColor.y = t, this.albedoColor = this._albedoColor;
                }), u(0, e, "_ColorA", function() {
                    return this._albedoColor.w;
                }, function(t) {
                    this._albedoColor.w = t, this.albedoColor = this._albedoColor;
                }), u(0, e, "_AlbedoIntensity", function() {
                    return this._albedoIntensity;
                }, function(t) {
                    if (this._albedoIntensity !== t) {
                        var e = this._shaderValues.getVector(n.ALBEDOCOLOR);
                        At.scale(this._albedoColor, t, e), this._albedoIntensity = t, this._shaderValues.setVector(n.ALBEDOCOLOR, e);
                    }
                }), u(0, e, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, e, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, e, "_Cutoff", function() {
                    return this.alphaTestValue;
                }, function(t) {
                    this.alphaTestValue = t;
                }), u(0, e, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, e, "albedoColorR", function() {
                    return this._ColorR;
                }, function(t) {
                    this._ColorR = t;
                }), u(0, e, "albedoColorG", function() {
                    return this._ColorG;
                }, function(t) {
                    this._ColorG = t;
                }), u(0, e, "albedoColorB", function() {
                    return this._ColorB;
                }, function(t) {
                    this._ColorB = t;
                }), u(0, e, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, e, "albedoColor", function() {
                    return this._albedoColor;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.ALBEDOCOLOR);
                    At.scale(t, this._albedoIntensity, e), this._albedoColor = t, this._shaderValues.setVector(n.ALBEDOCOLOR, e);
                }), u(0, e, "albedoIntensity", function() {
                    return this._albedoIntensity;
                }, function(t) {
                    this._AlbedoIntensity = t;
                }), u(0, e, "enableVertexColor", function() {
                    return this._enableVertexColor;
                }, function(t) {
                    (this._enableVertexColor = t) ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR): this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
                }), u(0, e, "albedoTexture", function() {
                    return this._shaderValues.getTexture(n.ALBEDOTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                        this._shaderValues.setTexture(n.ALBEDOTEXTURE, t);
                }), u(0, e, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, e, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, e, "blendSrc", function() {
                    return this._shaderValues.getInt(n.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_SRC, t);
                }), u(0, e, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, e, "tilingOffset", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(n.TILINGOFFSET, t);
                }), u(0, e, "renderMode", null, function(t) {
                    switch (t) {
                        case 0:
                            this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513;
                            break;

                        case 1:
                            this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513;
                            break;

                        case 2:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513;
                            break;

                        default:
                            throw new Error("UnlitMaterial : renderMode value error.");
                    }
                }), u(0, e, "depthWrite", function() {
                    return this._shaderValues.getBool(n.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(n.DEPTH_WRITE, t);
                }), u(0, e, "cull", function() {
                    return this._shaderValues.getInt(n.CULL);
                }, function(t) {
                    this._shaderValues.setInt(n.CULL, t);
                }), u(0, e, "blend", function() {
                    return this._shaderValues.getInt(n.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND, t);
                }), u(0, e, "blendDst", function() {
                    return this._shaderValues.getInt(n.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_DST, t);
                }), u(0, e, "depthTest", function() {
                    return this._shaderValues.getInt(n.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(n.DEPTH_TEST, t);
                }), n.__init__ = function() {
                    n.SHADERDEFINE_ALBEDOTEXTURE = n.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                        n.SHADERDEFINE_TILINGOFFSET = n.shaderDefines.registerDefine("TILINGOFFSET"), n.SHADERDEFINE_ENABLEVERTEXCOLOR = n.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
                }, n.RENDERMODE_OPAQUE = 0, n.RENDERMODE_CUTOUT = 1, n.RENDERMODE_TRANSPARENT = 2,
                n.RENDERMODE_ADDTIVE = 3, n.SHADERDEFINE_ALBEDOTEXTURE = 0, n.SHADERDEFINE_TILINGOFFSET = 0,
                n.SHADERDEFINE_ENABLEVERTEXCOLOR = 0, _(n, ["ALBEDOTEXTURE", function() {
                    return this.ALBEDOTEXTURE = Vt.propertyNameToID("u_AlbedoTexture");
                }, "ALBEDOCOLOR", function() {
                    return this.ALBEDOCOLOR = Vt.propertyNameToID("u_AlbedoColor");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new n();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), n;
        }(),
        Wn = function(n) {
            function e() {
                this._intensityColor = null, this._intensity = NaN, this._shadow = !1, this._shadowFarPlane = 0,
                    this._shadowMapSize = 0, this._shadowMapCount = 0, this._shadowMapPCFType = 0, this._parallelSplitShadowMap = null,
                    this._lightmapBakedType = 0, this.color = null, e.__super.call(this), this._intensity = 1,
                    this._intensityColor = new Ct(), this.color = new Ct(1, 1, 1), this._shadow = !1,
                    this._shadowFarPlane = 8, this._shadowMapSize = 512, this._shadowMapCount = 1, this._shadowMapPCFType = 0,
                    this._lightmapBakedType = e.LIGHTMAPBAKEDTYPE_REALTIME;
            }
            d(e, "laya.d3.core.light.LightSprite", n);
            var t = e.prototype;
            return t._parse = function(t) {
                    n.prototype._parse.call(this, t);
                    var e = t.color;
                    this.color.fromArray(e), this.intensity = t.intensity, this.lightmapBakedType = t.lightmapBakedType;
                }, t._onActive = function() {
                    laya.display.Node.prototype._onActive.call(this), this.lightmapBakedType !== e.LIGHTMAPBAKEDTYPE_BAKED && this._scene._addLight(this);
                }, t._onInActive = function() {
                    laya.display.Node.prototype._onInActive.call(this), this.lightmapBakedType !== e.LIGHTMAPBAKEDTYPE_BAKED && this._scene._removeLight(this);
                }, t._prepareToScene = function() {
                    return !1;
                }, u(0, t, "lightmapBakedType", function() {
                    return this._lightmapBakedType;
                }, function(t) {
                    this._lightmapBakedType !== t && (this._lightmapBakedType = t, this.activeInHierarchy && (t !== e.LIGHTMAPBAKEDTYPE_BAKED ? this._scene._addLight(this) : this._scene._removeLight(this)));
                }), u(0, t, "shadowPCFType", function() {
                    return this._shadowMapPCFType;
                }, function(t) {
                    this._shadowMapPCFType = t, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(t);
                }), u(0, t, "intensity", function() {
                    return this._intensity;
                }, function(t) {
                    this._intensity = t;
                }), u(0, t, "shadow", function() {
                    return this._shadow;
                }, function(t) {
                    throw new Error("LightSprite: must override it.");
                }), u(0, t, "shadowDistance", function() {
                    return this._shadowFarPlane;
                }, function(t) {
                    this._shadowFarPlane = t, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(t);
                }), u(0, t, "shadowPSSMCount", function() {
                    return this._shadowMapCount;
                }, function(t) {
                    this._shadowMapCount = t, this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = t);
                }), u(0, t, "shadowResolution", function() {
                    return this._shadowMapSize;
                }, function(t) {
                    this._shadowMapSize = t, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(t);
                }), u(0, t, "diffuseColor", function() {
                    return console.log("LightSprite: discard property,please use color property instead."),
                        this.color;
                }, function(t) {
                    console.log("LightSprite: discard property,please use color property instead."),
                        this.color = t;
                }), e.LIGHTMAPBAKEDTYPE_REALTIME = 0, e.LIGHTMAPBAKEDTYPE_MIXED = 1, e.LIGHTMAPBAKEDTYPE_BAKED = 2,
                e;
        }(An),
        Xn = function(i) {
            function h(t) {
                this._terrainRes = null, this._lightmapScaleOffset = null, h.__super.call(this),
                    this._lightmapScaleOffset = new At(1, 1, 0, 0), t && (this._terrainRes = t, this.buildTerrain(t));
            }
            d(h, "laya.d3.terrain.Terrain", i);
            var t = h.prototype;
            return t._parse = function(t) {
                    i.prototype._parse.call(this, t), this.terrainRes = xt.getRes(t.dataPath);
                    var e = t.lightmapIndex;
                    null != e && this.setLightmapIndex(e);
                    var n = t.lightmapScaleOffset;
                    n && this.setLightmapScaleOffset(new At(n[0], n[1], n[2], n[3]));
                }, t.setLightmapIndex = function(t) {
                    for (var e = 0; e < this._children.length; e++) {
                        this._children[e].terrainRender.lightmapIndex = t;
                    }
                }, t.setLightmapScaleOffset = function(t) {
                    if (t) {
                        t.cloneTo(this._lightmapScaleOffset);
                        for (var e = 0; e < this._children.length; e++) {
                            this._children[e].terrainRender.lightmapScaleOffset = this._lightmapScaleOffset;
                        }
                    }
                }, t.disableLight = function() {
                    for (var t = 0, e = this._children.length; t < e; t++)
                        for (var n = this._children[t], i = 0, r = n._render.sharedMaterials.length; i < r; i++) {
                            n._render.sharedMaterials[i].disableLight();
                        }
                }, t.buildTerrain = function(t) {
                    for (var e = t._chunkNumX, n = t._chunkNumZ, i = t._heightData, r = 0, a = 0; a < n; a++)
                        for (var o = 0; o < e; o++) {
                            for (var s = new pi(o, a, t._gridSize, i._terrainHeightData, i._width, i._height, t._cameraCoordinateInverse), l = t._chunkInfos[r++], h = 0; h < l.alphaMap.length; h++) {
                                var u = l.detailID[h].length,
                                    c = 0 < u ? t._detailTextureInfos[l.detailID[h][0]].diffuseTexture : null,
                                    _ = 1 < u ? t._detailTextureInfos[l.detailID[h][1]].diffuseTexture : null,
                                    d = 2 < u ? t._detailTextureInfos[l.detailID[h][2]].diffuseTexture : null,
                                    f = 3 < u ? t._detailTextureInfos[l.detailID[h][3]].diffuseTexture : null,
                                    m = 0 < u ? t._detailTextureInfos[l.detailID[h][0]].scale : null,
                                    p = 1 < u ? t._detailTextureInfos[l.detailID[h][1]].scale : null,
                                    T = 2 < u ? t._detailTextureInfos[l.detailID[h][2]].scale : null,
                                    E = 3 < u ? t._detailTextureInfos[l.detailID[h][3]].scale : null;
                                s.buildRenderElementAndMaterial(u, l.normalMap, l.alphaMap[h], c, _, d, f, t._materialInfo.ambientColor, t._materialInfo.diffuseColor, t._materialInfo.specularColor, m ? m.x : 1, m ? m.y : 1, p ? p.x : 1, p ? p.y : 1, T ? T.x : 1, T ? T.y : 1, E ? E.x : 1, E ? E.y : 1);
                            }
                            s.terrainRender.receiveShadow = !0, s.terrainRender.lightmapScaleOffset = this._lightmapScaleOffset,
                                this.addChild(s);
                        }
                }, t.width = function() {
                    return this._terrainRes._chunkNumX * ot.CHUNK_GRID_NUM * this._terrainRes._gridSize;
                }, t.depth = function() {
                    return this._terrainRes._chunkNumZ * ot.CHUNK_GRID_NUM * this._terrainRes._gridSize;
                }, t.getHeightXZ = function(t, e) {
                    if (!this._terrainRes) return NaN;
                    if (t -= this.transform.position.x, e -= this.transform.position.z, h.__VECTOR3__ || (h.__VECTOR3__ = new Ct()),
                        h.__VECTOR3__.x = t, h.__VECTOR3__.y = 0, h.__VECTOR3__.z = e, Ct.transformV3ToV3(h.__VECTOR3__, ot.__ADAPT_MATRIX_INV__, h.__VECTOR3__),
                        t = h.__VECTOR3__.x, e = h.__VECTOR3__.z, t < 0 || t > this.width() || e < 0 || e > this.depth()) return NaN;
                    var n = this._terrainRes._gridSize,
                        i = parseInt("" + t / n),
                        r = parseInt("" + e / n),
                        a = t - i * n,
                        o = e - r * n,
                        s = NaN,
                        l = this._terrainRes._heightData;
                    return n < a + o ? (s = l._terrainHeightData[(r + 1 - 1) * l._width + i + 1]) + (l._terrainHeightData[(r + 1 - 1) * l._width + i] - s) * ((n - a) / n) + (l._terrainHeightData[(r - 1) * l._width + i + 1] - s) * ((n - o) / n) : (s = l._terrainHeightData[Math.max(0, r - 1) * l._width + i]) + (l._terrainHeightData[Math.min(l._width * l._height - 1, (r + 1 - 1) * l._width + i)] - s) * (o / n) + (l._terrainHeightData[Math.min(l._width * l._height - 1, Math.max(0, r - 1) * l._width + i + 1)] - s) * (a / n);
                }, u(0, t, "terrainRes", null, function(t) {
                    t && (this._terrainRes = t, this.buildTerrain(t));
                }), h.load = function(t) {
                    m.loader.create(t, null, null, "TERRAIN", null, null, 1, !1);
                }, h.RENDER_LINE_MODEL = !1, h.LOD_TOLERANCE_VALUE = 4, h.LOD_DISTANCE_FACTOR = 2,
                h.__VECTOR3__ = null, h;
        }(An),
        Yn = function(t) {
            function n() {
                this._color = null, n.__super.call(this), this.setShaderName("Trail"), this._color = new At(1, 1, 1, 1),
                    this._shaderValues.setVector(n.TINTCOLOR, new At(1, 1, 1, 1)), this.renderMode = 0;
            }
            d(n, "laya.d3.core.trail.TrailMaterial", Cn);
            var e = n.prototype;
            return u(0, e, "_TintColorB", function() {
                    return this._color.z;
                }, function(t) {
                    this._color.z = t, this.color = this._color;
                }), u(0, e, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, e, "texture", function() {
                    return this._shaderValues.getTexture(n.MAINTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE),
                        this._shaderValues.setTexture(n.MAINTEXTURE, t);
                }), u(0, e, "_TintColorR", function() {
                    return this._color.x;
                }, function(t) {
                    this._color.x = t, this.color = this._color;
                }), u(0, e, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, e, "_TintColorG", function() {
                    return this._color.y;
                }, function(t) {
                    this._color.y = t, this.color = this._color;
                }), u(0, e, "_TintColorA", function() {
                    return this._color.w;
                }, function(t) {
                    this._color.w = t, this.color = this._color;
                }), u(0, e, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, e, "renderMode", null, function(t) {
                    switch (t) {
                        case 1:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 1, this.depthTest = 513, this._defineDatas.add(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        case 0:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513,
                                this._defineDatas.remove(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        default:
                            throw new Error("TrailMaterial : renderMode value error.");
                    }
                }), u(0, e, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, e, "colorR", function() {
                    return this._TintColorR;
                }, function(t) {
                    this._TintColorR = t;
                }), u(0, e, "colorG", function() {
                    return this._TintColorG;
                }, function(t) {
                    this._TintColorG = t;
                }), u(0, e, "colorB", function() {
                    return this._TintColorB;
                }, function(t) {
                    this._TintColorB = t;
                }), u(0, e, "colorA", function() {
                    return this._TintColorA;
                }, function(t) {
                    this._TintColorA = t;
                }), u(0, e, "blend", function() {
                    return this._shaderValues.getInt(n.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND, t);
                }), u(0, e, "color", function() {
                    return this._shaderValues.getVector(n.TINTCOLOR);
                }, function(t) {
                    this._shaderValues.setVector(n.TINTCOLOR, t);
                }), u(0, e, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, e, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, e, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, e, "blendSrc", function() {
                    return this._shaderValues.getInt(n.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_SRC, t);
                }), u(0, e, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, e, "tilingOffset", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(n.TILINGOFFSET, t);
                }), u(0, e, "depthWrite", function() {
                    return this._shaderValues.getBool(n.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(n.DEPTH_WRITE, t);
                }), u(0, e, "cull", function() {
                    return this._shaderValues.getInt(n.CULL);
                }, function(t) {
                    this._shaderValues.setInt(n.CULL, t);
                }), u(0, e, "blendDst", function() {
                    return this._shaderValues.getInt(n.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_DST, t);
                }), u(0, e, "depthTest", function() {
                    return this._shaderValues.getInt(n.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(n.DEPTH_TEST, t);
                }), n.__init__ = function() {
                    n.SHADERDEFINE_MAINTEXTURE = n.shaderDefines.registerDefine("MAINTEXTURE"), n.SHADERDEFINE_TILINGOFFSET = n.shaderDefines.registerDefine("TILINGOFFSET"),
                        n.SHADERDEFINE_ADDTIVEFOG = n.shaderDefines.registerDefine("ADDTIVEFOG");
                }, n.RENDERMODE_ALPHABLENDED = 0, n.RENDERMODE_ADDTIVE = 1, n.SHADERDEFINE_MAINTEXTURE = 0,
                n.SHADERDEFINE_TILINGOFFSET = 0, n.SHADERDEFINE_ADDTIVEFOG = 0, _(n, ["defaultMaterial", function() {
                    return this.defaultMaterial = new n();
                }, "MAINTEXTURE", function() {
                    return this.MAINTEXTURE = Vt.propertyNameToID("u_MainTexture");
                }, "TINTCOLOR", function() {
                    return this.TINTCOLOR = Vt.propertyNameToID("u_MainColor");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), n;
        }(),
        Zn = function(t) {
            function e() {
                this._sunDisk = 0, e.__super.call(this), this.setShaderName("SkyBoxProcedural"),
                    this.sunDisk = 1, this.sunSize = .04, this.sunSizeConvergence = 5, this.atmosphereThickness = 1,
                    this.skyTint = new At(.5, .5, .5, 1), this.groundTint = new At(.369, .349, .341, 1),
                    this.exposure = 1.3;
            }
            d(e, "laya.d3.core.material.SkyProceduralMaterial", Cn);
            var n = e.prototype;
            return u(0, n, "exposure", function() {
                    return this._shaderValues.getNumber(e.EXPOSURE);
                }, function(t) {
                    t = Math.min(Math.max(0, t), 8), this._shaderValues.setNumber(e.EXPOSURE, t);
                }), u(0, n, "sunSize", function() {
                    return this._shaderValues.getNumber(e.SUNSIZE);
                }, function(t) {
                    t = Math.min(Math.max(0, t), 1), this._shaderValues.setNumber(e.SUNSIZE, t);
                }), u(0, n, "sunDisk", function() {
                    return this._sunDisk;
                }, function(t) {
                    switch (t) {
                        case 1:
                            this._defineDatas.remove(e.SHADERDEFINE_SUN_SIMPLE), this._defineDatas.add(e.SHADERDEFINE_SUN_HIGH_QUALITY);
                            break;

                        case 2:
                            this._defineDatas.remove(e.SHADERDEFINE_SUN_HIGH_QUALITY), this._defineDatas.add(e.SHADERDEFINE_SUN_SIMPLE);
                            break;

                        case 0:
                            this._defineDatas.remove(e.SHADERDEFINE_SUN_HIGH_QUALITY), this._defineDatas.remove(e.SHADERDEFINE_SUN_SIMPLE);
                            break;

                        default:
                            throw "SkyBoxProceduralMaterial: unknown sun value.";
                    }
                    this._sunDisk = t;
                }), u(0, n, "sunSizeConvergence", function() {
                    return this._shaderValues.getNumber(e.SUNSIZECONVERGENCE);
                }, function(t) {
                    t = Math.min(Math.max(0, t), 20), this._shaderValues.setNumber(e.SUNSIZECONVERGENCE, t);
                }), u(0, n, "atmosphereThickness", function() {
                    return this._shaderValues.getNumber(e.ATMOSPHERETHICKNESS);
                }, function(t) {
                    t = Math.min(Math.max(0, t), 5), this._shaderValues.setNumber(e.ATMOSPHERETHICKNESS, t);
                }), u(0, n, "groundTint", function() {
                    return this._shaderValues.getVector(e.GROUNDTINT);
                }, function(t) {
                    this._shaderValues.setVector(e.GROUNDTINT, t);
                }), u(0, n, "skyTint", function() {
                    return this._shaderValues.getVector(e.SKYTINT);
                }, function(t) {
                    this._shaderValues.setVector(e.SKYTINT, t);
                }), e.__init__ = function() {
                    e.SHADERDEFINE_SUN_HIGH_QUALITY = e.shaderDefines.registerDefine("SUN_HIGH_QUALITY"),
                        e.SHADERDEFINE_SUN_SIMPLE = e.shaderDefines.registerDefine("SUN_SIMPLE");
                }, e.SUN_NODE = 0, e.SUN_HIGH_QUALITY = 1, e.SUN_SIMPLE = 2, e.SHADERDEFINE_SUN_HIGH_QUALITY = 0,
                e.SHADERDEFINE_SUN_SIMPLE = 0, _(e, ["SUNSIZE", function() {
                    return this.SUNSIZE = Vt.propertyNameToID("u_SunSize");
                }, "SUNSIZECONVERGENCE", function() {
                    return this.SUNSIZECONVERGENCE = Vt.propertyNameToID("u_SunSizeConvergence");
                }, "ATMOSPHERETHICKNESS", function() {
                    return this.ATMOSPHERETHICKNESS = Vt.propertyNameToID("u_AtmosphereThickness");
                }, "SKYTINT", function() {
                    return this.SKYTINT = Vt.propertyNameToID("u_SkyTint");
                }, "GROUNDTINT", function() {
                    return this.GROUNDTINT = Vt.propertyNameToID("u_GroundTint");
                }, "EXPOSURE", function() {
                    return this.EXPOSURE = Vt.propertyNameToID("u_Exposure");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new e();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), e;
        }(),
        jn = function(t) {
            function e() {
                e.__super.call(this), this.setShaderName("LineShader"), this._shaderValues.setVector(e.COLOR, new At(1, 1, 1, 1));
            }
            d(e, "laya.d3.core.pixelLine.PixelLineMaterial", Cn);
            var n = e.prototype;
            return u(0, n, "blend", function() {
                return this._shaderValues.getInt(e.BLEND);
            }, function(t) {
                this._shaderValues.setInt(e.BLEND, t);
            }), u(0, n, "color", function() {
                return this._shaderValues.getVector(e.COLOR);
            }, function(t) {
                this._shaderValues.setVector(e.COLOR, t);
            }), u(0, n, "cull", function() {
                return this._shaderValues.getInt(e.CULL);
            }, function(t) {
                this._shaderValues.setInt(e.CULL, t);
            }), u(0, n, "depthWrite", function() {
                return this._shaderValues.getBool(e.DEPTH_WRITE);
            }, function(t) {
                this._shaderValues.setBool(e.DEPTH_WRITE, t);
            }), u(0, n, "blendSrc", function() {
                return this._shaderValues.getInt(e.BLEND_SRC);
            }, function(t) {
                this._shaderValues.setInt(e.BLEND_SRC, t);
            }), u(0, n, "blendDst", function() {
                return this._shaderValues.getInt(e.BLEND_DST);
            }, function(t) {
                this._shaderValues.setInt(e.BLEND_DST, t);
            }), u(0, n, "depthTest", function() {
                return this._shaderValues.getInt(e.DEPTH_TEST);
            }, function(t) {
                this._shaderValues.setInt(e.DEPTH_TEST, t);
            }), _(e, ["COLOR", function() {
                return this.COLOR = Vt.propertyNameToID("u_Color");
            }, "defaultMaterial", function() {
                return this.defaultMaterial = new e();
            }, "shaderDefines", function() {
                return this.shaderDefines = new ht(Cn.shaderDefines);
            }, "CULL", function() {
                return this.CULL = Vt.propertyNameToID("s_Cull");
            }, "BLEND", function() {
                return this.BLEND = Vt.propertyNameToID("s_Blend");
            }, "BLEND_SRC", function() {
                return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
            }, "BLEND_DST", function() {
                return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
            }, "DEPTH_TEST", function() {
                return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
            }, "DEPTH_WRITE", function() {
                return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
            }]), e;
        }(),
        Kn = function(r) {
            function a(t, e) {
                a.__super.call(this), this._skyRenderer = new ce(), this._forward = new Ct(), this._up = new Ct(),
                    this.clearColor = new At(100 / 255, 149 / 255, 237 / 255, 1), void 0 === t && (t = .3),
                    void 0 === e && (e = 1e3), this._shaderValues = new at(null), this._fieldOfView = 60,
                    this._useUserProjectionMatrix = !1, this._orthographic = !1, this._orthographicVerticalSize = 10,
                    this.renderingOrder = 0, this._nearPlane = t, this._farPlane = e, this.cullingMask = 2147483647,
                    this.clearFlag = 0, this.useOcclusionCulling = !0, this._calculateProjectionMatrix(),
                    m.stage.on("resize", this, this._onScreenSizeChanged);
            }
            d(a, "laya.d3.core.BaseCamera", r);
            var t = a.prototype;
            return t._sortCamerasByRenderingOrder = function() {
                    if (this.displayedInStage)
                        for (var t = this.scene._cameraPool, e = t.length - 1, n = 0; n < e; n++)
                            if (t[n].renderingOrder > t[e].renderingOrder) {
                                var i = t[n];
                                t[n] = t[e], t[e] = i;
                            }
                }, t._calculateProjectionMatrix = function() {}, t._onScreenSizeChanged = function() {
                    this._calculateProjectionMatrix();
                }, t._prepareCameraToRender = function() {
                    this.transform.getForward(this._forward), this.transform.getUp(this._up);
                    var t = this._shaderValues;
                    t.setVector3(laya.d3.core.BaseCamera.CAMERAPOS, this.transform.position), t.setVector3(laya.d3.core.BaseCamera.CAMERADIRECTION, this._forward),
                        t.setVector3(laya.d3.core.BaseCamera.CAMERAUP, this._up);
                }, t._prepareCameraViewProject = function(t, e, n) {
                    var i = this._shaderValues;
                    i.setMatrix4x4(laya.d3.core.BaseCamera.VIEWMATRIX, t), i.setMatrix4x4(laya.d3.core.BaseCamera.PROJECTMATRIX, e),
                        this.transform.worldMatrix.cloneTo(a._tempMatrix4x40), a._tempMatrix4x40.transpose(),
                        be.multiply(e, a._tempMatrix4x40, n), i.setMatrix4x4(laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE, n);
                }, t.render = function(t, e) {}, t.addLayer = function(t) {
                    this.cullingMask |= Math.pow(2, t);
                }, t.removeLayer = function(t) {
                    this.cullingMask &= ~Math.pow(2, t);
                }, t.addAllLayers = function() {
                    this.cullingMask = 2147483647;
                }, t.removeAllLayers = function() {
                    this.cullingMask = 0;
                }, t.resetProjectionMatrix = function() {
                    this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
                }, t._onActive = function() {
                    this._scene._addCamera(this), laya.display.Node.prototype._onActive.call(this);
                }, t._onInActive = function() {
                    this._scene._removeCamera(this), laya.display.Node.prototype._onInActive.call(this);
                }, t._parse = function(t) {
                    r.prototype._parse.call(this, t);
                    var e = t.clearFlag;
                    void 0 !== e && (this.clearFlag = e), this.orthographic = t.orthographic, this.fieldOfView = t.fieldOfView,
                        this.nearPlane = t.nearPlane, this.farPlane = t.farPlane;
                    var n = t.clearColor;
                    this.clearColor = new At(n[0], n[1], n[2], n[3]);
                    var i = t.skyboxMaterial;
                    i && (this._skyRenderer.material = xt.getRes(i.path));
                }, t.destroy = function(t) {
                    void 0 === t && (t = !0), this.renderTarget = null, this._skyRenderer.destroy(),
                        this._skyRenderer = null, m.stage.off("resize", this, this._onScreenSizeChanged),
                        r.prototype.destroy.call(this, t);
                }, u(0, t, "renderingOrder", function() {
                    return this._renderingOrder;
                }, function(t) {
                    this._renderingOrder = t, this._sortCamerasByRenderingOrder();
                }), u(0, t, "skyRenderer", function() {
                    return this._skyRenderer;
                }), u(0, t, "farPlane", function() {
                    return this._farPlane;
                }, function(t) {
                    this._farPlane = t, this._calculateProjectionMatrix();
                }), u(0, t, "renderTarget", function() {
                    return this._renderTarget;
                }, function(t) {
                    this._renderTarget !== t && (this._renderTarget = t, this._calculateProjectionMatrix());
                }), u(0, t, "orthographic", function() {
                    return this._orthographic;
                }, function(t) {
                    this._orthographic = t, this._calculateProjectionMatrix();
                }), u(0, t, "fieldOfView", function() {
                    return this._fieldOfView;
                }, function(t) {
                    this._fieldOfView = t, this._calculateProjectionMatrix();
                }), u(0, t, "nearPlane", function() {
                    return this._nearPlane;
                }, function(t) {
                    this._nearPlane = t, this._calculateProjectionMatrix();
                }), u(0, t, "orthographicVerticalSize", function() {
                    return this._orthographicVerticalSize;
                }, function(t) {
                    this._orthographicVerticalSize = t, this._calculateProjectionMatrix();
                }), a.VPMATRIX = 3, a.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", a.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING",
                a.CLEARFLAG_SOLIDCOLOR = 0, a.CLEARFLAG_SKY = 1, a.CLEARFLAG_DEPTHONLY = 2, a.CLEARFLAG_NONE = 3,
                _(a, ["_tempMatrix4x40", function() {
                    return this._tempMatrix4x40 = new be();
                }, "CAMERAPOS", function() {
                    return this.CAMERAPOS = Vt.propertyNameToID("u_CameraPos");
                }, "VIEWMATRIX", function() {
                    return this.VIEWMATRIX = Vt.propertyNameToID("u_View");
                }, "PROJECTMATRIX", function() {
                    return this.PROJECTMATRIX = Vt.propertyNameToID("u_Projection");
                }, "VPMATRIX_NO_TRANSLATE", function() {
                    return this.VPMATRIX_NO_TRANSLATE = Vt.propertyNameToID("u_MvpMatrix");
                }, "CAMERADIRECTION", function() {
                    return this.CAMERADIRECTION = Vt.propertyNameToID("u_CameraDirection");
                }, "CAMERAUP", function() {
                    return this.CAMERAUP = Vt.propertyNameToID("u_CameraUp");
                }, "_invertYScaleMatrix", function() {
                    return this._invertYScaleMatrix = new be(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                }, "_invertYProjectionMatrix", function() {
                    return this._invertYProjectionMatrix = new be();
                }, "_invertYProjectionViewMatrix", function() {
                    return this._invertYProjectionViewMatrix = new be();
                }]), a;
        }(An),
        qn = function(n) {
            function i() {
                this._albedoColor = null, this._emissionColor = null, i.__super.call(this), this.setShaderName("PBRStandard"),
                    this._albedoColor = new At(1, 1, 1, 1), this._shaderValues.setVector(i.ALBEDOCOLOR, new At(1, 1, 1, 1)),
                    this._emissionColor = new At(0, 0, 0, 0), this._shaderValues.setVector(i.EMISSIONCOLOR, new At(0, 0, 0, 0)),
                    this._shaderValues.setNumber(i.METALLIC, 0), this._shaderValues.setNumber(i.SMOOTHNESS, .5),
                    this._shaderValues.setNumber(i.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(i.SMOOTHNESSSOURCE, 0),
                    this._shaderValues.setNumber(i.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(i.NORMALSCALE, 1),
                    this._shaderValues.setNumber(i.PARALLAXSCALE, .001), this._shaderValues.setBool(i.ENABLEEMISSION, !1),
                    this._shaderValues.setBool(i.ENABLEREFLECT, !0), this._shaderValues.setNumber(Cn.ALPHATESTVALUE, .5),
                    this._disablePublicDefineDatas.remove(Gn.SHADERDEFINE_REFLECTMAP), this.renderMode = 0;
            }
            d(i, "laya.d3.core.material.PBRStandardMaterial", n);
            var t = i.prototype;
            return t.cloneTo = function(t) {
                    n.prototype.cloneTo.call(this, t);
                    var e = t;
                    this._albedoColor.cloneTo(e._albedoColor), this._emissionColor.cloneTo(e._emissionColor);
                }, u(0, t, "_Parallax", function() {
                    return this._shaderValues.getNumber(i.PARALLAXSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.PARALLAXSCALE, t);
                }), u(0, t, "_ColorB", function() {
                    return this._albedoColor.z;
                }, function(t) {
                    this._albedoColor.z = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_ColorR", function() {
                    return this._albedoColor.x;
                }, function(t) {
                    this._albedoColor.x = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_ColorG", function() {
                    return this._albedoColor.y;
                }, function(t) {
                    this._albedoColor.y = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "metallic", function() {
                    return this._Metallic;
                }, function(t) {
                    this._Metallic = Math.max(0, Math.min(1, t));
                }), u(0, t, "_GlossMapScale", function() {
                    return this._shaderValues.getNumber(i.SMOOTHNESSSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.SMOOTHNESSSCALE, t);
                }), u(0, t, "_Glossiness", function() {
                    return this._shaderValues.getNumber(i.SMOOTHNESS);
                }, function(t) {
                    this._shaderValues.setNumber(i.SMOOTHNESS, t);
                }), u(0, t, "_ColorA", function() {
                    return this._albedoColor.w;
                }, function(t) {
                    this._albedoColor.w = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "enableReflection", function() {
                    return this._shaderValues.getBool(i.ENABLEREFLECT);
                }, function(t) {
                    this._shaderValues.setBool(i.ENABLEREFLECT, !0), t ? this._disablePublicDefineDatas.remove(Gn.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_REFLECTMAP);
                }), u(0, t, "_Metallic", function() {
                    return this._shaderValues.getNumber(i.METALLIC);
                }, function(t) {
                    this._shaderValues.setNumber(i.METALLIC, t);
                }), u(0, t, "_BumpScale", function() {
                    return this._shaderValues.getNumber(i.NORMALSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.NORMALSCALE, t);
                }), u(0, t, "_OcclusionStrength", function() {
                    return this._shaderValues.getNumber(i.OCCLUSIONSTRENGTH);
                }, function(t) {
                    this._shaderValues.setNumber(i.OCCLUSIONSTRENGTH, t);
                }), u(0, t, "_EmissionColorR", function() {
                    return this._emissionColor.x;
                }, function(t) {
                    this._emissionColor.x = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "tilingOffset", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(i.TILINGOFFSET, t);
                }), u(0, t, "_EmissionColorG", function() {
                    return this._emissionColor.y;
                }, function(t) {
                    this._emissionColor.y = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "blendSrc", function() {
                    return this._shaderValues.getInt(i.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_SRC, t);
                }), u(0, t, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, t, "_EmissionColorB", function() {
                    return this._emissionColor.z;
                }, function(t) {
                    this._emissionColor.z = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "_EmissionColorA", function() {
                    return this._emissionColor.w;
                }, function(t) {
                    this._emissionColor.w = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "albedoColorA", function() {
                    return this._ColorA;
                }, function(t) {
                    this._ColorA = t;
                }), u(0, t, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, t, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, t, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, t, "_Cutoff", function() {
                    return this.alphaTestValue;
                }, function(t) {
                    this.alphaTestValue = t;
                }), u(0, t, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, t, "albedoColorR", function() {
                    return this._ColorR;
                }, function(t) {
                    this._ColorR = t;
                }), u(0, t, "albedoColorG", function() {
                    return this._ColorG;
                }, function(t) {
                    this._ColorG = t;
                }), u(0, t, "albedoColorB", function() {
                    return this._ColorB;
                }, function(t) {
                    this._ColorB = t;
                }), u(0, t, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, t, "albedoColor", function() {
                    return this._albedoColor;
                }, function(t) {
                    this._albedoColor = t, this._shaderValues.setVector(i.ALBEDOCOLOR, t);
                }), u(0, t, "albedoTexture", function() {
                    return this._shaderValues.getTexture(i.ALBEDOTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                        this._shaderValues.setTexture(i.ALBEDOTEXTURE, t);
                }), u(0, t, "cull", function() {
                    return this._shaderValues.getInt(i.CULL);
                }, function(t) {
                    this._shaderValues.setInt(i.CULL, t);
                }), u(0, t, "parallaxTexture", function() {
                    return this._shaderValues.getTexture(i.PARALLAXTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE),
                        this._shaderValues.setTexture(i.PARALLAXTEXTURE, t);
                }), u(0, t, "normalTexture", function() {
                    return this._shaderValues.getTexture(i.NORMALTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE),
                        this._shaderValues.setTexture(i.NORMALTEXTURE, t);
                }), u(0, t, "emissionColor", function() {
                    return this._shaderValues.getVector(i.EMISSIONCOLOR);
                }, function(t) {
                    this._shaderValues.setVector(i.EMISSIONCOLOR, t);
                }), u(0, t, "parallaxTextureScale", function() {
                    return this._Parallax;
                }, function(t) {
                    this._Parallax = Math.max(.005, Math.min(.08, t));
                }), u(0, t, "normalTextureScale", function() {
                    return this._BumpScale;
                }, function(t) {
                    this._BumpScale = t;
                }), u(0, t, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, t, "occlusionTexture", function() {
                    return this._shaderValues.getTexture(i.OCCLUSIONTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE),
                        this._shaderValues.setTexture(i.OCCLUSIONTEXTURE, t);
                }), u(0, t, "occlusionTextureStrength", function() {
                    return this._OcclusionStrength;
                }, function(t) {
                    this._OcclusionStrength = Math.max(0, Math.min(1, t));
                }), u(0, t, "enableEmission", function() {
                    return this._shaderValues.getBool(i.ENABLEEMISSION);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION),
                        this._shaderValues.setBool(i.ENABLEEMISSION, t);
                }), u(0, t, "metallicGlossTexture", function() {
                    return this._shaderValues.getTexture(i.METALLICGLOSSTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE),
                        this._shaderValues.setTexture(i.METALLICGLOSSTEXTURE, t);
                }), u(0, t, "emissionColorA", function() {
                    return this._EmissionColorA;
                }, function(t) {
                    this._EmissionColorA = t;
                }), u(0, t, "smoothness", function() {
                    return this._Glossiness;
                }, function(t) {
                    this._Glossiness = Math.max(0, Math.min(1, t));
                }), u(0, t, "blendDst", function() {
                    return this._shaderValues.getInt(i.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_DST, t);
                }), u(0, t, "smoothnessTextureScale", function() {
                    return this._GlossMapScale;
                }, function(t) {
                    this._GlossMapScale = Math.max(0, Math.min(1, t));
                }), u(0, t, "depthWrite", function() {
                    return this._shaderValues.getBool(i.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(i.DEPTH_WRITE, t);
                }), u(0, t, "smoothnessSource", function() {
                    return this._shaderValues.getInt(i.SMOOTHNESSSOURCE);
                }, function(t) {
                    t ? (this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                        this._shaderValues.setInt(i.SMOOTHNESSSOURCE, 1)) : (this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                        this._shaderValues.setInt(i.SMOOTHNESSSOURCE, 0));
                }), u(0, t, "emissionColorR", function() {
                    return this._EmissionColorR;
                }, function(t) {
                    this._EmissionColorR = t;
                }), u(0, t, "emissionColorG", function() {
                    return this._EmissionColorG;
                }, function(t) {
                    this._EmissionColorG = t;
                }), u(0, t, "emissionColorB", function() {
                    return this._EmissionColorB;
                }, function(t) {
                    this._EmissionColorB = t;
                }), u(0, t, "emissionTexture", function() {
                    return this._shaderValues.getTexture(i.EMISSIONTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE),
                        this._shaderValues.setTexture(i.EMISSIONTEXTURE, t);
                }), u(0, t, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, t, "renderMode", null, function(t) {
                    switch (t) {
                        case 0:
                            this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 1:
                            this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 2:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513,
                                this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 3:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 1, this.blendDst = 771, this.depthTest = 513, this._defineDatas.add(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        default:
                            throw new Error("PBRSpecularMaterial : renderMode value error.");
                    }
                }), u(0, t, "blend", function() {
                    return this._shaderValues.getInt(i.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND, t);
                }), u(0, t, "depthTest", function() {
                    return this._shaderValues.getInt(i.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(i.DEPTH_TEST, t);
                }), i.__init__ = function() {
                    i.SHADERDEFINE_ALBEDOTEXTURE = i.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                        i.SHADERDEFINE_METALLICGLOSSTEXTURE = i.shaderDefines.registerDefine("METALLICGLOSSTEXTURE"),
                        i.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = i.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"),
                        i.SHADERDEFINE_NORMALTEXTURE = i.shaderDefines.registerDefine("NORMALTEXTURE"),
                        i.SHADERDEFINE_PARALLAXTEXTURE = i.shaderDefines.registerDefine("PARALLAXTEXTURE"),
                        i.SHADERDEFINE_OCCLUSIONTEXTURE = i.shaderDefines.registerDefine("OCCLUSIONTEXTURE"),
                        i.SHADERDEFINE_EMISSION = i.shaderDefines.registerDefine("EMISSION"), i.SHADERDEFINE_EMISSIONTEXTURE = i.shaderDefines.registerDefine("EMISSIONTEXTURE"),
                        i.SHADERDEFINE_REFLECTMAP = i.shaderDefines.registerDefine("REFLECTMAP"), i.SHADERDEFINE_TILINGOFFSET = i.shaderDefines.registerDefine("TILINGOFFSET"),
                        i.SHADERDEFINE_ALPHAPREMULTIPLY = i.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
                }, i.SmoothnessSource_MetallicGlossTexture_Alpha = 0, i.SmoothnessSource_AlbedoTexture_Alpha = 1,
                i.RENDERMODE_OPAQUE = 0, i.RENDERMODE_CUTOUT = 1, i.RENDERMODE_FADE = 2, i.RENDERMODE_TRANSPARENT = 3,
                i.SHADERDEFINE_ALBEDOTEXTURE = 0, i.SHADERDEFINE_NORMALTEXTURE = 0, i.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = 0,
                i.SHADERDEFINE_METALLICGLOSSTEXTURE = 0, i.SHADERDEFINE_OCCLUSIONTEXTURE = 0, i.SHADERDEFINE_PARALLAXTEXTURE = 0,
                i.SHADERDEFINE_EMISSION = 0, i.SHADERDEFINE_EMISSIONTEXTURE = 0, i.SHADERDEFINE_REFLECTMAP = 0,
                i.SHADERDEFINE_TILINGOFFSET = 0, i.SHADERDEFINE_ALPHAPREMULTIPLY = 0, i.SMOOTHNESSSOURCE = -1,
                i.ENABLEEMISSION = -1, i.ENABLEREFLECT = -1, _(i, ["ALBEDOTEXTURE", function() {
                    return this.ALBEDOTEXTURE = Vt.propertyNameToID("u_AlbedoTexture");
                }, "METALLICGLOSSTEXTURE", function() {
                    return this.METALLICGLOSSTEXTURE = Vt.propertyNameToID("u_MetallicGlossTexture");
                }, "NORMALTEXTURE", function() {
                    return this.NORMALTEXTURE = Vt.propertyNameToID("u_NormalTexture");
                }, "PARALLAXTEXTURE", function() {
                    return this.PARALLAXTEXTURE = Vt.propertyNameToID("u_ParallaxTexture");
                }, "OCCLUSIONTEXTURE", function() {
                    return this.OCCLUSIONTEXTURE = Vt.propertyNameToID("u_OcclusionTexture");
                }, "EMISSIONTEXTURE", function() {
                    return this.EMISSIONTEXTURE = Vt.propertyNameToID("u_EmissionTexture");
                }, "ALBEDOCOLOR", function() {
                    return this.ALBEDOCOLOR = Vt.propertyNameToID("u_AlbedoColor");
                }, "EMISSIONCOLOR", function() {
                    return this.EMISSIONCOLOR = Vt.propertyNameToID("u_EmissionColor");
                }, "METALLIC", function() {
                    return this.METALLIC = Vt.propertyNameToID("u_metallic");
                }, "SMOOTHNESS", function() {
                    return this.SMOOTHNESS = Vt.propertyNameToID("u_smoothness");
                }, "SMOOTHNESSSCALE", function() {
                    return this.SMOOTHNESSSCALE = Vt.propertyNameToID("u_smoothnessScale");
                }, "OCCLUSIONSTRENGTH", function() {
                    return this.OCCLUSIONSTRENGTH = Vt.propertyNameToID("u_occlusionStrength");
                }, "NORMALSCALE", function() {
                    return this.NORMALSCALE = Vt.propertyNameToID("u_normalScale");
                }, "PARALLAXSCALE", function() {
                    return this.PARALLAXSCALE = Vt.propertyNameToID("u_parallaxScale");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new i();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), i;
        }(Cn),
        Qn = function(t) {
            function n() {
                n.__super.call(this), this.setShaderName("PARTICLESHURIKEN"), this._color = new At(1, 1, 1, 1),
                    this.renderMode = 0;
            }
            d(n, "laya.d3.core.particleShuriKen.ShurikenParticleMaterial", Cn);
            var e = n.prototype;
            return u(0, e, "_TintColorB", function() {
                    return this._color.z;
                }, function(t) {
                    this._color.z = t, this.color = this._color;
                }), u(0, e, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, e, "texture", function() {
                    return this._shaderValues.getTexture(n.DIFFUSETEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP),
                        this._shaderValues.setTexture(n.DIFFUSETEXTURE, t);
                }), u(0, e, "_TintColorR", function() {
                    return this._color.x;
                }, function(t) {
                    this._color.x = t, this.color = this._color;
                }), u(0, e, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, e, "_TintColorG", function() {
                    return this._color.y;
                }, function(t) {
                    this._color.y = t, this.color = this._color;
                }), u(0, e, "_TintColorA", function() {
                    return this._color.w;
                }, function(t) {
                    this._color.w = t, this.color = this._color;
                }), u(0, e, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, e, "renderMode", null, function(t) {
                    switch (t) {
                        case 1:
                            this.renderQueue = 3e3, this.depthWrite = !1, this.cull = 0, this.blend = 1, this.blendSrc = 770,
                                this.blendDst = 1, this.alphaTest = !1, this._defineDatas.add(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        case 0:
                            this.renderQueue = 3e3, this.depthWrite = !1, this.cull = 0, this.blend = 1, this.blendSrc = 770,
                                this.blendDst = 771, this.alphaTest = !1, this._defineDatas.remove(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        default:
                            throw new Error("ShurikenParticleMaterial : renderMode value error.");
                    }
                }), u(0, e, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, e, "colorR", function() {
                    return this._TintColorR;
                }, function(t) {
                    this._TintColorR = t;
                }), u(0, e, "colorG", function() {
                    return this._TintColorG;
                }, function(t) {
                    this._TintColorG = t;
                }), u(0, e, "colorB", function() {
                    return this._TintColorB;
                }, function(t) {
                    this._TintColorB = t;
                }), u(0, e, "colorA", function() {
                    return this._TintColorA;
                }, function(t) {
                    this._TintColorA = t;
                }), u(0, e, "blend", function() {
                    return this._shaderValues.getInt(n.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND, t);
                }), u(0, e, "color", function() {
                    return this._shaderValues.getVector(n.TINTCOLOR);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR),
                        this._shaderValues.setVector(n.TINTCOLOR, t);
                }), u(0, e, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, e, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, e, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, e, "blendSrc", function() {
                    return this._shaderValues.getInt(n.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_SRC, t);
                }), u(0, e, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, e, "tilingOffset", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(n.TILINGOFFSET, t);
                }), u(0, e, "depthWrite", function() {
                    return this._shaderValues.getBool(n.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(n.DEPTH_WRITE, t);
                }), u(0, e, "cull", function() {
                    return this._shaderValues.getInt(n.CULL);
                }, function(t) {
                    this._shaderValues.setInt(n.CULL, t);
                }), u(0, e, "blendDst", function() {
                    return this._shaderValues.getInt(n.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_DST, t);
                }), u(0, e, "depthTest", function() {
                    return this._shaderValues.getInt(n.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(n.DEPTH_TEST, t);
                }), n.__init__ = function() {
                    n.SHADERDEFINE_DIFFUSEMAP = n.shaderDefines.registerDefine("DIFFUSEMAP"), n.SHADERDEFINE_TINTCOLOR = n.shaderDefines.registerDefine("TINTCOLOR"),
                        n.SHADERDEFINE_ADDTIVEFOG = n.shaderDefines.registerDefine("ADDTIVEFOG"), n.SHADERDEFINE_TILINGOFFSET = n.shaderDefines.registerDefine("TILINGOFFSET");
                }, n.RENDERMODE_ALPHABLENDED = 0, n.RENDERMODE_ADDTIVE = 1, n.SHADERDEFINE_DIFFUSEMAP = 0,
                n.SHADERDEFINE_TINTCOLOR = 0, n.SHADERDEFINE_TILINGOFFSET = 0, n.SHADERDEFINE_ADDTIVEFOG = 0,
                _(n, ["DIFFUSETEXTURE", function() {
                    return this.DIFFUSETEXTURE = Vt.propertyNameToID("u_texture");
                }, "TINTCOLOR", function() {
                    return this.TINTCOLOR = Vt.propertyNameToID("u_Tintcolor");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new n();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), n;
        }(),
        Jn = function(t) {
            function n() {
                this._color = null, n.__super.call(this), this.setShaderName("Effect"), this._color = new At(1, 1, 1, 1),
                    this._shaderValues.setVector(n.TINTCOLOR, new At(1, 1, 1, 1)), this.renderMode = 0;
            }
            d(n, "laya.d3.core.material.EffectMaterial", Cn);
            var e = n.prototype;
            return u(0, e, "_TintColorB", function() {
                    return this._color.z;
                }, function(t) {
                    this._color.z = t, this.color = this._color;
                }), u(0, e, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, e, "texture", function() {
                    return this._shaderValues.getTexture(n.MAINTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE),
                        this._shaderValues.setTexture(n.MAINTEXTURE, t);
                }), u(0, e, "_TintColorR", function() {
                    return this._color.x;
                }, function(t) {
                    this._color.x = t, this.color = this._color;
                }), u(0, e, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, e, "_TintColorG", function() {
                    return this._color.y;
                }, function(t) {
                    this._color.y = t, this.color = this._color;
                }), u(0, e, "_TintColorA", function() {
                    return this._color.w;
                }, function(t) {
                    this._color.w = t, this.color = this._color;
                }), u(0, e, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, e, "renderMode", null, function(t) {
                    switch (t) {
                        case 0:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 1, this.depthTest = 513, this._defineDatas.add(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        case 1:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513,
                                this._defineDatas.remove(n.SHADERDEFINE_ADDTIVEFOG);
                            break;

                        default:
                            throw new Error("MeshEffectMaterial : renderMode value error.");
                    }
                }), u(0, e, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(n.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, e, "colorR", function() {
                    return this._TintColorR;
                }, function(t) {
                    this._TintColorR = t;
                }), u(0, e, "colorG", function() {
                    return this._TintColorG;
                }, function(t) {
                    this._TintColorG = t;
                }), u(0, e, "colorB", function() {
                    return this._TintColorB;
                }, function(t) {
                    this._TintColorB = t;
                }), u(0, e, "colorA", function() {
                    return this._TintColorA;
                }, function(t) {
                    this._TintColorA = t;
                }), u(0, e, "blend", function() {
                    return this._shaderValues.getInt(n.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND, t);
                }), u(0, e, "color", function() {
                    return this._shaderValues.getVector(n.TINTCOLOR);
                }, function(t) {
                    this._shaderValues.setVector(n.TINTCOLOR, t);
                }), u(0, e, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, e, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, e, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, e, "blendSrc", function() {
                    return this._shaderValues.getInt(n.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_SRC, t);
                }), u(0, e, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, e, "tilingOffset", function() {
                    return this._shaderValues.getVector(n.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(n.TILINGOFFSET, t);
                }), u(0, e, "depthWrite", function() {
                    return this._shaderValues.getBool(n.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(n.DEPTH_WRITE, t);
                }), u(0, e, "cull", function() {
                    return this._shaderValues.getInt(n.CULL);
                }, function(t) {
                    this._shaderValues.setInt(n.CULL, t);
                }), u(0, e, "blendDst", function() {
                    return this._shaderValues.getInt(n.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_DST, t);
                }), u(0, e, "depthTest", function() {
                    return this._shaderValues.getInt(n.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(n.DEPTH_TEST, t);
                }), n.__init__ = function() {
                    n.SHADERDEFINE_MAINTEXTURE = n.shaderDefines.registerDefine("MAINTEXTURE"), n.SHADERDEFINE_TILINGOFFSET = n.shaderDefines.registerDefine("TILINGOFFSET"),
                        n.SHADERDEFINE_ADDTIVEFOG = n.shaderDefines.registerDefine("ADDTIVEFOG");
                }, n.RENDERMODE_ADDTIVE = 0, n.RENDERMODE_ALPHABLENDED = 1, n.SHADERDEFINE_MAINTEXTURE = 0,
                n.SHADERDEFINE_TILINGOFFSET = 0, n.SHADERDEFINE_ADDTIVEFOG = 0, _(n, ["defaultMaterial", function() {
                    return this.defaultMaterial = new n();
                }, "MAINTEXTURE", function() {
                    return this.MAINTEXTURE = Vt.propertyNameToID("u_AlbedoTexture");
                }, "TINTCOLOR", function() {
                    return this.TINTCOLOR = Vt.propertyNameToID("u_AlbedoColor");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), n;
        }(),
        $n = function(t) {
            function e() {
                e.__super.call(this), this.setShaderName("WaterPrimary"), this._shaderValues.setVector(e.HORIZONCOLOR, new At(.172, .463, .435, 0)),
                    this._shaderValues.setNumber(e.WAVESCALE, .15), this._shaderValues.setVector(e.WAVESPEED, new At(19, 9, -16, -7));
            }
            d(e, "laya.d3.core.material.WaterPrimaryMaterial", Cn);
            var n = e.prototype;
            return u(0, n, "waveSpeed", function() {
                return this._shaderValues.getVector(e.WAVESPEED);
            }, function(t) {
                this._shaderValues.setVector(e.WAVESPEED, t);
            }), u(0, n, "horizonColor", function() {
                return this._shaderValues.getVector(e.HORIZONCOLOR);
            }, function(t) {
                this._shaderValues.setVector(e.HORIZONCOLOR, t);
            }), u(0, n, "mainTexture", function() {
                return this._shaderValues.getTexture(e.MAINTEXTURE);
            }, function(t) {
                t ? this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(e.MAINTEXTURE, t);
            }), u(0, n, "normalTexture", function() {
                return this._shaderValues.getTexture(e.NORMALTEXTURE);
            }, function(t) {
                t ? this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE),
                    this._shaderValues.setTexture(e.NORMALTEXTURE, t);
            }), u(0, n, "waveScale", function() {
                return this._shaderValues.getNumber(e.WAVESCALE);
            }, function(t) {
                this._shaderValues.setNumber(e.WAVESCALE, t);
            }), e.__init__ = function() {
                e.SHADERDEFINE_MAINTEXTURE = e.shaderDefines.registerDefine("MAINTEXTURE"), e.SHADERDEFINE_NORMALTEXTURE = e.shaderDefines.registerDefine("NORMALTEXTURE");
            }, e.SHADERDEFINE_MAINTEXTURE = 0, e.SHADERDEFINE_NORMALTEXTURE = 0, _(e, ["HORIZONCOLOR", function() {
                return this.HORIZONCOLOR = Vt.propertyNameToID("u_HorizonColor");
            }, "MAINTEXTURE", function() {
                return this.MAINTEXTURE = Vt.propertyNameToID("u_MainTexture");
            }, "NORMALTEXTURE", function() {
                return this.NORMALTEXTURE = Vt.propertyNameToID("u_NormalTexture");
            }, "WAVESCALE", function() {
                return this.WAVESCALE = Vt.propertyNameToID("u_WaveScale");
            }, "WAVESPEED", function() {
                return this.WAVESPEED = Vt.propertyNameToID("u_WaveSpeed");
            }, "defaultMaterial", function() {
                return this.defaultMaterial = new e();
            }, "shaderDefines", function() {
                return this.shaderDefines = new ht(Cn.shaderDefines);
            }]), e;
        }(),
        ti = function(t) {
            function e() {
                this._enableLighting = !0, e.__super.call(this), this.setShaderName("ExtendTerrain"),
                    this.renderMode = 1;
            }
            d(e, "laya.d3.core.material.ExtendTerrainMaterial", Cn);
            var n = e.prototype;
            return n._setDetailNum = function(t) {
                    switch (t) {
                        case 1:
                            this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                            break;

                        case 2:
                            this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                            break;

                        case 3:
                            this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                            break;

                        case 4:
                            this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                            break;

                        case 5:
                            this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    }
                }, u(0, n, "diffuseScaleOffset2", null, function(t) {
                    this._shaderValues.setVector(e.DIFFUSESCALEOFFSET2, t);
                }), u(0, n, "splatAlphaTexture", function() {
                    return this._shaderValues.getTexture(e.SPLATALPHATEXTURE);
                }, function(t) {
                    this._shaderValues.setTexture(e.SPLATALPHATEXTURE, t);
                }), u(0, n, "diffuseScaleOffset3", null, function(t) {
                    this._shaderValues.setVector(e.DIFFUSESCALEOFFSET3, t);
                }), u(0, n, "diffuseTexture1", null, function(t) {
                    this._shaderValues.setTexture(e.DIFFUSETEXTURE1, t), this._setDetailNum(1);
                }), u(0, n, "renderMode", null, function(t) {
                    switch (t) {
                        case 1:
                            this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, this.blend = 0, this.depthTest = 513;
                            break;

                        case 2:
                            this.renderQueue = 2e3, this.depthWrite = !1, this.cull = 2, this.blend = 1, this.blendSrc = 770,
                                this.blendDst = 771, this.depthTest = 515;
                            break;

                        default:
                            throw new Error("ExtendTerrainMaterial:renderMode value error.");
                    }
                }), u(0, n, "diffuseTexture2", function() {
                    return this._shaderValues.getTexture(e.DIFFUSETEXTURE2);
                }, function(t) {
                    this._shaderValues.setTexture(e.DIFFUSETEXTURE2, t), this._setDetailNum(2);
                }), u(0, n, "diffuseScaleOffset1", null, function(t) {
                    this._shaderValues.setVector(e.DIFFUSESCALEOFFSET1, t);
                }), u(0, n, "diffuseTexture3", function() {
                    return this._shaderValues.getTexture(e.DIFFUSETEXTURE3);
                }, function(t) {
                    this._shaderValues.setTexture(e.DIFFUSETEXTURE3, t), this._setDetailNum(3);
                }), u(0, n, "diffuseTexture4", function() {
                    return this._shaderValues.getTexture(e.DIFFUSETEXTURE4);
                }, function(t) {
                    this._shaderValues.setTexture(e.DIFFUSETEXTURE4, t), this._setDetailNum(4);
                }), u(0, n, "diffuseTexture5", function() {
                    return this._shaderValues.getTexture(e.DIFFUSETEXTURE5);
                }, function(t) {
                    this._shaderValues.setTexture(e.DIFFUSETEXTURE5, t), this._setDetailNum(5);
                }), u(0, n, "diffuseScaleOffset4", null, function(t) {
                    this._shaderValues.setVector(e.DIFFUSESCALEOFFSET4, t);
                }), u(0, n, "diffuseScaleOffset5", null, function(t) {
                    this._shaderValues.setVector(e.DIFFUSESCALEOFFSET5, t);
                }), u(0, n, "blendSrc", function() {
                    return this._shaderValues.getInt(e.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(e.BLEND_SRC, t);
                }), u(0, n, "enableLighting", function() {
                    return this._enableLighting;
                }, function(t) {
                    this._enableLighting !== t && (t ? this._disablePublicDefineDatas.remove(Gn.SHADERDEFINE_POINTLIGHT | Gn.SHADERDEFINE_SPOTLIGHT | Gn.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_POINTLIGHT | Gn.SHADERDEFINE_SPOTLIGHT | Gn.SHADERDEFINE_DIRECTIONLIGHT),
                        this._enableLighting = t);
                }), u(0, n, "depthWrite", function() {
                    return this._shaderValues.getBool(e.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(e.DEPTH_WRITE, t);
                }), u(0, n, "cull", function() {
                    return this._shaderValues.getInt(e.CULL);
                }, function(t) {
                    this._shaderValues.setInt(e.CULL, t);
                }), u(0, n, "blend", function() {
                    return this._shaderValues.getInt(e.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(e.BLEND, t);
                }), u(0, n, "blendDst", function() {
                    return this._shaderValues.getInt(e.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(e.BLEND_DST, t);
                }), u(0, n, "depthTest", function() {
                    return this._shaderValues.getInt(e.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(e.DEPTH_TEST, t);
                }), e.__init__ = function() {
                    e.SHADERDEFINE_DETAIL_NUM1 = e.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1"),
                        e.SHADERDEFINE_DETAIL_NUM2 = e.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2"),
                        e.SHADERDEFINE_DETAIL_NUM3 = e.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3"),
                        e.SHADERDEFINE_DETAIL_NUM4 = e.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4"),
                        e.SHADERDEFINE_DETAIL_NUM5 = e.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
                }, e.RENDERMODE_OPAQUE = 1, e.RENDERMODE_TRANSPARENT = 2, e.SHADERDEFINE_DETAIL_NUM1 = 0,
                e.SHADERDEFINE_DETAIL_NUM2 = 0, e.SHADERDEFINE_DETAIL_NUM3 = 0, e.SHADERDEFINE_DETAIL_NUM4 = 0,
                e.SHADERDEFINE_DETAIL_NUM5 = 0, _(e, ["SPLATALPHATEXTURE", function() {
                    return this.SPLATALPHATEXTURE = Vt.propertyNameToID("u_SplatAlphaTexture");
                }, "DIFFUSETEXTURE1", function() {
                    return this.DIFFUSETEXTURE1 = Vt.propertyNameToID("u_DiffuseTexture1");
                }, "DIFFUSETEXTURE2", function() {
                    return this.DIFFUSETEXTURE2 = Vt.propertyNameToID("u_DiffuseTexture2");
                }, "DIFFUSETEXTURE3", function() {
                    return this.DIFFUSETEXTURE3 = Vt.propertyNameToID("u_DiffuseTexture3");
                }, "DIFFUSETEXTURE4", function() {
                    return this.DIFFUSETEXTURE4 = Vt.propertyNameToID("u_DiffuseTexture4");
                }, "DIFFUSETEXTURE5", function() {
                    return this.DIFFUSETEXTURE5 = Vt.propertyNameToID("u_DiffuseTexture5");
                }, "DIFFUSESCALEOFFSET1", function() {
                    return this.DIFFUSESCALEOFFSET1 = Vt.propertyNameToID("u_DiffuseScaleOffset1");
                }, "DIFFUSESCALEOFFSET2", function() {
                    return this.DIFFUSESCALEOFFSET2 = Vt.propertyNameToID("u_DiffuseScaleOffset2");
                }, "DIFFUSESCALEOFFSET3", function() {
                    return this.DIFFUSESCALEOFFSET3 = Vt.propertyNameToID("u_DiffuseScaleOffset3");
                }, "DIFFUSESCALEOFFSET4", function() {
                    return this.DIFFUSESCALEOFFSET4 = Vt.propertyNameToID("u_DiffuseScaleOffset4");
                }, "DIFFUSESCALEOFFSET5", function() {
                    return this.DIFFUSESCALEOFFSET5 = Vt.propertyNameToID("u_DiffuseScaleOffset5");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), e;
        }(),
        ei = function(n) {
            function i() {
                this._enableVertexColor = !1, i.__super.call(this), this.setShaderName("BLINNPHONG"),
                    this._albedoIntensity = 1, this._albedoColor = new At(1, 1, 1, 1);
                var t = this._shaderValues;
                t.setVector(i.ALBEDOCOLOR, new At(1, 1, 1, 1)), t.setVector(i.MATERIALSPECULAR, new At(1, 1, 1, 1)),
                    t.setNumber(i.SHININESS, .078125), t.setNumber(Cn.ALPHATESTVALUE, .5), t.setVector(i.TILINGOFFSET, new At(1, 1, 0, 0)),
                    this._enableLighting = !0, this.renderMode = 0;
            }
            d(i, "laya.d3.core.material.BlinnPhongMaterial", n);
            var t = i.prototype;
            return t.disableFog = function() {
                    this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_FOG);
                }, t.cloneTo = function(t) {
                    n.prototype.cloneTo.call(this, t);
                    var e = t;
                    e._enableLighting = this._enableLighting, e._albedoIntensity = this._albedoIntensity,
                        e._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(e._albedoColor);
                }, u(0, t, "_SpecColorG", function() {
                    return this._shaderValues.getVector(i.MATERIALSPECULAR).y;
                }, function(t) {
                    this._shaderValues.getVector(i.MATERIALSPECULAR).y = t;
                }), u(0, t, "_ColorB", function() {
                    return this._albedoColor.z;
                }, function(t) {
                    this._albedoColor.z = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_ColorR", function() {
                    return this._albedoColor.x;
                }, function(t) {
                    this._albedoColor.x = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "albedoColorA", function() {
                    return this._ColorA;
                }, function(t) {
                    this._ColorA = t;
                }), u(0, t, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, t, "_SpecColorB", function() {
                    return this._shaderValues.getVector(i.MATERIALSPECULAR).z;
                }, function(t) {
                    this._shaderValues.getVector(i.MATERIALSPECULAR).z = t;
                }), u(0, t, "renderMode", null, function(t) {
                    switch (t) {
                        case 0:
                            this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513;
                            break;

                        case 1:
                            this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513;
                            break;

                        case 2:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513;
                            break;

                        default:
                            throw new Error("Material:renderMode value error.");
                    }
                }), u(0, t, "_SpecColorR", function() {
                    return this._shaderValues.getVector(i.MATERIALSPECULAR).x;
                }, function(t) {
                    this._shaderValues.getVector(i.MATERIALSPECULAR).x = t;
                }), u(0, t, "_ColorG", function() {
                    return this._albedoColor.y;
                }, function(t) {
                    this._albedoColor.y = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_ColorA", function() {
                    return this._albedoColor.w;
                }, function(t) {
                    this._albedoColor.w = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "specularColor", function() {
                    return this._shaderValues.getVector(i.MATERIALSPECULAR);
                }, function(t) {
                    this._shaderValues.setVector(i.MATERIALSPECULAR, t);
                }), u(0, t, "albedoColorB", function() {
                    return this._ColorB;
                }, function(t) {
                    this._ColorB = t;
                }), u(0, t, "_SpecColorA", function() {
                    return this._shaderValues.getVector(i.MATERIALSPECULAR).w;
                }, function(t) {
                    this._shaderValues.getVector(i.MATERIALSPECULAR).w = t;
                }), u(0, t, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, t, "_AlbedoIntensity", function() {
                    return this._albedoIntensity;
                }, function(t) {
                    if (this._albedoIntensity !== t) {
                        var e = this._shaderValues.getVector(i.ALBEDOCOLOR);
                        At.scale(this._albedoColor, t, e), this._albedoIntensity = t, this._shaderValues.setVector(i.ALBEDOCOLOR, e);
                    }
                }), u(0, t, "specularColorA", function() {
                    return this._SpecColorA;
                }, function(t) {
                    this._SpecColorA = t;
                }), u(0, t, "_Shininess", function() {
                    return this._shaderValues.getNumber(i.SHININESS);
                }, function(t) {
                    t = Math.max(0, Math.min(1, t)), this._shaderValues.setNumber(i.SHININESS, t);
                }), u(0, t, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, t, "_Cutoff", function() {
                    return this.alphaTestValue;
                }, function(t) {
                    this.alphaTestValue = t;
                }), u(0, t, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, t, "albedoTexture", function() {
                    return this._shaderValues.getTexture(i.ALBEDOTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP),
                        this._shaderValues.setTexture(i.ALBEDOTEXTURE, t);
                }), u(0, t, "enableVertexColor", function() {
                    return this._enableVertexColor;
                }, function(t) {
                    (this._enableVertexColor = t) ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR): this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
                }), u(0, t, "albedoColor", function() {
                    return this._albedoColor;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.ALBEDOCOLOR);
                    At.scale(t, this._albedoIntensity, e), this._albedoColor = t, this._shaderValues.setVector(i.ALBEDOCOLOR, e);
                }), u(0, t, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, t, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, t, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, t, "blendSrc", function() {
                    return this._shaderValues.getInt(i.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_SRC, t);
                }), u(0, t, "enableLighting", function() {
                    return this._enableLighting;
                }, function(t) {
                    this._enableLighting !== t && (t ? this._disablePublicDefineDatas.remove(Gn.SHADERDEFINE_POINTLIGHT | Gn.SHADERDEFINE_SPOTLIGHT | Gn.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_POINTLIGHT | Gn.SHADERDEFINE_SPOTLIGHT | Gn.SHADERDEFINE_DIRECTIONLIGHT),
                        this._enableLighting = t);
                }), u(0, t, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, t, "tilingOffset", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(i.TILINGOFFSET, t);
                }), u(0, t, "albedoColorR", function() {
                    return this._ColorR;
                }, function(t) {
                    this._ColorR = t;
                }), u(0, t, "albedoColorG", function() {
                    return this._ColorG;
                }, function(t) {
                    this._ColorG = t;
                }), u(0, t, "albedoIntensity", function() {
                    return this._albedoIntensity;
                }, function(t) {
                    this._AlbedoIntensity = t;
                }), u(0, t, "specularColorR", function() {
                    return this._SpecColorR;
                }, function(t) {
                    this._SpecColorR = t;
                }), u(0, t, "specularColorG", function() {
                    return this._SpecColorG;
                }, function(t) {
                    this._SpecColorG = t;
                }), u(0, t, "specularColorB", function() {
                    return this._SpecColorB;
                }, function(t) {
                    this._SpecColorB = t;
                }), u(0, t, "blendDst", function() {
                    return this._shaderValues.getInt(i.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_DST, t);
                }), u(0, t, "shininess", function() {
                    return this._Shininess;
                }, function(t) {
                    this._Shininess = t;
                }), u(0, t, "cull", function() {
                    return this._shaderValues.getInt(i.CULL);
                }, function(t) {
                    this._shaderValues.setInt(i.CULL, t);
                }), u(0, t, "normalTexture", function() {
                    return this._shaderValues.getTexture(i.NORMALTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP),
                        this._shaderValues.setTexture(i.NORMALTEXTURE, t);
                }), u(0, t, "specularTexture", function() {
                    return this._shaderValues.getTexture(i.SPECULARTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP),
                        this._shaderValues.setTexture(i.SPECULARTEXTURE, t);
                }), u(0, t, "depthWrite", function() {
                    return this._shaderValues.getBool(i.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(i.DEPTH_WRITE, t);
                }), u(0, t, "blend", function() {
                    return this._shaderValues.getInt(i.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND, t);
                }), u(0, t, "depthTest", function() {
                    return this._shaderValues.getInt(i.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(i.DEPTH_TEST, t);
                }), i.__init__ = function() {
                    i.SHADERDEFINE_DIFFUSEMAP = i.shaderDefines.registerDefine("DIFFUSEMAP"), i.SHADERDEFINE_NORMALMAP = i.shaderDefines.registerDefine("NORMALMAP"),
                        i.SHADERDEFINE_SPECULARMAP = i.shaderDefines.registerDefine("SPECULARMAP"), i.SHADERDEFINE_TILINGOFFSET = i.shaderDefines.registerDefine("TILINGOFFSET"),
                        i.SHADERDEFINE_ENABLEVERTEXCOLOR = i.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
                }, i.SPECULARSOURCE_DIFFUSEMAPALPHA = 0, i.SPECULARSOURCE_SPECULARMAP = 0, i.RENDERMODE_OPAQUE = 0,
                i.RENDERMODE_CUTOUT = 1, i.RENDERMODE_TRANSPARENT = 2, i.SHADERDEFINE_DIFFUSEMAP = 0,
                i.SHADERDEFINE_NORMALMAP = 0, i.SHADERDEFINE_SPECULARMAP = 0, i.SHADERDEFINE_TILINGOFFSET = 0,
                i.SHADERDEFINE_ENABLEVERTEXCOLOR = 0, _(i, ["ALBEDOTEXTURE", function() {
                    return this.ALBEDOTEXTURE = Vt.propertyNameToID("u_DiffuseTexture");
                }, "NORMALTEXTURE", function() {
                    return this.NORMALTEXTURE = Vt.propertyNameToID("u_NormalTexture");
                }, "SPECULARTEXTURE", function() {
                    return this.SPECULARTEXTURE = Vt.propertyNameToID("u_SpecularTexture");
                }, "ALBEDOCOLOR", function() {
                    return this.ALBEDOCOLOR = Vt.propertyNameToID("u_DiffuseColor");
                }, "MATERIALSPECULAR", function() {
                    return this.MATERIALSPECULAR = Vt.propertyNameToID("u_MaterialSpecular");
                }, "SHININESS", function() {
                    return this.SHININESS = Vt.propertyNameToID("u_Shininess");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new i();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), i;
        }(Cn),
        ni = function(e) {
            function n() {
                this._diffuseScale1 = null, this._diffuseScale2 = null, this._diffuseScale3 = null,
                    this._diffuseScale4 = null, n.__super.call(this), this.setShaderName("Terrain"),
                    this.renderMode = 1, this._diffuseScale1 = new Lt(), this._diffuseScale2 = new Lt(),
                    this._diffuseScale3 = new Lt(), this._diffuseScale4 = new Lt(), this.ambientColor = new Ct(.6, .6, .6),
                    this.diffuseColor = new Ct(1, 1, 1), this.specularColor = new At(.2, .2, .2, 32);
            }
            d(n, "laya.d3.core.material.TerrainMaterial", e);
            var t = n.prototype;
            return t.setDiffuseScale1 = function(t, e) {
                    this._diffuseScale1.x = t, this._diffuseScale1.y = e, this._shaderValues.setVector2(6, this._diffuseScale1);
                }, t.setDiffuseScale2 = function(t, e) {
                    this._diffuseScale2.x = t, this._diffuseScale2.y = e, this._shaderValues.setVector2(7, this._diffuseScale2);
                }, t.setDiffuseScale3 = function(t, e) {
                    this._diffuseScale3.x = t, this._diffuseScale3.y = e, this._shaderValues.setVector2(8, this._diffuseScale3);
                }, t.setDiffuseScale4 = function(t, e) {
                    this._diffuseScale4.x = t, this._diffuseScale4.y = e, this._shaderValues.setVector2(9, this._diffuseScale4);
                }, t.setDetailNum = function(t) {
                    switch (t) {
                        case 1:
                            this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                            break;

                        case 2:
                            this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                            break;

                        case 3:
                            this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                            break;

                        case 4:
                            this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    }
                }, t.disableLight = function() {
                    this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_POINTLIGHT | Gn.SHADERDEFINE_SPOTLIGHT | Gn.SHADERDEFINE_DIRECTIONLIGHT);
                }, t.setShaderName = function(t) {
                    e.prototype.setShaderName.call(this, t);
                }, u(0, t, "renderMode", null, function(t) {
                    switch (t) {
                        case 1:
                            this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, this.blend = 0, this.depthTest = 513;
                            break;

                        case 2:
                            this.renderQueue = 2e3, this.depthWrite = !1, this.cull = 2, this.blend = 1, this.blendSrc = 770,
                                this.blendDst = 771, this.depthTest = 515;
                            break;

                        default:
                            throw new Error("TerrainMaterial:renderMode value error.");
                    }
                }), u(0, t, "diffuseTexture2", function() {
                    return this._shaderValues.getTexture(3);
                }, function(t) {
                    this._shaderValues.setTexture(3, t);
                }), u(0, t, "ambientColor", function() {
                    return this._shaderValues.getVector(10);
                }, function(t) {
                    this._shaderValues.setVector3(10, t);
                }), u(0, t, "diffuseTexture4", function() {
                    return this._shaderValues.getTexture(5);
                }, function(t) {
                    this._shaderValues.setTexture(5, t);
                }), u(0, t, "diffuseColor", function() {
                    return this._shaderValues.getVector(11);
                }, function(t) {
                    this._shaderValues.setVector3(11, t);
                }), u(0, t, "diffuseTexture1", function() {
                    return this._shaderValues.getTexture(2);
                }, function(t) {
                    this._shaderValues.setTexture(2, t);
                }), u(0, t, "specularColor", function() {
                    return this._shaderValues.getVector(12);
                }, function(t) {
                    this._shaderValues.setVector(12, t);
                }), u(0, t, "diffuseTexture3", function() {
                    return this._shaderValues.getTexture(4);
                }, function(t) {
                    this._shaderValues.setTexture(4, t);
                }), u(0, t, "splatAlphaTexture", function() {
                    return this._shaderValues.getTexture(0);
                }, function(t) {
                    this._shaderValues.setTexture(0, t);
                }), u(0, t, "cull", function() {
                    return this._shaderValues.getInt(n.CULL);
                }, function(t) {
                    this._shaderValues.setInt(n.CULL, t);
                }), u(0, t, "normalTexture", function() {
                    return this._shaderValues.getTexture(1);
                }, function(t) {
                    this._shaderValues.setTexture(1, t);
                }), u(0, t, "depthWrite", function() {
                    return this._shaderValues.getBool(n.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(n.DEPTH_WRITE, t);
                }), u(0, t, "blend", function() {
                    return this._shaderValues.getInt(n.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND, t);
                }), u(0, t, "blendSrc", function() {
                    return this._shaderValues.getInt(n.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_SRC, t);
                }), u(0, t, "blendDst", function() {
                    return this._shaderValues.getInt(n.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(n.BLEND_DST, t);
                }), u(0, t, "depthTest", function() {
                    return this._shaderValues.getInt(n.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(n.DEPTH_TEST, t);
                }), n.__init__ = function() {
                    n.SHADERDEFINE_DETAIL_NUM1 = n.shaderDefines.registerDefine("DETAIL_NUM1"), n.SHADERDEFINE_DETAIL_NUM2 = n.shaderDefines.registerDefine("DETAIL_NUM2"),
                        n.SHADERDEFINE_DETAIL_NUM4 = n.shaderDefines.registerDefine("DETAIL_NUM4"), n.SHADERDEFINE_DETAIL_NUM3 = n.shaderDefines.registerDefine("DETAIL_NUM3");
                }, n.RENDERMODE_OPAQUE = 1, n.RENDERMODE_TRANSPARENT = 2, n.SPLATALPHATEXTURE = 0,
                n.NORMALTEXTURE = 1, n.DIFFUSETEXTURE1 = 2, n.DIFFUSETEXTURE2 = 3, n.DIFFUSETEXTURE3 = 4,
                n.DIFFUSETEXTURE4 = 5, n.DIFFUSESCALE1 = 6, n.DIFFUSESCALE2 = 7, n.DIFFUSESCALE3 = 8,
                n.DIFFUSESCALE4 = 9, n.MATERIALAMBIENT = 10, n.MATERIALDIFFUSE = 11, n.MATERIALSPECULAR = 12,
                n.SHADERDEFINE_DETAIL_NUM1 = 0, n.SHADERDEFINE_DETAIL_NUM2 = 0, n.SHADERDEFINE_DETAIL_NUM3 = 0,
                n.SHADERDEFINE_DETAIL_NUM4 = 0, _(n, ["CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new n();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), n;
        }(Cn),
        ii = function(t) {
            function e() {
                e.__super.call(this), this.setShaderName("SkyBox");
            }
            d(e, "laya.d3.core.material.SkyBoxMaterial", Cn);
            var n = e.prototype;
            return u(0, n, "tintColor", function() {
                return this._shaderValues.getVector(e.TINTCOLOR);
            }, function(t) {
                this._shaderValues.setVector(e.TINTCOLOR, t);
            }), u(0, n, "exposure", function() {
                return this._shaderValues.getNumber(e.EXPOSURE);
            }, function(t) {
                this._shaderValues.setNumber(e.EXPOSURE, t);
            }), u(0, n, "rotation", function() {
                return this._shaderValues.getNumber(e.ROTATION);
            }, function(t) {
                this._shaderValues.setNumber(e.ROTATION, t);
            }), u(0, n, "textureCube", function() {
                return this._shaderValues.getTexture(e.TEXTURECUBE);
            }, function(t) {
                return this._shaderValues.setTexture(e.TEXTURECUBE, t);
            }), _(e, ["TINTCOLOR", function() {
                return this.TINTCOLOR = Vt.propertyNameToID("u_TintColor");
            }, "EXPOSURE", function() {
                return this.EXPOSURE = Vt.propertyNameToID("u_Exposure");
            }, "ROTATION", function() {
                return this.ROTATION = Vt.propertyNameToID("u_Rotation");
            }, "TEXTURECUBE", function() {
                return this.TEXTURECUBE = Vt.propertyNameToID("u_CubeTexture");
            }, "defaultMaterial", function() {
                return this.defaultMaterial = new e();
            }]), e;
        }(),
        ri = function(n) {
            function i() {
                this._albedoColor = null, this._specularColor = null, this._emissionColor = null,
                    i.__super.call(this), this.setShaderName("PBRSpecular"), this._albedoColor = new At(1, 1, 1, 1),
                    this._shaderValues.setVector(i.ALBEDOCOLOR, new At(1, 1, 1, 1)), this._emissionColor = new At(0, 0, 0, 0),
                    this._shaderValues.setVector(i.EMISSIONCOLOR, new At(0, 0, 0, 0)), this._specularColor = new At(.2, .2, .2, .2),
                    this._shaderValues.setVector(i.SPECULARCOLOR, new At(.2, .2, .2, .2)), this._shaderValues.setNumber(i.SMOOTHNESS, .5),
                    this._shaderValues.setNumber(i.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(i.SMOOTHNESSSOURCE, 0),
                    this._shaderValues.setNumber(i.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(i.NORMALSCALE, 1),
                    this._shaderValues.setNumber(i.PARALLAXSCALE, .001), this._shaderValues.setBool(i.ENABLEEMISSION, !1),
                    this._shaderValues.setNumber(Cn.ALPHATESTVALUE, .5), this.renderMode = 0;
            }
            d(i, "laya.d3.core.material.PBRSpecularMaterial", n);
            var t = i.prototype;
            return t.cloneTo = function(t) {
                    n.prototype.cloneTo.call(this, t);
                    var e = t;
                    this._albedoColor.cloneTo(e._albedoColor), this._specularColor.cloneTo(e._specularColor),
                        this._emissionColor.cloneTo(e._emissionColor);
                }, u(0, t, "emissionTexture", function() {
                    return this._shaderValues.getTexture(i.EMISSIONTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE),
                        this._shaderValues.setTexture(i.EMISSIONTEXTURE, t);
                }), u(0, t, "_SpecColorG", function() {
                    return this._specularColor.y;
                }, function(t) {
                    this._specularColor.y = t, this.specularColor = this._specularColor;
                }), u(0, t, "_ColorB", function() {
                    return this._albedoColor.z;
                }, function(t) {
                    this._albedoColor.z = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_ColorR", function() {
                    return this._albedoColor.x;
                }, function(t) {
                    this._albedoColor.x = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "albedoColorA", function() {
                    return this._ColorA;
                }, function(t) {
                    this._ColorA = t;
                }), u(0, t, "_MainTex_STX", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).x;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.x = t, this.tilingOffset = e;
                }), u(0, t, "_SpecColorB", function() {
                    return this._specularColor.z;
                }, function(t) {
                    this._specularColor.z = t, this.specularColor = this._specularColor;
                }), u(0, t, "renderMode", null, function(t) {
                    switch (t) {
                        case 0:
                            this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 1:
                            this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2,
                                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 2:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513,
                                this._defineDatas.remove(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        case 3:
                            this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2,
                                this.blend = 1, this.blendSrc = 1, this.blendDst = 771, this.depthTest = 513, this._defineDatas.add(i.SHADERDEFINE_ALPHAPREMULTIPLY);
                            break;

                        default:
                            throw new Error("PBRSpecularMaterial : renderMode value error.");
                    }
                }), u(0, t, "_SpecColorR", function() {
                    return this._specularColor.x;
                }, function(t) {
                    this._specularColor.x = t, this.specularColor = this._specularColor;
                }), u(0, t, "_ColorG", function() {
                    return this._albedoColor.y;
                }, function(t) {
                    this._albedoColor.y = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "_Glossiness", function() {
                    return this._shaderValues.getNumber(i.SMOOTHNESS);
                }, function(t) {
                    this._shaderValues.setNumber(i.SMOOTHNESS, t);
                }), u(0, t, "_ColorA", function() {
                    return this._albedoColor.w;
                }, function(t) {
                    this._albedoColor.w = t, this.albedoColor = this._albedoColor;
                }), u(0, t, "specularColor", function() {
                    return this._shaderValues.getVector(i.SPECULARCOLOR);
                }, function(t) {
                    this._shaderValues.setVector(i.SPECULARCOLOR, t);
                }), u(0, t, "albedoColorB", function() {
                    return this._ColorB;
                }, function(t) {
                    this._ColorB = t;
                }), u(0, t, "_SpecColorA", function() {
                    return this._specularColor.w;
                }, function(t) {
                    this._specularColor.w = t, this.specularColor = this._specularColor;
                }), u(0, t, "_GlossMapScale", function() {
                    return this._shaderValues.getNumber(i.SMOOTHNESSSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.SMOOTHNESSSCALE, t);
                }), u(0, t, "_BumpScale", function() {
                    return this._shaderValues.getNumber(i.NORMALSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.NORMALSCALE, t);
                }), u(0, t, "_Parallax", function() {
                    return this._shaderValues.getNumber(i.PARALLAXSCALE);
                }, function(t) {
                    this._shaderValues.setNumber(i.PARALLAXSCALE, t);
                }), u(0, t, "_OcclusionStrength", function() {
                    return this._shaderValues.getNumber(i.OCCLUSIONSTRENGTH);
                }, function(t) {
                    this._shaderValues.setNumber(i.OCCLUSIONSTRENGTH, t);
                }), u(0, t, "_EmissionColorR", function() {
                    return this._emissionColor.x;
                }, function(t) {
                    this._emissionColor.x = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "tilingOffset", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET);
                }, function(t) {
                    t && (1 != t.x || 1 != t.y || 0 != t.z || 0 != t.w) ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET),
                        this._shaderValues.setVector(i.TILINGOFFSET, t);
                }), u(0, t, "_EmissionColorG", function() {
                    return this._emissionColor.y;
                }, function(t) {
                    this._emissionColor.y = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "blendSrc", function() {
                    return this._shaderValues.getInt(i.BLEND_SRC);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_SRC, t);
                }), u(0, t, "tilingOffsetW", function() {
                    return this._MainTex_STW;
                }, function(t) {
                    this._MainTex_STW = t;
                }), u(0, t, "_EmissionColorB", function() {
                    return this._emissionColor.z;
                }, function(t) {
                    this._emissionColor.z = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "_EmissionColorA", function() {
                    return this._emissionColor.w;
                }, function(t) {
                    this._emissionColor.w = t, this.emissionColor = this._emissionColor;
                }), u(0, t, "_MainTex_STY", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).y;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.y = t, this.tilingOffset = e;
                }), u(0, t, "_MainTex_STZ", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).z;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.z = t, this.tilingOffset = e;
                }), u(0, t, "_Cutoff", function() {
                    return this.alphaTestValue;
                }, function(t) {
                    this.alphaTestValue = t;
                }), u(0, t, "_MainTex_STW", function() {
                    return this._shaderValues.getVector(i.TILINGOFFSET).w;
                }, function(t) {
                    var e = this._shaderValues.getVector(i.TILINGOFFSET);
                    e.w = t, this.tilingOffset = e;
                }), u(0, t, "albedoColorR", function() {
                    return this._ColorR;
                }, function(t) {
                    this._ColorR = t;
                }), u(0, t, "albedoColorG", function() {
                    return this._ColorG;
                }, function(t) {
                    this._ColorG = t;
                }), u(0, t, "tilingOffsetX", function() {
                    return this._MainTex_STX;
                }, function(t) {
                    this._MainTex_STX = t;
                }), u(0, t, "albedoColor", function() {
                    return this._albedoColor;
                }, function(t) {
                    this._albedoColor = t, this._shaderValues.setVector(i.ALBEDOCOLOR, t);
                }), u(0, t, "albedoTexture", function() {
                    return this._shaderValues.getTexture(i.ALBEDOTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                        this._shaderValues.setTexture(i.ALBEDOTEXTURE, t);
                }), u(0, t, "cull", function() {
                    return this._shaderValues.getInt(i.CULL);
                }, function(t) {
                    this._shaderValues.setInt(i.CULL, t);
                }), u(0, t, "parallaxTexture", function() {
                    return this._shaderValues.getTexture(i.PARALLAXTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE),
                        this._shaderValues.setTexture(i.PARALLAXTEXTURE, t);
                }), u(0, t, "normalTexture", function() {
                    return this._shaderValues.getTexture(i.NORMALTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE),
                        this._shaderValues.setTexture(i.NORMALTEXTURE, t);
                }), u(0, t, "emissionColor", function() {
                    return this._shaderValues.getVector(i.EMISSIONCOLOR);
                }, function(t) {
                    this._shaderValues.setVector(i.EMISSIONCOLOR, t);
                }), u(0, t, "parallaxTextureScale", function() {
                    return this._Parallax;
                }, function(t) {
                    this._Parallax = Math.max(.005, Math.min(.08, t));
                }), u(0, t, "normalTextureScale", function() {
                    return this._BumpScale;
                }, function(t) {
                    this._BumpScale = t;
                }), u(0, t, "tilingOffsetZ", function() {
                    return this._MainTex_STZ;
                }, function(t) {
                    this._MainTex_STZ = t;
                }), u(0, t, "occlusionTexture", function() {
                    return this._shaderValues.getTexture(i.OCCLUSIONTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE),
                        this._shaderValues.setTexture(i.OCCLUSIONTEXTURE, t);
                }), u(0, t, "occlusionTextureStrength", function() {
                    return this._OcclusionStrength;
                }, function(t) {
                    this._OcclusionStrength = Math.max(0, Math.min(1, t));
                }), u(0, t, "specularTexture", function() {
                    return this._shaderValues.getTexture(i.SPECULARTEXTURE);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE),
                        this._shaderValues.setTexture(i.SPECULARTEXTURE, t);
                }), u(0, t, "specularColorR", function() {
                    return this._SpecColorR;
                }, function(t) {
                    this._SpecColorR = t;
                }), u(0, t, "smoothness", function() {
                    return this._Glossiness;
                }, function(t) {
                    this._Glossiness = Math.max(0, Math.min(1, t));
                }), u(0, t, "specularColorG", function() {
                    return this._SpecColorG;
                }, function(t) {
                    this._SpecColorG = t;
                }), u(0, t, "specularColorB", function() {
                    return this._SpecColorB;
                }, function(t) {
                    this._SpecColorB = t;
                }), u(0, t, "specularColorA", function() {
                    return this._SpecColorA;
                }, function(t) {
                    this._SpecColorA = t;
                }), u(0, t, "blendDst", function() {
                    return this._shaderValues.getInt(i.BLEND_DST);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND_DST, t);
                }), u(0, t, "smoothnessTextureScale", function() {
                    return this._GlossMapScale;
                }, function(t) {
                    this._GlossMapScale = Math.max(0, Math.min(1, t));
                }), u(0, t, "depthWrite", function() {
                    return this._shaderValues.getBool(i.DEPTH_WRITE);
                }, function(t) {
                    this._shaderValues.setBool(i.DEPTH_WRITE, t);
                }), u(0, t, "smoothnessSource", function() {
                    return this._shaderValues.getInt(i.SMOOTHNESSSOURCE);
                }, function(t) {
                    t ? (this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                        this._shaderValues.setInt(i.SMOOTHNESSSOURCE, 1)) : (this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                        this._shaderValues.setInt(i.SMOOTHNESSSOURCE, 0));
                }), u(0, t, "enableEmission", function() {
                    return this._shaderValues.getBool(i.ENABLEEMISSION);
                }, function(t) {
                    t ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION),
                        this._shaderValues.setBool(i.ENABLEEMISSION, t);
                }), u(0, t, "enableReflection", function() {
                    return this._shaderValues.getBool(i.ENABLEREFLECT);
                }, function(t) {
                    this._shaderValues.setBool(i.ENABLEREFLECT, !0), t ? this._disablePublicDefineDatas.remove(Gn.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(Gn.SHADERDEFINE_REFLECTMAP);
                }), u(0, t, "tilingOffsetY", function() {
                    return this._MainTex_STY;
                }, function(t) {
                    this._MainTex_STY = t;
                }), u(0, t, "blend", function() {
                    return this._shaderValues.getInt(i.BLEND);
                }, function(t) {
                    this._shaderValues.setInt(i.BLEND, t);
                }), u(0, t, "depthTest", function() {
                    return this._shaderValues.getInt(i.DEPTH_TEST);
                }, function(t) {
                    this._shaderValues.setInt(i.DEPTH_TEST, t);
                }), i.__init__ = function() {
                    i.SHADERDEFINE_ALBEDOTEXTURE = i.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                        i.SHADERDEFINE_SPECULARTEXTURE = i.shaderDefines.registerDefine("SPECULARTEXTURE"),
                        i.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = i.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"),
                        i.SHADERDEFINE_NORMALTEXTURE = i.shaderDefines.registerDefine("NORMALTEXTURE"),
                        i.SHADERDEFINE_PARALLAXTEXTURE = i.shaderDefines.registerDefine("PARALLAXTEXTURE"),
                        i.SHADERDEFINE_OCCLUSIONTEXTURE = i.shaderDefines.registerDefine("OCCLUSIONTEXTURE"),
                        i.SHADERDEFINE_EMISSION = i.shaderDefines.registerDefine("EMISSION"), i.SHADERDEFINE_EMISSIONTEXTURE = i.shaderDefines.registerDefine("EMISSIONTEXTURE"),
                        i.SHADERDEFINE_TILINGOFFSET = i.shaderDefines.registerDefine("TILINGOFFSET"), i.SHADERDEFINE_ALPHAPREMULTIPLY = i.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
                }, i.SmoothnessSource_SpecularTexture_Alpha = 0, i.SmoothnessSource_AlbedoTexture_Alpha = 1,
                i.RENDERMODE_OPAQUE = 0, i.RENDERMODE_CUTOUT = 1, i.RENDERMODE_FADE = 2, i.RENDERMODE_TRANSPARENT = 3,
                i.SHADERDEFINE_ALBEDOTEXTURE = 0, i.SHADERDEFINE_NORMALTEXTURE = 0, i.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = 0,
                i.SHADERDEFINE_SPECULARTEXTURE = 0, i.SHADERDEFINE_OCCLUSIONTEXTURE = 0, i.SHADERDEFINE_PARALLAXTEXTURE = 0,
                i.SHADERDEFINE_EMISSION = 0, i.SHADERDEFINE_EMISSIONTEXTURE = 0, i.SHADERDEFINE_TILINGOFFSET = 0,
                i.SHADERDEFINE_ALPHAPREMULTIPLY = 0, i.SMOOTHNESSSOURCE = -1, i.ENABLEEMISSION = -1,
                i.ENABLEREFLECT = -1, _(i, ["ALBEDOTEXTURE", function() {
                    return this.ALBEDOTEXTURE = Vt.propertyNameToID("u_AlbedoTexture");
                }, "SPECULARTEXTURE", function() {
                    return this.SPECULARTEXTURE = Vt.propertyNameToID("u_SpecularTexture");
                }, "NORMALTEXTURE", function() {
                    return this.NORMALTEXTURE = Vt.propertyNameToID("u_NormalTexture");
                }, "PARALLAXTEXTURE", function() {
                    return this.PARALLAXTEXTURE = Vt.propertyNameToID("u_ParallaxTexture");
                }, "OCCLUSIONTEXTURE", function() {
                    return this.OCCLUSIONTEXTURE = Vt.propertyNameToID("u_OcclusionTexture");
                }, "EMISSIONTEXTURE", function() {
                    return this.EMISSIONTEXTURE = Vt.propertyNameToID("u_EmissionTexture");
                }, "ALBEDOCOLOR", function() {
                    return this.ALBEDOCOLOR = Vt.propertyNameToID("u_AlbedoColor");
                }, "SPECULARCOLOR", function() {
                    return this.SPECULARCOLOR = Vt.propertyNameToID("u_SpecularColor");
                }, "EMISSIONCOLOR", function() {
                    return this.EMISSIONCOLOR = Vt.propertyNameToID("u_EmissionColor");
                }, "SMOOTHNESS", function() {
                    return this.SMOOTHNESS = Vt.propertyNameToID("u_smoothness");
                }, "SMOOTHNESSSCALE", function() {
                    return this.SMOOTHNESSSCALE = Vt.propertyNameToID("u_smoothnessScale");
                }, "OCCLUSIONSTRENGTH", function() {
                    return this.OCCLUSIONSTRENGTH = Vt.propertyNameToID("u_occlusionStrength");
                }, "NORMALSCALE", function() {
                    return this.NORMALSCALE = Vt.propertyNameToID("u_normalScale");
                }, "PARALLAXSCALE", function() {
                    return this.PARALLAXSCALE = Vt.propertyNameToID("u_parallaxScale");
                }, "TILINGOFFSET", function() {
                    return this.TILINGOFFSET = Vt.propertyNameToID("u_TilingOffset");
                }, "CULL", function() {
                    return this.CULL = Vt.propertyNameToID("s_Cull");
                }, "BLEND", function() {
                    return this.BLEND = Vt.propertyNameToID("s_Blend");
                }, "BLEND_SRC", function() {
                    return this.BLEND_SRC = Vt.propertyNameToID("s_BlendSrc");
                }, "BLEND_DST", function() {
                    return this.BLEND_DST = Vt.propertyNameToID("s_BlendDst");
                }, "DEPTH_TEST", function() {
                    return this.DEPTH_TEST = Vt.propertyNameToID("s_DepthTest");
                }, "DEPTH_WRITE", function() {
                    return this.DEPTH_WRITE = Vt.propertyNameToID("s_DepthWrite");
                }, "defaultMaterial", function() {
                    return this.defaultMaterial = new i();
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Cn.shaderDefines);
                }]), i;
        }(Cn),
        ai = (function(r) {
            function a(t, e) {
                this._isKinematic = !1, this._mass = 1, this._angularDamping = 0, this._linearDamping = 0,
                    this._overrideGravity = !1, this._detectCollisions = !0, this._gravity = new Ct(0, -10, 0),
                    this._totalTorque = new Ct(0, 0, 0), this._linearVelocity = new Ct(), this._angularVelocity = new Ct(),
                    this._linearFactor = new Ct(1, 1, 1), this._angularFactor = new Ct(1, 1, 1), void 0 === t && (t = 1),
                    void 0 === e && (e = Ve.COLLISIONFILTERGROUP_ALLFILTER), a.__super.call(this, t, e);
            }
            d(a, "laya.d3.physics.Rigidbody3D", r);
            var t = a.prototype;
            t._updateMass = function(t) {
                    this._nativeColliderObject && this._colliderShape && (this._colliderShape._nativeShape.calculateLocalInertia(t, a._nativeInertia),
                        this._nativeColliderObject.setMassProps(t, a._nativeInertia), this._nativeColliderObject.updateInertiaTensor());
                }, t._delegateMotionStateGetWorldTransform = function(t) {}, t._delegateMotionStateSetWorldTransform = function(t) {
                    var e = this._rigidbody;
                    e._simulation._updatedRigidbodies++;
                    var n = k._physics3D,
                        i = n.wrapPointer(t, n.btTransform);
                    e._updateTransformComponent(i);
                }, t._delegateMotionStateGetWorldTransformNative = function(t, e) {}, t._delegateMotionStateSetWorldTransformNative = function(t, e) {
                    var n = t;
                    n._simulation._updatedRigidbodies++;
                    var i = k._physics3D,
                        r = i.wrapPointer(e, i.btTransform);
                    n._updateTransformComponent(r);
                }, t._onScaleChange = function(t) {
                    laya.d3.physics.PhysicsComponent.prototype._onScaleChange.call(this, t), this._updateMass(this._isKinematic ? 0 : this._mass);
                }, t._delegateMotionStateClear = function() {
                    this._rigidbody = null;
                }, t._onAdded = function() {
                    var t = k._physics3D,
                        e = new t.LayaMotionState();
                    null != o.conch && t.LayaMotionState.prototype.setRigidbody ? (e.setRigidbody(this),
                            e.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative),
                            e.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative)) : (e.getWorldTransform = this._delegateMotionStateGetWorldTransform,
                            e.setWorldTransform = this._delegateMotionStateSetWorldTransform), e.clear = this._delegateMotionStateClear,
                        (e._rigidbody = this)._nativeMotionState = e;
                    var n = new t.btRigidBodyConstructionInfo(0, e, null, a._nativeVector3Zero),
                        i = new t.btRigidBody(n);
                    i.setUserIndex(this.id), this._nativeColliderObject = i, r.prototype._onAdded.call(this),
                        this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor,
                        this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping,
                        this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic,
                        t.destroy(n);
                }, t._onShapeChange = function(t) {
                    laya.d3.physics.PhysicsComponent.prototype._onShapeChange.call(this, t), this._isKinematic ? this._updateMass(0) : (this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform()),
                        this._updateMass(this._mass));
                }, t._parse = function(t) {
                    null != t.friction && (this.friction = t.friction), null != t.rollingFriction && (this.rollingFriction = t.rollingFriction),
                        null != t.restitution && (this.restitution = t.restitution), null != t.isTrigger && (this.isTrigger = t.isTrigger),
                        null != t.mass && (this.mass = t.mass), null != t.isKinematic && (this.isKinematic = t.isKinematic),
                        null != t.linearDamping && (this.linearDamping = t.linearDamping), null != t.angularDamping && (this.angularDamping = t.angularDamping),
                        null != t.overrideGravity && (this.overrideGravity = t.overrideGravity), t.gravity && (this.gravity.fromArray(t.gravity),
                            this.gravity = this.gravity), laya.d3.physics.PhysicsComponent.prototype._parse.call(this, t),
                        this._parseShape(t.shapes);
                }, t._onDestroy = function() {
                    var t = k._physics3D;
                    this._nativeMotionState.clear(), t.destroy(this._nativeMotionState), laya.d3.physics.PhysicsComponent.prototype._onDestroy.call(this),
                        this._nativeMotionState = null, this._gravity = null, this._totalTorque = null,
                        this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null,
                        this._angularFactor = null;
                }, t._addToSimulation = function() {
                    this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
                }, t._removeFromSimulation = function() {
                    this._simulation._removeRigidBody(this);
                }, t._cloneTo = function(t) {
                    r.prototype._cloneTo.call(this, t);
                    var e = t;
                    e.isKinematic = this._isKinematic, e.mass = this._mass, e.gravity = this._gravity,
                        e.angularDamping = this._angularDamping, e.linearDamping = this._linearDamping,
                        e.overrideGravity = this._overrideGravity, e.linearVelocity = this._linearVelocity,
                        e.angularVelocity = this._angularVelocity, e.linearFactor = this._linearFactor,
                        e.angularFactor = this._angularFactor, e.detectCollisions = this._detectCollisions;
                }, t.applyForce = function(t, e) {
                    if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var n = a._nativeTempVector30;
                    if (n.setValue(-t.x, t.y, t.z), e) {
                        var i = a._nativeTempVector31;
                        i.setValue(-e.x, e.y, e.z), this._nativeColliderObject.applyForce(n, i);
                    } else this._nativeColliderObject.applyCentralForce(n);
                }, t.applyTorque = function(t) {
                    if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var e = a._nativeTempVector30;
                    e.setValue(-t.x, t.y, t.z), this._nativeColliderObject.applyTorque(e);
                }, t.applyImpulse = function(t, e) {
                    if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    a._nativeImpulse.setValue(-t.x, t.y, t.z), e ? (a._nativeImpulseOffset.setValue(-e.x, e.y, e.z),
                        this._nativeColliderObject.applyImpulse(a._nativeImpulse, a._nativeImpulseOffset)) : this._nativeColliderObject.applyCentralImpulse(a._nativeImpulse);
                }, t.applyTorqueImpulse = function(t) {
                    if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var e = a._nativeTempVector30;
                    e.setValue(-t.x, t.y, t.z), this._nativeColliderObject.applyTorqueImpulse(e);
                }, t.wakeUp = function() {
                    this._nativeColliderObject && this._nativeColliderObject.activate(!1);
                }, t.clearForces = function() {
                    var t = this._nativeColliderObject;
                    if (null == t) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    t.clearForces();
                    var e = a._nativeVector3Zero;
                    t.setInterpolationAngularVelocity(e), t.setLinearVelocity(e), t.setInterpolationAngularVelocity(e),
                        t.setAngularVelocity(e);
                }, u(0, t, "angularDamping", function() {
                    return this._angularDamping;
                }, function(t) {
                    this._angularDamping = t, this._nativeColliderObject && this._nativeColliderObject.setDamping(this._linearDamping, t);
                }), u(0, t, "mass", function() {
                    return this._mass;
                }, function(t) {
                    t = Math.max(t, 1e-7), this._mass = t, this._isKinematic || this._updateMass(t);
                }), u(0, t, "linearDamping", function() {
                    return this._linearDamping;
                }, function(t) {
                    this._linearDamping = t, this._nativeColliderObject && this._nativeColliderObject.setDamping(t, this._angularDamping);
                }), u(0, t, "isKinematic", function() {
                    return this._isKinematic;
                }, function(t) {
                    this._isKinematic = t;
                    var e = !!(this._simulation && this._enabled && this._colliderShape);
                    e && this._removeFromSimulation();
                    var n = this._nativeColliderObject,
                        i = n.getCollisionFlags();
                    t ? (i |= 2, n.setCollisionFlags(i), this._nativeColliderObject.forceActivationState(4),
                        this._enableProcessCollisions = !1, this._updateMass(0)) : (0 < (2 & i) && (i ^= 2),
                        n.setCollisionFlags(i), this._nativeColliderObject.setActivationState(1), this._enableProcessCollisions = !0,
                        this._updateMass(this._mass));
                    var r = a._nativeVector3Zero;
                    n.setInterpolationLinearVelocity(r), n.setLinearVelocity(r), n.setInterpolationAngularVelocity(r),
                        n.setAngularVelocity(r), e && this._addToSimulation();
                }), u(0, t, "gravity", function() {
                    return this._gravity;
                }, function(t) {
                    this._gravity = t, a._nativeGravity.setValue(-t.x, t.y, t.z), this._nativeColliderObject.setGravity(a._nativeGravity);
                }), u(0, t, "overrideGravity", function() {
                    return this._overrideGravity;
                }, function(t) {
                    if (this._overrideGravity = t, this._nativeColliderObject) {
                        var e = this._nativeColliderObject.getFlags();
                        t ? 0 == (1 & e) && this._nativeColliderObject.setFlags(1 | e) : 0 < (1 & e) && this._nativeColliderObject.setFlags(1 ^ e);
                    }
                }), u(0, t, "totalForce", function() {
                    return this._nativeColliderObject ? this._nativeColliderObject.getTotalForce() : null;
                }), u(0, t, "linearVelocity", function() {
                    return this._nativeColliderObject && Gt._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(), this._linearVelocity, !0),
                        this._linearVelocity;
                }, function(t) {
                    if (this._linearVelocity = t, this._nativeColliderObject) {
                        var e = a._nativeTempVector30;
                        Gt._convertToBulletVec3(t, e, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setLinearVelocity(e);
                    }
                }), u(0, t, "detectCollisions", function() {
                    return this._detectCollisions;
                }, function(t) {
                    this._detectCollisions !== t && (this._detectCollisions = t, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this),
                        this._simulation._addRigidBody(this, this._collisionGroup, t ? this._canCollideWith : 0)));
                }), u(0, t, "linearFactor", function() {
                    return this._nativeColliderObject ? this._linearFactor : null;
                }, function(t) {
                    if (this._linearFactor = t, this._nativeColliderObject) {
                        var e = a._nativeTempVector30;
                        Gt._convertToBulletVec3(t, e, !1), this._nativeColliderObject.setLinearFactor(e);
                    }
                }), u(0, t, "angularFactor", function() {
                    return this._nativeColliderObject ? this._angularFactor : null;
                }, function(t) {
                    if (this._angularFactor = t, this._nativeColliderObject) {
                        var e = a._nativeTempVector30;
                        Gt._convertToBulletVec3(t, e, !1), this._nativeColliderObject.setAngularFactor(e);
                    }
                }), u(0, t, "angularVelocity", function() {
                    return this._nativeColliderObject && Gt._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(), this._angularVelocity, !0),
                        this._angularVelocity;
                }, function(t) {
                    if (this._angularVelocity = t, this._nativeColliderObject) {
                        var e = a._nativeTempVector30;
                        Gt._convertToBulletVec3(t, e, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setAngularVelocity(e);
                    }
                }), u(0, t, "totalTorque", function() {
                    if (this._nativeColliderObject) {
                        var t = this._nativeColliderObject.getTotalTorque(),
                            e = this._totalTorque;
                        e.x = -t.x, e.y = t.y, e.z = t.z;
                    }
                    return null;
                }), u(0, t, "isSleeping", function() {
                    return !!this._nativeColliderObject && 2 === this._nativeColliderObject.getActivationState();
                }), u(0, t, "sleepLinearVelocity", function() {
                    return this._nativeColliderObject.getLinearSleepingThreshold();
                }, function(t) {
                    this._nativeColliderObject.setSleepingThresholds(t, this._nativeColliderObject.getAngularSleepingThreshold());
                }), u(0, t, "sleepAngularVelocity", function() {
                    return this._nativeColliderObject.getAngularSleepingThreshold();
                }, function(t) {
                    this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(), t);
                }), a.TYPE_STATIC = 0, a.TYPE_DYNAMIC = 1, a.TYPE_KINEMATIC = 2, a._BT_DISABLE_WORLD_GRAVITY = 1,
                a._BT_ENABLE_GYROPSCOPIC_FORCE = 2, _(a, ["_nativeTempVector30", function() {
                    return this._nativeTempVector30 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeTempVector31", function() {
                    return this._nativeTempVector31 = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeVector3Zero", function() {
                    return this._nativeVector3Zero = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeInertia", function() {
                    return this._nativeInertia = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeImpulse", function() {
                    return this._nativeImpulse = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeImpulseOffset", function() {
                    return this._nativeImpulseOffset = new k._physics3D.btVector3(0, 0, 0);
                }, "_nativeGravity", function() {
                    return this._nativeGravity = new k._physics3D.btVector3(0, 0, 0);
                }]);
        }(bn), function(n) {
            function i(t, e) {
                void 0 === t && (t = 1), void 0 === e && (e = Ve.COLLISIONFILTERGROUP_ALLFILTER),
                    i.__super.call(this, t, e);
            }
            d(i, "laya.d3.physics.PhysicsCollider", n);
            var t = i.prototype;
            t._addToSimulation = function() {
                this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
            }, t._removeFromSimulation = function() {
                this._simulation._removePhysicsCollider(this);
            }, t._onTransformChanged = function(t) {
                (t &= 56) && (this._transformFlag |= t, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
            }, t._parse = function(t) {
                null != t.friction && (this.friction = t.friction), null != t.rollingFriction && (this.rollingFriction = t.rollingFriction),
                    null != t.restitution && (this.restitution = t.restitution), null != t.isTrigger && (this.isTrigger = t.isTrigger),
                    laya.d3.physics.PhysicsComponent.prototype._parse.call(this, t), this._parseShape(t.shapes);
            }, t._onAdded = function() {
                var t = new k._physics3D.btCollisionObject();
                t.setUserIndex(this.id), t.forceActivationState(5);
                var e = t.getCollisionFlags();
                this.owner.isStatic ? (0 < (2 & e) && (e ^= 2), e |= 1) : (0 < (1 & e) && (e ^= 1),
                    e |= 2), t.setCollisionFlags(e), this._nativeColliderObject = t, n.prototype._onAdded.call(this);
            };
        }(bn), function(s) {
            function a(t) {
                a.__super.call(this, t), this._skinnedDataLoopMarks = [], this._cacheAnimationNode = [];
            }
            d(a, "laya.d3.core.SkinnedMeshRenderer", s);
            var t = a.prototype;
            return t._getCacheAnimationNodes = function() {
                var t = this._cacheMesh._boneNames,
                    e = this._cacheMesh._bindPoseIndices,
                    n = e.length;
                if (b.supportWebGLPlusAnimation) {
                    this._cacheAnimationNodeIndices = new Uint16Array(n);
                    var i = this._cacheAnimator._avatarNodeMap;
                    for (o = 0; o < n; o++) {
                        var r = i[t[e[o]]];
                        this._cacheAnimationNodeIndices[o] = r._worldMatrixIndex;
                    }
                } else {
                    this._cacheAnimationNode.length = n;
                    for (var a = this._cacheAnimator._avatarNodeMap, o = 0; o < n; o++) {
                        var s = a[t[e[o]]];
                        this._cacheAnimationNode[o] = s;
                    }
                }
            }, t._computeBoneIndexToMeshWithAsyncAvatar = function() {
                this._computeBoneIndexToMeshWithAsyncMesh();
            }, t._computeBoneIndexToMeshWithAsyncMesh = function() {
                this._getCacheAnimationNodes();
            }, t._computeSkinnedData = function() {
                if (this._cacheMesh && this._cacheAvatar)
                    for (var t = this._cacheMesh._inverseBindPoses, e = this._cacheMesh._bindPoseIndices, n = this._cacheMesh._skinDataPathMarks, i = 0, r = this._cacheMesh.subMeshCount; i < r; i++)
                        for (var a = this._cacheMesh._getSubMesh(i)._boneIndicesList, o = this._skinnedData[i], s = 0, l = a.length; s < l; s++) {
                            var h = a[s];
                            b.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, h, e, o[s]) : this._computeSubSkinnedData(t, h, e, o[s], n);
                        }
            }, t._computeSubSkinnedData = function(t, e, n, i, r) {
                for (var a = 0, o = e.length; a < o; a++) {
                    var s = e[a];
                    if (this._skinnedDataLoopMarks[s] === M.loopCount)
                        for (var l = r[s], h = this._skinnedData[l[0]][l[1]], u = 16 * l[2], c = 16 * a, _ = 0; _ < 16; _++) i[c + _] = h[u + _];
                    else Gt._mulMatrixArray(this._cacheAnimationNode[s].transform.getWorldMatrix(), t[n[s]], i, 16 * a),
                        this._skinnedDataLoopMarks[s] = M.loopCount;
                }
            }, t._onMeshChange = function(t) {
                s.prototype._onMeshChange.call(this, t);
                var e = (this._cacheMesh = t).subMeshCount;
                this._skinnedData = P(e), this._skinnedDataLoopMarks.length = t._bindPoseIndices.length;
                for (var n = 0; n < e; n++)
                    for (var i = t._getSubMesh(n)._boneIndicesList, r = i.length, a = this._skinnedData[n] = P(r), o = 0; o < r; o++) a[o] = new Float32Array(16 * i[o].length);
                this._cacheAvatar && t && this._computeBoneIndexToMeshWithAsyncAvatar();
            }, t._setCacheAnimator = function(t) {
                this._cacheAnimator = t;
            }, t._setRootBone = function(t) {
                this._rootBone = t;
            }, t._setCacheAvatar = function(t) {
                this._cacheAvatar !== t && (this._cacheMesh ? (this._cacheAvatar = t) && (this._defineDatas.add(fi.SHADERDEFINE_BONE),
                    this._computeBoneIndexToMeshWithAsyncAvatar()) : this._cacheAvatar = t);
            }, t._calculateBoundingBox = function() {
                if (this._cacheAnimator && this._rootBone)
                    if (null == this._localBoundBox) this._boundingBox.toDefault();
                    else {
                        var t = a._tempMatrix4x4,
                            e = this._cacheAnimator._avatarNodeMap[this._rootBone];
                        Gt.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, e.transform.getWorldMatrix(), t),
                            this.localBoundBox.tranform(t, this._boundingBox);
                    }
                else s.prototype._calculateBoundingBox.call(this);
            }, t._calculateBoundingSphere = function() {
                if (this._cacheAnimator && this._rootBone)
                    if (null == this.localBoundSphere) this._boundingSphere.toDefault();
                    else {
                        var t = a._tempMatrix4x4,
                            e = this._cacheAnimator._avatarNodeMap[this._rootBone];
                        Gt.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, e.transform.getWorldMatrix(), t),
                            this.localBoundBox.tranform(t, this._boundingBox);
                        var n = this._boundingSphere.center,
                            i = this._boundingBox.max;
                        if (Ct.add(this._boundingBox.min, i, n), Ct.scale(n, .5, n), this._boundingSphere.radius = Math.max(Math.max(i.x - n.x, i.y - n.y), i.z - n.z),
                            b.supportWebGLPlusCulling) {
                            var r = Ce._cullingBuffer;
                            r[this._cullingBufferIndex + 1] = n.x, r[this._cullingBufferIndex + 2] = n.y, r[this._cullingBufferIndex + 3] = n.z,
                                r[this._cullingBufferIndex + 4] = this._boundingSphere.radius;
                        }
                    }
                else s.prototype._calculateBoundingSphere.call(this);
            }, t._changeRenderObjectsByMesh = function(t) {
                var e = t.subMeshCount;
                this._renderElements.length = e;
                for (var n = 0; n < e; n++) {
                    var i = this._renderElements[n];
                    if (!i) {
                        var r = this.sharedMaterials[n];
                        (i = this._renderElements[n] = new Et()).setTransform(this._owner._transform), i.render = this,
                            i.material = r || ei.defaultMaterial;
                    }
                    i.setGeometry(t._getSubMesh(n));
                }
            }, t._renderUpdate = function(t, e) {
                if (this._cacheAnimator) {
                    this._computeSkinnedData();
                    var n = this._cacheAnimator.owner._transform;
                    this._shaderValues.setMatrix4x4(An.WORLDMATRIX, n.worldMatrix);
                } else this._shaderValues.setMatrix4x4(An.WORLDMATRIX, e.worldMatrix);
            }, t._renderUpdateWithCamera = function(t, e) {
                var n = t.projectionViewMatrix;
                if (this._cacheAnimator) {
                    var i = this._cacheAnimator.owner._transform;
                    be.multiply(n, i.worldMatrix, this._projectionViewWorldMatrix);
                } else be.multiply(n, e.worldMatrix, this._projectionViewWorldMatrix);
                this._shaderValues.setMatrix4x4(An.MVPMATRIX, this._projectionViewWorldMatrix);
            }, t._computeSubSkinnedDataNative = function(t, e, n, i, r, a) {
                E.instance.computeSubSkinnedData(t, e, n, i, r, a);
            }, u(0, t, "localBoundBox", function() {
                return this._localBoundBox;
            }, function(t) {
                this._localBoundBox = t;
            }), u(0, t, "boundingSphere", function() {
                return this._calculateBoundingSphere(), this._boundingSphere;
            }), u(0, t, "boundingBox", function() {
                return this._calculateBoundingBox(), this._boundingBox;
            }), u(0, t, "boundingBoxCenter", function() {
                var t = this.boundingBox;
                return Ct.add(t.min, t.max, this._boundingBoxCenter), Ct.scale(this._boundingBoxCenter, .5, this._boundingBoxCenter),
                    this._boundingBoxCenter;
            }), _(a, ["_tempMatrix4x4", function() {
                return this._tempMatrix4x4 = new be();
            }]), a;
        }(Bn)),
        oi = function(t) {
            function r(t, e, n, i) {
                void 0 === n && (n = 0), void 0 === i && (i = 0), r.__super.call(this, n, !1), this._glTextureType = 3553,
                    this._width = t, this._height = e, this._depthStencilFormat = i, this._create(t, e);
            }
            d(r, "laya.d3.resource.RenderTexture", n);
            var e = r.prototype;
            return e._create = function(t, e) {
                    var n = E.instance;
                    this._frameBuffer = n.createFramebuffer(), V.bindTexture(n, this._glTextureType, this._glTexture);
                    var i = this._getGLFormat();
                    if (n.texImage2D(this._glTextureType, 0, i, t, e, 0, i, 5121, null), this._setGPUMemory(t * e * 4),
                        n.bindFramebuffer(36160, this._frameBuffer), n.framebufferTexture2D(36160, 36064, 3553, this._glTexture, 0),
                        3 !== this._depthStencilFormat) switch (this._depthStencilBuffer = n.createRenderbuffer(),
                        n.bindRenderbuffer(36161, this._depthStencilBuffer), this._depthStencilFormat) {
                        case 0:
                            n.renderbufferStorage(36161, 33189, t, e), n.framebufferRenderbuffer(36160, 36096, 36161, this._depthStencilBuffer);
                            break;

                        case 1:
                            n.renderbufferStorage(36161, 36168, t, e), n.framebufferRenderbuffer(36160, 36128, 36161, this._depthStencilBuffer);
                            break;

                        case 2:
                            n.renderbufferStorage(36161, 34041, t, e), n.framebufferRenderbuffer(36160, 33306, 36161, this._depthStencilBuffer);
                            break;

                        default:
                            throw "RenderTexture: unkonw depth format.";
                    }
                    n.bindFramebuffer(36160, null), n.bindRenderbuffer(36161, null), this._setWarpMode(10242, this._wrapModeU),
                        this._setWarpMode(10243, this._wrapModeV), this._setFilterMode(this._filterMode),
                        this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource();
                }, e._start = function() {
                    E.instance.bindFramebuffer(36160, this._frameBuffer), (r._currentActive = this)._readyed = !1;
                }, e._end = function() {
                    E.instance.bindFramebuffer(36160, null), r._currentActive = null, this._readyed = !0;
                }, e.getData = function(t, e, n, i, r) {
                    if (b.isConchApp && 2 == conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
                    var a = E.instance;
                    return a.bindFramebuffer(36160, this._frameBuffer), 36053 === a.checkFramebufferStatus(36160) ? (a.readPixels(t, e, n, i, 6408, 5121, r),
                        a.bindFramebuffer(36160, null), r) : (a.bindFramebuffer(36160, null), null);
                }, e.getDataAsync = function(t, e, n, i, r) {
                    var a = E.instance;
                    a.bindFramebuffer(36160, this._frameBuffer), a.readPixelsAsync(t, e, n, i, 6408, 5121, function(t) {
                        r(new Uint8Array(t));
                    }), a.bindFramebuffer(36160, null);
                }, e._disposeResource = function() {
                    if (this._frameBuffer) {
                        var t = E.instance;
                        t.deleteTexture(this._glTexture), t.deleteFramebuffer(this._frameBuffer), t.deleteRenderbuffer(this._depthStencilBuffer),
                            this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null,
                            this._setGPUMemory(0);
                    }
                }, u(0, e, "depthStencilFormat", function() {
                    return this._depthStencilFormat;
                }), u(0, e, "defaulteTexture", function() {
                    return L.grayTexture;
                }), u(1, r, "currentActive", function() {
                    return r._currentActive;
                }, laya.webgl.resource.BaseTexture._$SET_currentActive), r._currentActive = null,
                r;
        }(),
        si = function(t) {
            function r(t, e) {
                void 0 === t && (t = 0), void 0 === e && (e = !1), r.__super.call(this, t, e), this._glTextureType = 34067;
            }
            d(r, "laya.d3.resource.TextureCube", n);
            var e = r.prototype;
            return e.setSixSideImageSources = function(t, e) {
                void 0 === e && (e = !1);
                for (var n = 0, i = 0, r = 0; r < 6; r++) {
                    var a = t[r];
                    if (!a) return void console.log("TextureCube: image Source can't be null.");
                    var o = a.width,
                        s = a.height;
                    if (0 < r && n !== o) return void console.log("TextureCube: each side image's width and height must same.");
                    if ((n = o) !== (i = s)) return void console.log("TextureCube: each side image's width and height must same.");
                }
                this._width = n, this._height = i;
                var l = E.instance;
                V.bindTexture(l, this._glTextureType, this._glTexture);
                var h = this._getGLFormat();
                if (b.isConchApp) {
                    if (1 == e)
                        for (var u = 0; u < 6; u++) t[u].setPremultiplyAlpha(e);
                    l.texImage2D(34073, 0, 6408, 6408, 5121, t[0]), l.texImage2D(34074, 0, 6408, 6408, 5121, t[1]),
                        l.texImage2D(34069, 0, 6408, 6408, 5121, t[2]), l.texImage2D(34070, 0, 6408, 6408, 5121, t[3]),
                        l.texImage2D(34071, 0, 6408, 6408, 5121, t[4]), l.texImage2D(34072, 0, 6408, 6408, 5121, t[5]);
                } else e && l.pixelStorei(37441, !0), l.texImage2D(34073, 0, h, h, 5121, t[0]),
                    l.texImage2D(34074, 0, h, h, 5121, t[1]), l.texImage2D(34069, 0, h, h, 5121, t[2]),
                    l.texImage2D(34070, 0, h, h, 5121, t[3]), l.texImage2D(34071, 0, h, h, 5121, t[4]),
                    l.texImage2D(34072, 0, h, h, 5121, t[5]), e && l.pixelStorei(37441, !1);
                this._mipmap && this._isPot(n) && this._isPot(i) ? (l.generateMipmap(this._glTextureType),
                        this._setGPUMemory(n * i * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(n * i * 4 * 6),
                    this._setWarpMode(10242, this._wrapModeU), this._setWarpMode(10243, this._wrapModeV),
                    this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
            }, e.setSixSidePixels = function(t, e, n) {
                if (t <= 0 || e <= 0) throw new Error("TextureCube:width or height must large than 0.");
                if (!n) throw new Error("TextureCube:pixels can't be null.");
                this._width = t, this._height = e;
                var i = E.instance;
                V.bindTexture(i, this._glTextureType, this._glTexture);
                var r = this._getGLFormat();
                i.texImage2D(34073, 0, r, t, e, 0, r, 5121, n[0]), i.texImage2D(34074, 0, r, t, e, 0, r, 5121, n[1]),
                    i.texImage2D(34069, 0, r, t, e, 0, r, 5121, n[2]), i.texImage2D(34070, 0, r, t, e, 0, r, 5121, n[3]),
                    i.texImage2D(34071, 0, r, t, e, 0, r, 5121, n[4]), i.texImage2D(34072, 0, r, t, e, 0, r, 5121, n[5]),
                    this._mipmap && this._isPot(t) && this._isPot(e) ? (i.generateMipmap(this._glTextureType),
                        this._setGPUMemory(t * e * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(t * e * 4 * 6),
                    this._setWarpMode(10242, this._wrapModeU), this._setWarpMode(10243, this._wrapModeV),
                    this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
            }, e._recoverResource = function() {}, u(0, e, "defaulteTexture", function() {
                return r.grayTexture;
            }), r.__init__ = function() {
                var t = new Uint8Array(3);
                t[0] = 128, t[1] = 128, t[2] = 128, (r.grayTexture = new r(0, !1)).setSixSidePixels(1, 1, [t, t, t, t, t, t]),
                    r.grayTexture.lock = !0;
            }, r._parse = function(t, e, n) {
                var i = n ? new r(n[0], n[1]) : new r();
                return i.setSixSideImageSources(t), i;
            }, r.load = function(t, e) {
                m.loader.create(t, e, null, "TEXTURECUBE");
            }, r.grayTexture = null, r;
        }(),
        li = function(e) {
            function n(t, e) {
                n.__super.call(this, e), this._meshFilter = new Qt(this), this._render = new Bn(this),
                    t && (this._meshFilter.sharedMesh = t);
            }
            d(n, "laya.d3.core.MeshSprite3D", e);
            var t = n.prototype;
            return t._parse = function(t) {
                    laya.d3.core.Sprite3D.prototype._parse.call(this, t);
                    var e = this.meshRenderer,
                        n = t.lightmapIndex;
                    null != n && (e.lightmapIndex = n);
                    var i = t.lightmapScaleOffset;
                    i && (e.lightmapScaleOffset = new At(i[0], i[1], i[2], i[3])), null != t.meshPath && (this.meshFilter.sharedMesh = xt.getRes(t.meshPath)),
                        null != t.enableRender && (this.meshRenderer.enable = t.enableRender);
                    var r = t.materials;
                    if (r) {
                        var a = e.sharedMaterials,
                            o = r.length;
                        a.length = o;
                        for (var s = 0; s < o; s++) a[s] = xt.getRes(r[s].path);
                        e.sharedMaterials = a;
                    }
                }, t._addToInitStaticBatchManager = function() {
                    dn.instance._addBatchSprite(this);
                }, t.cloneTo = function(t) {
                    var e = t;
                    e._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                    var n = this._render,
                        i = e._render;
                    i.enable = n.enable, i.sharedMaterials = n.sharedMaterials, i.castShadow = n.castShadow;
                    var r = n.lightmapScaleOffset;
                    r && (i.lightmapScaleOffset = r.clone()), i.lightmapIndex = n.lightmapIndex, i.receiveShadow = n.receiveShadow,
                        i.sortingFudge = n.sortingFudge, laya.d3.core.Sprite3D.prototype.cloneTo.call(this, t);
                }, t.destroy = function(t) {
                    void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                        this._meshFilter.destroy());
                }, u(0, t, "meshFilter", function() {
                    return this._meshFilter;
                }), u(0, t, "meshRenderer", function() {
                    return this._render;
                }), n.__init__ = function() {
                    n.SHADERDEFINE_UV0 = n.shaderDefines.registerDefine("UV"), n.SHADERDEFINE_COLOR = n.shaderDefines.registerDefine("COLOR"),
                        n.SHADERDEFINE_UV1 = n.shaderDefines.registerDefine("UV1"), n.SHADERDEFINE_GPU_INSTANCE = n.shaderDefines.registerDefine("GPU_INSTANCE"),
                        Z._registerManager(dn.instance), q._registerManager(Qe.instance);
                }, n.SHADERDEFINE_UV0 = 0, n.SHADERDEFINE_COLOR = 0, n.SHADERDEFINE_UV1 = 0, n.SHADERDEFINE_GPU_INSTANCE = 0,
                _(n, ["shaderDefines", function() {
                    return this.shaderDefines = new ht(Hn.shaderDefines);
                }]), n;
        }(Hn),
        hi = function(e) {
            function t() {
                this._direction = null, this._spotAngle = NaN, this._range = NaN, t.__super.call(this),
                    this._spotAngle = 30, this._range = 10, this._direction = new Ct();
            }
            d(t, "laya.d3.core.light.SpotLight", e);
            var n = t.prototype;
            return n._onActive = function() {
                e.prototype._onActive.call(this), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this.scene._defineDatas.add(Gn.SHADERDEFINE_SPOTLIGHT);
            }, n._onInActive = function() {
                e.prototype._onInActive.call(this), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this.scene._defineDatas.remove(Gn.SHADERDEFINE_SPOTLIGHT);
            }, n._prepareToScene = function() {
                var t = this._scene;
                if (t.enableLight && this.activeInHierarchy) {
                    t._defineDatas;
                    var e = t._shaderValues;
                    return Ct.scale(this.color, this._intensity, this._intensityColor), e.setVector3(Gn.SPOTLIGHTCOLOR, this._intensityColor),
                        e.setVector3(Gn.SPOTLIGHTPOS, this.transform.position), this.transform.worldMatrix.getForward(this._direction),
                        Ct.normalize(this._direction, this._direction), e.setVector3(Gn.SPOTLIGHTDIRECTION, this._direction),
                        e.setNumber(Gn.SPOTLIGHTRANGE, this.range), e.setNumber(Gn.SPOTLIGHTSPOTANGLE, this.spotAngle * Math.PI / 180), !0;
                }
                return !1;
            }, n._parse = function(t) {
                e.prototype._parse.call(this, t), this.range = t.range, this.spotAngle = t.spotAngle;
            }, u(0, n, "spotAngle", function() {
                return this._spotAngle;
            }, function(t) {
                this._spotAngle = Math.max(Math.min(t, 180), 0);
            }), u(0, n, "range", function() {
                return this._range;
            }, function(t) {
                this._range = t;
            }), _(t, ["_tempMatrix0", function() {
                return this._tempMatrix0 = new be();
            }, "_tempMatrix1", function() {
                return this._tempMatrix1 = new be();
            }]), t;
        }(Wn),
        ui = function(t) {
            function e() {
                this._direction = null, e.__super.call(this), this._direction = new Ct();
            }
            d(e, "laya.d3.core.light.DirectionLight", t);
            var n = e.prototype;
            return n._initShadow = function() {
                if (this._shadow) this._parallelSplitShadowMap = new wt(), this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap),
                    this.transform.worldMatrix.getForward(this._direction), Ct.normalize(this._direction, this._direction),
                    this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType);
                else {
                    var t = this._scene._defineDatas,
                        e = this.scene.parallelSplitShadowMaps;
                    e.splice(e.indexOf(this._parallelSplitShadowMap), 1), this._parallelSplitShadowMap.disposeAllRenderTarget(),
                        this._parallelSplitShadowMap = null, t.remove(Gn.SHADERDEFINE_SHADOW_PSSM1), t.remove(Gn.SHADERDEFINE_SHADOW_PSSM2),
                        t.remove(Gn.SHADERDEFINE_SHADOW_PSSM3);
                }
            }, n._onActive = function() {
                t.prototype._onActive.call(this), this._shadow && this._initShadow(), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.add(Gn.SHADERDEFINE_DIRECTIONLIGHT);
            }, n._onInActive = function() {
                t.prototype._onInActive.call(this), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.remove(Gn.SHADERDEFINE_DIRECTIONLIGHT);
            }, n._prepareToScene = function() {
                var t = this._scene;
                if (t.enableLight && this.activeInHierarchy) {
                    t._defineDatas;
                    var e = t._shaderValues;
                    return Ct.scale(this.color, this._intensity, this._intensityColor), e.setVector3(Gn.LIGHTDIRCOLOR, this._intensityColor),
                        this.transform.worldMatrix.getForward(this._direction), Ct.normalize(this._direction, this._direction),
                        e.setVector3(Gn.LIGHTDIRECTION, this._direction), !0;
                }
                return !1;
            }, u(0, n, "shadow", t.prototype._$get_shadow, function(t) {
                this._shadow !== t && (this._shadow = t, this.scene && this._initShadow());
            }), e;
        }(Wn),
        ci = function(e) {
            function t() {
                t.__super.call(this, this.name), this._render = new Un(this), this._geometryFilter = new Jt(this);
            }
            d(t, "laya.d3.core.trail.TrailSprite3D", e);
            var n = t.prototype;
            return n._parse = function(t) {
                laya.d3.core.Sprite3D.prototype._parse.call(this, t);
                var e = this._render,
                    n = this._geometryFilter,
                    i = 0,
                    r = 0,
                    a = t.materials;
                if (a) {
                    var o = e.sharedMaterials,
                        s = a.length;
                    for (o.length = s, i = 0; i < s; i++) o[i] = xt.getRes(a[i].path);
                    e.sharedMaterials = o;
                }
                n.time = t.time, n.minVertexDistance = t.minVertexDistance, n.widthMultiplier = t.widthMultiplier,
                    n.textureMode = t.textureMode, null != t.alignment && (n.alignment = t.alignment);
                var l = [],
                    h = t.widthCurve;
                for (i = 0, r = h.length; i < r; i++) {
                    var u = new un();
                    u.time = h[i].time, u.inTangent = h[i].inTangent, u.outTangent = h[i].outTangent,
                        u.value = h[i].value, l.push(u);
                }
                n.widthCurve = l;
                var c = t.colorGradient,
                    _ = c.colorKeys,
                    d = c.alphaKeys,
                    f = new it(_.length, d.length);
                for (f.mode = c.mode, i = 0, r = _.length; i < r; i++) {
                    var m = _[i];
                    f.addColorRGB(m.time, new dt(m.value[0], m.value[1], m.value[2], 1));
                }
                for (i = 0, r = d.length; i < r; i++) {
                    var p = d[i];
                    f.addColorAlpha(p.time, p.value);
                }
                n.colorGradient = f;
            }, n._onActive = function() {
                e.prototype._onActive.call(this), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
            }, n.cloneTo = function(t) {
                laya.d3.core.Sprite3D.prototype.cloneTo.call(this, t);
                var e, n = 0,
                    i = t,
                    r = i.trailFilter;
                r.time = this.trailFilter.time, r.minVertexDistance = this.trailFilter.minVertexDistance,
                    r.widthMultiplier = this.trailFilter.widthMultiplier, r.textureMode = this.trailFilter.textureMode;
                var a = this.trailFilter.widthCurve,
                    o = [];
                for (n = 0, e = a.length; n < e; n++) {
                    var s = new un();
                    a[n].cloneTo(s), o.push(s);
                }
                r.widthCurve = o;
                var l = new it(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                this.trailFilter.colorGradient.cloneTo(l), r.colorGradient = l, i.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
            }, n.destroy = function(t) {
                void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                    this._geometryFilter.destroy(), this._geometryFilter = null);
            }, u(0, n, "trailFilter", function() {
                return this._geometryFilter;
            }), u(0, n, "trailRenderer", function() {
                return this._render;
            }), t.__init__ = function() {
                t.SHADERDEFINE_GRADIENTMODE_BLEND = t.shaderDefines.registerDefine("GRADIENTMODE_BLEND");
            }, t.SHADERDEFINE_GRADIENTMODE_BLEND = 0, _(t, ["CURTIME", function() {
                return this.CURTIME = Vt.propertyNameToID("u_CurTime");
            }, "LIFETIME", function() {
                return this.LIFETIME = Vt.propertyNameToID("u_LifeTime");
            }, "WIDTHCURVE", function() {
                return this.WIDTHCURVE = Vt.propertyNameToID("u_WidthCurve");
            }, "WIDTHCURVEKEYLENGTH", function() {
                return this.WIDTHCURVEKEYLENGTH = Vt.propertyNameToID("u_WidthCurveKeyLength");
            }, "GRADIENTCOLORKEY", function() {
                return this.GRADIENTCOLORKEY = Vt.propertyNameToID("u_GradientColorkey");
            }, "GRADIENTALPHAKEY", function() {
                return this.GRADIENTALPHAKEY = Vt.propertyNameToID("u_GradientAlphakey");
            }, "shaderDefines", function() {
                return this.shaderDefines = new ht(Hn.shaderDefines);
            }]), t;
        }(Hn),
        _i = function(e) {
            function yt() {
                yt.__super.call(this, null), this._render = new Pn(this), this._particleSystem = new qe(this);
                var t = this._render._renderElements[0] = new Et();
                t.setTransform(this._transform), t.render = this._render, t.setGeometry(this._particleSystem),
                    t.material = Qn.defaultMaterial;
            }
            d(yt, "laya.d3.core.particleShuriKen.ShuriKenParticle3D", e);
            var t = yt.prototype;
            return t._initParticleVelocity = function(t) {
                    for (var e = new Ht(), n = t.velocitys, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.add(a.key, a.value);
                    }
                    return e;
                }, t._initParticleColor = function(t) {
                    var e = new it(4, 4),
                        n = t.alphas,
                        i = 0,
                        r = 0;
                    for (i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        3 === i && 1 !== a.key && (a.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")),
                            e.addColorAlpha(a.key, a.value);
                    }
                    var o = t.rgbs;
                    for (i = 0, r = o.length; i < r; i++) {
                        var s = o[i],
                            l = s.value;
                        3 === i && 1 !== s.key && (s.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")),
                            e.addColorRGB(s.key, new dt(l[0], l[1], l[2], 1));
                    }
                    return e;
                }, t._initParticleSize = function(t) {
                    for (var e = new Ht(), n = t.sizes, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.add(a.key, a.value);
                    }
                    return e;
                }, t._initParticleRotation = function(t) {
                    for (var e = new Ht(), n = t.angularVelocitys, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.add(a.key, a.value / 180 * Math.PI);
                    }
                    return e;
                }, t._initParticleFrame = function(t) {
                    for (var e = new ie(), n = t.frames, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.add(a.key, a.value);
                    }
                    return e;
                }, t._parse = function(t) {
                    laya.d3.core.Sprite3D.prototype._parse.call(this, t);
                    var e, n = Math.PI / 180,
                        i = 0,
                        r = 0,
                        a = this.particleRenderer,
                        o = t.material;
                    o && (e = xt.getRes(o.path)), a.sharedMaterial = e;
                    var s = t.meshPath;
                    s && (a.mesh = xt.getRes(s)), a.renderMode = t.renderMode, a.stretchedBillboardCameraSpeedScale = t.stretchedBillboardCameraSpeedScale,
                        a.stretchedBillboardSpeedScale = t.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = t.stretchedBillboardLengthScale,
                        a.sortingFudge = t.sortingFudge ? t.sortingFudge : 0;
                    var l = this.particleSystem;
                    l.isPerformanceMode = t.isPerformanceMode, l.duration = t.duration, l.looping = t.looping,
                        l.prewarm = t.prewarm, l.startDelayType = t.startDelayType, l.startDelay = t.startDelay,
                        l.startDelayMin = t.startDelayMin, l.startDelayMax = t.startDelayMax, l.startLifetimeType = t.startLifetimeType,
                        l.startLifetimeConstant = t.startLifetimeConstant, l.startLifeTimeGradient = yt._initStartLife(t.startLifetimeGradient),
                        l.startLifetimeConstantMin = t.startLifetimeConstantMin, l.startLifetimeConstantMax = t.startLifetimeConstantMax,
                        l.startLifeTimeGradientMin = yt._initStartLife(t.startLifetimeGradientMin), l.startLifeTimeGradientMax = yt._initStartLife(t.startLifetimeGradientMax),
                        l.startSpeedType = t.startSpeedType, l.startSpeedConstant = t.startSpeedConstant,
                        l.startSpeedConstantMin = t.startSpeedConstantMin, l.startSpeedConstantMax = t.startSpeedConstantMax,
                        l.threeDStartSize = t.threeDStartSize, l.startSizeType = t.startSizeType, l.startSizeConstant = t.startSizeConstant;
                    var h = t.startSizeConstantSeparate,
                        u = l.startSizeConstantSeparate;
                    u.x = h[0], u.y = h[1], u.z = h[2], l.startSizeConstantMin = t.startSizeConstantMin,
                        l.startSizeConstantMax = t.startSizeConstantMax;
                    var c = t.startSizeConstantMinSeparate,
                        _ = l.startSizeConstantMinSeparate;
                    _.x = c[0], _.y = c[1], _.z = c[2];
                    var d = t.startSizeConstantMaxSeparate,
                        f = l.startSizeConstantMaxSeparate;
                    f.x = d[0], f.y = d[1], f.z = d[2], l.threeDStartRotation = t.threeDStartRotation,
                        l.startRotationType = t.startRotationType, l.startRotationConstant = t.startRotationConstant * n;
                    var m = t.startRotationConstantSeparate,
                        p = l.startRotationConstantSeparate;
                    p.x = m[0] * n, p.y = m[1] * n, p.z = m[2] * n, l.startRotationConstantMin = t.startRotationConstantMin * n,
                        l.startRotationConstantMax = t.startRotationConstantMax * n;
                    var T = t.startRotationConstantMinSeparate,
                        E = l.startRotationConstantMinSeparate;
                    E.x = T[0] * n, E.y = T[1] * n, E.z = T[2] * n;
                    var v = t.startRotationConstantMaxSeparate,
                        g = l.startRotationConstantMaxSeparate;
                    g.x = v[0] * n, g.y = v[1] * n, g.z = v[2] * n, l.randomizeRotationDirection = t.randomizeRotationDirection,
                        l.startColorType = t.startColorType;
                    var S = t.startColorConstant,
                        y = l.startColorConstant;
                    y.x = S[0], y.y = S[1], y.z = S[2], y.w = S[3];
                    var x = t.startColorConstantMin,
                        D = l.startColorConstantMin;
                    D.x = x[0], D.y = x[1], D.z = x[2], D.w = x[3];
                    var I = t.startColorConstantMax,
                        R = l.startColorConstantMax;
                    R.x = I[0], R.y = I[1], R.z = I[2], R.w = I[3], l.gravityModifier = t.gravityModifier,
                        l.simulationSpace = t.simulationSpace, l.scaleMode = t.scaleMode, l.playOnAwake = t.playOnAwake,
                        l.maxParticles = t.maxParticles;
                    var M = t.autoRandomSeed;
                    null != M && (l.autoRandomSeed = M);
                    var A = t.randomSeed;
                    null != A && (l.randomSeed[0] = A);
                    var C = t.emission,
                        L = l.emission;
                    if (C) {
                        L.emissionRate = C.emissionRate;
                        var O = C.bursts;
                        if (O)
                            for (i = 0, r = O.length; i < r; i++) {
                                var N = O[i];
                                L.addBurst(new te(N.time, N.min, N.max));
                            }
                        L.enbale = C.enable;
                    } else L.enbale = !1;
                    var V = t.shape;
                    if (V) {
                        var w;
                        switch (V.shapeType) {
                            case 0:
                                var P;
                                w = P = new vn(), P.radius = V.sphereRadius, P.emitFromShell = V.sphereEmitFromShell,
                                    P.randomDirection = V.sphereRandomDirection;
                                break;

                            case 1:
                                var b;
                                w = b = new Tn(), b.radius = V.hemiSphereRadius, b.emitFromShell = V.hemiSphereEmitFromShell,
                                    b.randomDirection = V.hemiSphereRandomDirection;
                                break;

                            case 2:
                                var F;
                                w = F = new ke(), F.angle = V.coneAngle * n, F.radius = V.coneRadius, F.length = V.coneLength,
                                    F.emitType = V.coneEmitType, F.randomDirection = V.coneRandomDirection;
                                break;

                            case 3:
                                var B;
                                w = B = new xn(), B.x = V.boxX, B.y = V.boxY, B.z = V.boxZ, B.randomDirection = V.boxRandomDirection;
                                break;

                            case 7:
                                var U;
                                w = U = new Xe(), U.radius = V.circleRadius, U.arc = V.circleArc * n, U.emitFromEdge = V.circleEmitFromEdge,
                                    U.randomDirection = V.circleRandomDirection;
                                break;

                            default:
                                var z;
                                w = z = new Xe(), z.radius = V.circleRadius, z.arc = V.circleArc * n, z.emitFromEdge = V.circleEmitFromEdge,
                                    z.randomDirection = V.circleRandomDirection;
                        }
                        w.enable = V.enable, l.shape = w;
                    }
                    var G = t.velocityOverLifetime;
                    if (G) {
                        var H, k = G.velocity;
                        switch (k.type) {
                            case 0:
                                var W = k.constant;
                                H = Ee.createByConstant(new Ct(W[0], W[1], W[2]));
                                break;

                            case 1:
                                H = Ee.createByGradient(this._initParticleVelocity(k.gradientX), this._initParticleVelocity(k.gradientY), this._initParticleVelocity(k.gradientZ));
                                break;

                            case 2:
                                var X = k.constantMin,
                                    Y = k.constantMax;
                                H = Ee.createByRandomTwoConstant(new Ct(X[0], X[1], X[2]), new Ct(Y[0], Y[1], Y[2]));
                                break;

                            case 3:
                                H = Ee.createByRandomTwoGradient(this._initParticleVelocity(k.gradientXMin), this._initParticleVelocity(k.gradientXMax), this._initParticleVelocity(k.gradientYMin), this._initParticleVelocity(k.gradientYMax), this._initParticleVelocity(k.gradientZMin), this._initParticleVelocity(k.gradientZMax));
                        }
                        var Z = new Ot(H);
                        Z.space = G.space, Z.enbale = G.enable, l.velocityOverLifetime = Z;
                    }
                    var j = t.colorOverLifetime;
                    if (j) {
                        var K, q = j.color;
                        switch (q.type) {
                            case 0:
                                var Q = q.constant;
                                K = Rt.createByConstant(new At(Q[0], Q[1], Q[2], Q[3]));
                                break;

                            case 1:
                                K = Rt.createByGradient(this._initParticleColor(q.gradient));
                                break;

                            case 2:
                                var J = q.constantMin,
                                    $ = q.constantMax;
                                K = Rt.createByRandomTwoConstant(new At(J[0], J[1], J[2], J[3]), new At($[0], $[1], $[2], $[3]));
                                break;

                            case 3:
                                K = Rt.createByRandomTwoGradient(this._initParticleColor(q.gradientMin), this._initParticleColor(q.gradientMax));
                        }
                        var tt = new Dt(K);
                        tt.enbale = j.enable, l.colorOverLifetime = tt;
                    }
                    var et = t.sizeOverLifetime;
                    if (et) {
                        var nt, it = et.size;
                        switch (it.type) {
                            case 0:
                                nt = it.separateAxes ? fe.createByGradientSeparate(this._initParticleSize(it.gradientX), this._initParticleSize(it.gradientY), this._initParticleSize(it.gradientZ)) : fe.createByGradient(this._initParticleSize(it.gradient));
                                break;

                            case 1:
                                if (it.separateAxes) {
                                    var rt = it.constantMinSeparate,
                                        at = it.constantMaxSeparate;
                                    nt = fe.createByRandomTwoConstantSeparate(new Ct(rt[0], rt[1], rt[2]), new Ct(at[0], at[1], at[2]));
                                } else nt = fe.createByRandomTwoConstant(it.constantMin, it.constantMax);
                                break;

                            case 2:
                                nt = it.separateAxes ? fe.createByRandomTwoGradientSeparate(this._initParticleSize(it.gradientXMin), this._initParticleSize(it.gradientYMin), this._initParticleSize(it.gradientZMin), this._initParticleSize(it.gradientXMax), this._initParticleSize(it.gradientYMax), this._initParticleSize(it.gradientZMax)) : fe.createByRandomTwoGradient(this._initParticleSize(it.gradientMin), this._initParticleSize(it.gradientMax));
                        }
                        var ot = new Mt(nt);
                        ot.enbale = et.enable, l.sizeOverLifetime = ot;
                    }
                    var st = t.rotationOverLifetime;
                    if (st) {
                        var lt, ht = st.angularVelocity;
                        switch (ht.type) {
                            case 0:
                                if (ht.separateAxes) {
                                    var ut = ht.constantSeparate;
                                    lt = ae.createByConstantSeparate(new Ct(ut[0] * n, ut[1] * n, ut[2] * n));
                                } else lt = ae.createByConstant(ht.constant * n);
                                break;

                            case 1:
                                lt = ht.separateAxes ? ae.createByGradientSeparate(this._initParticleRotation(ht.gradientX), this._initParticleRotation(ht.gradientY), this._initParticleRotation(ht.gradientZ)) : ae.createByGradient(this._initParticleRotation(ht.gradient));
                                break;

                            case 2:
                                if (ht.separateAxes) {
                                    var ct = ht.constantMinSeparate,
                                        _t = ht.constantMaxSeparate;
                                    lt = ae.createByRandomTwoConstantSeparate(new Ct(ct[0] * n, ct[1] * n, ct[2] * n), new Ct(_t[0] * n, _t[1] * n, _t[2] * n));
                                } else lt = ae.createByRandomTwoConstant(ht.constantMin * n, ht.constantMax * n);
                                break;

                            case 3:
                                ht.separateAxes || (lt = ae.createByRandomTwoGradient(this._initParticleRotation(ht.gradientMin), this._initParticleRotation(ht.gradientMax)));
                        }
                        var dt = new Re(lt);
                        dt.enbale = st.enable, l.rotationOverLifetime = dt;
                    }
                    var ft = t.textureSheetAnimation;
                    if (ft) {
                        var mt, pt = ft.frame;
                        switch (pt.type) {
                            case 0:
                                mt = It.createByConstant(pt.constant);
                                break;

                            case 1:
                                mt = It.createByOverTime(this._initParticleFrame(pt.overTime));
                                break;

                            case 2:
                                mt = It.createByRandomTwoConstant(pt.constantMin, pt.constantMax);
                                break;

                            case 3:
                                mt = It.createByRandomTwoOverTime(this._initParticleFrame(pt.overTimeMin), this._initParticleFrame(pt.overTimeMax));
                        }
                        var Tt, Et = ft.startFrame;
                        switch (Et.type) {
                            case 0:
                                Tt = ve.createByConstant(Et.constant);
                                break;

                            case 1:
                                Tt = ve.createByRandomTwoConstant(Et.constantMin, Et.constantMax);
                        }
                        var vt = new Nt(mt, Tt);
                        vt.enable = ft.enable;
                        var gt = ft.tiles;
                        vt.tiles = new Lt(gt[0], gt[1]), vt.type = ft.type, vt.randomRow = ft.randomRow;
                        var St = ft.rowIndex;
                        void 0 !== St && (vt.rowIndex = St), vt.cycles = ft.cycles, l.textureSheetAnimation = vt;
                    }
                }, t._activeHierarchy = function(t) {
                    laya.display.Node.prototype._activeHierarchy.call(this, t), this.particleSystem.playOnAwake && this.particleSystem.play();
                }, t._inActiveHierarchy = function(t) {
                    laya.display.Node.prototype._inActiveHierarchy.call(this, t), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
                }, t.cloneTo = function(t) {
                    var e = t,
                        n = e._particleSystem;
                    this._particleSystem.cloneTo(n);
                    var i = e._render,
                        r = this._render;
                    i.sharedMaterials = r.sharedMaterials, i.enable = r.enable, i.renderMode = r.renderMode,
                        i.mesh = r.mesh, i.stretchedBillboardCameraSpeedScale = r.stretchedBillboardCameraSpeedScale,
                        i.stretchedBillboardSpeedScale = r.stretchedBillboardSpeedScale, i.stretchedBillboardLengthScale = r.stretchedBillboardLengthScale,
                        i.sortingFudge = r.sortingFudge, laya.d3.core.Sprite3D.prototype.cloneTo.call(this, t);
                }, t.destroy = function(t) {
                    void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                        this._particleSystem.destroy(), this._particleSystem = null);
                }, u(0, t, "particleSystem", function() {
                    return this._particleSystem;
                }), u(0, t, "particleRenderer", function() {
                    return this._render;
                }), yt.__init__ = function() {
                    yt.SHADERDEFINE_RENDERMODE_BILLBOARD = yt.shaderDefines.registerDefine("SPHERHBILLBOARD"),
                        yt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = yt.shaderDefines.registerDefine("STRETCHEDBILLBOARD"),
                        yt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = yt.shaderDefines.registerDefine("HORIZONTALBILLBOARD"),
                        yt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = yt.shaderDefines.registerDefine("VERTICALBILLBOARD"),
                        yt.SHADERDEFINE_COLOROVERLIFETIME = yt.shaderDefines.registerDefine("COLOROVERLIFETIME"),
                        yt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = yt.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME"),
                        yt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = yt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT"),
                        yt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = yt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE"),
                        yt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = yt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT"),
                        yt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = yt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE"),
                        yt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = yt.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE"),
                        yt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = yt.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIME = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIME"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS"),
                        yt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = yt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES"),
                        yt.SHADERDEFINE_SIZEOVERLIFETIMECURVE = yt.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE"),
                        yt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = yt.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE"),
                        yt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = yt.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES"),
                        yt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = yt.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"),
                        yt.SHADERDEFINE_RENDERMODE_MESH = yt.shaderDefines.registerDefine("RENDERMODE_MESH"),
                        yt.SHADERDEFINE_SHAPE = yt.shaderDefines.registerDefine("SHAPE");
                }, yt._initStartLife = function(t) {
                    for (var e = new Ht(), n = t.startLifetimes, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        e.add(a.key, a.value);
                    }
                    return e;
                }, yt.SHADERDEFINE_RENDERMODE_BILLBOARD = 0, yt.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = 0,
                yt.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = 0, yt.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = 0,
                yt.SHADERDEFINE_COLOROVERLIFETIME = 0, yt.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = 0,
                yt.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = 0, yt.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = 0,
                yt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = 0, yt.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = 0,
                yt.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = 0, yt.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = 0,
                yt.SHADERDEFINE_ROTATIONOVERLIFETIME = 0, yt.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = 0,
                yt.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = 0, yt.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = 0,
                yt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = 0, yt.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = 0,
                yt.SHADERDEFINE_SIZEOVERLIFETIMECURVE = 0, yt.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = 0,
                yt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = 0, yt.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = 0,
                yt.SHADERDEFINE_RENDERMODE_MESH = 0, yt.SHADERDEFINE_SHAPE = 0, _(yt, ["WORLDPOSITION", function() {
                    return this.WORLDPOSITION = Vt.propertyNameToID("u_WorldPosition");
                }, "WORLDROTATION", function() {
                    return this.WORLDROTATION = Vt.propertyNameToID("u_WorldRotation");
                }, "POSITIONSCALE", function() {
                    return this.POSITIONSCALE = Vt.propertyNameToID("u_PositionScale");
                }, "SIZESCALE", function() {
                    return this.SIZESCALE = Vt.propertyNameToID("u_SizeScale");
                }, "SCALINGMODE", function() {
                    return this.SCALINGMODE = Vt.propertyNameToID("u_ScalingMode");
                }, "GRAVITY", function() {
                    return this.GRAVITY = Vt.propertyNameToID("u_Gravity");
                }, "THREEDSTARTROTATION", function() {
                    return this.THREEDSTARTROTATION = Vt.propertyNameToID("u_ThreeDStartRotation");
                }, "STRETCHEDBILLBOARDLENGTHSCALE", function() {
                    return this.STRETCHEDBILLBOARDLENGTHSCALE = Vt.propertyNameToID("u_StretchedBillboardLengthScale");
                }, "STRETCHEDBILLBOARDSPEEDSCALE", function() {
                    return this.STRETCHEDBILLBOARDSPEEDSCALE = Vt.propertyNameToID("u_StretchedBillboardSpeedScale");
                }, "SIMULATIONSPACE", function() {
                    return this.SIMULATIONSPACE = Vt.propertyNameToID("u_SimulationSpace");
                }, "CURRENTTIME", function() {
                    return this.CURRENTTIME = Vt.propertyNameToID("u_CurrentTime");
                }, "VOLVELOCITYCONST", function() {
                    return this.VOLVELOCITYCONST = Vt.propertyNameToID("u_VOLVelocityConst");
                }, "VOLVELOCITYGRADIENTX", function() {
                    return this.VOLVELOCITYGRADIENTX = Vt.propertyNameToID("u_VOLVelocityGradientX");
                }, "VOLVELOCITYGRADIENTY", function() {
                    return this.VOLVELOCITYGRADIENTY = Vt.propertyNameToID("u_VOLVelocityGradientY");
                }, "VOLVELOCITYGRADIENTZ", function() {
                    return this.VOLVELOCITYGRADIENTZ = Vt.propertyNameToID("u_VOLVelocityGradientZ");
                }, "VOLVELOCITYCONSTMAX", function() {
                    return this.VOLVELOCITYCONSTMAX = Vt.propertyNameToID("u_VOLVelocityConstMax");
                }, "VOLVELOCITYGRADIENTXMAX", function() {
                    return this.VOLVELOCITYGRADIENTXMAX = Vt.propertyNameToID("u_VOLVelocityGradientMaxX");
                }, "VOLVELOCITYGRADIENTYMAX", function() {
                    return this.VOLVELOCITYGRADIENTYMAX = Vt.propertyNameToID("u_VOLVelocityGradientMaxY");
                }, "VOLVELOCITYGRADIENTZMAX", function() {
                    return this.VOLVELOCITYGRADIENTZMAX = Vt.propertyNameToID("u_VOLVelocityGradientMaxZ");
                }, "VOLSPACETYPE", function() {
                    return this.VOLSPACETYPE = Vt.propertyNameToID("u_VOLSpaceType");
                }, "COLOROVERLIFEGRADIENTALPHAS", function() {
                    return this.COLOROVERLIFEGRADIENTALPHAS = Vt.propertyNameToID("u_ColorOverLifeGradientAlphas");
                }, "COLOROVERLIFEGRADIENTCOLORS", function() {
                    return this.COLOROVERLIFEGRADIENTCOLORS = Vt.propertyNameToID("u_ColorOverLifeGradientColors");
                }, "MAXCOLOROVERLIFEGRADIENTALPHAS", function() {
                    return this.MAXCOLOROVERLIFEGRADIENTALPHAS = Vt.propertyNameToID("u_MaxColorOverLifeGradientAlphas");
                }, "MAXCOLOROVERLIFEGRADIENTCOLORS", function() {
                    return this.MAXCOLOROVERLIFEGRADIENTCOLORS = Vt.propertyNameToID("u_MaxColorOverLifeGradientColors");
                }, "SOLSIZEGRADIENT", function() {
                    return this.SOLSIZEGRADIENT = Vt.propertyNameToID("u_SOLSizeGradient");
                }, "SOLSIZEGRADIENTX", function() {
                    return this.SOLSIZEGRADIENTX = Vt.propertyNameToID("u_SOLSizeGradientX");
                }, "SOLSIZEGRADIENTY", function() {
                    return this.SOLSIZEGRADIENTY = Vt.propertyNameToID("u_SOLSizeGradientY");
                }, "SOLSizeGradientZ", function() {
                    return this.SOLSizeGradientZ = Vt.propertyNameToID("u_SOLSizeGradientZ");
                }, "SOLSizeGradientMax", function() {
                    return this.SOLSizeGradientMax = Vt.propertyNameToID("u_SOLSizeGradientMax");
                }, "SOLSIZEGRADIENTXMAX", function() {
                    return this.SOLSIZEGRADIENTXMAX = Vt.propertyNameToID("u_SOLSizeGradientMaxX");
                }, "SOLSIZEGRADIENTYMAX", function() {
                    return this.SOLSIZEGRADIENTYMAX = Vt.propertyNameToID("u_SOLSizeGradientMaxY");
                }, "SOLSizeGradientZMAX", function() {
                    return this.SOLSizeGradientZMAX = Vt.propertyNameToID("u_SOLSizeGradientMaxZ");
                }, "ROLANGULARVELOCITYCONST", function() {
                    return this.ROLANGULARVELOCITYCONST = Vt.propertyNameToID("u_ROLAngularVelocityConst");
                }, "ROLANGULARVELOCITYCONSTSEPRARATE", function() {
                    return this.ROLANGULARVELOCITYCONSTSEPRARATE = Vt.propertyNameToID("u_ROLAngularVelocityConstSeprarate");
                }, "ROLANGULARVELOCITYGRADIENT", function() {
                    return this.ROLANGULARVELOCITYGRADIENT = Vt.propertyNameToID("u_ROLAngularVelocityGradient");
                }, "ROLANGULARVELOCITYGRADIENTX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTX = Vt.propertyNameToID("u_ROLAngularVelocityGradientX");
                }, "ROLANGULARVELOCITYGRADIENTY", function() {
                    return this.ROLANGULARVELOCITYGRADIENTY = Vt.propertyNameToID("u_ROLAngularVelocityGradientY");
                }, "ROLANGULARVELOCITYGRADIENTZ", function() {
                    return this.ROLANGULARVELOCITYGRADIENTZ = Vt.propertyNameToID("u_ROLAngularVelocityGradientZ");
                }, "ROLANGULARVELOCITYCONSTMAX", function() {
                    return this.ROLANGULARVELOCITYCONSTMAX = Vt.propertyNameToID("u_ROLAngularVelocityConstMax");
                }, "ROLANGULARVELOCITYCONSTMAXSEPRARATE", function() {
                    return this.ROLANGULARVELOCITYCONSTMAXSEPRARATE = Vt.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate");
                }, "ROLANGULARVELOCITYGRADIENTMAX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTMAX = Vt.propertyNameToID("u_ROLAngularVelocityGradientMax");
                }, "ROLANGULARVELOCITYGRADIENTXMAX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTXMAX = Vt.propertyNameToID("u_ROLAngularVelocityGradientMaxX");
                }, "ROLANGULARVELOCITYGRADIENTYMAX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTYMAX = Vt.propertyNameToID("u_ROLAngularVelocityGradientMaxY");
                }, "ROLANGULARVELOCITYGRADIENTZMAX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTZMAX = Vt.propertyNameToID("u_ROLAngularVelocityGradientMaxZ");
                }, "ROLANGULARVELOCITYGRADIENTWMAX", function() {
                    return this.ROLANGULARVELOCITYGRADIENTWMAX = Vt.propertyNameToID("u_ROLAngularVelocityGradientMaxW");
                }, "TEXTURESHEETANIMATIONCYCLES", function() {
                    return this.TEXTURESHEETANIMATIONCYCLES = Vt.propertyNameToID("u_TSACycles");
                }, "TEXTURESHEETANIMATIONSUBUVLENGTH", function() {
                    return this.TEXTURESHEETANIMATIONSUBUVLENGTH = Vt.propertyNameToID("u_TSASubUVLength");
                }, "TEXTURESHEETANIMATIONGRADIENTUVS", function() {
                    return this.TEXTURESHEETANIMATIONGRADIENTUVS = Vt.propertyNameToID("u_TSAGradientUVs");
                }, "TEXTURESHEETANIMATIONGRADIENTMAXUVS", function() {
                    return this.TEXTURESHEETANIMATIONGRADIENTMAXUVS = Vt.propertyNameToID("u_TSAMaxGradientUVs");
                }, "shaderDefines", function() {
                    return this.shaderDefines = new ht(Hn.shaderDefines);
                }]), yt;
        }(Hn),
        di = function(t) {
            function n(t, e) {
                this._geometryFilter = null, void 0 === t && (t = 2), n.__super.call(this, e), this._geometryFilter = new on(this, t),
                    this._render = new zn(this), this._changeRenderObjects(this._render, 0, jn.defaultMaterial);
            }
            d(n, "laya.d3.core.pixelLine.PixelLineSprite3D", Hn);
            var e = n.prototype;
            return e._changeRenderObjects = function(t, e, n) {
                var i = this._render._renderElements;
                n || (n = jn.defaultMaterial);
                var r = i[e];
                r || (r = i[e] = new Et()), r.setTransform(this._transform), r.setGeometry(this._geometryFilter),
                    r.render = this._render, r.material = n;
            }, e.addLine = function(t, e, n, i) {
                if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
                this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, t, e, n, i);
            }, e.addLines = function(t) {
                var e = this._geometryFilter._lineCount,
                    n = t.length;
                if (e + n > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                this._geometryFilter._updateLineDatas(e, t), this._geometryFilter._lineCount += n;
            }, e.removeLine = function(t) {
                if (!(t < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._removeLineData(t);
            }, e.setLine = function(t, e, n, i, r) {
                if (!(t < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._updateLineData(t, e, n, i, r);
            }, e.getLine = function(t, e) {
                if (!(t < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                this._geometryFilter._getLineData(t, e);
            }, e.clear = function() {
                this._geometryFilter._lineCount = 0;
            }, u(0, e, "maxLineCount", function() {
                return this._geometryFilter._maxLineCount;
            }, function(t) {
                this._geometryFilter._resizeLineData(t), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, t);
            }), u(0, e, "pixelLineRenderer", function() {
                return this._render;
            }), u(0, e, "lineCount", function() {
                return this._geometryFilter._lineCount;
            }, function(t) {
                if (t > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
                this._geometryFilter._lineCount = t;
            }), n;
        }(),
        fi = function(e) {
            function n(t, e) {
                n.__super.call(this, e), this._meshFilter = new Qt(this), this._render = new ai(this),
                    t && (this._meshFilter.sharedMesh = t);
            }
            d(n, "laya.d3.core.SkinnedMeshSprite3D", e);
            var t = n.prototype;
            return t._parse = function(t) {
                laya.d3.core.Sprite3D.prototype._parse.call(this, t);
                var e = this.skinnedMeshRenderer,
                    n = t.lightmapIndex;
                null != n && (e.lightmapIndex = n);
                var i, r = t.lightmapScaleOffset;
                if (r && (e.lightmapScaleOffset = new At(r[0], r[1], r[2], r[3])), i = t.meshPath) {
                    var a = xt.getRes(i);
                    a && (this.meshFilter.sharedMesh = a);
                }
                var o = t.materials;
                if (o) {
                    var s = e.sharedMaterials,
                        l = o.length;
                    s.length = l;
                    for (var h = 0; h < l; h++) s[h] = xt.getRes(o[h].path);
                    e.sharedMaterials = s;
                }
                var u = t.rootBone;
                u && e._setRootBone(u);
                var c = t.boundBox,
                    _ = c.min,
                    d = c.max,
                    f = new we(new Ct(_[0], _[1], _[2]), new Ct(d[0], d[1], d[2]));
                e.localBoundBox = f;
                var m = t.boundSphere;
                if (m) {
                    var p = m.center,
                        T = new Tt(new Ct(p[0], p[1], p[2]), m.radius);
                    e.localBoundSphere = T;
                }
            }, t._changeHierarchyAnimator = function(t) {
                e.prototype._changeHierarchyAnimator.call(this, t), this.skinnedMeshRenderer._setCacheAnimator(t);
            }, t._changeAnimatorAvatar = function(t) {
                this.skinnedMeshRenderer._setCacheAvatar(t);
            }, t.cloneTo = function(t) {
                var e = t;
                e.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var n = this._render,
                    i = e._render;
                i.enable = n.enable, i.sharedMaterials = n.sharedMaterials, i.castShadow = n.castShadow;
                var r = n.lightmapScaleOffset;
                r && (i.lightmapScaleOffset = r.clone()), i.receiveShadow = n.receiveShadow, i.sortingFudge = n.sortingFudge,
                    i._rootBone = n._rootBone;
                var a = n.localBoundSphere;
                a && (i.localBoundSphere = a.clone());
                var o = n.localBoundBox;
                o && (i.localBoundBox = o.clone()), laya.d3.core.Sprite3D.prototype.cloneTo.call(this, t);
            }, t.destroy = function(t) {
                void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                    this._meshFilter.destroy());
            }, u(0, t, "meshFilter", function() {
                return this._meshFilter;
            }), u(0, t, "skinnedMeshRenderer", function() {
                return this._render;
            }), n.__init__ = function() {
                n.SHADERDEFINE_BONE = n.shaderDefines.registerDefine("BONE");
            }, n.SHADERDEFINE_BONE = 0, _(n, ["BONES", function() {
                return this.BONES = Vt.propertyNameToID("u_Bones");
            }, "shaderDefines", function() {
                return this.shaderDefines = new ht(li.shaderDefines);
            }]), n;
        }(Hn),
        mi = function(e) {
            function a() {
                this._range = NaN, this._lightMatrix = new be(), a.__super.call(this), this._range = 6;
            }
            d(a, "laya.d3.core.light.PointLight", e);
            var t = a.prototype;
            return t._onActive = function() {
                e.prototype._onActive.call(this), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.add(Gn.SHADERDEFINE_POINTLIGHT);
            }, t._onInActive = function() {
                e.prototype._onInActive.call(this), this._lightmapBakedType !== Wn.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.remove(Gn.SHADERDEFINE_POINTLIGHT);
            }, t._prepareToScene = function() {
                var t = this._scene;
                if (t.enableLight && this.activeInHierarchy) {
                    t._defineDatas;
                    var e = t._shaderValues;
                    Ct.scale(this.color, this._intensity, this._intensityColor), e.setVector3(Gn.POINTLIGHTCOLOR, this._intensityColor),
                        e.setVector3(Gn.POINTLIGHTPOS, this.transform.position), e.setNumber(Gn.POINTLIGHTRANGE, this.range);
                    var n = this._lightMatrix,
                        i = n.elements;
                    n.identity(), i[0] = i[5] = i[10] = 1 / this._range;
                    var r = a._tempMatrix0;
                    return this.transform.worldMatrix.invert(r), be.multiply(n, r, n), e.setMatrix4x4(Gn.POINTLIGHTMATRIX, n), !0;
                }
                return !1;
            }, t._parse = function(t) {
                e.prototype._parse.call(this, t), this.range = t.range;
            }, u(0, t, "range", function() {
                return this._range;
            }, function(t) {
                this._range = t;
            }), _(a, ["_tempMatrix0", function() {
                return this._tempMatrix0 = new be();
            }]), a;
        }(Wn),
        pi = function(e) {
            function l(t, e, n, i, r, a, o, s) {
                this._terrainFilter = null, l.__super.call(this, s), this._terrainFilter = new En(this, t, e, n, i, r, a, o),
                    this._render = new Fn(this);
            }
            d(l, "laya.d3.terrain.TerrainChunk", e);
            var t = l.prototype;
            return t.buildRenderElementAndMaterial = function(t, e, n, i, r, a, o, s, l, h, u, c, _, d, f, m, p, T) {
                void 0 === u && (u = 1), void 0 === c && (c = 1), void 0 === _ && (_ = 1), void 0 === d && (d = 1),
                    void 0 === f && (f = 1), void 0 === m && (m = 1), void 0 === p && (p = 1), void 0 === T && (T = 1);
                var E = new ni();
                l && (E.diffuseColor = l), s && (E.ambientColor = s), h && (E.specularColor = h),
                    E.splatAlphaTexture = xt.getRes(n), E.normalTexture = e ? xt.getRes(e) : null, E.diffuseTexture1 = i ? xt.getRes(i) : null,
                    E.diffuseTexture2 = r ? xt.getRes(r) : null, E.diffuseTexture3 = a ? xt.getRes(a) : null,
                    E.diffuseTexture4 = o ? xt.getRes(o) : null, E.setDiffuseScale1(u, c), E.setDiffuseScale2(_, d),
                    E.setDiffuseScale3(f, m), E.setDiffuseScale4(p, T), E.setDetailNum(t), 0 != this._render._renderElements.length && (E.renderMode = 2);
                var v = new Et();
                v.setTransform(this._transform), v.render = this._render, v.setGeometry(this._terrainFilter),
                    this._render._renderElements.push(v), this._render.sharedMaterial = E;
            }, t.cloneTo = function(t) {
                console.log("Terrain Chunk can't clone");
            }, t.destroy = function(t) {
                void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t),
                    this._terrainFilter.destroy(), this._terrainFilter = null);
            }, u(0, t, "terrainFilter", function() {
                return this._terrainFilter;
            }), u(0, t, "terrainRender", function() {
                return this._render;
            }), l;
        }(Hn),
        Ti = function(n) {
            function r(t, e, n) {
                this._updateViewMatrix = !0, this.enableRender = !0, void 0 === t && (t = 0), void 0 === e && (e = .3),
                    void 0 === n && (n = 1e3), this._viewMatrix = new be(), this._projectionMatrix = new be(),
                    this._projectionViewMatrix = new be(), this._projectionViewMatrixNoTranslateScale = new be(),
                    this._viewport = new Se(0, 0, 0, 0), this._normalizedViewport = new Se(0, 0, 1, 1),
                    this._aspectRatio = t, this._boundFrustum = new Me(be.DEFAULT), b.supportWebGLPlusCulling && (this._boundFrustumBuffer = new Float32Array(24)),
                    r.__super.call(this, e, n), this.transform.on("transformchanged", this, this._onTransformChanged);
            }
            d(r, "laya.d3.core.Camera", n);
            var t = r.prototype;
            return t._isLayerVisible = function(t) {
                return 0 != (Math.pow(2, t) & this.cullingMask);
            }, t._onTransformChanged = function(t) {
                (t &= 64) && (this._updateViewMatrix = !0);
            }, t._calculationViewport = function(t, e, n) {
                this._viewport.x = t.x * e, this._viewport.y = t.y * n, this._viewport.width = Math.min(Math.max(t.width * e, 0), e),
                    this._viewport.height = Math.min(Math.max(t.height * n, 0), n);
            }, t._parse = function(t) {
                n.prototype._parse.call(this, t);
                var e = t.viewport;
                this.normalizedViewport = new Se(e[0], e[1], e[2], e[3]);
            }, t._calculateProjectionMatrix = function() {
                if (!this._useUserProjectionMatrix)
                    if (this._orthographic) {
                        var t = this.orthographicVerticalSize * this.aspectRatio * .5,
                            e = .5 * this.orthographicVerticalSize;
                        be.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
                    } else be.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
            }, t._getCanvasHeight = function() {
                return this._renderTarget ? this._renderTarget.height : j.clientHeight;
            }, t.render = function(t, e) {
                if (this._scene) {
                    var n, i, r = E.instance,
                        a = j._instance,
                        o = a.scene = this._scene;
                    if (o.parallelSplitShadowMaps[0]) {
                        at.setRuntimeValueMode(!1);
                        var s = o.parallelSplitShadowMaps[0];
                        s._calcAllLightCameraInfo(this), o._defineDatas.add(Gn.SHADERDEFINE_CAST_SHADOW);
                        for (var l = 0, h = s.shadowMapCount; l < h; l++) {
                            var u = s.cameras[l];
                            a.camera = u, a.projectionViewMatrix = u.projectionViewMatrix, Ce.renderObjectCulling(u, o, a, o._castShadowRenders);
                            var c = s.cameras[l + 1].renderTarget;
                            c._start(), a.camera = u, a.viewport = u.viewport, u._prepareCameraToRender(), u._prepareCameraViewProject(u.viewMatrix, u.projectionMatrix, u._projectionViewMatrixNoTranslateScale),
                                o._clear(r, a), o._opaqueQueue._render(a, !1), c._end();
                        }
                        o._defineDatas.remove(Gn.SHADERDEFINE_CAST_SHADOW), at.setRuntimeValueMode(!0);
                    }
                    a.camera = this, o._preRenderScript(), n = a.viewMatrix = this.viewMatrix;
                    var _ = this._renderTarget;
                    a.projectionViewMatrix = _ ? (_._start(), be.multiply(Kn._invertYScaleMatrix, this._projectionMatrix, Kn._invertYProjectionMatrix),
                            be.multiply(Kn._invertYScaleMatrix, this.projectionViewMatrix, Kn._invertYProjectionViewMatrix),
                            i = a.projectionMatrix = Kn._invertYProjectionMatrix, Kn._invertYProjectionViewMatrix) : (i = a.projectionMatrix = this._projectionMatrix,
                            this.projectionViewMatrix), a.viewport = this.viewport, this._prepareCameraToRender(),
                        this._prepareCameraViewProject(n, i, this._projectionViewMatrixNoTranslateScale),
                        o._preCulling(a, this), o._clear(r, a), o._renderScene(r, a, t, e), o._postRenderScript(),
                        _ && _._end();
                }
            }, t.viewportPointToRay = function(t, e) {
                se.calculateCursorRay(t, this.viewport, this._projectionMatrix, this.viewMatrix, null, e);
            }, t.normalizedViewportPointToRay = function(t, e) {
                var n = r._tempVector20,
                    i = this.viewport;
                n.x = t.x * i.width, n.y = t.y * i.height, se.calculateCursorRay(n, this.viewport, this._projectionMatrix, this.viewMatrix, null, e);
            }, t.worldToViewportPoint = function(t, e) {
                be.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.viewport.project(t, this._projectionViewMatrix, e), e.x = e.x / m.stage.clientScaleX,
                    e.y = e.y / m.stage.clientScaleY;
            }, t.worldToNormalizedViewportPoint = function(t, e) {
                be.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.normalizedViewport.project(t, this._projectionViewMatrix, e), e.x = e.x / m.stage.clientScaleX,
                    e.y = e.y / m.stage.clientScaleY;
            }, t.convertScreenCoordToOrthographicCoord = function(t, e) {
                if (this._orthographic) {
                    var n = j.clientWidth,
                        i = j.clientHeight,
                        r = this.orthographicVerticalSize * this.aspectRatio / n,
                        a = this.orthographicVerticalSize / i;
                    return e.x = (-n / 2 + t.x) * r, e.y = (i / 2 - t.y) * a, e.z = (this.nearPlane - this.farPlane) * (t.z + 1) / 2 - this.nearPlane,
                        Ct.transformCoordinate(e, this.transform.worldMatrix, e), !0;
                }
                return !1;
            }, t.destroy = function(t) {
                void 0 === t && (t = !0), this.transform.off("transformchanged", this, this._onTransformChanged),
                    n.prototype.destroy.call(this, t);
            }, u(0, t, "projectionViewMatrix", function() {
                return be.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix),
                    this._projectionViewMatrix;
            }), u(0, t, "aspectRatio", function() {
                if (0 !== this._aspectRatio) return this._aspectRatio;
                var t = this.viewport;
                return t.width / t.height;
            }, function(t) {
                if (t < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = t, this._calculateProjectionMatrix();
            }), u(0, t, "boundFrustum", function() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix, b.supportWebGLPlusCulling) {
                    var t = this._boundFrustum.near,
                        e = this._boundFrustum.far,
                        n = this._boundFrustum.left,
                        i = this._boundFrustum.right,
                        r = this._boundFrustum.top,
                        a = this._boundFrustum.bottom,
                        o = t.normal,
                        s = e.normal,
                        l = n.normal,
                        h = i.normal,
                        u = r.normal,
                        c = a.normal,
                        _ = this._boundFrustumBuffer;
                    _[0] = o.x, _[1] = o.y, _[2] = o.z, _[3] = t.distance, _[4] = s.x, _[5] = s.y, _[6] = s.z,
                        _[7] = e.distance, _[8] = l.x, _[9] = l.y, _[10] = l.z, _[11] = n.distance, _[12] = h.x,
                        _[13] = h.y, _[14] = h.z, _[15] = i.distance, _[16] = u.x, _[17] = u.y, _[18] = u.z,
                        _[19] = r.distance, _[20] = c.x, _[21] = c.y, _[22] = c.z, _[23] = a.distance;
                }
                return this._boundFrustum;
            }), u(0, t, "viewport", function() {
                return this._renderTarget ? this._calculationViewport(this._normalizedViewport, this._renderTarget.width, this._renderTarget.height) : this._calculationViewport(this._normalizedViewport, j.clientWidth, j.clientHeight),
                    this._viewport;
            }, function(t) {
                var e = 0,
                    n = 0;
                n = this._renderTarget ? (e = this._renderTarget.width, this._renderTarget.height) : (e = j.clientWidth,
                        j.clientHeight), this._normalizedViewport.x = t.x / e, this._normalizedViewport.y = t.y / n,
                    this._normalizedViewport.width = t.width / e, this._normalizedViewport.height = t.height / n,
                    this._calculationViewport(this._normalizedViewport, e, n), this._calculateProjectionMatrix();
            }), u(0, t, "normalizedViewport", function() {
                return this._normalizedViewport;
            }, function(t) {
                var e = 0,
                    n = 0;
                n = this._renderTarget ? (e = this._renderTarget.width, this._renderTarget.height) : (e = j.clientWidth,
                        j.clientHeight), this._normalizedViewport !== t && t.cloneTo(this._normalizedViewport),
                    this._calculationViewport(t, e, n), this._calculateProjectionMatrix();
            }), u(0, t, "projectionMatrix", function() {
                return this._projectionMatrix;
            }, function(t) {
                this._projectionMatrix = t, this._useUserProjectionMatrix = !0;
            }), u(0, t, "viewMatrix", function() {
                if (this._updateViewMatrix) {
                    var t = this.transform.scale,
                        e = t.x,
                        n = t.y,
                        i = t.z,
                        r = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix), r[0] /= e, r[1] /= e, r[2] /= e,
                        r[4] /= n, r[5] /= n, r[6] /= n, r[8] /= i, r[9] /= i, r[10] /= i, this._viewMatrix.invert(this._viewMatrix),
                        this._updateViewMatrix = !1;
                }
                return this._viewMatrix;
            }), r._updateMark = 0, _(r, ["_tempVector20", function() {
                return this._tempVector20 = new Lt();
            }]), r;
        }(Kn);
    ! function(t) {
        function v(t, e, n) {
            this._minX = NaN, this._minZ = NaN, this._cellSize = null, this._heightMap = null,
                v.__super.call(this, t, n), this._heightMap = e, this._cellSize = new Lt();
        }
        d(v, "laya.d3.core.MeshTerrainSprite3D", li);
        var e = v.prototype;
        e._disableRotation = function() {
            var t = this.transform.rotation;
            t.x = 0, t.y = 0, t.z = 0, t.w = 1, this.transform.rotation = t;
        }, e._getScaleX = function() {
            var t = this.transform.worldMatrix.elements,
                e = t[0],
                n = t[1],
                i = t[2];
            return Math.sqrt(e * e + n * n + i * i);
        }, e._getScaleZ = function() {
            var t = this.transform.worldMatrix.elements,
                e = t[8],
                n = t[9],
                i = t[10];
            return Math.sqrt(e * e + n * n + i * i);
        }, e._initCreateFromMesh = function(t, e) {
            this._heightMap = Ut.creatFromMesh(this.meshFilter.sharedMesh, t, e, this._cellSize);
            var n = this.meshFilter.sharedMesh.boundingBox,
                i = n.min;
            n.max;
            this._minX = i.x, this._minZ = i.z;
        }, e._initCreateFromMeshHeightMap = function(t, e, n) {
            var i = this.meshFilter.sharedMesh.boundingBox;
            this._heightMap = Ut.createFromImage(t, e, n), this._computeCellSize(i);
            var r = i.min;
            i.max;
            this._minX = r.x, this._minZ = r.z;
        }, e._computeCellSize = function(t) {
            var e = t.min,
                n = t.max,
                i = e.x,
                r = e.z,
                a = n.x - i,
                o = n.z - r;
            this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = o / (this._heightMap.height - 1);
        }, e._update = function(t) {
            this._disableRotation();
        }, e.getHeight = function(t, e) {
            v._tempVector3.x = t, v._tempVector3.y = 0, v._tempVector3.z = e, this._disableRotation();
            var n = this.transform.worldMatrix;
            n.invert(v._tempMatrix4x4), Ct.transformCoordinate(v._tempVector3, v._tempMatrix4x4, v._tempVector3),
                t = v._tempVector3.x, e = v._tempVector3.z;
            var i = (t - this._minX) / this._cellSize.x,
                r = (e - this._minZ) / this._cellSize.y,
                a = Math.floor(r),
                o = Math.floor(i),
                s = i - o,
                l = r - a,
                h = n.elements,
                u = h[4],
                c = h[5],
                _ = h[6],
                d = Math.sqrt(u * u + c * c + _ * _),
                f = h[13],
                m = this._heightMap.getHeight(a, o + 1),
                p = this._heightMap.getHeight(a + 1, o);
            if (isNaN(m) || isNaN(p)) return NaN;
            if (s + l <= 1) {
                var T = this._heightMap.getHeight(a, o);
                return isNaN(T) ? NaN : (T + s * (m - T) + l * (p - T)) * d + f;
            }
            var E = this._heightMap.getHeight(a + 1, o + 1);
            return isNaN(E) ? NaN : (E + (1 - s) * (p - E) + (1 - l) * (m - E)) * d + f;
        }, u(0, e, "minX", function() {
            var t = this.transform.worldMatrix.elements;
            return this._minX * this._getScaleX() + t[12];
        }), u(0, e, "width", function() {
            return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
        }), u(0, e, "minZ", function() {
            var t = this.transform.worldMatrix.elements;
            return this._minZ * this._getScaleZ() + t[14];
        }), u(0, e, "depth", function() {
            return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
        }), v.createFromMesh = function(t, e, n, i) {
            var r = new v(t, null, i);
            return r._initCreateFromMesh(e, n), r;
        }, v.createFromMeshAndHeightMap = function(t, e, n, i, r) {
            var a = new v(t, null, r);
            return a._initCreateFromMeshHeightMap(e, n, i), a;
        }, _(v, ["_tempVector3", function() {
            return this._tempVector3 = new Ct();
        }, "_tempMatrix4x4", function() {
            return this._tempMatrix4x4 = new be();
        }]);
    }();
}(window, document, Laya);