!function(e, t, n) {
    n.un, n.uns;
    var i = n.static, r = n.class, a = n.getset, o = n.__newvec, s = laya.resource.BaseTexture, l = laya.utils.Browser, h = laya.webgl.utils.Buffer, u = laya.webgl.BufferStateBase, c = laya.utils.Byte, d = laya.utils.ClassUtils, _ = laya.layagl.CommandEncoder, f = laya.components.Component, m = n.Config, p = laya.resource.Context, T = (laya.events.Event, 
    laya.events.EventDispatcher), S = laya.utils.Handler, E = (laya.webgl.utils.InlcudeFile, 
    laya.layagl.LayaGL), v = laya.layagl.LayaGLRunner, g = laya.net.Loader, x = laya.net.LoaderManager, M = laya.maths.MathUtil, y = laya.display.Node, D = laya.maths.Point, R = laya.renders.Render, C = (laya.resource.RenderTexture2D, 
    laya.resource.Resource), I = laya.utils.RunDriver, A = (laya.webgl.shader.Shader, 
    laya.webgl.utils.ShaderCompile), L = laya.webgl.utils.ShaderNode, O = laya.display.Sprite, P = laya.utils.Stat, V = laya.webgl.submit.Submit, N = laya.webgl.submit.SubmitKey, B = laya.resource.Texture2D, w = (laya.utils.Timer, 
    laya.net.URL), b = laya.webgl.WebGL, F = laya.webgl.WebGLContext;
    n.interface("laya.d3.core.IClone"), n.interface("laya.d3.graphics.IVertex"), n.interface("laya.d3.core.scene.IOctreeObject");
    var U = function() {
        function ConchQuaternion(e, t, n, i, r) {
            var a;
            void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), 
            (a = r || new Float32Array(4))[0] = e, a[1] = t, a[2] = n, a[3] = i, this.elements = a;
        }
        r(ConchQuaternion, "laya.d3.math.Native.ConchQuaternion");
        var e = ConchQuaternion.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.scaling = function(e, t) {
            var n = t.elements, i = this.elements;
            n[0] = i[0] * e, n[1] = i[1] * e, n[2] = i[2] * e, n[3] = i[3] * e;
        }, e.normalize = function(e) {
            ConchQuaternion._normalizeArray(this.elements, e.elements);
        }, e.length = function() {
            var e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3];
            return Math.sqrt(t * t + n * n + i * i + r * r);
        }, e.rotateX = function(e, t) {
            var n = t.elements, i = this.elements;
            e *= .5;
            var r = i[0], a = i[1], o = i[2], s = i[3], l = Math.sin(e), h = Math.cos(e);
            n[0] = r * h + s * l, n[1] = a * h + o * l, n[2] = o * h - a * l, n[3] = s * h - r * l;
        }, e.rotateY = function(e, t) {
            var n = t.elements, i = this.elements;
            e *= .5;
            var r = i[0], a = i[1], o = i[2], s = i[3], l = Math.sin(e), h = Math.cos(e);
            n[0] = r * h - o * l, n[1] = a * h + s * l, n[2] = o * h + r * l, n[3] = s * h - a * l;
        }, e.rotateZ = function(e, t) {
            var n = t.elements, i = this.elements;
            e *= .5;
            var r = i[0], a = i[1], o = i[2], s = i[3], l = Math.sin(e), h = Math.cos(e);
            n[0] = r * h + a * l, n[1] = a * h - r * l, n[2] = o * h + s * l, n[3] = s * h - o * l;
        }, e.getYawPitchRoll = function(e) {
            G.transformQuat(G.ForwardRH, this, ConchQuaternion.TEMPVector31), G.transformQuat(G.Up, this, ConchQuaternion.TEMPVector32);
            var t = ConchQuaternion.TEMPVector32.elements;
            ConchQuaternion.angleTo(G.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33);
            var n = ConchQuaternion.TEMPVector33.elements;
            n[0] == Math.PI / 2 ? (n[1] = ConchQuaternion.arcTanAngle(t[2], t[0]), n[2] = 0) : n[0] == -Math.PI / 2 ? (n[1] = ConchQuaternion.arcTanAngle(-t[2], -t[0]), 
            n[2] = 0) : (Ht.createRotationY(-n[1], ConchQuaternion.TEMPMatrix0), Ht.createRotationX(-n[0], ConchQuaternion.TEMPMatrix1), 
            G.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32), 
            G.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32), 
            n[2] = ConchQuaternion.arcTanAngle(t[1], -t[0])), n[1] <= -Math.PI && (n[1] = Math.PI), 
            n[2] <= -Math.PI && (n[2] = Math.PI), n[1] >= Math.PI && n[2] >= Math.PI && (n[1] = 0, 
            n[2] = 0, n[0] = Math.PI - n[0]);
            var i = e.elements;
            i[0] = n[1], i[1] = n[0], i[2] = n[2];
        }, e.invert = function(e) {
            var t = e.elements, n = this.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = i * i + r * r + a * a + o * o, l = s ? 1 / s : 0;
            t[0] = -i * l, t[1] = -r * l, t[2] = -a * l, t[3] = o * l;
        }, e.identity = function() {
            var e = this.elements;
            e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], 
            this.elements[2] = e[t + 2], this.elements[3] = e[t + 3];
        }, e.cloneTo = function(e) {
            var t, n, i;
            if ((n = this.elements) !== (i = e.elements)) for (t = 0; t < 4; ++t) i[t] = n[t];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.equals = function(e) {
            var t = this.elements, n = e.elements;
            return ie.nearEqual(t[0], n[0]) && ie.nearEqual(t[1], n[1]) && ie.nearEqual(t[2], n[2]) && ie.nearEqual(t[3], n[3]);
        }, e.lengthSquared = function() {
            var e = this.elements[0], t = this.elements[1], n = this.elements[2], i = this.elements[3];
            return e * e + t * t + n * n + i * i;
        }, a(0, e, "x", function() {
            return this.elements[0];
        }, function(e) {
            this.elements[0] = e;
        }), a(0, e, "y", function() {
            return this.elements[1];
        }, function(e) {
            this.elements[1] = e;
        }), a(0, e, "z", function() {
            return this.elements[2];
        }, function(e) {
            this.elements[2] = e;
        }), a(0, e, "w", function() {
            return this.elements[3];
        }, function(e) {
            this.elements[3] = e;
        }), ConchQuaternion._dotArray = function(e, t) {
            return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        }, ConchQuaternion._normalizeArray = function(e, t) {
            var n = e[0], i = e[1], r = e[2], a = e[3], o = n * n + i * i + r * r + a * a;
            o > 0 && (o = 1 / Math.sqrt(o), t[0] = n * o, t[1] = i * o, t[2] = r * o, t[3] = a * o);
        }, ConchQuaternion._lerpArray = function(e, t, n, i) {
            var r = 1 - n;
            ConchQuaternion._dotArray(e, t) >= 0 ? (i[0] = r * e[0] + n * t[0], i[1] = r * e[1] + n * t[1], 
            i[2] = r * e[2] + n * t[2], i[3] = r * e[3] + n * t[3]) : (i[0] = r * e[0] - n * t[0], 
            i[1] = r * e[1] - n * t[1], i[2] = r * e[2] - n * t[2], i[3] = r * e[3] - n * t[3]), 
            ConchQuaternion._normalizeArray(i, i);
        }, ConchQuaternion.createFromYawPitchRoll = function(e, t, n, i) {
            var r = .5 * n, a = .5 * t, o = .5 * e, s = Math.sin(r), l = Math.cos(r), h = Math.sin(a), u = Math.cos(a), c = Math.sin(o), d = Math.cos(o), _ = i.elements;
            _[0] = d * h * l + c * u * s, _[1] = c * u * l - d * h * s, _[2] = d * u * s - c * h * l, 
            _[3] = d * u * l + c * h * s;
        }, ConchQuaternion.multiply = function(e, t, n) {
            var i = e.elements, r = t.elements, a = n.elements, o = i[0], s = i[1], l = i[2], h = i[3], u = r[0], c = r[1], d = r[2], _ = r[3], f = s * d - l * c, m = l * u - o * d, p = o * c - s * u, T = o * u + s * c + l * d;
            a[0] = o * _ + u * h + f, a[1] = s * _ + c * h + m, a[2] = l * _ + d * h + p, a[3] = h * _ - T;
        }, ConchQuaternion.arcTanAngle = function(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }, ConchQuaternion.angleTo = function(e, t, n) {
            G.subtract(t, e, ConchQuaternion.TEMPVector30), G.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30), 
            n.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y), n.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x);
        }, ConchQuaternion.createFromAxisAngle = function(e, t, n) {
            var i = n.elements, r = e.elements;
            t *= .5;
            var a = Math.sin(t);
            i[0] = a * r[0], i[1] = a * r[1], i[2] = a * r[2], i[3] = Math.cos(t);
        }, ConchQuaternion.createFromMatrix3x3 = function(e, t) {
            var n, i = t.elements, r = e.elements, a = r[0] + r[4] + r[8];
            if (a > 0) n = Math.sqrt(a + 1), i[3] = .5 * n, n = .5 / n, i[0] = (r[5] - r[7]) * n, 
            i[1] = (r[6] - r[2]) * n, i[2] = (r[1] - r[3]) * n; else {
                var o = 0;
                r[4] > r[0] && (o = 1), r[8] > r[3 * o + o] && (o = 2);
                var s = (o + 1) % 3, l = (o + 2) % 3;
                n = Math.sqrt(r[3 * o + o] - r[3 * s + s] - r[3 * l + l] + 1), i[o] = .5 * n, n = .5 / n, 
                i[3] = (r[3 * s + l] - r[3 * l + s]) * n, i[s] = (r[3 * s + o] + r[3 * o + s]) * n, 
                i[l] = (r[3 * l + o] + r[3 * o + l]) * n;
            }
        }, ConchQuaternion.createFromMatrix4x4 = function(e, t) {
            var n, i, r = e.elements, a = t.elements, o = r[0] + r[5] + r[10];
            o > 0 ? (n = Math.sqrt(o + 1), a[3] = .5 * n, n = .5 / n, a[0] = (r[6] - r[9]) * n, 
            a[1] = (r[8] - r[2]) * n, a[2] = (r[1] - r[4]) * n) : r[0] >= r[5] && r[0] >= r[10] ? (i = .5 / (n = Math.sqrt(1 + r[0] - r[5] - r[10])), 
            a[0] = .5 * n, a[1] = (r[1] + r[4]) * i, a[2] = (r[2] + r[8]) * i, a[3] = (r[6] - r[9]) * i) : r[5] > r[10] ? (i = .5 / (n = Math.sqrt(1 + r[5] - r[0] - r[10])), 
            a[0] = (r[4] + r[1]) * i, a[1] = .5 * n, a[2] = (r[9] + r[6]) * i, a[3] = (r[8] - r[2]) * i) : (i = .5 / (n = Math.sqrt(1 + r[10] - r[0] - r[5])), 
            a[0] = (r[8] + r[2]) * i, a[1] = (r[9] + r[6]) * i, a[2] = .5 * n, a[3] = (r[1] - r[4]) * i);
        }, ConchQuaternion.slerp = function(e, t, n, i) {
            var r, a, o, s, l, h = e.elements, u = t.elements, c = i.elements, d = h[0], _ = h[1], f = h[2], m = h[3], p = u[0], T = u[1], S = u[2], E = u[3];
            return (a = d * p + _ * T + f * S + m * E) < 0 && (a = -a, p = -p, T = -T, S = -S, 
            E = -E), 1 - a > 1e-6 ? (r = Math.acos(a), o = Math.sin(r), s = Math.sin((1 - n) * r) / o, 
            l = Math.sin(n * r) / o) : (s = 1 - n, l = n), c[0] = s * d + l * p, c[1] = s * _ + l * T, 
            c[2] = s * f + l * S, c[3] = s * m + l * E, c;
        }, ConchQuaternion.lerp = function(e, t, n, i) {
            ConchQuaternion._lerpArray(e.elements, t.elements, n, i.elements);
        }, ConchQuaternion.add = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2], i[3] = r[3] + a[3];
        }, ConchQuaternion.dot = function(e, t) {
            return ConchQuaternion._dotArray(e.elements, t.elements);
        }, ConchQuaternion.rotationLookAt = function(e, t, n) {
            ConchQuaternion.lookAt(G.ZERO, e, t, n);
        }, ConchQuaternion.lookAt = function(e, t, n, i) {
            Ft.lookAt(e, t, n, ConchQuaternion._tempMatrix3x3), ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, i);
        }, ConchQuaternion.invert = function(e, t) {
            var n = e.elements, i = t.elements, r = e.lengthSquared();
            ie.isZero(r) || (r = 1 / r, i[0] = -n[0] * r, i[1] = -n[1] * r, i[2] = -n[2] * r, 
            i[3] = n[3] * r);
        }, ConchQuaternion.rotationMatrix = function(e, t) {
            var n = e.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], l = n[5], h = n[6], u = n[7], c = n[8], d = t.elements, _ = NaN, f = NaN, m = i + s + c;
            m > 0 ? (_ = Math.sqrt(m + 1), d[3] = .5 * _, _ = .5 / _, d[0] = (l - u) * _, d[1] = (h - a) * _, 
            d[2] = (r - o) * _) : i >= s && i >= c ? (f = .5 / (_ = Math.sqrt(1 + i - s - c)), 
            d[0] = .5 * _, d[1] = (r + o) * f, d[2] = (a + h) * f, d[3] = (l - u) * f) : s > c ? (f = .5 / (_ = Math.sqrt(1 + s - i - c)), 
            d[0] = (o + r) * f, d[1] = .5 * _, d[2] = (u + l) * f, d[3] = (h - a) * f) : (f = .5 / (_ = Math.sqrt(1 + c - i - s)), 
            d[0] = (h + a) * f, d[1] = (u + l) * f, d[2] = .5 * _, d[3] = (r - o) * f);
        }, ConchQuaternion.DEFAULT = new ConchQuaternion(), i(ConchQuaternion, [ "TEMPVector30", function() {
            return this.TEMPVector30 = new G();
        }, "TEMPVector31", function() {
            return this.TEMPVector31 = new G();
        }, "TEMPVector32", function() {
            return this.TEMPVector32 = new G();
        }, "TEMPVector33", function() {
            return this.TEMPVector33 = new G();
        }, "TEMPMatrix0", function() {
            return this.TEMPMatrix0 = new Ht();
        }, "TEMPMatrix1", function() {
            return this.TEMPMatrix1 = new Ht();
        }, "_tempMatrix3x3", function() {
            return this._tempMatrix3x3 = new Ft();
        }, "NAN", function() {
            return this.NAN = new ConchQuaternion(NaN, NaN, NaN, NaN);
        } ]), ConchQuaternion;
    }(), z = function() {
        function ConchVector4(e, t, n, i) {
            this.elements = null, void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), 
            void 0 === i && (i = 0);
            var r = this.elements = new Float32Array(4);
            r[0] = e, r[1] = t, r[2] = n, r[3] = i;
        }
        r(ConchVector4, "laya.d3.math.Native.ConchVector4");
        var e = ConchVector4.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], 
            this.elements[2] = e[t + 2], this.elements[3] = e[t + 3];
        }, e.cloneTo = function(e) {
            var t = e.elements, n = this.elements;
            t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }, e.lengthSquared = function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }, a(0, e, "x", function() {
            return this.elements[0];
        }, function(e) {
            this.elements[0] = e;
        }), a(0, e, "y", function() {
            return this.elements[1];
        }, function(e) {
            this.elements[1] = e;
        }), a(0, e, "z", function() {
            return this.elements[2];
        }, function(e) {
            this.elements[2] = e;
        }), a(0, e, "w", function() {
            return this.elements[3];
        }, function(e) {
            this.elements[3] = e;
        }), ConchVector4.lerp = function(e, t, n, i) {
            var r = i.elements, a = e.elements, o = t.elements, s = a[0], l = a[1], h = a[2], u = a[3];
            r[0] = s + n * (o[0] - s), r[1] = l + n * (o[1] - l), r[2] = h + n * (o[2] - h), 
            r[3] = u + n * (o[3] - u);
        }, ConchVector4.transformByM4x4 = function(e, t, n) {
            var i = e.elements, r = i[0], a = i[1], o = i[2], s = i[3], l = t.elements, h = n.elements;
            h[0] = r * l[0] + a * l[4] + o * l[8] + s * l[12], h[1] = r * l[1] + a * l[5] + o * l[9] + s * l[13], 
            h[2] = r * l[2] + a * l[6] + o * l[10] + s * l[14], h[3] = r * l[3] + a * l[7] + o * l[11] + s * l[15];
        }, ConchVector4.equals = function(e, t) {
            var n = e.elements, i = t.elements;
            return ie.nearEqual(Math.abs(n[0]), Math.abs(i[0])) && ie.nearEqual(Math.abs(n[1]), Math.abs(i[1])) && ie.nearEqual(Math.abs(n[2]), Math.abs(i[2])) && ie.nearEqual(Math.abs(n[3]), Math.abs(i[3]));
        }, ConchVector4.normalize = function(e, t) {
            var n = e.elements, i = t.elements, r = e.length();
            r > 0 && (i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = n[3] * r);
        }, ConchVector4.add = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2], i[3] = r[3] + a[3];
        }, ConchVector4.subtract = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] - a[0], i[1] = r[1] - a[1], i[2] = r[2] - a[2], i[3] = r[3] - a[3];
        }, ConchVector4.multiply = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] * a[0], i[1] = r[1] * a[1], i[2] = r[2] * a[2], i[3] = r[3] * a[3];
        }, ConchVector4.scale = function(e, t, n) {
            var i = n.elements, r = e.elements;
            i[0] = r[0] * t, i[1] = r[1] * t, i[2] = r[2] * t, i[3] = r[3] * t;
        }, ConchVector4.Clamp = function(e, t, n, i) {
            var r = e.elements, a = r[0], o = r[1], s = r[2], l = r[3], h = t.elements, u = h[0], c = h[1], d = h[2], _ = h[3], f = n.elements, m = f[0], p = f[1], T = f[2], S = f[3], E = i.elements;
            a = (a = a > m ? m : a) < u ? u : a, o = (o = o > p ? p : o) < c ? c : o, s = (s = s > T ? T : s) < d ? d : s, 
            l = (l = l > S ? S : l) < _ ? _ : l, E[0] = a, E[1] = o, E[2] = s, E[3] = l;
        }, ConchVector4.distanceSquared = function(e, t) {
            var n = e.elements, i = t.elements, r = n[0] - i[0], a = n[1] - i[1], o = n[2] - i[2], s = n[3] - i[3];
            return r * r + a * a + o * o + s * s;
        }, ConchVector4.distance = function(e, t) {
            var n = e.elements, i = t.elements, r = n[0] - i[0], a = n[1] - i[1], o = n[2] - i[2], s = n[3] - i[3];
            return Math.sqrt(r * r + a * a + o * o + s * s);
        }, ConchVector4.dot = function(e, t) {
            var n = e.elements, i = t.elements;
            return n[0] * i[0] + n[1] * i[1] + n[2] * i[2] + n[3] * i[3];
        }, ConchVector4.min = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = Math.min(r[0], a[0]), i[1] = Math.min(r[1], a[1]), i[2] = Math.min(r[2], a[2]), 
            i[3] = Math.min(r[3], a[3]);
        }, ConchVector4.max = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = Math.max(r[0], a[0]), i[1] = Math.max(r[1], a[1]), i[2] = Math.max(r[2], a[2]), 
            i[3] = Math.max(r[3], a[3]);
        }, i(ConchVector4, [ "ZERO", function() {
            return this.ZERO = new ConchVector4();
        }, "ONE", function() {
            return this.ONE = new ConchVector4(1, 1, 1, 1);
        }, "UnitX", function() {
            return this.UnitX = new ConchVector4(1, 0, 0, 0);
        }, "UnitY", function() {
            return this.UnitY = new ConchVector4(0, 1, 0, 0);
        }, "UnitZ", function() {
            return this.UnitZ = new ConchVector4(0, 0, 1, 0);
        }, "UnitW", function() {
            return this.UnitW = new ConchVector4(0, 0, 0, 1);
        } ]), ConchVector4;
    }(), G = function() {
        function ConchVector3(e, t, n, i) {
            var r;
            this.elements = null, void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), 
            r = i || new Float32Array(3), this.elements = r, r[0] = e, r[1] = t, r[2] = n;
        }
        r(ConchVector3, "laya.d3.math.Native.ConchVector3");
        var e = ConchVector3.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setValue = function(e, t, n) {
            this.elements[0] = e, this.elements[1] = t, this.elements[2] = n;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], 
            this.elements[2] = e[t + 2];
        }, e.cloneTo = function(e) {
            var t = e.elements, n = this.elements;
            t[0] = n[0], t[1] = n[1], t[2] = n[2];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.toDefault = function() {
            this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
        }, a(0, e, "x", function() {
            return this.elements[0];
        }, function(e) {
            this.elements[0] = e;
        }), a(0, e, "y", function() {
            return this.elements[1];
        }, function(e) {
            this.elements[1] = e;
        }), a(0, e, "z", function() {
            return this.elements[2];
        }, function(e) {
            this.elements[2] = e;
        }), ConchVector3.distanceSquared = function(e, t) {
            var n = e.elements, i = t.elements, r = n[0] - i[0], a = n[1] - i[1], o = n[2] - i[2];
            return r * r + a * a + o * o;
        }, ConchVector3.distance = function(e, t) {
            var n = e.elements, i = t.elements, r = n[0] - i[0], a = n[1] - i[1], o = n[2] - i[2];
            return Math.sqrt(r * r + a * a + o * o);
        }, ConchVector3.min = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = Math.min(r[0], a[0]), i[1] = Math.min(r[1], a[1]), i[2] = Math.min(r[2], a[2]);
        }, ConchVector3.max = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = Math.max(r[0], a[0]), i[1] = Math.max(r[1], a[1]), i[2] = Math.max(r[2], a[2]);
        }, ConchVector3.transformQuat = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements, o = r[0], s = r[1], l = r[2], h = a[0], u = a[1], c = a[2], d = a[3], _ = d * o + u * l - c * s, f = d * s + c * o - h * l, m = d * l + h * s - u * o, p = -h * o - u * s - c * l;
            i[0] = _ * d + p * -h + f * -c - m * -u, i[1] = f * d + p * -u + m * -h - _ * -c, 
            i[2] = m * d + p * -c + _ * -u - f * -h;
        }, ConchVector3.scalarLength = function(e) {
            var t = e.elements, n = t[0], i = t[1], r = t[2];
            return Math.sqrt(n * n + i * i + r * r);
        }, ConchVector3.scalarLengthSquared = function(e) {
            var t = e.elements, n = t[0], i = t[1], r = t[2];
            return n * n + i * i + r * r;
        }, ConchVector3.normalize = function(e, t) {
            var n = e.elements, i = t.elements, r = n[0], a = n[1], o = n[2], s = r * r + a * a + o * o;
            s > 0 && (s = 1 / Math.sqrt(s), i[0] = n[0] * s, i[1] = n[1] * s, i[2] = n[2] * s);
        }, ConchVector3.multiply = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] * a[0], i[1] = r[1] * a[1], i[2] = r[2] * a[2];
        }, ConchVector3.scale = function(e, t, n) {
            var i = n.elements, r = e.elements;
            i[0] = r[0] * t, i[1] = r[1] * t, i[2] = r[2] * t;
        }, ConchVector3.lerp = function(e, t, n, i) {
            var r = i.elements, a = e.elements, o = t.elements, s = a[0], l = a[1], h = a[2];
            r[0] = s + n * (o[0] - s), r[1] = l + n * (o[1] - l), r[2] = h + n * (o[2] - h);
        }, ConchVector3.transformV3ToV3 = function(e, t, n) {
            var i = ConchVector3._tempVector4;
            ConchVector3.transformV3ToV4(e, t, i);
            var r = i.elements, a = n.elements;
            a[0] = r[0], a[1] = r[1], a[2] = r[2];
        }, ConchVector3.transformV3ToV4 = function(e, t, n) {
            var i = e.elements, r = i[0], a = i[1], o = i[2], s = t.elements, l = n.elements;
            l[0] = r * s[0] + a * s[4] + o * s[8] + s[12], l[1] = r * s[1] + a * s[5] + o * s[9] + s[13], 
            l[2] = r * s[2] + a * s[6] + o * s[10] + s[14], l[3] = r * s[3] + a * s[7] + o * s[11] + s[15];
        }, ConchVector3.TransformNormal = function(e, t, n) {
            var i = e.elements, r = i[0], a = i[1], o = i[2], s = t.elements, l = n.elements;
            l[0] = r * s[0] + a * s[4] + o * s[8], l[1] = r * s[1] + a * s[5] + o * s[9], l[2] = r * s[2] + a * s[6] + o * s[10];
        }, ConchVector3.transformCoordinate = function(e, t, n) {
            var i = e.elements, r = i[0], a = i[1], o = i[2], s = t.elements, l = r * s[3] + a * s[7] + o * s[11] + s[15], h = n.elements;
            h[0] = r * s[0] + a * s[4] + o * s[8] + s[12] / l, h[1] = r * s[1] + a * s[5] + o * s[9] + s[13] / l, 
            h[2] = r * s[2] + a * s[6] + o * s[10] + s[14] / l;
        }, ConchVector3.Clamp = function(e, t, n, i) {
            var r = e.elements, a = r[0], o = r[1], s = r[2], l = t.elements, h = l[0], u = l[1], c = l[2], d = n.elements, _ = d[0], f = d[1], m = d[2], p = i.elements;
            a = (a = a > _ ? _ : a) < h ? h : a, o = (o = o > f ? f : o) < u ? u : o, s = (s = s > m ? m : s) < c ? c : s, 
            p[0] = a, p[1] = o, p[2] = s;
        }, ConchVector3.add = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] + a[0], i[1] = r[1] + a[1], i[2] = r[2] + a[2];
        }, ConchVector3.subtract = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements;
            i[0] = r[0] - a[0], i[1] = r[1] - a[1], i[2] = r[2] - a[2];
        }, ConchVector3.cross = function(e, t, n) {
            var i = e.elements, r = t.elements, a = n.elements, o = i[0], s = i[1], l = i[2], h = r[0], u = r[1], c = r[2];
            a[0] = s * c - l * u, a[1] = l * h - o * c, a[2] = o * u - s * h;
        }, ConchVector3.dot = function(e, t) {
            var n = e.elements, i = t.elements;
            return n[0] * i[0] + n[1] * i[1] + n[2] * i[2];
        }, ConchVector3.equals = function(e, t) {
            var n = e.elements, i = t.elements;
            return ie.nearEqual(n[0], i[0]) && ie.nearEqual(n[1], i[1]) && ie.nearEqual(n[2], i[2]);
        }, ConchVector3.ZERO = new ConchVector3(0, 0, 0), ConchVector3.ONE = new ConchVector3(1, 1, 1), 
        ConchVector3.NegativeUnitX = new ConchVector3(-1, 0, 0), ConchVector3.UnitX = new ConchVector3(1, 0, 0), 
        ConchVector3.UnitY = new ConchVector3(0, 1, 0), ConchVector3.UnitZ = new ConchVector3(0, 0, 1), 
        ConchVector3.ForwardRH = new ConchVector3(0, 0, -1), ConchVector3.ForwardLH = new ConchVector3(0, 0, 1), 
        ConchVector3.Up = new ConchVector3(0, 1, 0), ConchVector3.NAN = new ConchVector3(NaN, NaN, NaN), 
        i(ConchVector3, [ "_tempVector4", function() {
            return this._tempVector4 = new z();
        } ]), ConchVector3;
    }(), H = function() {
        function ColorOverLifetime(e) {
            this._color = null, this.enbale = !1, this._color = e;
        }
        r(ColorOverLifetime, "laya.d3.core.particleShuriKen.module.ColorOverLifetime");
        var e = ColorOverLifetime.prototype;
        return e.cloneTo = function(e) {
            var t = e;
            this._color.cloneTo(t._color), t.enbale = this.enbale;
        }, e.clone = function() {
            var e;
            switch (this._color.type) {
              case 0:
                e = re.createByConstant(this._color.constant.clone());
                break;

              case 1:
                e = re.createByGradient(this._color.gradient.clone());
                break;

              case 2:
                e = re.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                break;

              case 3:
                e = re.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
            }
            var t = new this.constructor(e);
            return t.enbale = this.enbale, t;
        }, a(0, e, "color", function() {
            return this._color;
        }), ColorOverLifetime;
    }(), k = function() {
        function BaseShape() {
            this.enable = !1, this.randomDirection = !1;
        }
        r(BaseShape, "laya.d3.core.particleShuriKen.module.shape.BaseShape");
        var e = BaseShape.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e._getShapeBoundBox = function(e) {
            throw new Error("BaseShape: must override it.");
        }, e._getSpeedBoundBox = function(e) {
            throw new Error("BaseShape: must override it.");
        }, e.generatePositionAndDirection = function(e, t, n, i) {
            throw new Error("BaseShape: must override it.");
        }, e._calculateProceduralBounds = function(e, t, n) {
            this._getShapeBoundBox(e);
            var i = e.min, r = e.max;
            Te.multiply(i, t, i), Te.multiply(r, t, r);
            var a = new zt(new Te(), new Te());
            this.randomDirection ? (a.min = new Te(-1, -1, -1), a.max = new Te(1, 1, 1)) : this._getSpeedBoundBox(a);
            var o = new zt(new Te(), new Te()), s = o.min, l = o.max;
            Te.scale(a.min, n.y, s), Te.scale(a.max, n.y, l), Te.add(e.min, s, s), Te.add(e.max, l, l), 
            Te.min(e.min, s, e.min), Te.max(e.max, s, e.max);
            var h = new zt(new Te(), new Te()), u = h.min, c = h.max;
            Te.scale(a.min, n.x, u), Te.scale(a.max, n.x, c), Te.min(h.min, c, s), Te.max(h.min, c, l), 
            Te.min(e.min, s, e.min), Te.max(e.max, s, e.max);
        }, e.cloneTo = function(e) {
            e.enable = this.enable;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, BaseShape;
    }(), W = function() {
        function ColliderShape() {
            this._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null, 
            this._referenceCount = 0, this.needsCustomCollisionCallback = !1, this._scale = new Te(1, 1, 1), 
            this._centerMatrix = new Ht(), this._localOffset = new Te(0, 0, 0), this._localRotation = new he(0, 0, 0, 1);
        }
        r(ColliderShape, "laya.d3.physics.shape.ColliderShape");
        var e = ColliderShape.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e._setScale = function(e) {
            this._compoundParent ? this.updateLocalTransformations() : (ColliderShape._nativeScale.setValue(e.x, e.y, e.z), 
            this._nativeShape.setLocalScaling(ColliderShape._nativeScale));
        }, e._addReference = function() {
            this._referenceCount++;
        }, e._removeReference = function() {
            this._referenceCount--;
        }, e.updateLocalTransformations = function() {
            if (this._compoundParent) {
                var e = ColliderShape._tempVector30;
                Te.multiply(this.localOffset, this._scale, e), ColliderShape._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
            } else ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
        }, e.cloneTo = function(e) {
            var t = e;
            this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation), 
            t.localOffset = t.localOffset, t.localRotation = t.localRotation;
        }, e.clone = function() {
            return null;
        }, e.destroy = function() {
            this._nativeShape && (X._physics3D.destroy(this._nativeShape), this._nativeShape = null);
        }, a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "localOffset", function() {
            return this._localOffset;
        }, function(e) {
            this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }), a(0, e, "localRotation", function() {
            return this._localRotation;
        }, function(e) {
            this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }), ColliderShape._creatShape = function(e) {
            var t;
            switch (e.type) {
              case "BoxColliderShape":
                var n = e.size;
                t = n ? new hn(n[0], n[1], n[2]) : new hn();
                break;

              case "SphereColliderShape":
                t = new en(e.radius);
                break;

              case "CapsuleColliderShape":
                t = new an(e.radius, e.height, e.orientation);
                break;

              case "MeshColliderShape":
                var i = new yn();
                e.mesh && (i.mesh = g.getRes(e.mesh)), t = i;
                break;

              case "ConeColliderShape":
                t = new On(e.radius, e.height, e.orientation);
                break;

              case "CylinderColliderShape":
                t = new pn(e.radius, e.height, e.orientation);
                break;

              default:
                throw "unknown shape type.";
            }
            if (e.center) {
                var r = t.localOffset;
                r.fromArray(e.center), t.localOffset = r;
            }
            return t;
        }, ColliderShape._createAffineTransformation = function(e, t, n) {
            var i = t.x, r = t.y, a = t.z, o = t.w, s = i + i, l = r + r, h = a + a, u = i * s, c = i * l, d = i * h, _ = r * l, f = r * h, m = a * h, p = o * s, T = o * l, S = o * h;
            n[0] = 1 - (_ + m), n[1] = c + S, n[2] = d - T, n[3] = 0, n[4] = c - S, n[5] = 1 - (u + m), 
            n[6] = f + p, n[7] = 0, n[8] = d + T, n[9] = f - p, n[10] = 1 - (u + _), n[11] = 0, 
            n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1;
        }, ColliderShape.SHAPEORIENTATION_UPX = 0, ColliderShape.SHAPEORIENTATION_UPY = 1, 
        ColliderShape.SHAPEORIENTATION_UPZ = 2, ColliderShape.SHAPETYPES_BOX = 0, ColliderShape.SHAPETYPES_SPHERE = 1, 
        ColliderShape.SHAPETYPES_CYLINDER = 2, ColliderShape.SHAPETYPES_CAPSULE = 3, ColliderShape.SHAPETYPES_CONVEXHULL = 4, 
        ColliderShape.SHAPETYPES_COMPOUND = 5, ColliderShape.SHAPETYPES_STATICPLANE = 6, 
        ColliderShape.SHAPETYPES_CONE = 7, i(ColliderShape, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_nativeScale", function() {
            return this._nativeScale = new X._physics3D.btVector3(1, 1, 1);
        }, "_nativeVector30", function() {
            return this._nativeVector30 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativQuaternion0", function() {
            return this._nativQuaternion0 = new X._physics3D.btQuaternion(0, 0, 0, 1);
        }, "_nativeTransform0", function() {
            return this._nativeTransform0 = new X._physics3D.btTransform();
        } ]), ColliderShape;
    }(), X = function() {
        function Laya3D() {}
        return r(Laya3D, "Laya3D"), a(1, Laya3D, "enbalePhysics", function() {
            return Laya3D._enbalePhysics;
        }), Laya3D._cancelLoadByUrl = function(e) {
            n.loader.cancelLoadByUrl(e), Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(e), 
            Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(e), Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(e), 
            Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
        }, Laya3D._changeWebGLSize = function(e, t) {
            b.onStageResize(e, t), J.clientWidth = e, J.clientHeight = t;
        }, Laya3D.__init__ = function(e, t, i) {
            if (m.isAntialias = i.isAntialias, m.isAlpha = i.isAlpha, m.premultipliedAlpha = i.premultipliedAlpha, 
            m.isStencil = i.isStencil, b.enable()) {
                I.changeWebGLSize = Laya3D._changeWebGLSize, R.is3DMode = !0, n.init(e, t), R.supportWebGLPlusRendering || (E.instance = b.mainContext, 
                E.instance.createCommandEncoder = function(e, t, n) {
                    return void 0 === e && (e = 128), void 0 === t && (t = 64), void 0 === n && (n = !1), 
                    new _(this, e, t, n);
                }), Laya3D.enableNative3D(), bn.__init__(), Jn.__init__(), Si.__init__(), yi.__init__(), 
                xi.__init__(), Fn.__init__(), ci.__init__(), oi.__init__(), fi.__init__(), ii.__init__(), 
                $n.__init__(), gi.__init__(), ni.__init__(), li.__init__(), hi.__init__(), si.__init__(), 
                di.__init__(), ui.__init__(), He.__init__(), ri.defaultMaterial.lock = !0, ci.defaultMaterial.lock = !0, 
                li.defaultMaterial.lock = !0, oi.defaultMaterial.lock = !0, fi.defaultMaterial.lock = !0, 
                $n.defaultMaterial.lock = !0, si.defaultMaterial.lock = !0, ni.defaultMaterial.lock = !0, 
                ii.defaultMaterial.lock = !0, _i.defaultMaterial.lock = !0, hi.defaultMaterial.lock = !0, 
                B.__init__(), Ti.__init__(), Mn.__init__(), Ln.__init__(), Un.__init__(), Rt.__init__(), 
                Bt.__init__(), Ae.__init__();
                var r = x.createMap;
                r.lh = [ "HIERARCHY", bn._parse ], r.ls = [ "HIERARCHY", qn._parse ], r.lm = [ "MESH", Gn._parse ], 
                r.lmat = [ "MATERIAL", Fn._parse ], r.ltc = [ "TEXTURECUBE", Ti._parse ], r.jpg = [ "TEXTURE2D", B._parse ], 
                r.jpeg = [ "TEXTURE2D", B._parse ], r.bmp = [ "TEXTURE2D", B._parse ], r.gif = [ "TEXTURE2D", B._parse ], 
                r.png = [ "TEXTURE2D", B._parse ], r.dds = [ "TEXTURE2D", B._parse ], r.ktx = [ "TEXTURE2D", B._parse ], 
                r.pvr = [ "TEXTURE2D", B._parse ], r.lani = [ "ANIMATIONCLIP", kn._parse ], r.lav = [ "AVATAR", zn._parse ], 
                r.thdata = [ "TERRAINHEIGHTDATA", Hn._pharse ];
                var a = g.parserMap;
                a.HIERARCHY = Laya3D._loadHierarchy, a.MESH = Laya3D._loadMesh, a.MATERIAL = Laya3D._loadMaterial, 
                a.TEXTURECUBE = Laya3D._loadTextureCube, a.TEXTURE2D = Laya3D._loadTexture2D, a.ANIMATIONCLIP = Laya3D._loadAnimationClip, 
                a.AVATAR = Laya3D._loadAvatar, Laya3D._innerFirstLevelLoaderManager.on("error", null, Laya3D._eventLoadManagerError), 
                Laya3D._innerSecondLevelLoaderManager.on("error", null, Laya3D._eventLoadManagerError), 
                Laya3D._innerThirdLevelLoaderManager.on("error", null, Laya3D._eventLoadManagerError), 
                Laya3D._innerFourthLevelLoaderManager.on("error", null, Laya3D._eventLoadManagerError);
            } else alert("Laya3D init error,must support webGL!");
        }, Laya3D.enableNative3D = function() {
            if (R.isConchApp) {
                E = e.LayaGLContext;
                var t = ue, n = Wn, i = zn, r = Bt, a = Kn;
                if (R.supportWebGLPlusRendering && (t.prototype._initData = t.prototype._initDataForNative, 
                t.prototype.setBool = t.prototype.setBoolForNative, t.prototype.getBool = t.prototype.getBoolForNative, 
                t.prototype.setInt = t.prototype.setIntForNative, t.prototype.getInt = t.prototype.getIntForNative, 
                t.prototype.setNumber = t.prototype.setNumberForNative, t.prototype.getNumber = t.prototype.getNumberForNative, 
                t.prototype.setVector = t.prototype.setVectorForNative, t.prototype.getVector = t.prototype.getVectorForNative, 
                t.prototype.setVector2 = t.prototype.setVector2ForNative, t.prototype.getVector2 = t.prototype.getVector2ForNative, 
                t.prototype.setVector3 = t.prototype.setVector3ForNative, t.prototype.getVector3 = t.prototype.getVector3ForNative, 
                t.prototype.setQuaternion = t.prototype.setQuaternionForNative, t.prototype.getQuaternion = t.prototype.getQuaternionForNative, 
                t.prototype.setMatrix4x4 = t.prototype.setMatrix4x4ForNative, t.prototype.getMatrix4x4 = t.prototype.getMatrix4x4ForNative, 
                t.prototype.setBuffer = t.prototype.setBufferForNative, t.prototype.getBuffer = t.prototype.getBufferForNative, 
                t.prototype.setTexture = t.prototype.setTextureForNative, t.prototype.getTexture = t.prototype.getTextureForNative, 
                t.prototype.setAttribute = t.prototype.setAttributeForNative, t.prototype.getAttribute = t.prototype.getAttributeForNative, 
                t.prototype.cloneTo = t.prototype.cloneToForNative, t.prototype.getData = t.prototype.getDataForNative, 
                n.prototype._uniformMatrix2fv = n.prototype._uniformMatrix2fvForNative, n.prototype._uniformMatrix3fv = n.prototype._uniformMatrix3fvForNative, 
                n.prototype._uniformMatrix4fv = n.prototype._uniformMatrix4fvForNative, a.prototype._renderUpdateWithCamera = a.prototype._renderUpdateWithCameraForNative), 
                R.supportWebGLPlusCulling && (r.renderObjectCulling = Bt.renderObjectCullingNative), 
                R.supportWebGLPlusAnimation) {
                    i.prototype._cloneDatasToAnimator = i.prototype._cloneDatasToAnimatorNative, Tn = e.conchFloatKeyframe, 
                    An = e.conchFloatArrayKeyframe, Vn = e.conchFloatArrayKeyframe, gt = e.conchKeyframeNode, 
                    qe = e.conchKeyframeNodeList;
                    var o = kn;
                    o.prototype._evaluateClipDatasRealTime = o.prototype._evaluateClipDatasRealTimeForNative;
                }
            }
            b.shaderHighPrecision = !1, E.instance.getShaderPrecisionFormat(35632, 36338).precision ? b.shaderHighPrecision = !0 : b.shaderHighPrecision = !1;
        }, Laya3D.formatRelativePath = function(e, t) {
            var n;
            if (n = e + t, "." === t.charAt(0)) {
                for (var i = n.split("/"), r = 0, a = i.length; r < a; r++) if (".." == i[r]) {
                    var o = r - 1;
                    o > 0 && ".." !== i[o] && (i.splice(o, 2), r -= 2);
                }
                n = i.join("/");
            }
            return n;
        }, Laya3D._endLoad = function(e, t, n) {
            if (n) for (var i = 0, r = n.length; i < r; i++) {
                var a = g.getRes(n[i]);
                a && a._removeReference();
            }
            e.endLoad(t);
        }, Laya3D._eventLoadManagerError = function(e) {
            n.loader.event("error", e);
        }, Laya3D._addHierarchyInnerUrls = function(e, t, n, i, r, a, o, s) {
            var l = Laya3D.formatRelativePath(i, r);
            return n && (l += n), e.push({
                url: l,
                type: a,
                constructParams: o,
                propertyParams: s
            }), t.push(l), l;
        }, Laya3D._getSprite3DHierarchyInnerUrls = function(e, t, n, i, r, a, o, s) {
            var l = 0, h = 0, u = e.props;
            switch (e.type) {
              case "Scene3D":
                var c = u.lightmaps;
                for (l = 0, h = c.length; l < h; l++) {
                    var d = c[l];
                    d.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, d.path, "TEXTURE2D", d.constructParams, d.propertyParams);
                }
                var _ = u.reflectionTexture;
                if (_ && (u.reflectionTexture = Laya3D._addHierarchyInnerUrls(i, a, o, s, _, "TEXTURECUBE")), 
                u.sky) {
                    var f = u.sky.material;
                    f && (f.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, f.path, "MATERIAL"));
                }
                break;

              case "Camera":
                var m = u.skyboxMaterial;
                m && (m.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, m.path, "MATERIAL"));
                break;

              case "TrailSprite3D":
              case "MeshSprite3D":
              case "SkinnedMeshSprite3D":
                var p = u.meshPath;
                p && (u.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, p, "MESH"));
                var T = u.materials;
                if (T) for (l = 0, h = T.length; l < h; l++) T[l].path = Laya3D._addHierarchyInnerUrls(n, a, o, s, T[l].path, "MATERIAL");
                break;

              case "ShuriKenParticle3D":
                var S = u.meshPath;
                S && (u.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, "MESH")), u.material.path = Laya3D._addHierarchyInnerUrls(n, a, o, s, u.material.path, "MATERIAL");
                break;

              case "Terrain":
                Laya3D._addHierarchyInnerUrls(r, a, o, s, u.dataPath, "TERRAIN");
            }
            var E = e.components;
            if (E) for (var v = 0, g = E.length; v < g; v++) {
                var x = E[v];
                switch (x.type) {
                  case "Animator":
                    x.avatarPath;
                    var M = x.avatar;
                    M && (M.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, M.path, "AVATAR"));
                    var y = x.clipPaths;
                    if (y) for (l = 0, h = y.length; l < h; l++) y[l] = Laya3D._addHierarchyInnerUrls(r, a, o, s, y[l], "ANIMATIONCLIP"); else {
                        var D = x.layers;
                        for (l = 0; l < D.length; l++) for (var R = D[l].states, C = 0, I = R.length; C < I; C++) {
                            var A = R[C].clipPath;
                            A && (R[C].clipPath = Laya3D._addHierarchyInnerUrls(r, a, o, s, A, "ANIMATIONCLIP"));
                        }
                    }
                    break;

                  case "PhysicsCollider":
                  case "Rigidbody3D":
                  case "CharacterController":
                    var L = x.shapes;
                    for (l = 0; l < L.length; l++) {
                        var O = L[l];
                        if ("MeshColliderShape" === O.type) {
                            var P = O.mesh;
                            P && (O.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, P, "MESH"));
                        }
                    }
                }
            }
            var V = e.child;
            for (l = 0, h = V.length; l < h; l++) Laya3D._getSprite3DHierarchyInnerUrls(V[l], t, n, i, r, a, o, s);
        }, Laya3D._loadHierarchy = function(e) {
            e.on("loaded", null, Laya3D._onHierarchylhLoaded, [ e ]), e.load(e.url, "json", !1, null, !0);
        }, Laya3D._onHierarchylhLoaded = function(e, t) {
            var n = e.url, i = ke.getURLVerion(n), r = w.getPath(n), a = [], o = [], s = [], l = [], h = [];
            Laya3D._getSprite3DHierarchyInnerUrls(t.data, a, o, s, l, h, i, r);
            var u = a.length + o.length + l.length, c = u + 1, d = 1 / c;
            if (Laya3D._onProcessChange(e, 0, d, 1), l.length > 0) {
                var _ = u / c, f = S.create(null, Laya3D._onProcessChange, [ e, d, _ ], !1);
                Laya3D._innerFourthLevelLoaderManager._create(l, !1, S.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [ e, f, t, h, a, o, s, d + _ * l.length, _ ]), f, null, null, null, 1, !0);
            } else Laya3D._onHierarchyInnerForthLevResouLoaded(e, null, t, h, a, o, s, d, _);
        }, Laya3D._onHierarchyInnerForthLevResouLoaded = function(e, t, n, i, r, a, o, s, l) {
            if (t && t.recover(), o.length > 0) {
                var h = S.create(null, Laya3D._onProcessChange, [ e, s, l ], !1);
                Laya3D._innerThirdLevelLoaderManager._create(o, !1, S.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [ e, h, n, i, r, a, s + l * a.length, l ]), t, null, null, null, 1, !0);
            } else Laya3D._onHierarchyInnerThirdLevResouLoaded(e, null, n, i, r, a, s, l);
        }, Laya3D._onHierarchyInnerThirdLevResouLoaded = function(e, t, n, i, r, a, o, s) {
            if (t && t.recover(), a.length > 0) {
                var l = S.create(null, Laya3D._onProcessChange, [ e, o, s ], !1);
                Laya3D._innerSecondLevelLoaderManager._create(a, !1, S.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [ e, l, n, i, r, o + s * a.length, s ]), t, null, null, null, 1, !0);
            } else Laya3D._onHierarchyInnerSecondLevResouLoaded(e, null, n, i, r, o, s);
        }, Laya3D._onHierarchyInnerSecondLevResouLoaded = function(e, t, n, i, r, a, o) {
            if (t && t.recover(), r.length > 0) {
                var s = S.create(null, Laya3D._onProcessChange, [ e, a, o ], !1);
                Laya3D._innerFirstLevelLoaderManager._create(r, !1, S.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [ e, s, n, i ]), t, null, null, null, 1, !0);
            } else Laya3D._onHierarchyInnerFirstLevResouLoaded(e, null, n, i);
        }, Laya3D._onHierarchyInnerFirstLevResouLoaded = function(e, t, n, i) {
            t && t.recover(), e._cache = e._createCache;
            var r = "Scene3D" === n.data.type ? qn._parse(n, e._propertyParams, e._constructParams) : bn._parse(n, e._propertyParams, e._constructParams);
            Laya3D._endLoad(e, r, i);
        }, Laya3D._loadMesh = function(e) {
            e.on("loaded", null, Laya3D._onMeshLmLoaded, [ e ]), e.load(e.url, "arraybuffer", !1, null, !0);
        }, Laya3D._onMeshLmLoaded = function(e, t) {
            e._cache = e._createCache;
            var n = Gn._parse(t, e._propertyParams, e._constructParams);
            Laya3D._endLoad(e, n);
        }, Laya3D._loadMaterial = function(e) {
            e.on("loaded", null, Laya3D._onMaterilLmatLoaded, [ e ]), e.load(e.url, "json", !1, null, !0);
        }, Laya3D._onMaterilLmatLoaded = function(e, t) {
            var n, i = e.url, r = ke.getURLVerion(i), a = w.getPath(i), o = [], s = [];
            t.customProps;
            switch (t.version) {
              case "LAYAMATERIAL:01":
              case "LAYAMATERIAL:02":
                var l = 0, h = 0, u = t.props.textures;
                if (u) for (l = 0, h = u.length; l < h; l++) {
                    var c = u[l], d = c.path;
                    d && (n = Laya3D.formatRelativePath(a, d), r && (n += r), o.push({
                        url: n,
                        constructParams: c.constructParams,
                        propertyParams: c.propertyParams
                    }), s.push(n), c.path = n);
                }
                break;

              default:
                throw new Error("Laya3D:unkonwn version.");
            }
            var _ = o.length, f = _ + 1, m = 1 / f;
            if (Laya3D._onProcessChange(e, 0, m, 1), _ > 0) {
                var p = S.create(null, Laya3D._onProcessChange, [ e, m, _ / f ], !1);
                Laya3D._innerFourthLevelLoaderManager._create(o, !1, S.create(null, Laya3D._onMateialTexturesLoaded, [ e, p, t, s ]), p, null, null, null, 1, !0);
            } else Laya3D._onMateialTexturesLoaded(e, null, t, null);
        }, Laya3D._onMateialTexturesLoaded = function(e, t, n, i) {
            e._cache = e._createCache;
            var r = Fn._parse(n, e._propertyParams, e._constructParams);
            Laya3D._endLoad(e, r, i), t && t.recover();
        }, Laya3D._loadAvatar = function(e) {
            e.on("loaded", null, function(t) {
                e._cache = e._createCache;
                var n = zn._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, n);
            }), e.load(e.url, "json", !1, null, !0);
        }, Laya3D._loadAnimationClip = function(e) {
            e.on("loaded", null, function(t) {
                e._cache = e._createCache;
                var n = kn._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, n);
            }), e.load(e.url, "arraybuffer", !1, null, !0);
        }, Laya3D._loadTexture2D = function(e) {
            var t, n = e.url, i = n.lastIndexOf(".") + 1, r = n.indexOf("?"), a = -1 == r ? n.length : r;
            switch (n.substr(i, a - i)) {
              case "jpg":
              case "jpeg":
              case "bmp":
              case "gif":
              case "png":
                t = "nativeimage";
                break;

              case "dds":
              case "ktx":
              case "pvr":
                t = "arraybuffer";
            }
            e.on("loaded", null, function(t) {
                e._cache = e._createCache;
                var n = B._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, n);
            }), e.load(e.url, t, !1, null, !0);
        }, Laya3D._loadTextureCube = function(e) {
            e.on("loaded", null, Laya3D._onTextureCubeLtcLoaded, [ e ]), e.load(e.url, "json", !1, null, !0);
        }, Laya3D._onTextureCubeLtcLoaded = function(e, t) {
            var n = w.getPath(e.url), i = [ Laya3D.formatRelativePath(n, t.front), Laya3D.formatRelativePath(n, t.back), Laya3D.formatRelativePath(n, t.left), Laya3D.formatRelativePath(n, t.right), Laya3D.formatRelativePath(n, t.up), Laya3D.formatRelativePath(n, t.down) ];
            Laya3D._onProcessChange(e, 0, 1 / 7, 1);
            var r = S.create(null, Laya3D._onProcessChange, [ e, 1 / 7, 6 / 7 ], !1);
            Laya3D._innerFourthLevelLoaderManager.load(i, S.create(null, Laya3D._onTextureCubeImagesLoaded, [ e, i, r ]), r, "nativeimage");
        }, Laya3D._onTextureCubeImagesLoaded = function(e, t, n) {
            for (var i = new Array(6), r = 0; r < 6; r++) i[r] = g.getRes(t[r]);
            e._cache = e._createCache;
            var a = Ti._parse(i, e._propertyParams, e._constructParams);
            for (n.recover(), r = 0; r < 6; r++) g.clearRes(t[r]);
            Laya3D._endLoad(e, a);
        }, Laya3D._onProcessChange = function(e, t, n, i) {
            (i = t + i * n) < 1 && e.event("progress", i);
        }, Laya3D.init = function(t, n, i, r) {
            if (!Laya3D._isInit) {
                Laya3D._isInit = !0, (i = i || ut._default).cloneTo(Laya3D._config), Laya3D._editerEnvironment = Laya3D._config._editerEnvironment;
                var a = e.Physics3D;
                null == a ? (Laya3D._enbalePhysics = !1, Laya3D.__init__(t, n, Laya3D._config), 
                r && r.run()) : (Laya3D._enbalePhysics = !0, a(1024 * Laya3D._config.defaultPhysicsMemory * 1024).then(function() {
                    Laya3D.__init__(t, n, Laya3D._config), r && r.run();
                }));
            }
        }, Laya3D.HIERARCHY = "HIERARCHY", Laya3D.MESH = "MESH", Laya3D.MATERIAL = "MATERIAL", 
        Laya3D.TEXTURE2D = "TEXTURE2D", Laya3D.TEXTURECUBE = "TEXTURECUBE", Laya3D.ANIMATIONCLIP = "ANIMATIONCLIP", 
        Laya3D.AVATAR = "AVATAR", Laya3D.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Laya3D.TERRAINRES = "TERRAIN", 
        Laya3D._isInit = !1, Laya3D._enbalePhysics = !1, Laya3D._editerEnvironment = !1, 
        i(Laya3D, [ "_innerFirstLevelLoaderManager", function() {
            return this._innerFirstLevelLoaderManager = new x();
        }, "_innerSecondLevelLoaderManager", function() {
            return this._innerSecondLevelLoaderManager = new x();
        }, "_innerThirdLevelLoaderManager", function() {
            return this._innerThirdLevelLoaderManager = new x();
        }, "_innerFourthLevelLoaderManager", function() {
            return this._innerFourthLevelLoaderManager = new x();
        }, "_physics3D", function() {
            return this._physics3D = e.Physics3D;
        }, "_config", function() {
            return this._config = new ut();
        }, "physicsSettings", function() {
            return this.physicsSettings = new ae();
        } ]), Laya3D;
    }(), Y = function() {
        function FrameOverTime() {
            this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0, 
            this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
        }
        r(FrameOverTime, "laya.d3.core.particleShuriKen.module.FrameOverTime");
        var e = FrameOverTime.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, this._overTime.cloneTo(t._overTime), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin.cloneTo(t._overTimeMin), 
            this._overTimeMax.cloneTo(t._overTimeMax);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "frameOverTimeData", function() {
            return this._overTime;
        }), a(0, e, "constant", function() {
            return this._constant;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "frameOverTimeDataMin", function() {
            return this._overTimeMin;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "frameOverTimeDataMax", function() {
            return this._overTimeMax;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), FrameOverTime.createByConstant = function(e) {
            var t = new FrameOverTime();
            return t._type = 0, t._constant = e, t;
        }, FrameOverTime.createByOverTime = function(e) {
            var t = new FrameOverTime();
            return t._type = 1, t._overTime = e, t;
        }, FrameOverTime.createByRandomTwoConstant = function(e, t) {
            var n = new FrameOverTime();
            return n._type = 2, n._constantMin = e, n._constantMax = t, n;
        }, FrameOverTime.createByRandomTwoOverTime = function(e, t) {
            var n = new FrameOverTime();
            return n._type = 3, n._overTimeMin = e, n._overTimeMax = t, n;
        }, FrameOverTime;
    }(), Z = function() {
        function RenderState() {
            this.cull = 0, this.blend = 0, this.srcBlend = 0, this.dstBlend = 0, this.srcBlendRGB = 0, 
            this.dstBlendRGB = 0, this.srcBlendAlpha = 0, this.dstBlendAlpha = 0, this.blendConstColor = null, 
            this.blendEquation = 0, this.blendEquationRGB = 0, this.blendEquationAlpha = 0, 
            this.depthTest = 0, this.depthWrite = !1, this.cull = 2, this.blend = 0, this.srcBlend = 1, 
            this.dstBlend = 0, this.srcBlendRGB = 1, this.dstBlendRGB = 0, this.srcBlendAlpha = 1, 
            this.dstBlendAlpha = 0, this.blendConstColor = new me(1, 1, 1, 1), this.blendEquation = 0, 
            this.blendEquationRGB = 0, this.blendEquationAlpha = 0, this.depthTest = 515, this.depthWrite = !0;
        }
        r(RenderState, "laya.d3.core.material.RenderState");
        var e = RenderState.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend, 
            t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha, 
            t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor), 
            t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB, 
            t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, RenderState.CULL_NONE = 0, RenderState.CULL_FRONT = 1, RenderState.CULL_BACK = 2, 
        RenderState.BLEND_DISABLE = 0, RenderState.BLEND_ENABLE_ALL = 1, RenderState.BLEND_ENABLE_SEPERATE = 2, 
        RenderState.BLENDPARAM_ZERO = 0, RenderState.BLENDPARAM_ONE = 1, RenderState.BLENDPARAM_SRC_COLOR = 768, 
        RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, RenderState.BLENDPARAM_DST_COLOR = 774, 
        RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = 775, RenderState.BLENDPARAM_SRC_ALPHA = 770, 
        RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, RenderState.BLENDPARAM_DST_ALPHA = 772, 
        RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = 776, 
        RenderState.BLENDEQUATION_ADD = 0, RenderState.BLENDEQUATION_SUBTRACT = 1, RenderState.BLENDEQUATION_REVERSE_SUBTRACT = 2, 
        RenderState.DEPTHTEST_OFF = 0, RenderState.DEPTHTEST_NEVER = 512, RenderState.DEPTHTEST_LESS = 513, 
        RenderState.DEPTHTEST_EQUAL = 514, RenderState.DEPTHTEST_LEQUAL = 515, RenderState.DEPTHTEST_GREATER = 516, 
        RenderState.DEPTHTEST_NOTEQUAL = 517, RenderState.DEPTHTEST_GEQUAL = 518, RenderState.DEPTHTEST_ALWAYS = 519, 
        RenderState;
    }(), K = function() {
        function Ray(e, t) {
            this.origin = null, this.direction = null, this.origin = e, this.direction = t;
        }
        return r(Ray, "laya.d3.math.Ray"), Ray;
    }(), Q = function() {
        function ContactPoint() {
            this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0, 
            this.normal = new Te(), this.positionOnA = new Te(), this.positionOnB = new Te(), 
            this._id = ++this._idCounter;
        }
        return r(ContactPoint, "laya.d3.physics.ContactPoint"), ContactPoint;
    }(), j = function() {
        function StaticBatchManager() {
            this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0, 
            this._batchRenderElementPool = [];
        }
        r(StaticBatchManager, "laya.d3.graphics.StaticBatchManager");
        var e = StaticBatchManager.prototype;
        return e._partition = function(e, t, n) {
            for (var i = e[Math.floor((n + t) / 2)]; t <= n; ) {
                for (;this._compare(e[t], i) < 0; ) t++;
                for (;this._compare(e[n], i) > 0; ) n--;
                if (t < n) {
                    var r = e[t];
                    e[t] = e[n], e[n] = r, t++, n--;
                } else if (t === n) {
                    t++;
                    break;
                }
            }
            return t;
        }, e._quickSort = function(e, t, n) {
            if (e.length > 1) {
                var i = this._partition(e, t, n), r = i - 1;
                t < r && this._quickSort(e, t, r), i < n && this._quickSort(e, i, n);
            }
        }, e._compare = function(e, t) {
            throw "StaticBatch:must override this function.";
        }, e._initStaticBatchs = function(e) {
            throw "StaticBatch:must override this function.";
        }, e._getBatchRenderElementFromPool = function() {
            throw "StaticBatch:must override this function.";
        }, e._addBatchSprite = function(e) {
            this._initBatchSprites.push(e);
        }, e._clear = function() {
            this._batchRenderElementPoolIndex = 0;
        }, e._garbageCollection = function() {
            throw "StaticBatchManager: must override it.";
        }, e.dispose = function() {
            this._staticBatches = null;
        }, StaticBatchManager._registerManager = function(e) {
            StaticBatchManager._managers.push(e);
        }, StaticBatchManager._addToStaticBatchQueue = function(e, t) {
            e instanceof laya.d3.core.RenderableSprite3D && e.isStatic && t.push(e);
            for (var n = 0, i = e.numChildren; n < i; n++) StaticBatchManager._addToStaticBatchQueue(e._children[n], t);
        }, StaticBatchManager.combine = function(e, t) {
            t || (t = [], e && StaticBatchManager._addToStaticBatchQueue(e, t));
            var n = t.length;
            if (n > 0) {
                for (var i = 0; i < n; i++) {
                    var r = t[i];
                    r.isStatic && r._addToInitStaticBatchManager();
                }
                for (var a = 0, o = StaticBatchManager._managers.length; a < o; a++) {
                    StaticBatchManager._managers[a]._initStaticBatchs(e);
                }
            }
        }, StaticBatchManager._managers = [], StaticBatchManager;
    }(), q = function() {
        function Command() {}
        r(Command, "laya.d3.core.render.command.Command");
        var e = Command.prototype;
        return e.run = function() {}, e.recover = function() {}, Command;
    }(), J = function() {
        function RenderContext3D() {}
        return r(RenderContext3D, "laya.d3.core.render.RenderContext3D"), RenderContext3D.clientWidth = 0, 
        RenderContext3D.clientHeight = 0, i(RenderContext3D, [ "_instance", function() {
            return this._instance = new RenderContext3D();
        } ]), RenderContext3D;
    }(), $ = (function() {
        function GradientMode() {}
        r(GradientMode, "laya.d3.core.GradientMode"), GradientMode.Blend = 0, GradientMode.Fixed = 1;
    }(), function() {
        function SingletonList() {
            this.length = 0, this.elements = [];
        }
        return r(SingletonList, "laya.d3.component.SingletonList"), SingletonList.prototype._add = function(e) {
            this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
        }, SingletonList;
    }()), ee = function() {
        function DynamicBatchManager() {
            this._batchRenderElementPool = [];
        }
        r(DynamicBatchManager, "laya.d3.graphics.DynamicBatchManager");
        var e = DynamicBatchManager.prototype;
        return e._clear = function() {
            this._batchRenderElementPoolIndex = 0;
        }, e._getBatchRenderElementFromPool = function() {
            throw "StaticBatch:must override this function.";
        }, e.dispose = function() {}, DynamicBatchManager._registerManager = function(e) {
            DynamicBatchManager._managers.push(e);
        }, DynamicBatchManager._managers = [], DynamicBatchManager;
    }(), te = (function() {
        function Point2PointConstraint() {
            this._damping = NaN, this._impulseClamp = NaN, this._tau = NaN, this._pivotInA = new Te(), 
            this._pivotInB = new Te();
        }
        r(Point2PointConstraint, "laya.d3.physics.constraints.Point2PointConstraint");
        var e = Point2PointConstraint.prototype;
        a(0, e, "pivotInA", function() {
            return this._pivotInA;
        }, function(e) {
            this._pivotInA = e;
        }), a(0, e, "pivotInB", function() {
            return this._pivotInB;
        }, function(e) {
            this._pivotInB = e;
        }), a(0, e, "damping", function() {
            return this._damping;
        }, function(e) {
            this._damping = e;
        }), a(0, e, "impulseClamp", function() {
            return this._impulseClamp;
        }, function(e) {
            this._impulseClamp = e;
        }), a(0, e, "tau", function() {
            return this._tau;
        }, function(e) {
            this._tau = e;
        });
    }(), function() {
        function GeometryElement() {
            this._destroyed = !1;
        }
        r(GeometryElement, "laya.d3.core.GeometryElement");
        var e = GeometryElement.prototype;
        return n.imps(e, {
            "laya.resource.IDestroy": !0
        }), e._getType = function() {
            throw "GeometryElement:must override it.";
        }, e._prepareRender = function(e) {
            return !0;
        }, e._render = function(e) {
            throw "GeometryElement:must override it.";
        }, e.destroy = function() {
            this._destroyed || (this._destroyed = !0);
        }, a(0, e, "destroyed", function() {
            return this._destroyed;
        }), GeometryElement._typeCounter = 0, GeometryElement;
    }()), ne = function() {
        function VertexPositionTexture0(e, t) {
            this._position = null, this._textureCoordinate0 = null, this._position = e, this._textureCoordinate0 = t;
        }
        r(VertexPositionTexture0, "laya.d3.graphics.Vertex.VertexPositionTexture0");
        var e = VertexPositionTexture0.prototype;
        return n.imps(e, {
            "laya.d3.graphics.IVertex": !0
        }), a(0, e, "position", function() {
            return this._position;
        }), a(0, e, "textureCoordinate0", function() {
            return this._textureCoordinate0;
        }), a(0, e, "vertexDeclaration", function() {
            return VertexPositionTexture0._vertexDeclaration;
        }), a(1, VertexPositionTexture0, "vertexDeclaration", function() {
            return VertexPositionTexture0._vertexDeclaration;
        }), i(VertexPositionTexture0, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(20, [ new ze(0, "vector3", 0), new ze(12, "vector2", 2) ]);
        } ]), VertexPositionTexture0;
    }(), ie = function() {
        function MathUtils3D() {}
        return r(MathUtils3D, "laya.d3.math.MathUtils3D"), MathUtils3D.isZero = function(e) {
            return Math.abs(e) < MathUtils3D.zeroTolerance;
        }, MathUtils3D.nearEqual = function(e, t) {
            return !!MathUtils3D.isZero(e - t);
        }, MathUtils3D.fastInvSqrt = function(e) {
            return MathUtils3D.isZero(e) ? e : 1 / Math.sqrt(e);
        }, i(MathUtils3D, [ "zeroTolerance", function() {
            return this.zeroTolerance = 1e-6;
        }, "MaxValue", function() {
            return this.MaxValue = 3.40282347e38;
        }, "MinValue", function() {
            return this.MinValue = -3.40282347e38;
        } ]), MathUtils3D;
    }(), re = function() {
        function GradientColor() {
            this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null, 
            this._gradient = null, this._gradientMin = null, this._gradientMax = null;
        }
        r(GradientColor, "laya.d3.core.particleShuriKen.module.GradientColor");
        var e = GradientColor.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin), 
            this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient), 
            this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradient", function() {
            return this._gradient;
        }), a(0, e, "constant", function() {
            return this._constant;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "gradientMin", function() {
            return this._gradientMin;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "gradientMax", function() {
            return this._gradientMax;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), GradientColor.createByConstant = function(e) {
            var t = new GradientColor();
            return t._type = 0, t._constant = e, t;
        }, GradientColor.createByGradient = function(e) {
            var t = new GradientColor();
            return t._type = 1, t._gradient = e, t;
        }, GradientColor.createByRandomTwoConstant = function(e, t) {
            var n = new GradientColor();
            return n._type = 2, n._constantMin = e, n._constantMax = t, n;
        }, GradientColor.createByRandomTwoGradient = function(e, t) {
            var n = new GradientColor();
            return n._type = 3, n._gradientMin = e, n._gradientMax = t, n;
        }, GradientColor;
    }(), ae = (function() {
        function Size(e, t) {
            this._width = 0, this._height = 0, this._width = e, this._height = t;
        }
        r(Size, "laya.d3.utils.Size");
        var e = Size.prototype;
        a(0, e, "width", function() {
            return -1 === this._width ? J.clientWidth : this._width;
        }), a(0, e, "height", function() {
            return -1 === this._height ? J.clientHeight : this._height;
        }), a(1, Size, "fullScreen", function() {
            return new Size(-1, -1);
        });
    }(), function() {
        function PhysicsSettings() {
            this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
        }
        return r(PhysicsSettings, "laya.d3.physics.PhysicsSettings"), PhysicsSettings;
    }()), oe = function() {
        function Plane(e, t) {
            this.normal = null, this.distance = NaN, void 0 === t && (t = 0), this.normal = e, 
            this.distance = t;
        }
        return r(Plane, "laya.d3.math.Plane"), Plane.prototype.normalize = function() {
            var e = this.normal.x, t = this.normal.y, n = this.normal.z, i = 1 / Math.sqrt(e * e + t * t + n * n);
            this.normal.x = e * i, this.normal.y = t * i, this.normal.z = n * i, this.distance *= i;
        }, Plane.createPlaneBy3P = function(e, t, n) {
            var i = t.x - e.x, r = t.y - e.y, a = t.z - e.z, o = n.x - e.x, s = n.y - e.y, l = n.z - e.z, h = r * l - a * s, u = a * o - i * l, c = i * s - r * o, d = 1 / Math.sqrt(h * h + u * u + c * c), _ = h * d, f = u * d, m = c * d;
            Plane._TEMPVec3.x = _, Plane._TEMPVec3.y = f, Plane._TEMPVec3.z = m;
            var p = -(_ * e.x + f * e.y + m * e.z);
            return new Plane(Plane._TEMPVec3, p);
        }, Plane.PlaneIntersectionType_Back = 0, Plane.PlaneIntersectionType_Front = 1, 
        Plane.PlaneIntersectionType_Intersecting = 2, i(Plane, [ "_TEMPVec3", function() {
            return this._TEMPVec3 = new Te();
        } ]), Plane;
    }(), se = function() {
        function MaterialInfo() {
            this.ambientColor = null, this.diffuseColor = null, this.specularColor = null;
        }
        return r(MaterialInfo, "laya.d3.terrain.unit.MaterialInfo"), MaterialInfo;
    }(), le = function() {
        function Gradient(e, t) {
            this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0, 
            this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null, 
            this._rgbElements = null, this._maxColorRGBKeysCount = e, this._maxColorAlphaKeysCount = t, 
            this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
        }
        r(Gradient, "laya.d3.core.Gradient");
        var e = Gradient.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.addColorRGB = function(e, t) {
            if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                var n = 4 * this._colorRGBKeysCount;
                this._rgbElements[n] = e, this._rgbElements[n + 1] = t.r, this._rgbElements[n + 2] = t.g, 
                this._rgbElements[n + 3] = t.b, this._colorRGBKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
        }, e.addColorAlpha = function(e, t) {
            if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                var n = 2 * this._colorAlphaKeysCount;
                this._alphaElements[n] = e, this._alphaElements[n + 1] = t, this._colorAlphaKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
        }, e.updateColorRGB = function(e, t, n) {
            if (e < this._colorRGBKeysCount) {
                var i = 4 * e;
                this._rgbElements[i] = t, this._rgbElements[i + 1] = n.r, this._rgbElements[i + 2] = n.g, 
                this._rgbElements[i + 3] = n.b;
            } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
        }, e.updateColorAlpha = function(e, t, n) {
            if (e < this._colorAlphaKeysCount) {
                var i = 2 * e;
                this._alphaElements[i] = t, this._alphaElements[i + 1] = n;
            } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
        }, e.cloneTo = function(e) {
            var t = e, n = 0, i = 0;
            t._colorAlphaKeysCount = this._colorAlphaKeysCount;
            var r = t._alphaElements;
            for (r.length = this._alphaElements.length, n = 0, i = this._alphaElements.length; n < i; n++) r[n] = this._alphaElements[n];
            t._colorRGBKeysCount = this._colorRGBKeysCount;
            var a = t._rgbElements;
            for (a.length = this._rgbElements.length, n = 0, i = this._rgbElements.length; n < i; n++) a[n] = this._rgbElements[n];
        }, e.clone = function() {
            var e = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
            return this.cloneTo(e), e;
        }, a(0, e, "colorRGBKeysCount", function() {
            return this._colorRGBKeysCount / 4;
        }), a(0, e, "mode", function() {
            return this._mode;
        }, function(e) {
            this._mode = e;
        }), a(0, e, "colorAlphaKeysCount", function() {
            return this._colorAlphaKeysCount / 2;
        }), a(0, e, "maxColorRGBKeysCount", function() {
            return this._maxColorRGBKeysCount;
        }), a(0, e, "maxColorAlphaKeysCount", function() {
            return this._maxColorAlphaKeysCount;
        }), Gradient;
    }(), he = function() {
        function Quaternion(e, t, n, i, r) {
            void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 1), 
            this.x = e, this.y = t, this.z = n, this.w = i;
        }
        r(Quaternion, "laya.d3.math.Quaternion");
        var e = Quaternion.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.scaling = function(e, t) {
            t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
        }, e.normalize = function(e) {
            var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t, 
            e.w = this.w * t);
        }, e.length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }, e.rotateX = function(e, t) {
            e *= .5;
            var n = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i + this.w * n, t.y = this.y * i + this.z * n, t.z = this.z * i - this.y * n, 
            t.w = this.w * i - this.x * n;
        }, e.rotateY = function(e, t) {
            e *= .5;
            var n = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i - this.z * n, t.y = this.y * i + this.w * n, t.z = this.z * i + this.x * n, 
            t.w = this.w * i - this.y * n;
        }, e.rotateZ = function(e, t) {
            e *= .5;
            var n = Math.sin(e), i = Math.cos(e);
            t.x = this.x * i + this.y * n, t.y = this.y * i - this.x * n, t.z = this.z * i + this.w * n, 
            t.w = this.w * i - this.z * n;
        }, e.getYawPitchRoll = function(e) {
            Te.transformQuat(Te._ForwardRH, this, Quaternion.TEMPVector31), Te.transformQuat(Te._Up, this, Quaternion.TEMPVector32);
            var t = Quaternion.TEMPVector32;
            Quaternion.angleTo(Te._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
            var n = Quaternion.TEMPVector33;
            n.x == Math.PI / 2 ? (n.y = Quaternion.arcTanAngle(t.z, t.x), n.z = 0) : n.x == -Math.PI / 2 ? (n.y = Quaternion.arcTanAngle(-t.z, -t.x), 
            n.z = 0) : (Ht.createRotationY(-n.y, Quaternion.TEMPMatrix0), Ht.createRotationX(-n.x, Quaternion.TEMPMatrix1), 
            Te.transformCoordinate(Quaternion.TEMPVector32, Quaternion.TEMPMatrix0, Quaternion.TEMPVector32), 
            Te.transformCoordinate(Quaternion.TEMPVector32, Quaternion.TEMPMatrix1, Quaternion.TEMPVector32), 
            n.z = Quaternion.arcTanAngle(t.y, -t.x)), n.y <= -Math.PI && (n.y = Math.PI), n.z <= -Math.PI && (n.z = Math.PI), 
            n.y >= Math.PI && n.z >= Math.PI && (n.y = 0, n.z = 0, n.x = Math.PI - n.x);
            var i = e;
            i.x = n.y, i.y = n.x, i.z = n.z;
        }, e.invert = function(e) {
            var t = this.x, n = this.y, i = this.z, r = this.w, a = t * t + n * n + i * i + r * r, o = a ? 1 / a : 0;
            e.x = -t * o, e.y = -n * o, e.z = -i * o, e.w = r * o;
        }, e.identity = function() {
            this.x = 0, this.y = 0, this.z = 0, this.w = 1;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], 
            this.w = e[t + 3];
        }, e.cloneTo = function(e) {
            this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.equals = function(e) {
            return ie.nearEqual(this.x, e.x) && ie.nearEqual(this.y, e.y) && ie.nearEqual(this.z, e.z) && ie.nearEqual(this.w, e.w);
        }, e.lengthSquared = function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }, e.forNativeElement = function(e) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
            this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
            Se.rewriteNumProperty(this, "x", 0), Se.rewriteNumProperty(this, "y", 1), Se.rewriteNumProperty(this, "z", 2), 
            Se.rewriteNumProperty(this, "w", 3);
        }, Quaternion.createFromYawPitchRoll = function(e, t, n, i) {
            var r = .5 * n, a = .5 * t, o = .5 * e, s = Math.sin(r), l = Math.cos(r), h = Math.sin(a), u = Math.cos(a), c = Math.sin(o), d = Math.cos(o);
            i.x = d * h * l + c * u * s, i.y = c * u * l - d * h * s, i.z = d * u * s - c * h * l, 
            i.w = d * u * l + c * h * s;
        }, Quaternion.multiply = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = e.w, s = t.x, l = t.y, h = t.z, u = t.w, c = r * h - a * l, d = a * s - i * h, _ = i * l - r * s, f = i * s + r * l + a * h;
            n.x = i * u + s * o + c, n.y = r * u + l * o + d, n.z = a * u + h * o + _, n.w = o * u - f;
        }, Quaternion.arcTanAngle = function(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }, Quaternion.angleTo = function(e, t, n) {
            Te.subtract(t, e, Quaternion.TEMPVector30), Te.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30), 
            n.x = Math.asin(Quaternion.TEMPVector30.y), n.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
        }, Quaternion.createFromAxisAngle = function(e, t, n) {
            t *= .5;
            var i = Math.sin(t);
            n.x = i * e.x, n.y = i * e.y, n.z = i * e.z, n.w = Math.cos(t);
        }, Quaternion.createFromMatrix4x4 = function(e, t) {
            var n, i, r = e.elements, a = r[0] + r[5] + r[10];
            a > 0 ? (n = Math.sqrt(a + 1), t.w = .5 * n, n = .5 / n, t.x = (r[6] - r[9]) * n, 
            t.y = (r[8] - r[2]) * n, t.z = (r[1] - r[4]) * n) : r[0] >= r[5] && r[0] >= r[10] ? (i = .5 / (n = Math.sqrt(1 + r[0] - r[5] - r[10])), 
            t.x = .5 * n, t.y = (r[1] + r[4]) * i, t.z = (r[2] + r[8]) * i, t.w = (r[6] - r[9]) * i) : r[5] > r[10] ? (i = .5 / (n = Math.sqrt(1 + r[5] - r[0] - r[10])), 
            t.x = (r[4] + r[1]) * i, t.y = .5 * n, t.z = (r[9] + r[6]) * i, t.w = (r[8] - r[2]) * i) : (i = .5 / (n = Math.sqrt(1 + r[10] - r[0] - r[5])), 
            t.x = (r[8] + r[2]) * i, t.y = (r[9] + r[6]) * i, t.z = .5 * n, t.w = (r[1] - r[4]) * i);
        }, Quaternion.slerp = function(e, t, n, i) {
            var r, a, o, s, l, h = e.x, u = e.y, c = e.z, d = e.w, _ = t.x, f = t.y, m = t.z, p = t.w;
            return (a = h * _ + u * f + c * m + d * p) < 0 && (a = -a, _ = -_, f = -f, m = -m, 
            p = -p), 1 - a > 1e-6 ? (r = Math.acos(a), o = Math.sin(r), s = Math.sin((1 - n) * r) / o, 
            l = Math.sin(n * r) / o) : (s = 1 - n, l = n), i.x = s * h + l * _, i.y = s * u + l * f, 
            i.z = s * c + l * m, i.w = s * d + l * p, i;
        }, Quaternion.lerp = function(e, t, n, i) {
            var r = 1 - n;
            Quaternion.dot(e, t) >= 0 ? (i.x = r * e.x + n * t.x, i.y = r * e.y + n * t.y, i.z = r * e.z + n * t.z, 
            i.w = r * e.w + n * t.w) : (i.x = r * e.x - n * t.x, i.y = r * e.y - n * t.y, i.z = r * e.z - n * t.z, 
            i.w = r * e.w - n * t.w), i.normalize(i);
        }, Quaternion.add = function(e, t, n) {
            n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w;
        }, Quaternion.dot = function(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }, Quaternion.rotationLookAt = function(e, t, n) {
            Quaternion.lookAt(Te._ZERO, e, t, n);
        }, Quaternion.lookAt = function(e, t, n, i) {
            Ft.lookAt(e, t, n, Quaternion._tempMatrix3x3), Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, i);
        }, Quaternion.invert = function(e, t) {
            var n = e.lengthSquared();
            ie.isZero(n) || (n = 1 / n, t.x = -e.x * n, t.y = -e.y * n, t.z = -e.z * n, t.w = e.w * n);
        }, Quaternion.rotationMatrix = function(e, t) {
            var n = e.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], l = n[5], h = n[6], u = n[7], c = n[8], d = NaN, _ = NaN, f = i + s + c;
            f > 0 ? (d = Math.sqrt(f + 1), t.w = .5 * d, d = .5 / d, t.x = (l - u) * d, t.y = (h - a) * d, 
            t.z = (r - o) * d) : i >= s && i >= c ? (_ = .5 / (d = Math.sqrt(1 + i - s - c)), 
            t.x = .5 * d, t.y = (r + o) * _, t.z = (a + h) * _, t.w = (l - u) * _) : s > c ? (_ = .5 / (d = Math.sqrt(1 + s - i - c)), 
            t.x = (o + r) * _, t.y = .5 * d, t.z = (u + l) * _, t.w = (h - a) * _) : (_ = .5 / (d = Math.sqrt(1 + c - i - s)), 
            t.x = (h + a) * _, t.y = (u + l) * _, t.z = .5 * d, t.w = (r - o) * _);
        }, Quaternion.DEFAULT = new Quaternion(), i(Quaternion, [ "TEMPVector30", function() {
            return this.TEMPVector30 = new Te();
        }, "TEMPVector31", function() {
            return this.TEMPVector31 = new Te();
        }, "TEMPVector32", function() {
            return this.TEMPVector32 = new Te();
        }, "TEMPVector33", function() {
            return this.TEMPVector33 = new Te();
        }, "TEMPMatrix0", function() {
            return this.TEMPMatrix0 = new Ht();
        }, "TEMPMatrix1", function() {
            return this.TEMPMatrix1 = new Ht();
        }, "_tempMatrix3x3", function() {
            return this._tempMatrix3x3 = new Ft();
        }, "NAN", function() {
            return this.NAN = new Quaternion(NaN, NaN, NaN, NaN);
        } ]), Quaternion;
    }(), ue = function() {
        function ShaderData(e) {
            this._ownerResource = null, this._data = null, this._int32Data = null, this._float32Data = null, 
            this._nativeArray = null, this._frameCount = 0, this._runtimeCopyValues = [], this._ownerResource = e, 
            this._initData();
        }
        r(ShaderData, "laya.d3.shader.ShaderData");
        var e = ShaderData.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e._initData = function() {
            this._data = new Object();
        }, e.getData = function() {
            return this._data;
        }, e.getBool = function(e) {
            return this._data[e];
        }, e.setBool = function(e, t) {
            this._data[e] = t;
        }, e.getInt = function(e) {
            return this._data[e];
        }, e.setInt = function(e, t) {
            this._data[e] = t;
        }, e.getNumber = function(e) {
            return this._data[e];
        }, e.setNumber = function(e, t) {
            this._data[e] = t;
        }, e.getVector2 = function(e) {
            return this._data[e];
        }, e.setVector2 = function(e, t) {
            this._data[e] = t;
        }, e.getVector3 = function(e) {
            return this._data[e];
        }, e.setVector3 = function(e, t) {
            this._data[e] = t;
        }, e.getVector = function(e) {
            return this._data[e];
        }, e.setVector = function(e, t) {
            this._data[e] = t;
        }, e.getQuaternion = function(e) {
            return this._data[e];
        }, e.setQuaternion = function(e, t) {
            this._data[e] = t;
        }, e.getMatrix4x4 = function(e) {
            return this._data[e];
        }, e.setMatrix4x4 = function(e, t) {
            this._data[e] = t;
        }, e.getBuffer = function(e) {
            return this._data[e];
        }, e.setBuffer = function(e, t) {
            this._data[e] = t;
        }, e.setTexture = function(e, t) {
            var n = this._data[e];
            this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (n && n._removeReference(), 
            t && t._addReference());
        }, e.getTexture = function(e) {
            return this._data[e];
        }, e.setAttribute = function(e, t) {
            this._data[e] = t;
        }, e.getAttribute = function(e) {
            return this._data[e];
        }, e.getLength = function() {
            return this._data.length;
        }, e.setLength = function(e) {
            this._data.length = e;
        }, e.cloneTo = function(e) {
            var t = e._data;
            for (var n in this._data) {
                var i = this._data[n];
                if (null != i) if ("number" == typeof i) t[n] = i; else if ("number" == typeof i && Math.floor(i) == i) t[n] = i; else if ("boolean" == typeof i) t[n] = i; else if (i instanceof laya.d3.math.Vector2) {
                    var r = t[n] || (t[n] = new Se());
                    i.cloneTo(r), t[n] = r;
                } else if (i instanceof laya.d3.math.Vector3) {
                    var a = t[n] || (t[n] = new Te());
                    i.cloneTo(a), t[n] = a;
                } else if (i instanceof laya.d3.math.Vector4) {
                    var o = t[n] || (t[n] = new me());
                    i.cloneTo(o), t[n] = o;
                } else if (i instanceof laya.d3.math.Matrix4x4) {
                    var s = t[n] || (t[n] = new Ht());
                    i.cloneTo(s), t[n] = s;
                } else i instanceof laya.resource.BaseTexture && (t[n] = i);
            }
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.cloneToForNative = function(e) {
            var t = e;
            this._int32Data.length - t._int32Data.length > 0 && t.needRenewArrayBufferForNative(this._int32Data.length), 
            t._int32Data.set(this._int32Data, 0);
            var n = t._nativeArray, i = this._nativeArray.length;
            n.length = i;
            for (var r = 0; r < i; r++) {
                var a = this._nativeArray[r];
                if (a) if ("number" == typeof a) n[r] = a, t.setNumber(r, a); else if ("number" == typeof a && Math.floor(a) == a) n[r] = a, 
                t.setInt(r, a); else if ("boolean" == typeof a) n[r] = a, t.setBool(r, a); else if (a instanceof laya.d3.math.Vector2) {
                    var o = n[r] || (n[r] = new Se());
                    a.cloneTo(o), n[r] = o, t.setVector2(r, o);
                } else if (a instanceof laya.d3.math.Vector3) {
                    var s = n[r] || (n[r] = new Te());
                    a.cloneTo(s), n[r] = s, t.setVector3(r, s);
                } else if (a instanceof laya.d3.math.Vector4) {
                    var l = n[r] || (n[r] = new me());
                    a.cloneTo(l), n[r] = l, t.setVector(r, l);
                } else if (a instanceof laya.d3.math.Matrix4x4) {
                    var h = n[r] || (n[r] = new Ht());
                    a.cloneTo(h), n[r] = h, t.setMatrix4x4(r, h);
                } else a instanceof laya.resource.BaseTexture && (n[r] = a, t.setTexture(r, a));
            }
        }, e._initDataForNative = function() {
            this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [], 
            this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data), 
            this._float32Data = new Float32Array(this._data), E.createArrayBufferRef(this._data, 0, !0);
        }, e.needRenewArrayBufferForNative = function(e) {
            if (e >= this._int32Data.length) {
                var t = 4 * (e + 1), n = this._int32Data, i = this._data.conchRef, r = this._data._ptrID;
                this._data = new ArrayBuffer(t), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data), 
                this._data.conchRef = i, this._data._ptrID = r, n && this._int32Data.set(n, 0), 
                conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
            }
        }, e.getDataForNative = function() {
            return this._nativeArray;
        }, e.getIntForNative = function(e) {
            return this._int32Data[e];
        }, e.setIntForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
        }, e.getBoolForNative = function(e) {
            return 1 == this._int32Data[e];
        }, e.setBoolForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
        }, e.getNumberForNative = function(e) {
            return this._float32Data[e];
        }, e.setNumberForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
        }, e.getMatrix4x4ForNative = function(e) {
            return this._nativeArray[e];
        }, e.setMatrix4x4ForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var n = this.setReferenceForNative(t.elements);
            this._int32Data[e] = n;
        }, e.getVectorForNative = function(e) {
            return this._nativeArray[e];
        }, e.setVectorForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var n = this.setReferenceForNative(t.elements);
            this._int32Data[e] = n;
        }, e.getVector2ForNative = function(e) {
            return this._nativeArray[e];
        }, e.setVector2ForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var n = this.setReferenceForNative(t.elements);
            this._int32Data[e] = n;
        }, e.getVector3ForNative = function(e) {
            return this._nativeArray[e];
        }, e.setVector3ForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var n = this.setReferenceForNative(t.elements);
            this._int32Data[e] = n;
        }, e.getQuaternionForNative = function(e) {
            return this._nativeArray[e];
        }, e.setQuaternionForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var n = this.setReferenceForNative(t.elements);
            this._int32Data[e] = n;
        }, e.getBufferForNative = function(e) {
            return this._nativeArray[e];
        }, e.setBufferForNative = function(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var n = this.setReferenceForNative(t);
            this._int32Data[e] = n;
        }, e.getAttributeForNative = function(e) {
            return this._nativeArray[e];
        }, e.setAttributeForNative = function(e, t) {
            this._nativeArray[e] = t, t._ptrID || E.createArrayBufferRef(t, 0, !0), E.syncBufferToRenderThread(t), 
            this._int32Data[e] = t._ptrID;
        }, e.getTextureForNative = function(e) {
            return this._nativeArray[e];
        }, e.setTextureForNative = function(e, t) {
            if (t) {
                this.needRenewArrayBufferForNative(e);
                var n = this._nativeArray[e];
                this._nativeArray[e] = t, this._int32Data[e] = t._glTexture.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (n && n._removeReference(), 
                t && t._addReference());
            }
        }, e.setReferenceForNative = function(e) {
            this.clearRuntimeCopyArray();
            var t = 0, n = 0;
            return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (E.createArrayBufferRefs(e, 0, !0, 0), 
            t = 0, n = e.getPtrID(t)) : (E.createArrayBufferRefs(e, 0, !0, 1), t = e.getRefNum() - 1, 
            n = e.getPtrID(t), this._runtimeCopyValues.push({
                obj: e,
                refID: t,
                ptrID: n
            })), E.syncBufferToRenderThread(e, t), n;
        }, e.clearRuntimeCopyArray = function() {
            var e = E.getFrameCount();
            if (this._frameCount != e) {
                this._frameCount = e;
                for (var t = 0, n = this._runtimeCopyValues.length; t < n; t++) {
                    this._runtimeCopyValues[t].obj.clearRefNum();
                }
                this._runtimeCopyValues.length = 0;
            }
        }, ShaderData.setRuntimeValueMode = function(e) {
            ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
        }, ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0, ShaderData;
    }(), ce = function() {
        function TerrainLeaf() {
            this._boundingSphere = null, this._boundingBox = null, this._sizeOfY = null, this._currentLODLevel = 0, 
            this._lastDistanceToEye = NaN, this._originalBoundingSphere = null, this._originalBoundingBox = null, 
            this._originalBoundingBoxCorners = null, this._bUseStrip = !1, this._gridSize = NaN, 
            this._beginGridX = 0, this._beginGridZ = 0, this._LODError = null, TerrainLeaf.__init__(), 
            this._currentLODLevel = 0;
        }
        r(TerrainLeaf, "laya.d3.terrain.TerrainLeaf");
        var e = TerrainLeaf.prototype;
        return e.calcVertextNorml = function(e, t, n, i, r, a) {
            var o = 0, s = 0;
            s = -1 * TerrainLeaf.getHeightFromTerrainHeightData(e - 1, t - 1, n, i, r), s += -1 * TerrainLeaf.getHeightFromTerrainHeightData(e - 1, t, n, i, r), 
            s += -1 * TerrainLeaf.getHeightFromTerrainHeightData(e - 1, t + 1, n, i, r), s += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e + 1, t - 1, n, i, r), 
            s += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e + 1, t, n, i, r), s += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e + 1, t + 1, n, i, r), 
            o = -1 * TerrainLeaf.getHeightFromTerrainHeightData(e - 1, t - 1, n, i, r), o += -1 * TerrainLeaf.getHeightFromTerrainHeightData(e, t - 1, n, i, r), 
            o += -1 * TerrainLeaf.getHeightFromTerrainHeightData(e + 1, t - 1, n, i, r), o += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e - 1, t + 1, n, i, r), 
            o += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e, t + 1, n, i, r), o += 1 * TerrainLeaf.getHeightFromTerrainHeightData(e + 1, t + 1, n, i, r), 
            a.x = -s, a.y = 6, a.z = -o, Te.normalize(a, a);
        }, e.calcVertextNormlUV = function(e, t, n, i, r) {
            r.x = e / n, r.y = t / i, r.z = t / i;
        }, e.calcVertextBuffer = function(e, t, n, i, r, a, o, s, l, h, u, c) {
            if (1 == c && !TerrainLeaf.__ADAPT_MATRIX__) {
                TerrainLeaf.__ADAPT_MATRIX__ = new Ht();
                var d = new Ht();
                Ht.createRotationY(Math.PI, TerrainLeaf.__ADAPT_MATRIX__), Ht.createTranslate(new Te(0, 0, (u - 1) * r), d), 
                Ht.multiply(d, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__ADAPT_MATRIX__), TerrainLeaf.__ADAPT_MATRIX_INV__ = new Ht(), 
                TerrainLeaf.__ADAPT_MATRIX__.invert(TerrainLeaf.__ADAPT_MATRIX_INV__);
            }
            this._gridSize = r, this._beginGridX = e * TerrainLeaf.CHUNK_GRID_NUM + n, this._beginGridZ = t * TerrainLeaf.CHUNK_GRID_NUM + i;
            for (var _ = o * s, f = 2147483647, m = -2147483648, p = new Te(), T = 0, S = TerrainLeaf.LEAF_GRID_NUM + 1; T < S; T++) for (var E = 0, v = TerrainLeaf.LEAF_GRID_NUM + 1; E < v; E++) TerrainLeaf.__VECTOR3__.x = (this._beginGridX + E) * this._gridSize, 
            TerrainLeaf.__VECTOR3__.z = (this._beginGridZ + T) * this._gridSize, TerrainLeaf.__VECTOR3__.y = l[(this._beginGridZ + T) * h + (this._beginGridX + E)], 
            f = TerrainLeaf.__VECTOR3__.y < f ? TerrainLeaf.__VECTOR3__.y : f, m = TerrainLeaf.__VECTOR3__.y > m ? TerrainLeaf.__VECTOR3__.y : m, 
            TerrainLeaf.__ADAPT_MATRIX__ && Te.transformV3ToV3(TerrainLeaf.__VECTOR3__, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__VECTOR3__), 
            a[_] = TerrainLeaf.__VECTOR3__.x, a[++_] = TerrainLeaf.__VECTOR3__.y, a[++_] = TerrainLeaf.__VECTOR3__.z, 
            _++, this.calcVertextNormlUV(this._beginGridX + E, this._beginGridZ + T, h, u, p), 
            a[_] = p.x, a[++_] = p.y, a[++_] = p.z, a[++_] = (n + E) / TerrainLeaf.CHUNK_GRID_NUM, 
            a[++_] = (i + T) / TerrainLeaf.CHUNK_GRID_NUM, a[++_] = this._beginGridX + E, a[++_] = this._beginGridZ + T, 
            _++;
            this._sizeOfY = new Se(f - 1, m + 1), this.calcLODErrors(l, h, u), this.calcOriginalBoudingBoxAndSphere();
        }, e.calcSkirtVertextBuffer = function(e, t, n, i, r, a, o, s, l, h, u) {
            this._gridSize = r, this._beginGridX = e * TerrainLeaf.CHUNK_GRID_NUM + n, this._beginGridZ = t * TerrainLeaf.CHUNK_GRID_NUM + i;
            var c = o * s, d = 0, _ = 0, f = TerrainLeaf.LEAF_GRID_NUM + 1, m = new Te(), p = 0, T = 0;
            for (d = 0; d < 2; d++) for (_ = 0; _ < f; _++) TerrainLeaf.__VECTOR3__.x = (this._beginGridX + _) * this._gridSize, 
            TerrainLeaf.__VECTOR3__.y = 1 == d ? l[this._beginGridZ * h + (this._beginGridX + _)] : -this._gridSize, 
            TerrainLeaf.__VECTOR3__.z = (this._beginGridZ + 0) * this._gridSize, TerrainLeaf.__ADAPT_MATRIX__ && Te.transformV3ToV3(TerrainLeaf.__VECTOR3__, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__VECTOR3__), 
            a[c] = TerrainLeaf.__VECTOR3__.x, a[++c] = TerrainLeaf.__VECTOR3__.y, a[++c] = TerrainLeaf.__VECTOR3__.z, 
            c++, p = 0 == d ? this._beginGridZ - 1 : this._beginGridZ, this.calcVertextNormlUV(this._beginGridX + _, p, h, u, m), 
            a[c] = m.x, a[++c] = m.y, a[++c] = m.z, a[++c] = (n + _) / TerrainLeaf.CHUNK_GRID_NUM, 
            a[++c] = (i + 0) / TerrainLeaf.CHUNK_GRID_NUM, a[++c] = this._beginGridX + _, a[++c] = p, 
            c++;
            for (d = 0; d < 2; d++) for (_ = 0; _ < f; _++) TerrainLeaf.__VECTOR3__.x = (this._beginGridX + _) * this._gridSize, 
            TerrainLeaf.__VECTOR3__.y = 0 == d ? l[(this._beginGridZ + TerrainLeaf.LEAF_GRID_NUM) * h + (this._beginGridX + _)] : -this._gridSize, 
            TerrainLeaf.__VECTOR3__.z = (this._beginGridZ + TerrainLeaf.LEAF_GRID_NUM) * this._gridSize, 
            TerrainLeaf.__ADAPT_MATRIX__ && Te.transformV3ToV3(TerrainLeaf.__VECTOR3__, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__VECTOR3__), 
            a[c] = TerrainLeaf.__VECTOR3__.x, a[++c] = TerrainLeaf.__VECTOR3__.y, a[++c] = TerrainLeaf.__VECTOR3__.z, 
            c++, p = 0 == d ? this._beginGridZ + TerrainLeaf.LEAF_GRID_NUM : this._beginGridZ + TerrainLeaf.LEAF_GRID_NUM + 1, 
            this.calcVertextNormlUV(this._beginGridX + _, p, h, u, m), a[c] = m.x, a[++c] = m.y, 
            a[++c] = m.z, a[++c] = (n + _) / TerrainLeaf.CHUNK_GRID_NUM, a[++c] = (i + TerrainLeaf.LEAF_GRID_NUM) / TerrainLeaf.CHUNK_GRID_NUM, 
            a[++c] = this._beginGridX + _, a[++c] = p, c++;
            for (d = 0; d < 2; d++) for (_ = 0; _ < f; _++) TerrainLeaf.__VECTOR3__.x = (this._beginGridX + 0) * this._gridSize, 
            TerrainLeaf.__VECTOR3__.y = 0 == d ? l[(this._beginGridZ + _) * h + (this._beginGridX + 0)] : -this._gridSize, 
            TerrainLeaf.__VECTOR3__.z = (this._beginGridZ + _) * this._gridSize, TerrainLeaf.__ADAPT_MATRIX__ && Te.transformV3ToV3(TerrainLeaf.__VECTOR3__, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__VECTOR3__), 
            a[c] = TerrainLeaf.__VECTOR3__.x, a[++c] = TerrainLeaf.__VECTOR3__.y, a[++c] = TerrainLeaf.__VECTOR3__.z, 
            c++, T = 0 == d ? this._beginGridX : this._beginGridX - 1, this.calcVertextNormlUV(T, this._beginGridZ + _, h, u, m), 
            a[c] = m.x, a[++c] = m.y, a[++c] = m.z, a[++c] = (n + 0) / TerrainLeaf.CHUNK_GRID_NUM, 
            a[++c] = (i + _) / TerrainLeaf.CHUNK_GRID_NUM, a[++c] = T, a[++c] = this._beginGridZ + _, 
            c++;
            for (d = 0; d < 2; d++) for (_ = 0; _ < f; _++) TerrainLeaf.__VECTOR3__.x = (this._beginGridX + TerrainLeaf.LEAF_GRID_NUM) * this._gridSize, 
            TerrainLeaf.__VECTOR3__.y = 1 == d ? l[(this._beginGridZ + _) * h + (this._beginGridX + TerrainLeaf.LEAF_GRID_NUM)] : -this._gridSize, 
            TerrainLeaf.__VECTOR3__.z = (this._beginGridZ + _) * this._gridSize, TerrainLeaf.__ADAPT_MATRIX__ && Te.transformV3ToV3(TerrainLeaf.__VECTOR3__, TerrainLeaf.__ADAPT_MATRIX__, TerrainLeaf.__VECTOR3__), 
            a[c] = TerrainLeaf.__VECTOR3__.x, a[++c] = TerrainLeaf.__VECTOR3__.y, a[++c] = TerrainLeaf.__VECTOR3__.z, 
            c++, T = 0 == d ? this._beginGridX + TerrainLeaf.LEAF_GRID_NUM + 1 : this._beginGridX + TerrainLeaf.LEAF_GRID_NUM, 
            this.calcVertextNormlUV(T, this._beginGridZ + _, h, u, m), a[c] = m.x, a[++c] = m.y, 
            a[++c] = m.z, a[++c] = (n + TerrainLeaf.LEAF_GRID_NUM) / TerrainLeaf.CHUNK_GRID_NUM, 
            a[++c] = (i + _) / TerrainLeaf.CHUNK_GRID_NUM, a[++c] = T, a[++c] = this._beginGridZ + _, 
            c++;
        }, e.calcOriginalBoudingBoxAndSphere = function() {
            var e = new Te(this._beginGridX * this._gridSize, this._sizeOfY.x, this._beginGridZ * this._gridSize), t = new Te((this._beginGridX + TerrainLeaf.LEAF_GRID_NUM) * this._gridSize, this._sizeOfY.y, (this._beginGridZ + TerrainLeaf.LEAF_GRID_NUM) * this._gridSize);
            TerrainLeaf.__ADAPT_MATRIX__ && (Te.transformV3ToV3(e, TerrainLeaf.__ADAPT_MATRIX__, e), 
            Te.transformV3ToV3(t, TerrainLeaf.__ADAPT_MATRIX__, t)), this._originalBoundingBox = new zt(e, t);
            var n = new Te();
            Te.subtract(t, e, n), Te.scale(n, .5, n);
            var i = new Te();
            Te.add(e, n, i), this._originalBoundingSphere = new Ce(i, Te.scalarLength(n)), this._originalBoundingBoxCorners = o(8, null), 
            this._originalBoundingBox.getCorners(this._originalBoundingBoxCorners), this._boundingBox = new zt(new Te(-.5, -.5, -.5), new Te(.5, .5, .5)), 
            this._boundingSphere = new Ce(new Te(0, 0, 0), 1);
        }, e.calcLeafBoudingBox = function(e) {
            for (var t = 0; t < 8; t++) Te.transformCoordinate(this._originalBoundingBoxCorners[t], e, Xt._tempBoundBoxCorners[t]);
            zt.createfromPoints(Xt._tempBoundBoxCorners, this._boundingBox);
        }, e.calcLeafBoudingSphere = function(e, t) {
            Te.transformCoordinate(this._originalBoundingSphere.center, e, this._boundingSphere.center), 
            this._boundingSphere.radius = this._originalBoundingSphere.radius * t;
        }, e.calcLODErrors = function(e, t, n) {
            this._LODError = new Float32Array(TerrainLeaf._maxLODLevel + 1);
            for (var i = 1, r = 0, a = TerrainLeaf._maxLODLevel + 1; r < a; r++) {
                for (var o = 0, s = 0, l = TerrainLeaf.LEAF_GRID_NUM; s < l; s += i) for (var h = 0, u = TerrainLeaf.LEAF_GRID_NUM; h < u; h += i) for (var c = e[(this._beginGridZ + s) * t + (this._beginGridX + h)], d = e[(this._beginGridZ + s) * t + (this._beginGridX + h) + i], _ = e[(this._beginGridZ + s + i) * t + (this._beginGridX + h)], f = e[(this._beginGridZ + s + i) * t + (this._beginGridX + h) + i], m = 0; m < i; m++) for (var p = m / i, T = 0; T < i; T++) {
                    var S = T / i, E = e[(this._beginGridZ + s + m) * t + (this._beginGridX + h) + T], v = S + p <= 1 ? c + (d - c) * S + (_ - c) * p : f + (_ - f) * (1 - S) + (d - f) * (1 - p), g = Math.abs(v - E);
                    o = Math.max(o, g);
                }
                i *= 2, this._LODError[r] = o;
            }
        }, e.determineLod = function(e, t, n, i) {
            var r = Te.distance(e, this._boundingSphere.center), a = TerrainLeaf._maxLODLevel;
            if (!i) {
                if (this._lastDistanceToEye == r) return this._currentLODLevel;
                this._lastDistanceToEye > r && (a = this._currentLODLevel);
            }
            for (var o = a; o >= 1; o--) if (ti.LOD_DISTANCE_FACTOR * this._LODError[o] / r * t < n) {
                this._currentLODLevel = o;
                break;
            }
            return this._lastDistanceToEye = r, this._currentLODLevel;
        }, TerrainLeaf.__init__ = function() {
            if (!TerrainLeaf._bInit) {
                var e = TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM * (TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM);
                TerrainLeaf._planeLODIndex = o(e);
                var t = 0, n = 0, i = 0, r = 0, a = 0, s = 0, l = null, h = null;
                for (t = 0; t < e; t++) TerrainLeaf._planeLODIndex[t] = new Array(TerrainLeaf._maxLODLevel + 1);
                for (t = 0, r = TerrainLeaf._maxLODLevel + 1; t < r; t++) TerrainLeaf._planeLODIndex[0][t] = TerrainLeaf.calcPlaneLODIndex(t);
                for (t = 1; t < e; t++) for (s = t * TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT, n = 0, 
                a = TerrainLeaf._maxLODLevel + 1; n < a; n++) {
                    for (l = TerrainLeaf._planeLODIndex[0][n], h = new Uint16Array(l.length), i = 0; i < l.length; i++) h[i] = l[i] + s;
                    TerrainLeaf._planeLODIndex[t][n] = h;
                }
                for (TerrainLeaf._skirtLODIndex = o(e), t = 0; t < e; t++) TerrainLeaf._skirtLODIndex[t] = new Array(TerrainLeaf._maxLODLevel + 1);
                for (t = 0, r = TerrainLeaf._maxLODLevel + 1; t < r; t++) TerrainLeaf._skirtLODIndex[0][t] = TerrainLeaf.calcSkirtLODIndex(t);
                for (t = 1; t < e; t++) for (s = t * TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT, n = 0, 
                a = TerrainLeaf._maxLODLevel + 1; n < a; n++) {
                    for (l = TerrainLeaf._skirtLODIndex[0][n], h = new Uint16Array(l.length), i = 0; i < l.length; i++) h[i] = l[i] + s;
                    TerrainLeaf._skirtLODIndex[t][n] = h;
                }
                TerrainLeaf._bInit = !0;
            }
        }, TerrainLeaf.getPlaneLODIndex = function(e, t) {
            return TerrainLeaf._planeLODIndex[e][t];
        }, TerrainLeaf.getSkirtLODIndex = function(e, t) {
            return TerrainLeaf._skirtLODIndex[e][t];
        }, TerrainLeaf.calcPlaneLODIndex = function(e) {
            e > TerrainLeaf._maxLODLevel && (e = TerrainLeaf._maxLODLevel);
            var t = TerrainLeaf.LEAF_GRID_NUM + 1, n = 0, i = null, r = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2, e);
            i = new Uint16Array(r * r * 6);
            for (var a = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / r, o = 0; o < TerrainLeaf.LEAF_GRID_NUM; o += a) for (var s = 0; s < TerrainLeaf.LEAF_GRID_NUM; s += a) i[n] = (o + a) * t + s, 
            i[++n] = o * t + s, i[++n] = o * t + s + a, i[++n] = o * t + s + a, i[++n] = (o + a) * t + s + a, 
            i[++n] = (o + a) * t + s, n++;
            return i;
        }, TerrainLeaf.calcSkirtLODIndex = function(e) {
            e > TerrainLeaf._maxLODLevel && (e = TerrainLeaf._maxLODLevel);
            var t = TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM * (TerrainLeaf.CHUNK_GRID_NUM / TerrainLeaf.LEAF_GRID_NUM) * TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT, n = TerrainLeaf.LEAF_GRID_NUM + 1, i = 0, r = null, a = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / Math.pow(2, e);
            r = new Uint16Array(4 * a * 6);
            for (var o = laya.d3.terrain.TerrainLeaf.LEAF_GRID_NUM / a, s = 0; s < 4; s++) {
                for (var l = 0; l < TerrainLeaf.LEAF_GRID_NUM; l += o) r[i] = t + n + l, r[++i] = t + l, 
                r[++i] = t + l + o, r[++i] = t + l + o, r[++i] = t + n + l + o, r[++i] = t + n + l, 
                i++;
                t += 2 * n;
            }
            return r;
        }, TerrainLeaf.getHeightFromTerrainHeightData = function(e, t, n, i, r) {
            return n[(t = (t = t < 0 ? 0 : t) >= r ? r - 1 : t) * i + (e = (e = e < 0 ? 0 : e) >= i ? i - 1 : e)];
        }, TerrainLeaf.CHUNK_GRID_NUM = 64, TerrainLeaf.LEAF_GRID_NUM = 32, TerrainLeaf.__ADAPT_MATRIX__ = null, 
        TerrainLeaf.__ADAPT_MATRIX_INV__ = null, TerrainLeaf._planeLODIndex = null, TerrainLeaf._skirtLODIndex = null, 
        TerrainLeaf._bInit = !1, i(TerrainLeaf, [ "LEAF_PLANE_VERTEXT_COUNT", function() {
            return this.LEAF_PLANE_VERTEXT_COUNT = (TerrainLeaf.LEAF_GRID_NUM + 1) * (TerrainLeaf.LEAF_GRID_NUM + 1);
        }, "LEAF_SKIRT_VERTEXT_COUNT", function() {
            return this.LEAF_SKIRT_VERTEXT_COUNT = 2 * (TerrainLeaf.LEAF_GRID_NUM + 1) * 4;
        }, "LEAF_VERTEXT_COUNT", function() {
            return this.LEAF_VERTEXT_COUNT = TerrainLeaf.LEAF_PLANE_VERTEXT_COUNT + TerrainLeaf.LEAF_SKIRT_VERTEXT_COUNT;
        }, "LEAF_PLANE_MAX_INDEX_COUNT", function() {
            return this.LEAF_PLANE_MAX_INDEX_COUNT = TerrainLeaf.LEAF_GRID_NUM * TerrainLeaf.LEAF_GRID_NUM * 6;
        }, "LEAF_SKIRT_MAX_INDEX_COUNT", function() {
            return this.LEAF_SKIRT_MAX_INDEX_COUNT = 4 * TerrainLeaf.LEAF_GRID_NUM * 6;
        }, "LEAF_MAX_INDEX_COUNT", function() {
            return this.LEAF_MAX_INDEX_COUNT = TerrainLeaf.LEAF_PLANE_MAX_INDEX_COUNT + TerrainLeaf.LEAF_SKIRT_MAX_INDEX_COUNT;
        }, "__VECTOR3__", function() {
            return this.__VECTOR3__ = new Te();
        }, "_maxLODLevel", function() {
            return this._maxLODLevel = Math.log2(TerrainLeaf.LEAF_GRID_NUM);
        } ]), TerrainLeaf;
    }(), de = function() {
        function VertexShuriKenParticle() {}
        return r(VertexShuriKenParticle, "laya.d3.graphics.Vertex.VertexShuriKenParticle"), 
        VertexShuriKenParticle.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, VertexShuriKenParticle.PARTICLE_POSITION0 = 1, 
        VertexShuriKenParticle.PARTICLE_COLOR0 = 2, VertexShuriKenParticle.PARTICLE_TEXTURECOORDINATE0 = 3, 
        VertexShuriKenParticle.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, VertexShuriKenParticle.PARTICLE_DIRECTIONTIME = 5, 
        VertexShuriKenParticle.PARTICLE_STARTCOLOR0 = 6, VertexShuriKenParticle.PARTICLE_ENDCOLOR0 = 7, 
        VertexShuriKenParticle.PARTICLE_STARTSIZE = 8, VertexShuriKenParticle.PARTICLE_STARTROTATION = 9, 
        VertexShuriKenParticle.PARTICLE_STARTSPEED = 10, VertexShuriKenParticle.PARTICLE_RANDOM0 = 11, 
        VertexShuriKenParticle.PARTICLE_RANDOM1 = 12, VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDPOSTION = 13, 
        VertexShuriKenParticle.PARTICLE_SIMULATIONWORLDROTATION = 14, VertexShuriKenParticle;
    }(), _e = function() {
        function SizeOverLifetime(e) {
            this._size = null, this.enbale = !1, this._size = e;
        }
        r(SizeOverLifetime, "laya.d3.core.particleShuriKen.module.SizeOverLifetime");
        var e = SizeOverLifetime.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            this._size.cloneTo(t._size), t.enbale = this.enbale;
        }, e.clone = function() {
            var e;
            switch (this._size.type) {
              case 0:
                e = this._size.separateAxes ? St.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : St.createByGradient(this._size.gradient.clone());
                break;

              case 1:
                e = this._size.separateAxes ? St.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : St.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                break;

              case 2:
                e = this._size.separateAxes ? St.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : St.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
            }
            var t = new this.constructor(e);
            return t.enbale = this.enbale, t;
        }, a(0, e, "size", function() {
            return this._size;
        }), SizeOverLifetime;
    }(), fe = function() {
        function Keyframe() {
            this.time = NaN;
        }
        r(Keyframe, "laya.d3.core.Keyframe");
        var e = Keyframe.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            e.time = this.time;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, Keyframe;
    }(), me = function() {
        function Vector4(e, t, n, i) {
            this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, void 0 === e && (e = 0), 
            void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), this.x = e, 
            this.y = t, this.z = n, this.w = i;
        }
        r(Vector4, "laya.d3.math.Vector4");
        var e = Vector4.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setValue = function(e, t, n, i) {
            this.x = e, this.y = t, this.z = n, this.w = i;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], 
            this.w = e[t + 3];
        }, e.cloneTo = function(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.length = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }, e.lengthSquared = function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }, e.forNativeElement = function(e) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z, 
            this.elements[3] = this.w) : this.elements = new Float32Array([ this.x, this.y, this.z, this.w ]), 
            Se.rewriteNumProperty(this, "x", 0), Se.rewriteNumProperty(this, "y", 1), Se.rewriteNumProperty(this, "z", 2), 
            Se.rewriteNumProperty(this, "w", 3);
        }, Vector4.lerp = function(e, t, n, i) {
            var r = e.x, a = e.y, o = e.z, s = e.w;
            i.x = r + n * (t.x - r), i.y = a + n * (t.y - a), i.z = o + n * (t.z - o), i.w = s + n * (t.w - s);
        }, Vector4.transformByM4x4 = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = e.w, s = t.elements;
            n.x = i * s[0] + r * s[4] + a * s[8] + o * s[12], n.y = i * s[1] + r * s[5] + a * s[9] + o * s[13], 
            n.z = i * s[2] + r * s[6] + a * s[10] + o * s[14], n.w = i * s[3] + r * s[7] + a * s[11] + o * s[15];
        }, Vector4.equals = function(e, t) {
            return ie.nearEqual(Math.abs(e.x), Math.abs(t.x)) && ie.nearEqual(Math.abs(e.y), Math.abs(t.y)) && ie.nearEqual(Math.abs(e.z), Math.abs(t.z)) && ie.nearEqual(Math.abs(e.w), Math.abs(t.w));
        }, Vector4.normalize = function(e, t) {
            var n = e.length();
            n > 0 && (t.x = e.x * n, t.y = e.y * n, t.z = e.z * n, t.w = e.w * n);
        }, Vector4.add = function(e, t, n) {
            n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z, n.w = e.w + t.w;
        }, Vector4.subtract = function(e, t, n) {
            n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z, n.w = e.w - t.w;
        }, Vector4.multiply = function(e, t, n) {
            n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z, n.w = e.w * t.w;
        }, Vector4.scale = function(e, t, n) {
            n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w * t;
        }, Vector4.Clamp = function(e, t, n, i) {
            var r = e.x, a = e.y, o = e.z, s = e.w, l = t.x, h = t.y, u = t.z, c = t.w, d = n.x, _ = n.y, f = n.z, m = n.w;
            r = (r = r > d ? d : r) < l ? l : r, a = (a = a > _ ? _ : a) < h ? h : a, o = (o = o > f ? f : o) < u ? u : o, 
            s = (s = s > m ? m : s) < c ? c : s, i.x = r, i.y = a, i.z = o, i.w = s;
        }, Vector4.distanceSquared = function(e, t) {
            var n = e.x - t.x, i = e.y - t.y, r = e.z - t.z, a = e.w - t.w;
            return n * n + i * i + r * r + a * a;
        }, Vector4.distance = function(e, t) {
            var n = e.x - t.x, i = e.y - t.y, r = e.z - t.z, a = e.w - t.w;
            return Math.sqrt(n * n + i * i + r * r + a * a);
        }, Vector4.dot = function(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }, Vector4.min = function(e, t, n) {
            n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z), n.w = Math.min(e.w, t.w);
        }, Vector4.max = function(e, t, n) {
            n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z), n.w = Math.max(e.w, t.w);
        }, i(Vector4, [ "ZERO", function() {
            return this.ZERO = new Vector4();
        }, "ONE", function() {
            return this.ONE = new Vector4(1, 1, 1, 1);
        }, "UnitX", function() {
            return this.UnitX = new Vector4(1, 0, 0, 0);
        }, "UnitY", function() {
            return this.UnitY = new Vector4(0, 1, 0, 0);
        }, "UnitZ", function() {
            return this.UnitZ = new Vector4(0, 0, 1, 0);
        }, "UnitW", function() {
            return this.UnitW = new Vector4(0, 0, 0, 1);
        } ]), Vector4;
    }(), pe = function() {
        function ShaderDefines(e) {
            if (this._counter = 0, this.defines = {}, e) for (var t in this._counter = e._counter, 
            e.defines) this.defines[t] = e.defines[t];
        }
        return r(ShaderDefines, "laya.d3.shader.ShaderDefines"), ShaderDefines.prototype.registerDefine = function(e) {
            var t = Math.pow(2, this._counter++);
            return this.defines[t] = e, t;
        }, ShaderDefines;
    }(), Te = function() {
        function Vector3(e, t, n, i) {
            this.x = NaN, this.y = NaN, this.z = NaN, void 0 === e && (e = 0), void 0 === t && (t = 0), 
            void 0 === n && (n = 0), this.x = e, this.y = t, this.z = n;
        }
        r(Vector3, "laya.d3.math.Vector3");
        var e = Vector3.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setValue = function(e, t, n) {
            this.x = e, this.y = t, this.z = n;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
        }, e.cloneTo = function(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.toDefault = function() {
            this.x = 0, this.y = 0, this.z = 0;
        }, e.forNativeElement = function(e) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([ this.x, this.y, this.z ]), 
            Se.rewriteNumProperty(this, "x", 0), Se.rewriteNumProperty(this, "y", 1), Se.rewriteNumProperty(this, "z", 2);
        }, Vector3.distanceSquared = function(e, t) {
            var n = e.x - t.x, i = e.y - t.y, r = e.z - t.z;
            return n * n + i * i + r * r;
        }, Vector3.distance = function(e, t) {
            var n = e.x - t.x, i = e.y - t.y, r = e.z - t.z;
            return Math.sqrt(n * n + i * i + r * r);
        }, Vector3.min = function(e, t, n) {
            n.x = Math.min(e.x, t.x), n.y = Math.min(e.y, t.y), n.z = Math.min(e.z, t.z);
        }, Vector3.max = function(e, t, n) {
            n.x = Math.max(e.x, t.x), n.y = Math.max(e.y, t.y), n.z = Math.max(e.z, t.z);
        }, Vector3.transformQuat = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.x, s = t.y, l = t.z, h = t.w, u = h * i + s * a - l * r, c = h * r + l * i - o * a, d = h * a + o * r - s * i, _ = -o * i - s * r - l * a;
            n.x = u * h + _ * -o + c * -l - d * -s, n.y = c * h + _ * -s + d * -o - u * -l, 
            n.z = d * h + _ * -l + u * -s - c * -o;
        }, Vector3.scalarLength = function(e) {
            var t = e.x, n = e.y, i = e.z;
            return Math.sqrt(t * t + n * n + i * i);
        }, Vector3.scalarLengthSquared = function(e) {
            var t = e.x, n = e.y, i = e.z;
            return t * t + n * n + i * i;
        }, Vector3.normalize = function(e, t) {
            var n = e.x, i = e.y, r = e.z, a = n * n + i * i + r * r;
            a > 0 && (a = 1 / Math.sqrt(a), t.x = e.x * a, t.y = e.y * a, t.z = e.z * a);
        }, Vector3.multiply = function(e, t, n) {
            n.x = e.x * t.x, n.y = e.y * t.y, n.z = e.z * t.z;
        }, Vector3.scale = function(e, t, n) {
            n.x = e.x * t, n.y = e.y * t, n.z = e.z * t;
        }, Vector3.lerp = function(e, t, n, i) {
            var r = e.x, a = e.y, o = e.z;
            i.x = r + n * (t.x - r), i.y = a + n * (t.y - a), i.z = o + n * (t.z - o);
        }, Vector3.transformV3ToV3 = function(e, t, n) {
            var i = Vector3._tempVector4;
            Vector3.transformV3ToV4(e, t, i), n.x = i.x, n.y = i.y, n.z = i.z;
        }, Vector3.transformV3ToV4 = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.elements;
            n.x = i * o[0] + r * o[4] + a * o[8] + o[12], n.y = i * o[1] + r * o[5] + a * o[9] + o[13], 
            n.z = i * o[2] + r * o[6] + a * o[10] + o[14], n.w = i * o[3] + r * o[7] + a * o[11] + o[15];
        }, Vector3.TransformNormal = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.elements;
            n.x = i * o[0] + r * o[4] + a * o[8], n.y = i * o[1] + r * o[5] + a * o[9], n.z = i * o[2] + r * o[6] + a * o[10];
        }, Vector3.transformCoordinate = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.elements, s = i * o[3] + r * o[7] + a * o[11] + o[15];
            n.x = i * o[0] + r * o[4] + a * o[8] + o[12] / s, n.y = i * o[1] + r * o[5] + a * o[9] + o[13] / s, 
            n.z = i * o[2] + r * o[6] + a * o[10] + o[14] / s;
        }, Vector3.Clamp = function(e, t, n, i) {
            var r = e.x, a = e.y, o = e.z, s = t.x, l = t.y, h = t.z, u = n.x, c = n.y, d = n.z;
            r = (r = r > u ? u : r) < s ? s : r, a = (a = a > c ? c : a) < l ? l : a, o = (o = o > d ? d : o) < h ? h : o, 
            i.x = r, i.y = a, i.z = o;
        }, Vector3.add = function(e, t, n) {
            n.x = e.x + t.x, n.y = e.y + t.y, n.z = e.z + t.z;
        }, Vector3.subtract = function(e, t, n) {
            n.x = e.x - t.x, n.y = e.y - t.y, n.z = e.z - t.z;
        }, Vector3.cross = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.x, s = t.y, l = t.z;
            n.x = r * l - a * s, n.y = a * o - i * l, n.z = i * s - r * o;
        }, Vector3.dot = function(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z;
        }, Vector3.equals = function(e, t) {
            return ie.nearEqual(e.x, t.x) && ie.nearEqual(e.y, t.y) && ie.nearEqual(e.z, t.z);
        }, Vector3._ZERO = new Vector3(0, 0, 0), Vector3._ONE = new Vector3(1, 1, 1), Vector3._NegativeUnitX = new Vector3(-1, 0, 0), 
        Vector3._UnitX = new Vector3(1, 0, 0), Vector3._UnitY = new Vector3(0, 1, 0), Vector3._UnitZ = new Vector3(0, 0, 1), 
        Vector3._ForwardRH = new Vector3(0, 0, -1), Vector3._ForwardLH = new Vector3(0, 0, 1), 
        Vector3._Up = new Vector3(0, 1, 0), i(Vector3, [ "_tempVector4", function() {
            return this._tempVector4 = new me();
        } ]), Vector3;
    }(), Se = function() {
        function Vector2(e, t) {
            this.x = NaN, this.y = NaN, void 0 === e && (e = 0), void 0 === t && (t = 0), this.x = e, 
            this.y = t;
        }
        r(Vector2, "laya.d3.math.Vector2");
        var e = Vector2.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setValue = function(e, t) {
            this.x = e, this.y = t;
        }, e.fromArray = function(e, t) {
            void 0 === t && (t = 0), this.x = e[t + 0], this.y = e[t + 1];
        }, e.cloneTo = function(e) {
            var t = e;
            t.x = this.x, t.y = this.y;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.forNativeElement = function(e) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([ this.x, this.y ]), 
            Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1);
        }, Vector2.scale = function(e, t, n) {
            n.x = e.x * t, n.y = e.y * t;
        }, Vector2.dot = function(e, t) {
            return e.x * t.x + e.y * t.y;
        }, Vector2.normalize = function(e, t) {
            var n = e.x, i = e.y, r = n * n + i * i;
            r > 0 && (r = 1 / Math.sqrt(r), t.x = n * r, t.y = i * r);
        }, Vector2.scalarLength = function(e) {
            var t = e.x, n = e.y;
            return Math.sqrt(t * t + n * n);
        }, Vector2.rewriteNumProperty = function(e, t, n) {
            Object.defineProperty(e, t, {
                get: function() {
                    return this.elements[n];
                },
                set: function(e) {
                    this.elements[n] = e;
                }
            });
        }, i(Vector2, [ "ZERO", function() {
            return this.ZERO = new Vector2(0, 0);
        }, "ONE", function() {
            return this.ONE = new Vector2(1, 1);
        } ]), Vector2;
    }(), Ee = function() {
        function AnimatorPlayState() {}
        r(AnimatorPlayState, "laya.d3.component.AnimatorPlayState");
        var e = AnimatorPlayState.prototype;
        return e._resetPlayState = function(e) {
            this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0, 
            this._lastIsFront = !0;
        }, e._cloneTo = function(e) {
            e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime, 
            e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
        }, a(0, e, "normalizedTime", function() {
            return this._normalizedTime;
        }), a(0, e, "duration", function() {
            return this._duration;
        }), AnimatorPlayState;
    }(), ve = function() {
        function VelocityOverLifetime(e) {
            this._velocity = null, this.enbale = !1, this.space = 0, this._velocity = e;
        }
        r(VelocityOverLifetime, "laya.d3.core.particleShuriKen.module.VelocityOverLifetime");
        var e = VelocityOverLifetime.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            this._velocity.cloneTo(t._velocity), t.enbale = this.enbale, t.space = this.space;
        }, e.clone = function() {
            var e;
            switch (this._velocity.type) {
              case 0:
                e = xt.createByConstant(this._velocity.constant.clone());
                break;

              case 1:
                e = xt.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                break;

              case 2:
                e = xt.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                break;

              case 3:
                e = xt.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
            }
            var t = new this.constructor(e);
            return t.enbale = this.enbale, t.space = this.space, t;
        }, a(0, e, "velocity", function() {
            return this._velocity;
        }), VelocityOverLifetime;
    }(), ge = function() {
        function MeshReader() {}
        return r(MeshReader, "laya.d3.loaders.MeshReader"), MeshReader.read = function(e, t, n) {
            var i = new c(e);
            i.pos = 0;
            var r = i.readUTFString();
            switch (r) {
              case "LAYAMODEL:0301":
              case "LAYAMODEL:0400":
              case "LAYAMODEL:0401":
                ye.parse(i, r, t, n);
                break;

              case "LAYAMODEL:05":
              case "LAYAMODEL:COMPRESSION_05":
                xe.parse(i, r, t, n);
                break;

              default:
                throw new Error("MeshReader: unknown mesh version.");
            }
            t._setSubMeshes(n);
        }, MeshReader;
    }(), xe = (function() {
        function SceneManager() {}
        r(SceneManager, "laya.d3.core.scene.SceneManager");
    }(), function() {
        function ContainmentType() {}
        r(ContainmentType, "laya.d3.math.ContainmentType"), ContainmentType.Disjoint = 0, 
        ContainmentType.Contains = 1, ContainmentType.Intersects = 2;
    }(), function() {
        function LoadModelV05() {}
        return r(LoadModelV05, "laya.d3.loaders.LoadModelV05"), LoadModelV05.parse = function(e, t, n, i) {
            LoadModelV05._mesh = n, LoadModelV05._subMeshes = i, LoadModelV05._version = t, 
            LoadModelV05._readData = e, LoadModelV05.READ_DATA(), LoadModelV05.READ_BLOCK(), 
            LoadModelV05.READ_STRINGS();
            for (var r = 0, a = LoadModelV05._BLOCK.count; r < a; r++) {
                LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[r];
                var o = LoadModelV05._readData.getUint16(), s = LoadModelV05._strings[o], l = LoadModelV05["READ_" + s];
                if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                l.call(null);
            }
            LoadModelV05._mesh._bindPoseIndices = new Uint16Array(LoadModelV05._bindPoseIndices), 
            LoadModelV05._bindPoseIndices.length = 0, LoadModelV05._strings.length = 0, LoadModelV05._readData = null, 
            LoadModelV05._version = null, LoadModelV05._mesh = null, LoadModelV05._subMeshes = null;
        }, LoadModelV05._readString = function() {
            return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
        }, LoadModelV05.READ_DATA = function() {
            LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(), LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
        }, LoadModelV05.READ_BLOCK = function() {
            for (var e = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), t = LoadModelV05._BLOCK.blockStarts = [], n = LoadModelV05._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(LoadModelV05._readData.getUint32()), 
            n.push(LoadModelV05._readData.getUint32());
        }, LoadModelV05.READ_STRINGS = function() {
            var e = LoadModelV05._readData.getUint32(), t = LoadModelV05._readData.getUint16(), n = LoadModelV05._readData.pos;
            LoadModelV05._readData.pos = e + LoadModelV05._DATA.offset;
            for (var i = 0; i < t; i++) LoadModelV05._strings[i] = LoadModelV05._readData.readUTFString();
            LoadModelV05._readData.pos = n;
        }, LoadModelV05.READ_MESH = function() {
            var e = 0, t = 0, n = (LoadModelV05._readString(), LoadModelV05._readData.__getBuffer()), i = LoadModelV05._readData.getInt16(), r = LoadModelV05._DATA.offset;
            for (e = 0; e < i; e++) {
                var a = r + LoadModelV05._readData.getUint32(), s = LoadModelV05._readData.getUint32(), l = LoadModelV05._readString(), h = De.getVertexDeclaration(l, !1), u = h.vertexStride, c = new ArrayBuffer(u * s), d = new Float32Array(c), _ = l.split(","), f = _.length;
                switch (LoadModelV05._version) {
                  case "LAYAMODEL:05":
                    d = new Float32Array(n.slice(a, a + s * u));
                    break;

                  case "LAYAMODEL:COMPRESSION_05":
                    var m = LoadModelV05._readData.pos;
                    d = new Float32Array(c);
                    var p = new Uint8Array(c);
                    LoadModelV05._readData.pos = a;
                    for (var T = 0; T < s; T++) for (var S = 0, E = T * u, v = 0; v < f; v++) switch (_[v]) {
                      case "POSITION":
                        d[S = E / 4] = Ae.convertToNumber(LoadModelV05._readData.getUint16()), d[S + 1] = Ae.convertToNumber(LoadModelV05._readData.getUint16()), 
                        d[S + 2] = Ae.convertToNumber(LoadModelV05._readData.getUint16()), E += 12;
                        break;

                      case "NORMAL":
                        d[S = E / 4] = LoadModelV05._readData.getUint8() / 127.5 - 1, d[S + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1, 
                        d[S + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1, E += 12;
                        break;

                      case "COLOR":
                        d[S = E / 4] = LoadModelV05._readData.getUint8() / 255, d[S + 1] = LoadModelV05._readData.getUint8() / 255, 
                        d[S + 2] = LoadModelV05._readData.getUint8() / 255, d[S + 3] = LoadModelV05._readData.getUint8() / 255, 
                        E += 16;
                        break;

                      case "UV":
                      case "UV1":
                        d[S = E / 4] = Ae.convertToNumber(LoadModelV05._readData.getUint16()), d[S + 1] = Ae.convertToNumber(LoadModelV05._readData.getUint16()), 
                        E += 8;
                        break;

                      case "BLENDWEIGHT":
                        d[S = E / 4] = LoadModelV05._readData.getUint8() / 255, d[S + 1] = LoadModelV05._readData.getUint8() / 255, 
                        d[S + 2] = LoadModelV05._readData.getUint8() / 255, d[S + 3] = LoadModelV05._readData.getUint8() / 255, 
                        E += 16;
                        break;

                      case "BLENDINDICES":
                        p[E] = LoadModelV05._readData.getUint8(), p[E + 1] = LoadModelV05._readData.getUint8(), 
                        p[E + 2] = LoadModelV05._readData.getUint8(), p[E + 3] = LoadModelV05._readData.getUint8(), 
                        E += 4;
                        break;

                      case "TANGENT":
                        d[S = E / 4] = LoadModelV05._readData.getUint8() / 127.5 - 1, d[S + 1] = LoadModelV05._readData.getUint8() / 127.5 - 1, 
                        d[S + 2] = LoadModelV05._readData.getUint8() / 127.5 - 1, d[S + 3] = LoadModelV05._readData.getUint8() / 127.5 - 1, 
                        E += 16;
                    }
                    LoadModelV05._readData.pos = m;
                }
                var g = new Qt(c.byteLength, 35044, !0);
                g.vertexDeclaration = h, g.setData(d), LoadModelV05._mesh._vertexBuffers.push(g), 
                LoadModelV05._mesh._vertexCount += g.vertexCount, t += 4 * d.length;
            }
            var x = r + LoadModelV05._readData.getUint32(), M = LoadModelV05._readData.getUint32(), y = new Uint16Array(n.slice(x, x + M)), D = new jt("ushort", M / 2, 35044, !0);
            D.setData(y), LoadModelV05._mesh._indexBuffer = D, LoadModelV05._mesh._setBuffer(LoadModelV05._mesh._vertexBuffers, D), 
            t += 2 * D.indexCount, LoadModelV05._mesh._setCPUMemory(t), LoadModelV05._mesh._setGPUMemory(t);
            var R = LoadModelV05._mesh._boneNames = [], C = LoadModelV05._readData.getUint16();
            for (R.length = C, e = 0; e < C; e++) R[e] = LoadModelV05._strings[LoadModelV05._readData.getUint16()];
            var I = LoadModelV05._readData.getUint32(), A = LoadModelV05._readData.getUint32(), L = new Float32Array(n.slice(r + I, r + I + A)), O = L.length, P = O / 16, V = LoadModelV05._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * O);
            for (LoadModelV05._mesh._inverseBindPoses = o(P), e = 0; e < O; e += 16) {
                var N = new Ht(L[e + 0], L[e + 1], L[e + 2], L[e + 3], L[e + 4], L[e + 5], L[e + 6], L[e + 7], L[e + 8], L[e + 9], L[e + 10], L[e + 11], L[e + 12], L[e + 13], L[e + 14], L[e + 15], new Float32Array(V, 4 * e, 16));
                LoadModelV05._mesh._inverseBindPoses[e / 16] = N;
            }
            return !0;
        }, LoadModelV05.READ_SUBMESH = function() {
            var e = LoadModelV05._readData.__getBuffer(), t = new on(LoadModelV05._mesh), n = LoadModelV05._readData.getInt16(), i = LoadModelV05._readData.getUint32(), r = LoadModelV05._readData.getUint32(), a = LoadModelV05._mesh._indexBuffer;
            t._indexBuffer = a, t._indexStart = i, t._indexCount = r, t._indices = new Uint16Array(a.getData().buffer, 2 * i, r);
            var o = LoadModelV05._mesh._vertexBuffers[n];
            t._vertexBuffer = o;
            var s = LoadModelV05._DATA.offset, l = t._subIndexBufferStart, h = t._subIndexBufferCount, u = t._boneIndicesList, c = LoadModelV05._readData.getUint16();
            l.length = c, h.length = c, u.length = c;
            for (var d = LoadModelV05._mesh._skinDataPathMarks, _ = LoadModelV05._bindPoseIndices, f = LoadModelV05._subMeshes.length, m = 0; m < c; m++) {
                l[m] = LoadModelV05._readData.getUint32(), h[m] = LoadModelV05._readData.getUint32();
                for (var p = LoadModelV05._readData.getUint32(), T = LoadModelV05._readData.getUint32(), S = u[m] = new Uint16Array(e.slice(s + p, s + p + T)), E = 0, v = S.length; E < v; E++) {
                    var g = S[E], x = _.indexOf(g);
                    -1 === x ? (S[E] = _.length, _.push(g), d.push([ f, m, E ])) : S[E] = x;
                }
            }
            return LoadModelV05._subMeshes.push(t), !0;
        }, LoadModelV05._strings = [], LoadModelV05._readData = null, LoadModelV05._version = null, 
        LoadModelV05._mesh = null, LoadModelV05._subMeshes = null, LoadModelV05._bindPoseIndices = [], 
        i(LoadModelV05, [ "_BLOCK", function() {
            return this._BLOCK = {
                count: 0
            };
        }, "_DATA", function() {
            return this._DATA = {
                offset: 0,
                size: 0
            };
        } ]), LoadModelV05;
    }()), Me = function() {
        function Color(e, t, n, i) {
            this.r = NaN, this.g = NaN, this.b = NaN, this.a = NaN, void 0 === e && (e = 1), 
            void 0 === t && (t = 1), void 0 === n && (n = 1), void 0 === i && (i = 1), this.r = e, 
            this.g = t, this.b = n, this.a = i;
        }
        r(Color, "laya.d3.math.Color");
        var e = Color.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.toLinear = function(e) {
            e.r = ke.gammaToLinearSpace(this.r), e.g = ke.gammaToLinearSpace(this.g), e.b = ke.gammaToLinearSpace(this.b);
        }, e.toGamma = function(e) {
            e.r = ke.linearToGammaSpace(this.r), e.g = ke.linearToGammaSpace(this.g), e.b = ke.linearToGammaSpace(this.b);
        }, e.cloneTo = function(e) {
            var t = e;
            t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.forNativeElement = function(e) {
            e ? (this.elements = e, this.elements[0] = this.r, this.elements[1] = this.g, this.elements[2] = this.b, 
            this.elements[3] = this.a) : this.elements = new Float32Array([ this.r, this.g, this.b, this.a ]), 
            Se.rewriteNumProperty(this, "r", 0), Se.rewriteNumProperty(this, "g", 1), Se.rewriteNumProperty(this, "b", 2), 
            Se.rewriteNumProperty(this, "a", 3);
        }, i(Color, [ "RED", function() {
            return this.RED = new Color(1, 0, 0, 1);
        }, "GREEN", function() {
            return this.GREEN = new Color(0, 1, 0, 1);
        }, "BLUE", function() {
            return this.BLUE = new Color(0, 0, 1, 1);
        }, "CYAN", function() {
            return this.CYAN = new Color(0, 1, 1, 1);
        }, "YELLOW", function() {
            return this.YELLOW = new Color(1, .92, .016, 1);
        }, "MAGENTA", function() {
            return this.MAGENTA = new Color(1, 0, 1, 1);
        }, "GRAY", function() {
            return this.GRAY = new Color(.5, .5, .5, 1);
        }, "WHITE", function() {
            return this.WHITE = new Color(1, 1, 1, 1);
        }, "BLACK", function() {
            return this.BLACK = new Color(0, 0, 0, 1);
        } ]), Color;
    }(), ye = function() {
        function LoadModelV04() {}
        return r(LoadModelV04, "laya.d3.loaders.LoadModelV04"), LoadModelV04.parse = function(e, t, n, i) {
            LoadModelV04._mesh = n, LoadModelV04._subMeshes = i, LoadModelV04._version = t, 
            LoadModelV04._readData = e, LoadModelV04.READ_DATA(), LoadModelV04.READ_BLOCK(), 
            LoadModelV04.READ_STRINGS();
            for (var r = 0, a = LoadModelV04._BLOCK.count; r < a; r++) {
                LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[r];
                var o = LoadModelV04._readData.getUint16(), s = LoadModelV04._strings[o], l = LoadModelV04["READ_" + s];
                if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                l.call(null);
            }
            LoadModelV04._mesh._bindPoseIndices = new Uint16Array(LoadModelV04._bindPoseIndices), 
            LoadModelV04._bindPoseIndices.length = 0, LoadModelV04._strings.length = 0, LoadModelV04._readData = null, 
            LoadModelV04._version = null, LoadModelV04._mesh = null, LoadModelV04._subMeshes = null;
        }, LoadModelV04._readString = function() {
            return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
        }, LoadModelV04.READ_DATA = function() {
            LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(), LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
        }, LoadModelV04.READ_BLOCK = function() {
            for (var e = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), t = LoadModelV04._BLOCK.blockStarts = [], n = LoadModelV04._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(LoadModelV04._readData.getUint32()), 
            n.push(LoadModelV04._readData.getUint32());
        }, LoadModelV04.READ_STRINGS = function() {
            var e = LoadModelV04._readData.getUint32(), t = LoadModelV04._readData.getUint16(), n = LoadModelV04._readData.pos;
            LoadModelV04._readData.pos = e + LoadModelV04._DATA.offset;
            for (var i = 0; i < t; i++) LoadModelV04._strings[i] = LoadModelV04._readData.readUTFString();
            LoadModelV04._readData.pos = n;
        }, LoadModelV04.READ_MESH = function() {
            LoadModelV04._readString();
            var e = LoadModelV04._readData.__getBuffer(), t = 0, n = 0, i = LoadModelV04._readData.getInt16(), r = LoadModelV04._DATA.offset;
            for (t = 0; t < i; t++) {
                var a, s = r + LoadModelV04._readData.getUint32(), l = LoadModelV04._readData.getUint32(), h = new Float32Array(e.slice(s, s + l)), u = LoadModelV04._readString();
                switch (LoadModelV04._version) {
                  case "LAYAMODEL:0301":
                  case "LAYAMODEL:0400":
                    a = De.getVertexDeclaration(u);
                    break;

                  case "LAYAMODEL:0401":
                    a = De.getVertexDeclaration(u, !1);
                    break;

                  default:
                    throw new Error("LoadModelV03: unknown version.");
                }
                if (!a) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                var c = new Qt(4 * h.length, 35044, !0);
                c.vertexDeclaration = a, c.setData(h), LoadModelV04._mesh._vertexBuffers.push(c), 
                LoadModelV04._mesh._vertexCount += c.vertexCount, n += 4 * h.length;
            }
            var d = r + LoadModelV04._readData.getUint32(), _ = LoadModelV04._readData.getUint32(), f = new Uint16Array(e.slice(d, d + _)), m = new jt("ushort", _ / 2, 35044, !0);
            m.setData(f), LoadModelV04._mesh._indexBuffer = m, n += 2 * m.indexCount, LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffers, m), 
            LoadModelV04._mesh._setCPUMemory(n), LoadModelV04._mesh._setGPUMemory(n);
            var p = LoadModelV04._mesh._boneNames = [], T = LoadModelV04._readData.getUint16();
            for (p.length = T, t = 0; t < T; t++) p[t] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
            LoadModelV04._readData.pos += 8;
            var S = LoadModelV04._readData.getUint32(), E = LoadModelV04._readData.getUint32(), v = new Float32Array(e.slice(r + S, r + S + E)), g = v.length, x = g / 16, M = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * g);
            for (LoadModelV04._mesh._inverseBindPoses = o(x), t = 0; t < g; t += 16) {
                var y = new Ht(v[t + 0], v[t + 1], v[t + 2], v[t + 3], v[t + 4], v[t + 5], v[t + 6], v[t + 7], v[t + 8], v[t + 9], v[t + 10], v[t + 11], v[t + 12], v[t + 13], v[t + 14], v[t + 15], new Float32Array(M, 4 * t, 16));
                LoadModelV04._mesh._inverseBindPoses[t / 16] = y;
            }
            return !0;
        }, LoadModelV04.READ_SUBMESH = function() {
            var e = LoadModelV04._readData.__getBuffer(), t = new on(LoadModelV04._mesh), n = LoadModelV04._readData.getInt16();
            LoadModelV04._readData.getUint32(), LoadModelV04._readData.getUint32();
            var i = LoadModelV04._readData.getUint32(), r = LoadModelV04._readData.getUint32(), a = LoadModelV04._mesh._indexBuffer;
            t._indexBuffer = a, t._indexStart = i, t._indexCount = r, t._indices = new Uint16Array(a.getData().buffer, 2 * i, r);
            var o = LoadModelV04._mesh._vertexBuffers[n];
            t._vertexBuffer = o;
            var s = LoadModelV04._DATA.offset, l = t._subIndexBufferStart, h = t._subIndexBufferCount, u = t._boneIndicesList, c = LoadModelV04._readData.getUint16();
            l.length = c, h.length = c, u.length = c;
            for (var d = LoadModelV04._mesh._skinDataPathMarks, _ = LoadModelV04._bindPoseIndices, f = LoadModelV04._subMeshes.length, m = 0; m < c; m++) {
                l[m] = LoadModelV04._readData.getUint32(), h[m] = LoadModelV04._readData.getUint32();
                for (var p = LoadModelV04._readData.getUint32(), T = LoadModelV04._readData.getUint32(), S = u[m] = new Uint16Array(e.slice(s + p, s + p + T)), E = 0, v = S.length; E < v; E++) {
                    var g = S[E], x = _.indexOf(g);
                    -1 === x ? (S[E] = _.length, _.push(g), d.push([ f, m, E ])) : S[E] = x;
                }
            }
            return LoadModelV04._subMeshes.push(t), !0;
        }, LoadModelV04._strings = [], LoadModelV04._readData = null, LoadModelV04._version = null, 
        LoadModelV04._mesh = null, LoadModelV04._subMeshes = null, LoadModelV04._bindPoseIndices = [], 
        i(LoadModelV04, [ "_BLOCK", function() {
            return this._BLOCK = {
                count: 0
            };
        }, "_DATA", function() {
            return this._DATA = {
                offset: 0,
                size: 0
            };
        } ]), LoadModelV04;
    }(), De = function() {
        function VertexMesh() {}
        return r(VertexMesh, "laya.d3.graphics.Vertex.VertexMesh"), VertexMesh.getVertexDeclaration = function(e, t) {
            void 0 === t && (t = !0);
            var n = VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")];
            if (!n) {
                for (var i = e.split(","), r = 0, a = [], o = 0, s = i.length; o < s; o++) {
                    var l;
                    switch (i[o]) {
                      case "POSITION":
                        l = new ze(r, "vector3", 0), r += 12;
                        break;

                      case "NORMAL":
                        l = new ze(r, "vector3", 3), r += 12;
                        break;

                      case "COLOR":
                        l = new ze(r, "vector4", 1), r += 16;
                        break;

                      case "UV":
                        l = new ze(r, "vector2", 2), r += 8;
                        break;

                      case "UV1":
                        l = new ze(r, "vector2", 7), r += 8;
                        break;

                      case "BLENDWEIGHT":
                        l = new ze(r, "vector4", 6), r += 16;
                        break;

                      case "BLENDINDICES":
                        t ? (l = new ze(r, "vector4", 5), r += 16) : (l = new ze(r, "byte4", 5), r += 4);
                        break;

                      case "TANGENT":
                        l = new ze(r, "vector4", 4), r += 16;
                        break;

                      default:
                        throw "VertexMesh: unknown vertex flag.";
                    }
                    a.push(l);
                }
                n = new ft(r, a), VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")] = n;
            }
            return n;
        }, VertexMesh.MESH_POSITION0 = 0, VertexMesh.MESH_COLOR0 = 1, VertexMesh.MESH_TEXTURECOORDINATE0 = 2, 
        VertexMesh.MESH_NORMAL0 = 3, VertexMesh.MESH_TANGENT0 = 4, VertexMesh.MESH_BLENDINDICES0 = 5, 
        VertexMesh.MESH_BLENDWEIGHT0 = 6, VertexMesh.MESH_TEXTURECOORDINATE1 = 7, VertexMesh.MESH_WORLDMATRIX_ROW0 = 8, 
        VertexMesh.MESH_WORLDMATRIX_ROW1 = 9, VertexMesh.MESH_WORLDMATRIX_ROW2 = 10, VertexMesh.MESH_WORLDMATRIX_ROW3 = 11, 
        VertexMesh.MESH_MVPMATRIX_ROW0 = 12, VertexMesh.MESH_MVPMATRIX_ROW1 = 13, VertexMesh.MESH_MVPMATRIX_ROW2 = 14, 
        VertexMesh.MESH_MVPMATRIX_ROW3 = 15, VertexMesh._vertexDeclarationMap = {}, i(VertexMesh, [ "instanceWorldMatrixDeclaration", function() {
            return this.instanceWorldMatrixDeclaration = new ft(64, [ new ze(0, "vector4", 8), new ze(16, "vector4", 9), new ze(32, "vector4", 10), new ze(48, "vector4", 11) ]);
        }, "instanceMVPMatrixDeclaration", function() {
            return this.instanceMVPMatrixDeclaration = new ft(64, [ new ze(0, "vector4", 12), new ze(16, "vector4", 13), new ze(32, "vector4", 14), new ze(48, "vector4", 15) ]);
        } ]), VertexMesh;
    }(), Re = function() {
        function Emission() {
            this._destroyed = !1, this._emissionRate = 0, this._bursts = null, this.enbale = !1, 
            this._destroyed = !1, this.emissionRate = 10, this._bursts = [];
        }
        r(Emission, "laya.d3.core.particleShuriKen.module.Emission");
        var e = Emission.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0,
            "laya.resource.IDestroy": !0
        }), e.destroy = function() {
            this._bursts = null, this._destroyed = !0;
        }, e.getBurstsCount = function() {
            return this._bursts.length;
        }, e.getBurstByIndex = function(e) {
            return this._bursts[e];
        }, e.addBurst = function(e) {
            var t = this._bursts.length;
            if (t > 0) for (var n = 0; n < t; n++) this._bursts[n].time > e.time && this._bursts.splice(n, 0, e);
            this._bursts.push(e);
        }, e.removeBurst = function(e) {
            var t = this._bursts.indexOf(e);
            -1 !== t && this._bursts.splice(t, 1);
        }, e.removeBurstByIndex = function(e) {
            this._bursts.splice(e, 1);
        }, e.clearBurst = function() {
            this._bursts.length = 0;
        }, e.cloneTo = function(e) {
            var t = e, n = t._bursts;
            n.length = this._bursts.length;
            for (var i = 0, r = this._bursts.length; i < r; i++) {
                var a = n[i];
                a ? this._bursts[i].cloneTo(a) : n[i] = this._bursts[i].clone();
            }
            t._emissionRate = this._emissionRate, t.enbale = this.enbale;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "destroyed", function() {
            return this._destroyed;
        }), a(0, e, "emissionRate", function() {
            return this._emissionRate;
        }, function(e) {
            if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
            this._emissionRate = e;
        }), Emission;
    }(), Ce = function() {
        function BoundSphere(e, t) {
            this.center = null, this.radius = NaN, this.center = e, this.radius = t;
        }
        r(BoundSphere, "laya.d3.math.BoundSphere");
        var e = BoundSphere.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.toDefault = function() {
            this.center.toDefault(), this.radius = 0;
        }, e.intersectsRayDistance = function(e) {
            return bt.intersectsRayAndSphereRD(e, this);
        }, e.intersectsRayPoint = function(e, t) {
            return bt.intersectsRayAndSphereRP(e, this, t);
        }, e.cloneTo = function(e) {
            var t = e;
            this.center.cloneTo(t.center), t.radius = this.radius;
        }, e.clone = function() {
            var e = new this.constructor(new Te(), new Te());
            return this.cloneTo(e), e;
        }, BoundSphere.createFromSubPoints = function(e, t, n, i) {
            if (null == e) throw new Error("points");
            if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
            if (n < 0 || t + n > e.length) throw new Error("count" + n + "Must be in the range <= " + e.length + "}");
            var r = t + n, a = BoundSphere._tempVector3;
            a.x = 0, a.y = 0, a.z = 0;
            for (var o = t; o < r; ++o) Te.add(e[o], a, a);
            var s = i.center;
            Te.scale(a, 1 / n, s);
            var l = 0;
            for (o = t; o < r; ++o) {
                var h = Te.distanceSquared(s, e[o]);
                h > l && (l = h);
            }
            i.radius = Math.sqrt(l);
        }, BoundSphere.createfromPoints = function(e, t) {
            if (null == e) throw new Error("points");
            BoundSphere.createFromSubPoints(e, 0, e.length, t);
        }, i(BoundSphere, [ "_tempVector3", function() {
            return this._tempVector3 = new Te();
        } ]), BoundSphere;
    }(), Ie = function() {
        function RenderElement() {
            this.renderType = 0;
        }
        r(RenderElement, "laya.d3.core.render.RenderElement");
        var e = RenderElement.prototype;
        return e.setTransform = function(e) {
            this._transform = e;
        }, e.setGeometry = function(e) {
            this._geometry = e;
        }, e.addToOpaqueRenderQueue = function(e, t) {
            t.elements.push(this);
        }, e.addToTransparentRenderQueue = function(e, t) {
            t.elements.push(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
        }, e._render = function(e, t, n, i) {
            var r, a, o, s = Ci._updateMark, l = e.scene, h = e.camera, u = this._transform, c = this._geometry;
            e.renderElement = this;
            var d = s !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
            if (d && (this.render._renderUpdate(e, u), this.render._renderUpdateWithCamera(e, u), 
            this.render._updateMark = s, this.render._updateRenderType = this.renderType), c._prepareRender(e)) {
                var _, f = this.material._shader.getSubShaderAt(0);
                if (n) if (i) {
                    var m = f.getFlag(i);
                    if (!m) return;
                    for (var p = n._subShaders, T = 0, S = p.length; T < S; T++) {
                        var E = p[T];
                        if (m === E.getFlag(i)) {
                            _ = E._passes;
                            break;
                        }
                    }
                    if (!_) return;
                } else _ = n.getSubShaderAt(0)._passes; else _ = f._passes;
                for (var v = 0, g = _.length; v < g; v++) {
                    var x = e.shader = _[v].withCompile(l._defineDatas.value & ~this.material._disablePublicDefineDatas.value, this.render._defineDatas.value, this.material._defineDatas.value), M = x.bind(), y = s !== x._uploadMark, D = x._uploadScene !== l || y;
                    (D || M) && (x.uploadUniforms(x._sceneUniformParamsMap, l._shaderValues, D), x._uploadScene = l);
                    var R = x._uploadRender !== this.render || x._uploadRenderType !== this.renderType || y;
                    (R || M) && (x.uploadUniforms(x._spriteUniformParamsMap, this.render._shaderValues, R), 
                    x._uploadRender = this.render, x._uploadRenderType = this.renderType);
                    var C = x._uploadCamera !== h || y;
                    (C || M) && (x.uploadUniforms(x._cameraUniformParamsMap, h._shaderValues, C), x._uploadCamera = h);
                    var I = x._uploadMaterial !== this.material || y;
                    (I || M) && (x.uploadUniforms(x._materialUniformParamsMap, this.material._shaderValues, I), 
                    x._uploadMaterial = this.material);
                    var A = this.material._shaderValues;
                    r !== this.material || a !== x ? (x.uploadRenderStateBlendDepth(A), x.uploadRenderStateFrontFace(A, t, u), 
                    r = this.material, a = x, o = this.render) : o !== this.render && (x.uploadRenderStateFrontFace(A, t, u), 
                    o = this.render), c._render(e), x._uploadMark = s;
                }
            }
            d && 0 !== this.renderType && this.render._revertBatchRenderUpdate(e), Ci._updateMark++;
        }, e.destroy = function() {
            this._transform = null, this._geometry = null, this.material = null, this.render = null;
        }, RenderElement.RENDERTYPE_NORMAL = 0, RenderElement.RENDERTYPE_STATICBATCH = 1, 
        RenderElement.RENDERTYPE_INSTANCEBATCH = 2, RenderElement.RENDERTYPE_VERTEXBATCH = 3, 
        RenderElement;
    }(), Ae = function() {
        function HalfFloatUtils() {}
        return r(HalfFloatUtils, "laya.d3.math.HalfFloatUtils"), HalfFloatUtils.__init__ = function() {
            for (var e = 0; e < 256; ++e) {
                var t = e - 127;
                t < -27 ? (HalfFloatUtils._baseTable[0 | e] = 0, HalfFloatUtils._baseTable[256 | e] = 32768, 
                HalfFloatUtils._shiftTable[0 | e] = 24, HalfFloatUtils._shiftTable[256 | e] = 24) : t < -14 ? (HalfFloatUtils._baseTable[0 | e] = 1024 >> -t - 14, 
                HalfFloatUtils._baseTable[256 | e] = 1024 >> -t - 14 | 32768, HalfFloatUtils._shiftTable[0 | e] = -t - 1, 
                HalfFloatUtils._shiftTable[256 | e] = -t - 1) : t <= 15 ? (HalfFloatUtils._baseTable[0 | e] = t + 15 << 10, 
                HalfFloatUtils._baseTable[256 | e] = t + 15 << 10 | 32768, HalfFloatUtils._shiftTable[0 | e] = 13, 
                HalfFloatUtils._shiftTable[256 | e] = 13) : t < 128 ? (HalfFloatUtils._baseTable[0 | e] = 31744, 
                HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 24, 
                HalfFloatUtils._shiftTable[256 | e] = 24) : (HalfFloatUtils._baseTable[0 | e] = 31744, 
                HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 13, 
                HalfFloatUtils._shiftTable[256 | e] = 13);
            }
            for (HalfFloatUtils._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                var n = e << 13;
                for (t = 0; 0 == (8388608 & n); ) t -= 8388608, n <<= 1;
                n &= -8388609, t += 947912704, HalfFloatUtils._mantissaTable[e] = n | t;
            }
            for (e = 1024; e < 2048; ++e) HalfFloatUtils._mantissaTable[e] = 939524096 + (e - 1024 << 13);
            for (HalfFloatUtils._exponentTable[0] = 0, e = 1; e < 31; ++e) HalfFloatUtils._exponentTable[e] = e << 23;
            for (HalfFloatUtils._exponentTable[31] = 1199570944, HalfFloatUtils._exponentTable[32] = 2147483648, 
            e = 33; e < 63; ++e) HalfFloatUtils._exponentTable[e] = 2147483648 + (e - 32 << 23);
            for (HalfFloatUtils._exponentTable[63] = 3347054592, HalfFloatUtils._offsetTable[0] = 0, 
            e = 1; e < 64; ++e) HalfFloatUtils._offsetTable[e] = 32 === e ? 0 : 1024;
        }, HalfFloatUtils.roundToFloat16Bits = function(e) {
            HalfFloatUtils._floatView[0] = e;
            var t = HalfFloatUtils._uint32View[0], n = t >> 23 & 511;
            return HalfFloatUtils._baseTable[n] + ((8388607 & t) >> HalfFloatUtils._shiftTable[n]);
        }, HalfFloatUtils.convertToNumber = function(e) {
            var t = e >> 10;
            return HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[t] + (1023 & e)] + HalfFloatUtils._exponentTable[t], 
            HalfFloatUtils._floatView[0];
        }, i(HalfFloatUtils, [ "_buffer", function() {
            return this._buffer = new ArrayBuffer(4);
        }, "_floatView", function() {
            return this._floatView = new Float32Array(HalfFloatUtils._buffer);
        }, "_uint32View", function() {
            return this._uint32View = new Uint32Array(HalfFloatUtils._buffer);
        }, "_baseTable", function() {
            return this._baseTable = new Uint32Array(512);
        }, "_shiftTable", function() {
            return this._shiftTable = new Uint32Array(512);
        }, "_mantissaTable", function() {
            return this._mantissaTable = new Uint32Array(2048);
        }, "_exponentTable", function() {
            return this._exponentTable = new Uint32Array(64);
        }, "_offsetTable", function() {
            return this._offsetTable = new Uint32Array(64);
        } ]), HalfFloatUtils;
    }(), Le = function() {
        function SkyMesh() {
            this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = null;
        }
        return r(SkyMesh, "laya.d3.resource.models.SkyMesh"), SkyMesh.prototype._render = function(e) {}, 
        SkyMesh;
    }(), Oe = function() {
        function TextureSheetAnimation(e, t) {
            this._frame = null, this._startFrame = null, this.tiles = null, this.type = 0, this.randomRow = !1, 
            this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, this.enable = !1, 
            this.tiles = new Se(1, 1), this.type = 0, this.randomRow = !0, this.rowIndex = 0, 
            this.cycles = 1, this.enableUVChannels = 1, this._frame = e, this._startFrame = t;
        }
        r(TextureSheetAnimation, "laya.d3.core.particleShuriKen.module.TextureSheetAnimation");
        var e = TextureSheetAnimation.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, this._frame.cloneTo(t._frame), 
            this._startFrame.cloneTo(t._startFrame), t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, 
            t.enable = this.enable;
        }, e.clone = function() {
            var e, t;
            switch (this._frame.type) {
              case 0:
                e = Y.createByConstant(this._frame.constant);
                break;

              case 1:
                e = Y.createByOverTime(this._frame.frameOverTimeData.clone());
                break;

              case 2:
                e = Y.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                break;

              case 3:
                e = Y.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
            }
            switch (this._startFrame.type) {
              case 0:
                t = yt.createByConstant(this._startFrame.constant);
                break;

              case 1:
                t = yt.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
            }
            var n = new this.constructor(e, t);
            return this.tiles.cloneTo(n.tiles), n.type = this.type, n.randomRow = this.randomRow, 
            n.cycles = this.cycles, n.enableUVChannels = this.enableUVChannels, n.enable = this.enable, 
            n;
        }, a(0, e, "frame", function() {
            return this._frame;
        }), a(0, e, "startFrame", function() {
            return this._startFrame;
        }), TextureSheetAnimation;
    }(), Pe = function() {
        function TextureGenerator() {}
        return r(TextureGenerator, "laya.d3.resource.TextureGenerator"), TextureGenerator.lightAttenTexture = function(e, t, n, i, r, a) {
            var o = e / n, s = 1 / (1 + 25 * o);
            o >= .64 && (o > 1 ? s = 0 : s *= 1 - (o - .64) / .36), a[r] = Math.floor(255 * s + .5);
        }, TextureGenerator.haloTexture = function(e, t, n, i, r, a) {
            var o = (e - (n >>= 1)) / n, s = (t - (i >>= 1)) / i, l = o * o + s * s;
            l > 1 && (l = 1), a[r] = Math.floor(255 * (1 - l) + .5);
        }, TextureGenerator._generateTexture2D = function(e, t, n, i) {
            var r = 0, a = 0;
            switch (e.format) {
              case 0:
                a = 3;
                break;

              case 1:
                a = 4;
                break;

              case 2:
                a = 1;
                break;

              default:
                throw "GeneratedTexture._generateTexture: unkonw texture format.";
            }
            for (var o = new Uint8Array(t * n * a), s = 0; s < n; s++) for (var l = 0; l < t; l++) i(l, s, t, n, r, o), 
            r += a;
            e.setPixels(o);
        }, TextureGenerator;
    }(), Ve = function() {
        function Shader3D(e, t, n, i) {
            this._attributeMap = null, this._uniformMap = null, this._enableInstancing = !1, 
            this._subShaders = [], this._name = e, this._attributeMap = t, this._uniformMap = n, 
            this._enableInstancing = i;
        }
        r(Shader3D, "laya.d3.shader.Shader3D");
        var e = Shader3D.prototype;
        return e.addSubShader = function(e) {
            this._subShaders.push(e), e._owner = this;
        }, e.getSubShaderAt = function(e) {
            return this._subShaders[e];
        }, Shader3D.propertyNameToID = function(e) {
            if (null != Shader3D._propertyNameMap[e]) return Shader3D._propertyNameMap[e];
            var t = Shader3D._propertyNameCounter++;
            return Shader3D._propertyNameMap[e] = t, t;
        }, Shader3D.addInclude = function(e, t) {
            A.addInclude(e, t);
        }, Shader3D.registerPublicDefine = function(e) {
            var t = Math.pow(2, Shader3D._publicCounter++);
            return Shader3D._globleDefines[t] = e, t;
        }, Shader3D.compileShader = function(e, t, n, i, r, a) {
            var o = laya.d3.shader.Shader3D.find(e);
            if (o) {
                var s = o.getSubShaderAt(t);
                if (s) {
                    var l = s._passes[n];
                    l ? b.shaderHighPrecision ? l.withCompile(i, r, a) : l.withCompile(i - laya.d3.shader.Shader3D.SHADERDEFINE_HIGHPRECISION, r, a) : console.warn("Shader3D: unknown passIndex.");
                } else console.warn("Shader3D: unknown subShaderIndex.");
            } else console.warn("Shader3D: unknown shader name.");
        }, Shader3D.add = function(e, t, n, i) {
            return void 0 === i && (i = !1), laya.d3.shader.Shader3D._preCompileShader[e] = new Shader3D(e, t, n, i);
        }, Shader3D.find = function(e) {
            return laya.d3.shader.Shader3D._preCompileShader[e];
        }, Shader3D.RENDER_STATE_CULL = 0, Shader3D.RENDER_STATE_BLEND = 1, Shader3D.RENDER_STATE_BLEND_SRC = 2, 
        Shader3D.RENDER_STATE_BLEND_DST = 3, Shader3D.RENDER_STATE_BLEND_SRC_RGB = 4, Shader3D.RENDER_STATE_BLEND_DST_RGB = 5, 
        Shader3D.RENDER_STATE_BLEND_SRC_ALPHA = 6, Shader3D.RENDER_STATE_BLEND_DST_ALPHA = 7, 
        Shader3D.RENDER_STATE_BLEND_CONST_COLOR = 8, Shader3D.RENDER_STATE_BLEND_EQUATION = 9, 
        Shader3D.RENDER_STATE_BLEND_EQUATION_RGB = 10, Shader3D.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, 
        Shader3D.RENDER_STATE_DEPTH_TEST = 12, Shader3D.RENDER_STATE_DEPTH_WRITE = 13, Shader3D.PERIOD_CUSTOM = 0, 
        Shader3D.PERIOD_MATERIAL = 1, Shader3D.PERIOD_SPRITE = 2, Shader3D.PERIOD_CAMERA = 3, 
        Shader3D.PERIOD_SCENE = 4, Shader3D.SHADERDEFINE_HIGHPRECISION = 0, Shader3D._propertyNameCounter = 0, 
        Shader3D._propertyNameMap = {}, Shader3D._publicCounter = 0, Shader3D._globleDefines = [], 
        Shader3D._preCompileShader = {}, Shader3D.debugMode = !1, Shader3D;
    }(), Ne = function() {
        function Rand(e) {
            this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = e, 
            this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        r(Rand, "laya.d3.math.Rand");
        var e = Rand.prototype;
        return e.getUint = function() {
            return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1], 
            this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8, 
            this.seeds[3];
        }, e.getFloat = function() {
            return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
        }, e.getSignedFloat = function() {
            return 2 * this.getFloat() - 1;
        }, a(0, e, "seed", function() {
            return this.seeds[0];
        }, function(e) {
            this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1, 
            this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }), Rand.getFloatFromInt = function(e) {
            return 1 / 8388607 * (8388607 & e);
        }, Rand.getByteFromInt = function(e) {
            return (8388607 & e) >>> 15;
        }, Rand;
    }(), Be = function() {
        function ParallelSplitShadowMap() {
            this._currentPSSM = -1, this._shadowMapCount = 3, this._maxDistance = 200, this._ratioOfDistance = 1 / this._shadowMapCount, 
            this._statesDirty = !0, this._shadowMapTextureSize = 1024, this._scene = null, this._PCFType = 0, 
            this._shaderValueLightVP = null, this._spiltDistance = new Array(4), this._globalParallelLightDir = new Te(0, -1, 0), 
            this._boundingSphere = new Array(4), this._boundingBox = new Array(4), this._frustumPos = new Array(16), 
            this._uniformDistance = new Array(4), this._logDistance = new Array(4), this._dimension = new Array(4), 
            this._tempLookAt3 = new Te(), this._tempLookAt4 = new me(), this._tempValue = new me(), 
            this._tempPos = new Te(), this._tempLightUp = new Te(), this._tempMin = new me(), 
            this._tempMax = new me(), this._tempMatrix44 = new Ht(), this._splitFrustumCulling = new Vt(Ht.DEFAULT), 
            this._tempScaleMatrix44 = new Ht(), this._shadowPCFOffset = new Se(1 / 1024, 1 / 1024), 
            this._shaderValueDistance = new me(), this.cameras = [], this._shaderValueVPs = [];
            var e = 0;
            for (e = 0; e < this._spiltDistance.length; e++) this._spiltDistance[e] = 0;
            for (e = 0; e < this._dimension.length; e++) this._dimension[e] = new Se();
            for (e = 0; e < this._frustumPos.length; e++) this._frustumPos[e] = new Te();
            for (e = 0; e < this._boundingBox.length; e++) this._boundingBox[e] = new zt(new Te(), new Te());
            for (e = 0; e < this._boundingSphere.length; e++) this._boundingSphere[e] = new Ce(new Te(), 0);
            Ht.createScaling(new Te(.5, .5, 1), this._tempScaleMatrix44), this._tempScaleMatrix44.elements[12] = .5, 
            this._tempScaleMatrix44.elements[13] = .5;
        }
        r(ParallelSplitShadowMap, "laya.d3.shadowMap.ParallelSplitShadowMap");
        var e = ParallelSplitShadowMap.prototype;
        return e.setInfo = function(e, t, n, i, r, a) {
            r > 3 && (this._shadowMapCount = 3), this._scene = e, this._maxDistance = t, this.shadowMapCount = r, 
            this._globalParallelLightDir = n, this._ratioOfDistance = 1 / this._shadowMapCount;
            for (var o = 0; o < this._spiltDistance.length; o++) this._spiltDistance[o] = 0;
            this._shadowMapTextureSize = i, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize, 
            this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this.setPCFType(a), this._statesDirty = !0;
        }, e.setPCFType = function(e) {
            this._PCFType = e;
            var t = this._scene._defineDatas;
            switch (this._PCFType) {
              case 0:
                t.add(qn.SHADERDEFINE_SHADOW_PCF_NO), t.remove(qn.SHADERDEFINE_SHADOW_PCF1), t.remove(qn.SHADERDEFINE_SHADOW_PCF2), 
                t.remove(qn.SHADERDEFINE_SHADOW_PCF3);
                break;

              case 1:
                t.add(qn.SHADERDEFINE_SHADOW_PCF1), t.remove(qn.SHADERDEFINE_SHADOW_PCF_NO), t.remove(qn.SHADERDEFINE_SHADOW_PCF2), 
                t.remove(qn.SHADERDEFINE_SHADOW_PCF3);
                break;

              case 2:
                t.add(qn.SHADERDEFINE_SHADOW_PCF2), t.remove(qn.SHADERDEFINE_SHADOW_PCF_NO), t.remove(qn.SHADERDEFINE_SHADOW_PCF1), 
                t.remove(qn.SHADERDEFINE_SHADOW_PCF3);
                break;

              case 3:
                t.add(qn.SHADERDEFINE_SHADOW_PCF3), t.remove(qn.SHADERDEFINE_SHADOW_PCF_NO), t.remove(qn.SHADERDEFINE_SHADOW_PCF1), 
                t.remove(qn.SHADERDEFINE_SHADOW_PCF2);
            }
        }, e.getPCFType = function() {
            return this._PCFType;
        }, e.setFarDistance = function(e) {
            this._maxDistance != e && (this._maxDistance = e, this._statesDirty = !0);
        }, e.getFarDistance = function() {
            return this._maxDistance;
        }, e._beginSampler = function(e, t) {
            if (e < 0 || e > this._shadowMapCount) throw new Error("ParallelSplitShadowMap: beginSample invalid index");
            this._currentPSSM = e, this._update(t);
        }, e.endSampler = function(e) {
            this._currentPSSM = -1;
        }, e._calcAllLightCameraInfo = function(e) {
            if (1 === this._shadowMapCount) this._beginSampler(0, e), this.endSampler(e); else for (var t = 0, n = this._shadowMapCount + 1; t < n; t++) this._beginSampler(t, e), 
            this.endSampler(e);
        }, e._recalculate = function(e, t, n) {
            this._calcSplitDistance(e), this._calcBoundingBox(t, n), this._rebuildRenderInfo();
        }, e._update = function(e) {
            var t = e.nearPlane, n = e.fieldOfView, i = e.aspectRatio;
            (this._statesDirty || this.lastNearPlane !== t || this.lastFieldOfView !== n || this.lastAspectRatio !== i) && (this._recalculate(t, n, i), 
            this._uploadShaderValue(), this._statesDirty = !1, this.lastNearPlane = t, this.lastFieldOfView = n, 
            this.lastAspectRatio = i), this._calcLightViewProject(e);
        }, e._uploadShaderValue = function() {
            var e = this._scene._defineDatas;
            switch (this._shadowMapCount) {
              case 1:
                e.add(qn.SHADERDEFINE_SHADOW_PSSM1), e.remove(qn.SHADERDEFINE_SHADOW_PSSM2), e.remove(qn.SHADERDEFINE_SHADOW_PSSM3);
                break;

              case 2:
                e.add(qn.SHADERDEFINE_SHADOW_PSSM2), e.remove(qn.SHADERDEFINE_SHADOW_PSSM1), e.remove(qn.SHADERDEFINE_SHADOW_PSSM3);
                break;

              case 3:
                e.add(qn.SHADERDEFINE_SHADOW_PSSM3), e.remove(qn.SHADERDEFINE_SHADOW_PSSM1), e.remove(qn.SHADERDEFINE_SHADOW_PSSM2);
            }
            var t = this._scene._shaderValues;
            switch (t.setVector(qn.SHADOWDISTANCE, this._shaderValueDistance), t.setBuffer(qn.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP), 
            t.setVector2(qn.SHADOWMAPPCFOFFSET, this._shadowPCFOffset), this._shadowMapCount) {
              case 3:
                t.setTexture(qn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), t.setTexture(qn.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget), 
                t.setTexture(qn.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                break;

              case 2:
                t.setTexture(qn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), t.setTexture(qn.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                break;

              case 1:
                t.setTexture(qn.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
            }
        }, e._calcSplitDistance = function(e) {
            var t = this._maxDistance, n = 1 / this._shadowMapCount, i = 0;
            for (i = 0; i <= this._shadowMapCount; i++) this._uniformDistance[i] = e + (t - e) * i * n;
            var r = t / e;
            for (i = 0; i <= this._shadowMapCount; i++) {
                var a = Math.pow(r, i * n);
                this._logDistance[i] = e * a;
            }
            for (i = 0; i <= this._shadowMapCount; i++) this._spiltDistance[i] = this._uniformDistance[i] * this._ratioOfDistance + this._logDistance[i] * (1 - this._ratioOfDistance);
            this._shaderValueDistance.x = this._spiltDistance[1], this._shaderValueDistance.y = this._spiltDistance[2], 
            this._shaderValueDistance.z = this._spiltDistance[3], this._shaderValueDistance.w = 0;
        }, e._calcBoundingBox = function(e, t) {
            var n, i, r, a, o = 3.1415926 * e / 180, s = Math.tan(o / 2), l = NaN, h = NaN, u = NaN, c = 0;
            for (c = 0; c <= this._shadowMapCount; c++) {
                h = (l = (u = this._spiltDistance[c]) * s) * t;
                var d = this._frustumPos[4 * c + 0];
                d.x = -h, d.y = -l, d.z = -u, (d = this._frustumPos[4 * c + 1]).x = h, d.y = -l, 
                d.z = -u, (d = this._frustumPos[4 * c + 2]).x = -h, d.y = l, d.z = -u, (d = this._frustumPos[4 * c + 3]).x = h, 
                d.y = l, d.z = -u, (d = this._dimension[c]).x = h, d.y = l;
            }
            for (c = 1; c <= this._shadowMapCount; c++) n = this._dimension[c], (i = this._boundingBox[c].min).x = -n.x, 
            i.y = -n.y, i.z = -this._spiltDistance[c], (r = this._boundingBox[c].max).x = n.x, 
            r.y = n.y, r.z = -this._spiltDistance[c - 1], (a = this._boundingSphere[c].center).x = .5 * (i.x + r.x), 
            a.y = .5 * (i.y + r.y), a.z = .5 * (i.z + r.z), this._boundingSphere[c].radius = .5 * Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2) + Math.pow(r.z - i.z, 2));
            i = this._boundingBox[0].min, n = this._dimension[this._shadowMapCount], i.x = -n.x, 
            i.y = -n.y, i.z = -this._spiltDistance[this._shadowMapCount], (r = this._boundingBox[0].max).x = n.x, 
            r.y = n.y, r.z = -this._spiltDistance[0], (a = this._boundingSphere[0].center).x = .5 * (i.x + r.x), 
            a.y = .5 * (i.y + r.y), a.z = .5 * (i.z + r.z), this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2) + Math.pow(r.z - i.z, 2));
        }, e.calcSplitFrustum = function(e) {
            this._currentPSSM > 0 ? Ht.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : Ht.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44), 
            Ht.multiply(this._tempMatrix44, e.viewMatrix, this._tempMatrix44), this._splitFrustumCulling.matrix = this._tempMatrix44;
        }, e._rebuildRenderInfo = function() {
            var e = this._shadowMapCount + 1, t = 0;
            for (this.cameras.length = e, t = 0; t < e; t++) {
                if (!this.cameras[t]) {
                    var n = new Ci();
                    n.name = "lightCamera" + t, n.clearColor = new me(1, 1, 1, 1), this.cameras[t] = n;
                }
                var i = this.cameras[t].renderTarget;
                null != i && i.width == this._shadowMapTextureSize && i.height == this._shadowMapTextureSize || (i && i.destroy(), 
                (i = new pi(this._shadowMapTextureSize, this._shadowMapTextureSize, 1, 0)).filterMode = 0, 
                this.cameras[t].renderTarget = i);
            }
        }, e._calcLightViewProject = function(e) {
            var t = this._boundingSphere[this._currentPSSM], n = e.transform.worldMatrix;
            t.radius;
            t.center.cloneTo(this._tempLookAt3), Te.transformV3ToV4(this._tempLookAt3, n, this._tempLookAt4);
            var i = this._tempLookAt3, r = this._tempLookAt4;
            i.x = r.x, i.y = r.y, i.z = r.z;
            var a = this._tempLightUp;
            e.transform.worldMatrix.getForward(ParallelSplitShadowMap._tempVector30);
            var o = ParallelSplitShadowMap._tempVector30;
            a.x = o.x, a.y = 1, a.z = o.z, Te.normalize(this._tempLightUp, this._tempLightUp), 
            Te.scale(this._globalParallelLightDir, 4 * t.radius, this._tempPos), Te.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
            var s = this.cameras[this._currentPSSM];
            s.transform.position = this._tempPos, s.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
            var l = this._tempMax, h = this._tempMin;
            l.x = l.y = l.z = -1e5, l.w = 1, h.x = h.y = h.z = 1e5, h.w = 1, Ht.multiply(s.viewMatrix, n, this._tempMatrix44);
            var u = this._tempValue, c = [];
            c.length = 8, this._boundingBox[this._currentPSSM].getCorners(c);
            for (var d = 0; d < 8; d++) {
                var _ = c[d];
                u.x = _.x, u.y = _.y, u.z = _.z, u.w = 1, me.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue), 
                h.x = u.x < h.x ? u.x : h.x, h.y = u.y < h.y ? u.y : h.y, h.z = u.z < h.z ? u.z : h.z, 
                l.x = u.x > l.x ? u.x : l.x, l.y = u.y > l.y ? u.y : l.y, l.z = u.z > l.z ? u.z : l.z;
            }
            me.add(this._tempMax, this._tempMin, this._tempValue), u.x *= .5, u.y *= .5, u.z *= .5, 
            u.w = 1, me.transformByM4x4(this._tempValue, s.transform.worldMatrix, this._tempValue);
            var f = Math.abs(-this._tempMax.z), m = f > this._maxDistance ? f : this._maxDistance;
            Te.scale(this._globalParallelLightDir, m, this._tempPos);
            var p = this._tempPos;
            p.x = u.x - p.x, p.y = u.y - p.y, p.z = u.z - p.z, s.transform.position = this._tempPos, 
            s.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1), Ht.createOrthoOffCenter(h.x, l.x, h.y, l.y, 1, m + .5 * (l.z - h.z), s.projectionMatrix);
            var T = s.projectionViewMatrix;
            ParallelSplitShadowMap.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, T, this._shaderValueVPs[this._currentPSSM]), 
            this._scene._shaderValues.setBuffer(qn.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
        }, e.setShadowMapTextureSize = function(e) {
            e !== this._shadowMapTextureSize && (this._shadowMapTextureSize = e, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize, 
            this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this._statesDirty = !0);
        }, e.disposeAllRenderTarget = function() {
            for (var e = 0, t = this._shadowMapCount + 1; e < t; e++) this.cameras[e].renderTarget && (this.cameras[e].renderTarget.destroy(), 
            this.cameras[e].renderTarget = null);
        }, a(0, e, "shadowMapCount", function() {
            return this._shadowMapCount;
        }, function(e) {
            if (e = (e = e > 0 ? e : 1) <= 3 ? e : 3, this._shadowMapCount != e) {
                this._shadowMapCount = e, this._ratioOfDistance = 1 / this._shadowMapCount, this._statesDirty = !0, 
                this._shaderValueLightVP = new Float32Array(16 * e), this._shaderValueVPs.length = e;
                for (var t = 0; t < e; t++) this._shaderValueVPs[t] = new Float32Array(this._shaderValueLightVP.buffer, 64 * t);
            }
        }), ParallelSplitShadowMap.multiplyMatrixOutFloat32Array = function(e, t, n) {
            var i, r, a, o, s, l, h;
            for (r = e.elements, a = t.elements, i = 0; i < 4; i++) o = r[i], s = r[i + 4], 
            l = r[i + 8], h = r[i + 12], n[i] = o * a[0] + s * a[1] + l * a[2] + h * a[3], n[i + 4] = o * a[4] + s * a[5] + l * a[6] + h * a[7], 
            n[i + 8] = o * a[8] + s * a[9] + l * a[10] + h * a[11], n[i + 12] = o * a[12] + s * a[13] + l * a[14] + h * a[15];
        }, ParallelSplitShadowMap.MAX_PSSM_COUNT = 3, i(ParallelSplitShadowMap, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        } ]), ParallelSplitShadowMap;
    }(), we = (function() {
        function PrimitiveMesh() {}
        r(PrimitiveMesh, "laya.d3.resource.models.PrimitiveMesh"), PrimitiveMesh._createMesh = function(e, t, n) {
            var i = new Gn(), r = new on(i), a = new Qt(4 * t.length, 35044, !0);
            a.vertexDeclaration = e, a.setData(t), i._vertexBuffers.push(a), i._vertexCount += a.vertexCount;
            var s = new jt("ushort", n.length, 35044, !0);
            s.setData(n), i._indexBuffer = s;
            var l = o(1, null);
            l[0] = a, i._setBuffer(l, s), r._vertexBuffer = a, r._indexBuffer = s, r._indexStart = 0, 
            r._indexCount = s.indexCount;
            var h = r._subIndexBufferStart, u = r._subIndexBufferCount, c = r._boneIndicesList;
            h.length = 1, u.length = 1, c.length = 1, h[0] = 0, u[0] = s.indexCount;
            var d = [];
            d.push(r), i._setSubMeshes(d);
            var _ = a._byteLength + s._byteLength;
            return i._setCPUMemory(_), i._setGPUMemory(_), i;
        }, PrimitiveMesh.createBox = function(e, t, n) {
            void 0 === e && (e = 1), void 0 === t && (t = 1), void 0 === n && (n = 1);
            var i = De.getVertexDeclaration("POSITION,NORMAL,UV"), r = e / 2, a = t / 2, o = n / 2, s = new Float32Array([ -r, a, -o, 0, 1, 0, 0, 0, r, a, -o, 0, 1, 0, 1, 0, r, a, o, 0, 1, 0, 1, 1, -r, a, o, 0, 1, 0, 0, 1, -r, -a, -o, 0, -1, 0, 0, 1, r, -a, -o, 0, -1, 0, 1, 1, r, -a, o, 0, -1, 0, 1, 0, -r, -a, o, 0, -1, 0, 0, 0, -r, a, -o, -1, 0, 0, 0, 0, -r, a, o, -1, 0, 0, 1, 0, -r, -a, o, -1, 0, 0, 1, 1, -r, -a, -o, -1, 0, 0, 0, 1, r, a, -o, 1, 0, 0, 1, 0, r, a, o, 1, 0, 0, 0, 0, r, -a, o, 1, 0, 0, 0, 1, r, -a, -o, 1, 0, 0, 1, 1, -r, a, o, 0, 0, 1, 0, 0, r, a, o, 0, 0, 1, 1, 0, r, -a, o, 0, 0, 1, 1, 1, -r, -a, o, 0, 0, 1, 0, 1, -r, a, -o, 0, 0, -1, 1, 0, r, a, -o, 0, 0, -1, 0, 0, r, -a, -o, 0, 0, -1, 0, 1, -r, -a, -o, 0, 0, -1, 1, 1 ]), l = new Uint16Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20 ]);
            return PrimitiveMesh._createMesh(i, s, l);
        }, PrimitiveMesh.createCapsule = function(e, t, n, i) {
            void 0 === e && (e = .5), void 0 === t && (t = 2), void 0 === n && (n = 16), void 0 === i && (i = 32);
            var r = (n + 1) * (i + 1) * 2 + 2 * (i + 1), a = 3 * n * (i + 1) * 2 * 2 + 2 * i * 3, o = De.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(r * s), h = new Uint16Array(a), u = Math.PI / 2 / n, c = 2 * Math.PI / i, d = t / 2 - e, _ = 0, f = 0, m = 0, p = 0, T = 0, S = 0, E = 0, v = 0;
            for (E = 0; E <= n; E++) for (v = 0; v <= i; v++) _ = e * Math.cos(E * u) * Math.cos(v * c + Math.PI), 
            f = e * Math.sin(E * u), m = e * Math.cos(E * u) * Math.sin(v * c + Math.PI), l[p++] = _, 
            l[p++] = f + d, l[p++] = m, l[p++] = _, l[p++] = f, l[p++] = m, l[p++] = 1 - v / i, 
            l[p++] = (1 - E / n) * (Math.PI * e / 2 / (t + Math.PI * e)), E < n && (h[T++] = E * (i + 1) + v + (i + 1), 
            h[T++] = E * (i + 1) + v, h[T++] = E * (i + 1) + v + 1, h[T++] = E * (i + 1) + v + i, 
            h[T++] = E * (i + 1) + v, h[T++] = E * (i + 1) + v + (i + 1));
            for (S += (n + 1) * (i + 1), E = 0; E <= n; E++) for (v = 0; v <= i; v++) _ = e * Math.cos(E * u) * Math.cos(v * c + Math.PI), 
            f = e * Math.sin(-E * u), m = e * Math.cos(E * u) * Math.sin(v * c + Math.PI), l[p++] = _, 
            l[p++] = f - d, l[p++] = m, l[p++] = _, l[p++] = f, l[p++] = m, l[p++] = 1 - v / i, 
            l[p++] = (E / n * (Math.PI * e / 2) + (t + Math.PI * e / 2)) / (t + Math.PI * e), 
            E < n && (h[T++] = S + E * (i + 1) + v, h[T++] = S + E * (i + 1) + v + (i + 1), 
            h[T++] = S + E * (i + 1) + v + 1, h[T++] = S + E * (i + 1) + v, h[T++] = S + E * (i + 1) + v + i, 
            h[T++] = S + E * (i + 1) + v + (i + 1));
            for (S += (n + 1) * (i + 1), v = 0; v <= i; v++) _ = e * Math.cos(v * c + Math.PI), 
            f = d, m = e * Math.sin(v * c + Math.PI), l[p++] = _, l[p + 8 * (i + 1) - 1] = _, 
            l[p++] = f, l[p + 8 * (i + 1) - 1] = -f, l[p++] = m, l[p + 8 * (i + 1) - 1] = m, 
            l[p++] = _, l[p + 8 * (i + 1) - 1] = _, l[p++] = 0, l[p + 8 * (i + 1) - 1] = 0, 
            l[p++] = m, l[p + 8 * (i + 1) - 1] = m, l[p++] = 1 - 1 * v / i, l[p + 8 * (i + 1) - 1] = 1 - 1 * v / i, 
            l[p++] = Math.PI * e / 2 / (t + Math.PI * e), l[p + 8 * (i + 1) - 1] = (Math.PI * e / 2 + t) / (t + Math.PI * e);
            for (v = 0; v < i; v++) h[T++] = v + S + (i + 1), h[T++] = v + S + 1, h[T++] = v + S, 
            h[T++] = v + S + (i + 1), h[T++] = v + S + (i + 1) + 1, h[T++] = v + S + 1;
            return S += 2 * (i + 1), PrimitiveMesh._createMesh(o, l, h);
        }, PrimitiveMesh.createCone = function(e, t, n) {
            void 0 === e && (e = .5), void 0 === t && (t = 1), void 0 === n && (n = 32);
            for (var i = n + 1 + 1 + 2 * (n + 1), r = 6 * n + 3 * n, a = De.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(i * o), l = new Uint16Array(r), h = 2 * Math.PI / n, u = t / 2, c = 0, d = 0, _ = 0, f = 0, m = 0, p = new Te(), T = new Te(0, -1, 0), S = new Te(0, u, 0), E = new Te(), v = new Te(), g = new he(), x = new Te(), M = NaN, y = 0, D = 0, R = 0; R <= n; R++) c = R * h, 
            _ = Math.cos(c + Math.PI) * e, f = u, m = Math.sin(c + Math.PI) * e, s[y++] = 0, 
            s[y + 8 * (n + 1) - 1] = _, s[y++] = f, s[y + 8 * (n + 1) - 1] = -f, s[y++] = 0, 
            s[y + 8 * (n + 1) - 1] = m, p.x = _, p.y = 0, p.z = m, E.x = _, E.y = -f, E.z = m, 
            Te.subtract(E, S, v), Te.normalize(v, v), M = Math.acos(Te.dot(T, v)), Te.cross(T, v, x), 
            Te.normalize(x, x), he.createFromAxisAngle(x, M, g), Te.normalize(p, p), Te.transformQuat(p, g, p), 
            Te.normalize(p, p), s[y++] = p.x, s[y + 8 * (n + 1) - 1] = p.x, s[y++] = p.y, s[y + 8 * (n + 1) - 1] = p.y, 
            s[y++] = p.z, s[y + 8 * (n + 1) - 1] = p.z, s[y++] = 1 - 1 * R / n, s[y + 8 * (n + 1) - 1] = 1 - 1 * R / n, 
            s[y++] = 0, s[y + 8 * (n + 1) - 1] = 1;
            y += 8 * (n + 1);
            for (var C = 0; C < n; C++) l[D++] = C + d + (n + 1), l[D++] = C + d + 1, l[D++] = C + d, 
            l[D++] = C + d + (n + 1), l[D++] = C + d + (n + 1) + 1, l[D++] = C + d + 1;
            d += 2 * (n + 1);
            for (var I = 0; I <= n; I++) 0 === I && (s[y++] = 0, s[y++] = -u, s[y++] = 0, s[y++] = 0, 
            s[y++] = -1, s[y++] = 0, s[y++] = .5, s[y++] = .5), c = I * h, _ = Math.cos(c + Math.PI) * e, 
            f = -u, m = Math.sin(c + Math.PI) * e, s[y++] = _, s[y++] = f, s[y++] = m, s[y++] = 0, 
            s[y++] = -1, s[y++] = 0, s[y++] = .5 + .5 * Math.cos(c), s[y++] = .5 + .5 * Math.sin(c);
            for (var A = 0; A < n; A++) l[D++] = 0 + d, l[D++] = A + 2 + d, l[D++] = A + 1 + d;
            return d += n + 1 + 1, PrimitiveMesh._createMesh(a, s, l);
        }, PrimitiveMesh.createCylinder = function(e, t, n) {
            void 0 === e && (e = .5), void 0 === t && (t = 2), void 0 === n && (n = 32);
            for (var i = n + 1 + 1 + 2 * (n + 1) + (n + 1 + 1), r = 3 * n + 6 * n + 3 * n, a = De.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(i * o), l = new Uint16Array(r), h = 2 * Math.PI / n, u = t / 2, c = 0, d = 0, _ = 0, f = 0, m = 0, p = 0, T = 0, S = 0; S <= n; S++) 0 === S && (s[p++] = 0, 
            s[p++] = u, s[p++] = 0, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5, s[p++] = .5), 
            c = S * h, _ = Math.cos(c) * e, f = u, m = Math.sin(c) * e, s[p++] = _, s[p++] = f, 
            s[p++] = m, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5 + .5 * Math.cos(c), 
            s[p++] = .5 + .5 * Math.sin(c);
            for (var E = 0; E < n; E++) l[T++] = 0, l[T++] = E + 1, l[T++] = E + 2;
            d += n + 1 + 1;
            for (var v = 0; v <= n; v++) c = v * h, _ = Math.cos(c + Math.PI) * e, f = u, m = Math.sin(c + Math.PI) * e, 
            s[p++] = _, s[p + 8 * (n + 1) - 1] = _, s[p++] = f, s[p + 8 * (n + 1) - 1] = -f, 
            s[p++] = m, s[p + 8 * (n + 1) - 1] = m, s[p++] = _, s[p + 8 * (n + 1) - 1] = _, 
            s[p++] = 0, s[p + 8 * (n + 1) - 1] = 0, s[p++] = m, s[p + 8 * (n + 1) - 1] = m, 
            s[p++] = 1 - 1 * v / n, s[p + 8 * (n + 1) - 1] = 1 - 1 * v / n, s[p++] = 0, s[p + 8 * (n + 1) - 1] = 1;
            p += 8 * (n + 1);
            for (var g = 0; g < n; g++) l[T++] = g + d + (n + 1), l[T++] = g + d + 1, l[T++] = g + d, 
            l[T++] = g + d + (n + 1), l[T++] = g + d + (n + 1) + 1, l[T++] = g + d + 1;
            d += 2 * (n + 1);
            for (var x = 0; x <= n; x++) 0 === x && (s[p++] = 0, s[p++] = -u, s[p++] = 0, s[p++] = 0, 
            s[p++] = -1, s[p++] = 0, s[p++] = .5, s[p++] = .5), c = x * h, _ = Math.cos(c + Math.PI) * e, 
            f = -u, m = Math.sin(c + Math.PI) * e, s[p++] = _, s[p++] = f, s[p++] = m, s[p++] = 0, 
            s[p++] = -1, s[p++] = 0, s[p++] = .5 + .5 * Math.cos(c), s[p++] = .5 + .5 * Math.sin(c);
            for (var M = 0; M < n; M++) l[T++] = 0 + d, l[T++] = M + 2 + d, l[T++] = M + 1 + d;
            return d += n + 1 + 1, PrimitiveMesh._createMesh(a, s, l);
        }, PrimitiveMesh.createPlane = function(e, t, n, i) {
            void 0 === e && (e = 10), void 0 === t && (t = 10), void 0 === n && (n = 10), void 0 === i && (i = 10);
            for (var r = (n + 1) * (i + 1), a = new Uint16Array(n * i * 2 * 3), o = De.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(r * s), h = e / 2, u = t / 2, c = e / n, d = t / i, _ = 0, f = 0; f <= i; f++) for (var m = 0; m <= n; m++) l[_++] = m * c - h, 
            l[_++] = 0, l[_++] = f * d - u, l[_++] = 0, l[_++] = 1, l[_++] = 0, l[_++] = 1 * m / n, 
            l[_++] = 1 * f / i;
            var p = 0;
            for (f = 0; f < i; f++) for (m = 0; m < n; m++) a[p++] = (f + 1) * (n + 1) + m, 
            a[p++] = f * (n + 1) + m, a[p++] = (f + 1) * (n + 1) + m + 1, a[p++] = f * (n + 1) + m, 
            a[p++] = f * (n + 1) + m + 1, a[p++] = (f + 1) * (n + 1) + m + 1;
            return PrimitiveMesh._createMesh(o, l, a);
        }, PrimitiveMesh.createQuad = function(e, t) {
            void 0 === e && (e = 1), void 0 === t && (t = 1);
            var n = De.getVertexDeclaration("POSITION,NORMAL,UV"), i = (n.vertexStride, e / 2), r = t / 2, a = new Float32Array([ -i, r, 0, 0, 0, 1, 0, 0, i, r, 0, 0, 0, 1, 1, 0, -i, -r, 0, 0, 0, 1, 0, 1, i, -r, 0, 0, 0, 1, 1, 1 ]), o = new Uint16Array([ 0, 1, 2, 3, 2, 1 ]);
            return PrimitiveMesh._createMesh(n, a, o);
        }, PrimitiveMesh.createSphere = function(e, t, n) {
            void 0 === e && (e = .5), void 0 === t && (t = 32), void 0 === n && (n = 32);
            var i = (t + 1) * (n + 1), r = 3 * t * (n + 1) * 2, a = new Uint16Array(r), o = De.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(i * s), h = Math.PI / t, u = 2 * Math.PI / n, c = 0;
            i = 0, r = 0;
            for (var d = 0; d < t + 1; d++) for (var _ = Math.sin(d * h), f = Math.cos(d * h), m = 0; m < n + 1; m++) {
                var p = _ * Math.sin(m * u + 1 * Math.PI / 2), T = _ * Math.cos(m * u + 1 * Math.PI / 2);
                l[i + 0] = p * e, l[i + 1] = f * e, l[i + 2] = T * e, l[i + 3] = p, l[i + 4] = f, 
                l[i + 5] = T, l[i + 6] = m / n, l[i + 7] = d / t, i += s, d != t - 1 && (a[r++] = c + (n + 1), 
                a[r++] = c, a[r++] = c + 1, a[r++] = c + n, a[r++] = c, a[r++] = c + (n + 1), c++);
            }
            return PrimitiveMesh._createMesh(o, l, a);
        };
    }(), function() {
        function PostProcessEffect() {}
        return r(PostProcessEffect, "laya.d3.core.render.PostProcessEffect"), PostProcessEffect.prototype.render = function(e) {}, 
        PostProcessEffect;
    }()), be = function() {
        function AnimationClipParser04() {}
        return r(AnimationClipParser04, "laya.d3.animation.AnimationClipParser04"), AnimationClipParser04.READ_DATA = function() {
            AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(), 
            AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
        }, AnimationClipParser04.READ_BLOCK = function() {
            for (var e = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16(), t = AnimationClipParser04._BLOCK.blockStarts = [], n = AnimationClipParser04._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(AnimationClipParser04._reader.getUint32()), 
            n.push(AnimationClipParser04._reader.getUint32());
        }, AnimationClipParser04.READ_STRINGS = function() {
            var e = AnimationClipParser04._reader.getUint32(), t = AnimationClipParser04._reader.getUint16(), n = AnimationClipParser04._reader.pos;
            AnimationClipParser04._reader.pos = e + AnimationClipParser04._DATA.offset;
            for (var i = 0; i < t; i++) AnimationClipParser04._strings[i] = AnimationClipParser04._reader.readUTFString();
            AnimationClipParser04._reader.pos = n;
        }, AnimationClipParser04.parse = function(e, t, n) {
            AnimationClipParser04._animationClip = e, AnimationClipParser04._reader = t, AnimationClipParser04._version = n, 
            AnimationClipParser04.READ_DATA(), AnimationClipParser04.READ_BLOCK(), AnimationClipParser04.READ_STRINGS();
            for (var i = 0, r = AnimationClipParser04._BLOCK.count; i < r; i++) {
                var a = t.getUint16(), o = AnimationClipParser04._strings[a], s = AnimationClipParser04["READ_" + o];
                if (null == s) throw new Error("model file err,no this function:" + a + " " + o);
                s.call(null);
            }
            AnimationClipParser04._version = null, AnimationClipParser04._reader = null, AnimationClipParser04._animationClip = null;
        }, AnimationClipParser04.READ_ANIMATIONS = function() {
            var e, t = 0, n = 0, i = AnimationClipParser04._reader, r = (i.__getBuffer(), []), a = i.getUint16();
            for (r.length = a, t = 0; t < a; t++) r[t] = i.getFloat32();
            var o = AnimationClipParser04._animationClip;
            o.name = AnimationClipParser04._strings[i.getUint16()];
            var s = o._duration = i.getFloat32();
            o.islooping = !!i.getByte(), o._frameRate = i.getInt16();
            var l = i.getInt16(), h = o._nodes;
            h.count = l;
            var u = o._nodesMap = {}, c = o._nodesDic = {};
            for (t = 0; t < l; t++) {
                e = new gt(), h.setNodeByIndex(t, e), e._indexInList = t;
                var d = e.type = i.getUint8(), _ = i.getUint16();
                for (e._setOwnerPathCount(_), n = 0; n < _; n++) e._setOwnerPathByIndex(n, AnimationClipParser04._strings[i.getUint16()]);
                var f = e._joinOwnerPath("/"), m = u[f];
                m || (u[f] = m = []), m.push(e), e.propertyOwner = AnimationClipParser04._strings[i.getUint16()];
                var p = i.getUint16();
                for (e._setPropertyCount(p), n = 0; n < p; n++) e._setPropertyByIndex(n, AnimationClipParser04._strings[i.getUint16()]);
                var T = f + "." + e.propertyOwner + "." + e._joinProperty(".");
                c[T] = e, e.fullPath = T;
                var S = i.getUint16();
                e._setKeyframeCount(S);
                switch (d) {
                  case 0:
                    break;

                  case 1:
                  case 3:
                  case 4:
                    e.data = R.supportWebGLPlusAnimation ? new G() : new Te();
                    break;

                  case 2:
                    e.data = R.supportWebGLPlusAnimation ? new U() : new he();
                    break;

                  default:
                    throw "AnimationClipParser04:unknown type.";
                }
                switch (AnimationClipParser04._version) {
                  case "LAYAANIMATION:04":
                    for (n = 0; n < S; n++) switch (d) {
                      case 0:
                        var E = new Tn();
                        e._setKeyframeByIndex(n, E), E.time = r[i.getUint16()], E.inTangent = i.getFloat32(), 
                        E.outTangent = i.getFloat32(), E.value = i.getFloat32();
                        break;

                      case 1:
                      case 3:
                      case 4:
                        var v = new An();
                        if (e._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                            for (var g = v.data = new Float32Array(9), x = 0; x < 3; x++) g[x] = i.getFloat32();
                            for (x = 0; x < 3; x++) g[3 + x] = i.getFloat32();
                            for (x = 0; x < 3; x++) g[6 + x] = i.getFloat32();
                        } else {
                            var M = v.inTangent, y = v.outTangent, D = v.value;
                            M.x = i.getFloat32(), M.y = i.getFloat32(), M.z = i.getFloat32(), y.x = i.getFloat32(), 
                            y.y = i.getFloat32(), y.z = i.getFloat32(), D.x = i.getFloat32(), D.y = i.getFloat32(), 
                            D.z = i.getFloat32();
                        }
                        break;

                      case 2:
                        var C = new Vn();
                        if (e._setKeyframeByIndex(n, C), C.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                            for (g = C.data = new Float32Array(12), x = 0; x < 4; x++) g[x] = i.getFloat32();
                            for (x = 0; x < 4; x++) g[4 + x] = i.getFloat32();
                            for (x = 0; x < 4; x++) g[8 + x] = i.getFloat32();
                        } else {
                            var I = C.inTangent, A = C.outTangent, L = C.value;
                            I.x = i.getFloat32(), I.y = i.getFloat32(), I.z = i.getFloat32(), I.w = i.getFloat32(), 
                            A.x = i.getFloat32(), A.y = i.getFloat32(), A.z = i.getFloat32(), A.w = i.getFloat32(), 
                            L.x = i.getFloat32(), L.y = i.getFloat32(), L.z = i.getFloat32(), L.w = i.getFloat32();
                        }
                        break;

                      default:
                        throw "AnimationClipParser04:unknown type.";
                    }
                    break;

                  case "LAYAANIMATION:COMPRESSION_04":
                    for (n = 0; n < S; n++) switch (d) {
                      case 0:
                        E = new Tn(), e._setKeyframeByIndex(n, E), E.time = r[i.getUint16()], E.inTangent = Ae.convertToNumber(i.getUint16()), 
                        E.outTangent = Ae.convertToNumber(i.getUint16()), E.value = Ae.convertToNumber(i.getUint16());
                        break;

                      case 1:
                      case 3:
                      case 4:
                        if (v = new An(), e._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                            for (g = v.data = new Float32Array(9), x = 0; x < 3; x++) g[x] = Ae.convertToNumber(i.getUint16());
                            for (x = 0; x < 3; x++) g[3 + x] = Ae.convertToNumber(i.getUint16());
                            for (x = 0; x < 3; x++) g[6 + x] = Ae.convertToNumber(i.getUint16());
                        } else M = v.inTangent, y = v.outTangent, D = v.value, M.x = Ae.convertToNumber(i.getUint16()), 
                        M.y = Ae.convertToNumber(i.getUint16()), M.z = Ae.convertToNumber(i.getUint16()), 
                        y.x = Ae.convertToNumber(i.getUint16()), y.y = Ae.convertToNumber(i.getUint16()), 
                        y.z = Ae.convertToNumber(i.getUint16()), D.x = Ae.convertToNumber(i.getUint16()), 
                        D.y = Ae.convertToNumber(i.getUint16()), D.z = Ae.convertToNumber(i.getUint16());
                        break;

                      case 2:
                        if (C = new Vn(), e._setKeyframeByIndex(n, C), C.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                            for (g = C.data = new Float32Array(12), x = 0; x < 4; x++) g[x] = Ae.convertToNumber(i.getUint16());
                            for (x = 0; x < 4; x++) g[4 + x] = Ae.convertToNumber(i.getUint16());
                            for (x = 0; x < 4; x++) g[8 + x] = Ae.convertToNumber(i.getUint16());
                        } else I = C.inTangent, A = C.outTangent, L = C.value, I.x = Ae.convertToNumber(i.getUint16()), 
                        I.y = Ae.convertToNumber(i.getUint16()), I.z = Ae.convertToNumber(i.getUint16()), 
                        I.w = Ae.convertToNumber(i.getUint16()), A.x = Ae.convertToNumber(i.getUint16()), 
                        A.y = Ae.convertToNumber(i.getUint16()), A.z = Ae.convertToNumber(i.getUint16()), 
                        A.w = Ae.convertToNumber(i.getUint16()), L.x = Ae.convertToNumber(i.getUint16()), 
                        L.y = Ae.convertToNumber(i.getUint16()), L.z = Ae.convertToNumber(i.getUint16()), 
                        L.w = Ae.convertToNumber(i.getUint16());
                        break;

                      default:
                        throw "AnimationClipParser04:unknown type.";
                    }
                }
            }
            var O = i.getUint16();
            for (t = 0; t < O; t++) {
                var P, V = new it();
                V.time = Math.min(s, i.getFloat32()), V.eventName = AnimationClipParser04._strings[i.getUint16()];
                var N = i.getUint16();
                for (N > 0 && (V.params = P = []), n = 0; n < N; n++) {
                    switch (i.getByte()) {
                      case 0:
                        P.push(!!i.getByte());
                        break;

                      case 1:
                        P.push(i.getInt32());
                        break;

                      case 2:
                        P.push(i.getFloat32());
                        break;

                      case 3:
                        P.push(AnimationClipParser04._strings[i.getUint16()]);
                        break;

                      default:
                        throw new Error("unknown type.");
                    }
                }
                o.addEvent(V);
            }
        }, AnimationClipParser04._animationClip = null, AnimationClipParser04._reader = null, 
        AnimationClipParser04._strings = [], AnimationClipParser04._version = null, i(AnimationClipParser04, [ "_BLOCK", function() {
            return this._BLOCK = {
                count: 0
            };
        }, "_DATA", function() {
            return this._DATA = {
                offset: 0,
                size: 0
            };
        } ]), AnimationClipParser04;
    }(), Fe = function() {
        function AnimationClipParser03() {}
        return r(AnimationClipParser03, "laya.d3.animation.AnimationClipParser03"), AnimationClipParser03.READ_DATA = function() {
            AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(), 
            AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
        }, AnimationClipParser03.READ_BLOCK = function() {
            for (var e = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16(), t = AnimationClipParser03._BLOCK.blockStarts = [], n = AnimationClipParser03._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(AnimationClipParser03._reader.getUint32()), 
            n.push(AnimationClipParser03._reader.getUint32());
        }, AnimationClipParser03.READ_STRINGS = function() {
            var e = AnimationClipParser03._reader.getUint32(), t = AnimationClipParser03._reader.getUint16(), n = AnimationClipParser03._reader.pos;
            AnimationClipParser03._reader.pos = e + AnimationClipParser03._DATA.offset;
            for (var i = 0; i < t; i++) AnimationClipParser03._strings[i] = AnimationClipParser03._reader.readUTFString();
            AnimationClipParser03._reader.pos = n;
        }, AnimationClipParser03.parse = function(e, t) {
            AnimationClipParser03._animationClip = e, AnimationClipParser03._reader = t;
            t.__getBuffer();
            AnimationClipParser03.READ_DATA(), AnimationClipParser03.READ_BLOCK(), AnimationClipParser03.READ_STRINGS();
            for (var n = 0, i = AnimationClipParser03._BLOCK.count; n < i; n++) {
                var r = t.getUint16(), a = AnimationClipParser03._strings[r], o = AnimationClipParser03["READ_" + a];
                if (null == o) throw new Error("model file err,no this function:" + r + " " + a);
                o.call(null);
            }
        }, AnimationClipParser03.READ_ANIMATIONS = function() {
            var e, t = 0, n = 0, i = AnimationClipParser03._reader, r = (i.__getBuffer(), []), a = i.getUint16();
            for (r.length = a, t = 0; t < a; t++) r[t] = i.getFloat32();
            var o = AnimationClipParser03._animationClip;
            o.name = AnimationClipParser03._strings[i.getUint16()];
            var s = o._duration = i.getFloat32();
            o.islooping = !!i.getByte(), o._frameRate = i.getInt16();
            var l = i.getInt16(), h = o._nodes;
            h.count = l;
            var u = o._nodesMap = {}, c = o._nodesDic = {};
            for (t = 0; t < l; t++) {
                e = new gt(), h.setNodeByIndex(t, e), e._indexInList = t;
                var d = e.type = i.getUint8(), _ = i.getUint16();
                for (e._setOwnerPathCount(_), n = 0; n < _; n++) e._setOwnerPathByIndex(n, AnimationClipParser03._strings[i.getUint16()]);
                var f = e._joinOwnerPath("/"), m = u[f];
                m || (u[f] = m = []), m.push(e), e.propertyOwner = AnimationClipParser03._strings[i.getUint16()];
                var p = i.getUint16();
                for (e._setPropertyCount(p), n = 0; n < p; n++) e._setPropertyByIndex(n, AnimationClipParser03._strings[i.getUint16()]);
                var T = f + "." + e.propertyOwner + "." + e._joinProperty(".");
                c[T] = e, e.fullPath = T;
                var S = i.getUint16();
                e._setKeyframeCount(S);
                switch (d) {
                  case 0:
                    break;

                  case 1:
                  case 3:
                  case 4:
                    e.data = R.supportWebGLPlusAnimation ? new G() : new Te();
                    break;

                  case 2:
                    e.data = R.supportWebGLPlusAnimation ? new U() : new he();
                    break;

                  default:
                    throw "AnimationClipParser03:unknown type.";
                }
                for (n = 0; n < S; n++) switch (d) {
                  case 0:
                    var E = new Tn();
                    e._setKeyframeByIndex(n, E), E.time = r[i.getUint16()], E.inTangent = i.getFloat32(), 
                    E.outTangent = i.getFloat32(), E.value = i.getFloat32();
                    break;

                  case 1:
                  case 3:
                  case 4:
                    var v = new An();
                    if (e._setKeyframeByIndex(n, v), v.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                        for (var g = v.data = new Float32Array(9), x = 0; x < 3; x++) g[x] = i.getFloat32();
                        for (x = 0; x < 3; x++) g[3 + x] = i.getFloat32();
                        for (x = 0; x < 3; x++) g[6 + x] = i.getFloat32();
                    } else {
                        var M = v.inTangent, y = v.outTangent, D = v.value;
                        M.x = i.getFloat32(), M.y = i.getFloat32(), M.z = i.getFloat32(), y.x = i.getFloat32(), 
                        y.y = i.getFloat32(), y.z = i.getFloat32(), D.x = i.getFloat32(), D.y = i.getFloat32(), 
                        D.z = i.getFloat32();
                    }
                    break;

                  case 2:
                    var C = new Vn();
                    if (e._setKeyframeByIndex(n, C), C.time = r[i.getUint16()], R.supportWebGLPlusAnimation) {
                        for (g = C.data = new Float32Array(12), x = 0; x < 4; x++) g[x] = i.getFloat32();
                        for (x = 0; x < 4; x++) g[4 + x] = i.getFloat32();
                        for (x = 0; x < 4; x++) g[8 + x] = i.getFloat32();
                    } else {
                        var I = C.inTangent, A = C.outTangent, L = C.value;
                        I.x = i.getFloat32(), I.y = i.getFloat32(), I.z = i.getFloat32(), I.w = i.getFloat32(), 
                        A.x = i.getFloat32(), A.y = i.getFloat32(), A.z = i.getFloat32(), A.w = i.getFloat32(), 
                        L.x = i.getFloat32(), L.y = i.getFloat32(), L.z = i.getFloat32(), L.w = i.getFloat32();
                    }
                    break;

                  default:
                    throw "AnimationClipParser03:unknown type.";
                }
            }
            var O = i.getUint16();
            for (t = 0; t < O; t++) {
                var P, V = new it();
                V.time = Math.min(s, i.getFloat32()), V.eventName = AnimationClipParser03._strings[i.getUint16()];
                var N = i.getUint16();
                for (N > 0 && (V.params = P = []), n = 0; n < N; n++) {
                    switch (i.getByte()) {
                      case 0:
                        P.push(!!i.getByte());
                        break;

                      case 1:
                        P.push(i.getInt32());
                        break;

                      case 2:
                        P.push(i.getFloat32());
                        break;

                      case 3:
                        P.push(AnimationClipParser03._strings[i.getUint16()]);
                        break;

                      default:
                        throw new Error("unknown type.");
                    }
                }
                o.addEvent(V);
            }
        }, AnimationClipParser03._animationClip = null, AnimationClipParser03._reader = null, 
        AnimationClipParser03._strings = [], i(AnimationClipParser03, [ "_BLOCK", function() {
            return this._BLOCK = {
                count: 0
            };
        }, "_DATA", function() {
            return this._DATA = {
                offset: 0,
                size: 0
            };
        } ]), AnimationClipParser03;
    }(), Ue = function() {
        function DefineDatas() {
            this.value = 0;
        }
        r(DefineDatas, "laya.d3.shader.DefineDatas");
        var e = DefineDatas.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.add = function(e) {
            this.value |= e;
        }, e.remove = function(e) {
            this.value &= ~e;
        }, e.has = function(e) {
            return (this.value & e) > 0;
        }, e.cloneTo = function(e) {
            e.value = this.value;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, DefineDatas;
    }(), ze = function() {
        function VertexElement(e, t, n) {
            this.offset = 0, this.elementFormat = null, this.elementUsage = 0, this.offset = e, 
            this.elementFormat = t, this.elementUsage = n;
        }
        return r(VertexElement, "laya.d3.graphics.VertexElement"), VertexElement;
    }(), Ge = function() {
        function HeightMap(e, t, n, i) {
            this._datas = null, this._w = 0, this._h = 0, this._minHeight = NaN, this._maxHeight = NaN, 
            this._datas = [], this._w = e, this._h = t, this._minHeight = n, this._maxHeight = i;
        }
        r(HeightMap, "laya.d3.core.HeightMap");
        var e = HeightMap.prototype;
        return e._inBounds = function(e, t) {
            return e >= 0 && e < this._h && t >= 0 && t < this._w;
        }, e.getHeight = function(e, t) {
            return this._inBounds(e, t) ? this._datas[e][t] : NaN;
        }, a(0, e, "width", function() {
            return this._w;
        }), a(0, e, "height", function() {
            return this._h;
        }), a(0, e, "maxHeight", function() {
            return this._maxHeight;
        }), a(0, e, "minHeight", function() {
            return this._minHeight;
        }), HeightMap.creatFromMesh = function(e, t, n, i) {
            for (var r = [], a = [], o = e.subMeshCount, s = 0; s < o; s++) {
                for (var l = e._getSubMesh(s), h = l._vertexBuffer, u = h.getData(), c = [], d = 0; d < u.length; d += h.vertexDeclaration.vertexStride / 4) {
                    var _ = new Te(u[d + 0], u[d + 1], u[d + 2]);
                    c.push(_);
                }
                r.push(c);
                var f = l._indexBuffer;
                a.push(f.getData());
            }
            var m = e.bounds, p = m.getMin().x, T = m.getMin().z, S = m.getMax().x, E = m.getMax().z, v = m.getMin().y, g = m.getMax().y, x = S - p, M = E - T, y = i.x = x / (t - 1), D = i.y = M / (n - 1), R = new HeightMap(t, n, v, g), C = HeightMap._tempRay, I = C.direction;
            I.x = 0, I.y = -1, I.z = 0;
            var A = g + .1;
            C.origin.y = A;
            for (var L = 0; L < n; L++) {
                var O = T + L * D;
                R._datas[L] = [];
                for (var P = 0; P < t; P++) {
                    var V = p + P * y, N = C.origin;
                    N.x = V, N.z = O;
                    var B = HeightMap._getPosition(C, r, a);
                    R._datas[L][P] = B === Number.MAX_VALUE ? NaN : A - B;
                }
            }
            return R;
        }, HeightMap.createFromImage = function(e, t, n) {
            for (var i = e.width, r = e.height, a = new HeightMap(i, r, t, n), o = (n - t) / 254, s = e.getPixels(), l = 0, h = 0; h < r; h++) for (var u = a._datas[h] = [], c = 0; c < i; c++) {
                var d = s[l++], _ = s[l++], f = s[l++], m = s[l++];
                u[c] = 255 == d && 255 == _ && 255 == f && 255 == m ? NaN : (d + _ + f) / 3 * o + t;
            }
            return a;
        }, HeightMap._getPosition = function(e, t, n) {
            for (var i = Number.MAX_VALUE, r = 0; r < t.length; r++) for (var a = t[r], o = n[r], s = 0; s < o.length; s += 3) {
                var l = a[o[s + 0]], h = a[o[s + 1]], u = a[o[s + 2]], c = ct.rayIntersectsTriangle(e, l, h, u);
                !isNaN(c) && c < i && (i = c);
            }
            return i;
        }, i(HeightMap, [ "_tempRay", function() {
            return this._tempRay = new K(new Te(), new Te());
        } ]), HeightMap;
    }(), He = function() {
        function ShaderInit3D() {}
        return r(ShaderInit3D, "laya.d3.shader.ShaderInit3D"), ShaderInit3D.__init__ = function() {
            var e, t;
            ShaderInit3D._rangeAttenTex = ke._buildTexture2D(1024, 1, 2, Pe.lightAttenTexture), 
            ShaderInit3D._rangeAttenTex.wrapModeU = 1, ShaderInit3D._rangeAttenTex.wrapModeV = 1, 
            ShaderInit3D._rangeAttenTex.lock = !0, Ve.SHADERDEFINE_HIGHPRECISION = Ve.registerPublicDefine("HIGHPRECISION"), 
            qn.SHADERDEFINE_FOG = Ve.registerPublicDefine("FOG"), qn.SHADERDEFINE_DIRECTIONLIGHT = Ve.registerPublicDefine("DIRECTIONLIGHT"), 
            qn.SHADERDEFINE_POINTLIGHT = Ve.registerPublicDefine("POINTLIGHT"), qn.SHADERDEFINE_SPOTLIGHT = Ve.registerPublicDefine("SPOTLIGHT"), 
            qn.SHADERDEFINE_CAST_SHADOW = Ve.registerPublicDefine("CASTSHADOW"), qn.SHADERDEFINE_SHADOW_PSSM1 = Ve.registerPublicDefine("SHADOWMAP_PSSM1"), 
            qn.SHADERDEFINE_SHADOW_PSSM2 = Ve.registerPublicDefine("SHADOWMAP_PSSM2"), qn.SHADERDEFINE_SHADOW_PSSM3 = Ve.registerPublicDefine("SHADOWMAP_PSSM3"), 
            qn.SHADERDEFINE_SHADOW_PCF_NO = Ve.registerPublicDefine("SHADOWMAP_PCF_NO"), qn.SHADERDEFINE_SHADOW_PCF1 = Ve.registerPublicDefine("SHADOWMAP_PCF1"), 
            qn.SHADERDEFINE_SHADOW_PCF2 = Ve.registerPublicDefine("SHADOWMAP_PCF2"), qn.SHADERDEFINE_SHADOW_PCF3 = Ve.registerPublicDefine("SHADOWMAP_PCF3"), 
            qn.SHADERDEFINE_REFLECTMAP = Ve.registerPublicDefine("REFLECTMAP"), Ve.addInclude("Lighting.glsl", "\nstruct DirectionLight {\n\tvec3 Color;\n\tvec3 Direction;\n};\n\nstruct PointLight {\n\tvec3 Color;\n\tvec3 Position;\n\tfloat Range;\n};\n\nstruct SpotLight {\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n\tfloat Spot;\n\tfloat Range;\n};\n\n// Laya中使用衰减纹理\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\n\tfRatio *= fRatio;\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\n}\n\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\n\tvec3 distance = L * invLightRadius;\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\n\treturn attenuation * attenuation;\n}\n\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\n\tfloat attenuationFactor = 30.0;\n\tvec3 distance = L * invLightRadius;\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\n\tattenuation /= 1.0 - attenuationFactor;\n\treturn attenuation;\n}\n\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\n\tmediump vec3 h = normalize(viewDir-lightVec);\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\n\tfloat nh = max (0.0, dot (h,normal));\n\tdiffuseColor=lightColor * ln;\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\n}\n\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec=normalize(light.Direction);\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\n}\n\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec =  pos-light.Position;\n\t//if( length(lightVec) > light.Range )\n\t//\treturn;\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\n\tdiffuseColor *= attenuate;\n\tspecularColor*= attenuate;\n}\n\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\n\tvec3 lightVec =  pos-light.Position;\n\t//if( length(lightVec) > light.Range)\n\t//\treturn;\n\n\tvec3 normalLightVec=lightVec/length(lightVec);\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\n\tvec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\n\tfloat dl=dot(normalize(light.Direction),normalLightVec);\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\n\tdiffuseColor *=attenuate;\n\tspecularColor *=attenuate;\n}\n\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\n\n\t// Build orthonormal basis.\n\tvec3 N = normalize(unitNormal);\n\tvec3 T = normalize(tangent);\n\tvec3 B = normalize(binormal);\n\tmat3 TBN = mat3(T, B, N);\n\n\t// Transform from tangent space to world space.\n\tvec3 bumpedNormal = TBN*normalT;\n\n\treturn bumpedNormal;\n}\n\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\n\tvec3 normalT;\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n\n\tvec3 T = normalize(tangent);\n\tvec3 B = normalize(binormal);\n\tvec3 N = normalize(unitNormal);\n\tmat3 TBN = mat3(T, B, N);\n\n\t// Transform from tangent space to world space.\n\tvec3 bumpedNormal = TBN * normalize(normalT);\n\n\treturn bumpedNormal;\n}\n\nvec3 DecodeLightmap(vec4 color) {\n\treturn color.rgb*color.a*5.0;\n}\n\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\n\ttransTexcoord.y+=1.0;\n\treturn transTexcoord;\n}\n\nvec4 remapGLPositionZ(vec4 position) {\n\tposition.z=position.z * 2.0 - position.w;\n\treturn position;\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\n"), 
            Ve.addInclude("ShadowHelper.glsl", "uniform sampler2D u_shadowMap1;\nuniform sampler2D u_shadowMap2;\nuniform sampler2D u_shadowMap3;\nuniform vec2\t  u_shadowPCFoffset;\nuniform vec4     u_shadowPSSMDistance;\nvec4 packDepth(const in float depth)\n{\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\n\tres -= res.xxyz * bitMask;\n\treturn res;\n}\nfloat unpackDepth(const in vec4 rgbaDepth)\n{\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\n{\n\tvec2 texelpos =texcoord / invsize;\n\tvec2 lerps = fract( texelpos );\n\tfloat sourcevals[4];\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\n}\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tint nPSNum = int(posViewZ>pssmDistance.x);\n\tnPSNum += int(posViewZ>pssmDistance.y);\n\tnPSNum += int(posViewZ>pssmDistance.z);\n\t//真SB,webgl不支持在PS中直接访问数组\n\tmat4 lightVP;\n\tif( nPSNum == 0 )\n\t{\n\t\tlightVP = lightShadowVP[1];\n\t}\n\telse if( nPSNum == 1 )\n\t{\n\t\tlightVP = lightShadowVP[2];\n\t}\n\telse if( nPSNum == 2 )\n\t{\n\t\tlightVP = lightShadowVP[3];\n\t}\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n\t//为了效率，在CPU计算/2.0 + 0.5\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n\tfloat fMyZ = vText.z - zBias;\n\t/*\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\tbool bInFrustum = all( bInFrustumVec );\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\tbool bFrustumTest = all( bFrustumTestVec );\n\tif ( bFrustumTest ) \n\t*/\n\tif( fMyZ <= 1.0 )\n\t{\n\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue = value/4.0;\n\t\t} \n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF2\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n\t\tvec4 color;\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 2 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\n\t\t}\n\t\tzdepth = unpackDepth(color);\n\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t}\n\treturn value;\n}\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tint nPSNum = int(posViewZ>pssmDistance.x);\n\tnPSNum += int(posViewZ>pssmDistance.y);\n\t//真SB,webgl不支持在PS中直接访问数组\n\tmat4 lightVP;\n\tif( nPSNum == 0 )\n\t{\n\t\tlightVP = lightShadowVP[1];\n\t}\n\telse if( nPSNum == 1 )\n\t{\n\t\tlightVP = lightShadowVP[2];\n\t}\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\n\t//为了效率，在CPU计算/2.0 + 0.5\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\n\tfloat fMyZ = vText.z - zBias;\n\t/*\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\tbool bInFrustum = all( bInFrustumVec );\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\tbool bFrustumTest = all( bFrustumTestVec );\n\tif ( bFrustumTest ) \n\t*/\n\tif( fMyZ <= 1.0 )\n\t{\n\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\n\t\t\tvalue = value/4.0;\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF2\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n\t\t}\n#endif\n#ifdef SHADOWMAP_PCF_NO\n\t\tvec4 color;\n\t\tif ( nPSNum == 0 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\n\t\t}\n\t\telse if( nPSNum == 1 )\n\t\t{\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\n\t\t}\n\t\tzdepth = unpackDepth(color);\n\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t}\n\treturn value;\n}\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\n{\n\tfloat value = 1.0;\n\tif( posViewZ < pssmDistance.x )\n\t{\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\n\t\tfloat fMyZ = vText.z - zBias;\n\t\t/*\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\n\t\tbool bInFrustum = all( bInFrustumVec );\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\n\t\tbool bFrustumTest = all( bFrustumTestVec );\n\t\t*/\n\t\tif ( fMyZ <= 1.0 ) \n\t\t{\n\t\t\tfloat zdepth=0.0;\n#ifdef SHADOWMAP_PCF3\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\n\t\t\tvalue = value/4.0;\n#endif\n#ifdef SHADOWMAP_PCF2\t\t\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF1\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\n#endif\n#ifdef SHADOWMAP_PCF_NO\t\t\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\n\t\t\tzdepth = unpackDepth(color);\n\t\t\tvalue = float(fMyZ < zdepth);\n#endif\n\t\t}\n\t}\n\treturn value;\n}"), 
            Ve.addInclude("BRDF.glsl", "struct LayaGI\n{\n\tvec3 diffuse;\n\tvec3 specular;\n};\n\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\n\tvec3 halfDir = SafeNormalize(viewDir - lightDir);\n\t\n\tfloat nv = abs(dot(normal, viewDir));\n\t\n\tfloat nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\n\tfloat nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\n\tfloat lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\n\tfloat lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\n\t\n\tfloat diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\n\t\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n\t\n\t//#if UNITY_BRDF_GGX\n\tfloat V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\n\tfloat D = GGXTerm(nh, roughness);\n\t\n\tfloat specularTerm = V * D * PI;\n\t\n\tspecularTerm = sqrt(max(0.0001, specularTerm));\n\tspecularTerm = max(0.0, specularTerm * nl);\n\t\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\n\t\n\tvec4 color;\n\tcolor.rgb = diffuseColor * (gi.diffuse + lightColor * diffuseTerm) \n\t\t\t  + specularTerm * lightColor * FresnelTerm (specularColor, lh)\n\t\t\t  + surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\n\t\n\treturn color;\n}"), 
            Ve.addInclude("PBRUtils.glsl", "struct DirectionLight\n{\n\tvec3 Color;\n\tvec3 Direction;\n};\n\nstruct PointLight\n{\n\tvec3 Color;\n\tvec3 Position;\n\tfloat Range;\n};\n\nstruct SpotLight\n{\n\tvec3 Color;\n\tvec3 Position;\n\tvec3 Direction;\n\tfloat SpotAngle;\n\tfloat Range;\n};\n\nvec3 UnpackScaleNormal(in vec2 uv0)\n{\n\t#ifdef NORMALTEXTURE\n\t\tvec3 normalT;\n\t\tvec4 normalMapSample = texture2D(u_NormalTexture, uv0);\n\t\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\n\t\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\n\t\tnormalT.xy *= u_normalScale;\n\t\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\n\t\t\n\t\tvec3 T = normalize(v_Tangent);\n\t\tvec3 B = normalize(v_Binormal);\n\t\tvec3 N = normalize(v_Normal);\n\t\tmat3 TBN = mat3(T, B, N);\n\t\t\n\t\tvec3 bumpedNormal = TBN * normalize(normalT);\n\t\treturn bumpedNormal;\n\t#else\n\t\treturn normalize(v_Normal);\n\t#endif\n}\n\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\n\nfloat PI = 3.14159265359;\n\nvec3 FresnelTerm (in vec3 F0, in float cosA)\n{\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\n}\n\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\n{\n    float t = pow(1.0 - cosA, 5.0);\n    return mix(F0, F90, t);\n}\n\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\n{\n\treturn perceptualRoughness * perceptualRoughness;\n}\n\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\n{\n\tfloat m = PerceptualRoughnessToRoughness(perceptualRoughness);\n\tfloat sq = max(0.0001, m * m);\n\tfloat n = (2.0 / sq) - 2.0;\n\tn = max(n, 0.0001);\n\treturn n;\n}\n\nfloat RoughnessToPerceptualRoughness(in float roughness)\n{\n\treturn sqrt(roughness);\n}\n\nfloat SmoothnessToRoughness(in float smoothness)\n{\n\treturn (1.0 - smoothness) * (1.0 - smoothness);\n}\n\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\n{\n\treturn (1.0 - smoothness);\n}\n\nvec3 SafeNormalize(in vec3 inVec)\n{\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\n\treturn inVec * (1.0 / sqrt(dp3));\n}\n\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\n{\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n\tfloat lightScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\n\tfloat viewScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\n\n\treturn lightScatter * viewScatter;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n\tfloat a = roughness;\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\n\n\treturn 0.5 / (lambdaV + lambdaL + 0.00001);\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0;\n\treturn 0.31830988618 * a2 / (d * d + 0.0000001);\n}\n\nfloat OneMinusReflectivityFromMetallic(in float metallic)\n{\n\tfloat oneMinusDielectricSpec = DielectricSpecularColor.a;\n\treturn oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nfloat SpecularStrength(vec3 specular)\n{\n    //(SHADER_TARGET < 30)return specular.r; \n    return max (max (specular.r, specular.g), specular.b);\n}\n\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\n{\n\tspecularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\n\toneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n\treturn diffuseColor * oneMinusReflectivity;\n}\n\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\n{\n\toneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\n\treturn diffuseColor * oneMinusReflectivity;\n}\n\nvec4 Occlusion(in vec2 uv0){\n\t#ifdef OCCLUSIONTEXTURE\n\t\tvec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\n\t\tfloat occ = occlusionTextureColor.g;\n\t\tfloat oneMinusT = 1.0 - u_occlusionStrength;\n\t\tfloat lerpOneTo = oneMinusT + occ * u_occlusionStrength;\n\t\treturn occlusionTextureColor * lerpOneTo;\n\t#else\n\t\treturn vec4(1.0);\n\t#endif\n}\n\nvec2 ParallaxOffset(in vec3 viewDir){\n\t#ifdef PARALLAXTEXTURE\n\t\tfloat h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\n\t\th = h * u_parallaxScale - u_parallaxScale / 2.0;\n\t\tvec3 v = viewDir;\n\t\tv.z += 0.42;\n\t\tvec2 offset = h * (v.xy / v.z);\n\t\treturn v_Texcoord0 + offset;\n\t#else\n\t\treturn v_Texcoord0;\n\t#endif\n}\n\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\n\t#ifdef REFLECTMAP\n\t\tvec3 incident = -viewDir;\n\t\tvec3 reflectionVector = reflect(incident, normal);\n\t\tvec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\n\t\treturn reflectionColor * u_ReflectIntensity;\n\t#else\n\t\treturn vec3(0.0);\n\t#endif\n}\n\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\n{\n\tfloat fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\n\tfRatio *= fRatio;\n\treturn 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\n}\n\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\n{\n\t#ifdef ALPHAPREMULTIPLY\n\t\tdiffColor *= alpha;\n\t\toutModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\n\t#else\n\t\toutModifiedAlpha = alpha;\n\t#endif\n\treturn diffColor;\n}\n\n"), 
            Ve.addInclude("PBRStandardLighting.glsl", '#include "PBRUtils.glsl"\n#include "BRDF.glsl"\n\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat oneMinusReflectivity;\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat alpha;\n\t\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\n\t\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n\t\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n\tcolor.a = alpha;\n\treturn color;\n}\n\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n\tvec3 lightVec = normalize(light.Direction);\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n\tfloat distance = dot(lightCoord, lightCoord);\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n\tvec3 lightVec = normalize(pos - light.Position);\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightVec =  pos - light.Position;\n\tvec3 normalLightVec = normalize(lightVec);\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//\t\n//\tfloat distance = dot(lightCoord, lightCoord);\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//\tvec3 lightVec = normalize(pos - light.Position);\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\n{\n\tvec2 mg;\n\t\n\t#ifdef METALLICGLOSSTEXTURE\n\t\tvec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tmg.r = metallicGlossTextureColor.r;\n\t\t\tmg.g = albedoTextureAlpha;\n\t\t#else\n\t\t    mg = metallicGlossTextureColor.ra;\n\t\t#endif\n\t\tmg.g *= u_smoothnessScale;\n\t#else\n\t\tmg.r = u_metallic;\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tmg.g = albedoTextureAlpha * u_smoothnessScale;\n\t\t#else\n\t\t\tmg.g = u_smoothness;\n\t\t#endif\n\t#endif\n\t\n\treturn mg;\n}\n\n'), 
            Ve.addInclude("PBRSpecularLighting.glsl", '#include "PBRUtils.glsl"\n#include "BRDF.glsl"\n\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\n{\n\tfloat oneMinusReflectivity;\n\tvec3 diffuseColor;\n\tfloat alpha;\n\t\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\n\t\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\n\t\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\n\tcolor.a = alpha;\n\treturn color;\n}\n\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\n{\n\tvec3 lightVec = normalize(light.Direction);\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\n}\n\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\n\tfloat distance = dot(lightCoord, lightCoord);\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\n\tvec3 lightVec = normalize(pos - light.Position);\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n{\n\tvec3 lightVec =  pos - light.Position;\n\tvec3 normalLightVec = normalize(lightVec);\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n}\n\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\n//{\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\n//\t\n//\tfloat distance = dot(lightCoord, lightCoord);\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\n//\tvec3 lightVec = normalize(pos - light.Position);\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\n//}\n\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\n{\n    vec4 sg;\n\t\n\t#ifdef SPECULARTEXTURE\n\t\tvec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tsg.rgb = specularTextureColor.rgb;\n\t\t\tsg.a = albedoTextureAlpha;\n\t\t#else\n\t\t\tsg = specularTextureColor;\n\t\t#endif\n\t\tsg.a *= u_smoothnessScale;\n\t#else\n\t\tsg.rgb = u_SpecularColor.rgb;\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n\t\t\tsg.a = albedoTextureAlpha * u_smoothnessScale;\n\t\t#else\n\t\t\tsg.a = u_smoothness;\n\t\t#endif\n\t#endif\n\t\n    return sg;\n}\n\n'), 
            Ve.addInclude("Colors.glsl", '#include "StdLib.glsl";\n\n#define EPSILON 1.0e-4\n\n// Quadratic color thresholding\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\n\t// Pixel brightness\n\tmediump float br = max3(color.r, color.g, color.b);\n\n\t// Under-threshold part: quadratic curve\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\n\trq = curve.z * rq * rq;\n\n\t// Combine and apply the brightness response curve.\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\n\n\treturn color;\n}\n\n//\n// sRGB transfer functions\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\n//\nmediump vec3 SRGBToLinear(mediump vec3 c) {\n\t#ifdef USE_VERY_FAST_SRGB\n\t\treturn c * c;\n\t#elif defined(USE_FAST_SRGB)\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\n\t#else\n\t\tmediump vec3 linearRGBLo = c / 12.92;\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\n\t\treturn linearRGB;\n\t#endif\n}\n\nmediump vec3 LinearToSRGB(mediump vec3 c) {\n\t#ifdef USE_VERY_FAST_SRGB\n\t\treturn sqrt(c);\n\t#elif defined(USE_FAST_SRGB)\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\n\t#else\n\t\tmediump vec3 sRGBLo = c * 12.92;\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\n\t\treturn sRGB;\n\t#endif\n}'), 
            Ve.addInclude("Sampling.glsl", "// Better, temporally stable box filtering\n// [Jimenez14] http://goo.gl/eomGso\n// . . . . . . .\n// . A . B . C .\n// . . D . E . .\n// . F . G . H .\n// . . I . J . .\n// . K . L . M .\n// . . . . . . .\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\n    mediump vec4 G = texture2D(tex, uv);\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\n\n\tmediump vec2 scale= vec2(0.5, 0.125);\n    mediump vec2 div = (1.0 / 4.0) * scale;\n\n    mediump vec4 o = (D + E + I + J) * div.x;\n    o += (A + B + G + F) * div.y;\n    o += (B + C + H + G) * div.y;\n    o += (F + G + L + K) * div.y;\n    o += (G + H + M + L) * div.y;\n\n    return o;\n}\n\n// Standard box filtering\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\n{\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\n\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\n    s += texture2D(tex, uv + d.zy);\n    s += texture2D(tex, uv + d.xw);\n    s += texture2D(tex, uv + d.zw);\n\n    return s * (1.0 / 4.0);\n}\n\n// 9-tap bilinear upsampler (tent filter)\n// . . . . . . .\n// . 1 . 2 . 1 .\n// . . . . . . .\n// . 2 . 4 . 2 .\n// . . . . . . .\n// . 1 . 2 . 1 .\n// . . . . . . .\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n{\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\n\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\n    s += texture2D(tex, uv - d.wy) * 2.0;\n    s += texture2D(tex, uv - d.zy);\n\n    s += texture2D(tex, uv + d.zw) * 2.0;\n    s += texture2D(tex, uv) * 4.0;\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\n\n    s += texture2D(tex, uv + d.zy);\n    s += texture2D(tex, uv + d.wy) * 2.0;\n    s += texture2D(tex, uv + d.xy);\n\n    return s * (1.0 / 16.0);\n}\n\n// Standard box filtering\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\n{\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * (sampleScale * 0.5);\n\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\n    s += texture2D(tex, uv + d.zy);\n    s += texture2D(tex, uv + d.xw);\n    s += texture2D(tex, uv + d.zw);\n\n    return s * (1.0 / 4.0);\n}"), 
            Ve.addInclude("StdLib.glsl", "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\n\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\n\nmediump vec4 safeHDR(mediump vec4 c)\n{\n    return min(c, HALF_MAX);\n}\n\nfloat max3(float a, float b, float c)\n{\n    return max(max(a, b), c);\n}\n\nvec3 positivePow(vec3 base, vec3 power)\n{\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\n}");
            var n = {
                a_Position: 0,
                a_Color: 1,
                a_Normal: 3,
                a_Texcoord0: 2,
                a_Texcoord1: 7,
                a_BoneWeights: 6,
                a_BoneIndices: 5,
                a_Tangent0: 4,
                a_MvpMatrix: 12,
                a_WorldMat: 8
            }, i = {
                u_Bones: 0,
                u_DiffuseTexture: 1,
                u_SpecularTexture: 1,
                u_NormalTexture: 1,
                u_AlphaTestValue: 1,
                u_DiffuseColor: 1,
                u_MaterialSpecular: 1,
                u_Shininess: 1,
                u_TilingOffset: 1,
                u_WorldMat: 2,
                u_MvpMatrix: 2,
                u_LightmapScaleOffset: 2,
                u_LightMap: 2,
                u_CameraPos: 3,
                u_ReflectTexture: 4,
                u_ReflectIntensity: 4,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4,
                "u_DirectionLight.Color": 4,
                "u_DirectionLight.Direction": 4,
                "u_PointLight.Position": 4,
                "u_PointLight.Range": 4,
                "u_PointLight.Color": 4,
                "u_SpotLight.Position": 4,
                "u_SpotLight.Direction": 4,
                "u_SpotLight.Range": 4,
                "u_SpotLight.Spot": 4,
                "u_SpotLight.Color": 4,
                u_AmbientColor: 4,
                u_shadowMap1: 4,
                u_shadowMap2: 4,
                u_shadowMap3: 4,
                u_shadowPSSMDistance: 4,
                u_lightShadowVP: 4,
                u_shadowPCFoffset: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            };
            e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\n\tattribute vec2 a_Texcoord0;\n\tvarying vec2 v_Texcoord0;\n#endif\n\n#if defined(LIGHTMAP)&&defined(UV1)\n\tattribute vec2 a_Texcoord1;\n#endif\n\n#ifdef LIGHTMAP\n\tuniform vec4 u_LightmapScaleOffset;\n\tvarying vec2 v_LightMapUV;\n#endif\n\n#ifdef COLOR\n\tattribute vec4 a_Color;\n\tvarying vec4 v_Color;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tattribute vec3 a_Normal;\n\tvarying vec3 v_Normal; \n\tuniform vec3 u_CameraPos;\n\tvarying vec3 v_ViewDir; \n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\tattribute vec4 a_Tangent0;\n\tvarying vec3 v_Tangent;\n\tvarying vec3 v_Binormal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t#ifdef GPU_INSTANCE\n\t\tattribute mat4 a_WorldMat;\n\t#else\n\t\tuniform mat4 u_WorldMat;\n\t#endif\n\tvarying vec3 v_PositionWorld;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n  varying vec4 v_lightMVPPos;\n  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n\t\t#ifdef TILINGOFFSET\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t\t#else\n\t\t\tv_Texcoord0=a_Texcoord0;\n\t\t#endif\n\t#endif\n\n\t#ifdef LIGHTMAP\n\t\t#ifdef SCALEOFFSETLIGHTINGMAPUV\n\t\t\t#ifdef UV1\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n\t\t\t#else\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\n\t\t\t#endif \n\t\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\n\t\t#else\n\t\t\t#ifdef UV1\n\t\t\t\tv_LightMapUV=a_Texcoord1;\n\t\t\t#else\n\t\t\t\tv_LightMapUV=a_Texcoord0;\n\t\t\t#endif \n\t\t#endif \n\t#endif\n\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tv_Color=a_Color;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}', 
            t = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\nuniform vec4 u_DiffuseColor;\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\tvarying vec4 v_Color;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tvarying vec3 v_ViewDir; \n#endif\n\n#ifdef ALPHATEST\n\tuniform float u_AlphaTestValue;\n#endif\n\n#ifdef DIFFUSEMAP\n\tuniform sampler2D u_DiffuseTexture;\n#endif\n\n\n\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\n\tvarying vec2 v_Texcoord0;\n#endif\n\n#ifdef LIGHTMAP\n\tvarying vec2 v_LightMapUV;\n\tuniform sampler2D u_LightMap;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tuniform vec3 u_MaterialSpecular;\n\tuniform float u_Shininess;\n\t#ifdef SPECULARMAP \n\t\tuniform sampler2D u_SpecularTexture;\n\t#endif\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\tvarying vec3 v_Normal;\n#endif\n\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\tuniform sampler2D u_NormalTexture;\n\tvarying vec3 v_Tangent;\n\tvarying vec3 v_Binormal;\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\nuniform vec3 u_AmbientColor;\n\n\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#include "ShadowHelper.glsl"\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\nvoid main_castShadow()\n{\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\nvoid main_normal()\n{\n\tvec3 globalDiffuse=u_AmbientColor;\n\t#ifdef LIGHTMAP\t\n\t\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tvec3 normal;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\n\t\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\n\t\t#else\n\t\t\tnormal = normalize(v_Normal);\n\t\t#endif\n\t\tvec3 viewDir= normalize(v_ViewDir);\n\t#endif\n\t\n\tvec4 mainColor=u_DiffuseColor;\n\t#ifdef DIFFUSEMAP\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\n\t\tmainColor=mainColor*difTexColor;\n\t#endif \n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tmainColor=mainColor*v_Color;\n\t#endif \n    \n\t#ifdef ALPHATEST\n\t\tif(mainColor.a<u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n  \n\t\n\tvec3 diffuse = vec3(0.0);\n\tvec3 specular= vec3(0.0);\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tvec3 dif,spe;\n\t\t#ifdef SPECULARMAP\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\n\t\t#else\n\t\t\t#ifdef DIFFUSEMAP\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\n\t\t\t#else\n\t\t\t\tvec3 gloss=vec3(1.0);\n\t\t\t#endif\n\t\t#endif\n\t#endif\n\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n\n\t#ifdef SPOTLIGHT\n\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\n\t\tdiffuse+=dif;\n\t\tspecular+=spe;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\n\t#else\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\t#ifdef RECEIVESHADOW\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\n\t\t#else\n\t\t\tgl_FragColor.rgb+=specular;\n\t\t#endif\n\t#endif\n\t  \n\t#ifdef FOG\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}\n\n';
            var a = Ve.add("BLINNPHONG", !0), o = new ot(n, i, yi.shaderDefines, ci.shaderDefines);
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_Color: 1
            }, i = {
                u_MvpMatrix: 2,
                u_Color: 1
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform vec4 u_Color;\nattribute vec4 a_Color;\nvarying vec4 v_Color;\n\n\nvoid main()\n{\n\tgl_Position = u_MvpMatrix * a_Position;\n\tv_Color=a_Color*u_Color;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}', 
            t = "#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nuniform vec4 u_Color;\n\nvoid main()\n{\n  gl_FragColor = v_Color * u_Color; \n}\n\n", 
            a = Ve.add("LineShader"), o = new ot(n, i), a.addSubShader(o), o.addShaderPass(e, t, r), 
            n = {
                a_Position: 0,
                a_Normal: 3,
                a_Tangent0: 4,
                a_Texcoord0: 2,
                a_BoneWeights: 6,
                a_BoneIndices: 5,
                a_MvpMatrix: 12,
                a_WorldMat: 8
            }, i = {
                u_Bones: 0,
                u_MvpMatrix: 2,
                u_WorldMat: 2,
                u_CameraPos: 3,
                u_AlphaTestValue: 1,
                u_AlbedoColor: 1,
                u_EmissionColor: 1,
                u_AlbedoTexture: 1,
                u_NormalTexture: 1,
                u_ParallaxTexture: 1,
                u_MetallicGlossTexture: 1,
                u_OcclusionTexture: 1,
                u_EmissionTexture: 1,
                u_metallic: 1,
                u_smoothness: 1,
                u_smoothnessScale: 1,
                u_occlusionStrength: 1,
                u_normalScale: 1,
                u_parallaxScale: 1,
                u_TilingOffset: 1,
                "u_DirectionLight.Direction": 4,
                "u_DirectionLight.Color": 4,
                u_PointLightMatrix: 4,
                "u_PointLight.Position": 4,
                "u_PointLight.Range": 4,
                "u_PointLight.Color": 4,
                "u_SpotLight.Position": 4,
                "u_SpotLight.Direction": 4,
                "u_SpotLight.Range": 4,
                "u_SpotLight.SpotAngle": 4,
                "u_SpotLight.Color": 4,
                u_RangeTexture: 4,
                u_ReflectTexture: 4,
                u_ReflectIntensity: 4,
                u_AmbientColor: 4,
                u_shadowMap1: 4,
                u_shadowMap2: 4,
                u_shadowMap3: 4,
                u_shadowPSSMDistance: 4,
                u_lightShadowVP: 4,
                u_shadowPCFoffset: 4,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_WorldMat;\n#else\n\tuniform mat4 u_WorldMat;\n#endif\n\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n\t  varying vec4 v_lightMVPPos;\n\t  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t \n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0 = a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\t\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n  \n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}', 
            t = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef METALLICGLOSSTEXTURE\n\tuniform sampler2D u_MetallicGlossTexture;\n#endif\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n\tuniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n\tuniform sampler2D u_ParallaxTexture;\n\tuniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n\tuniform sampler2D u_OcclusionTexture;\n\tuniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n\t#ifdef EMISSIONTEXTURE\n\t\tuniform sampler2D u_EmissionTexture;\n\t#endif\n\tuniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n\tuniform samplerCube u_ReflectTexture;\n\tuniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include "PBRStandardLighting.glsl"\n#include "ShadowHelper.glsl"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\n\nvoid main_normal()\n{\t\n\tvec3 viewDir = normalize(v_ViewDir);\n\t\n\tvec2 uv0 = ParallaxOffset(viewDir);\n\t\n\tvec2 mg;\n\tvec4 albedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tvec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\n\t\talbedoColor = abledoTextureColor * u_AlbedoColor;\n\t\tmg = MetallicGloss(abledoTextureColor.a, uv0);\n\t#else\n\t\talbedoColor = u_AlbedoColor;\n\t\tmg = MetallicGloss(1.0, uv0);\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(albedoColor.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n\t\n\tvec3 normal = UnpackScaleNormal(uv0);\n  \n\tLayaGI gi;\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n\tgi.specular = ReflectCubeMap(viewDir, normal);\n  \n\tvec4 color = vec4(0.0);\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tcolor += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef SPOTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef EMISSION\n\t\tvec4 emissionColor = u_EmissionColor;\n\t\t#ifdef EMISSIONTEXTURE\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\n\t\t#endif\n\t\tcolor.rgb += emissionColor.rgb;\n\t#endif\n\t\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\n\t#else\n\t\tgl_FragColor = color;\n\t#endif\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}', 
            a = Ve.add("PBRStandard", !0), o = new ot(n, i, yi.shaderDefines, oi.shaderDefines), 
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_Normal: 3,
                a_Tangent0: 4,
                a_Texcoord0: 2,
                a_BoneWeights: 6,
                a_BoneIndices: 5,
                a_MvpMatrix: 12,
                a_WorldMat: 8
            }, i = {
                u_Bones: 0,
                u_MvpMatrix: 2,
                u_WorldMat: 2,
                u_CameraPos: 3,
                u_AlphaTestValue: 1,
                u_AlbedoColor: 1,
                u_SpecularColor: 1,
                u_EmissionColor: 1,
                u_AlbedoTexture: 1,
                u_NormalTexture: 1,
                u_ParallaxTexture: 1,
                u_SpecularTexture: 1,
                u_OcclusionTexture: 1,
                u_EmissionTexture: 1,
                u_smoothness: 1,
                u_smoothnessScale: 1,
                u_occlusionStrength: 1,
                u_normalScale: 1,
                u_parallaxScale: 1,
                u_TilingOffset: 1,
                "u_DirectionLight.Direction": 4,
                "u_DirectionLight.Color": 4,
                u_PointLightMatrix: 4,
                "u_PointLight.Position": 4,
                "u_PointLight.Range": 4,
                "u_PointLight.Color": 4,
                "u_SpotLight.Position": 4,
                "u_SpotLight.Direction": 4,
                "u_SpotLight.Range": 4,
                "u_SpotLight.SpotAngle": 4,
                "u_SpotLight.Color": 4,
                u_RangeTexture: 4,
                u_ReflectTexture: 4,
                u_ReflectIntensity: 4,
                u_AmbientColor: 4,
                u_shadowMap1: 4,
                u_shadowMap2: 4,
                u_shadowMap3: 4,
                u_shadowPSSMDistance: 4,
                u_lightShadowVP: 4,
                u_shadowPCFoffset: 4,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_WorldMat;\n#else\n\tuniform mat4 u_WorldMat;\n#endif\nuniform vec3 u_CameraPos;\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n  #ifdef SHADOWMAP_PSSM1 \n\t  varying vec4 v_lightMVPPos;\n\t  uniform mat4 u_lightShadowVP[4];\n  #endif\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main_castShadow()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t \n\t//TODO没考虑UV动画呢\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tv_Texcoord0 = a_Texcoord0;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n\tv_posViewZ = gl_Position.z;\n}\n\nvoid main_normal()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tmat4 worldMat;\n\t\t#ifdef GPU_INSTANCE\n\t\t\tworldMat = a_WorldMat;\n\t\t#else\n\t\t\tworldMat = u_WorldMat;\n\t\t#endif\n\t#endif\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tmat3 worldInvMat;\n\t\t#ifdef BONE\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\n\t\t#else\n\t\t\tworldInvMat=inverse(mat3(worldMat));\n\t\t#endif  \n\t\tv_Normal=a_Normal*worldInvMat;\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\n\t\t#endif\n\t#endif\n\t\n\t\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\n\t\tv_PositionWorld=(worldMat*position).xyz;\n\t#endif\n\t\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n  \n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1 \n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif\n}', 
            t = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nvarying vec2 v_Texcoord0;\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec3 v_PositionWorld;\n\nuniform vec3 u_AmbientColor;\nuniform vec4 u_AlbedoColor;\nuniform vec4 u_SpecularColor;\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n#ifdef SPECULARTEXTURE\n\tuniform sampler2D u_SpecularTexture;\n#endif\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n\tuniform float u_normalScale;\n#endif\n#ifdef PARALLAXTEXTURE\n\tuniform sampler2D u_ParallaxTexture;\n\tuniform float u_parallaxScale;\n#endif\n#ifdef OCCLUSIONTEXTURE\n\tuniform sampler2D u_OcclusionTexture;\n\tuniform float u_occlusionStrength;\n#endif\n#ifdef EMISSION\n\t#ifdef EMISSIONTEXTURE\n\t\tuniform sampler2D u_EmissionTexture;\n\t#endif\n\tuniform vec4 u_EmissionColor;\n#endif\n#ifdef REFLECTMAP\n\tuniform samplerCube u_ReflectTexture;\n\tuniform float u_ReflectIntensity;\n#endif\n\nuniform float u_AlphaTestValue;\nuniform float u_metallic;\nuniform float u_smoothness;\nuniform float u_smoothnessScale;\n\nuniform sampler2D u_RangeTexture;\n//uniform sampler2D u_AngleTexture;\nuniform mat4 u_PointLightMatrix;\n//uniform mat4 u_SpotLightMatrix;\n\n#include "PBRSpecularLighting.glsl"\n#include "ShadowHelper.glsl"\n\nvarying float v_posViewZ;\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\nvoid main_castShadow()\n{\n\tgl_FragColor=packDepth(v_posViewZ);\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\n\t\tif( alpha < u_AlphaTestValue )\n\t\t{\n\t\t\tdiscard;\n\t\t}\n\t#endif\n}\n\nvoid main_normal()\n{\t\n\tvec3 viewDir = normalize(v_ViewDir);\n\t\n\tvec2 uv0 = ParallaxOffset(viewDir);\n\t\n\tvec4 sg;\n\tvec4 albedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tvec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\n\t\talbedoColor = albedoTextureColor * u_AlbedoColor;\n\t\tsg = SpecularGloss(albedoTextureColor.a, uv0);\n\t#else\n\t\talbedoColor = u_AlbedoColor;\n\t\tsg = SpecularGloss(1.0, uv0);\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(albedoColor.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n  \n\tvec3 normal = UnpackScaleNormal(uv0);\n\t\n\tLayaGI gi;\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\n\tgi.specular = ReflectCubeMap(viewDir, normal);\n\t\n\t//float a = (sg.r+sg.g+sg.b) / 3.0;\n  \n\tvec4 color = vec4(0.0);\n\t\n\t#ifdef DIRECTIONLIGHT\n\t\tcolor += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\n\t#endif\n \n\t#ifdef POINTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef SPOTLIGHT\n\t\tcolor.a = 0.0;\n\t\tcolor += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\n\t#endif\n\t\n\t#ifdef EMISSION\n\t\tvec4 emissionColor = u_EmissionColor;\n\t\t#ifdef EMISSIONTEXTURE\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\n\t\t#endif\n\t\tcolor.rgb += emissionColor.rgb;\n\t#endif\n\t\n\t#ifdef RECEIVESHADOW\n\t\tfloat shadowValue = 1.0;\n\t\t#ifdef SHADOWMAP_PSSM3\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif\n\t\t#ifdef SHADOWMAP_PSSM2\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t\t#endif \n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t\t#endif\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\n\t#else\n\t\tgl_FragColor = color;\n\t#endif\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t#endif\n}\n\nvoid main()\n{\n\t#ifdef CASTSHADOW\t\t\n\t\tmain_castShadow();\n\t#else\n\t\tmain_normal();\n\t#endif  \n}\n\n', 
            a = Ve.add("PBRSpecular", !0), o = new ot(n, i, yi.shaderDefines, fi.shaderDefines), 
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_Color: 1,
                a_Texcoord0: 2,
                a_BoneWeights: 6,
                a_BoneIndices: 5,
                a_MvpMatrix: 12
            }, i = {
                u_Bones: 0,
                u_AlbedoTexture: 1,
                u_AlbedoColor: 1,
                u_TilingOffset: 1,
                u_AlphaTestValue: 1,
                u_MvpMatrix: 2,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\n\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\nattribute vec4 a_Color;\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main() {\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tv_Color = a_Color;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}', 
            t = "#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\tvarying vec4 v_Color;\n#endif\n\n#ifdef ALBEDOTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n\tvarying vec2 v_Texcoord0;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef ALPHATEST\n\tuniform float u_AlphaTestValue;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\nvoid main()\n{\n\tvec4 color =  u_AlbedoColor;\n\t#ifdef ALBEDOTEXTURE\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\n\t#endif\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\n\t\tcolor *= v_Color;\n\t#endif\n\t\n\t#ifdef ALPHATEST\n\t\tif(color.a < u_AlphaTestValue)\n\t\t\tdiscard;\n\t#endif\n\t\n\tgl_FragColor = color;\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t\t#endif\n\t#endif\n\t\n}\n\n", 
            a = Ve.add("Unlit", !0), o = new ot(n, i, yi.shaderDefines, $n.shaderDefines), a.addSubShader(o), 
            o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_Texcoord0: 2,
                a_BoneWeights: 6,
                a_BoneIndices: 5,
                a_MvpMatrix: 12
            }, i = {
                u_Bones: 0,
                u_AlbedoTexture: 1,
                u_AlbedoColor: 1,
                u_TilingOffset: 1,
                u_AlphaTestValue: 1,
                u_MvpMatrix: 2,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec4 a_Color;\nattribute vec2 a_Texcoord0;\n\n#ifdef GPU_INSTANCE\n\tattribute mat4 a_MvpMatrix;\n#else\n\tuniform mat4 u_MvpMatrix;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_Texcoord0;\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\n#ifdef BONE\n\tconst int c_MaxBoneCount = 24;\n\tattribute vec4 a_BoneIndices;\n\tattribute vec4 a_BoneWeights;\n\tuniform mat4 u_Bones[c_MaxBoneCount];\n#endif\n\nvoid main()\n{\n\tvec4 position;\n\t#ifdef BONE\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\n\t\tposition=skinTransform*a_Position;\n\t#else\n\t\tposition=a_Position;\n\t#endif\n\t#ifdef GPU_INSTANCE\n\t\tgl_Position = a_MvpMatrix * position;\n\t#else\n\t\tgl_Position = u_MvpMatrix * position;\n\t#endif\n\t\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\n\t#else\n\t\tv_Texcoord0=a_Texcoord0;\n\t#endif\n\t\t\n\tv_Color = a_Color;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}', 
            t = "#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#ifdef COLOR\n\tvarying vec4 v_Color;\n#endif\nvarying vec2 v_Texcoord0;\n\n#ifdef MAINTEXTURE\n\tuniform sampler2D u_AlbedoTexture;\n#endif\n\nuniform vec4 u_AlbedoColor;\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\nvoid main()\n{\n\tvec4 color =  2.0 * u_AlbedoColor;\n\t#ifdef COLOR\n\t\tcolor *= v_Color;\n\t#endif\n\t#ifdef MAINTEXTURE\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\n\t#endif\n\t\n\tgl_FragColor = color;\n\t\n\t#ifdef FOG\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\n\t\t#endif\n\t#endif\n}\n\n", 
            a = Ve.add("Effect", !0), o = new ot(n, i, yi.shaderDefines, li.shaderDefines), 
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_CornerTextureCoordinate: 0,
                a_MeshPosition: 1,
                a_MeshColor: 2,
                a_MeshTextureCoordinate: 3,
                a_ShapePositionStartLifeTime: 4,
                a_DirectionTime: 5,
                a_StartColor: 6,
                a_EndColor: 7,
                a_StartSize: 8,
                a_StartRotation0: 9,
                a_StartSpeed: 10,
                a_Random0: 11,
                a_Random1: 12,
                a_SimulationWorldPostion: 13,
                a_SimulationWorldRotation: 14
            }, i = {
                u_Tintcolor: 1,
                u_TilingOffset: 1,
                u_texture: 1,
                u_WorldPosition: 2,
                u_WorldRotation: 2,
                u_PositionScale: 2,
                u_SizeScale: 2,
                u_ScalingMode: 2,
                u_Gravity: 2,
                u_ThreeDStartRotation: 2,
                u_StretchedBillboardLengthScale: 2,
                u_StretchedBillboardSpeedScale: 2,
                u_SimulationSpace: 2,
                u_CurrentTime: 2,
                u_ColorOverLifeGradientAlphas: 2,
                u_ColorOverLifeGradientColors: 2,
                u_MaxColorOverLifeGradientAlphas: 2,
                u_MaxColorOverLifeGradientColors: 2,
                u_VOLVelocityConst: 2,
                u_VOLVelocityGradientX: 2,
                u_VOLVelocityGradientY: 2,
                u_VOLVelocityGradientZ: 2,
                u_VOLVelocityConstMax: 2,
                u_VOLVelocityGradientMaxX: 2,
                u_VOLVelocityGradientMaxY: 2,
                u_VOLVelocityGradientMaxZ: 2,
                u_VOLSpaceType: 2,
                u_SOLSizeGradient: 2,
                u_SOLSizeGradientX: 2,
                u_SOLSizeGradientY: 2,
                u_SOLSizeGradientZ: 2,
                u_SOLSizeGradientMax: 2,
                u_SOLSizeGradientMaxX: 2,
                u_SOLSizeGradientMaxY: 2,
                u_SOLSizeGradientMaxZ: 2,
                u_ROLAngularVelocityConst: 2,
                u_ROLAngularVelocityConstSeprarate: 2,
                u_ROLAngularVelocityGradient: 2,
                u_ROLAngularVelocityGradientX: 2,
                u_ROLAngularVelocityGradientY: 2,
                u_ROLAngularVelocityGradientZ: 2,
                u_ROLAngularVelocityConstMax: 2,
                u_ROLAngularVelocityConstMaxSeprarate: 2,
                u_ROLAngularVelocityGradientMax: 2,
                u_ROLAngularVelocityGradientMaxX: 2,
                u_ROLAngularVelocityGradientMaxY: 2,
                u_ROLAngularVelocityGradientMaxZ: 2,
                u_ROLAngularVelocityGradientMaxW: 2,
                u_TSACycles: 2,
                u_TSASubUVLength: 2,
                u_TSAGradientUVs: 2,
                u_TSAMaxGradientUVs: 2,
                u_CameraPos: 3,
                u_CameraDirection: 3,
                u_CameraUp: 3,
                u_View: 3,
                u_Projection: 3,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\n#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n\tattribute vec4 a_CornerTextureCoordinate;\n#endif\n#ifdef RENDERMODE_MESH\n\tattribute vec3 a_MeshPosition;\n\tattribute vec4 a_MeshColor;\n\tattribute vec2 a_MeshTextureCoordinate;\n\tvarying vec4 v_MeshColor;\n#endif\n\nattribute vec4 a_ShapePositionStartLifeTime;\nattribute vec4 a_DirectionTime;\nattribute vec4 a_StartColor;\nattribute vec3 a_StartSize;\nattribute vec3 a_StartRotation0;\nattribute float a_StartSpeed;\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n  attribute vec4 a_Random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  attribute vec4 a_Random1;\n#endif\nattribute vec3 a_SimulationWorldPostion;\nattribute vec4 a_SimulationWorldRotation;\n\nvarying float v_Discard;\nvarying vec4 v_Color;\n#ifdef DIFFUSEMAP\n\tvarying vec2 v_TextureCoordinate;\n#endif\n\nuniform float u_CurrentTime;\nuniform vec3 u_Gravity;\n\nuniform vec3 u_WorldPosition;\nuniform vec4 u_WorldRotation;\nuniform bool u_ThreeDStartRotation;\nuniform int u_ScalingMode;\nuniform vec3 u_PositionScale;\nuniform vec3 u_SizeScale;\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\n#ifdef STRETCHEDBILLBOARD\n\tuniform vec3 u_CameraPosition;\n#endif\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\nuniform vec3 u_CameraUp;\n\nuniform  float u_StretchedBillboardLengthScale;\nuniform  float u_StretchedBillboardSpeedScale;\nuniform int u_SimulationSpace;\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  int  u_VOLSpaceType;\n#endif\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\n  uniform  vec3 u_VOLVelocityConst;\n#endif\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n  uniform  vec3 u_VOLVelocityConstMax;\n#endif\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\n#endif\n\n#ifdef COLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n#ifdef RANDOMCOLOROVERLIFETIME\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\n#endif\n\n\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\n#endif\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\n#endif\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\n#endif\n\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  float u_ROLAngularVelocityConst;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  float u_ROLAngularVelocityConstMax;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\n  #endif\n#endif\n#ifdef ROTATIONOVERLIFETIMESEPERATE\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\n  #endif\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\n  uniform  float u_TSACycles;\n  uniform  vec2 u_TSASubUVLength;\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\n#endif\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\n#endif\n\n#ifdef FOG\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef TILINGOFFSET\n\tuniform vec4 u_TilingOffset;\n#endif\n\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\n{\n\tfloat halfRoll = rot.z * 0.5;\n    float halfPitch = rot.x * 0.5;\n\tfloat halfYaw = rot.y * 0.5;\n\n\tfloat sinRoll = sin(halfRoll);\n\tfloat cosRoll = cos(halfRoll);\n\tfloat sinPitch = sin(halfPitch);\n\tfloat cosPitch = cos(halfPitch);\n\tfloat sinYaw = sin(halfYaw);\n\tfloat cosYaw = cos(halfYaw);\n\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n\t\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\t\n\tfloat x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n\tfloat xx = quaX * x;\n    float xy = quaX * y;\n\tfloat xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n\t\n}\n\n//假定axis已经归一化\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\n{\n\tfloat halfAngle = angle * 0.5;\n\tfloat sin = sin(halfAngle);\n\t\n\tfloat quaX = axis.x * sin;\n\tfloat quaY = axis.y * sin;\n\tfloat quaZ = axis.z * sin;\n\tfloat quaW = cos(halfAngle);\n\t\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\n\t\n\tfloat x = quaX + quaX;\n    float y = quaY + quaY;\n    float z = quaZ + quaZ;\n    float wx = quaW * x;\n    float wy = quaW * y;\n    float wz = quaW * z;\n\tfloat xx = quaX * x;\n    float xy = quaX * y;\n\tfloat xz = quaX * z;\n    float yy = quaY * y;\n    float yz = quaY * z;\n    float zz = quaZ * z;\n\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n\t\n}\n\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \n{\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n \n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n\tfloat curValue;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientNumber=gradientNumbers[i];\n\t\tfloat key=gradientNumber.x;\n\t\tif(key>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\n\t\t\tfloat lastKey=lastGradientNumber.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn curValue;\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\n{\n\tfloat totalValue=0.0;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientNumber=gradientNumbers[i];\n\t\tfloat key=gradientNumber.x;\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\n\t\tfloat lastValue=lastGradientNumber.y;\n\t\t\n\t\tif(key>=normalizedAge){\n\t\t\tfloat lastKey=lastGradientNumber.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\n\t\t}\n\t}\n\treturn totalValue;\n}\n#endif\n\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\n{\n\tvec4 overTimeColor;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientAlpha=gradientAlphas[i];\n\t\tfloat alphaKey=gradientAlpha.x;\n\t\tif(alphaKey>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec4 gradientColor=gradientColors[i];\n\t\tfloat colorKey=gradientColor.x;\n\t\tif(colorKey>=normalizedAge)\n\t\t{\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\n\t\t\tfloat lastColorKey=lastGradientColor.x;\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\n{\n\tfloat overTimeFrame;\n\tfor(int i=1;i<4;i++)\n\t{\n\t\tvec2 gradientFrame=gradientFrames[i];\n\t\tfloat key=gradientFrame.x;\n\t\tif(key>=normalizedAge)\n\t\t{\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\n\t\t\tfloat lastKey=lastGradientFrame.x;\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn floor(overTimeFrame);\n}\n#endif\n\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\nvec3 computeParticleLifeVelocity(in float normalizedAge)\n{\n  vec3 outLifeVelocity;\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\n\t outLifeVelocity=u_VOLVelocityConst; \n  #endif\n  #ifdef VELOCITYOVERLIFETIMECURVE\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \n  #endif\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n  #endif\n\t\t\t\t\t\n  return outLifeVelocity;\n} \n#endif\n\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\n{\n   vec3 startPosition;\n   vec3 lifePosition;\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=lifeVelocity*age;\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMECURVE\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=lifeVelocity*age;\n\t#endif\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\n\t\t  startPosition=startVelocity*age;\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\n\t#endif\n\t\n\tvec3 finalPosition;\n\tif(u_VOLSpaceType==0){\n\t  if(u_ScalingMode!=2)\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\n\t  else\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\n\t}\n\telse{\n\t  if(u_ScalingMode!=2)\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\n\t  else\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\n\t}\n  #else\n\t startPosition=startVelocity*age;\n\t vec3 finalPosition;\n\t if(u_ScalingMode!=2)\n\t   finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\n\t else\n\t   finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_SimulationSpace==0)\n    finalPosition=finalPosition+a_SimulationWorldPostion;\n  else if(u_SimulationSpace==1) \n    finalPosition=finalPosition+u_WorldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return  finalPosition;\n}\n\n\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\n{\n\t#ifdef COLOROVERLIFETIME\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\n\t#endif\n\t\n\t#ifdef RANDOMCOLOROVERLIFETIME\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\n\t#endif\n\n    return color;\n}\n\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\n{\n\t#ifdef SIZEOVERLIFETIMECURVE\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n\t#endif\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\n\t#endif\n\treturn size;\n}\n\n#ifdef RENDERMODE_MESH\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\n{\n\t#ifdef SIZEOVERLIFETIMECURVE\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \n\t#endif\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\n\t#endif\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\n\t#endif\n\treturn size;\n}\n#endif\n\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n\t\t#endif\n\t#endif\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n\t\t#endif\n\t#endif\n\treturn rotation;\n}\n\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\n{ \n\t#ifdef ROTATIONOVERLIFETIME\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\n\t\t#endif\n\t#endif\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\n\t        rotation+=ageRot;\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\n\t\t#endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\n\t        rotation+=ageRot;\n\t    #endif\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\n\t\t#endif\n\t#endif\n\treturn rotation;\n}\n#endif\n\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\n{ \n\t#ifdef TEXTURESHEETANIMATIONCURVE\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t    uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\n\t\tfloat floorTotalULength=floor(totalULength);\n\t    uv.x+=totalULength-floorTotalULength;\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\n    #endif\n\treturn uv;\n}\n\nvoid main()\n{\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\n\tvec3 lifeVelocity;\n\tif(normalizedAge<1.0){ \n\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\n\t#endif \n\tvec3 gravityVelocity=u_Gravity*age;\n\t\n\tvec4 worldRotation;\n\tif(u_SimulationSpace==0)\n\t\tworldRotation=a_SimulationWorldRotation;\n\telse\n\t\tworldRotation=u_WorldRotation;\n\t\n\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\n   \n   \n   #ifdef SPHERHBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\n\t    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n\t\t\t\tfloat c = cos(rot);\n\t\t\t\tfloat s = sin(rot);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#else\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfloat c = cos(a_StartRotation0.x);\n\t\t\t\tfloat s = sin(a_StartRotation0.x);\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\n\t\t\t\tcorner=rotation*corner;\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n\t\t\t}\n\t\t#endif\n   #endif\n   \n   #ifdef STRETCHEDBILLBOARD\n\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n\tvec3 velocity;\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\n\t    if(u_VOLSpaceType==0)\n\t\t  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\n\t    else\n\t\t  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\n    #else\n\t    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\n    #endif\t\n\t\tvec3 cameraUpVector = normalize(velocity);\n\t\tvec3 direction = normalize(center-u_CameraPosition);\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n\t\t\n\t\tsideVector=u_SizeScale.xzy*sideVector;\n\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\n\t\t\n\t    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n\t\t\n\t    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n\t    corner=rotaionZHalfPI*corner;\n\t    corner.y=corner.y-abs(corner.y);\n\t\t\n\t    float speed=length(velocity);//TODO:\n\t    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef HORIZONTALBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n\t    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n\t\t\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef VERTICALBILLBOARD\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\n\t\t\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n        float c = cos(rot);\n        float s = sin(rot);\n        mat2 rotation= mat2(c, -s, s, c);\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n   #endif\n   \n   #ifdef RENDERMODE_MESH\n\t    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t#ifdef ROTATIONOVERLIFETIME\n\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t#ifdef SHAPE\n\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\n\t\t\t\t\t\t#endif\n\t\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\n\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\n\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\n\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\n\t\t\t\t#endif\t\t\n\t\t\t}\n\t\t#else\n\t\t\tif(u_ThreeDStartRotation){\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\n\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\n\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t#ifdef SHAPE\n\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\n\t\t\t\t\t#else\n\t\t\t\t\t\tif(u_SimulationSpace==0)\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tv_MeshColor=a_MeshColor;\n   #endif\n   \n    gl_Position=u_Projection*u_View*vec4(center,1.0);\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\n\t#ifdef DIFFUSEMAP\n\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\n\t\t#endif\n\t\t#ifdef RENDERMODE_MESH\n\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\n\t\t#endif\n\t\t\n\t\t#ifdef TILINGOFFSET\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\n\t\t#endif\n\t#endif\n    v_Discard=0.0;\n\t  \n\t#ifdef FOG\n\t\tv_PositionWorld=center;\n\t#endif\n   }\n   else\n\t{\n\t\tv_Discard=1.0;\n\t}\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n\n', 
            t = "#ifdef HIGHPRECISION\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nvarying float v_Discard;\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\nuniform vec4 u_Tintcolor;\n\n#ifdef RENDERMODE_MESH\n\tvarying vec4 v_MeshColor;\n#endif\n\n#ifdef FOG\n\tvarying vec3 v_PositionWorld;\n\tuniform vec3 u_CameraPosition;\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\t#ifdef ADDTIVEFOG\n\t#else\n\t\tuniform vec3 u_FogColor;\n\t#endif\n#endif\n\n\nvoid main()\n{\t\n\t#ifdef RENDERMODE_MESH\n\t\tgl_FragColor=v_MeshColor;\n\t#else\n\t\tgl_FragColor=vec4(1.0);\t\n\t#endif\n\t\t\n\t#ifdef DIFFUSEMAP\n\t\tif(v_Discard!=0.0)\n\t\t\tdiscard;\n\t\t#ifdef TINTCOLOR\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\n\t\t#else\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n\t\t#endif\n\t#else\n\t\t#ifdef TINTCOLOR\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\n\t\t#else\n\t\t\tgl_FragColor*=v_Color;\n\t\t#endif\n\t#endif\n\t\n\t#ifdef FOG\n\t\tvec3 toEye=u_CameraPosition-v_PositionWorld;\n\t\tfloat toEyeLength=length(toEye);\n\t\ttoEye/=toEyeLength;\n\t\t\n\t\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n\t\t#ifdef ADDTIVEFOG\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\n\t\t#else\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n\t\t#endif\n\t#endif\n}", 
            a = Ve.add("PARTICLESHURIKEN"), o = new ot(n, i, xi.shaderDefines, si.shaderDefines), 
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_Position: 0
            }, i = {
                u_TintColor: 1,
                u_Exposure: 1,
                u_Rotation: 1,
                u_CubeTexture: 1,
                u_MvpMatrix: 3
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nuniform mat4 u_MvpMatrix;\nuniform float u_Rotation;\nvarying vec3 v_Texcoord;\n\n\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\n{\n\tfloat angle = degrees * 3.141593 / 180.0;\n\tfloat sina=sin(angle);\n\tfloat cosa=cos(angle);\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\n}\n\t\t\nvoid main()\n{\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\n\tgl_Position = (u_MvpMatrix*position).xyww;\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n', 
            t = "#ifdef HIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec3 v_Texcoord;\n\nuniform samplerCube u_CubeTexture;\nuniform float u_Exposure;\nuniform vec4 u_TintColor;\n\n\nvoid main()\n{\t\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\n\tgl_FragColor=vec4(color,1.0);\n}\n\n", 
            a = Ve.add("SkyBox"), o = new ot(n, i), a.addSubShader(o), o.addShaderPass(e, t), 
            n = {
                a_Position: 0
            }, i = {
                u_SunSize: 1,
                u_SunSizeConvergence: 1,
                u_AtmosphereThickness: 1,
                u_SkyTint: 1,
                u_GroundTint: 1,
                u_Exposure: 1,
                u_MvpMatrix: 3,
                "u_DirectionLight.Direction": 4,
                "u_DirectionLight.Color": 4
            }, e = "#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include \"Lighting.glsl\";\n\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\n#define MIE 0.0010             // Mie constant 米氏散射\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\n\nconst float SKY_GROUND_THRESHOLD = 0.02;\nconst float outerRadius = OUTER_RADIUS;\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float innerRadius = 1.0;\nconst float innerRadius2 = 1.0;\nconst float cameraHeight = 0.0001;\n\nconst float HDSundiskIntensityFactor = 15.0;\nconst float simpleSundiskIntensityFactor = 27.0;\n\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\nconst float kmESun = MIE * SUN_BRIGHTNESS;\nconst float km4PI = MIE * 4.0 * 3.14159265;\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float scaleDepth = 0.25;\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\n\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\n\nattribute vec4 a_Position;\n\nuniform mat4 u_MvpMatrix;\nuniform vec3 u_SkyTint;\nuniform vec3 u_GroundTint;\nuniform float u_Exposure;\nuniform float u_AtmosphereThickness;\nuniform DirectionLight u_DirectionLight;\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n#ifdef SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(vec3 light, vec3 ray) \n{\n\tfloat eyeCos = dot(light, ray);\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\n}\n\nfloat scaleAngle(float inCos)\n{\n\tfloat x = 1.0 - inCos;\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\n\nvoid main () {\n\tgl_Position = (u_MvpMatrix*a_Position).xyww;\n\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\n\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\n\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\n\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n\tvec3 eyeRay = normalize(a_Position.xyz);\n\n\tfloat far = 0.0;\n\tvec3 cIn, cOut;\n\tif (eyeRay.y >= 0.0) {// Sky\n\t\t// Calculate the length of the \"atmosphere\"\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat height = innerRadius + cameraHeight;\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\tvec3 frontColor = vec3(0.0);\n\t\t//unrolling this manually to avoid some platform for loop slow\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n\t\tcIn = frontColor * (invWavelength * krESun);\n\t\tcOut = frontColor * kmESun;\n\t} else {// Ground\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\n\t\tvec3 pos = cameraPos + far * eyeRay;\n\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\n\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, pos);\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\n\t\tfloat lightScale = scaleAngle(lightAngle);\n\t\tfloat cameraOffset = depth*cameraScale;\n\t\tfloat temp = lightScale + cameraScale;\n\n\t\t// Initialize the scattering loop variables\n\t\tfloat sampleLength = far / samples;\n\t\tfloat scaledLength = sampleLength * scale;\n\t\tvec3 sampleRay = eyeRay * sampleLength;\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\n\n\t\t// Now loop through the sample rays\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\n\t\tvec3 attenuate;\n\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\n\t\t{\n\t\t\tfloat height = length(samplePoint);\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\n\t\t\tfloat scatter = depth*temp - cameraOffset;\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\n\t\t\tsamplePoint += sampleRay;\n\t\t}\n\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\n\t}\n\n\t#ifdef SUN_HIGH_QUALITY\n\t\tv_Vertex = -a_Position.xyz;\n\t#elif defined(SUN_SIMPLE) \n\t\tv_RayDir = -eyeRay;\n\t#else\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\n\t#endif\n\n\t// if we want to calculate color in vprog:\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\n\n\t\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\n\tfloat lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\n\n\t#ifdef SUN_HIGH_QUALITY \n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n\t#elif defined(SUN_SIMPLE) \n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n", 
            t = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\nconst float MIE_G = -0.990;\nconst float MIE_G2 = 0.9801;\nconst float SKY_GROUND_THRESHOLD = 0.02;\n\nuniform float u_SunSize;\nuniform float u_SunSizeConvergence;\nuniform DirectionLight u_DirectionLight;\n\n\nvarying vec3 v_GroundColor;\nvarying vec3 v_SkyColor;\n\n\n#ifdef SUN_HIGH_QUALITY\n\tvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\n\tvarying vec3 v_RayDir;\n#else\n\tvarying float v_SkyGroundFactor;\n#endif\n\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\tvarying vec3 v_SunColor;\n#endif\n\n// Calculates the Mie phase function\nfloat getMiePhase(float eyeCos, float eyeCos2) {\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\n\treturn temp;\n}\n\n// Calculates the sun shape\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\n\t#ifdef SUN_HIGH_QUALITY\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\n\t#else //SUN_SIMPLE\n\t\tvec3 delta = lightPos - ray;\n\t\tfloat dist = length(delta);\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\n\t\treturn spot * spot;\n\t#endif\n}\n\nvoid main() {\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\n\t// if y < 0 [eyeRay.y > 0] - sky\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\n\t#ifdef SUN_HIGH_QUALITY\n\t\tvec3 ray = normalize(v_Vertex);\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\n\t#elif defined(SUN_SIMPLE) \n\t\tvec3 ray = v_RayDir;\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\n\t#else\n\t\tfloat y = v_SkyGroundFactor;\n\t#endif\n\n\t// if we did precalculate color in vprog: just do lerp between them\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\n\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\n\t\tif (y < 0.0)\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\n\t#endif\n\n\tcol = sqrt(col);//linear space convert to gamma space\n\tgl_FragColor=vec4(col,1.0);\n}\n\n', 
            a = Ve.add("SkyBoxProcedural"), o = new ot(n, i, null, ii.shaderDefines), a.addSubShader(o), 
            o.addShaderPass(e, t), n = {
                a_Position: 0,
                a_Normal: 3,
                a_Texcoord0: 2
            }, i = {
                u_MvpMatrix: 2,
                u_WorldMat: 2,
                u_CameraPos: 3,
                u_LightmapScaleOffset: 2,
                u_LightMap: 2,
                u_SplatAlphaTexture: 1,
                u_DiffuseTexture1: 1,
                u_DiffuseTexture2: 1,
                u_DiffuseTexture3: 1,
                u_DiffuseTexture4: 1,
                u_DiffuseTexture5: 1,
                u_DiffuseScaleOffset1: 1,
                u_DiffuseScaleOffset2: 1,
                u_DiffuseScaleOffset3: 1,
                u_DiffuseScaleOffset4: 1,
                u_DiffuseScaleOffset5: 1,
                u_FogStart: 4,
                u_FogRange: 4,
                u_FogColor: 4,
                "u_DirectionLight.Direction": 4,
                "u_DirectionLight.Color": 4,
                "u_PointLight.Position": 4,
                "u_PointLight.Range": 4,
                "u_PointLight.Attenuation": 4,
                "u_PointLight.Color": 4,
                "u_SpotLight.Position": 4,
                "u_SpotLight.Direction": 4,
                "u_SpotLight.Range": 4,
                "u_SpotLight.Spot": 4,
                "u_SpotLight.Color": 4,
                u_AmbientColor: 4,
                u_shadowMap1: 4,
                u_shadowMap2: 4,
                u_shadowMap3: 4,
                u_shadowPSSMDistance: 4,
                u_lightShadowVP: 4,
                u_shadowPCFoffset: 4
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec2 a_Texcoord0;\n\nuniform mat4 u_MvpMatrix;\n\nvarying vec2 v_Texcoord0;\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\n\tattribute vec3 a_Normal;\n\tvarying vec3 v_Normal;\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n\tuniform mat4 u_WorldMat;\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef LIGHTMAP\n\tvarying vec2 v_LightMapUV;\n\tuniform vec4 u_LightmapScaleOffset;\n#endif\n\n#ifdef RECEIVESHADOW\n\tvarying float v_posViewZ;\n\t#ifdef SHADOWMAP_PSSM1 \n\t\tvarying vec4 v_lightMVPPos;\n\t\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n#endif\n\nvoid main()\n{\n\tgl_Position = u_MvpMatrix * a_Position;\n  \n\tv_Texcoord0 = a_Texcoord0;\n  \n\t#ifdef LIGHTMAP\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\n\t#endif\n  \n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t\tv_Normal = a_Normal;\n\t#endif\n\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\n\t#endif\n\n\t#ifdef RECEIVESHADOW\n\t\tv_posViewZ = gl_Position.w;\n\t\t#ifdef SHADOWMAP_PSSM1\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\n\t\t#endif\n\t#endif\n\tgl_Position=remapGLPositionZ(gl_Position);\n}', 
            t = '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Lighting.glsl";\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n\tuniform vec3 u_CameraPos;\n\tvarying vec3 v_Normal;\n\tvarying vec3 v_PositionWorld;\n#endif\n\n#ifdef FOG\n\tuniform float u_FogStart;\n\tuniform float u_FogRange;\n\tuniform vec3 u_FogColor;\n#endif\n\n\n#ifdef DIRECTIONLIGHT\n\tuniform DirectionLight u_DirectionLight;\n#endif\n\n#ifdef POINTLIGHT\n\tuniform PointLight u_PointLight;\n#endif\n\n#ifdef SPOTLIGHT\n\tuniform SpotLight u_SpotLight;\n#endif\n\n#include "ShadowHelper.glsl"\n#ifdef RECEIVESHADOW\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\n\tuniform mat4 u_lightShadowVP[4];\n\t#endif\n\t#ifdef SHADOWMAP_PSSM1 \n\tvarying vec4 v_lightMVPPos;\n\t#endif\n#endif\nvarying float v_posViewZ;\n\nuniform vec3 u_AmbientColor;\n\nuniform sampler2D u_SplatAlphaTexture;\n\nuniform sampler2D u_DiffuseTexture1;\nuniform sampler2D u_DiffuseTexture2;\nuniform sampler2D u_DiffuseTexture3;\nuniform sampler2D u_DiffuseTexture4;\nuniform sampler2D u_DiffuseTexture5;\n\nuniform vec4 u_DiffuseScaleOffset1;\nuniform vec4 u_DiffuseScaleOffset2;\nuniform vec4 u_DiffuseScaleOffset3;\nuniform vec4 u_DiffuseScaleOffset4;\nuniform vec4 u_DiffuseScaleOffset5;\n\nvarying vec2 v_Texcoord0;\n\n#ifdef LIGHTMAP\n\tuniform sampler2D u_LightMap;\n\tvarying vec2 v_LightMapUV;\n#endif\n\nvoid main()\n{\n\tvec4 splatAlpha = vec4(1.0);\n\t#ifdef ExtendTerrain_DETAIL_NUM1\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM2\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM3\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM4\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\n\t#endif\n\t#ifdef ExtendTerrain_DETAIL_NUM5\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\n\t#endif\n\t\tgl_FragColor.w = splatAlpha.a;\n\t\t\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n    vec3 normal = v_Normal;\n\tvec3 dif, spe;\n#endif\n\nvec3 diffuse = vec3(0.0);\nvec3 specular= vec3(0.0);\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\n\tvec3 toEye;\n\t#ifdef FOG\n\t\ttoEye=u_CameraPos-v_PositionWorld;\n\t\tfloat toEyeLength=length(toEye);\n\t\ttoEye/=toEyeLength;\n\t#else\n\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\n\t#endif\n#endif\n\n#ifdef DIRECTIONLIGHT\n\tLayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n \n#ifdef POINTLIGHT\n\tLayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n\n#ifdef SPOTLIGHT\n\tLayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\n\tdiffuse+=dif;\n\tspecular+=spe;\n#endif\n\nvec3 globalDiffuse = u_AmbientColor;\n#ifdef LIGHTMAP\n\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\n#endif\n\n#ifdef RECEIVESHADOW\n\tfloat shadowValue = 1.0;\n\t#ifdef SHADOWMAP_PSSM3\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t#endif\n\t#ifdef SHADOWMAP_PSSM2\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\n\t#endif \n\t#ifdef SHADOWMAP_PSSM1\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\n\t#endif\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\n#else\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\n#endif\n\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\n\t#ifdef RECEIVESHADOW\n\t\tgl_FragColor.rgb += specular * shadowValue;\n\t#else\n\t\tgl_FragColor.rgb += specular;\n\t#endif\n#endif\n\n#ifdef FOG\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\n#endif\n}\n\n\n\n\n\n', 
            a = Ve.add("ExtendTerrain"), o = new ot(n, i, Jn.shaderDefines, ui.shaderDefines), 
            a.addSubShader(o), o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_OffsetVector: 1,
                a_Texcoord0X: 4,
                a_Texcoord0Y: 3,
                a_BirthTime: 2
            }, i = {
                u_MvpMatrix: 2,
                u_View: 3,
                u_Projection: 3,
                u_TilingOffset: 1,
                u_MainTexture: 1,
                u_MainColor: 1,
                u_CurTime: 2,
                u_LifeTime: 2,
                u_WidthCurve: 2,
                u_WidthCurveKeyLength: 2,
                u_GradientColorkey: 2,
                u_GradientAlphakey: 2
            }, r = {
                s_Cull: 0,
                s_Blend: 1,
                s_BlendSrc: 2,
                s_BlendDst: 3,
                s_DepthTest: 12,
                s_DepthWrite: 13
            }, e = '#include "Lighting.glsl";\n\nattribute vec3 a_Position;\nattribute vec3 a_OffsetVector;\nattribute vec4 a_Color;\nattribute float a_Texcoord0X;\nattribute float a_Texcoord0Y;\nattribute float a_BirthTime;\n\nuniform mat4 u_View;\nuniform mat4 u_Projection;\n\nuniform vec4 u_TilingOffset;\n\nuniform float u_CurTime;\nuniform float u_LifeTime;\nuniform vec4 u_WidthCurve[10];\nuniform int u_WidthCurveKeyLength;\n\nuniform vec4 u_GradientColorkey[10];\nuniform vec2 u_GradientAlphakey[10];\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\n{\n\tfloat t2 = t * t;\n\tfloat t3 = t2 * t;\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\n\tfloat b = t3 - 2.0 * t2 + t;\n\tfloat c = t3 - t2;\n\tfloat d = -2.0 * t3 + 3.0 * t2;\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\n}\n\nfloat getCurWidth(in float normalizeTime)\n{\n\tfloat width;\n\tif(normalizeTime == 0.0){\n\t\twidth=u_WidthCurve[0].w;\n\t}\n\telse if(normalizeTime >= 1.0){\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\n\t}\n\telse{\n\t\tfor(int i = 0; i < 10; i ++ )\n\t\t{\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\n\t\t\t\twidth=u_WidthCurve[i].w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\n\t\t\t{\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\n\t\t\t\tfloat outTangent = lastFrame.z;\n\t\t\t\tfloat inTangent = nextFrame.y;\n\t\t\t\tfloat value1 = lastFrame.w;\n\t\t\t\tfloat value2 = nextFrame.w;\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn width;\n}\t\n\nvec4 getColorFromGradientByBlend(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n\tvec4 color;\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec4 gradientColor = gradientColors[i];\n\t\tfloat colorKey = gradientColor.x;\n\t\tif(colorKey >= normalizeTime)\n\t\t{\n\t\t\tvec4 lastGradientColor = gradientColors[i-1];\n\t\t\tfloat lastColorKey = lastGradientColor.x;\n\t\t\tfloat age = (normalizeTime - lastColorKey) / (colorKey - lastColorKey);\n\t\t\tcolor.rgb = mix(gradientColors[i-1].yzw, gradientColor.yzw, age);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec2 gradientAlpha = gradientAlphas[i];\n\t\tfloat alphaKey = gradientAlpha.x;\n\t\tif(alphaKey >= normalizeTime)\n\t\t{\n\t\t\tvec2 lastGradientAlpha = gradientAlphas[i-1];\n\t\t\tfloat lastAlphaKey = lastGradientAlpha.x;\n\t\t\tfloat age = (normalizeTime - lastAlphaKey) / (alphaKey - lastAlphaKey);\n\t\t\tcolor.a = mix(lastGradientAlpha.y, gradientAlpha.y, age);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec4 getColorFromGradientByFixed(in vec4 gradientColors[10], in vec2 gradientAlphas[10], in float normalizeTime)\n{\n\tvec4 color;\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec4 gradientColor = gradientColors[i];\n\t\tif(gradientColor.w >= normalizeTime)\n\t\t{\n\t\t\tcolor.rgb = gradientColor.xyz;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i = 1; i < 10; i++)\n\t{\n\t\tvec2 gradientAlpha = gradientAlphas[i];\n\t\tif(gradientAlpha.y >= normalizeTime)\n\t\t{\n\t\t\tcolor.a = gradientAlpha.x;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid main()\n{\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\n\t\n\t#ifdef TILINGOFFSET\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\n\t#else\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\n\t#endif\n\t\n\t#ifdef GRADIENTMODE_BLEND\n\t\tv_Color = getColorFromGradientByBlend(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n\t#else\n\t\tv_Color = getColorFromGradientByFixed(u_GradientColorkey, u_GradientAlphakey, normalizeTime);\n\t#endif\n\t\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\n\tgl_Position=remapGLPositionZ(gl_Position);\n}\n', 
            t = "#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nuniform sampler2D u_MainTexture;\nuniform vec4 u_MainColor;\n\nvarying vec2 v_Texcoord0;\nvarying vec4 v_Color;\n\nvoid main()\n{\t\n\tvec4 color = 2.0 * u_MainColor * v_Color;\n\t#ifdef MAINTEXTURE\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\n\t\tcolor *= mainTextureColor;\n\t#endif\n\tgl_FragColor = color;\n}\n\n", 
            a = Ve.add("Trail"), o = new ot(n, i, gi.shaderDefines, ni.shaderDefines), a.addSubShader(o), 
            o.addShaderPass(e, t, r), n = {
                a_Position: 0,
                a_Normal: 3,
                a_Tangent0: 4
            }, i = {
                u_MvpMatrix: 2,
                u_WorldMat: 2,
                u_CameraPos: 3,
                u_Time: 4,
                u_MainTexture: 1,
                u_NormalTexture: 1,
                u_HorizonColor: 1,
                u_WaveScale: 1,
                u_WaveSpeed: 1
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_Position;\nattribute vec3 a_Normal;\nattribute vec4 a_Tangent0;\n\nuniform mat4 u_MvpMatrix;\nuniform mat4 u_WorldMat;\nuniform vec3 u_CameraPos;\nuniform float u_WaveScale;\nuniform vec4 u_WaveSpeed;\nuniform float u_Time;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\nvoid main()\n{\n\tvec4 positionWorld = u_WorldMat * a_Position;\n\tvec4 position = u_MvpMatrix * a_Position;\n\t\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\n\t\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\n\tv_Texcoord1 = temp.wz;\n\t\n\tmat3 worldMat = mat3(u_WorldMat);\n\tv_Normal = worldMat * a_Normal;\n\tv_Tangent = worldMat * a_Tangent0.xyz;\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\n\t\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\n\tgl_Position = position;\n\tgl_Position=remapGLPositionZ(gl_Position);\n}', 
            t = '#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#ifdef MAINTEXTURE\n\tuniform sampler2D u_MainTexture;\n#endif\n\n#ifdef NORMALTEXTURE\n\tuniform sampler2D u_NormalTexture;\n#endif\n\nuniform vec4 u_HorizonColor;\n\nvarying vec3 v_Normal;\nvarying vec3 v_Tangent;\nvarying vec3 v_Binormal;\nvarying vec3 v_ViewDir;\nvarying vec2 v_Texcoord0;\nvarying vec2 v_Texcoord1;\n\n#include "Lighting.glsl"\n\nvoid main()\n{\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\n\t\n\tvec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\n\tvec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\n\t\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\n\tvec3 viewDir = normalize(v_ViewDir);\n\tfloat fresnel = dot(viewDir, normal);\n\t\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\n\t\n\tvec4 color;\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\n\tcolor.a = u_HorizonColor.a;\n\t\n\tgl_FragColor = color;\n}\n\n', 
            a = Ve.add("WaterPrimary"), o = new ot(n, i, null, hi.shaderDefines), a.addSubShader(o), 
            o.addShaderPass(e, t), n = {
                a_PositionTexcoord: 0
            }, i = {
                u_ScreenTexture: 1
            }, e = '#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', 
            t = "#ifdef FSHIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\nuniform sampler2D u_ScreenTexture;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_FragColor = texture2D(u_ScreenTexture, v_Texcoord0);\n}\n\n", 
            a = Ve.add("ScreenQuad"), o = new ot(n, i, null, null), a.addSubShader(o);
            var s = o.addShaderPass(e, t), l = s.renderState;
            l.depthTest = 519, l.depthWrite = !1, l.cull = 0, l.blend = 0, n = {
                a_PositionTexcoord: 0
            }, i = {
                u_MainTex: 1,
                u_BloomTex: 1,
                u_AutoExposureTex: 1,
                u_MainTex_TexelSize: 1,
                u_SampleScale: 1,
                u_Threshold: 1,
                u_Params: 1
            }, a = Ve.add("PostProcessBloom", n, i), o = new ot(null, null, null, null), a.addSubShader(o), 
            (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_AutoExposureTex;\nuniform vec4 u_MainTex_TexelSize;\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\nuniform vec4 u_Params; // x: clamp, yzw: unused\n\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\n\tcolor *= autoExposure;\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\n\treturn color;\n}\n\nvoid fragPrefilter13() {\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\n}\n\nvoid main() {\n\tfragPrefilter13();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, o = new ot(null, null, null, null), 
            a.addSubShader(o), (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_AutoExposureTex;\nuniform vec4 u_MainTex_TexelSize;\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\nuniform vec4 u_Params; // x: clamp, yzw: unused\n\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\n\tcolor *= autoExposure;\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\n\treturn color;\n}\n\nvoid fragPrefilter4() {\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\n}\n\nvoid main() {\n\tfragPrefilter4();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, o = new ot(null, null, null, null), 
            a.addSubShader(o), (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform vec4 u_MainTex_TexelSize;\n\nvoid fragDownsample13() {\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\n\tgl_FragColor = color;\n}\n\nvoid main() {\n\tfragDownsample13();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, o = new ot(null, null, null, null), 
            a.addSubShader(o), (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_BloomTex;\n\nuniform vec4 u_MainTex_TexelSize;\nuniform float u_SampleScale;\n\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\n\treturn bloom + color;\n}\n\nvoid fragUpsampleTent() {\n\tmediump vec4 bloom = UpsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, u_SampleScale);\n\tgl_FragColor = combine(bloom, v_Texcoord0);\n}\n\nvoid main() {\n\tfragUpsampleTent();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, o = new ot(null, null, null, null), 
            a.addSubShader(o), (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_BloomTex;\n\nuniform vec4 u_MainTex_TexelSize;\nuniform float u_SampleScale;\n\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\n\treturn bloom + color;\n}\n\nvoid fragUpsampleBox() {\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\n\tgl_FragColor = combine(bloom, v_Texcoord0);\n}\n\nvoid main() {\n\tfragUpsampleBox();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, o = new ot(null, null, null, null), 
            a.addSubShader(o), (l = (s = o.addShaderPass('#include "Lighting.glsl";\n\nattribute vec4 a_PositionTexcoord;\nvarying vec2 v_Texcoord0;\n\nvoid main() {\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\n\tv_Texcoord0 = a_PositionTexcoord.zw;\n\tgl_Position = remapGLPositionZ(gl_Position);\n}', '#ifdef HIGHPRECISION\n\tprecision highp float;\n#else\n\tprecision mediump float;\n#endif\n\n#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_AutoExposureTex;\nuniform vec4 u_MainTex_TexelSize;\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\nuniform vec4 u_Params; // x: clamp, yzw: unused\n\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\n\tcolor *= autoExposure;\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\n\treturn color;\n}\n\nvoid fragPrefilter13() {\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\n}\n\nvoid main() {\n\tfragPrefilter13();\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0, n = {
                a_PositionTexcoord: 0
            }, i = {
                u_MainTex: 1,
                u_BloomTex: 1,
                u_AutoExposureTex: 1,
                u_Bloom_DirtTex: 1,
                u_BloomTex_TexelSize: 1,
                u_Bloom_Settings: 1,
                u_Bloom_Color: 1
            }, a = Ve.add("PostProcessComposite", n, i), o = new ot(null, null, null, Rt.shaderDefines), 
            a.addSubShader(o), (l = (s = o.addShaderPass("attribute vec4 a_Position;\nvarying vec2 v_Texcoord0;\n\nvec2 TransformTriangleVertexToUV(vec2 vertex)\n{\n    vec2 uv = (vertex + 1.0) * 0.5;\n    return uv;\n}\n\nvoid main() {\n\tgl_Position =vec4(a_Position.xy, 0.0, 1.0);\n\tv_Texcoord0=TransformTriangleVertexToUV(a_Position.xy);\n\tgl_Position=remapGLPositionZ(gl_Position);\n}", '#include "Colors.glsl";\n#include "Sampling.glsl";\n\nvarying vec2 v_Texcoord0;\n\nuniform sampler2D u_MainTex;\nuniform sampler2D u_BloomTex;\n\nuniform sampler2D u_AutoExposureTex;\nuniform sampler2D u_Bloom_DirtTex;\nuniform vec4 u_BloomTex_TexelSize;\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\nuniform mediump vec3 u_Bloom_Color;\n\nvoid main() {\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\n\tmediump vec4 color=vec4(0.0)\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\n\t\n\tcolor = SRGBToLinear(color);\n\tcolor.rgb *= autoExposure;\n\t\n\t#if BLOOM || BLOOM_LOW\n\t{\n\t\t#if BLOOM\n\t\t\tmediump vec4 bloom = UpsampleTent(_BloomTex, uvDistorted, _BloomTex_TexelSize.xy, _Bloom_Settings.x);\n\t\t#else\n\t\t\tmediump vec4 bloom = UpsampleBox(_BloomTex, uvDistorted, _BloomTex_TexelSize.xy, _Bloom_Settings.x);\n\t\t#endif\n\n\t\t// UVs should be Distort(uv * _Bloom_DirtTileOffset.xy + _Bloom_DirtTileOffset.zw)\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\n\t\t// is active\n\t\tmediump vec4 dirt = mediump vec4(SAMPLE_TEXTURE2D(_Bloom_DirtTex, sampler_Bloom_DirtTex, uvDistorted * _Bloom_DirtTileOffset.xy + _Bloom_DirtTileOffset.zw).rgb, 0.0);\n\n\t\t// Additive bloom (artist friendly)\n\t\tbloom *= _Bloom_Settings.y;\n\t\tdirt *= _Bloom_Settings.z;\n\t\tcolor += bloom * half4(_Bloom_Color, 1.0);\n\t\tcolor += dirt * bloom;\n\t}\n\t#endif\n\t\n\thalf4 output = color;\n\toutput = LinearToSRGB(output);\n\t//output.rgb = Dither(output.rgb, v_Texcoord0);//TODO:\n}')).renderState).depthTest = 519, 
            l.depthWrite = !1, l.cull = 0, l.blend = 0;
        }, ShaderInit3D._rangeAttenTex = null, ShaderInit3D;
    }(), ke = function() {
        function Utils3D() {}
        return r(Utils3D, "laya.d3.utils.Utils3D"), Utils3D._convertToLayaVec3 = function(e, t, n) {
            t.x = n ? -e.x() : e.x(), t.y = e.y(), t.z = e.z();
        }, Utils3D._convertToBulletVec3 = function(e, t, n) {
            t.setValue(n ? -e.x : e.x, e.y, e.z);
        }, Utils3D._rotationTransformScaleSkinAnimation = function(e, t, n, i, r, a, o, s, l, h, u, c) {
            var d, _, f, m, p, T = Utils3D._tempArray16_0, S = Utils3D._tempArray16_1, E = Utils3D._tempArray16_2, v = i + i, g = r + r, x = a + a, M = i * v, y = r * v, D = r * g, R = a * v, C = a * g, I = a * x, A = o * v, L = o * g, O = o * x;
            for (T[15] = 1, T[0] = 1 - D - I, T[1] = y + O, T[2] = R - L, T[4] = y - O, T[5] = 1 - M - I, 
            T[6] = C + A, T[8] = R + L, T[9] = C - A, T[10] = 1 - M - D, S[15] = 1, S[0] = s, 
            S[5] = l, S[10] = h, d = 0; d < 4; d++) _ = T[d], f = T[d + 4], m = T[d + 8], p = T[d + 12], 
            E[d] = _, E[d + 4] = f, E[d + 8] = m, E[d + 12] = _ * e + f * t + m * n + p;
            for (d = 0; d < 4; d++) _ = E[d], f = E[d + 4], m = E[d + 8], p = E[d + 12], u[d + c] = _ * S[0] + f * S[1] + m * S[2] + p * S[3], 
            u[d + c + 4] = _ * S[4] + f * S[5] + m * S[6] + p * S[7], u[d + c + 8] = _ * S[8] + f * S[9] + m * S[10] + p * S[11], 
            u[d + c + 12] = _ * S[12] + f * S[13] + m * S[14] + p * S[15];
        }, Utils3D._createSceneByJsonForMaker = function(e, t, n) {
            var i = Utils3D._createNodeByJsonForMaker(e, t, n);
            return Utils3D._addComponentByJsonForMaker(e, t, n), i;
        }, Utils3D._createNodeByJsonForMaker = function(e, t, n) {
            var i;
            switch (e.type) {
              case "Scene3D":
                i = new qn();
                break;

              case "Sprite3D":
                i = new bn();
                break;

              case "MeshSprite3D":
                i = new Si(), t && t.push(i);
                break;

              case "SkinnedMeshSprite3D":
                i = new yi();
                break;

              case "ShuriKenParticle3D":
                i = new xi();
                break;

              case "Terrain":
                i = new ti();
                break;

              case "Camera":
                i = new Ci();
                break;

              case "DirectionLight":
                i = new vi();
                break;

              case "PointLight":
                i = new Di();
                break;

              case "SpotLight":
                i = new Ei();
                break;

              case "TrailSprite3D":
                i = new gi();
                break;

              default:
                var r = d.getClass(e.props.runtime);
                i = new r();
            }
            var a = e.child;
            if (a) for (var o = 0, s = a.length; o < s; o++) {
                var h = Utils3D._createNodeByJsonForMaker(a[o], t, n);
                i.addChild(h);
            }
            var u = e.compId;
            i.compId = u, i._parse(e.props, null), n && (n._idMap[u] = i), Utils3D._compIdToNode[u] = i;
            var c = e.components;
            if (c) for (var _ = 0, f = c.length; _ < f; _++) {
                var m = c[_];
                if (!(r = l.window.Laya[m.type])) r = l.window, m.type.split(".").forEach(function(e) {
                    r = r[e];
                });
                if ("function" == typeof r) {
                    var p = new r();
                    n && (n._idMap[m.compId] = p, console.log(m.compId));
                } else console.warn("Utils3D:Unkown component type.");
            }
            return i;
        }, Utils3D._addComponentByJsonForMaker = function(e, t, n) {
            var i = e.compId, r = Utils3D._compIdToNode[i], a = e.child;
            if (a) for (var o = 0, s = a.length; o < s; o++) Utils3D._addComponentByJsonForMaker(a[o], t, n);
            var h = e.components;
            if (h) for (var u = 0, c = h.length; u < c; u++) {
                var d = h[u];
                if (!(f = l.window.Laya[d.type])) {
                    var _ = d.type.split("."), f = l.window;
                    _.forEach(function(e) {
                        f = f[e];
                    });
                }
                if ("function" == typeof f) {
                    var m = n._idMap[d.compId];
                    r.addComponentIntance(m), m._parse(d);
                } else console.warn("Utils3D:Unkown component type.");
            }
        }, Utils3D._createSprite3DInstance = function(e, t, n) {
            var i;
            switch (e.type) {
              case "Scene3D":
                i = new qn();
                break;

              case "Sprite3D":
                i = new bn();
                break;

              case "MeshSprite3D":
                i = new Si(), n && n.push(i);
                break;

              case "SkinnedMeshSprite3D":
                i = new yi();
                break;

              case "ShuriKenParticle3D":
                i = new xi();
                break;

              case "Terrain":
                i = new ti();
                break;

              case "Camera":
                i = new Ci();
                break;

              case "DirectionLight":
                i = new vi();
                break;

              case "PointLight":
                i = new Di();
                break;

              case "SpotLight":
                i = new Ei();
                break;

              case "TrailSprite3D":
                i = new gi();
                break;

              default:
                throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var r = e.child;
            if (r) for (var a = 0, o = r.length; a < o; a++) {
                var s = Utils3D._createSprite3DInstance(r[a], t, n);
                i.addChild(s);
            }
            return t[e.instanceID] = i, i;
        }, Utils3D._createComponentInstance = function(e, t) {
            var n = t[e.instanceID];
            n._parse(e.props, t);
            var i = e.child;
            if (i) for (var r = 0, a = i.length; r < a; r++) Utils3D._createComponentInstance(i[r], t);
            var o = e.components;
            if (o) for (var s = 0, h = o.length; s < h; s++) {
                var u = o[s], c = l.window.Laya[u.type];
                if (!c) {
                    var d = u.type.split(".");
                    c = l.window, d.forEach(function(e) {
                        c = c[e];
                    });
                }
                if ("function" == typeof c) n.addComponent(c)._parse(u); else console.warn("Unkown component type.");
            }
        }, Utils3D._createNodeByJson02 = function(e, t) {
            var n = {}, i = Utils3D._createSprite3DInstance(e, n, t);
            return Utils3D._createComponentInstance(e, n), i;
        }, Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxix = function(e, t, n, i, r, a) {
            var o, s, l = 0, h = 0, u = e.length;
            for (o = 0; o < u; l += e[o].keyframeWidth, h += 16, o++) laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], i, h), 
            0 != o && (s = 16 * e[o].parentIndex, laya.d3.utils.Utils3D.mulMatrixByArray(i, s, i, h, i, h));
            var c = n.length;
            for (o = 0; o < c; o++) laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(i, 16 * a[o], n[o], r, 16 * o);
        }, Utils3D._computeAnimationDatasByArrayAndMatrixFast = function(e, t, n, i) {
            for (var r = 0, a = e.length; r < a; r++) laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(t, 16 * i[r], e[r], n, 16 * r);
        }, Utils3D._computeBoneAndAnimationDatasByBindPoseMatrxixOld = function(e, t, n, i, r) {
            var a, o, s = 0, l = 0, h = e.length;
            for (a = 0; a < h; s += e[a].keyframeWidth, l += 16, a++) laya.d3.utils.Utils3D._rotationTransformScaleSkinAnimation(t[s + 7], t[s + 8], t[s + 9], t[s + 3], t[s + 4], t[s + 5], t[s + 6], t[s + 0], t[s + 1], t[s + 2], i, l), 
            0 != a && (o = 16 * e[a].parentIndex, laya.d3.utils.Utils3D.mulMatrixByArray(i, o, i, l, i, l));
            var u = n.length;
            for (a = 0; a < u; a++) {
                var c = 16 * a;
                laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(i, c, n[a], r, c);
            }
        }, Utils3D._computeAnimationDatasByArrayAndMatrixFastOld = function(e, t, n) {
            for (var i = e.length, r = 0; r < i; r++) {
                var a = 16 * r;
                laya.d3.utils.Utils3D.mulMatrixByArrayAndMatrixFast(t, a, e[r], n, a);
            }
        }, Utils3D._computeRootAnimationData = function(e, t, n) {
            for (var i = 0, r = 0, a = 0, o = e.length; i < o; r += e[i].keyframeWidth, a += 16, 
            i++) laya.d3.utils.Utils3D.createAffineTransformationArray(t[r + 0], t[r + 1], t[r + 2], t[r + 3], t[r + 4], t[r + 5], t[r + 6], t[r + 7], t[r + 8], t[r + 9], n, a);
        }, Utils3D.transformVector3ArrayByQuat = function(e, t, n, i, r) {
            var a = e[t], o = e[t + 1], s = e[t + 2], l = n.x, h = n.y, u = n.z, c = n.w, d = c * a + h * s - u * o, _ = c * o + u * a - l * s, f = c * s + l * o - h * a, m = -l * a - h * o - u * s;
            i[r] = d * c + m * -l + _ * -u - f * -h, i[r + 1] = _ * c + m * -h + f * -l - d * -u, 
            i[r + 2] = f * c + m * -u + d * -h - _ * -l;
        }, Utils3D.mulMatrixByArray = function(e, t, n, i, r, a) {
            var o, s, l, h, u;
            if (r === n) {
                for (n = Utils3D._tempArray16_3, o = 0; o < 16; ++o) n[o] = r[a + o];
                i = 0;
            }
            for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], h = e[t + o + 8], u = e[t + o + 12], 
            r[a + o] = s * n[i + 0] + l * n[i + 1] + h * n[i + 2] + u * n[i + 3], r[a + o + 4] = s * n[i + 4] + l * n[i + 5] + h * n[i + 6] + u * n[i + 7], 
            r[a + o + 8] = s * n[i + 8] + l * n[i + 9] + h * n[i + 10] + u * n[i + 11], r[a + o + 12] = s * n[i + 12] + l * n[i + 13] + h * n[i + 14] + u * n[i + 15];
        }, Utils3D.mulMatrixByArrayFast = function(e, t, n, i, r, a) {
            var o, s, l, h, u;
            for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], h = e[t + o + 8], u = e[t + o + 12], 
            r[a + o] = s * n[i + 0] + l * n[i + 1] + h * n[i + 2] + u * n[i + 3], r[a + o + 4] = s * n[i + 4] + l * n[i + 5] + h * n[i + 6] + u * n[i + 7], 
            r[a + o + 8] = s * n[i + 8] + l * n[i + 9] + h * n[i + 10] + u * n[i + 11], r[a + o + 12] = s * n[i + 12] + l * n[i + 13] + h * n[i + 14] + u * n[i + 15];
        }, Utils3D.mulMatrixByArrayAndMatrixFast = function(e, t, n, i, r) {
            var a, o, s, l, h, u = n.elements, c = u[0], d = u[1], _ = u[2], f = u[3], m = u[4], p = u[5], T = u[6], S = u[7], E = u[8], v = u[9], g = u[10], x = u[11], M = u[12], y = u[13], D = u[14], R = u[15], C = t, I = t + 4, A = t + 8, L = t + 12, O = r, P = r + 4, V = r + 8, N = r + 12;
            for (a = 0; a < 4; a++) o = e[C + a], s = e[I + a], l = e[A + a], h = e[L + a], 
            i[O + a] = o * c + s * d + l * _ + h * f, i[P + a] = o * m + s * p + l * T + h * S, 
            i[V + a] = o * E + s * v + l * g + h * x, i[N + a] = o * M + s * y + l * D + h * R;
        }, Utils3D.createAffineTransformationArray = function(e, t, n, i, r, a, o, s, l, h, u, c) {
            var d = i + i, _ = r + r, f = a + a, m = i * d, p = i * _, T = i * f, S = r * _, E = r * f, v = a * f, g = o * d, x = o * _, M = o * f;
            u[c + 0] = (1 - (S + v)) * s, u[c + 1] = (p + M) * s, u[c + 2] = (T - x) * s, u[c + 3] = 0, 
            u[c + 4] = (p - M) * l, u[c + 5] = (1 - (m + v)) * l, u[c + 6] = (E + g) * l, u[c + 7] = 0, 
            u[c + 8] = (T + x) * h, u[c + 9] = (E - g) * h, u[c + 10] = (1 - (m + S)) * h, u[c + 11] = 0, 
            u[c + 12] = e, u[c + 13] = t, u[c + 14] = n, u[c + 15] = 1;
        }, Utils3D.transformVector3ArrayToVector3ArrayCoordinate = function(e, t, n, i, r) {
            var a = e[t + 0], o = e[t + 1], s = e[t + 2], l = n.elements, h = a * l[3] + o * l[7] + s * l[11] + l[15];
            i[r] = a * l[0] + o * l[4] + s * l[8] + l[12] / h, i[r + 1] = a * l[1] + o * l[5] + s * l[9] + l[13] / h, 
            i[r + 2] = a * l[2] + o * l[6] + s * l[10] + l[14] / h;
        }, Utils3D.transformLightingMapTexcoordArray = function(e, t, n, i, r) {
            i[r + 0] = e[t + 0] * n.x + n.z, i[r + 1] = 1 - ((1 - e[t + 1]) * n.y + n.w);
        }, Utils3D.getURLVerion = function(e) {
            var t = e.indexOf("?");
            return t >= 0 ? e.substr(t) : null;
        }, Utils3D._createAffineTransformationArray = function(e, t, n, i) {
            var r = t.x, a = t.y, o = t.z, s = t.w, l = r + r, h = a + a, u = o + o, c = r * l, d = r * h, _ = r * u, f = a * h, m = a * u, p = o * u, T = s * l, S = s * h, E = s * u, v = n.x, g = n.y, x = n.z;
            i[0] = (1 - (f + p)) * v, i[1] = (d + E) * v, i[2] = (_ - S) * v, i[3] = 0, i[4] = (d - E) * g, 
            i[5] = (1 - (c + p)) * g, i[6] = (m + T) * g, i[7] = 0, i[8] = (_ + S) * x, i[9] = (m - T) * x, 
            i[10] = (1 - (c + f)) * x, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
        }, Utils3D._mulMatrixArray = function(e, t, n, i) {
            var r, a, o, s, l, h = t.elements, u = h[0], c = h[1], d = h[2], _ = h[3], f = h[4], m = h[5], p = h[6], T = h[7], S = h[8], E = h[9], v = h[10], g = h[11], x = h[12], M = h[13], y = h[14], D = h[15], R = i, C = i + 4, I = i + 8, A = i + 12;
            for (r = 0; r < 4; r++) a = e[r], o = e[r + 4], s = e[r + 8], l = e[r + 12], n[R + r] = a * u + o * c + s * d + l * _, 
            n[C + r] = a * f + o * m + s * p + l * T, n[I + r] = a * S + o * E + s * v + l * g, 
            n[A + r] = a * x + o * M + s * y + l * D;
        }, Utils3D.arcTanAngle = function(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }, Utils3D.angleTo = function(e, t, n) {
            Te.subtract(t, e, he.TEMPVector30), Te.normalize(he.TEMPVector30, he.TEMPVector30), 
            n.x = Math.asin(he.TEMPVector30.y), n.y = Utils3D.arcTanAngle(-he.TEMPVector30.z, -he.TEMPVector30.x);
        }, Utils3D.transformQuat = function(e, t, n) {
            var i = t, r = e.x, a = e.y, o = e.z, s = i[0], l = i[1], h = i[2], u = i[3], c = u * r + l * o - h * a, d = u * a + h * r - s * o, _ = u * o + s * a - l * r, f = -s * r - l * a - h * o;
            n.x = c * u + f * -s + d * -h - _ * -l, n.y = d * u + f * -l + _ * -s - c * -h, 
            n.z = _ * u + f * -h + c * -l - d * -s;
        }, Utils3D.quaternionWeight = function(e, t, n) {
            n.x = e.x * t, n.y = e.y * t, n.z = e.z * t, n.w = e.w;
        }, Utils3D.quaternionConjugate = function(e, t) {
            t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
        }, Utils3D.scaleWeight = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z;
            n.x = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), n.y = r > 0 ? Math.pow(Math.abs(r), t) : -Math.pow(Math.abs(r), t), 
            n.z = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t);
        }, Utils3D.scaleBlend = function(e, t, n, i) {
            var r = Utils3D._tempVector3_0, a = Utils3D._tempVector3_1;
            Utils3D.scaleWeight(e, 1 - n, r), Utils3D.scaleWeight(t, n, a);
            var o = n > .5 ? t : e;
            i.x = o.x > 0 ? Math.abs(r.x * a.x) : -Math.abs(r.x * a.x), i.y = o.y > 0 ? Math.abs(r.y * a.y) : -Math.abs(r.y * a.y), 
            i.z = o.z > 0 ? Math.abs(r.z * a.z) : -Math.abs(r.z * a.z);
        }, Utils3D.gammaToLinearSpace = function(e) {
            return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
        }, Utils3D.linearToGammaSpace = function(e) {
            return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
        }, Utils3D.matrix4x4MultiplyFFF = function(e, t, n) {
            var i, r, a, o, s;
            if (n === t) for (t = new Float32Array(16), i = 0; i < 16; ++i) t[i] = n[i];
            var l = t[0], h = t[1], u = t[2], c = t[3], d = t[4], _ = t[5], f = t[6], m = t[7], p = t[8], T = t[9], S = t[10], E = t[11], v = t[12], g = t[13], x = t[14], M = t[15];
            for (i = 0; i < 4; i++) r = e[i], a = e[i + 4], o = e[i + 8], s = e[i + 12], n[i] = r * l + a * h + o * u + s * c, 
            n[i + 4] = r * d + a * _ + o * f + s * m, n[i + 8] = r * p + a * T + o * S + s * E, 
            n[i + 12] = r * v + a * g + o * x + s * M;
        }, Utils3D.matrix4x4MultiplyFFFForNative = function(e, t, n) {
            E.instance.matrix4x4Multiply(e, t, n);
        }, Utils3D.matrix4x4MultiplyMFM = function(e, t, n) {
            Utils3D.matrix4x4MultiplyFFF(e.elements, t, n.elements);
        }, Utils3D._buildTexture2D = function(e, t, n, i, r) {
            void 0 === r && (r = !1);
            var a = new B(e, t, n, r, !0);
            return a.anisoLevel = 1, a.filterMode = 0, Pe._generateTexture2D(a, e, t, i), a;
        }, Utils3D._drawBound = function(e, t, n) {
            e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
            var i = Utils3D._tempVector3_0, r = Utils3D._tempVector3_1, a = t.min, o = t.max;
            i.setValue(a.x, a.y, a.z), r.setValue(o.x, a.y, a.z), e.addLine(i, r, n, n), i.setValue(a.x, a.y, a.z), 
            r.setValue(a.x, a.y, o.z), e.addLine(i, r, n, n), i.setValue(o.x, a.y, a.z), r.setValue(o.x, a.y, o.z), 
            e.addLine(i, r, n, n), i.setValue(a.x, a.y, o.z), r.setValue(o.x, a.y, o.z), e.addLine(i, r, n, n), 
            i.setValue(a.x, a.y, a.z), r.setValue(a.x, o.y, a.z), e.addLine(i, r, n, n), i.setValue(a.x, a.y, o.z), 
            r.setValue(a.x, o.y, o.z), e.addLine(i, r, n, n), i.setValue(o.x, a.y, a.z), r.setValue(o.x, o.y, a.z), 
            e.addLine(i, r, n, n), i.setValue(o.x, a.y, o.z), r.setValue(o.x, o.y, o.z), e.addLine(i, r, n, n), 
            i.setValue(a.x, o.y, a.z), r.setValue(o.x, o.y, a.z), e.addLine(i, r, n, n), i.setValue(a.x, o.y, a.z), 
            r.setValue(a.x, o.y, o.z), e.addLine(i, r, n, n), i.setValue(o.x, o.y, a.z), r.setValue(o.x, o.y, o.z), 
            e.addLine(i, r, n, n), i.setValue(a.x, o.y, o.z), r.setValue(o.x, o.y, o.z), e.addLine(i, r, n, n);
        }, Utils3D._getHierarchyPath = function(e, t, n) {
            n.length = 0;
            for (var i = t; i !== e; ) {
                var r = i._parent;
                if (!r) return null;
                n.push(r.getChildIndex(i)), i = r;
            }
            return n;
        }, Utils3D._getNodeByHierarchyPath = function(e, t) {
            for (var n = e, i = t.length - 1; i >= 0; i--) n = n.getChildAt(t[i]);
            return n;
        }, Utils3D._createNodeByJson = function(e, t) {
            var n;
            switch (e.type) {
              case "Scene3D":
                n = new qn();
                break;

              case "Sprite3D":
                n = new bn();
                break;

              case "MeshSprite3D":
                n = new Si(), t && t.push(n);
                break;

              case "SkinnedMeshSprite3D":
                n = new yi();
                break;

              case "ShuriKenParticle3D":
                n = new xi();
                break;

              case "Terrain":
                n = new ti();
                break;

              case "Camera":
                n = new Ci();
                break;

              case "DirectionLight":
                n = new vi();
                break;

              case "PointLight":
                n = new Di();
                break;

              case "SpotLight":
                n = new Ei();
                break;

              case "TrailSprite3D":
                n = new gi();
                break;

              default:
                throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var i = e.child;
            if (i) for (var r = 0, a = i.length; r < a; r++) {
                var o = Utils3D._createNodeByJson(i[r], t);
                n.addChild(o);
            }
            var s = e.components;
            if (s) for (var h = 0, u = s.length; h < u; h++) {
                var c = s[h];
                if (!(_ = l.window.Laya[c.type])) {
                    var d = c.type.split("."), _ = l.window;
                    d.forEach(function(e) {
                        _ = _[e];
                    });
                }
                if ("function" == typeof _) n.addComponent(_)._parse(c); else console.warn("Unkown component type.");
            }
            return n._parse(e.props, null), n;
        }, Utils3D._tempArray16_0 = new Float32Array(16), Utils3D._tempArray16_1 = new Float32Array(16), 
        Utils3D._tempArray16_2 = new Float32Array(16), Utils3D._tempArray16_3 = new Float32Array(16), 
        i(Utils3D, [ "_tempVector3_0", function() {
            return this._tempVector3_0 = new Te();
        }, "_tempVector3_1", function() {
            return this._tempVector3_1 = new Te();
        }, "_tempVector3_2", function() {
            return this._tempVector3_2 = new Te();
        }, "_tempColor0", function() {
            return this._tempColor0 = new Me();
        }, "_compIdToNode", function() {
            return this._compIdToNode = new Object();
        } ]), Utils3D;
    }(), We = function() {
        function GradientDataNumber() {
            this._currentLength = 0, this._elements = null, this._elements = new Float32Array(8);
        }
        r(GradientDataNumber, "laya.d3.core.particleShuriKen.module.GradientDataNumber");
        var e = GradientDataNumber.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.add = function(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
        }, e.getKeyByIndex = function(e) {
            return this._elements[2 * e];
        }, e.getValueByIndex = function(e) {
            return this._elements[2 * e + 1];
        }, e.getAverageValue = function() {
            for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                this._elements[e + 1];
                this._elements[e + 3], this._elements[e + 2] - this._elements[e];
            }
            return 0;
        }, e.cloneTo = function(e) {
            var t = e;
            t._currentLength = this._currentLength;
            var n = t._elements;
            n.length = this._elements.length;
            for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientCount", function() {
            return this._currentLength / 2;
        }), GradientDataNumber;
    }(), Xe = function() {
        function PixelLineVertex() {}
        r(PixelLineVertex, "laya.d3.core.pixelLine.PixelLineVertex");
        var e = PixelLineVertex.prototype;
        return a(0, e, "vertexDeclaration", function() {
            return PixelLineVertex._vertexDeclaration;
        }), a(1, PixelLineVertex, "vertexDeclaration", function() {
            return PixelLineVertex._vertexDeclaration;
        }), i(PixelLineVertex, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(28, [ new ze(0, "vector3", 0), new ze(12, "vector4", 1) ]);
        } ]), PixelLineVertex;
    }(), Ye = function() {
        function CollisionTool() {
            this._hitResultsPoolIndex = 0, this._contactPonintsPoolIndex = 0, this._collisions = {}, 
            this._hitResultsPool = [], this._contactPointsPool = [], this._collisionsPool = [];
        }
        r(CollisionTool, "laya.d3.physics.CollisionTool");
        var e = CollisionTool.prototype;
        return e.getHitResult = function() {
            var e = this._hitResultsPool[this._hitResultsPoolIndex++];
            return e || (e = new Tt(), this._hitResultsPool.push(e)), e;
        }, e.recoverAllHitResultsPool = function() {
            this._hitResultsPoolIndex = 0;
        }, e.getContactPoints = function() {
            var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
            return e || (e = new Q(), this._contactPointsPool.push(e)), e;
        }, e.recoverAllContactPointsPool = function() {
            this._contactPonintsPoolIndex = 0;
        }, e.getCollision = function(e, t) {
            var n, i = e.id, r = t.id, a = this._collisions[i];
            return a && (n = a[r]), n || (a || (a = {}, this._collisions[i] = a), (n = 0 === this._collisionsPool.length ? new _t() : this._collisionsPool.pop())._colliderA = e, 
            n._colliderB = t, a[r] = n), n;
        }, e.recoverCollision = function(e) {
            var t = e._colliderA.id, n = e._colliderB.id;
            this._collisions[t][n] = null, this._collisionsPool.push(e);
        }, e.garbageCollection = function() {
            for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0, 
            this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                var t = this._collisionsPool[e], n = !0;
                for (var i in t) t[i] ? n = !1 : delete t[i];
                n && delete this._collisionsPool[e];
            }
        }, CollisionTool;
    }(), Ze = function() {
        function Input3D() {
            this._scene = null, this._eventList = [], this._multiTouchEnabled = !0, this._mouseTouch = new rt(), 
            this._touchPool = [], this._touches = new un();
        }
        r(Input3D, "laya.d3.Input3D");
        var e = Input3D.prototype;
        return e.__init__ = function(e, t) {
            this._scene = t;
            var n = this._eventList;
            e.oncontextmenu = function(e) {
                return !1;
            }, e.addEventListener("mousedown", function(e) {
                e.preventDefault(), n.push(e);
            }), e.addEventListener("mouseup", function(e) {
                e.preventDefault(), n.push(e);
            }, !0), e.addEventListener("mousemove", function(e) {
                e.preventDefault(), n.push(e);
            }, !0), e.addEventListener("touchstart", function(e) {
                e.preventDefault(), n.push(e);
            }), e.addEventListener("touchend", function(e) {
                e.preventDefault(), n.push(e);
            }, !0), e.addEventListener("touchmove", function(e) {
                e.preventDefault(), n.push(e);
            }, !0), e.addEventListener("touchcancel", function(e) {
                n.push(e);
            }, !0);
        }, e.touchCount = function() {
            return this._touches.length;
        }, e._getTouch = function(e) {
            var t = this._touchPool[e];
            return t || (t = new dt(), this._touchPool[e] = t, t._identifier = e), t;
        }, e._mouseTouchDown = function() {
            var e = this._mouseTouch, t = e.sprite;
            if (e._pressedSprite = t, e._pressedLoopCount = P.loopCount, t) {
                var n = t._scripts;
                if (n) for (var i = 0, r = n.length; i < r; i++) n[i].onMouseDown();
            }
        }, e._mouseTouchUp = function() {
            var e = 0, t = 0, n = this._mouseTouch, i = n._pressedSprite;
            n._pressedSprite = null, n._pressedLoopCount = -1;
            var r = n.sprite;
            if (r && r === i) {
                var a = r._scripts;
                if (a) for (e = 0, t = a.length; e < t; e++) a[e].onMouseClick();
            }
            if (i) {
                var o = i._scripts;
                if (o) for (e = 0, t = o.length; e < t; e++) o[e].onMouseUp();
            }
        }, e._mouseTouchRayCast = function(e) {
            var t = Input3D._tempHitResult0, n = Input3D._tempVector20, i = Input3D._tempRay0;
            t.succeeded = !1;
            var r = this._mouseTouch.mousePositionX, a = this._mouseTouch.mousePositionY;
            n.x = r, n.y = a;
            for (var o = e.length - 1; o >= 0; o--) {
                var s = e[o], l = s.viewport;
                if (n.x >= l.x && n.y >= l.y && n.x <= l.width && n.y <= l.height) if (s.viewportPointToRay(n, i), 
                this._scene._physicsSimulation.rayCast(i, t) || 0 === s.clearFlag || 1 === s.clearFlag) break;
            }
            var h = this._mouseTouch, u = h.sprite;
            if (t.succeeded) {
                var c = t.collider.owner;
                h.sprite = c;
                var d = c._scripts;
                if (u !== c && d) for (var _ = 0, f = d.length; _ < f; _++) d[_].onMouseEnter();
            } else h.sprite = null;
            if (u && u !== c) {
                var m = u._scripts;
                if (m) for (_ = 0, f = m.length; _ < f; _++) m[_].onMouseOut();
            }
        }, e._changeTouches = function(e, t) {
            for (var i = 0, r = 0, a = this._touches.length, o = 0, s = e.length; o < s; o++) {
                var l = e[o], h = l.identifier;
                if (this._multiTouchEnabled || 0 === h) {
                    var u = this._getTouch(h), c = u._position, d = Input3D._tempPoint;
                    d.setTo(l.pageX, l.pageY), n.stage._canvasTransform.invertTransformPoint(d);
                    var _ = d.x, f = d.y;
                    switch (t) {
                      case 0:
                        this._touches.add(u), i += _, r += f;
                        break;

                      case 1:
                        this._touches.remove(u), i -= _, r -= f;
                        break;

                      case 2:
                        i = _ - c.x, r = f - c.y;
                    }
                    c.x = _, c.y = f;
                }
            }
            var m = this._touches.length;
            0 === m ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * a + i) / m, 
            this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * a + r) / m);
        }, e._update = function() {
            var e, t = 0, i = 0, r = 0;
            e = this._eventList.length;
            var a = this._scene._cameraPool;
            if (e > 0) {
                for (t = 0; t < e; t++) {
                    var o = this._eventList[t];
                    switch (o.type) {
                      case "mousedown":
                        this._mouseTouchDown();
                        break;

                      case "mouseup":
                        this._mouseTouchUp();
                        break;

                      case "mousemove":
                        var s = Input3D._tempPoint;
                        s.setTo(o.pageX, o.pageY), n.stage._canvasTransform.invertTransformPoint(s), this._mouseTouch.mousePositionX = s.x, 
                        this._mouseTouch.mousePositionY = s.y, this._mouseTouchRayCast(a);
                        break;

                      case "touchstart":
                        var l = this._touches.length;
                        this._changeTouches(o.changedTouches, 0), this._mouseTouchRayCast(a), 0 === l && this._mouseTouchDown();
                        break;

                      case "touchend":
                      case "touchcancel":
                        this._changeTouches(o.changedTouches, 1), 0 === this._touches.length && this._mouseTouchUp();
                        break;

                      case "touchmove":
                        this._changeTouches(o.changedTouches, 2), this._mouseTouchRayCast(a);
                        break;

                      default:
                        throw "Input3D:unkonwn event type.";
                    }
                }
                this._eventList.length = 0;
            }
            var h = this._mouseTouch, u = h._pressedSprite;
            if (u && P.loopCount > h._pressedLoopCount) {
                var c = u._scripts;
                if (c) for (i = 0, r = c.length; i < r; i++) c[i].onMouseDrag();
            }
            var d = h.sprite;
            if (d) {
                var _ = d._scripts;
                if (_) for (i = 0, r = _.length; i < r; i++) _[i].onMouseOver();
            }
        }, e.getTouch = function(e) {
            return e < this._touches.length ? this._touches.elements[e] : null;
        }, a(0, e, "multiTouchEnabled", function() {
            return this._multiTouchEnabled;
        }, function(e) {
            this._multiTouchEnabled = e;
        }), i(Input3D, [ "_tempPoint", function() {
            return this._tempPoint = new D();
        }, "_tempVector20", function() {
            return this._tempVector20 = new Se();
        }, "_tempRay0", function() {
            return this._tempRay0 = new K(new Te(), new Te());
        }, "_tempHitResult0", function() {
            return this._tempHitResult0 = new Tt();
        } ]), Input3D;
    }(), Ke = function() {
        function ShurikenParticleData() {}
        return r(ShurikenParticleData, "laya.d3.core.particleShuriKen.ShurikenParticleData"), 
        ShurikenParticleData._getStartLifetimeFromGradient = function(e, t) {
            for (var n = 1, i = e.gradientCount; n < i; n++) {
                var r = e.getKeyByIndex(n);
                if (r >= t) {
                    var a = e.getKeyByIndex(n - 1), o = (t - a) / (r - a);
                    return M.lerp(e.getValueByIndex(n - 1), e.getValueByIndex(n), o);
                }
            }
            throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
        }, ShurikenParticleData._randomInvertRoationArray = function(e, t, n, i, r) {
            var a = NaN;
            i ? (i.seed = r[6], a = i.getFloat(), r[6] = i.seed) : a = Math.random(), a < n ? (t.x = -e.x, 
            t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
        }, ShurikenParticleData._randomInvertRoation = function(e, t, n, i) {
            var r = NaN;
            return n ? (n.seed = i[6], r = n.getFloat(), i[6] = n.seed) : r = Math.random(), 
            r < t && (e = -e), e;
        }, ShurikenParticleData.create = function(e, t, n) {
            var i = e.autoRandomSeed, r = e._rand, a = e._randomSeeds;
            switch (e.startColorType) {
              case 0:
                var o = e.startColorConstant;
                ShurikenParticleData.startColor.x = o.x, ShurikenParticleData.startColor.y = o.y, 
                ShurikenParticleData.startColor.z = o.z, ShurikenParticleData.startColor.w = o.w;
                break;

              case 2:
                i ? me.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), ShurikenParticleData.startColor) : (r.seed = a[3], 
                me.lerp(e.startColorConstantMin, e.startColorConstantMax, r.getFloat(), ShurikenParticleData.startColor), 
                a[3] = r.seed);
            }
            var s = e.colorOverLifetime;
            if (s && s.enbale) {
                var l = s.color;
                switch (l.type) {
                  case 0:
                    ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * l.constant.x, 
                    ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * l.constant.y, 
                    ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * l.constant.z, 
                    ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * l.constant.w;
                    break;

                  case 2:
                    var h = NaN;
                    i ? h = Math.random() : (r.seed = a[10], h = r.getFloat(), a[10] = r.seed);
                    var u = l.constantMin, c = l.constantMax;
                    ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * M.lerp(u.x, c.x, h), 
                    ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * M.lerp(u.y, c.y, h), 
                    ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * M.lerp(u.z, c.z, h), 
                    ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * M.lerp(u.w, c.w, h);
                }
            }
            var d = ShurikenParticleData.startSize;
            switch (e.startSizeType) {
              case 0:
                if (e.threeDStartSize) {
                    var _ = e.startSizeConstantSeparate;
                    d[0] = _.x, d[1] = _.y, d[2] = _.z;
                } else d[0] = d[1] = d[2] = e.startSizeConstant;
                break;

              case 2:
                if (e.threeDStartSize) {
                    var f = e.startSizeConstantMinSeparate, m = e.startSizeConstantMaxSeparate;
                    i ? (d[0] = M.lerp(f.x, m.x, Math.random()), d[1] = M.lerp(f.y, m.y, Math.random()), 
                    d[2] = M.lerp(f.z, m.z, Math.random())) : (r.seed = a[4], d[0] = M.lerp(f.x, m.x, r.getFloat()), 
                    d[1] = M.lerp(f.y, m.y, r.getFloat()), d[2] = M.lerp(f.z, m.z, r.getFloat()), a[4] = r.seed);
                } else i ? d[0] = d[1] = d[2] = M.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (r.seed = a[4], 
                d[0] = d[1] = d[2] = M.lerp(e.startSizeConstantMin, e.startSizeConstantMax, r.getFloat()), 
                a[4] = r.seed);
            }
            var p = e.sizeOverLifetime;
            if (p && p.enbale && 1 === p.size.type) {
                var T = p.size;
                if (T.separateAxes) i ? (d[0] = d[0] * M.lerp(T.constantMinSeparate.x, T.constantMaxSeparate.x, Math.random()), 
                d[1] = d[1] * M.lerp(T.constantMinSeparate.y, T.constantMaxSeparate.y, Math.random()), 
                d[2] = d[2] * M.lerp(T.constantMinSeparate.z, T.constantMaxSeparate.z, Math.random())) : (r.seed = a[11], 
                d[0] = d[0] * M.lerp(T.constantMinSeparate.x, T.constantMaxSeparate.x, r.getFloat()), 
                d[1] = d[1] * M.lerp(T.constantMinSeparate.y, T.constantMaxSeparate.y, r.getFloat()), 
                d[2] = d[2] * M.lerp(T.constantMinSeparate.z, T.constantMaxSeparate.z, r.getFloat()), 
                a[11] = r.seed); else {
                    var S = NaN;
                    i ? S = M.lerp(T.constantMin, T.constantMax, Math.random()) : (r.seed = a[11], S = M.lerp(T.constantMin, T.constantMax, r.getFloat()), 
                    a[11] = r.seed), d[0] = d[0] * S, d[1] = d[1] * S, d[2] = d[2] * S;
                }
            }
            var E = t.renderMode;
            if (1 !== E) switch (e.startRotationType) {
              case 0:
                if (e.threeDStartRotation) {
                    var v = e.startRotationConstantSeparate, g = ShurikenParticleData._tempVector30;
                    ShurikenParticleData._randomInvertRoationArray(v, g, e.randomizeRotationDirection, i ? null : r, a), 
                    ShurikenParticleData.startRotation[0] = g.x, ShurikenParticleData.startRotation[1] = g.y, 
                    ShurikenParticleData.startRotation[2] = 4 !== E ? -g.z : g.z;
                } else ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, i ? null : r, a), 
                ShurikenParticleData.startRotation[1] = 0, ShurikenParticleData.startRotation[2] = 0;
                break;

              case 2:
                if (e.threeDStartRotation) {
                    var x = e.startRotationConstantMinSeparate, y = e.startRotationConstantMaxSeparate, D = ShurikenParticleData._tempVector30;
                    i ? (D.x = M.lerp(x.x, y.x, Math.random()), D.y = M.lerp(x.y, y.y, Math.random()), 
                    D.z = M.lerp(x.z, y.z, Math.random())) : (r.seed = a[5], D.x = M.lerp(x.x, y.x, r.getFloat()), 
                    D.y = M.lerp(x.y, y.y, r.getFloat()), D.z = M.lerp(x.z, y.z, r.getFloat()), a[5] = r.seed), 
                    ShurikenParticleData._randomInvertRoationArray(D, D, e.randomizeRotationDirection, i ? null : r, a), 
                    ShurikenParticleData.startRotation[0] = D.x, ShurikenParticleData.startRotation[1] = D.y, 
                    ShurikenParticleData.startRotation[2] = 4 !== E ? -D.z : D.z;
                } else i ? ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(M.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, i ? null : r, a) : (r.seed = a[5], 
                ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(M.lerp(e.startRotationConstantMin, e.startRotationConstantMax, r.getFloat()), e.randomizeRotationDirection, i ? null : r, a), 
                a[5] = r.seed);
            }
            switch (e.startLifetimeType) {
              case 0:
                ShurikenParticleData.startLifeTime = e.startLifetimeConstant;
                break;

              case 1:
                ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                break;

              case 2:
                i ? ShurikenParticleData.startLifeTime = M.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (r.seed = a[7], 
                ShurikenParticleData.startLifeTime = M.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, r.getFloat()), 
                a[7] = r.seed);
                break;

              case 3:
                var R = e.emissionTime;
                i ? ShurikenParticleData.startLifeTime = M.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, R), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, R), Math.random()) : (r.seed = a[7], 
                ShurikenParticleData.startLifeTime = M.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, R), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, R), r.getFloat()), 
                a[7] = r.seed);
            }
            switch (e.startSpeedType) {
              case 0:
                ShurikenParticleData.startSpeed = e.startSpeedConstant;
                break;

              case 2:
                i ? ShurikenParticleData.startSpeed = M.lerp(e.startSpeedConstantMin, e.startSpeedConstantMax, Math.random()) : (r.seed = a[8], 
                ShurikenParticleData.startSpeed = M.lerp(e.startSpeedConstantMin, e.startSpeedConstantMax, r.getFloat()), 
                a[8] = r.seed);
            }
            var C = e.textureSheetAnimation;
            if (C && C.enable) {
                var I = C.tiles, A = I.x, L = I.y, O = 1 / A, P = 1 / L, V = 0, N = C.startFrame;
                switch (N.type) {
                  case 0:
                    V = N.constant;
                    break;

                  case 1:
                    i ? V = M.lerp(N.constantMin, N.constantMax, Math.random()) : (r.seed = a[14], V = M.lerp(N.constantMin, N.constantMax, r.getFloat()), 
                    a[14] = r.seed);
                }
                var B = C.frame;
                switch (B.type) {
                  case 0:
                    V += B.constant;
                    break;

                  case 2:
                    i ? V += M.lerp(B.constantMin, B.constantMax, Math.random()) : (r.seed = a[15], 
                    V += M.lerp(B.constantMin, B.constantMax, r.getFloat()), a[15] = r.seed);
                }
                var w = 0;
                switch (C.type) {
                  case 0:
                    w = Math.floor(V / A);
                    break;

                  case 1:
                    C.randomRow ? i ? w = Math.floor(Math.random() * L) : (r.seed = a[13], w = Math.floor(r.getFloat() * L), 
                    a[13] = r.seed) : w = C.rowIndex;
                }
                var b = Math.floor(V % A);
                ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = O, 
                ShurikenParticleData.startUVInfo[1] = P, ShurikenParticleData.startUVInfo[2] = b * O, 
                ShurikenParticleData.startUVInfo[3] = w * P;
            } else ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = 1, 
            ShurikenParticleData.startUVInfo[1] = 1, ShurikenParticleData.startUVInfo[2] = 0, 
            ShurikenParticleData.startUVInfo[3] = 0;
            switch (e.simulationSpace) {
              case 0:
                var F = n.position;
                ShurikenParticleData.simulationWorldPostion[0] = F.x, ShurikenParticleData.simulationWorldPostion[1] = F.y, 
                ShurikenParticleData.simulationWorldPostion[2] = F.z;
                var U = n.rotation;
                ShurikenParticleData.simulationWorldRotation[0] = U.x, ShurikenParticleData.simulationWorldRotation[1] = U.y, 
                ShurikenParticleData.simulationWorldRotation[2] = U.z, ShurikenParticleData.simulationWorldRotation[3] = U.w;
                break;

              case 1:
                break;

              default:
                throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
        }, ShurikenParticleData.startLifeTime = NaN, ShurikenParticleData.startSpeed = NaN, 
        i(ShurikenParticleData, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempQuaternion", function() {
            return this._tempQuaternion = new he();
        }, "startColor", function() {
            return this.startColor = new me();
        }, "startSize", function() {
            return this.startSize = new Float32Array(3);
        }, "startRotation", function() {
            return this.startRotation = new Float32Array(3);
        }, "startUVInfo", function() {
            return this.startUVInfo = new Float32Array(4);
        }, "simulationWorldPostion", function() {
            return this.simulationWorldPostion = new Float32Array(3);
        }, "simulationWorldRotation", function() {
            return this.simulationWorldRotation = new Float32Array(4);
        } ]), ShurikenParticleData;
    }(), Qe = function() {
        function BoundsOctreeNode(e, t, n, i) {
            this._octree = null, this._parent = null, this._children = null, this._isContaion = !1, 
            this.baseLength = 0, this._bounds = new zt(new Te(), new Te()), this._objects = [], 
            this.center = new Te(), this._setValues(e, t, n, i);
        }
        r(BoundsOctreeNode, "laya.d3.core.scene.BoundsOctreeNode");
        var e = BoundsOctreeNode.prototype;
        return e._setValues = function(e, t, n, i) {
            this._octree = e, this._parent = t, this.baseLength = n, i.cloneTo(this.center);
            var r = this._bounds.min, a = this._bounds.max, o = e._looseness * n / 2;
            r.setValue(i.x - o, i.y - o, i.z - o), a.setValue(i.x + o, i.y + o, i.z + o);
        }, e._getChildBound = function(e) {
            if (null != this._children && this._children[e]) return this._children[e]._bounds;
            var t = this.baseLength / 4, n = this.baseLength / 2 * this._octree._looseness / 2, i = BoundsOctreeNode._tempBoundBox, r = i.min, a = i.max;
            switch (e) {
              case 0:
                r.x = this.center.x - t - n, r.y = this.center.y + t - n, r.z = this.center.z - t - n, 
                a.x = this.center.x - t + n, a.y = this.center.y + t + n, a.z = this.center.z - t + n;
                break;

              case 1:
                r.x = this.center.x + t - n, r.y = this.center.y + t - n, r.z = this.center.z - t - n, 
                a.x = this.center.x + t + n, a.y = this.center.y + t + n, a.z = this.center.z - t + n;
                break;

              case 2:
                r.x = this.center.x - t - n, r.y = this.center.y + t - n, r.z = this.center.z + t - n, 
                a.x = this.center.x - t + n, a.y = this.center.y + t + n, a.z = this.center.z + t + n;
                break;

              case 3:
                r.x = this.center.x + t - n, r.y = this.center.y + t - n, r.z = this.center.z + t - n, 
                a.x = this.center.x + t + n, a.y = this.center.y + t + n, a.z = this.center.z + t + n;
                break;

              case 4:
                r.x = this.center.x - t - n, r.y = this.center.y - t - n, r.z = this.center.z - t - n, 
                a.x = this.center.x - t + n, a.y = this.center.y - t + n, a.z = this.center.z - t + n;
                break;

              case 5:
                r.x = this.center.x + t - n, r.y = this.center.y - t - n, r.z = this.center.z - t - n, 
                a.x = this.center.x + t + n, a.y = this.center.y - t + n, a.z = this.center.z - t + n;
                break;

              case 6:
                r.x = this.center.x - t - n, r.y = this.center.y - t - n, r.z = this.center.z + t - n, 
                a.x = this.center.x - t + n, a.y = this.center.y - t + n, a.z = this.center.z + t + n;
                break;

              case 7:
                r.x = this.center.x + t - n, r.y = this.center.y - t - n, r.z = this.center.z + t - n, 
                a.x = this.center.x + t + n, a.y = this.center.y - t + n, a.z = this.center.z + t + n;
            }
            return i;
        }, e._getChildCenter = function(e) {
            if (null != this._children) return this._children[e].center;
            var t = this.baseLength / 4, n = BoundsOctreeNode._tempVector30;
            switch (e) {
              case 0:
                n.x = this.center.x - t, n.y = this.center.y + t, n.z = this.center.z - t;
                break;

              case 1:
                n.x = this.center.x + t, n.y = this.center.y + t, n.z = this.center.z - t;
                break;

              case 2:
                n.x = this.center.x - t, n.y = this.center.y + t, n.z = this.center.z + t;
                break;

              case 3:
                n.x = this.center.x + t, n.y = this.center.y + t, n.z = this.center.z + t;
                break;

              case 4:
                n.x = this.center.x - t, n.y = this.center.y - t, n.z = this.center.z - t;
                break;

              case 5:
                n.x = this.center.x + t, n.y = this.center.y - t, n.z = this.center.z - t;
                break;

              case 6:
                n.x = this.center.x - t, n.y = this.center.y - t, n.z = this.center.z + t;
                break;

              case 7:
                n.x = this.center.x + t, n.y = this.center.y - t, n.z = this.center.z + t;
            }
            return n;
        }, e._getChild = function(e) {
            var t = this.baseLength / 4;
            switch (this._children || (this._children = o(8, null)), e) {
              case 0:
                return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x + -t, this.center.y + t, this.center.z - t)));

              case 1:
                return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x + t, this.center.y + t, this.center.z - t)));

              case 2:
                return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x - t, this.center.y + t, this.center.z + t)));

              case 3:
                return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x + t, this.center.y + t, this.center.z + t)));

              case 4:
                return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x - t, this.center.y - t, this.center.z - t)));

              case 5:
                return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x + t, this.center.y - t, this.center.z - t)));

              case 6:
                return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x - t, this.center.y - t, this.center.z + t)));

              case 7:
                return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new Te(this.center.x + t, this.center.y - t, this.center.z + t)));

              default:
                throw "BoundsOctreeNode: unknown index.";
            }
        }, e._shouldMerge = function() {
            for (var e = this._objects.length, t = 0; t < 8; t++) {
                var n = this._children[t];
                if (n) {
                    if (null != n._children) return !1;
                    e += n._objects.length;
                }
            }
            return e <= 8;
        }, e._mergeChildren = function() {
            for (var e = 0; e < 8; e++) {
                var t = this._children[e];
                if (t) {
                    t._parent = null;
                    for (var n = t._objects, i = n.length - 1; i >= 0; i--) {
                        var r = n[i];
                        this._objects.push(r), r._setOctreeNode(this);
                    }
                }
            }
            this._children = null;
        }, e._merge = function() {
            if (null === this._children) {
                var e = this._parent;
                e && e._shouldMerge() && (e._mergeChildren(), e._merge());
            }
        }, e._checkAddNode = function(e) {
            if (null == this._children) {
                if (this._objects.length < 8 || this.baseLength / 2 < this._octree._minSize) return this;
                for (var t = this._objects.length - 1; t >= 0; t--) {
                    var n = this._objects[t], i = this._bestFitChild(n.bounds.getCenter());
                    BoundsOctreeNode._encapsulates(this._getChildBound(i), n.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(n), 1), 
                    this._getChild(i)._add(n));
                }
            }
            var r = this._bestFitChild(e.bounds.getCenter());
            return BoundsOctreeNode._encapsulates(this._getChildBound(r), e.bounds._getBoundBox()) ? this._getChild(r)._checkAddNode(e) : this;
        }, e._add = function(e) {
            var t = this._checkAddNode(e);
            t._objects.push(e), e._setOctreeNode(t);
        }, e._remove = function(e) {
            var t = this._objects.indexOf(e);
            this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
        }, e._addUp = function(e) {
            return 1 === bt.boxContainsBox(this._bounds, e.bounds._getBoundBox()) ? (this._add(e), 
            !0) : !!this._parent && this._parent._addUp(e);
        }, e._getCollidingWithFrustum = function(e, t, n, i) {
            if (n) {
                var r = t.containsBoundBox(this._bounds);
                if (P.octreeNodeCulling++, 0 === r) return;
                n = 2 === r;
            }
            this._isContaion = !n;
            for (var a = e.camera, o = e.scene, s = 0, l = this._objects.length; s < l; s++) {
                var h = this._objects[s];
                if (a._isLayerVisible(h._owner.layer) && h._enable) {
                    if (n && (P.frustumCulling++, !h._needRender(t))) continue;
                    h._distanceForSort = Te.distance(h.bounds.getCenter(), i);
                    for (var u = h._renderElements, c = 0, d = u.length; c < d; c++) {
                        var _ = u[c], f = o._getRenderQueue(_.material.renderQueue);
                        f.isTransparent ? _.addToTransparentRenderQueue(e, f) : _.addToOpaqueRenderQueue(e, f);
                    }
                }
            }
            if (null != this._children) for (s = 0; s < 8; s++) {
                var m = this._children[s];
                m && m._getCollidingWithFrustum(e, t, n, i);
            }
        }, e._getCollidingWithBoundBox = function(e, t, n) {
            if (t) {
                var i = bt.boxContainsBox(this._bounds, e);
                if (0 === i) return;
                t = 2 === i;
            }
            if (t) for (var r = 0, a = this._objects.length; r < a; r++) {
                var o = this._objects[r];
                bt.intersectsBoxAndBox(o.bounds._getBoundBox(), e) && n.push(o);
            }
            if (null != this._children) for (r = 0; r < 8; r++) {
                this._children[r]._getCollidingWithBoundBox(e, t, n);
            }
        }, e._bestFitChild = function(e) {
            return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
        }, e._update = function(e) {
            if (1 === bt.boxContainsBox(this._bounds, e.bounds._getBoundBox())) {
                var t = this._checkAddNode(e);
                if (t !== e._getOctreeNode()) {
                    t._objects.push(e), e._setOctreeNode(t);
                    var n = this._objects.indexOf(e);
                    this._objects.splice(n, 1), this._merge();
                }
                return !0;
            }
            if (this._parent) {
                var i = this._parent._addUp(e);
                return i && (n = this._objects.indexOf(e), this._objects.splice(n, 1), this._merge()), 
                i;
            }
            return !1;
        }, e.add = function(e) {
            return !!BoundsOctreeNode._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), 
            !0);
        }, e.remove = function(e) {
            return e._getOctreeNode() === this && (this._remove(e), !0);
        }, e.update = function(e) {
            return e._getOctreeNode() === this && this._update(e);
        }, e.shrinkIfPossible = function(e) {
            if (this.baseLength < 2 * e) return this;
            for (var t = -1, n = 0, i = this._objects.length; n < i; n++) {
                var r = this._objects[n], a = this._bestFitChild(r.bounds.getCenter());
                if (0 != n && a != t) return this;
                var o = this._getChildBound(a);
                if (!BoundsOctreeNode._encapsulates(o, r.bounds._getBoundBox())) return this;
                0 == n && (t = a);
            }
            if (null == this._children) {
                if (-1 != t) {
                    var s = this._getChildCenter(t);
                    this._setValues(this._octree, null, this.baseLength / 2, s);
                }
                return this;
            }
            var l = !1;
            for (n = 0, i = this._children.length; n < i; n++) {
                var h = this._children[n];
                if (h && h.hasAnyObjects()) {
                    if (l) return this;
                    if (t >= 0 && t != n) return this;
                    l = !0, t = n;
                }
            }
            if (-1 != t) {
                var u = this._children[t];
                return u._parent = null, u;
            }
            return this;
        }, e.hasAnyObjects = function() {
            if (this._objects.length > 0) return !0;
            if (null != this._children) for (var e = 0; e < 8; e++) {
                var t = this._children[e];
                if (t && t.hasAnyObjects()) return !0;
            }
            return !1;
        }, e.getCollidingWithBoundBox = function(e, t) {
            this._getCollidingWithBoundBox(e, !0, t);
        }, e.getCollidingWithRay = function(e, t, n) {
            void 0 === n && (n = Number.MAX_VALUE);
            var i = bt.intersectsRayAndBoxRD(e, this._bounds);
            if (!(-1 == i || i > n)) {
                for (var r = 0, a = this._objects.length; r < a; r++) {
                    var o = this._objects[r];
                    -1 !== (i = bt.intersectsRayAndBoxRD(e, o.bounds._getBoundBox())) && i <= n && t.push(o);
                }
                if (null != this._children) for (r = 0; r < 8; r++) {
                    this._children[r].getCollidingWithRay(e, t, n);
                }
            }
        }, e.getCollidingWithFrustum = function(e) {
            var t = e.camera.transform.position, n = e.camera.boundFrustum;
            this._getCollidingWithFrustum(e, n, !0, t);
        }, e.isCollidingWithBoundBox = function(e) {
            if (!bt.intersectsBoxAndBox(this._bounds, e)) return !1;
            for (var t = 0, n = this._objects.length; t < n; t++) {
                var i = this._objects[t];
                if (bt.intersectsBoxAndBox(i.bounds._getBoundBox(), e)) return !0;
            }
            if (null != this._children) for (t = 0; t < 8; t++) {
                if (this._children[t].isCollidingWithBoundBox(e)) return !0;
            }
            return !1;
        }, e.isCollidingWithRay = function(e, t) {
            void 0 === t && (t = Number.MAX_VALUE);
            var n = bt.intersectsRayAndBoxRD(e, this._bounds);
            if (-1 == n || n > t) return !1;
            for (var i = 0, r = this._objects.length; i < r; i++) {
                var a = this._objects[i];
                if (-1 !== (n = bt.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) && n <= t) return !0;
            }
            if (null != this._children) for (i = 0; i < 8; i++) {
                if (this._children[i].isCollidingWithRay(e, t)) return !0;
            }
            return !1;
        }, e.getBound = function() {
            return this._bounds;
        }, e.drawAllBounds = function(e, t, n) {
            if (null !== this._children || 0 != this._objects.length) {
                t++;
                var i = BoundsOctreeNode._tempColor0;
                if (this._isContaion) i.r = 0, i.g = 0, i.b = 1; else {
                    var r = n ? t / n : 0;
                    i.r = 1 - r, i.g = r, i.b = 0;
                }
                if (i.a = .3, ke._drawBound(e, this._bounds, i), null != this._children) for (var a = 0; a < 8; a++) {
                    var o = this._children[a];
                    o && o.drawAllBounds(e, t, n);
                }
            }
        }, e.drawAllObjects = function(e, t, n) {
            t++;
            var i = BoundsOctreeNode._tempColor0;
            if (this._isContaion) i.r = 0, i.g = 0, i.b = 1; else {
                var r = n ? t / n : 0;
                i.r = 1 - r, i.g = r, i.b = 0;
            }
            i.a = 1;
            for (var a = 0, o = this._objects.length; a < o; a++) ke._drawBound(e, this._objects[a].bounds._getBoundBox(), i);
            if (null != this._children) for (a = 0; a < 8; a++) {
                var s = this._children[a];
                s && s.drawAllObjects(e, t, n);
            }
        }, BoundsOctreeNode._encapsulates = function(e, t) {
            return 1 == bt.boxContainsBox(e, t);
        }, BoundsOctreeNode._NUM_OBJECTS_ALLOWED = 8, i(BoundsOctreeNode, [ "_tempVector3", function() {
            return this._tempVector3 = new Te();
        }, "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempColor0", function() {
            return this._tempColor0 = new Me();
        }, "_tempBoundBox", function() {
            return this._tempBoundBox = new zt(new Te(), new Te());
        } ]), BoundsOctreeNode;
    }(), je = (function() {
        function GradientDataVector2() {
            this._currentLength = 0, this._elements = null, this._elements = new Float32Array(12);
        }
        r(GradientDataVector2, "laya.d3.core.particleShuriKen.module.GradientDataVector2");
        var e = GradientDataVector2.prototype;
        n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.add = function(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x, 
            this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
        }, e.cloneTo = function(e) {
            var t = e;
            t._currentLength = this._currentLength;
            var n = t._elements;
            n.length = this._elements.length;
            for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientCount", function() {
            return this._currentLength / 3;
        });
    }(), function() {
        function VertexPositionTerrain(e, t, n, i) {
            this._position = null, this._normal = null, this._textureCoord0 = null, this._textureCoord1 = null, 
            this._position = e, this._normal = t, this._textureCoord0 = n, this._textureCoord1 = i;
        }
        r(VertexPositionTerrain, "laya.d3.graphics.Vertex.VertexPositionTerrain");
        var e = VertexPositionTerrain.prototype;
        return n.imps(e, {
            "laya.d3.graphics.IVertex": !0
        }), a(0, e, "normal", function() {
            return this._normal;
        }), a(0, e, "position", function() {
            return this._position;
        }), a(0, e, "textureCoord0", function() {
            return this._textureCoord0;
        }), a(0, e, "textureCoord1", function() {
            return this._textureCoord1;
        }), a(0, e, "vertexDeclaration", function() {
            return VertexPositionTerrain._vertexDeclaration;
        }), a(1, VertexPositionTerrain, "vertexDeclaration", function() {
            return VertexPositionTerrain._vertexDeclaration;
        }), VertexPositionTerrain.TERRAIN_POSITION0 = 0, VertexPositionTerrain.TERRAIN_NORMAL0 = 1, 
        VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0 = 2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1 = 3, 
        i(VertexPositionTerrain, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(40, [ new ze(0, "vector3", 0), new ze(12, "vector3", 1), new ze(24, "vector2", 2), new ze(32, "vector2", 3) ]);
        } ]), VertexPositionTerrain;
    }()), qe = function() {
        function KeyframeNodeList() {
            this._nodes = [];
        }
        r(KeyframeNodeList, "laya.d3.animation.KeyframeNodeList");
        var e = KeyframeNodeList.prototype;
        return e.getNodeByIndex = function(e) {
            return this._nodes[e];
        }, e.setNodeByIndex = function(e, t) {
            this._nodes[e] = t;
        }, a(0, e, "count", function() {
            return this._nodes.length;
        }, function(e) {
            this._nodes.length = e;
        }), KeyframeNodeList;
    }(), Je = function() {
        function BoundsOctree(e, t, n, i) {
            this._initialSize = NaN, this._rootNode = null, this._looseness = NaN, this._minSize = NaN, 
            this.count = 0, this._motionObjects = new En(), n > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + n + " Adjusted to: " + e), 
            n = e), this._initialSize = e, this._minSize = n, this._looseness = Math.min(Math.max(i, 1), 2), 
            this._rootNode = new Qe(this, null, e, t);
        }
        r(BoundsOctree, "laya.d3.core.scene.BoundsOctree");
        var e = BoundsOctree.prototype;
        return e._getMaxDepth = function(e, t) {
            t++;
            var n = e._children;
            if (null != n) for (var i = t, r = 0, a = n.length; r < a; r++) {
                var o = n[r];
                o && (t = Math.max(this._getMaxDepth(o, i), t));
            }
            return t;
        }, e._grow = function(e) {
            var t = e.x >= 0 ? 1 : -1, n = e.y >= 0 ? 1 : -1, i = e.z >= 0 ? 1 : -1, r = this._rootNode, a = this._rootNode.baseLength / 2, s = 2 * this._rootNode.baseLength, l = this._rootNode.center, h = new Te(l.x + t * a, l.y + n * a, l.z + i * a);
            if (this._rootNode = new Qe(this, null, s, h), r.hasAnyObjects()) {
                for (var u = this._rootNode._bestFitChild(r.center), c = o(8, null), d = 0; d < 8; d++) d == u && (r._parent = this._rootNode, 
                c[d] = r);
                this._rootNode._children = c;
            }
        }, e.add = function(e) {
            for (var t = 0; !this._rootNode.add(e); ) {
                var n = BoundsOctree._tempVector30;
                if (Te.subtract(e.bounds.getCenter(), this._rootNode.center, n), this._grow(n), 
                ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
            }
            this.count++;
        }, e.remove = function(e) {
            var t = e._getOctreeNode().remove(e);
            return t && this.count--, t;
        }, e.update = function(e) {
            var t = 0, n = e._getOctreeNode();
            if (n) {
                for (;!n._update(e); ) if (this._grow(e.bounds.getCenter()), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                return !0;
            }
            return !1;
        }, e.shrinkRootIfPossible = function() {
            this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
        }, e.addMotionObject = function(e) {
            this._motionObjects.add(e);
        }, e.removeMotionObject = function(e) {
            this._motionObjects.remove(e);
        }, e.updateMotionObjects = function() {
            for (var e = this._motionObjects.elements, t = 0, n = this._motionObjects.length; t < n; t++) {
                var i = e[t];
                this.update(i), i._setIndexInMotionList(-1);
            }
            this._motionObjects.length = 0;
        }, e.isCollidingWithBoundBox = function(e) {
            return this._rootNode.isCollidingWithBoundBox(e);
        }, e.isCollidingWithRay = function(e, t) {
            return void 0 === t && (t = Number.MAX_VALUE), this._rootNode.isCollidingWithRay(e, t);
        }, e.getCollidingWithBoundBox = function(e, t) {
            this._rootNode.getCollidingWithBoundBox(e, t);
        }, e.getCollidingWithRay = function(e, t, n) {
            void 0 === n && (n = Number.MAX_VALUE), this._rootNode.getCollidingWithRay(e, t, n);
        }, e.getCollidingWithFrustum = function(e) {
            this._rootNode.getCollidingWithFrustum(e);
        }, e.getMaxBounds = function() {
            return this._rootNode.getBound();
        }, e.drawAllBounds = function(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllBounds(e, -1, t);
        }, e.drawAllObjects = function(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllObjects(e, -1, t);
        }, i(BoundsOctree, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        } ]), BoundsOctree;
    }(), $e = function() {
        function MeshFilter(e) {
            this._owner = null, this._sharedMesh = null, this._owner = e;
        }
        r(MeshFilter, "laya.d3.core.MeshFilter");
        var e = MeshFilter.prototype;
        return e._getMeshDefine = function(e) {
            for (var t = 0, n = 0, i = e._subMeshCount; n < i; n++) for (var r = e._getSubMesh(n)._vertexBuffer._vertexDeclaration.vertexElements, a = 0, o = r.length; a < o; a++) {
                switch (r[a].elementUsage) {
                  case 1:
                    t |= Si.SHADERDEFINE_COLOR;
                    break;

                  case 2:
                    t |= Si.SHADERDEFINE_UV0;
                    break;

                  case 7:
                    t |= Si.SHADERDEFINE_UV1;
                }
            }
            return t;
        }, e.destroy = function() {
            this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
        }, a(0, e, "sharedMesh", function() {
            return this._sharedMesh;
        }, function(e) {
            if (this._sharedMesh !== e) {
                var t = this._owner._render._defineDatas, n = this._sharedMesh;
                n && (n._removeReference(), t.remove(this._getMeshDefine(n))), e._addReference(), 
                this._sharedMesh = e, t.add(this._getMeshDefine(e)), this._owner._render._changeRenderObjectsByMesh(e);
            }
            this._owner._render._onMeshChange(e);
        }), MeshFilter;
    }(), et = function() {
        function TrailFilter(e) {
            this._minVertexDistance = NaN, this._widthMultiplier = NaN, this._time = NaN, this._widthCurve = null, 
            this._colorGradient = null, this._textureMode = 0, this._trialGeometry = null, this._totalLength = 0, 
            this._owner = null, this._curtime = 0, this._trailRenderElementIndex = 0, this._lastPosition = new Te(), 
            this.alignment = 0, this._owner = e, this._initDefaultData(), this.addRenderElement();
        }
        r(TrailFilter, "laya.d3.core.trail.TrailFilter");
        var e = TrailFilter.prototype;
        return e.addRenderElement = function() {
            var e = this._owner._render, t = e._renderElements, n = e.sharedMaterials[0];
            n || (n = ni.defaultMaterial);
            var i = new Ie();
            i.setTransform(this._owner._transform), i.render = e, i.material = n, this._trialGeometry = new _n(this), 
            i.setGeometry(this._trialGeometry), t.push(i);
        }, e._update = function(e) {
            var t = this._owner._render;
            this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(gi.CURTIME, this._curtime);
            var n = this._owner.transform.position, i = t._renderElements[0]._geometry;
            i._updateDisappear(), i._updateTrail(e.camera, this._lastPosition, n), i._updateVertexBufferUV(), 
            n.cloneTo(this._lastPosition);
        }, e._initDefaultData = function() {
            this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = 0;
            var e = [], t = new Tn();
            t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
            var n = new Tn();
            n.time = 1, n.inTangent = 0, n.outTangent = 0, n.value = 1, e.push(n), this.widthCurve = e;
            var i = new le(2, 2);
            i.mode = 0, i.addColorRGB(0, Me.WHITE), i.addColorRGB(1, Me.WHITE), i.addColorAlpha(0, 1), 
            i.addColorAlpha(1, 1), this.colorGradient = i;
        }, e.destroy = function() {
            this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null, 
            this._colorGradient = null;
        }, a(0, e, "widthMultiplier", function() {
            return this._widthMultiplier;
        }, function(e) {
            this._widthMultiplier = e;
        }), a(0, e, "time", function() {
            return this._time;
        }, function(e) {
            this._time = e, this._owner._render._shaderValues.setNumber(gi.LIFETIME, e);
        }), a(0, e, "widthCurve", function() {
            return this._widthCurve;
        }, function(e) {
            this._widthCurve = e;
            var t, n = new Float32Array(4 * e.length), i = 0, r = 0;
            for (i = 0, t = e.length; i < t; i++) n[r++] = e[i].time, n[r++] = e[i].inTangent, 
            n[r++] = e[i].outTangent, n[r++] = e[i].value;
            this._owner._render._shaderValues.setBuffer(gi.WIDTHCURVE, n), this._owner._render._shaderValues.setInt(gi.WIDTHCURVEKEYLENGTH, e.length);
        }), a(0, e, "minVertexDistance", function() {
            return this._minVertexDistance;
        }, function(e) {
            this._minVertexDistance = e;
        }), a(0, e, "colorGradient", function() {
            return this._colorGradient;
        }, function(e) {
            this._colorGradient = e, this._owner._render._shaderValues.setBuffer(gi.GRADIENTCOLORKEY, e._rgbElements), 
            this._owner._render._shaderValues.setBuffer(gi.GRADIENTALPHAKEY, e._alphaElements), 
            0 == e.mode ? this._owner._render._defineDatas.add(gi.SHADERDEFINE_GRADIENTMODE_BLEND) : this._owner._render._defineDatas.remove(gi.SHADERDEFINE_GRADIENTMODE_BLEND);
        }), a(0, e, "textureMode", function() {
            return this._textureMode;
        }, function(e) {
            this._textureMode = e;
        }), TrailFilter.ALIGNMENT_VIEW = 0, TrailFilter.ALIGNMENT_TRANSFORM_Z = 1, TrailFilter;
    }(), tt = function() {
        function VertexTrail() {}
        r(VertexTrail, "laya.d3.core.trail.VertexTrail");
        var e = VertexTrail.prototype;
        return n.imps(e, {
            "laya.d3.graphics.IVertex": !0
        }), a(0, e, "vertexDeclaration", function() {
            return VertexTrail._vertexDeclaration1;
        }), a(1, VertexTrail, "vertexDeclaration1", function() {
            return VertexTrail._vertexDeclaration1;
        }), a(1, VertexTrail, "vertexDeclaration2", function() {
            return VertexTrail._vertexDeclaration2;
        }), VertexTrail.TRAIL_POSITION0 = 0, VertexTrail.TRAIL_OFFSETVECTOR = 1, VertexTrail.TRAIL_TIME0 = 2, 
        VertexTrail.TRAIL_TEXTURECOORDINATE0Y = 3, VertexTrail.TRAIL_TEXTURECOORDINATE0X = 4, 
        i(VertexTrail, [ "_vertexDeclaration1", function() {
            return this._vertexDeclaration1 = new ft(32, [ new ze(0, "vector3", 0), new ze(12, "vector3", 1), new ze(24, "single", 2), new ze(28, "single", 3) ]);
        }, "_vertexDeclaration2", function() {
            return this._vertexDeclaration2 = new ft(4, [ new ze(0, "single", 4) ]);
        } ]), VertexTrail;
    }(), nt = function() {
        function Burst(e, t, n) {
            this._time = NaN, this._minCount = 0, this._maxCount = 0, this._time = e, this._minCount = t, 
            this._maxCount = n;
        }
        r(Burst, "laya.d3.core.particleShuriKen.module.Burst");
        var e = Burst.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "time", function() {
            return this._time;
        }), a(0, e, "minCount", function() {
            return this._minCount;
        }), a(0, e, "maxCount", function() {
            return this._maxCount;
        }), Burst;
    }(), it = function() {
        function AnimationEvent() {
            this.time = NaN, this.eventName = null, this.params = null;
        }
        return r(AnimationEvent, "laya.d3.animation.AnimationEvent"), AnimationEvent;
    }(), rt = (function() {
        function Constraint3D() {
            this._nativeConstraint = null, this._simulation = null, this.rigidbodyA = null, 
            this.rigidbodyB = null;
        }
        r(Constraint3D, "laya.d3.physics.Constraint3D");
    }(), function() {
        function MouseTouch() {
            this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0, 
            this.mousePositionY = 0;
        }
        return r(MouseTouch, "laya.d3.MouseTouch"), MouseTouch;
    }()), at = function() {
        function GradientDataInt() {
            this._currentLength = 0, this._elements = null, this._elements = new Float32Array(8);
        }
        r(GradientDataInt, "laya.d3.core.particleShuriKen.module.GradientDataInt");
        var e = GradientDataInt.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.add = function(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")), 
            this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
        }, e.cloneTo = function(e) {
            var t = e;
            t._currentLength = this._currentLength;
            var n = t._elements;
            n.length = this._elements.length;
            for (var i = 0, r = this._elements.length; i < r; i++) n[i] = this._elements[i];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientCount", function() {
            return this._currentLength / 2;
        }), GradientDataInt;
    }(), ot = function() {
        function SubShader(e, t, n, i) {
            this._attributeMap = null, this._uniformMap = null, this._publicDefines = null, 
            this._publicDefinesMap = null, this._spriteDefines = null, this._spriteDefinesMap = null, 
            this._materialDefines = null, this._materialDefinesMap = null, this._owner = null, 
            this._flags = {}, this._passes = [], this._publicDefines = [], this._publicDefinesMap = {}, 
            this._spriteDefines = [], this._spriteDefinesMap = {}, this._materialDefines = [], 
            this._materialDefinesMap = {}, this._addDefines(this._publicDefines, this._publicDefinesMap, Ve._globleDefines), 
            n && this._addDefines(this._spriteDefines, this._spriteDefinesMap, n.defines), i && this._addDefines(this._materialDefines, this._materialDefinesMap, i.defines), 
            this._attributeMap = e, this._uniformMap = t;
        }
        r(SubShader, "laya.d3.shader.SubShader");
        var e = SubShader.prototype;
        return e._addDefines = function(e, t, n) {
            for (var i in n) {
                var r = n[i], a = parseInt(i);
                e[a] = r, t[r] = a;
            }
        }, e.getMaterialDefineByName = function(e) {
            return this._materialDefinesMap[e];
        }, e.setFlag = function(e, t) {
            t ? this._flags[e] = t : delete this._flags[e];
        }, e.getFlag = function(e) {
            return this._flags[e];
        }, e.addShaderPass = function(e, t, n) {
            var i = new qt(this, e, t, n);
            return this._passes.push(i), i;
        }, SubShader;
    }(), st = function() {
        function PostProcessRenderContext() {
            this.source = null, this.destination = null, this.camera = null, this.compositeShaderData = null, 
            this.compositeDefineData = null, this.command = null, this.tempRenderTextures = [];
        }
        return r(PostProcessRenderContext, "laya.d3.core.render.PostProcessRenderContext"), 
        PostProcessRenderContext;
    }(), lt = function() {
        function CommandBuffer() {
            this._commands = [];
        }
        r(CommandBuffer, "laya.d3.core.render.command.CommandBuffer");
        var e = CommandBuffer.prototype;
        return e._apply = function() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run();
        }, e.setShaderDataTexture = function(e, t, n) {
            this._commands.push(Cn.create(e, t, n));
        }, e.blit = function(e, t, n, i, r) {
            void 0 === r && (r = 0), this._commands.push(nn.create(e, t, n, i, r));
        }, e.setRenderTarget = function(e) {
            this._commands.push(vn.create(e));
        }, e.clear = function() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].recover();
            this._commands.length = 0;
        }, CommandBuffer.SCREENTEXTURE_NAME = "u_ScreenTexture", i(CommandBuffer, [ "screenShader", function() {
            return this.screenShader = Ve.find("ScreenQuad");
        }, "SCREENTEXTURE_ID", function() {
            return this.SCREENTEXTURE_ID = Ve.propertyNameToID("u_ScreenTexture");
        } ]), CommandBuffer;
    }(), ht = function() {
        function GradientAngularVelocity() {
            this._type = 0, this._separateAxes = !1, this._constant = NaN, this._constantSeparate = null, 
            this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null, 
            this._gradientW = null, this._constantMin = NaN, this._constantMax = NaN, this._constantMinSeparate = null, 
            this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null, 
            this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null, 
            this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null, 
            this._gradientWMin = null, this._gradientWMax = null;
        }
        r(GradientAngularVelocity, "laya.d3.core.particleShuriKen.module.GradientAngularVelocity");
        var e = GradientAngularVelocity.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant, 
            this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient), 
            this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
            this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
            this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientZ", function() {
            return this._gradientZ;
        }), a(0, e, "constant", function() {
            return this._constant;
        }), a(0, e, "gradient", function() {
            return this._gradient;
        }), a(0, e, "separateAxes", function() {
            return this._separateAxes;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "constantSeparate", function() {
            return this._constantSeparate;
        }), a(0, e, "gradientX", function() {
            return this._gradientX;
        }), a(0, e, "gradientY", function() {
            return this._gradientY;
        }), a(0, e, "gradientW", function() {
            return this._gradientW;
        }), a(0, e, "gradientMin", function() {
            return this._gradientMin;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "gradientMax", function() {
            return this._gradientMax;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), a(0, e, "gradientWMin", function() {
            return this._gradientWMin;
        }), a(0, e, "constantMinSeparate", function() {
            return this._constantMinSeparate;
        }), a(0, e, "constantMaxSeparate", function() {
            return this._constantMaxSeparate;
        }), a(0, e, "gradientXMin", function() {
            return this._gradientXMin;
        }), a(0, e, "gradientXMax", function() {
            return this._gradientXMax;
        }), a(0, e, "gradientWMax", function() {
            return this._gradientWMax;
        }), a(0, e, "gradientYMin", function() {
            return this._gradientYMin;
        }), a(0, e, "gradientYMax", function() {
            return this._gradientYMax;
        }), a(0, e, "gradientZMin", function() {
            return this._gradientZMin;
        }), a(0, e, "gradientZMax", function() {
            return this._gradientZMax;
        }), GradientAngularVelocity.createByConstant = function(e) {
            var t = new GradientAngularVelocity();
            return t._type = 0, t._separateAxes = !1, t._constant = e, t;
        }, GradientAngularVelocity.createByConstantSeparate = function(e) {
            var t = new GradientAngularVelocity();
            return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
        }, GradientAngularVelocity.createByGradient = function(e) {
            var t = new GradientAngularVelocity();
            return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
        }, GradientAngularVelocity.createByGradientSeparate = function(e, t, n) {
            var i = new GradientAngularVelocity();
            return i._type = 1, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = n, 
            i;
        }, GradientAngularVelocity.createByRandomTwoConstant = function(e, t) {
            var n = new GradientAngularVelocity();
            return n._type = 2, n._separateAxes = !1, n._constantMin = e, n._constantMax = t, 
            n;
        }, GradientAngularVelocity.createByRandomTwoConstantSeparate = function(e, t) {
            var n = new GradientAngularVelocity();
            return n._type = 2, n._separateAxes = !0, n._constantMinSeparate = e, n._constantMaxSeparate = t, 
            n;
        }, GradientAngularVelocity.createByRandomTwoGradient = function(e, t) {
            var n = new GradientAngularVelocity();
            return n._type = 3, n._separateAxes = !1, n._gradientMin = e, n._gradientMax = t, 
            n;
        }, GradientAngularVelocity.createByRandomTwoGradientSeparate = function(e, t, n, i, r, a, o, s) {
            var l = new GradientAngularVelocity();
            return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t, 
            l._gradientYMin = n, l._gradientYMax = i, l._gradientZMin = r, l._gradientZMax = a, 
            l._gradientWMin = o, l._gradientWMax = s, l;
        }, GradientAngularVelocity;
    }(), ut = function() {
        function Config3D() {
            this._defaultPhysicsMemory = 128, this._editerEnvironment = !1, this.isAntialias = !0, 
            this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.octreeCulling = !1, 
            this.octreeInitialSize = 64, this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, 
            this.debugFrustumCulling = !1, this.octreeInitialCenter = new Te(0, 0, 0);
        }
        r(Config3D, "Config3D");
        var e = Config3D.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment, 
            t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha, 
            t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter), 
            t.octreeMinNodeSize = this.octreeMinNodeSize, t.octreeLooseness = this.octreeLooseness, 
            t.debugFrustumCulling = this.debugFrustumCulling;
        }, e.clone = function() {
            var e = new Config3D();
            return this.cloneTo(e), e;
        }, a(0, e, "defaultPhysicsMemory", function() {
            return this._defaultPhysicsMemory;
        }, function(e) {
            if (e < 16) throw "defaultPhysicsMemory must large than 16M";
            this._defaultPhysicsMemory = e;
        }), i(Config3D, [ "_default", function() {
            return this._default = new Config3D();
        } ]), Config3D;
    }(), ct = (function() {
        function RandX(e) {
            if (this._state0U = NaN, this._state0L = NaN, this._state1U = NaN, this._state1L = NaN, 
            !(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        r(RandX, "laya.d3.math.RandX");
        var e = RandX.prototype;
        e.randomint = function() {
            var e = this._state0U, t = this._state0L, n = this._state1U, i = this._state1L, r = (i >>> 0) + (t >>> 0), a = n + e + (r / 2 >>> 31) >>> 0, o = r >>> 0;
            this._state0U = n, this._state0L = i;
            var s = 0, l = 0;
            s = (e ^= s = e << 23 | (-512 & t) >>> 9) ^ n, l = (t ^= l = t << 23) ^ i;
            s ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
            return s ^= n >>> 5, l ^= i >>> 5 | (31 & n) << 27, this._state1U = s, this._state1L = l, 
            [ a, o ];
        }, e.random = function() {
            var e = this.randomint(), t = e[0], n = 1023 << 20 | t >>> 12, i = 0 | (e[1] >>> 12 | (4095 & t) << 20);
            return RandX._CONVERTION_BUFFER.setUint32(0, n, !1), RandX._CONVERTION_BUFFER.setUint32(4, i, !1), 
            Ne._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
        }, i(RandX, [ "_CONVERTION_BUFFER", function() {
            return this._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8));
        }, "defaultRand", function() {
            return this.defaultRand = new Ne([ 0, Date.now() / 65536, 0, Date.now() % 65536 ]);
        } ]);
    }(), function() {
        function Picker() {}
        return r(Picker, "laya.d3.utils.Picker"), Picker.calculateCursorRay = function(e, t, n, i, r, a) {
            var o = e.x, s = e.y, l = Picker._tempVector30, h = l;
            h.x = o, h.y = s, h.z = t.minDepth;
            var u = Picker._tempVector31, c = u;
            c.x = o, c.y = s, c.z = t.maxDepth;
            var d = a.origin, _ = Picker._tempVector32;
            t.unprojectFromWVP(l, n, i, r, d), t.unprojectFromWVP(u, n, i, r, _);
            var f = a.direction;
            f.x = _.x - d.x, f.y = _.y - d.y, f.z = _.z - d.z, Te.normalize(a.direction, a.direction);
        }, Picker.rayIntersectsTriangle = function(e, t, n, i) {
            var r = Picker._tempVector30, a = Picker._tempVector31;
            Te.subtract(n, t, r), Te.subtract(i, t, a);
            var o, s = Picker._tempVector32;
            if (Te.cross(e.direction, a, s), (o = Te.dot(r, s)) > -Number.MIN_VALUE && o < Number.MIN_VALUE) return Number.NaN;
            var l, h = 1 / o, u = Picker._tempVector33;
            if (Te.subtract(e.origin, t, u), l = Te.dot(u, s), (l *= h) < 0 || l > 1) return Number.NaN;
            var c, d, _ = Picker._tempVector34;
            return Te.cross(u, r, _), c = Te.dot(e.direction, _), (c *= h) < 0 || l + c > 1 ? Number.NaN : (d = Te.dot(a, _), 
            (d *= h) < 0 ? Number.NaN : d);
        }, i(Picker, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempVector32", function() {
            return this._tempVector32 = new Te();
        }, "_tempVector33", function() {
            return this._tempVector33 = new Te();
        }, "_tempVector34", function() {
            return this._tempVector34 = new Te();
        } ]), Picker;
    }()), dt = function() {
        function Touch() {
            this._indexInList = -1, this._identifier = -1, this._position = new Se();
        }
        r(Touch, "laya.d3.Touch");
        var e = Touch.prototype;
        return n.imps(e, {
            "laya.resource.ISingletonElement": !0
        }), e._getIndexInList = function() {
            return this._indexInList;
        }, e._setIndexInList = function(e) {
            this._indexInList = e;
        }, a(0, e, "identifier", function() {
            return this._identifier;
        }), a(0, e, "position", function() {
            return this._position;
        }), Touch;
    }(), _t = (function() {
        function PixelLineData() {
            this.startPosition = new Te(), this.endPosition = new Te(), this.startColor = new Me(), 
            this.endColor = new Me();
        }
        r(PixelLineData, "laya.d3.core.pixelLine.PixelLineData"), PixelLineData.prototype.cloneTo = function(e) {
            this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition), 
            this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
        };
    }(), function() {
        function Collision() {
            this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1, 
            this.contacts = [];
        }
        return r(Collision, "laya.d3.physics.Collision"), Collision.prototype._setUpdateFrame = function(e) {
            this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
        }, Collision;
    }()), ft = function() {
        function VertexDeclaration(e, t) {
            this._id = 0, this._vertexStride = 0, this._vertexElementsDic = null, this._shaderValues = null, 
            this._defineDatas = null, this.vertexElements = null, this._id = ++VertexDeclaration._uniqueIDCounter, 
            this._defineDatas = new Ue(), this._vertexElementsDic = {}, this._vertexStride = e, 
            this.vertexElements = t;
            var n = t.length;
            this._shaderValues = new ue(null);
            for (var i = 0; i < n; i++) {
                var r = t[i], a = r.elementUsage;
                this._vertexElementsDic[a] = r;
                var o = new Int32Array(5), s = Ot.getElementInfos(r.elementFormat);
                o[0] = s[0], o[1] = s[1], o[2] = s[2], o[3] = this._vertexStride, o[4] = r.offset, 
                this._shaderValues.setAttribute(a, o);
            }
        }
        r(VertexDeclaration, "laya.d3.graphics.VertexDeclaration");
        var e = VertexDeclaration.prototype;
        return e.getVertexElementByUsage = function(e) {
            return this._vertexElementsDic[e];
        }, e.unBinding = function() {}, a(0, e, "id", function() {
            return this._id;
        }), a(0, e, "vertexStride", function() {
            return this._vertexStride;
        }), VertexDeclaration._uniqueIDCounter = 1, VertexDeclaration;
    }(), mt = function() {
        function SkyRenderer() {
            this._material = null, this._mesh = Mn.instance;
        }
        r(SkyRenderer, "laya.d3.resource.models.SkyRenderer");
        var e = SkyRenderer.prototype;
        return e._isAvailable = function() {
            return this._material && this._mesh;
        }, e._render = function(e) {
            if (this._material && this._mesh) {
                var t = E.instance, n = e.scene, i = e.camera;
                F.setCullFace(t, !1), F.setDepthFunc(t, 515), F.setDepthMask(t, !1);
                var r = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0, 0, this._material._defineDatas.value), a = r.bind(), o = P.loopCount !== r._uploadMark, s = r._uploadScene !== n || o;
                (s || a) && (r.uploadUniforms(r._sceneUniformParamsMap, n._shaderValues, s), r._uploadScene = n);
                var l = r._uploadCamera !== i || o;
                (l || a) && (r.uploadUniforms(r._cameraUniformParamsMap, i._shaderValues, l), r._uploadCamera = i);
                var h = r._uploadMaterial !== this._material || o;
                (h || a) && (r.uploadUniforms(r._materialUniformParamsMap, this._material._shaderValues, h), 
                r._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e), 
                F.setDepthFunc(t, 513), F.setDepthMask(t, !0);
            }
        }, e.destroy = function() {
            this._material && (this._material._removeReference(), this._material = null);
        }, a(0, e, "material", function() {
            return this._material;
        }, function(e) {
            this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(), 
            this._material = e);
        }), a(0, e, "mesh", function() {
            return this._mesh;
        }, function(e) {
            this._mesh !== e && (this._mesh = e);
        }), SkyRenderer;
    }(), pt = (function() {
        function AnimatorStateScript() {}
        r(AnimatorStateScript, "laya.d3.animation.AnimatorStateScript");
        var e = AnimatorStateScript.prototype;
        e.onStateEnter = function() {}, e.onStateUpdate = function() {}, e.onStateExit = function() {};
    }(), function() {
        function BatchMark() {
            this.updateMark = -1, this.indexInList = -1, this.batched = !1;
        }
        return r(BatchMark, "laya.d3.core.render.BatchMark"), BatchMark;
    }()), Tt = function() {
        function HitResult() {
            this.succeeded = !1, this.collider = null, this.hitFraction = 0, this.point = new Te(), 
            this.normal = new Te();
        }
        return r(HitResult, "laya.d3.physics.HitResult"), HitResult;
    }(), St = function() {
        function GradientSize() {
            this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null, 
            this._gradientY = null, this._gradientZ = null, this._constantMin = NaN, this._constantMax = NaN, 
            this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null, 
            this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null, 
            this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, 
            this._gradientZMax = null;
        }
        r(GradientSize, "laya.d3.core.particleShuriKen.module.GradientSize");
        var e = GradientSize.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.getMaxSizeInGradient = function() {
            var e = 0, t = 0, n = -Number.MAX_VALUE;
            switch (this._type) {
              case 0:
                if (this._separateAxes) {
                    for (e = 0, t = this._gradientX.gradientCount; e < t; e++) n = Math.max(n, this._gradientX.getValueByIndex(e));
                    for (e = 0, t = this._gradientY.gradientCount; e < t; e++) n = Math.max(n, this._gradientY.getValueByIndex(e));
                } else for (e = 0, t = this._gradient.gradientCount; e < t; e++) n = Math.max(n, this._gradient.getValueByIndex(e));
                break;

              case 1:
                this._separateAxes ? (n = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x), 
                n = Math.max(n, this._constantMinSeparate.y), n = Math.max(n, this._constantMaxSeparate.y)) : n = Math.max(this._constantMin, this._constantMax);
                break;

              case 2:
                if (this._separateAxes) {
                    for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientXMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientXMax.getValueByIndex(e));
                    for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientYMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientZMax.getValueByIndex(e));
                } else {
                    for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) n = Math.max(n, this._gradientMin.getValueByIndex(e));
                    for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) n = Math.max(n, this._gradientMax.getValueByIndex(e));
                }
            }
            return n;
        }, e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient), 
            this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), 
            t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate), 
            this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin), 
            this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientZ", function() {
            return this._gradientZ;
        }), a(0, e, "gradient", function() {
            return this._gradient;
        }), a(0, e, "separateAxes", function() {
            return this._separateAxes;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "gradientMin", function() {
            return this._gradientMin;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "gradientX", function() {
            return this._gradientX;
        }), a(0, e, "gradientY", function() {
            return this._gradientY;
        }), a(0, e, "gradientMax", function() {
            return this._gradientMax;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), a(0, e, "constantMinSeparate", function() {
            return this._constantMinSeparate;
        }), a(0, e, "constantMaxSeparate", function() {
            return this._constantMaxSeparate;
        }), a(0, e, "gradientXMin", function() {
            return this._gradientXMin;
        }), a(0, e, "gradientXMax", function() {
            return this._gradientXMax;
        }), a(0, e, "gradientYMin", function() {
            return this._gradientYMin;
        }), a(0, e, "gradientYMax", function() {
            return this._gradientYMax;
        }), a(0, e, "gradientZMin", function() {
            return this._gradientZMin;
        }), a(0, e, "gradientZMax", function() {
            return this._gradientZMax;
        }), GradientSize.createByGradient = function(e) {
            var t = new GradientSize();
            return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
        }, GradientSize.createByGradientSeparate = function(e, t, n) {
            var i = new GradientSize();
            return i._type = 0, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = n, 
            i;
        }, GradientSize.createByRandomTwoConstant = function(e, t) {
            var n = new GradientSize();
            return n._type = 1, n._separateAxes = !1, n._constantMin = e, n._constantMax = t, 
            n;
        }, GradientSize.createByRandomTwoConstantSeparate = function(e, t) {
            var n = new GradientSize();
            return n._type = 1, n._separateAxes = !0, n._constantMinSeparate = e, n._constantMaxSeparate = t, 
            n;
        }, GradientSize.createByRandomTwoGradient = function(e, t) {
            var n = new GradientSize();
            return n._type = 2, n._separateAxes = !1, n._gradientMin = e, n._gradientMax = t, 
            n;
        }, GradientSize.createByRandomTwoGradientSeparate = function(e, t, n, i, r, a) {
            var o = new GradientSize();
            return o._type = 2, o._separateAxes = !0, o._gradientXMin = e, o._gradientXMax = t, 
            o._gradientYMin = n, o._gradientYMax = i, o._gradientZMin = r, o._gradientZMax = a, 
            o;
        }, GradientSize;
    }(), Et = function() {
        function ChunkInfo() {
            this.alphaMap = null, this.detailID = null, this.normalMap = null;
        }
        return r(ChunkInfo, "laya.d3.terrain.unit.ChunkInfo"), ChunkInfo;
    }(), vt = function() {
        function ShaderVariable() {
            this.textureID = -1;
        }
        return r(ShaderVariable, "laya.d3.shader.ShaderVariable"), ShaderVariable;
    }(), gt = function() {
        function KeyframeNode() {
            this._indexInList = 0, this.type = 0, this.fullPath = null, this.propertyOwner = null, 
            this.data = null, this._ownerPath = [], this._propertys = [], this._keyFrames = [];
        }
        r(KeyframeNode, "laya.d3.animation.KeyframeNode");
        var e = KeyframeNode.prototype;
        return e._setOwnerPathCount = function(e) {
            this._ownerPath.length = e;
        }, e._setOwnerPathByIndex = function(e, t) {
            this._ownerPath[e] = t;
        }, e._joinOwnerPath = function(e) {
            return this._ownerPath.join(e);
        }, e._setPropertyCount = function(e) {
            this._propertys.length = e;
        }, e._setPropertyByIndex = function(e, t) {
            this._propertys[e] = t;
        }, e._joinProperty = function(e) {
            return this._propertys.join(e);
        }, e._setKeyframeCount = function(e) {
            this._keyFrames.length = e;
        }, e._setKeyframeByIndex = function(e, t) {
            this._keyFrames[e] = t;
        }, e.getOwnerPathByIndex = function(e) {
            return this._ownerPath[e];
        }, e.getPropertyByIndex = function(e) {
            return this._propertys[e];
        }, e.getKeyframeByIndex = function(e) {
            return this._keyFrames[e];
        }, a(0, e, "ownerPathCount", function() {
            return this._ownerPath.length;
        }), a(0, e, "propertyCount", function() {
            return this._propertys.length;
        }), a(0, e, "keyFramesCount", function() {
            return this._keyFrames.length;
        }), KeyframeNode;
    }(), xt = function() {
        function GradientVelocity() {
            this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null, 
            this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null, 
            this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null, 
            this._gradientZMin = null, this._gradientZMax = null;
        }
        r(GradientVelocity, "laya.d3.core.particleShuriKen.module.GradientVelocity");
        var e = GradientVelocity.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX), 
            this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin), 
            this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin), 
            this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), 
            this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin), 
            this._gradientZMax.cloneTo(t._gradientZMax);
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "gradientZ", function() {
            return this._gradientZ;
        }), a(0, e, "constant", function() {
            return this._constant;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "gradientXMax", function() {
            return this._gradientXMax;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "gradientX", function() {
            return this._gradientX;
        }), a(0, e, "gradientY", function() {
            return this._gradientY;
        }), a(0, e, "gradientXMin", function() {
            return this._gradientXMin;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), a(0, e, "gradientYMin", function() {
            return this._gradientYMin;
        }), a(0, e, "gradientYMax", function() {
            return this._gradientYMax;
        }), a(0, e, "gradientZMin", function() {
            return this._gradientZMin;
        }), a(0, e, "gradientZMax", function() {
            return this._gradientZMax;
        }), GradientVelocity.createByConstant = function(e) {
            var t = new GradientVelocity();
            return t._type = 0, t._constant = e, t;
        }, GradientVelocity.createByGradient = function(e, t, n) {
            var i = new GradientVelocity();
            return i._type = 1, i._gradientX = e, i._gradientY = t, i._gradientZ = n, i;
        }, GradientVelocity.createByRandomTwoConstant = function(e, t) {
            var n = new GradientVelocity();
            return n._type = 2, n._constantMin = e, n._constantMax = t, n;
        }, GradientVelocity.createByRandomTwoGradient = function(e, t, n, i, r, a) {
            var o = new GradientVelocity();
            return o._type = 3, o._gradientXMin = e, o._gradientXMax = t, o._gradientYMin = n, 
            o._gradientYMax = i, o._gradientZMin = r, o._gradientZMax = a, o;
        }, GradientVelocity;
    }(), Mt = function() {
        function Bounds(e, t) {
            this._updateFlag = 0, this._center = new Te(), this._extent = new Te(), this._boundBox = new zt(new Te(), new Te()), 
            e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max), this._setUpdateFlag(12, !0);
        }
        r(Bounds, "laya.d3.core.Bounds");
        var e = Bounds.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setMin = function(e) {
            var t = this._boundBox.min;
            e !== t && e.cloneTo(t), this._setUpdateFlag(12, !0), this._setUpdateFlag(1, !1);
        }, e.getMin = function() {
            var e = this._boundBox.min;
            return this._getUpdateFlag(1) && (this._getMin(this.getCenter(), this.getExtent(), e), 
            this._setUpdateFlag(1, !1)), e;
        }, e.setMax = function(e) {
            var t = this._boundBox.max;
            e !== t && e.cloneTo(t), this._setUpdateFlag(12, !0), this._setUpdateFlag(2, !1);
        }, e.getMax = function() {
            var e = this._boundBox.max;
            return this._getUpdateFlag(2) && (this._getMax(this.getCenter(), this.getExtent(), e), 
            this._setUpdateFlag(2, !1)), e;
        }, e.setCenter = function(e) {
            e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(3, !0), this._setUpdateFlag(4, !1);
        }, e.getCenter = function() {
            return this._getUpdateFlag(4) && (this._getCenter(this.getMin(), this.getMax(), this._center), 
            this._setUpdateFlag(4, !1)), this._center;
        }, e.setExtent = function(e) {
            e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(3, !0), this._setUpdateFlag(8, !1);
        }, e.getExtent = function() {
            return this._getUpdateFlag(8) && (this._getExtent(this.getMin(), this.getMax(), this._extent), 
            this._setUpdateFlag(8, !1)), this._extent;
        }, e._getUpdateFlag = function(e) {
            return 0 != (this._updateFlag & e);
        }, e._setUpdateFlag = function(e, t) {
            t ? this._updateFlag |= e : this._updateFlag &= ~e;
        }, e._getCenter = function(e, t, n) {
            Te.add(e, t, n), Te.scale(n, .5, n);
        }, e._getExtent = function(e, t, n) {
            Te.subtract(t, e, n), Te.scale(n, .5, n);
        }, e._getMin = function(e, t, n) {
            Te.subtract(e, t, n);
        }, e._getMax = function(e, t, n) {
            Te.add(e, t, n);
        }, e._rotateExtents = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.elements;
            n.x = Math.abs(o[0] * i) + Math.abs(o[4] * r) + Math.abs(o[8] * a), n.y = Math.abs(o[1] * i) + Math.abs(o[5] * r) + Math.abs(o[9] * a), 
            n.z = Math.abs(o[2] * i) + Math.abs(o[6] * r) + Math.abs(o[10] * a);
        }, e._tranform = function(e, t) {
            var n = t._center, i = t._extent;
            Te.transformCoordinate(this.getCenter(), e, n), this._rotateExtents(this.getExtent(), e, i), 
            t._boundBox.setCenterAndExtent(n, i), t._updateFlag = 0;
        }, e._getBoundBox = function() {
            var e = this._boundBox.min;
            this._getUpdateFlag(1) && (this._getMin(this.getCenter(), this.getExtent(), e), 
            this._setUpdateFlag(1, !1));
            var t = this._boundBox.max;
            return this._getUpdateFlag(2) && (this._getMax(this.getCenter(), this.getExtent(), t), 
            this._setUpdateFlag(2, !1)), this._boundBox;
        }, e.cloneTo = function(e) {
            var t = e;
            this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max), 
            this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, Bounds._UPDATE_MIN = 1, Bounds._UPDATE_MAX = 2, Bounds._UPDATE_CENTER = 4, Bounds._UPDATE_EXTENT = 8, 
        Bounds;
    }(), yt = function() {
        function StartFrame() {
            this._type = 0, this._constant = NaN, this._constantMin = NaN, this._constantMax = NaN;
        }
        r(StartFrame, "laya.d3.core.particleShuriKen.module.StartFrame");
        var e = StartFrame.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin, 
            t._constantMax = this._constantMax;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "constant", function() {
            return this._constant;
        }), a(0, e, "type", function() {
            return this._type;
        }), a(0, e, "constantMin", function() {
            return this._constantMin;
        }), a(0, e, "constantMax", function() {
            return this._constantMax;
        }), StartFrame.createByConstant = function(e) {
            var t = new StartFrame();
            return t._type = 0, t._constant = e, t;
        }, StartFrame.createByRandomTwoConstant = function(e, t) {
            var n = new StartFrame();
            return n._type = 1, n._constantMin = e, n._constantMax = t, n;
        }, StartFrame;
    }(), Dt = function() {
        function AnimationNode(e, t, n, i) {
            this._children = [], this.transform = new Kt(this, e, t, n, i);
        }
        r(AnimationNode, "laya.d3.animation.AnimationNode");
        var e = AnimationNode.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.addChild = function(e) {
            e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
        }, e.removeChild = function(e) {
            var t = this._children.indexOf(e);
            -1 !== t && this._children.splice(t, 1);
        }, e.getChildByName = function(e) {
            for (var t = 0, n = this._children.length; t < n; t++) {
                var i = this._children[t];
                if (i.name === e) return i;
            }
            return null;
        }, e.getChildByIndex = function(e) {
            return this._children[e];
        }, e.getChildCount = function() {
            return this._children.length;
        }, e.cloneTo = function(e) {
            var t = e;
            t.name = this.name;
            for (var n = 0, i = this._children.length; n < i; n++) {
                var r = this._children[n], a = r.clone();
                t.addChild(a);
                var o = r.transform, s = a.transform, l = s.localPosition, h = s.localRotation, u = s.localScale;
                o.localPosition.cloneTo(l), o.localRotation.cloneTo(h), o.localScale.cloneTo(u), 
                s.localPosition = l, s.localRotation = h, s.localScale = u;
            }
        }, e.clone = function() {
            var e = new AnimationNode();
            return this.cloneTo(e), e;
        }, e._cloneNative = function(e, t, n, i, r, a, o) {
            var s = o._nativeCurCloneCount;
            r[s] = a;
            var l = new AnimationNode(new Float32Array(e.buffer, 3 * s * 4, 3), new Float32Array(t.buffer, 4 * s * 4, 4), new Float32Array(n.buffer, 3 * s * 4, 3), new Float32Array(i.buffer, 16 * s * 4, 16));
            return l._worldMatrixIndex = s, this._cloneToNative(l, e, t, n, i, r, s, o), l;
        }, e._cloneToNative = function(e, t, n, i, r, a, o, s) {
            var l = e;
            l.name = this.name;
            for (var h = 0, u = this._children.length; h < u; h++) {
                var c = this._children[h];
                s._nativeCurCloneCount++;
                var d = c._cloneNative(t, n, i, r, a, o, s);
                l.addChild(d);
                var _ = c.transform, f = d.transform, m = f.localPosition, p = f.localRotation, T = f.localScale;
                _.localPosition.cloneTo(m), _.localRotation.cloneTo(p), _.localScale.cloneTo(T), 
                f.localPosition = m, f.localRotation = p, f.localScale = T;
            }
        }, AnimationNode;
    }(), Rt = function() {
        function PostProcess() {
            this._context = null, this._compositeShader = Ve.find("PostProcessComposite"), this._compositeShaderData = new ue(), 
            this._compositeDefineData = new Ue(), this._effects = [], this._context = new st(), 
            this._context.compositeShaderData = this._compositeShaderData, this._context.compositeDefineData = this._compositeDefineData;
        }
        r(PostProcess, "laya.d3.component.PostProcess");
        var e = PostProcess.prototype;
        return e._init = function(e, t) {
            this._context.camera = e, this._context.command = t;
        }, e._render = function() {
            var e = pi.getTemporary(J.clientWidth, J.clientHeight, 0, 3), t = this._context.camera.getRenderTexture();
            this._context.command.clear(), this._context.source = e, this._context.destination = t;
            for (var n = 0, i = this._effects.length; n < i; n++) this._effects[n].render(this._context);
            pi.setReleaseTemporary(e);
            var r = this._context.tempRenderTextures;
            for (n = 0, i = r.length; n < i; n++) pi.setReleaseTemporary(r[n]);
        }, e.addEffect = function(e) {
            this._effects.push(e);
        }, e.removeEffect = function(e) {
            var t = this._effects.indexOf(e);
            -1 !== t && this._effects.splice(t, 1);
        }, PostProcess.__init__ = function() {
            PostProcess.SHADERDEFINE_BLOOM_LOW = PostProcess.shaderDefines.registerDefine("BLOOM_LOW"), 
            PostProcess.SHADERDEFINE_BLOOM = PostProcess.shaderDefines.registerDefine("BLOOM");
        }, PostProcess.SHADERDEFINE_BLOOM_LOW = 0, PostProcess.SHADERDEFINE_BLOOM = 0, i(PostProcess, [ "SHADERVALUE_MAINTEX", function() {
            return this.SHADERVALUE_MAINTEX = Ve.propertyNameToID("u_MainTex");
        }, "SHADERVALUE_BLOOMTEX", function() {
            return this.SHADERVALUE_BLOOMTEX = Ve.propertyNameToID("u_BloomTex");
        }, "SHADERVALUE_AUTOEXPOSURETEX", function() {
            return this.SHADERVALUE_AUTOEXPOSURETEX = Ve.propertyNameToID("u_AutoExposureTex");
        }, "SHADERVALUE_BLOOM_DIRTTEX", function() {
            return this.SHADERVALUE_BLOOM_DIRTTEX = Ve.propertyNameToID("u_Bloom_DirtTex");
        }, "SHADERVALUE_BLOOMTEX_TEXELSIZE", function() {
            return this.SHADERVALUE_BLOOMTEX_TEXELSIZE = Ve.propertyNameToID("u_BloomTex_TexelSize");
        }, "SHADERVALUE_BLOOM_DIRTTILEOFFSET", function() {
            return this.SHADERVALUE_BLOOM_DIRTTILEOFFSET = Ve.propertyNameToID("u_Bloom_DirtTileOffset");
        }, "SHADERVALUE_BLOOM_SETTINGS", function() {
            return this.SHADERVALUE_BLOOM_SETTINGS = Ve.propertyNameToID("u_Bloom_Settings");
        }, "SHADERVALUE_BLOOM_COLOR", function() {
            return this.SHADERVALUE_BLOOM_COLOR = Ve.propertyNameToID("u_Bloom_Color");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe();
        } ]), PostProcess;
    }(), Ct = function() {
        function Viewport(e, t, n, i) {
            this.minDepth = 0, this.maxDepth = 1, this.x = e, this.y = t, this.width = n, this.height = i;
        }
        r(Viewport, "laya.d3.math.Viewport");
        var e = Viewport.prototype;
        return e.project = function(e, t, n) {
            Te.transformV3ToV3(e, t, n);
            var i = t.elements, r = e.x * i[3] + e.y * i[7] + e.z * i[11] + i[15];
            1 !== r && (n.x = n.x / r, n.y = n.y / r, n.z = n.z / r), n.x = .5 * (n.x + 1) * this.width + this.x, 
            n.y = .5 * (1 - n.y) * this.height + this.y, n.z = n.z * (this.maxDepth - this.minDepth) + this.minDepth;
        }, e.project1 = function(e, t, n) {
            var i = Te._tempVector4;
            Te.transformV3ToV4(e, t, i);
            var r = i.w;
            r < .1 && r > -1e-6 && (r = 1e-6), i.x /= r, i.y /= r, i.z /= r, n.x = (i.x + 1) * this.width / 2 + this.x, 
            n.y = (1 - i.y) * this.height / 2 + this.y, n.z = i.w;
        }, e.unprojectFromMat = function(e, t, n) {
            var i = t.elements;
            n.x = (e.x - this.x) / this.width * 2 - 1, n.y = -((e.y - this.y) / this.height * 2 - 1);
            var r = (this.maxDepth - this.minDepth) / 2;
            n.z = (e.z - this.minDepth - r) / r;
            var a = n.x * i[3] + n.y * i[7] + n.z * i[11] + i[15];
            Te.transformV3ToV3(n, t, n), 1 !== a && (n.x = n.x / a, n.y = n.y / a, n.z = n.z / a);
        }, e.unprojectFromWVP = function(e, t, n, i, r) {
            Ht.multiply(t, n, Viewport._tempMatrix4x4), i && Ht.multiply(Viewport._tempMatrix4x4, i, Viewport._tempMatrix4x4), 
            Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4), this.unprojectFromMat(e, Viewport._tempMatrix4x4, r);
        }, e.cloneTo = function(e) {
            e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth, 
            e.maxDepth = this.maxDepth;
        }, i(Viewport, [ "_tempMatrix4x4", function() {
            return this._tempMatrix4x4 = new Ht();
        } ]), Viewport;
    }(), It = function() {
        function DetailTextureInfo() {
            this.diffuseTexture = null, this.normalTexture = null, this.scale = null, this.offset = null;
        }
        return r(DetailTextureInfo, "laya.d3.terrain.unit.DetailTextureInfo"), DetailTextureInfo;
    }(), At = (function() {
        function OrientedBoundBox(e, t) {
            this.extents = null, this.transformation = null, this.extents = e, this.transformation = t;
        }
        r(OrientedBoundBox, "laya.d3.math.OrientedBoundBox");
        var e = OrientedBoundBox.prototype;
        e.getCorners = function(e) {
            OrientedBoundBox._tempV30.x = this.extents.x, OrientedBoundBox._tempV30.y = OrientedBoundBox._tempV30.z = 0, 
            OrientedBoundBox._tempV31.y = this.extents.y, OrientedBoundBox._tempV31.x = OrientedBoundBox._tempV31.z = 0, 
            OrientedBoundBox._tempV32.z = this.extents.z, OrientedBoundBox._tempV32.x = OrientedBoundBox._tempV32.y = 0, 
            Te.TransformNormal(OrientedBoundBox._tempV30, this.transformation, OrientedBoundBox._tempV30), 
            Te.TransformNormal(OrientedBoundBox._tempV31, this.transformation, OrientedBoundBox._tempV31), 
            Te.TransformNormal(OrientedBoundBox._tempV32, this.transformation, OrientedBoundBox._tempV32);
            var t = OrientedBoundBox._tempV33;
            this.transformation.getTranslationVector(t), e.length = 8, Te.add(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[0]), Te.add(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[1]), Te.subtract(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[2]), Te.subtract(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[3]), Te.add(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[4]), Te.add(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[5]), Te.subtract(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[6]), Te.subtract(t, OrientedBoundBox._tempV30, OrientedBoundBox._tempV34), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV31, OrientedBoundBox._tempV34), 
            Te.add(OrientedBoundBox._tempV34, OrientedBoundBox._tempV32, e[7]);
        }, e.transform = function(e) {
            Ht.multiply(this.transformation, e, this.transformation);
        }, e.scale = function(e) {
            Te.multiply(this.extents, e, this.extents);
        }, e.translate = function(e) {
            this.transformation.getTranslationVector(OrientedBoundBox._tempV30), Te.add(OrientedBoundBox._tempV30, e, OrientedBoundBox._tempV31), 
            this.transformation.setTranslationVector(OrientedBoundBox._tempV31);
        }, e.Size = function(e) {
            Te.scale(this.extents, 2, e);
        }, e.getSize = function(e) {
            OrientedBoundBox._tempV30.x = this.extents.x, OrientedBoundBox._tempV31.y = this.extents.y, 
            OrientedBoundBox._tempV32.z = this.extents.z, Te.TransformNormal(OrientedBoundBox._tempV30, this.transformation, OrientedBoundBox._tempV30), 
            Te.TransformNormal(OrientedBoundBox._tempV31, this.transformation, OrientedBoundBox._tempV31), 
            Te.TransformNormal(OrientedBoundBox._tempV31, this.transformation, OrientedBoundBox._tempV32), 
            e.x = Te.scalarLength(OrientedBoundBox._tempV30), e.y = Te.scalarLength(OrientedBoundBox._tempV31), 
            e.z = Te.scalarLength(OrientedBoundBox._tempV32);
        }, e.getSizeSquared = function(e) {
            OrientedBoundBox._tempV30.x = this.extents.x, OrientedBoundBox._tempV31.y = this.extents.y, 
            OrientedBoundBox._tempV32.z = this.extents.z, Te.TransformNormal(OrientedBoundBox._tempV30, this.transformation, OrientedBoundBox._tempV30), 
            Te.TransformNormal(OrientedBoundBox._tempV31, this.transformation, OrientedBoundBox._tempV31), 
            Te.TransformNormal(OrientedBoundBox._tempV31, this.transformation, OrientedBoundBox._tempV32), 
            e.x = Te.scalarLengthSquared(OrientedBoundBox._tempV30), e.y = Te.scalarLengthSquared(OrientedBoundBox._tempV31), 
            e.z = Te.scalarLengthSquared(OrientedBoundBox._tempV32);
        }, e.getCenter = function(e) {
            this.transformation.getTranslationVector(e);
        }, e.containsPoint = function(e) {
            var t = this.extents.x, n = this.extents.y, i = this.extents.z;
            this.transformation.invert(OrientedBoundBox._tempM0), Te.transformCoordinate(e, OrientedBoundBox._tempM0, OrientedBoundBox._tempV30);
            var r = Math.abs(OrientedBoundBox._tempV30.x), a = Math.abs(OrientedBoundBox._tempV30.y), o = Math.abs(OrientedBoundBox._tempV30.z);
            return ie.nearEqual(r, t) && ie.nearEqual(a, n) && ie.nearEqual(o, i) ? 2 : r < t && a < n && o < i ? 1 : 0;
        }, e.containsPoints = function(e) {
            var t = this.extents.x, n = this.extents.y, i = this.extents.z;
            this.transformation.invert(OrientedBoundBox._tempM0);
            for (var r = !0, a = !1, o = 0; o < e.length; o++) {
                Te.transformCoordinate(e[o], OrientedBoundBox._tempM0, OrientedBoundBox._tempV30);
                var s = Math.abs(OrientedBoundBox._tempV30.x), l = Math.abs(OrientedBoundBox._tempV30.y), h = Math.abs(OrientedBoundBox._tempV30.z);
                ie.nearEqual(s, t) && ie.nearEqual(l, n) && ie.nearEqual(h, i) && (a = !0), s < t && l < n && h < i ? a = !0 : r = !1;
            }
            return r ? 1 : a ? 2 : 0;
        }, e.containsSphere = function(e, t) {
            void 0 === t && (t = !1);
            var n = this.extents.x, i = this.extents.y, r = this.extents.z, a = e.radius;
            this.transformation.invert(OrientedBoundBox._tempM0), Te.transformCoordinate(e.center, OrientedBoundBox._tempM0, OrientedBoundBox._tempV30);
            var o = NaN;
            if (t ? o = a : (Te.scale(Te._UnitX, a, OrientedBoundBox._tempV31), Te.TransformNormal(OrientedBoundBox._tempV31, OrientedBoundBox._tempM0, OrientedBoundBox._tempV31), 
            o = Te.scalarLength(OrientedBoundBox._tempV31)), Te.scale(this.extents, -1, OrientedBoundBox._tempV32), 
            Te.Clamp(OrientedBoundBox._tempV30, OrientedBoundBox._tempV32, this.extents, OrientedBoundBox._tempV33), 
            Te.distanceSquared(OrientedBoundBox._tempV30, OrientedBoundBox._tempV33) > o * o) return 0;
            var s = OrientedBoundBox._tempV30.x, l = OrientedBoundBox._tempV30.y, h = OrientedBoundBox._tempV30.z, u = OrientedBoundBox._tempV32.x, c = OrientedBoundBox._tempV32.y, d = OrientedBoundBox._tempV32.z;
            return u + o <= s && s <= n - o && n - u > o && c + o <= l && l <= i - o && i - c > o && d + o <= h && h <= r - o && r - d > o ? 1 : 2;
        }, e.containsOrientedBoundBox = function(e) {
            var t = 0, n = 0;
            e.getCorners(OrientedBoundBox._corners);
            var i = this.containsPoints(OrientedBoundBox._corners);
            if (0 != i) return i;
            OrientedBoundBox._sizeAe[0] = this.extents.x, OrientedBoundBox._sizeAe[1] = this.extents.y, 
            OrientedBoundBox._sizeAe[2] = this.extents.z, e.extents.cloneTo(OrientedBoundBox._tempV35), 
            OrientedBoundBox._sizeBe[0] = OrientedBoundBox._tempV35.x, OrientedBoundBox._sizeBe[1] = OrientedBoundBox._tempV35.y, 
            OrientedBoundBox._sizeBe[2] = OrientedBoundBox._tempV35.z, OrientedBoundBox._getRows(this.transformation, OrientedBoundBox._rows1), 
            OrientedBoundBox._getRows(e.transformation, OrientedBoundBox._rows2);
            var r = NaN, a = NaN, o = NaN;
            for (t = 0; t < 4; t++) for (n = 0; n < 4; n++) 3 == t || 3 == n ? (OrientedBoundBox._tempM0.setElementByRowColumn(t, n, 0), 
            OrientedBoundBox._tempM1.setElementByRowColumn(t, n, 0)) : (o = Te.dot(OrientedBoundBox._rows1[t], OrientedBoundBox._rows2[n]), 
            OrientedBoundBox._tempM0.setElementByRowColumn(t, n, o), OrientedBoundBox._tempM1.setElementByRowColumn(t, n, Math.abs(o)));
            for (e.getCenter(OrientedBoundBox._tempV34), this.getCenter(OrientedBoundBox._tempV36), 
            Te.subtract(OrientedBoundBox._tempV34, OrientedBoundBox._tempV36, OrientedBoundBox._tempV30), 
            OrientedBoundBox._tempV31.x = Te.dot(OrientedBoundBox._tempV30, OrientedBoundBox._rows1[0]), 
            OrientedBoundBox._tempV31.y = Te.dot(OrientedBoundBox._tempV30, OrientedBoundBox._rows1[1]), 
            OrientedBoundBox._tempV31.z = Te.dot(OrientedBoundBox._tempV30, OrientedBoundBox._rows1[2]), 
            OrientedBoundBox._vsepAe[0] = OrientedBoundBox._tempV31.x, OrientedBoundBox._vsepAe[1] = OrientedBoundBox._tempV31.y, 
            OrientedBoundBox._vsepAe[2] = OrientedBoundBox._tempV31.z, t = 0; t < 3; t++) if (OrientedBoundBox._tempV32.x = OrientedBoundBox._tempM1.getElementByRowColumn(t, 0), 
            OrientedBoundBox._tempV32.y = OrientedBoundBox._tempM1.getElementByRowColumn(t, 1), 
            OrientedBoundBox._tempV32.z = OrientedBoundBox._tempM1.getElementByRowColumn(t, 2), 
            r = OrientedBoundBox._sizeAe[t], a = Te.dot(OrientedBoundBox._tempV35, OrientedBoundBox._tempV32), 
            Math.abs(OrientedBoundBox._vsepAe[t]) > r + a) return 0;
            for (n = 0; n < 3; n++) if (OrientedBoundBox._tempV32.x = OrientedBoundBox._tempM1.getElementByRowColumn(0, n), 
            OrientedBoundBox._tempV32.y = OrientedBoundBox._tempM1.getElementByRowColumn(1, n), 
            OrientedBoundBox._tempV32.z = OrientedBoundBox._tempM1.getElementByRowColumn(2, n), 
            OrientedBoundBox._tempV33.x = OrientedBoundBox._tempM0.getElementByRowColumn(0, n), 
            OrientedBoundBox._tempV33.y = OrientedBoundBox._tempM0.getElementByRowColumn(1, n), 
            OrientedBoundBox._tempV33.z = OrientedBoundBox._tempM0.getElementByRowColumn(2, n), 
            r = Te.dot(this.extents, OrientedBoundBox._tempV32), a = OrientedBoundBox._sizeBe[n], 
            Math.abs(Te.dot(OrientedBoundBox._tempV31, OrientedBoundBox._tempV33)) > r + a) return 0;
            for (t = 0; t < 3; t++) for (n = 0; n < 3; n++) {
                var s = (t + 1) % 3, l = (t + 2) % 3, h = (n + 1) % 3, u = (n + 2) % 3;
                if (r = OrientedBoundBox._sizeAe[s] * OrientedBoundBox._tempM1.getElementByRowColumn(l, n) + OrientedBoundBox._sizeAe[l] * OrientedBoundBox._tempM1.getElementByRowColumn(s, n), 
                a = OrientedBoundBox._sizeBe[h] * OrientedBoundBox._tempM1.getElementByRowColumn(t, u) + OrientedBoundBox._sizeBe[u] * OrientedBoundBox._tempM1.getElementByRowColumn(t, h), 
                Math.abs(OrientedBoundBox._vsepAe[l] * OrientedBoundBox._tempM0.getElementByRowColumn(s, n) - OrientedBoundBox._vsepAe[s] * OrientedBoundBox._tempM0.getElementByRowColumn(l, n)) > r + a) return 0;
            }
            return 2;
        }, e.containsLine = function(e, t) {
            OrientedBoundBox._corners[0] = e, OrientedBoundBox._corners[1] = t;
            var n = this.containsPoints(OrientedBoundBox._corners);
            if (0 != n) return n;
            var i = this.extents.x, r = this.extents.y, a = this.extents.z;
            this.transformation.invert(OrientedBoundBox._tempM0), Te.transformCoordinate(e, OrientedBoundBox._tempM0, OrientedBoundBox._tempV30), 
            Te.transformCoordinate(t, OrientedBoundBox._tempM0, OrientedBoundBox._tempV31), 
            Te.add(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV32), 
            Te.scale(OrientedBoundBox._tempV32, .5, OrientedBoundBox._tempV32), Te.subtract(OrientedBoundBox._tempV30, OrientedBoundBox._tempV32, OrientedBoundBox._tempV33);
            var o = OrientedBoundBox._tempV33.x, s = OrientedBoundBox._tempV33.y, l = OrientedBoundBox._tempV33.z, h = OrientedBoundBox._tempV34.x = Math.abs(OrientedBoundBox._tempV33.x), u = OrientedBoundBox._tempV34.y = Math.abs(OrientedBoundBox._tempV33.y), c = OrientedBoundBox._tempV34.z = Math.abs(OrientedBoundBox._tempV33.z), d = OrientedBoundBox._tempV32.x, _ = OrientedBoundBox._tempV32.y, f = OrientedBoundBox._tempV32.z;
            return Math.abs(d) > i + h ? 0 : Math.abs(_) > r + u ? 0 : Math.abs(f) > a + c ? 0 : Math.abs(_ * l - f * s) > r * c + a * u ? 0 : Math.abs(d * l - f * o) > i * c + a * h ? 0 : Math.abs(d * s - _ * o) > i * u + r * h ? 0 : 2;
        }, e.containsBoundBox = function(e) {
            var t = 0, n = 0, i = e.min, r = e.max;
            e.getCorners(OrientedBoundBox._corners);
            var a = this.containsPoints(OrientedBoundBox._corners);
            if (0 != a) return a;
            Te.subtract(r, i, OrientedBoundBox._tempV30), Te.scale(OrientedBoundBox._tempV30, .5, OrientedBoundBox._tempV30), 
            Te.add(i, OrientedBoundBox._tempV30, OrientedBoundBox._tempV30), Te.subtract(r, OrientedBoundBox._tempV30, OrientedBoundBox._tempV31), 
            OrientedBoundBox._sizeAe[0] = this.extents.x, OrientedBoundBox._sizeAe[1] = this.extents.y, 
            OrientedBoundBox._sizeAe[2] = this.extents.z, OrientedBoundBox._sizeBe[0] = OrientedBoundBox._tempV31.x, 
            OrientedBoundBox._sizeBe[1] = OrientedBoundBox._tempV31.y, OrientedBoundBox._sizeBe[2] = OrientedBoundBox._tempV31.z, 
            OrientedBoundBox._getRows(this.transformation, OrientedBoundBox._rows1), this.transformation.invert(OrientedBoundBox._tempM0);
            var o = NaN, s = NaN;
            for (t = 0; t < 3; t++) for (n = 0; n < 3; n++) OrientedBoundBox._tempM1.setElementByRowColumn(t, n, Math.abs(OrientedBoundBox._tempM0.getElementByRowColumn(t, n)));
            for (this.getCenter(OrientedBoundBox._tempV35), Te.subtract(OrientedBoundBox._tempV30, OrientedBoundBox._tempV35, OrientedBoundBox._tempV32), 
            OrientedBoundBox._tempV31.x = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[0]), 
            OrientedBoundBox._tempV31.y = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[1]), 
            OrientedBoundBox._tempV31.z = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[2]), 
            OrientedBoundBox._vsepAe[0] = OrientedBoundBox._tempV31.x, OrientedBoundBox._vsepAe[1] = OrientedBoundBox._tempV31.y, 
            OrientedBoundBox._vsepAe[2] = OrientedBoundBox._tempV31.z, t = 0; t < 3; t++) if (OrientedBoundBox._tempV33.x = OrientedBoundBox._tempM1.getElementByRowColumn(t, 0), 
            OrientedBoundBox._tempV33.y = OrientedBoundBox._tempM1.getElementByRowColumn(t, 1), 
            OrientedBoundBox._tempV33.z = OrientedBoundBox._tempM1.getElementByRowColumn(t, 2), 
            o = OrientedBoundBox._sizeAe[t], s = Te.dot(OrientedBoundBox._tempV31, OrientedBoundBox._tempV33), 
            Math.abs(OrientedBoundBox._vsepAe[t]) > o + s) return 0;
            for (n = 0; n < 3; n++) if (OrientedBoundBox._tempV33.x = OrientedBoundBox._tempM1.getElementByRowColumn(0, n), 
            OrientedBoundBox._tempV33.y = OrientedBoundBox._tempM1.getElementByRowColumn(1, n), 
            OrientedBoundBox._tempV33.z = OrientedBoundBox._tempM1.getElementByRowColumn(2, n), 
            OrientedBoundBox._tempV34.x = OrientedBoundBox._tempM0.getElementByRowColumn(0, n), 
            OrientedBoundBox._tempV34.y = OrientedBoundBox._tempM0.getElementByRowColumn(1, n), 
            OrientedBoundBox._tempV34.z = OrientedBoundBox._tempM0.getElementByRowColumn(2, n), 
            o = Te.dot(this.extents, OrientedBoundBox._tempV33), s = OrientedBoundBox._sizeBe[n], 
            Math.abs(Te.dot(OrientedBoundBox._tempV31, OrientedBoundBox._tempV34)) > o + s) return 0;
            for (t = 0; t < 3; t++) for (n = 0; n < 3; n++) {
                var l = (t + 1) % 3, h = (t + 2) % 3, u = (n + 1) % 3, c = (n + 2) % 3;
                if (o = OrientedBoundBox._sizeAe[l] * OrientedBoundBox._tempM1.getElementByRowColumn(h, n) + OrientedBoundBox._sizeAe[h] * OrientedBoundBox._tempM1.getElementByRowColumn(l, n), 
                s = OrientedBoundBox._sizeBe[u] * OrientedBoundBox._tempM1.getElementByRowColumn(t, c) + OrientedBoundBox._sizeBe[c] * OrientedBoundBox._tempM1.getElementByRowColumn(t, u), 
                Math.abs(OrientedBoundBox._vsepAe[h] * OrientedBoundBox._tempM0.getElementByRowColumn(l, n) - OrientedBoundBox._vsepAe[l] * OrientedBoundBox._tempM0.getElementByRowColumn(h, n)) > o + s) return 0;
            }
            return 2;
        }, e.intersectsRay = function(e, t) {
            Te.scale(this.extents, -1, OrientedBoundBox._tempV30), this.transformation.invert(OrientedBoundBox._tempM0), 
            Te.TransformNormal(e.direction, OrientedBoundBox._tempM0, OrientedBoundBox._ray.direction), 
            Te.transformCoordinate(e.origin, OrientedBoundBox._tempM0, OrientedBoundBox._ray.origin), 
            OrientedBoundBox._boxBound1.min = OrientedBoundBox._tempV30, OrientedBoundBox._boxBound1.max = this.extents;
            var n = bt.intersectsRayAndBoxRP(OrientedBoundBox._ray, OrientedBoundBox._boxBound1, t);
            return -1 !== n && Te.transformCoordinate(t, this.transformation, t), n;
        }, e._getLocalCorners = function(e) {
            e.length = 8, OrientedBoundBox._tempV30.x = this.extents.x, OrientedBoundBox._tempV31.y = this.extents.y, 
            OrientedBoundBox._tempV32.z = this.extents.z, Te.add(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV33), 
            Te.add(OrientedBoundBox._tempV33, OrientedBoundBox._tempV32, e[0]), Te.add(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV33), 
            Te.subtract(OrientedBoundBox._tempV33, OrientedBoundBox._tempV32, e[1]), Te.subtract(OrientedBoundBox._tempV31, OrientedBoundBox._tempV30, OrientedBoundBox._tempV33), 
            Te.subtract(OrientedBoundBox._tempV33, OrientedBoundBox._tempV30, e[2]), Te.subtract(OrientedBoundBox._tempV31, OrientedBoundBox._tempV30, OrientedBoundBox._tempV33), 
            Te.add(OrientedBoundBox._tempV33, OrientedBoundBox._tempV32, e[3]), Te.subtract(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV33), 
            Te.add(OrientedBoundBox._tempV33, OrientedBoundBox._tempV32, e[4]), Te.subtract(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV33), 
            Te.subtract(OrientedBoundBox._tempV33, OrientedBoundBox._tempV32, e[5]), Te.scale(e[0], -1, e[6]), 
            Te.subtract(OrientedBoundBox._tempV32, OrientedBoundBox._tempV30, OrientedBoundBox._tempV33), 
            Te.subtract(OrientedBoundBox._tempV33, OrientedBoundBox._tempV31, e[7]);
        }, e.equals = function(e) {
            return this.extents == e.extents && this.transformation == e.transformation;
        }, e.cloneTo = function(e) {
            var t = e;
            this.extents.cloneTo(t.extents), this.transformation.cloneTo(t.transformation);
        }, OrientedBoundBox.createByBoundBox = function(e, t) {
            var n = e.min, i = e.max;
            Te.subtract(i, n, OrientedBoundBox._tempV30), Te.scale(OrientedBoundBox._tempV30, .5, OrientedBoundBox._tempV30), 
            Te.add(n, OrientedBoundBox._tempV30, OrientedBoundBox._tempV31), Te.subtract(i, OrientedBoundBox._tempV31, OrientedBoundBox._tempV32), 
            Ht.translation(OrientedBoundBox._tempV31, OrientedBoundBox._tempM0);
            var r = OrientedBoundBox._tempV32.clone(), a = OrientedBoundBox._tempM0.clone();
            t.extents = r, t.transformation = a;
        }, OrientedBoundBox.createByMinAndMaxVertex = function(e, t) {
            return Te.subtract(t, e, OrientedBoundBox._tempV30), Te.scale(OrientedBoundBox._tempV30, .5, OrientedBoundBox._tempV30), 
            Te.add(e, OrientedBoundBox._tempV30, OrientedBoundBox._tempV31), Te.subtract(t, OrientedBoundBox._tempV31, OrientedBoundBox._tempV32), 
            Ht.translation(OrientedBoundBox._tempV31, OrientedBoundBox._tempM0), new OrientedBoundBox(OrientedBoundBox._tempV32, OrientedBoundBox._tempM0);
        }, OrientedBoundBox._getRows = function(e, t) {
            t.length = 3;
            var n = e.elements;
            t[0].x = n[0], t[0].y = n[1], t[0].z = n[2], t[1].x = n[4], t[1].y = n[5], t[1].z = n[6], 
            t[2].x = n[8], t[2].y = n[9], t[2].z = n[10];
        }, OrientedBoundBox.getObbtoObbMatrix4x4 = function(e, t, n, i) {
            var r = e.transformation, a = t.transformation;
            if (n) {
                OrientedBoundBox._getRows(r, OrientedBoundBox._rows1), OrientedBoundBox._getRows(a, OrientedBoundBox._rows2);
                for (var o = 0; o < 3; o++) for (var s = 0; s < 3; s++) i.setElementByRowColumn(o, s, Te.dot(OrientedBoundBox._rows2[o], OrientedBoundBox._rows1[s]));
                t.getCenter(OrientedBoundBox._tempV30), e.getCenter(OrientedBoundBox._tempV31), 
                Te.subtract(OrientedBoundBox._tempV30, OrientedBoundBox._tempV31, OrientedBoundBox._tempV32);
                var l = i.elements;
                l[12] = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[0]), l[13] = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[1]), 
                l[14] = Te.dot(OrientedBoundBox._tempV32, OrientedBoundBox._rows1[2]), l[15] = 1;
            } else r.invert(OrientedBoundBox._tempM0), Ht.multiply(a, OrientedBoundBox._tempM0, i);
        }, OrientedBoundBox.merge = function(e, t, n) {
            var i = e.extents, r = e.transformation;
            OrientedBoundBox.getObbtoObbMatrix4x4(e, t, n, OrientedBoundBox._tempM0), t._getLocalCorners(OrientedBoundBox._corners), 
            Te.transformCoordinate(OrientedBoundBox._corners[0], OrientedBoundBox._tempM0, OrientedBoundBox._corners[0]), 
            Te.transformCoordinate(OrientedBoundBox._corners[1], OrientedBoundBox._tempM0, OrientedBoundBox._corners[1]), 
            Te.transformCoordinate(OrientedBoundBox._corners[2], OrientedBoundBox._tempM0, OrientedBoundBox._corners[2]), 
            Te.transformCoordinate(OrientedBoundBox._corners[3], OrientedBoundBox._tempM0, OrientedBoundBox._corners[3]), 
            Te.transformCoordinate(OrientedBoundBox._corners[4], OrientedBoundBox._tempM0, OrientedBoundBox._corners[4]), 
            Te.transformCoordinate(OrientedBoundBox._corners[5], OrientedBoundBox._tempM0, OrientedBoundBox._corners[5]), 
            Te.transformCoordinate(OrientedBoundBox._corners[6], OrientedBoundBox._tempM0, OrientedBoundBox._corners[6]), 
            Te.transformCoordinate(OrientedBoundBox._corners[7], OrientedBoundBox._tempM0, OrientedBoundBox._corners[7]), 
            Te.scale(i, -1, OrientedBoundBox._boxBound1.min), i.cloneTo(OrientedBoundBox._boxBound1.max), 
            zt.createfromPoints(OrientedBoundBox._corners, OrientedBoundBox._boxBound2), zt.merge(OrientedBoundBox._boxBound2, OrientedBoundBox._boxBound1, OrientedBoundBox._boxBound3);
            var a = OrientedBoundBox._boxBound3.min, o = OrientedBoundBox._boxBound3.max;
            Te.subtract(o, a, OrientedBoundBox._tempV30), Te.scale(OrientedBoundBox._tempV30, .5, OrientedBoundBox._tempV30), 
            Te.add(a, OrientedBoundBox._tempV30, OrientedBoundBox._tempV32), Te.subtract(o, OrientedBoundBox._tempV32, i), 
            Te.transformCoordinate(OrientedBoundBox._tempV32, r, OrientedBoundBox._tempV33);
        }, i(OrientedBoundBox, [ "_tempV30", function() {
            return this._tempV30 = new Te();
        }, "_tempV31", function() {
            return this._tempV31 = new Te();
        }, "_tempV32", function() {
            return this._tempV32 = new Te();
        }, "_tempV33", function() {
            return this._tempV33 = new Te();
        }, "_tempV34", function() {
            return this._tempV34 = new Te();
        }, "_tempV35", function() {
            return this._tempV35 = new Te();
        }, "_tempV36", function() {
            return this._tempV36 = new Te();
        }, "_tempM0", function() {
            return this._tempM0 = new Ht();
        }, "_tempM1", function() {
            return this._tempM1 = new Ht();
        }, "_corners", function() {
            return this._corners = [ new Te(), new Te(), new Te(), new Te(), new Te(), new Te(), new Te(), new Te() ];
        }, "_rows1", function() {
            return this._rows1 = [ new Te(), new Te(), new Te() ];
        }, "_rows2", function() {
            return this._rows2 = [ new Te(), new Te(), new Te() ];
        }, "_ray", function() {
            return this._ray = new K(new Te(), new Te());
        }, "_boxBound1", function() {
            return this._boxBound1 = new zt(new Te(), new Te());
        }, "_boxBound2", function() {
            return this._boxBound2 = new zt(new Te(), new Te());
        }, "_boxBound3", function() {
            return this._boxBound3 = new zt(new Te(), new Te());
        }, "_vsepAe", function() {
            return this._vsepAe = new Float32Array();
        }, "_sizeBe", function() {
            return this._sizeBe = new Float32Array();
        }, "_sizeAe", function() {
            return this._sizeAe = new Float32Array();
        } ]);
    }(), function() {
        function RenderQueue(e) {
            void 0 === e && (e = !1), this.isTransparent = e, this.elements = [];
        }
        r(RenderQueue, "laya.d3.core.render.RenderQueue");
        var e = RenderQueue.prototype;
        return e._compare = function(e, t) {
            var n = e.material.renderQueue - t.material.renderQueue;
            return 0 === n ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : n;
        }, e._partitionRenderObject = function(e, t) {
            for (var n = this.elements[Math.floor((t + e) / 2)]; e <= t; ) {
                for (;this._compare(this.elements[e], n) < 0; ) e++;
                for (;this._compare(this.elements[t], n) > 0; ) t--;
                if (e < t) {
                    var i = this.elements[e];
                    this.elements[e] = this.elements[t], this.elements[t] = i, e++, t--;
                } else if (e === t) {
                    e++;
                    break;
                }
            }
            return e;
        }, e._quickSort = function(e, t) {
            if (this.elements.length > 1) {
                var n = this._partitionRenderObject(e, t), i = n - 1;
                e < i && this._quickSort(e, i), n < t && this._quickSort(n, t);
            }
        }, e._render = function(e, t, n, i) {
            for (var r = 0, a = this.elements.length; r < a; r++) this.elements[r]._render(e, t, n, i);
        }, e.clear = function() {
            this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
        }, RenderQueue;
    }()), Lt = (function() {
        function TextureMode() {}
        r(TextureMode, "laya.d3.core.TextureMode"), TextureMode.Stretch = 0, TextureMode.Tile = 1;
    }(), function() {
        function HeightfieldColliderShape() {}
        r(HeightfieldColliderShape, "laya.d3.physics.shape.HeightfieldColliderShape");
    }(), function() {
        function ShapeUtils() {}
        return r(ShapeUtils, "laya.d3.core.particleShuriKen.module.shape.ShapeUtils"), ShapeUtils._randomPointUnitArcCircle = function(e, t, n) {
            var i = NaN;
            i = n ? n.getFloat() * e : Math.random() * e, t.x = Math.cos(i), t.y = Math.sin(i);
        }, ShapeUtils._randomPointInsideUnitArcCircle = function(e, t, n) {
            ShapeUtils._randomPointUnitArcCircle(e, t, n);
            var i = NaN;
            i = n ? Math.pow(n.getFloat(), .5) : Math.pow(Math.random(), .5), t.x = t.x * i, 
            t.y = t.y * i;
        }, ShapeUtils._randomPointUnitCircle = function(e, t) {
            var n = NaN;
            n = t ? t.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(n), 
            e.y = Math.sin(n);
        }, ShapeUtils._randomPointInsideUnitCircle = function(e, t) {
            ShapeUtils._randomPointUnitCircle(e);
            var n = NaN;
            n = t ? Math.pow(t.getFloat(), .5) : Math.pow(Math.random(), .5), e.x = e.x * n, 
            e.y = e.y * n;
        }, ShapeUtils._randomPointUnitSphere = function(e, t) {
            var n = NaN, i = NaN;
            t ? (n = e.z = 2 * t.getFloat() - 1, i = t.getFloat() * Math.PI * 2) : (n = e.z = 2 * Math.random() - 1, 
            i = Math.random() * Math.PI * 2);
            var r = Math.sqrt(1 - n * n);
            e.x = r * Math.cos(i), e.y = r * Math.sin(i);
        }, ShapeUtils._randomPointInsideUnitSphere = function(e, t) {
            ShapeUtils._randomPointUnitSphere(e);
            var n = NaN;
            n = t ? Math.pow(t.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3), e.x = e.x * n, 
            e.y = e.y * n, e.z = e.z * n;
        }, ShapeUtils._randomPointInsideHalfUnitBox = function(e, t) {
            t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5, 
            e.y = Math.random() - .5, e.z = Math.random() - .5);
        }, ShapeUtils;
    }()), Ot = function() {
        function VertexElementFormat() {}
        return r(VertexElementFormat, "laya.d3.graphics.VertexElementFormat"), VertexElementFormat.getElementInfos = function(e) {
            var t = VertexElementFormat._elementInfos[e];
            if (t) return t;
            throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }, VertexElementFormat.Single = "single", VertexElementFormat.Vector2 = "vector2", 
        VertexElementFormat.Vector3 = "vector3", VertexElementFormat.Vector4 = "vector4", 
        VertexElementFormat.Color = "color", VertexElementFormat.Byte4 = "byte4", VertexElementFormat.Short2 = "short2", 
        VertexElementFormat.Short4 = "short4", VertexElementFormat.NormalizedShort2 = "normalizedshort2", 
        VertexElementFormat.NormalizedShort4 = "normalizedshort4", VertexElementFormat.HalfVector2 = "halfvector2", 
        VertexElementFormat.HalfVector4 = "halfvector4", i(VertexElementFormat, [ "_elementInfos", function() {
            return this._elementInfos = {
                single: [ 1, 5126, 0 ],
                vector2: [ 2, 5126, 0 ],
                vector3: [ 3, 5126, 0 ],
                vector4: [ 4, 5126, 0 ],
                color: [ 4, 5126, 0 ],
                byte4: [ 4, 5121, 0 ],
                short2: [ 2, 5126, 0 ],
                short4: [ 4, 5126, 0 ],
                normalizedshort2: [ 2, 5126, 0 ],
                normalizedshort4: [ 4, 5126, 0 ],
                halfvector2: [ 2, 5126, 0 ],
                halfvector4: [ 4, 5126, 0 ]
            };
        } ]), VertexElementFormat;
    }(), Pt = function() {
        function RotationOverLifetime(e) {
            this._angularVelocity = null, this.enbale = !1, this._angularVelocity = e;
        }
        r(RotationOverLifetime, "laya.d3.core.particleShuriKen.module.RotationOverLifetime");
        var e = RotationOverLifetime.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.cloneTo = function(e) {
            var t = e;
            this._angularVelocity.cloneTo(t._angularVelocity), t.enbale = this.enbale;
        }, e.clone = function() {
            var e;
            switch (this._angularVelocity.type) {
              case 0:
                e = this._angularVelocity.separateAxes ? ht.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : ht.createByConstant(this._angularVelocity.constant);
                break;

              case 1:
                e = this._angularVelocity.separateAxes ? ht.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : ht.createByGradient(this._angularVelocity.gradient.clone());
                break;

              case 2:
                e = this._angularVelocity.separateAxes ? ht.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : ht.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                break;

              case 3:
                e = this._angularVelocity.separateAxes ? ht.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : ht.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
            }
            var t = new this.constructor(e);
            return t.enbale = this.enbale, t;
        }, a(0, e, "angularVelocity", function() {
            return this._angularVelocity;
        }), RotationOverLifetime;
    }(), Vt = function() {
        function BoundFrustum(e) {
            this._matrix = null, this._near = null, this._far = null, this._left = null, this._right = null, 
            this._top = null, this._bottom = null, this._matrix = e, this._near = new oe(new Te()), 
            this._far = new oe(new Te()), this._left = new oe(new Te()), this._right = new oe(new Te()), 
            this._top = new oe(new Te()), this._bottom = new oe(new Te()), BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        r(BoundFrustum, "laya.d3.math.BoundFrustum");
        var e = BoundFrustum.prototype;
        return e.equalsBoundFrustum = function(e) {
            return this._matrix.equalsOtherMatrix(e.matrix);
        }, e.equalsObj = function(e) {
            if (e instanceof laya.d3.math.BoundFrustum) {
                var t = e;
                return this.equalsBoundFrustum(t);
            }
            return !1;
        }, e.getPlane = function(e) {
            switch (e) {
              case 0:
                return this._near;

              case 1:
                return this._far;

              case 2:
                return this._left;

              case 3:
                return this._right;

              case 4:
                return this._top;

              case 5:
                return this._bottom;

              default:
                return null;
            }
        }, e.getCorners = function(e) {
            BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(e[0]), 
            BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(e[1]), 
            BoundFrustum._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(e[2]), 
            BoundFrustum._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(e[3]), 
            BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(e[4]), 
            BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(e[5]), 
            BoundFrustum._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(e[6]), 
            BoundFrustum._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(e[7]);
        }, e.containsPoint = function(e) {
            for (var t = oe.PlaneIntersectionType_Front, n = oe.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                  case 0:
                    n = bt.intersectsPlaneAndPoint(this._near, e);
                    break;

                  case 1:
                    n = bt.intersectsPlaneAndPoint(this._far, e);
                    break;

                  case 2:
                    n = bt.intersectsPlaneAndPoint(this._left, e);
                    break;

                  case 3:
                    n = bt.intersectsPlaneAndPoint(this._right, e);
                    break;

                  case 4:
                    n = bt.intersectsPlaneAndPoint(this._top, e);
                    break;

                  case 5:
                    n = bt.intersectsPlaneAndPoint(this._bottom, e);
                }
                switch (n) {
                  case oe.PlaneIntersectionType_Back:
                    return 0;

                  case oe.PlaneIntersectionType_Intersecting:
                    t = oe.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
              case oe.PlaneIntersectionType_Intersecting:
                return 2;

              default:
                return 1;
            }
        }, e.containsBoundBox = function(e) {
            for (var t = BoundFrustum._tempV30, n = BoundFrustum._tempV31, i = e.min, r = e.max, a = 1, o = 0; o < 6; o++) {
                var s = this.getPlane(o), l = s.normal;
                if (l.x >= 0 ? (t.x = r.x, n.x = i.x) : (t.x = i.x, n.x = r.x), l.y >= 0 ? (t.y = r.y, 
                n.y = i.y) : (t.y = i.y, n.y = r.y), l.z >= 0 ? (t.z = r.z, n.z = i.z) : (t.z = i.z, 
                n.z = r.z), bt.intersectsPlaneAndPoint(s, t) === oe.PlaneIntersectionType_Back) return 0;
                bt.intersectsPlaneAndPoint(s, n) === oe.PlaneIntersectionType_Back && (a = 2);
            }
            return a;
        }, e.containsBoundSphere = function(e) {
            for (var t = oe.PlaneIntersectionType_Front, n = oe.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                  case 0:
                    n = bt.intersectsPlaneAndSphere(this._near, e);
                    break;

                  case 1:
                    n = bt.intersectsPlaneAndSphere(this._far, e);
                    break;

                  case 2:
                    n = bt.intersectsPlaneAndSphere(this._left, e);
                    break;

                  case 3:
                    n = bt.intersectsPlaneAndSphere(this._right, e);
                    break;

                  case 4:
                    n = bt.intersectsPlaneAndSphere(this._top, e);
                    break;

                  case 5:
                    n = bt.intersectsPlaneAndSphere(this._bottom, e);
                }
                switch (n) {
                  case oe.PlaneIntersectionType_Back:
                    return 0;

                  case oe.PlaneIntersectionType_Intersecting:
                    t = oe.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
              case oe.PlaneIntersectionType_Intersecting:
                return 2;

              default:
                return 1;
            }
        }, a(0, e, "top", function() {
            return this._top;
        }), a(0, e, "matrix", function() {
            return this._matrix;
        }, function(e) {
            this._matrix = e, BoundFrustum._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }), a(0, e, "near", function() {
            return this._near;
        }), a(0, e, "far", function() {
            return this._far;
        }), a(0, e, "left", function() {
            return this._left;
        }), a(0, e, "right", function() {
            return this._right;
        }), a(0, e, "bottom", function() {
            return this._bottom;
        }), BoundFrustum._getPlanesFromMatrix = function(e, t, n, i, r, a, o) {
            var s = e.elements, l = s[0], h = s[1], u = s[2], c = s[3], d = s[4], _ = s[5], f = s[6], m = s[7], p = s[8], T = s[9], S = s[10], E = s[11], v = s[12], g = s[13], x = s[14], M = s[15], y = t.normal;
            y.x = c + u, y.y = m + f, y.z = E + S, t.distance = M + x, t.normalize();
            var D = n.normal;
            D.x = c - u, D.y = m - f, D.z = E - S, n.distance = M - x, n.normalize();
            var R = i.normal;
            R.x = c + l, R.y = m + d, R.z = E + p, i.distance = M + v, i.normalize();
            var C = r.normal;
            C.x = c - l, C.y = m - d, C.z = E - p, r.distance = M - v, r.normalize();
            var I = a.normal;
            I.x = c - h, I.y = m - _, I.z = E - T, a.distance = M - g, a.normalize();
            var A = o.normal;
            A.x = c + h, A.y = m + _, A.z = E + T, o.distance = M + g, o.normalize();
        }, BoundFrustum._get3PlaneInterPoint = function(e, t, n) {
            var i = e.normal, r = t.normal, a = n.normal;
            Te.cross(r, a, BoundFrustum._tempV30), Te.cross(a, i, BoundFrustum._tempV31), Te.cross(i, r, BoundFrustum._tempV32);
            var o = Te.dot(i, BoundFrustum._tempV30), s = Te.dot(r, BoundFrustum._tempV31), l = Te.dot(a, BoundFrustum._tempV32);
            return Te.scale(BoundFrustum._tempV30, -e.distance / o, BoundFrustum._tempV33), 
            Te.scale(BoundFrustum._tempV31, -t.distance / s, BoundFrustum._tempV34), Te.scale(BoundFrustum._tempV32, -n.distance / l, BoundFrustum._tempV35), 
            Te.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36), Te.add(BoundFrustum._tempV35, BoundFrustum._tempV36, BoundFrustum._tempV37), 
            BoundFrustum._tempV37;
        }, i(BoundFrustum, [ "_tempV30", function() {
            return this._tempV30 = new Te();
        }, "_tempV31", function() {
            return this._tempV31 = new Te();
        }, "_tempV32", function() {
            return this._tempV32 = new Te();
        }, "_tempV33", function() {
            return this._tempV33 = new Te();
        }, "_tempV34", function() {
            return this._tempV34 = new Te();
        }, "_tempV35", function() {
            return this._tempV35 = new Te();
        }, "_tempV36", function() {
            return this._tempV36 = new Te();
        }, "_tempV37", function() {
            return this._tempV37 = new Te();
        } ]), BoundFrustum;
    }(), Nt = function() {
        function KeyframeNodeOwner() {
            this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1, 
            this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null, 
            this.crossFixedValue = null;
        }
        return r(KeyframeNodeOwner, "laya.d3.component.KeyframeNodeOwner"), KeyframeNodeOwner.prototype.saveCrossFixedValue = function() {
            var e = this.propertyOwner;
            if (e) switch (this.type) {
              case 0:
                for (var t = this.property, n = t.length - 1, i = 0; i < n && (e = e[t[i]]); i++) ;
                this.crossFixedValue = e[t[n]];
                break;

              case 1:
                var r = e.localPosition;
                this.crossFixedValue || (this.crossFixedValue = new Te()), this.crossFixedValue.x = r.x, 
                this.crossFixedValue.y = r.y, this.crossFixedValue.z = r.z;
                break;

              case 2:
                var a = e.localRotation;
                this.crossFixedValue || (this.crossFixedValue = new he()), this.crossFixedValue.x = a.x, 
                this.crossFixedValue.y = a.y, this.crossFixedValue.z = a.z, this.crossFixedValue.w = a.w;
                break;

              case 3:
                var o = e.localScale;
                this.crossFixedValue || (this.crossFixedValue = new Te()), this.crossFixedValue.x = o.x, 
                this.crossFixedValue.y = o.y, this.crossFixedValue.z = o.z;
                break;

              case 4:
                var s = e.localRotationEuler;
                this.crossFixedValue || (this.crossFixedValue = new Te()), this.crossFixedValue.x = s.x, 
                this.crossFixedValue.y = s.y, this.crossFixedValue.z = s.z;
                break;

              default:
                throw "Animator:unknown type.";
            }
        }, KeyframeNodeOwner;
    }(), Bt = function() {
        function FrustumCulling() {}
        return r(FrustumCulling, "laya.d3.graphics.FrustumCulling"), FrustumCulling.__init__ = function() {
            R.supportWebGLPlusCulling && (FrustumCulling._cullingBufferLength = 0, FrustumCulling._cullingBuffer = new Float32Array(4096));
        }, FrustumCulling._drawTraversalCullingBound = function(e, t) {
            e.length;
            for (var n = e.elements, i = 0, r = e.length; i < r; i++) {
                var a = FrustumCulling._tempColor0;
                a.r = 0, a.g = 1, a.b = 0, a.a = 1, ke._drawBound(t, n[i].bounds._getBoundBox(), a);
            }
        }, FrustumCulling._traversalCulling = function(e, t, n, i) {
            for (var r = i.length, a = i.elements, o = e.boundFrustum, s = e._transform.position, l = 0; l < r; l++) {
                var h = a[l];
                if (e._isLayerVisible(h._owner._layer) && h._enable) if (P.frustumCulling++, !e.useOcclusionCulling || h._needRender(o)) {
                    h._visible = !0;
                    var u = h.bounds;
                    h._distanceForSort = Te.distance(u.getCenter(), s);
                    for (var c = h._renderElements, d = 0, _ = c.length; d < _; d++) {
                        var f = c[d], m = t._getRenderQueue(f.material.renderQueue);
                        m.isTransparent ? f.addToTransparentRenderQueue(n, m) : f.addToOpaqueRenderQueue(n, m);
                    }
                } else h._visible = !1; else h._visible = !1;
            }
        }, FrustumCulling.renderObjectCulling = function(e, t, n, i) {
            var r = 0, a = 0, o = t._opaqueQueue, s = t._transparentQueue;
            o.clear(), s.clear();
            var l = j._managers;
            for (r = 0, a = l.length; r < a; r++) l[r]._clear();
            var h = ee._managers;
            for (r = 0, a = h.length; r < a; r++) h[r]._clear();
            var u = t._octree;
            if (u ? (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(n)) : FrustumCulling._traversalCulling(e, t, n, i), 
            X._config.debugFrustumCulling) {
                var c = t._debugTool;
                c.clear(), u ? (u.drawAllBounds(c), u.drawAllObjects(c)) : FrustumCulling._drawTraversalCullingBound(i, c);
            }
            var d = o.elements.length;
            d > 0 && o._quickSort(0, d - 1), (d = s.elements.length) > 0 && s._quickSort(0, d - 1);
        }, FrustumCulling.renderObjectCullingNative = function(e, t, n, i) {
            var r = 0, a = 0, o = 0, s = 0, l = t._opaqueQueue, h = t._transparentQueue;
            l.clear(), h.clear();
            var u = j._managers;
            for (r = 0, a = u.length; r < a; r++) u[r]._clear();
            var c = ee._managers;
            for (r = 0, a = c.length; r < a; r++) c[r]._clear();
            var d = i.length, _ = i.elements;
            for (r = 0; r < d; r++) _[r].bounds;
            e.boundFrustum;
            FrustumCulling.cullingNative(e._boundFrustumBuffer, FrustumCulling._cullingBuffer, t._cullingBufferIndices, d, t._cullingBufferResult);
            var f = n.camera._transform.position;
            for (r = 0; r < d; r++) {
                var m = _[r];
                if (e._isLayerVisible(m._owner._layer) && m._enable && t._cullingBufferResult[r]) {
                    m._visible = !0, m._distanceForSort = Te.distance(m.bounds.getCenter(), f);
                    var p = m._renderElements;
                    for (o = 0, s = p.length; o < s; o++) {
                        var T = p[o], S = t._getRenderQueue(T.material.renderQueue);
                        S.isTransparent ? T.addToTransparentRenderQueue(n, S) : T.addToOpaqueRenderQueue(n, S);
                    }
                } else m._visible = !1;
            }
            var E = l.elements.length;
            E > 0 && l._quickSort(0, E - 1), (E = h.elements.length) > 0 && h._quickSort(0, E - 1);
        }, FrustumCulling.cullingNative = function(e, t, n, i, r) {
            return E.instance.culling(e, t, n, i, r);
        }, FrustumCulling._cullingBufferLength = 0, FrustumCulling._cullingBuffer = null, 
        i(FrustumCulling, [ "_tempVector3", function() {
            return this._tempVector3 = new Te();
        }, "_tempColor0", function() {
            return this._tempColor0 = new Me();
        } ]), FrustumCulling;
    }(), wt = function() {
        function AnimatorControllerLayer(e) {
            this._defaultState = null, this._statesMap = {}, this.playOnWake = !0, this._playType = -1, 
            this._crossMark = 0, this._crossDuration = -1, this._crossNodesOwnersIndicesMap = {}, 
            this._crossNodesOwnersCount = 0, this._crossNodesOwners = [], this._currentPlayState = null, 
            this._states = [], this._playStateInfo = new Ee(), this._crossPlayStateInfo = new Ee(), 
            this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], this.name = e, 
            this.defaultWeight = 1, this.blendingMode = laya.d3.component.AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
        }
        r(AnimatorControllerLayer, "laya.d3.component.AnimatorControllerLayer");
        var e = AnimatorControllerLayer.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.getAnimatorState = function(e) {
            var t = this._statesMap[e];
            return t || null;
        }, e.destroy = function() {
            this._statesMap = null, this._states = null, this._playStateInfo = null, this._crossPlayStateInfo = null, 
            this._defaultState = null;
        }, e.cloneTo = function(e) {
            var t = e;
            t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight, 
            t.playOnWake = this.playOnWake;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "defaultState", function() {
            return this._defaultState;
        }, function(e) {
            this._defaultState = e, this._statesMap[e.name] = e;
        }), AnimatorControllerLayer.BLENDINGMODE_OVERRIDE = 0, AnimatorControllerLayer.BLENDINGMODE_ADDTIVE = 1, 
        AnimatorControllerLayer;
    }(), bt = function() {
        function CollisionUtils() {}
        return r(CollisionUtils, "laya.d3.math.CollisionUtils"), CollisionUtils.distancePlaneToPoint = function(e, t) {
            return Te.dot(e.normal, t) - e.distance;
        }, CollisionUtils.distanceBoxToPoint = function(e, t) {
            var n = e.min, i = n.x, r = n.y, a = n.z, o = e.max, s = o.x, l = o.y, h = o.z, u = t.x, c = t.y, d = t.z, _ = 0;
            return u < i && (_ += (i - u) * (i - u)), u > s && (_ += (s - u) * (s - u)), c < r && (_ += (r - c) * (r - c)), 
            c > l && (_ += (l - c) * (l - c)), d < a && (_ += (a - d) * (a - d)), d > h && (_ += (h - d) * (h - d)), 
            Math.sqrt(_);
        }, CollisionUtils.distanceBoxToBox = function(e, t) {
            var n = e.min, i = n.x, r = n.y, a = n.z, o = e.max, s = o.x, l = o.y, h = o.z, u = t.min, c = u.x, d = u.y, _ = u.z, f = t.max, m = f.x, p = f.y, T = f.z, S = 0, E = NaN;
            return i > m ? S += (E = i - m) * E : c > s && (S += (E = c - s) * E), r > p ? S += (E = r - p) * E : d > l && (S += (E = d - l) * E), 
            a > T ? S += (E = a - T) * E : _ > h && (S += (E = _ - h) * E), Math.sqrt(S);
        }, CollisionUtils.distanceSphereToPoint = function(e, t) {
            var n = Math.sqrt(Te.distanceSquared(e.center, t));
            return n -= e.radius, Math.max(n, 0);
        }, CollisionUtils.distanceSphereToSphere = function(e, t) {
            var n = Math.sqrt(Te.distanceSquared(e.center, t.center));
            return n -= e.radius + t.radius, Math.max(n, 0);
        }, CollisionUtils.intersectsRayAndTriangleRD = function(e, t, n, i, r) {
            var a = e.origin, o = a.x, s = a.y, l = a.z, h = e.direction, u = h.x, c = h.y, d = h.z, _ = t.x, f = t.y, m = t.z, p = n.x, T = n.y, S = n.z, E = i.x, v = i.y, g = i.z, x = CollisionUtils._tempV30.x, M = CollisionUtils._tempV30.y, y = CollisionUtils._tempV30.z;
            x = p - _, M = T - f, y = S - m;
            var D = CollisionUtils._tempV31.x, R = CollisionUtils._tempV31.y, C = CollisionUtils._tempV31.z;
            D = E - _, R = v - f, C = g - m;
            var I = CollisionUtils._tempV32.x, A = CollisionUtils._tempV32.y, L = CollisionUtils._tempV32.z, O = x * (I = c * C - d * R) + M * (A = d * D - u * C) + y * (L = u * R - c * D);
            if (ie.isZero(O)) return 0, !1;
            var P = 1 / O, V = CollisionUtils._tempV33.x, N = CollisionUtils._tempV33.y, B = CollisionUtils._tempV33.z, w = (V = o - _) * I + (N = s - f) * A + (B = l - m) * L;
            if ((w *= P) < 0 || w > 1) return 0, !1;
            var b = CollisionUtils._tempV34.x, F = CollisionUtils._tempV34.y, U = CollisionUtils._tempV34.z, z = u * (b = N * y - B * M) + c * (F = B * x - V * y) + d * (U = V * M - N * x);
            if ((z *= P) < 0 || w + z > 1) return 0, !1;
            var G = D * b + R * F + C * U;
            return (G *= P) < 0 ? (0, !1) : (G, !0);
        }, CollisionUtils.intersectsRayAndTriangleRP = function(e, t, n, i, r) {
            return CollisionUtils.intersectsRayAndTriangleRD(e, t, n, i, NaN) ? (Te.scale(e.direction, NaN, CollisionUtils._tempV30), 
            Te.add(e.origin, CollisionUtils._tempV30, r), !0) : (r = Te._ZERO, !1);
        }, CollisionUtils.intersectsRayAndPoint = function(e, t) {
            Te.subtract(e.origin, t, CollisionUtils._tempV30);
            var n = Te.dot(CollisionUtils._tempV30, e.direction), i = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - ie.zeroTolerance;
            return !(i > 0 && n > 0) && !(n * n - i < 0);
        }, CollisionUtils.intersectsRayAndRay = function(e, t, n) {
            var i = e.origin, r = i.x, a = i.y, o = i.z, s = e.direction, l = s.x, h = s.y, u = s.z, c = t.origin, d = c.x, _ = c.y, f = c.z, m = t.direction, p = m.x, T = m.y, S = m.z;
            Te.cross(s, m, CollisionUtils._tempV30);
            var E = CollisionUtils._tempV30, v = Te.scalarLength(CollisionUtils._tempV30);
            if (ie.isZero(v) && ie.nearEqual(d, r) && ie.nearEqual(_, a) && ie.nearEqual(f, o)) return Te._ZERO, 
            !0;
            v *= v;
            var g = d - r, x = _ - a, M = f - o, y = p, D = T, R = S, C = E.x, I = E.y, A = E.z, L = (g * D * A + x * R * C + M * y * I - g * R * I - x * y * A - M * D * C) / v;
            D = h, R = u, y = l;
            Te.scale(s, L, CollisionUtils._tempV30), Te.scale(m, L, CollisionUtils._tempV31), 
            Te.add(i, CollisionUtils._tempV30, CollisionUtils._tempV32), Te.add(c, CollisionUtils._tempV31, CollisionUtils._tempV33);
            var O = CollisionUtils._tempV32, P = CollisionUtils._tempV33;
            return ie.nearEqual(P.x, O.x) && ie.nearEqual(P.y, O.y) && ie.nearEqual(P.z, O.z) ? (CollisionUtils._tempV32, 
            !0) : (Te._ZERO, !1);
        }, CollisionUtils.intersectsPlaneAndTriangle = function(e, t, n, i) {
            var r = CollisionUtils.intersectsPlaneAndPoint(e, t), a = CollisionUtils.intersectsPlaneAndPoint(e, n), o = CollisionUtils.intersectsPlaneAndPoint(e, i);
            return r == oe.PlaneIntersectionType_Front && a == oe.PlaneIntersectionType_Front && o == oe.PlaneIntersectionType_Front ? oe.PlaneIntersectionType_Front : r == oe.PlaneIntersectionType_Back && a == oe.PlaneIntersectionType_Back && o == oe.PlaneIntersectionType_Back ? oe.PlaneIntersectionType_Back : oe.PlaneIntersectionType_Intersecting;
        }, CollisionUtils.intersectsRayAndPlaneRD = function(e, t, n) {
            var i = t.normal, r = Te.dot(i, e.direction);
            if (ie.isZero(r)) return 0, !1;
            var a = Te.dot(i, e.origin);
            return !((-t.distance - a) / r < 0) || (0, !1);
        }, CollisionUtils.intersectsRayAndPlaneRP = function(e, t, n) {
            return CollisionUtils.intersectsRayAndPlaneRD(e, t, NaN) ? (Te.scale(e.direction, NaN, CollisionUtils._tempV30), 
            Te.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31, 
            !0) : (Te._ZERO, !1);
        }, CollisionUtils.intersectsRayAndBoxRD = function(e, t) {
            var n = e.origin, i = n.x, r = n.y, a = n.z, o = e.direction, s = o.x, l = o.y, h = o.z, u = t.min, c = u.x, d = u.y, _ = u.z, f = t.max, m = f.x, p = f.y, T = f.z, S = 0, E = ie.MaxValue;
            if (ie.isZero(s)) {
                if (i < c || i > m) return -1;
            } else {
                var v = 1 / s, g = (c - i) * v, x = (m - i) * v;
                if (g > x) {
                    var M = g;
                    g = x, x = M;
                }
                if ((S = Math.max(g, S)) > (E = Math.min(x, E))) return -1;
            }
            if (ie.isZero(l)) {
                if (r < d || r > p) return -1;
            } else {
                var y = 1 / l, D = (d - r) * y, R = (p - r) * y;
                if (D > R) {
                    var C = D;
                    D = R, R = C;
                }
                if ((S = Math.max(D, S)) > (E = Math.min(R, E))) return -1;
            }
            if (ie.isZero(h)) {
                if (a < _ || a > T) return -1;
            } else {
                var I = 1 / h, A = (_ - a) * I, L = (T - a) * I;
                if (A > L) {
                    var O = A;
                    A = L, L = O;
                }
                if ((S = Math.max(A, S)) > (E = Math.min(L, E))) return -1;
            }
            return S;
        }, CollisionUtils.intersectsRayAndBoxRP = function(e, t, n) {
            var i = CollisionUtils.intersectsRayAndBoxRD(e, t);
            return -1 === i ? (Te._ZERO.cloneTo(n), i) : (Te.scale(e.direction, i, CollisionUtils._tempV30), 
            Te.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(n), 
            i);
        }, CollisionUtils.intersectsRayAndSphereRD = function(e, t) {
            var n = t.radius;
            Te.subtract(e.origin, t.center, CollisionUtils._tempV30);
            var i = Te.dot(CollisionUtils._tempV30, e.direction), r = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - n * n;
            if (r > 0 && i > 0) return -1;
            var a = i * i - r;
            if (a < 0) return -1;
            var o = -i - Math.sqrt(a);
            return o < 0 && (o = 0), o;
        }, CollisionUtils.intersectsRayAndSphereRP = function(e, t, n) {
            var i = CollisionUtils.intersectsRayAndSphereRD(e, t);
            return -1 === i ? (Te._ZERO.cloneTo(n), i) : (Te.scale(e.direction, i, CollisionUtils._tempV30), 
            Te.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(n), 
            i);
        }, CollisionUtils.intersectsSphereAndTriangle = function(e, t, n, i) {
            var r = e.center, a = e.radius;
            return CollisionUtils.closestPointPointTriangle(r, t, n, i, CollisionUtils._tempV30), 
            Te.subtract(CollisionUtils._tempV30, r, CollisionUtils._tempV31), Te.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <= a * a;
        }, CollisionUtils.intersectsPlaneAndPoint = function(e, t) {
            var n = Te.dot(e.normal, t) + e.distance;
            return n > 0 ? oe.PlaneIntersectionType_Front : n < 0 ? oe.PlaneIntersectionType_Back : oe.PlaneIntersectionType_Intersecting;
        }, CollisionUtils.intersectsPlaneAndPlane = function(e, t) {
            Te.cross(e.normal, t.normal, CollisionUtils._tempV30);
            var n = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
            return !ie.isZero(n);
        }, CollisionUtils.intersectsPlaneAndPlaneRL = function(e, t, n) {
            var i = e.normal, r = t.normal;
            Te.cross(i, r, CollisionUtils._tempV34);
            var a = Te.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
            return !ie.isZero(a) && (Te.scale(r, e.distance, CollisionUtils._tempV30), Te.scale(i, t.distance, CollisionUtils._tempV31), 
            Te.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32), 
            Te.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33), 
            Te.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34), new K(CollisionUtils._tempV33, CollisionUtils._tempV34), 
            !0);
        }, CollisionUtils.intersectsPlaneAndBox = function(e, t) {
            var n = e.distance, i = e.normal, r = i.x, a = i.y, o = i.z, s = t.min, l = s.x, h = s.y, u = s.z, c = t.max, d = c.x, _ = c.y, f = c.z;
            CollisionUtils._tempV30.x = r > 0 ? l : d, CollisionUtils._tempV30.y = a > 0 ? h : _, 
            CollisionUtils._tempV30.z = o > 0 ? u : f, CollisionUtils._tempV31.x = r > 0 ? d : l, 
            CollisionUtils._tempV31.y = a > 0 ? _ : h, CollisionUtils._tempV31.z = o > 0 ? f : u;
            var m = Te.dot(i, CollisionUtils._tempV30);
            return m + n > 0 ? oe.PlaneIntersectionType_Front : (m = Te.dot(i, CollisionUtils._tempV31)) + n < 0 ? oe.PlaneIntersectionType_Back : oe.PlaneIntersectionType_Intersecting;
        }, CollisionUtils.intersectsPlaneAndSphere = function(e, t) {
            var n = t.radius, i = Te.dot(e.normal, t.center) + e.distance;
            return i > n ? oe.PlaneIntersectionType_Front : i < -n ? oe.PlaneIntersectionType_Back : oe.PlaneIntersectionType_Intersecting;
        }, CollisionUtils.intersectsBoxAndBox = function(e, t) {
            var n = e.min, i = e.max, r = t.min, a = t.max;
            return !(n.x > a.x || r.x > i.x) && (!(n.y > a.y || r.y > i.y) && !(n.z > a.z || r.z > i.z));
        }, CollisionUtils.intersectsBoxAndSphere = function(e, t) {
            var n = t.center, i = t.radius;
            return Te.Clamp(n, e.min, e.max, CollisionUtils._tempV30), Te.distanceSquared(n, CollisionUtils._tempV30) <= i * i;
        }, CollisionUtils.intersectsSphereAndSphere = function(e, t) {
            var n = e.radius + t.radius;
            return Te.distanceSquared(e.center, t.center) <= n * n;
        }, CollisionUtils.boxContainsPoint = function(e, t) {
            var n = e.min, i = e.max;
            return n.x <= t.x && i.x >= t.x && n.y <= t.y && i.y >= t.y && n.z <= t.z && i.z >= t.z ? 1 : 0;
        }, CollisionUtils.boxContainsBox = function(e, t) {
            var n = e.min, i = n.x, r = n.y, a = n.z, o = e.max, s = o.x, l = o.y, h = o.z, u = t.min, c = u.x, d = u.y, _ = u.z, f = t.max, m = f.x, p = f.y, T = f.z;
            return s < c || i > m ? 0 : l < d || r > p ? 0 : h < _ || a > T ? 0 : i <= c && m <= s && r <= d && p <= l && a <= _ && T <= h ? 1 : 2;
        }, CollisionUtils.boxContainsSphere = function(e, t) {
            var n = e.min, i = n.x, r = n.y, a = n.z, o = e.max, s = o.x, l = o.y, h = o.z, u = t.center, c = u.x, d = u.y, _ = u.z, f = t.radius;
            return Te.Clamp(u, n, o, CollisionUtils._tempV30), Te.distanceSquared(u, CollisionUtils._tempV30) > f * f ? 0 : i + f <= c && c <= s - f && s - i > f && r + f <= d && d <= l - f && l - r > f && a + f <= _ && _ <= h - f && h - a > f ? 1 : 2;
        }, CollisionUtils.sphereContainsPoint = function(e, t) {
            return Te.distanceSquared(t, e.center) <= e.radius * e.radius ? 1 : 0;
        }, CollisionUtils.sphereContainsTriangle = function(e, t, n, i) {
            var r = CollisionUtils.sphereContainsPoint(e, t), a = CollisionUtils.sphereContainsPoint(e, n), o = CollisionUtils.sphereContainsPoint(e, i);
            return 1 == r && 1 == a && 1 == o ? 1 : CollisionUtils.intersectsSphereAndTriangle(e, t, n, i) ? 2 : 0;
        }, CollisionUtils.sphereContainsBox = function(e, t) {
            var n = e.center, i = n.x, r = n.y, a = n.z, o = e.radius, s = t.min, l = s.x, h = s.y, u = s.z, c = t.max, d = c.x, _ = c.y, f = c.z, m = CollisionUtils._tempV30;
            m.x, m.y, m.z;
            if (!CollisionUtils.intersectsBoxAndSphere(t, e)) return 0;
            var p = o * o;
            return i - l, r - _, a - f, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - d, 
            r - _, a - f, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - d, 
            r - h, a - f, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - l, 
            r - h, a - f, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - l, 
            r - _, a - u, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - d, 
            r - _, a - u, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - d, 
            r - h, a - u, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : (i - l, 
            r - h, a - u, Te.scalarLengthSquared(CollisionUtils._tempV30) > p ? 2 : 1)))))));
        }, CollisionUtils.sphereContainsSphere = function(e, t) {
            var n = e.radius, i = t.radius, r = Te.distance(e.center, t.center);
            return n + i < r ? 0 : n - i < r ? 2 : 1;
        }, CollisionUtils.closestPointPointTriangle = function(e, t, n, i, r) {
            Te.subtract(n, t, CollisionUtils._tempV30), Te.subtract(i, t, CollisionUtils._tempV31), 
            Te.subtract(e, t, CollisionUtils._tempV32), Te.subtract(e, n, CollisionUtils._tempV33), 
            Te.subtract(e, i, CollisionUtils._tempV34);
            var a = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV32), o = Te.dot(CollisionUtils._tempV31, CollisionUtils._tempV32), s = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV33), l = Te.dot(CollisionUtils._tempV31, CollisionUtils._tempV33), h = Te.dot(CollisionUtils._tempV30, CollisionUtils._tempV34), u = Te.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
            if (a <= 0 && o <= 0) t.cloneTo(r); else if (s >= 0 && l <= s) n.cloneTo(r); else {
                var c = a * l - s * o;
                if (c <= 0 && a >= 0 && s <= 0) {
                    var d = a / (a - s);
                    return Te.scale(CollisionUtils._tempV30, d, r), void Te.add(t, r, r);
                }
                if (u >= 0 && h <= u) i.cloneTo(r); else {
                    var _ = h * o - a * u;
                    if (_ <= 0 && o >= 0 && u <= 0) {
                        var f = o / (o - u);
                        return Te.scale(CollisionUtils._tempV31, f, r), void Te.add(t, r, r);
                    }
                    var m = s * u - h * l;
                    if (m <= 0 && l - s >= 0 && h - u >= 0) {
                        var p = (l - s) / (l - s + (h - u));
                        return Te.subtract(i, n, r), Te.scale(r, p, r), void Te.add(n, r, r);
                    }
                    var T = 1 / (m + _ + c), S = _ * T, E = c * T;
                    Te.scale(CollisionUtils._tempV30, S, CollisionUtils._tempV35), Te.scale(CollisionUtils._tempV31, E, CollisionUtils._tempV36), 
                    Te.add(CollisionUtils._tempV35, CollisionUtils._tempV36, r), Te.add(t, r, r);
                }
            }
        }, CollisionUtils.closestPointPlanePoint = function(e, t, n) {
            var i = e.normal, r = Te.dot(i, t) - e.distance;
            Te.scale(i, r, CollisionUtils._tempV30), Te.subtract(t, CollisionUtils._tempV30, n);
        }, CollisionUtils.closestPointBoxPoint = function(e, t, n) {
            Te.max(t, e.min, CollisionUtils._tempV30), Te.min(CollisionUtils._tempV30, e.max, n);
        }, CollisionUtils.closestPointSpherePoint = function(e, t, n) {
            var i = e.center;
            Te.subtract(t, i, n), Te.normalize(n, n), Te.scale(n, e.radius, n), Te.add(n, i, n);
        }, CollisionUtils.closestPointSphereSphere = function(e, t, n) {
            var i = e.center;
            Te.subtract(t.center, i, n), Te.normalize(n, n), Te.scale(n, e.radius, n), Te.add(n, i, n);
        }, i(CollisionUtils, [ "_tempV30", function() {
            return this._tempV30 = new Te();
        }, "_tempV31", function() {
            return this._tempV31 = new Te();
        }, "_tempV32", function() {
            return this._tempV32 = new Te();
        }, "_tempV33", function() {
            return this._tempV33 = new Te();
        }, "_tempV34", function() {
            return this._tempV34 = new Te();
        }, "_tempV35", function() {
            return this._tempV35 = new Te();
        }, "_tempV36", function() {
            return this._tempV36 = new Te();
        } ]), CollisionUtils;
    }(), Ft = function() {
        function Matrix3x3() {
            var e = this.elements = new Float32Array(9);
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
            e[8] = 1;
        }
        r(Matrix3x3, "laya.d3.math.Matrix3x3");
        var e = Matrix3x3.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.determinant = function() {
            var e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], a = e[4], o = e[5], s = e[6], l = e[7], h = e[8];
            return t * (h * a - o * l) + n * (-h * r + o * s) + i * (l * r - a * s);
        }, e.translate = function(e, t) {
            var n = t.elements, i = this.elements, r = i[0], a = i[1], o = i[2], s = i[3], l = i[4], h = i[5], u = i[6], c = i[7], d = i[8], _ = e.x, f = e.y;
            n[0] = r, n[1] = a, n[2] = o, n[3] = s, n[4] = l, n[5] = h, n[6] = _ * r + f * s + u, 
            n[7] = _ * a + f * l + c, n[8] = _ * o + f * h + d;
        }, e.rotate = function(e, t) {
            var n = t.elements, i = this.elements, r = i[0], a = i[1], o = i[2], s = i[3], l = i[4], h = i[5], u = i[6], c = i[7], d = i[8], _ = Math.sin(e), f = Math.cos(e);
            n[0] = f * r + _ * s, n[1] = f * a + _ * l, n[2] = f * o + _ * h, n[3] = f * s - _ * r, 
            n[4] = f * l - _ * a, n[5] = f * h - _ * o, n[6] = u, n[7] = c, n[8] = d;
        }, e.scale = function(e, t) {
            var n = t.elements, i = this.elements, r = e.x, a = e.y;
            n[0] = r * i[0], n[1] = r * i[1], n[2] = r * i[2], n[3] = a * i[3], n[4] = a * i[4], 
            n[5] = a * i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8];
        }, e.invert = function(e) {
            var t = e.elements, n = this.elements, i = n[0], r = n[1], a = n[2], o = n[3], s = n[4], l = n[5], h = n[6], u = n[7], c = n[8], d = c * s - l * u, _ = -c * o + l * h, f = u * o - s * h, m = i * d + r * _ + a * f;
            m || (e = null), m = 1 / m, t[0] = d * m, t[1] = (-c * r + a * u) * m, t[2] = (l * r - a * s) * m, 
            t[3] = _ * m, t[4] = (c * i - a * h) * m, t[5] = (-l * i + a * o) * m, t[6] = f * m, 
            t[7] = (-u * i + r * h) * m, t[8] = (s * i - r * o) * m;
        }, e.transpose = function(e) {
            var t = e.elements, n = this.elements;
            if (e === this) {
                var i = n[1], r = n[2], a = n[5];
                t[1] = n[3], t[2] = n[6], t[3] = i, t[5] = n[7], t[6] = r, t[7] = a;
            } else t[0] = n[0], t[1] = n[3], t[2] = n[6], t[3] = n[1], t[4] = n[4], t[5] = n[7], 
            t[6] = n[2], t[7] = n[5], t[8] = n[8];
        }, e.identity = function() {
            var e = this.elements;
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, 
            e[8] = 1;
        }, e.cloneTo = function(e) {
            var t, n, i;
            if ((n = this.elements) !== (i = e.elements)) for (t = 0; t < 9; ++t) i[t] = n[t];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, Matrix3x3.createFromTranslation = function(e, t) {
            t.elements;
            t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e.x, t[7] = e.y, 
            t[8] = 1;
        }, Matrix3x3.createFromRotation = function(e, t) {
            var n = t.elements, i = Math.sin(e), r = Math.cos(e);
            n[0] = r, n[1] = i, n[2] = 0, n[3] = -i, n[4] = r, n[5] = 0, n[6] = 0, n[7] = 0, 
            n[8] = 1;
        }, Matrix3x3.createFromScaling = function(e, t) {
            var n = t.elements;
            n[0] = e.x, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = e.y, n[5] = 0, n[6] = 0, n[7] = 0, 
            n[8] = 1;
        }, Matrix3x3.createFromMatrix4x4 = function(e, t) {
            t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], 
            t[7] = e[9], t[8] = e[10];
        }, Matrix3x3.multiply = function(e, t, n) {
            var i = n.elements, r = e.elements, a = t.elements, o = r[0], s = r[1], l = r[2], h = r[3], u = r[4], c = r[5], d = r[6], _ = r[7], f = r[8], m = a[0], p = a[1], T = a[2], S = a[3], E = a[4], v = a[5], g = a[6], x = a[7], M = a[8];
            i[0] = m * o + p * h + T * d, i[1] = m * s + p * u + T * _, i[2] = m * l + p * c + T * f, 
            i[3] = S * o + E * h + v * d, i[4] = S * s + E * u + v * _, i[5] = S * l + E * c + v * f, 
            i[6] = g * o + x * h + M * d, i[7] = g * s + x * u + M * _, i[8] = g * l + x * c + M * f;
        }, Matrix3x3.lookAt = function(e, t, n, i) {
            Te.subtract(e, t, Matrix3x3._tempV30), Te.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30), 
            Te.cross(n, Matrix3x3._tempV30, Matrix3x3._tempV31), Te.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31), 
            Te.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
            var r = Matrix3x3._tempV30, a = Matrix3x3._tempV31, o = Matrix3x3._tempV32, s = i.elements;
            s[0] = a.x, s[3] = a.y, s[6] = a.z, s[1] = o.x, s[4] = o.y, s[7] = o.z, s[2] = r.x, 
            s[5] = r.y, s[8] = r.z;
        }, Matrix3x3.DEFAULT = new Matrix3x3(), i(Matrix3x3, [ "_tempV30", function() {
            return this._tempV30 = new Te();
        }, "_tempV31", function() {
            return this._tempV31 = new Te();
        }, "_tempV32", function() {
            return this._tempV32 = new Te();
        } ]), Matrix3x3;
    }(), Ut = function() {
        function Physics3DUtils() {}
        return r(Physics3DUtils, "laya.d3.utils.Physics3DUtils"), Physics3DUtils.setColliderCollision = function(e, t, n) {}, 
        Physics3DUtils.getIColliderCollision = function(e, t) {
            return !1;
        }, Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER = 2, 
        Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER = 8, 
        Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER = 32, 
        Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128, 
        Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512, 
        Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048, 
        Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192, 
        Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768, 
        Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER = -1, i(Physics3DUtils, [ "gravity", function() {
            return this.gravity = new Te(0, -9.81, 0);
        } ]), Physics3DUtils;
    }(), zt = function() {
        function BoundBox(e, t) {
            this.min = null, this.max = null, this.min = e, this.max = t;
        }
        r(BoundBox, "laya.d3.math.BoundBox");
        var e = BoundBox.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e._rotateExtents = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = t.elements;
            n.x = Math.abs(o[0] * i) + Math.abs(o[4] * r) + Math.abs(o[8] * a), n.y = Math.abs(o[1] * i) + Math.abs(o[5] * r) + Math.abs(o[9] * a), 
            n.z = Math.abs(o[2] * i) + Math.abs(o[6] * r) + Math.abs(o[10] * a);
        }, e.getCorners = function(e) {
            e.length = 8;
            var t = this.min.x, n = this.min.y, i = this.min.z, r = this.max.x, a = this.max.y, o = this.max.z;
            e[0] = new Te(t, a, o), e[1] = new Te(r, a, o), e[2] = new Te(r, n, o), e[3] = new Te(t, n, o), 
            e[4] = new Te(t, a, i), e[5] = new Te(r, a, i), e[6] = new Te(r, n, i), e[7] = new Te(t, n, i);
        }, e.getCenter = function(e) {
            Te.add(this.min, this.max, e), Te.scale(e, .5, e);
        }, e.getExtent = function(e) {
            Te.subtract(this.max, this.min, e), Te.scale(e, .5, e);
        }, e.setCenterAndExtent = function(e, t) {
            Te.subtract(e, t, this.min), Te.add(e, t, this.max);
        }, e.tranform = function(e, t) {
            var n = BoundBox._tempVector30, i = BoundBox._tempVector31;
            this.getCenter(n), this.getExtent(i), Te.transformCoordinate(n, e, n), this._rotateExtents(i, e, i), 
            t.setCenterAndExtent(n, i);
        }, e.toDefault = function() {
            this.min.toDefault(), this.max.toDefault();
        }, e.cloneTo = function(e) {
            var t = e;
            this.min.cloneTo(t.min), this.max.cloneTo(t.max);
        }, e.clone = function() {
            var e = new this.constructor(new Te(), new Te());
            return this.cloneTo(e), e;
        }, BoundBox.createfromPoints = function(e, t) {
            if (null == e) throw new Error("points");
            var n = t.min, i = t.max;
            n.x = Number.MAX_VALUE, n.y = Number.MAX_VALUE, n.z = Number.MAX_VALUE, i.x = -Number.MAX_VALUE, 
            i.y = -Number.MAX_VALUE, i.z = -Number.MAX_VALUE;
            for (var r = 0, a = e.length; r < a; ++r) Te.min(n, e[r], n), Te.max(i, e[r], i);
        }, BoundBox.merge = function(e, t, n) {
            Te.min(e.min, t.min, n.min), Te.max(e.max, t.max, n.max);
        }, i(BoundBox, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        } ]), BoundBox;
    }(), Gt = function() {
        function AnimatorState() {
            this.speed = 1, this.clipStart = 0, this.clipEnd = 1, this._nodeOwners = [];
        }
        r(AnimatorState, "laya.d3.component.AnimatorState");
        var e = AnimatorState.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e._resetFrameIndices = function() {
            for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this._currentFrameIndices[e] = -1;
        }, e.addScript = function(e) {
            var t = new e();
            return this._scripts = this._scripts || [], this._scripts.push(t), t;
        }, e.getScript = function(e) {
            if (this._scripts) for (var t = 0, i = this._scripts.length; t < i; t++) {
                var r = this._scripts[t];
                if (n.__typeof(r, e)) return r;
            }
            return null;
        }, e.getScripts = function(e) {
            var t;
            if (this._scripts) for (var i = 0, r = this._scripts.length; i < r; i++) {
                var a = this._scripts[i];
                n.__typeof(a, e) && (t = t || []).push(a);
            }
            return t;
        }, e.cloneTo = function(e) {
            var t = e;
            t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd, 
            t.clip = this._clip;
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, e, "clip", function() {
            return this._clip;
        }, function(e) {
            this._clip = e, this._currentFrameIndices = new Int16Array(e._nodes.count), this._resetFrameIndices();
        }), AnimatorState;
    }(), Ht = (function() {
        function TextMesh() {
            this._vertices = null, this._vertexBuffer = null, this._text = null, this._fontSize = 0, 
            this._color = null;
        }
        r(TextMesh, "laya.d3.text.TextMesh");
        var e = TextMesh.prototype;
        e._createVertexBuffer = function(e) {}, e._resizeVertexBuffer = function(e) {}, 
        e._addChar = function() {}, a(0, e, "text", function() {
            return this._text;
        }, function(e) {
            this._text = e;
        }), a(0, e, "fontSize", function() {
            return this._fontSize;
        }, function(e) {
            this._fontSize = e;
        }), a(0, e, "color", function() {
            return this._color;
        }, function(e) {
            this._color = e;
        }), TextMesh._indexBuffer = null;
    }(), function() {
        function Matrix4x4(e, t, n, i, r, a, o, s, l, h, u, c, d, _, f, m, p) {
            void 0 === e && (e = 1), void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 0), 
            void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === o && (o = 0), void 0 === s && (s = 0), 
            void 0 === l && (l = 0), void 0 === h && (h = 0), void 0 === u && (u = 1), void 0 === c && (c = 0), 
            void 0 === d && (d = 0), void 0 === _ && (_ = 0), void 0 === f && (f = 0), void 0 === m && (m = 1);
            var T = this.elements = p || new Float32Array(16);
            T[0] = e, T[1] = t, T[2] = n, T[3] = i, T[4] = r, T[5] = a, T[6] = o, T[7] = s, 
            T[8] = l, T[9] = h, T[10] = u, T[11] = c, T[12] = d, T[13] = _, T[14] = f, T[15] = m;
        }
        r(Matrix4x4, "laya.d3.math.Matrix4x4");
        var e = Matrix4x4.prototype;
        return n.imps(e, {
            "laya.d3.core.IClone": !0
        }), e.setRotation = function(e) {
            var t = e.x, n = e.y, i = e.z, r = e.w, a = t * t, o = n * n, s = i * i, l = t * n, h = i * r, u = i * t, c = n * r, d = n * i, _ = t * r, f = this.elements;
            f[0] = 1 - 2 * (o + s), f[1] = 2 * (l + h), f[2] = 2 * (u - c), f[4] = 2 * (l - h), 
            f[5] = 1 - 2 * (s + a), f[6] = 2 * (d + _), f[8] = 2 * (u + c), f[9] = 2 * (d - _), 
            f[10] = 1 - 2 * (o + a);
        }, e.setPosition = function(e) {
            var t = this.elements;
            t[12] = e.x, t[13] = e.y, t[14] = e.z;
        }, e.getElementByRowColumn = function(e, t) {
            if (e < 0 || e > 3) throw new Error("row", "Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column", "Rows and columns for matrices run from 0 to 3, inclusive.");
            return this.elements[4 * e + t];
        }, e.setElementByRowColumn = function(e, t, n) {
            if (e < 0 || e > 3) throw new Error("row", "Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column", "Rows and columns for matrices run from 0 to 3, inclusive.");
            this.elements[4 * e + t] = n;
        }, e.equalsOtherMatrix = function(e) {
            var t = this.elements, n = e.elements;
            return ie.nearEqual(t[0], n[0]) && ie.nearEqual(t[1], n[1]) && ie.nearEqual(t[2], n[2]) && ie.nearEqual(t[3], n[3]) && ie.nearEqual(t[4], n[4]) && ie.nearEqual(t[5], n[5]) && ie.nearEqual(t[6], n[6]) && ie.nearEqual(t[7], n[7]) && ie.nearEqual(t[8], n[8]) && ie.nearEqual(t[9], n[9]) && ie.nearEqual(t[10], n[10]) && ie.nearEqual(t[11], n[11]) && ie.nearEqual(t[12], n[12]) && ie.nearEqual(t[13], n[13]) && ie.nearEqual(t[14], n[14]) && ie.nearEqual(t[15], n[15]);
        }, e.decomposeTransRotScale = function(e, t, n) {
            var i = Matrix4x4._tempMatrix4x4;
            return this.decomposeTransRotMatScale(e, i, n) ? (he.createFromMatrix4x4(i, t), 
            !0) : (t.identity(), !1);
        }, e.decomposeTransRotMatScale = function(e, t, n) {
            var i = this.elements, r = e, a = t.elements, o = n;
            r.x = i[12], r.y = i[13], r.z = i[14];
            var s = i[0], l = i[1], h = i[2], u = i[4], c = i[5], d = i[6], _ = i[8], f = i[9], m = i[10], p = o.x = Math.sqrt(s * s + l * l + h * h), T = o.y = Math.sqrt(u * u + c * c + d * d), S = o.z = Math.sqrt(_ * _ + f * f + m * m);
            if (ie.isZero(p) || ie.isZero(T) || ie.isZero(S)) return a[1] = a[2] = a[3] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[12] = a[13] = a[14] = 0, 
            a[0] = a[5] = a[10] = a[15] = 1, !1;
            var E = Matrix4x4._tempVector0;
            E.x = _ / S, E.y = f / S, E.z = m / S;
            var v = Matrix4x4._tempVector1;
            v.x = s / p, v.y = l / p, v.z = h / p;
            var g = Matrix4x4._tempVector2;
            Te.cross(E, v, g);
            var x = Matrix4x4._tempVector1;
            return Te.cross(g, E, x), a[3] = a[7] = a[11] = a[12] = a[13] = a[14] = 0, a[15] = 1, 
            a[0] = x.x, a[1] = x.y, a[2] = x.z, a[4] = g.x, a[5] = g.y, a[6] = g.z, a[8] = E.x, 
            a[9] = E.y, a[10] = E.z, a[0] * s + a[1] * l + a[2] * h < 0 && (o[0] = -p), a[4] * u + a[5] * c + a[6] * d < 0 && (o[1] = -T), 
            a[8] * _ + a[9] * f + a[10] * m < 0 && (o[2] = -S), !0;
        }, e.decomposeYawPitchRoll = function(e) {
            var t = Math.asin(-this.elements[9]);
            e.y = t, Math.cos(t) > ie.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]), 
            e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]), 
            e.x = 0);
        }, e.normalize = function() {
            var e = this.elements, t = e[0], n = e[1], i = e[2], r = Math.sqrt(t * t + n * n + i * i);
            if (!r) return e[0] = 0, e[1] = 0, void (e[2] = 0);
            1 != r && (r = 1 / r, e[0] = t * r, e[1] = n * r, e[2] = i * r);
        }, e.transpose = function() {
            var e, t;
            return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], 
            e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7], 
            e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }, e.invert = function(e) {
            var t = this.elements, n = e.elements, i = t[0], r = t[1], a = t[2], o = t[3], s = t[4], l = t[5], h = t[6], u = t[7], c = t[8], d = t[9], _ = t[10], f = t[11], m = t[12], p = t[13], T = t[14], S = t[15], E = i * l - r * s, v = i * h - a * s, g = i * u - o * s, x = r * h - a * l, M = r * u - o * l, y = a * u - o * h, D = c * p - d * m, R = c * T - _ * m, C = c * S - f * m, I = d * T - _ * p, A = d * S - f * p, L = _ * S - f * T, O = E * L - v * A + g * I + x * C - M * R + y * D;
            0 !== Math.abs(O) && (O = 1 / O, n[0] = (l * L - h * A + u * I) * O, n[1] = (a * A - r * L - o * I) * O, 
            n[2] = (p * y - T * M + S * x) * O, n[3] = (_ * M - d * y - f * x) * O, n[4] = (h * C - s * L - u * R) * O, 
            n[5] = (i * L - a * C + o * R) * O, n[6] = (T * g - m * y - S * v) * O, n[7] = (c * y - _ * g + f * v) * O, 
            n[8] = (s * A - l * C + u * D) * O, n[9] = (r * C - i * A - o * D) * O, n[10] = (m * M - p * g + S * E) * O, 
            n[11] = (d * g - c * M - f * E) * O, n[12] = (l * R - s * I - h * D) * O, n[13] = (i * I - r * R + a * D) * O, 
            n[14] = (p * v - m * x - T * E) * O, n[15] = (c * x - d * v + _ * E) * O);
        }, e.identity = function() {
            var e = this.elements;
            e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
            e[0] = e[5] = e[10] = e[15] = 1;
        }, e.cloneTo = function(e) {
            var t, n, i;
            if ((n = this.elements) !== (i = e.elements)) for (t = 0; t < 16; ++t) i[t] = n[t];
        }, e.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, e.getTranslationVector = function(e) {
            var t = this.elements;
            e.x = t[12], e.y = t[13], e.z = t[14];
        }, e.setTranslationVector = function(e) {
            var t = this.elements, n = e;
            t[12] = n.x, t[13] = n.y, t[14] = n.z;
        }, e.getForward = function(e) {
            var t = this.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }, e.setForward = function(e) {
            var t = this.elements;
            t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
        }, Matrix4x4.createRotationX = function(e, t) {
            var n = t.elements, i = Math.sin(e), r = Math.cos(e);
            n[1] = n[2] = n[3] = n[4] = n[7] = n[8] = n[11] = n[12] = n[13] = n[14] = 0, n[0] = n[15] = 1, 
            n[5] = n[10] = r, n[6] = i, n[9] = -i;
        }, Matrix4x4.createRotationY = function(e, t) {
            var n = t.elements, i = Math.sin(e), r = Math.cos(e);
            n[1] = n[3] = n[4] = n[6] = n[7] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[5] = n[15] = 1, 
            n[0] = n[10] = r, n[2] = -i, n[8] = i;
        }, Matrix4x4.createRotationZ = function(e, t) {
            var n = t.elements, i = Math.sin(e), r = Math.cos(e);
            n[2] = n[3] = n[6] = n[7] = n[8] = n[9] = n[11] = n[12] = n[13] = n[14] = 0, n[10] = n[15] = 1, 
            n[0] = n[5] = r, n[1] = i, n[4] = -i;
        }, Matrix4x4.createRotationYawPitchRoll = function(e, t, n, i) {
            he.createFromYawPitchRoll(e, t, n, Matrix4x4._tempQuaternion), Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, i);
        }, Matrix4x4.createRotationAxis = function(e, t, n) {
            var i = e.x, r = e.y, a = e.z, o = Math.cos(t), s = Math.sin(t), l = i * i, h = r * r, u = a * a, c = i * r, d = i * a, _ = r * a, f = n.elements;
            f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + o * (1 - l), 
            f[1] = c - o * c + s * a, f[2] = d - o * d - s * r, f[4] = c - o * c - s * a, f[5] = h + o * (1 - h), 
            f[6] = _ - o * _ + s * i, f[8] = d - o * d + s * r, f[9] = _ - o * _ - s * i, f[10] = u + o * (1 - u);
        }, Matrix4x4.createRotationQuaternion = function(e, t) {
            var n = t.elements, i = e.x, r = e.y, a = e.z, o = e.w, s = i * i, l = r * r, h = a * a, u = i * r, c = a * o, d = a * i, _ = r * o, f = r * a, m = i * o;
            n[3] = n[7] = n[11] = n[12] = n[13] = n[14] = 0, n[15] = 1, n[0] = 1 - 2 * (l + h), 
            n[1] = 2 * (u + c), n[2] = 2 * (d - _), n[4] = 2 * (u - c), n[5] = 1 - 2 * (h + s), 
            n[6] = 2 * (f + m), n[8] = 2 * (d + _), n[9] = 2 * (f - m), n[10] = 1 - 2 * (l + s);
        }, Matrix4x4.createTranslate = function(e, t) {
            var n = t.elements;
            n[4] = n[8] = n[1] = n[9] = n[2] = n[6] = n[3] = n[7] = n[11] = 0, n[0] = n[5] = n[10] = n[15] = 1, 
            n[12] = e.x, n[13] = e.y, n[14] = e.z;
        }, Matrix4x4.createScaling = function(e, t) {
            var n = t.elements;
            n[0] = e.x, n[5] = e.y, n[10] = e.z, n[1] = n[4] = n[8] = n[12] = n[9] = n[13] = n[2] = n[6] = n[14] = n[3] = n[7] = n[11] = 0, 
            n[15] = 1;
        }, Matrix4x4.multiply = function(e, t, n) {
            var i, r, a, o, s, l, h, u;
            if (r = n.elements, a = e.elements, r === (o = t.elements)) for (o = new Float32Array(16), 
            i = 0; i < 16; ++i) o[i] = r[i];
            var c = o[0], d = o[1], _ = o[2], f = o[3], m = o[4], p = o[5], T = o[6], S = o[7], E = o[8], v = o[9], g = o[10], x = o[11], M = o[12], y = o[13], D = o[14], R = o[15];
            for (i = 0; i < 4; i++) s = a[i], l = a[i + 4], h = a[i + 8], u = a[i + 12], r[i] = s * c + l * d + h * _ + u * f, 
            r[i + 4] = s * m + l * p + h * T + u * S, r[i + 8] = s * E + l * v + h * g + u * x, 
            r[i + 12] = s * M + l * y + h * D + u * R;
        }, Matrix4x4.multiplyForNative = function(e, t, n) {
            E.instance.matrix4x4Multiply(e.elements, t.elements, n.elements);
        }, Matrix4x4.createFromQuaternion = function(e, t) {
            var n = t.elements, i = e.x, r = e.y, a = e.z, o = e.w, s = i + i, l = r + r, h = a + a, u = i * s, c = r * s, d = r * l, _ = a * s, f = a * l, m = a * h, p = o * s, T = o * l, S = o * h;
            n[0] = 1 - d - m, n[1] = c + S, n[2] = _ - T, n[3] = 0, n[4] = c - S, n[5] = 1 - u - m, 
            n[6] = f + p, n[7] = 0, n[8] = _ + T, n[9] = f - p, n[10] = 1 - u - d, n[11] = 0, 
            n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1;
        }, Matrix4x4.createAffineTransformation = function(e, t, n, i) {
            var r = i.elements, a = t.x, o = t.y, s = t.z, l = t.w, h = a + a, u = o + o, c = s + s, d = a * h, _ = a * u, f = a * c, m = o * u, p = o * c, T = s * c, S = l * h, E = l * u, v = l * c, g = n.x, x = n.y, M = n.z;
            r[0] = (1 - (m + T)) * g, r[1] = (_ + v) * g, r[2] = (f - E) * g, r[3] = 0, r[4] = (_ - v) * x, 
            r[5] = (1 - (d + T)) * x, r[6] = (p + S) * x, r[7] = 0, r[8] = (f + E) * M, r[9] = (p - S) * M, 
            r[10] = (1 - (d + m)) * M, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
        }, Matrix4x4.createLookAt = function(e, t, n, i) {
            var r = i.elements, a = Matrix4x4._tempVector0, o = Matrix4x4._tempVector1, s = Matrix4x4._tempVector2;
            Te.subtract(e, t, s), Te.normalize(s, s), Te.cross(n, s, a), Te.normalize(a, a), 
            Te.cross(s, a, o), i.identity(), r[0] = a.x, r[4] = a.y, r[8] = a.z, r[1] = o.x, 
            r[5] = o.y, r[9] = o.z, r[2] = s.x, r[6] = s.y, r[10] = s.z, r[12] = -Te.dot(a, e), 
            r[13] = -Te.dot(o, e), r[14] = -Te.dot(s, e);
        }, Matrix4x4.createPerspective = function(e, t, n, i, r) {
            var a = 1 / Math.tan(.5 * e), o = n / (a / t), s = n / a;
            Matrix4x4.createPerspectiveOffCenter(-o, o, -s, s, n, i, r);
        }, Matrix4x4.createPerspectiveOffCenter = function(e, t, n, i, r, a, o) {
            var s = o.elements, l = a / (a - r);
            s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0, s[0] = 2 * r / (t - e), 
            s[5] = 2 * r / (i - n), s[8] = (e + t) / (t - e), s[9] = (i + n) / (i - n), s[10] = -l, 
            s[11] = -1, s[14] = -r * l;
        }, Matrix4x4.createOrthoOffCenter = function(e, t, n, i, r, a, o) {
            var s = o.elements, l = 1 / (a - r);
            s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0, s[15] = 1, s[0] = 2 / (t - e), 
            s[5] = 2 / (i - n), s[10] = -l, s[12] = (e + t) / (e - t), s[13] = (i + n) / (n - i), 
            s[14] = -r * l;
        }, Matrix4x4.billboard = function(e, t, n, i, r, a) {
            Te.subtract(e, t, Matrix4x4._tempVector0);
            var o = Te.scalarLengthSquared(Matrix4x4._tempVector0);
            ie.isZero(o) ? (Te.scale(r, -1, Matrix4x4._tempVector1), Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0)) : Te.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(o), Matrix4x4._tempVector0), 
            Te.cross(i, Matrix4x4._tempVector0, Matrix4x4._tempVector2), Te.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2), 
            Te.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
            var s = Matrix4x4._tempVector2, l = Matrix4x4._tempVector3, h = Matrix4x4._tempVector0, u = e, c = a.elements;
            c[0] = s.x, c[1] = s.y, c[2] = s.z, c[3] = 0, c[4] = l.x, c[5] = l.y, c[6] = l.z, 
            c[7] = 0, c[8] = h.x, c[9] = h.y, c[10] = h.z, c[11] = 0, c[12] = u.x, c[13] = u.y, 
            c[14] = u.z, c[15] = 1;
        }, Matrix4x4.translation = function(e, t) {
            var n = t.elements;
            n[0] = n[5] = n[10] = n[15] = 1, n[12] = e.x, n[13] = e.y, n[14] = e.z;
        }, i(Matrix4x4, [ "_tempMatrix4x4", function() {
            return this._tempMatrix4x4 = new Matrix4x4();
        }, "_tempVector0", function() {
            return this._tempVector0 = new Te();
        }, "_tempVector1", function() {
            return this._tempVector1 = new Te();
        }, "_tempVector2", function() {
            return this._tempVector2 = new Te();
        }, "_tempVector3", function() {
            return this._tempVector3 = new Te();
        }, "_tempQuaternion", function() {
            return this._tempQuaternion = new he();
        }, "DEFAULT", function() {
            return this.DEFAULT = new Matrix4x4();
        }, "ZERO", function() {
            return this.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        } ]), Matrix4x4;
    }()), kt = function() {
        function PhysicsSimulation(e, t) {
            this._nativeDiscreteDynamicsWorld = null, this._nativeCollisionWorld = null, this._nativeDispatcher = null, 
            this._nativeCollisionConfiguration = null, this._nativeBroadphase = null, this._nativeSolverInfo = null, 
            this._nativeDispatchInfo = null, this._nativeClosestRayResultCallback = null, this._nativeAllHitsRayResultCallback = null, 
            this._nativeClosestConvexResultCallback = null, this._nativeAllConvexResultCallback = null, 
            this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60, 
            this._gravity = new Te(0, -10, 0), this._nativeVector3Zero = new X._physics3D.btVector3(0, 0, 0), 
            this._nativeDefaultQuaternion = new X._physics3D.btQuaternion(0, 0, 0, -1), this._collisionsUtils = new Ye(), 
            this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new cn(), 
            this._characters = [], void 0 === t && (t = 0), this.maxSubSteps = e.maxSubSteps, 
            this.fixedTimeStep = e.fixedTimeStep;
            var n = X._physics3D;
            this._nativeCollisionConfiguration = new n.btDefaultCollisionConfiguration(), this._nativeDispatcher = new n.btCollisionDispatcher(this._nativeCollisionConfiguration), 
            this._nativeBroadphase = new n.btDbvtBroadphase(), this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new n.btGhostPairCallback());
            var i = e.flags;
            if (1 & i) this._nativeCollisionWorld = new n.btCollisionWorld(this._nativeDispatcher, this._nativeBroadphase, this._nativeCollisionConfiguration); else {
                if (2 & i) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var r = new n.btSequentialImpulseConstraintSolver();
                this._nativeDiscreteDynamicsWorld = new n.btDiscreteDynamicsWorld(this._nativeDispatcher, this._nativeBroadphase, r, this._nativeCollisionConfiguration), 
                this._nativeCollisionWorld = this._nativeDiscreteDynamicsWorld;
            }
            this._nativeDiscreteDynamicsWorld && (this._nativeSolverInfo = this._nativeDiscreteDynamicsWorld.getSolverInfo(), 
            this._nativeDispatchInfo = this._nativeDiscreteDynamicsWorld.getDispatchInfo()), 
            this._nativeClosestRayResultCallback = new n.ClosestRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), 
            this._nativeAllHitsRayResultCallback = new n.AllHitsRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), 
            this._nativeClosestConvexResultCallback = new n.ClosestConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), 
            this._nativeAllConvexResultCallback = new n.AllConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero), 
            n._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a);
        }
        r(PhysicsSimulation, "laya.d3.physics.PhysicsSimulation");
        var e = PhysicsSimulation.prototype;
        return e._simulate = function(e) {
            this._updatedRigidbodies = 0, this._nativeDiscreteDynamicsWorld ? this._nativeDiscreteDynamicsWorld.stepSimulation(e, this.maxSubSteps, this.fixedTimeStep) : this._nativeCollisionWorld.PerformDiscreteCollisionDetection();
        }, e._destroy = function() {
            var e = X._physics3D;
            this._nativeDiscreteDynamicsWorld ? (e.destroy(this._nativeDiscreteDynamicsWorld), 
            this._nativeDiscreteDynamicsWorld = null) : (e.destroy(this._nativeCollisionWorld), 
            this._nativeCollisionWorld = null), e.destroy(this._nativeBroadphase), this._nativeBroadphase = null, 
            e.destroy(this._nativeDispatcher), this._nativeDispatcher = null, e.destroy(this._nativeCollisionConfiguration), 
            this._nativeCollisionConfiguration = null;
        }, e._addPhysicsCollider = function(e, t, n) {
            this._nativeCollisionWorld.addCollisionObject(e._nativeColliderObject, t, n);
        }, e._removePhysicsCollider = function(e) {
            this._nativeCollisionWorld.removeCollisionObject(e._nativeColliderObject);
        }, e._addRigidBody = function(e, t, n) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.addRigidBody(e._nativeColliderObject, t, n);
        }, e._removeRigidBody = function(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.removeRigidBody(e._nativeColliderObject);
        }, e._addCharacter = function(e, t, n) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.addCollisionObject(e._nativeColliderObject, t, n), this._nativeCollisionWorld.addAction(e._nativeKinematicCharacter);
        }, e._removeCharacter = function(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.removeCollisionObject(e._nativeColliderObject), this._nativeCollisionWorld.removeAction(e._nativeKinematicCharacter);
        }, e.raycastFromTo = function(e, t, n, i, r) {
            void 0 === i && (i = Ut.COLLISIONFILTERGROUP_ALLFILTER), void 0 === r && (r = Ut.COLLISIONFILTERGROUP_ALLFILTER);
            var a = this._nativeClosestRayResultCallback, o = PhysicsSimulation._nativeTempVector30, s = PhysicsSimulation._nativeTempVector31;
            if (o.setValue(-e.x, e.y, e.z), s.setValue(-t.x, t.y, t.z), a.set_m_rayFromWorld(o), 
            a.set_m_rayToWorld(s), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(r), 
            a.set_m_collisionObject(null), a.set_m_closestHitFraction(1), this._nativeCollisionWorld.rayTest(o, s, a), 
            a.hasHit()) {
                if (n) {
                    n.succeeded = !0, n.collider = Wt._physicObjectsMap[a.get_m_collisionObject().getUserIndex()], 
                    n.hitFraction = a.get_m_closestHitFraction();
                    var l = a.get_m_hitPointWorld(), h = n.point;
                    h.x = -l.x(), h.y = l.y(), h.z = l.z();
                    var u = a.get_m_hitNormalWorld(), c = n.normal;
                    c.x = -u.x(), c.y = u.y(), c.z = u.z();
                }
                return !0;
            }
            return n && (n.succeeded = !1), !1;
        }, e.raycastAllFromTo = function(e, t, n, i, r) {
            void 0 === i && (i = Ut.COLLISIONFILTERGROUP_ALLFILTER), void 0 === r && (r = Ut.COLLISIONFILTERGROUP_ALLFILTER);
            var a = this._nativeAllHitsRayResultCallback, o = PhysicsSimulation._nativeTempVector30, s = PhysicsSimulation._nativeTempVector31;
            n.length = 0, o.setValue(-e.x, e.y, e.z), s.setValue(-t.x, t.y, t.z), a.set_m_rayFromWorld(o), 
            a.set_m_rayToWorld(s), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(r);
            var l = a.get_m_collisionObjects(), h = a.get_m_hitPointWorld(), u = a.get_m_hitNormalWorld(), c = a.get_m_hitFractions();
            l.clear(), h.clear(), u.clear(), c.clear(), this._nativeCollisionWorld.rayTest(o, s, a);
            var d = l.size();
            if (d > 0) {
                this._collisionsUtils.recoverAllHitResultsPool();
                for (var _ = 0; _ < d; _++) {
                    var f = this._collisionsUtils.getHitResult();
                    n.push(f), f.succeeded = !0, f.collider = Wt._physicObjectsMap[l.at(_).getUserIndex()], 
                    f.hitFraction = c.at(_);
                    var m = h.at(_), p = f.point;
                    p.x = -m.x(), p.y = m.y(), p.z = m.z();
                    var T = u.at(_), S = f.normal;
                    S.x = -T.x(), S.y = T.y(), S.z = T.z();
                }
                return !0;
            }
            return !1;
        }, e.rayCast = function(e, t, n, i, r) {
            void 0 === n && (n = 2147483647), void 0 === i && (i = Ut.COLLISIONFILTERGROUP_ALLFILTER), 
            void 0 === r && (r = Ut.COLLISIONFILTERGROUP_ALLFILTER);
            var a = e.origin, o = PhysicsSimulation._tempVector30;
            return Te.normalize(e.direction, o), Te.scale(o, n, o), Te.add(a, o, o), this.raycastFromTo(a, o, t, i, r);
        }, e.rayCastAll = function(e, t, n, i, r) {
            void 0 === n && (n = 2147483647), void 0 === i && (i = Ut.COLLISIONFILTERGROUP_ALLFILTER), 
            void 0 === r && (r = Ut.COLLISIONFILTERGROUP_ALLFILTER);
            var a = e.origin, o = PhysicsSimulation._tempVector30;
            return Te.normalize(e.direction, o), Te.scale(o, n, o), Te.add(a, o, o), this.raycastAllFromTo(a, o, t, i, r);
        }, e.shapeCast = function(e, t, n, i, r, a, o, s, l) {
            void 0 === o && (o = Ut.COLLISIONFILTERGROUP_ALLFILTER), void 0 === s && (s = Ut.COLLISIONFILTERGROUP_ALLFILTER), 
            void 0 === l && (l = 0);
            var h = this._nativeClosestConvexResultCallback, u = PhysicsSimulation._nativeTempVector30, c = PhysicsSimulation._nativeTempVector31, d = PhysicsSimulation._nativeTempQuaternion0, _ = PhysicsSimulation._nativeTempQuaternion1, f = PhysicsSimulation._nativeTempTransform0, m = PhysicsSimulation._nativeTempTransform1, p = e._nativeShape;
            if (u.setValue(-t.x, t.y, t.z), c.setValue(-n.x, n.y, n.z), h.set_m_collisionFilterGroup(o), 
            h.set_m_collisionFilterMask(s), f.setOrigin(u), m.setOrigin(c), r ? (d.setValue(-r.x, r.y, r.z, -r.w), 
            f.setRotation(d)) : f.setRotation(this._nativeDefaultQuaternion), a ? (_.setValue(-a.x, a.y, a.z, -a.w), 
            m.setRotation(_)) : m.setRotation(this._nativeDefaultQuaternion), h.set_m_hitCollisionObject(null), 
            h.set_m_closestHitFraction(1), this._nativeCollisionWorld.convexSweepTest(p, f, m, h, l), 
            h.hasHit()) {
                if (i) {
                    i.succeeded = !0, i.collider = Wt._physicObjectsMap[h.get_m_hitCollisionObject().getUserIndex()], 
                    i.hitFraction = h.get_m_closestHitFraction();
                    var T = h.get_m_hitPointWorld(), S = h.get_m_hitNormalWorld(), E = i.point, v = i.normal;
                    E.x = -T.x(), E.y = T.y(), E.z = T.z(), v.x = -S.x(), v.y = S.y(), v.z = S.z();
                }
                return !0;
            }
            return i && (i.succeeded = !1), !1;
        }, e.shapeCastAll = function(e, t, n, i, r, a, o, s, l) {
            void 0 === o && (o = Ut.COLLISIONFILTERGROUP_ALLFILTER), void 0 === s && (s = Ut.COLLISIONFILTERGROUP_ALLFILTER), 
            void 0 === l && (l = 0);
            var h = this._nativeAllConvexResultCallback, u = PhysicsSimulation._nativeTempVector30, c = PhysicsSimulation._nativeTempVector31, d = PhysicsSimulation._nativeTempQuaternion0, _ = PhysicsSimulation._nativeTempQuaternion1, f = PhysicsSimulation._nativeTempTransform0, m = PhysicsSimulation._nativeTempTransform1, p = e._nativeShape;
            i.length = 0, u.setValue(-t.x, t.y, t.z), c.setValue(-n.x, n.y, n.z), h.set_m_collisionFilterGroup(o), 
            h.set_m_collisionFilterMask(s), f.setOrigin(u), m.setOrigin(c), r ? (d.setValue(-r.x, r.y, r.z, -r.w), 
            f.setRotation(d)) : f.setRotation(this._nativeDefaultQuaternion), a ? (_.setValue(-a.x, a.y, a.z, -a.w), 
            m.setRotation(_)) : m.setRotation(this._nativeDefaultQuaternion);
            var T = h.get_m_collisionObjects();
            T.clear(), this._nativeCollisionWorld.convexSweepTest(p, f, m, h, l);
            var S = T.size();
            if (S > 0) {
                for (var E = h.get_m_hitPointWorld(), v = h.get_m_hitNormalWorld(), g = h.get_m_hitFractions(), x = 0; x < S; x++) {
                    var M = this._collisionsUtils.getHitResult();
                    i.push(M), M.succeeded = !0, M.collider = Wt._physicObjectsMap[T.at(x).getUserIndex()], 
                    M.hitFraction = g.at(x);
                    var y = E.at(x), D = M.point;
                    D.x = -y.x(), D.y = y.y(), D.z = y.z();
                    var R = v.at(x), C = M.normal;
                    C.x = -R.x(), C.y = R.y(), C.z = R.z();
                }
                return !0;
            }
            return !1;
        }, e.addConstraint = function(e, t) {
            if (void 0 === t && (t = !1), !this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.addConstraint(e._nativeConstraint, t), e._simulation = this;
        }, e.removeConstraint = function(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.removeConstraint(e._nativeConstraint);
        }, e._updatePhysicsTransformFromRender = function() {
            for (var e = this._physicsUpdateList.elements, t = 0, n = this._physicsUpdateList.length; t < n; t++) {
                var i = e[t];
                i._derivePhysicsTransformation(!1), i._inPhysicUpdateListIndex = -1;
            }
            this._physicsUpdateList.length = 0;
        }, e._updateCharacters = function() {
            for (var e = 0, t = this._characters.length; e < t; e++) {
                var n = this._characters[e];
                n._updateTransformComponent(n._nativeColliderObject.getWorldTransform());
            }
        }, e._updateCollisions = function() {
            this._collisionsUtils.recoverAllContactPointsPool();
            var e = this._currentFrameCollisions;
            this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0, 
            this._previousFrameCollisions = e;
            for (var t = P.loopCount, n = this._nativeDispatcher.getNumManifolds(), i = 0; i < n; i++) {
                var r = this._nativeDispatcher.getManifoldByIndexInternal(i), a = Wt._physicObjectsMap[r.getBody0().getUserIndex()], o = Wt._physicObjectsMap[r.getBody1().getUserIndex()], s = null, l = !1, h = null;
                if ((a.isTrigger || o.isTrigger) && (a.owner._needProcessTriggers || o.owner._needProcessTriggers)) for (var u = r.getNumContacts(), c = 0; c < u; c++) {
                    var d = r.getContactPoint(c), _ = d.getDistance();
                    if (_ <= 0) {
                        h = (s = this._collisionsUtils.getCollision(a, o)).contacts, (l = s._updateFrame !== t) && (s._isTrigger = !0, 
                        h.length = 0);
                        break;
                    }
                } else if ((a.owner._needProcessCollisions || o.owner._needProcessCollisions) && (a._enableProcessCollisions || o._enableProcessCollisions)) for (u = r.getNumContacts(), 
                c = 0; c < u; c++) if ((_ = (d = r.getContactPoint(c)).getDistance()) <= 0) {
                    var f = this._collisionsUtils.getContactPoints();
                    f.colliderA = a, f.colliderB = o, f.distance = _;
                    var m = d.get_m_normalWorldOnB(), p = f.normal;
                    p.x = -m.x(), p.y = m.y(), p.z = m.z();
                    var T = d.get_m_positionWorldOnA(), S = f.positionOnA;
                    S.x = -T.x(), S.y = T.y(), S.z = T.z();
                    var E = d.get_m_positionWorldOnB(), v = f.positionOnB;
                    v.x = -E.x(), v.y = E.y(), v.z = E.z(), s || (h = (s = this._collisionsUtils.getCollision(a, o)).contacts, 
                    (l = s._updateFrame !== t) && (s._isTrigger = !1, h.length = 0)), h.push(f);
                }
                s && l && (this._currentFrameCollisions.push(s), s._setUpdateFrame(t));
            }
        }, e._eventScripts = function() {
            for (var e = P.loopCount, t = 0, n = this._currentFrameCollisions.length; t < n; t++) {
                var i = this._currentFrameCollisions[t], r = i._colliderA, a = i._colliderB;
                if (!r.destroyed && !a.destroyed) if (e - i._lastUpdateFrame == 1) {
                    var o = r.owner, s = o._scripts;
                    if (s) if (i._isTrigger) {
                        if (o._needProcessTriggers) for (var l = 0, h = s.length; l < h; l++) s[l].onTriggerStay(a);
                    } else if (o._needProcessCollisions) for (l = 0, h = s.length; l < h; l++) i.other = a, 
                    s[l].onCollisionStay(i);
                    var u = a.owner, c = u._scripts;
                    if (c) if (i._isTrigger) {
                        if (u._needProcessTriggers) for (l = 0, h = c.length; l < h; l++) c[l].onTriggerStay(r);
                    } else if (u._needProcessCollisions) for (l = 0, h = c.length; l < h; l++) i.other = r, 
                    c[l].onCollisionStay(i);
                } else {
                    if (s = (o = r.owner)._scripts) if (i._isTrigger) {
                        if (o._needProcessTriggers) for (l = 0, h = s.length; l < h; l++) s[l].onTriggerEnter(a);
                    } else if (o._needProcessCollisions) for (l = 0, h = s.length; l < h; l++) i.other = a, 
                    s[l].onCollisionEnter(i);
                    if (c = (u = a.owner)._scripts) if (i._isTrigger) {
                        if (u._needProcessTriggers) for (l = 0, h = c.length; l < h; l++) c[l].onTriggerEnter(r);
                    } else if (u._needProcessCollisions) for (l = 0, h = c.length; l < h; l++) i.other = r, 
                    c[l].onCollisionEnter(i);
                }
            }
            for (t = 0, n = this._previousFrameCollisions.length; t < n; t++) {
                var d = this._previousFrameCollisions[t], _ = d._colliderA, f = d._colliderB;
                if (!_.destroyed && !f.destroyed && e - d._updateFrame == 1) {
                    if (this._collisionsUtils.recoverCollision(d), s = (o = _.owner)._scripts) if (d._isTrigger) {
                        if (o._needProcessTriggers) for (l = 0, h = s.length; l < h; l++) s[l].onTriggerExit(f);
                    } else if (o._needProcessCollisions) for (l = 0, h = s.length; l < h; l++) d.other = f, 
                    s[l].onCollisionExit(d);
                    if (c = (u = f.owner)._scripts) if (d._isTrigger) {
                        if (u._needProcessTriggers) for (l = 0, h = c.length; l < h; l++) c[l].onTriggerExit(_);
                    } else if (u._needProcessCollisions) for (l = 0, h = c.length; l < h; l++) d.other = _, 
                    c[l].onCollisionExit(d);
                }
            }
        }, e.clearForces = function() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.clearForces();
        }, a(0, e, "gravity", function() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._gravity;
        }, function(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._gravity = e;
            var t = PhysicsSimulation._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeDiscreteDynamicsWorld.setGravity(t);
        }), a(0, e, "continuousCollisionDetection", function() {
            return this._nativeDispatchInfo.get_m_useContinuous();
        }, function(e) {
            this._nativeDispatchInfo.set_m_useContinuous(e);
        }), a(0, e, "speculativeContactRestitution", function() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution();
        }, function(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(e);
        }), PhysicsSimulation.createConstraint = function() {}, PhysicsSimulation.PHYSICSENGINEFLAGS_NONE = 0, 
        PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2, 
        PhysicsSimulation.PHYSICSENGINEFLAGS_MULTITHREADED = 4, PhysicsSimulation.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, 
        PhysicsSimulation.SOLVERMODE_RANDMIZE_ORDER = 1, PhysicsSimulation.SOLVERMODE_FRICTION_SEPARATE = 2, 
        PhysicsSimulation.SOLVERMODE_USE_WARMSTARTING = 4, PhysicsSimulation.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, 
        PhysicsSimulation.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, PhysicsSimulation.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, 
        PhysicsSimulation.SOLVERMODE_CACHE_FRIENDLY = 128, PhysicsSimulation.SOLVERMODE_SIMD = 256, 
        PhysicsSimulation.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512, 
        PhysicsSimulation.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, PhysicsSimulation.disableSimulation = !1, 
        i(PhysicsSimulation, [ "_nativeTempVector30", function() {
            return this._nativeTempVector30 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeTempVector31", function() {
            return this._nativeTempVector31 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeTempQuaternion0", function() {
            return this._nativeTempQuaternion0 = new X._physics3D.btQuaternion(0, 0, 0, 1);
        }, "_nativeTempQuaternion1", function() {
            return this._nativeTempQuaternion1 = new X._physics3D.btQuaternion(0, 0, 0, 1);
        }, "_nativeTempTransform0", function() {
            return this._nativeTempTransform0 = new X._physics3D.btTransform();
        }, "_nativeTempTransform1", function() {
            return this._nativeTempTransform1 = new X._physics3D.btTransform();
        }, "_tempVector30", function() {
            return this._tempVector30 = new Te();
        } ]), PhysicsSimulation;
    }(), Wt = function(e) {
        function PhysicsComponent(e, t) {
            this._restitution = 0, this._friction = .5, this._rollingFriction = 0, this._ccdMotionThreshold = 0, 
            this._ccdSweptSphereRadius = 0, this._colliderShape = null, this._transformFlag = 2147483647, 
            this._enableProcessCollisions = !0, this._inPhysicUpdateListIndex = -1, this.canScaleShape = !0, 
            PhysicsComponent.__super.call(this), this._collisionGroup = 1, this._canCollideWith = Ut.COLLISIONFILTERGROUP_ALLFILTER, 
            this._collisionGroup = e, this._canCollideWith = t, PhysicsComponent._physicObjectsMap[this.id] = this;
        }
        r(PhysicsComponent, "laya.d3.physics.PhysicsComponent", e);
        var t = PhysicsComponent.prototype;
        return t._isValid = function() {
            return this._simulation && this._colliderShape && this._enabled;
        }, t._parse = function(e) {
            null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith), 
            null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold), 
            null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
        }, t._parseShape = function(e) {
            var t = e.length;
            if (1 === t) {
                var n = W._creatShape(e[0]);
                this.colliderShape = n;
            } else {
                for (var i = new fn(), r = 0; r < t; r++) n = W._creatShape(e[r]), i.addChildShape(n);
                this.colliderShape = i;
            }
        }, t._onScaleChange = function(e) {
            this._colliderShape._setScale(e);
        }, t._setTransformFlag = function(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }, t._getTransformFlag = function(e) {
            return 0 != (this._transformFlag & e);
        }, t._addToSimulation = function() {}, t._removeFromSimulation = function() {}, 
        t._derivePhysicsTransformation = function(e) {
            this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(), e);
        }, t._innerDerivePhysicsTransformation = function(e, t) {
            var n = this.owner._transform, i = n.rotation;
            if (t || this._getTransformFlag(8)) {
                var r = this._colliderShape.localOffset, a = n.position, o = PhysicsComponent._nativeVector30;
                if (0 !== r.x || 0 !== r.y || 0 !== r.z) {
                    var s = PhysicsComponent._tempVector30;
                    PhysicsComponent.physicVector3TransformQuat(r, i.x, i.y, i.z, i.w, s), Te.add(a, s, s), 
                    o.setValue(-s.x, s.y, s.z);
                } else o.setValue(-a.x, a.y, a.z);
                e.setOrigin(o), this._setTransformFlag(8, !1);
            }
            if (t || this._getTransformFlag(16)) {
                var l = this._colliderShape.localRotation, h = PhysicsComponent._nativeQuaternion0;
                if (0 !== l.x || 0 !== l.y || 0 !== l.z || 1 !== l.w) {
                    var u = PhysicsComponent._tempQuaternion0;
                    PhysicsComponent.physicQuaternionMultiply(i.x, i.y, i.z, i.w, l, u), h.setValue(-u.x, u.y, u.z, -u.w);
                } else h.setValue(-i.x, i.y, i.z, -i.w);
                e.setRotation(h), this._setTransformFlag(16, !1);
            }
            (t || this._getTransformFlag(32)) && (this._onScaleChange(n.scale), this._setTransformFlag(32, !1));
        }, t._updateTransformComponent = function(e) {
            var t = this._colliderShape.localOffset, n = this._colliderShape.localRotation, i = this.owner._transform, r = i.position, a = i.rotation, o = e.getOrigin(), s = e.getRotation(), l = -s.x(), h = s.y(), u = s.z(), c = -s.w();
            if (0 !== t.x || 0 !== t.y || 0 !== t.z) {
                var d = PhysicsComponent._tempVector30;
                PhysicsComponent.physicVector3TransformQuat(t, l, h, u, c, d), r.x = -o.x() - d.x, 
                r.y = o.y() - d.y, r.z = o.z() - d.z;
            } else r.x = -o.x(), r.y = o.y(), r.z = o.z();
            if (i.position = r, 0 !== n.x || 0 !== n.y || 0 !== n.z || 1 !== n.w) {
                var _ = PhysicsComponent._tempQuaternion0;
                n.invert(_), PhysicsComponent.physicQuaternionMultiply(l, h, u, c, _, a);
            } else a.x = l, a.y = h, a.z = u, a.w = c;
            i.rotation = a;
        }, t._onEnable = function() {
            this._simulation = this.owner._scene.physicsSimulation, this._nativeColliderObject.setContactProcessingThreshold(1e30), 
            this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0), 
            this._addToSimulation());
        }, t._onDisable = function() {
            this._colliderShape && this._enabled && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)), 
            this._simulation = null;
        }, t._onShapeChange = function(e) {
            var t = this._nativeColliderObject, n = t.getCollisionFlags();
            e.needsCustomCollisionCallback ? 0 == (8 & n) && t.setCollisionFlags(8 | n) : (8 & n) > 0 && t.setCollisionFlags(8 ^ n);
        }, t._onAdded = function() {
            this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction, 
            this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold, 
            this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on("transformchanged", this, this._onTransformChanged);
        }, t._onDestroy = function() {
            var t = X._physics3D;
            delete PhysicsComponent._physicObjectsMap[this.id], t.destroy(this._nativeColliderObject), 
            this._colliderShape.destroy(), e.prototype._onDestroy.call(this), this._nativeColliderObject = null, 
            this._colliderShape = null, this._simulation = null, this.owner.transform.off("transformchanged", this, this._onTransformChanged);
        }, t._onTransformChanged = function(e) {
            PhysicsComponent._addUpdateList && (e &= 56) && (this._transformFlag |= e, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
        }, t._cloneTo = function(e) {
            var t = e;
            t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction, 
            t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius, 
            t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith, 
            t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
        }, a(0, t, "isActive", function() {
            return !!this._nativeColliderObject && this._nativeColliderObject.isActive();
        }), a(0, t, "restitution", function() {
            return this._restitution;
        }, function(e) {
            this._restitution = e, this._nativeColliderObject && this._nativeColliderObject.setRestitution(e);
        }), a(0, t, "friction", function() {
            return this._friction;
        }, function(e) {
            this._friction = e, this._nativeColliderObject && this._nativeColliderObject.setFriction(e);
        }), a(0, t, "rollingFriction", function() {
            return this._nativeColliderObject.getRollingFriction();
        }, function(e) {
            this._rollingFriction = e, this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(e);
        }), a(0, t, "ccdMotionThreshold", function() {
            return this._ccdMotionThreshold;
        }, function(e) {
            this._ccdMotionThreshold = e, this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(e);
        }), a(0, t, "ccdSweptSphereRadius", function() {
            return this._ccdSweptSphereRadius;
        }, function(e) {
            this._ccdSweptSphereRadius = e, this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(e);
        }), a(0, t, "collisionGroup", function() {
            return this._collisionGroup;
        }, function(e) {
            this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
            this._addToSimulation()));
        }), a(0, t, "simulation", function() {
            return this._simulation;
        }), a(0, t, "colliderShape", function() {
            return this._colliderShape;
        }, function(e) {
            var t = this._colliderShape;
            if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e, 
            e) {
                if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                if (e._attatched = !0, e._attatchedCollisionObject = this, this._nativeColliderObject) {
                    this._nativeColliderObject.setCollisionShape(e._nativeShape);
                    var n = this._simulation && this._enabled;
                    n && t && this._removeFromSimulation(), this._onShapeChange(e), n && (this._derivePhysicsTransformation(!0), 
                    this._addToSimulation());
                }
            } else this._simulation && this._enabled && t && this._removeFromSimulation();
        }), a(0, t, "enabled", e.prototype._$get_enabled, function(e) {
            this._simulation && this._colliderShape && (e ? (this._derivePhysicsTransformation(!0), 
            this._addToSimulation()) : this._removeFromSimulation()), n.superSet(f, this, "enabled", e);
        }), a(0, t, "canCollideWith", function() {
            return this._canCollideWith;
        }, function(e) {
            this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(), 
            this._addToSimulation()));
        }), PhysicsComponent._createAffineTransformationArray = function(e, t, n, i, r, a, o, s, l) {
            var h = i + i, u = r + r, c = a + a, d = i * h, _ = i * u, f = i * c, m = r * u, p = r * c, T = a * c, S = o * h, E = o * u, v = o * c, g = s[0], x = s[1], M = s[2];
            l[0] = (1 - (m + T)) * g, l[1] = (_ + v) * g, l[2] = (f - E) * g, l[3] = 0, l[4] = (_ - v) * x, 
            l[5] = (1 - (d + T)) * x, l[6] = (p + S) * x, l[7] = 0, l[8] = (f + E) * M, l[9] = (p - S) * M, 
            l[10] = (1 - (d + m)) * M, l[11] = 0, l[12] = e, l[13] = t, l[14] = n, l[15] = 1;
        }, PhysicsComponent.physicVector3TransformQuat = function(e, t, n, i, r, a) {
            var o = e.x, s = e.y, l = e.z, h = r * o + n * l - i * s, u = r * s + i * o - t * l, c = r * l + t * s - n * o, d = -t * o - n * s - i * l;
            a.x = h * r + d * -t + u * -i - c * -n, a.y = u * r + d * -n + c * -t - h * -i, 
            a.z = c * r + d * -i + h * -n - u * -t;
        }, PhysicsComponent.physicQuaternionMultiply = function(e, t, n, i, r, a) {
            var o = r.x, s = r.y, l = r.z, h = r.w, u = t * l - n * s, c = n * o - e * l, d = e * s - t * o, _ = e * o + t * s + n * l;
            a.x = e * h + o * i + u, a.y = t * h + s * i + c, a.z = n * h + l * i + d, a.w = i * h - _;
        }, PhysicsComponent.ACTIVATIONSTATE_ACTIVE_TAG = 1, PhysicsComponent.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, 
        PhysicsComponent.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3, PhysicsComponent.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, 
        PhysicsComponent.ACTIVATIONSTATE_DISABLE_SIMULATION = 5, PhysicsComponent.COLLISIONFLAGS_STATIC_OBJECT = 1, 
        PhysicsComponent.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, PhysicsComponent.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4, 
        PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, PhysicsComponent.COLLISIONFLAGS_CHARACTER_OBJECT = 16, 
        PhysicsComponent.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, PhysicsComponent.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64, 
        PhysicsComponent._physicObjectsMap = {}, PhysicsComponent._addUpdateList = !0, i(PhysicsComponent, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempQuaternion0", function() {
            return this._tempQuaternion0 = new he();
        }, "_tempQuaternion1", function() {
            return this._tempQuaternion1 = new he();
        }, "_tempMatrix4x40", function() {
            return this._tempMatrix4x40 = new Ht();
        }, "_nativeVector30", function() {
            return this._nativeVector30 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeQuaternion0", function() {
            return this._nativeQuaternion0 = new X._physics3D.btQuaternion(0, 0, 0, 1);
        } ]), PhysicsComponent;
    }(f), Xt = function(e) {
        function BaseRender(e) {
            if (this._indexInList = -1, this._indexInCastShadowList = -1, this._boundsChange = !0, 
            this._visible = !0, this._indexInOctreeMotionList = -1, this._updateMark = -1, this._updateRenderType = -1, 
            this._isPartOfStaticBatch = !1, this._staticBatch = null, BaseRender.__super.call(this), 
            this._sharedMaterials = [], this._id = ++BaseRender._uniqueIDCounter, this._indexInCastShadowList = -1, 
            this._bounds = new Mt(Te._ZERO, Te._ZERO), R.supportWebGLPlusCulling) {
                var t = Bt._cullingBufferLength;
                this._cullingBufferIndex = t;
                var n = Bt._cullingBuffer, i = t + 7;
                if (i >= n.length) {
                    var r = n;
                    (n = Bt._cullingBuffer = new Float32Array(n.length + 4096)).set(r, 0);
                }
                n[t] = 2, Bt._cullingBufferLength = i;
            }
            this._renderElements = [], this._owner = e, this._enable = !0, this._materialsInstance = [], 
            this._shaderValues = new ue(null), this._defineDatas = new Ue(), this.lightmapIndex = -1, 
            this._castShadow = !1, this.receiveShadow = !1, this.sortingFudge = 0, e && this._owner.transform.on("transformchanged", this, this._onWorldMatNeedChange);
        }
        r(BaseRender, "laya.d3.core.render.BaseRender", T);
        var t = BaseRender.prototype;
        return n.imps(t, {
            "laya.resource.ISingletonElement": !0,
            "laya.d3.core.scene.IOctreeObject": !0
        }), t._getOctreeNode = function() {
            return this._octreeNode;
        }, t._setOctreeNode = function(e) {
            this._octreeNode = e;
        }, t._getIndexInMotionList = function() {
            return this._indexInOctreeMotionList;
        }, t._setIndexInMotionList = function(e) {
            this._indexInOctreeMotionList = e;
        }, t._changeMaterialReference = function(e, t) {
            e && e._removeReference(), t._addReference();
        }, t._getInstanceMaterial = function(e, t) {
            var n = new e.constructor();
            return e.cloneTo(n), n.name = n.name + "(Instance)", this._materialsInstance[t] = !0, 
            this._changeMaterialReference(this._sharedMaterials[t], n), this._sharedMaterials[t] = n, 
            n;
        }, t._applyLightMapParams = function() {
            if (this._scene && this._lightmapIndex >= 0) {
                var e = this._scene.getlightmaps();
                this._lightmapIndex < e.length ? (this._defineDatas.add(Jn.SAHDERDEFINE_LIGHTMAP), 
                this._shaderValues.setTexture(Jn.LIGHTMAP, e[this._lightmapIndex])) : this._defineDatas.remove(Jn.SAHDERDEFINE_LIGHTMAP);
            } else this._defineDatas.remove(Jn.SAHDERDEFINE_LIGHTMAP);
        }, t._onWorldMatNeedChange = function(e) {
            this._boundsChange = !0, this._octreeNode && (e &= 56) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
        }, t._calculateBoundingBox = function() {
            throw "BaseRender: must override it.";
        }, t._getIndexInList = function() {
            return this._indexInList;
        }, t._setIndexInList = function(e) {
            this._indexInList = e;
        }, t._setBelongScene = function(e) {
            this._scene !== e && (this._scene = e, this._applyLightMapParams());
        }, t._needRender = function(e) {
            return !0;
        }, t._renderUpdate = function(e, t) {}, t._renderUpdateWithCamera = function(e, t) {}, 
        t._revertBatchRenderUpdate = function(e) {}, t._destroy = function() {
            -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this), 
            this.offAll();
            var e = 0, t = 0;
            for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e].destroy();
            for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
            this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null, 
            this._lightmapScaleOffset = null;
        }, a(0, t, "bounds", function() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
            this._bounds;
        }), a(0, t, "id", function() {
            return this._id;
        }), a(0, t, "material", function() {
            var e = this._sharedMaterials[0];
            if (e && !this._materialsInstance[0]) {
                var t = this._getInstanceMaterial(e, 0), n = this._renderElements[0];
                n && (n.material = t);
            }
            return this._sharedMaterials[0];
        }, function(e) {
            this.sharedMaterial = e;
        }), a(0, t, "isPartOfStaticBatch", function() {
            return this._isPartOfStaticBatch;
        }), a(0, t, "sharedMaterial", function() {
            return this._sharedMaterials[0];
        }, function(e) {
            var t = this._sharedMaterials[0];
            if (t !== e) {
                this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                var n = this._renderElements[0];
                n && (n.material = e);
            }
        }), a(0, t, "lightmapIndex", function() {
            return this._lightmapIndex;
        }, function(e) {
            this._lightmapIndex !== e && (this._lightmapIndex = e, this._applyLightMapParams());
        }), a(0, t, "lightmapScaleOffset", function() {
            return this._lightmapScaleOffset;
        }, function(e) {
            this._lightmapScaleOffset = e, this._shaderValues.setVector(Jn.LIGHTMAPSCALEOFFSET, e), 
            this._defineDatas.add(Jn.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
        }), a(0, t, "castShadow", function() {
            return this._castShadow;
        }, function(e) {
            this._castShadow !== e && (this._owner.activeInHierarchy && (e ? this._scene._addShadowCastRenderObject(this) : this._scene._removeShadowCastRenderObject(this)), 
            this._castShadow = e);
        }), a(0, t, "enable", function() {
            return this._enable;
        }, function(e) {
            this._enable = !!e;
        }), a(0, t, "materials", function() {
            for (var e = 0, t = this._sharedMaterials.length; e < t; e++) if (!this._materialsInstance[e]) {
                var n = this._getInstanceMaterial(this._sharedMaterials[e], e), i = this._renderElements[e];
                i && (i.material = n);
            }
            return this._sharedMaterials.slice();
        }, function(e) {
            this.sharedMaterials = e;
        }), a(0, t, "sharedMaterials", function() {
            return this._sharedMaterials.slice();
        }, function(e) {
            for (var t = this._sharedMaterials, n = 0, i = t.length; n < i; n++) t[n]._removeReference();
            if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
            var r = e.length;
            for (this._materialsInstance.length = r, t.length = r, n = 0; n < r; n++) {
                var a = t[n], o = e[n];
                if (a !== o) {
                    this._materialsInstance[n] = !1;
                    var s = this._renderElements[n];
                    s && (s.material = o);
                }
                o._addReference(), t[n] = o;
            }
        }), a(0, t, "receiveShadow", function() {
            return this._receiveShadow;
        }, function(e) {
            this._receiveShadow !== e && (this._receiveShadow = e, e ? this._defineDatas.add(Jn.SHADERDEFINE_RECEIVE_SHADOW) : this._defineDatas.remove(Jn.SHADERDEFINE_RECEIVE_SHADOW));
        }), BaseRender._uniqueIDCounter = 0, i(BaseRender, [ "_tempBoundBoxCorners", function() {
            return this._tempBoundBoxCorners = [ new Te(), new Te(), new Te(), new Te(), new Te(), new Te(), new Te(), new Te() ];
        } ]), BaseRender;
    }(), Yt = (function(e) {
        function Script3D() {
            Script3D.__super.call(this);
        }
        r(Script3D, "laya.d3.component.Script3D", f);
        var t = Script3D.prototype;
        t._checkProcessTriggers = function() {
            var e = laya.d3.component.Script3D.prototype;
            return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
        }, t._checkProcessCollisions = function() {
            var e = laya.d3.component.Script3D.prototype;
            return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
        }, t._onAwake = function() {
            this.onAwake(), this.onStart !== laya.d3.component.Script3D.prototype.onStart && n.startTimer.callLater(this, this.onStart);
        }, t._onEnable = function() {
            this.owner._scene._scriptPool.add(this);
            var e = laya.d3.component.Script3D.prototype;
            this.onKeyDown !== e.onKeyDown && n.stage.on("keydown", this, this.onKeyDown), this.onKeyPress !== e.onKeyPress && n.stage.on("keypress", this, this.onKeyUp), 
            this.onKeyUp !== e.onKeyUp && n.stage.on("keyup", this, this.onKeyUp);
        }, t._onDisable = function() {
            this.owner._scene._scriptPool.remove(this), this.owner.offAllCaller(this), n.stage.offAllCaller(this);
        }, t._isScript = function() {
            return !0;
        }, t._onAdded = function() {
            var e = this.owner, t = e._scripts;
            t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()), 
            e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
        }, t._onDestroy = function() {
            var e = this.owner._scripts;
            e.splice(e.indexOf(this), 1);
            var t = this.owner;
            t._needProcessTriggers = !1;
            for (var n = 0, i = e.length; n < i; n++) if (e[n]._checkProcessTriggers()) {
                t._needProcessTriggers = !0;
                break;
            }
            for (t._needProcessCollisions = !1, n = 0, i = e.length; n < i; n++) if (e[n]._checkProcessCollisions()) {
                t._needProcessCollisions = !0;
                break;
            }
            this.onDestroy();
        }, t.onAwake = function() {}, t.onEnable = function() {}, t.onStart = function() {}, 
        t.onTriggerEnter = function(e) {}, t.onTriggerStay = function(e) {}, t.onTriggerExit = function(e) {}, 
        t.onCollisionEnter = function(e) {}, t.onCollisionStay = function(e) {}, t.onCollisionExit = function(e) {}, 
        t.onMouseDown = function() {}, t.onMouseDrag = function() {}, t.onMouseClick = function() {}, 
        t.onMouseUp = function() {}, t.onMouseEnter = function() {}, t.onMouseOver = function() {}, 
        t.onMouseOut = function() {}, t.onKeyDown = function(e) {}, t.onKeyPress = function(e) {}, 
        t.onKeyUp = function(e) {}, t.onUpdate = function() {}, t.onLateUpdate = function() {}, 
        t.onPreRender = function() {}, t.onPostRender = function() {}, t.onDisable = function() {}, 
        t.onDestroy = function() {}, a(0, t, "isSingleton", function() {
            return !1;
        });
    }(), function(e) {
        function Transform3D(e) {
            this._owner = null, this._children = null, this._parent = null, this._dummy = null, 
            this._transformFlag = 0, Transform3D.__super.call(this), this._localPosition = new Te(0, 0, 0), 
            this._localRotation = new he(0, 0, 0, 1), this._localScale = new Te(1, 1, 1), this._localRotationEuler = new Te(0, 0, 0), 
            this._localMatrix = new Ht(), this._position = new Te(0, 0, 0), this._rotation = new he(0, 0, 0, 1), 
            this._scale = new Te(1, 1, 1), this._rotationEuler = new Te(0, 0, 0), this._worldMatrix = new Ht(), 
            this._owner = e, this._children = [], this._setTransformFlag(7, !1), this._setTransformFlag(248, !0);
        }
        r(Transform3D, "laya.d3.core.Transform3D", T);
        var t = Transform3D.prototype;
        return t._setTransformFlag = function(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }, t._getTransformFlag = function(e) {
            return 0 != (this._transformFlag & e);
        }, t._setParent = function(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children, n = t.indexOf(this);
                    t.splice(n, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }, t._updateLocalMatrix = function() {
            Ht.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix);
        }, t._onWorldPositionRotationTransform = function() {
            if (!(this._getTransformFlag(64) && this._getTransformFlag(8) && this._getTransformFlag(16) && this._getTransformFlag(128))) {
                this._setTransformFlag(216, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }, t._onWorldPositionScaleTransform = function() {
            if (!this._getTransformFlag(64) || !this._getTransformFlag(8) || !this._getTransformFlag(32)) {
                this._setTransformFlag(104, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }, t._onWorldPositionTransform = function() {
            if (!this._getTransformFlag(64) || !this._getTransformFlag(8)) {
                this._setTransformFlag(72, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldPositionTransform();
            }
        }, t._onWorldRotationTransform = function() {
            if (!this._getTransformFlag(64) || !this._getTransformFlag(16) || !this._getTransformFlag(128)) {
                this._setTransformFlag(208, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }, t._onWorldScaleTransform = function() {
            if (!this._getTransformFlag(64) || !this._getTransformFlag(32)) {
                this._setTransformFlag(96, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }, t._onWorldTransform = function() {
            if (!(this._getTransformFlag(64) && this._getTransformFlag(8) && this._getTransformFlag(16) && this._getTransformFlag(128) && this._getTransformFlag(32))) {
                this._setTransformFlag(248, !0), this.event("transformchanged", this._transformFlag);
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldTransform();
            }
        }, t.translate = function(e, t) {
            void 0 === t && (t = !0), t ? (Ht.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0), 
            Te.transformCoordinate(e, Transform3D._tempMatrix0, Transform3D._tempVector30), 
            Te.add(this.localPosition, Transform3D._tempVector30, this._localPosition), this.localPosition = this._localPosition) : (Te.add(this.position, e, this._position), 
            this.position = this._position);
        }, t.rotate = function(e, t, n) {
            var i;
            void 0 === t && (t = !0), void 0 === n && (n = !0), n ? i = e : (Te.scale(e, Math.PI / 180, Transform3D._tempVector30), 
            i = Transform3D._tempVector30), he.createFromYawPitchRoll(i.y, i.x, i.z, Transform3D._tempQuaternion0), 
            t ? (he.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation), 
            this.localRotation = this._localRotation) : (he.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation), 
            this.rotation = this._rotation);
        }, t.getForward = function(e) {
            var t = this.worldMatrix.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }, t.getUp = function(e) {
            var t = this.worldMatrix.elements;
            e.x = t[4], e.y = t[5], e.z = t[6];
        }, t.getRight = function(e) {
            var t = this.worldMatrix.elements;
            e.x = t[0], e.y = t[1], e.z = t[2];
        }, t.lookAt = function(e, t, n) {
            var i;
            if (void 0 === n && (n = !1), n) {
                if (i = this._localPosition, Math.abs(i.x - e.x) < ie.zeroTolerance && Math.abs(i.y - e.y) < ie.zeroTolerance && Math.abs(i.z - e.z) < ie.zeroTolerance) return;
                he.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation), 
                this.localRotation = this._localRotation;
            } else {
                var r = this.position;
                if (i = r, Math.abs(i.x - e.x) < ie.zeroTolerance && Math.abs(i.y - e.y) < ie.zeroTolerance && Math.abs(i.z - e.z) < ie.zeroTolerance) return;
                he.lookAt(r, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
            }
        }, a(0, t, "_isFrontFaceInvert", function() {
            var e = this.scale, t = e.x < 0;
            return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
        }), a(0, t, "owner", function() {
            return this._owner;
        }), a(0, t, "localPositionY", function() {
            return this._localPosition.y;
        }, function(e) {
            this._localPosition.y = e, this.localPosition = this._localPosition;
        }), a(0, t, "localScaleX", function() {
            return this._localScale.x;
        }, function(e) {
            this._localScale.x = e, this.localScale = this._localScale;
        }), a(0, t, "worldNeedUpdate", function() {
            return this._getTransformFlag(64);
        }), a(0, t, "localPositionX", function() {
            return this._localPosition.x;
        }, function(e) {
            this._localPosition.x = e, this.localPosition = this._localPosition;
        }), a(0, t, "localPosition", function() {
            return this._localPosition;
        }, function(e) {
            this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(4, !0), 
            this._onWorldPositionTransform();
        }), a(0, t, "localPositionZ", function() {
            return this._localPosition.z;
        }, function(e) {
            this._localPosition.z = e, this.localPosition = this._localPosition;
        }), a(0, t, "localRotationX", function() {
            return this.localRotation.x;
        }, function(e) {
            this._localRotation.x = e, this.localRotation = this._localRotation;
        }), a(0, t, "localRotationY", function() {
            return this.localRotation.y;
        }, function(e) {
            this._localRotation.y = e, this.localRotation = this._localRotation;
        }), a(0, t, "localRotationZ", function() {
            return this.localRotation.z;
        }, function(e) {
            this._localRotation.z = e, this.localRotation = this._localRotation;
        }), a(0, t, "localRotationW", function() {
            return this.localRotation.w;
        }, function(e) {
            this._localRotation.w = e, this.localRotation = this._localRotation;
        }), a(0, t, "localRotation", function() {
            if (this._getTransformFlag(1)) {
                var e = this._localRotationEuler;
                he.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._localRotation), 
                this._setTransformFlag(1, !1);
            }
            return this._localRotation;
        }, function(e) {
            this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation), 
            this._setTransformFlag(6, !0), this._setTransformFlag(1, !1), this._onWorldRotationTransform();
        }), a(0, t, "localScaleY", function() {
            return this._localScale.y;
        }, function(e) {
            this._localScale.y = e, this.localScale = this._localScale;
        }), a(0, t, "localScaleZ", function() {
            return this._localScale.z;
        }, function(e) {
            this._localScale.z = e, this.localScale = this._localScale;
        }), a(0, t, "position", function() {
            if (this._getTransformFlag(8)) {
                if (null != this._parent) {
                    var e = this._parent.position;
                    Te.multiply(this._localPosition, this._parent.scale, Transform3D._tempVector30), 
                    Te.transformQuat(Transform3D._tempVector30, this._parent.rotation, Transform3D._tempVector30), 
                    Te.add(e, Transform3D._tempVector30, this._position);
                } else this._localPosition.cloneTo(this._position);
                this._setTransformFlag(8, !1);
            }
            return this._position;
        }, function(e) {
            if (null != this._parent) {
                Te.subtract(e, this._parent.position, this._localPosition);
                var t = this._parent.scale, n = t.x, i = t.y, r = t.z;
                if (1 !== n || 1 !== i || 1 !== r) {
                    var a = Transform3D._tempVector30;
                    a.x = 1 / n, a.y = 1 / i, a.z = 1 / r, Te.multiply(this._localPosition, a, this._localPosition);
                }
                this._parent.rotation.invert(Transform3D._tempQuaternion0), Te.transformQuat(this._localPosition, Transform3D._tempQuaternion0, this._localPosition);
            } else e.cloneTo(this._localPosition);
            this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position), 
            this._setTransformFlag(8, !1);
        }), a(0, t, "localRotationEulerY", function() {
            return this.localRotationEuler.y;
        }, function(e) {
            this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
        }), a(0, t, "localScale", function() {
            return this._localScale;
        }, function(e) {
            this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(4, !0), 
            this._onWorldScaleTransform();
        }), a(0, t, "localRotationEulerX", function() {
            return this.localRotationEuler.x;
        }, function(e) {
            this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
        }), a(0, t, "localRotationEulerZ", function() {
            return this.localRotationEuler.z;
        }, function(e) {
            this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
        }), a(0, t, "localRotationEuler", function() {
            if (this._getTransformFlag(2)) {
                this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                var e = Transform3D._tempVector30, t = this._localRotationEuler;
                t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin, 
                t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(2, !1);
            }
            return this._localRotationEuler;
        }, function(e) {
            this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(2, !1), 
            this._setTransformFlag(5, !0), this._onWorldRotationTransform();
        }), a(0, t, "localMatrix", function() {
            return this._getTransformFlag(4) && (this._updateLocalMatrix(), this._setTransformFlag(4, !1)), 
            this._localMatrix;
        }, function(e) {
            this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale), 
            this._setTransformFlag(4, !1), this._onWorldTransform();
        }), a(0, t, "rotation", function() {
            return this._getTransformFlag(16) && (null != this._parent ? he.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation), 
            this._setTransformFlag(16, !1)), this._rotation;
        }, function(e) {
            null != this._parent ? (this._parent.rotation.invert(Transform3D._tempQuaternion0), 
            he.multiply(Transform3D._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation), 
            this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation), 
            this._setTransformFlag(16, !1);
        }), a(0, t, "scale", function() {
            return this._getTransformFlag(32) ? (null !== this._parent ? Te.multiply(this._parent.scale, this._localScale, this._scale) : this._localScale.cloneTo(this._scale), 
            this._setTransformFlag(32, !1), this._scale) : this._scale;
        }, function(e) {
            if (null !== this._parent) {
                var t = this._parent.scale, n = Transform3D._tempVector30;
                n.x = 1 / t.x, n.y = 1 / t.y, n.z = 1 / t.z, Te.multiply(e, Transform3D._tempVector30, this._localScale);
            } else e.cloneTo(this._localScale);
            this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale), 
            this._setTransformFlag(32, !1);
        }), a(0, t, "rotationEuler", function() {
            if (this._getTransformFlag(128)) {
                this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                var e = Transform3D._tempVector30, t = this._rotationEuler;
                t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin, 
                t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(128, !1);
            }
            return this._rotationEuler;
        }, function(e) {
            he.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._rotation), 
            this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler), 
            this._setTransformFlag(128, !1);
        }), a(0, t, "worldMatrix", function() {
            return this._getTransformFlag(64) && (null != this._parent ? Ht.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix), 
            this._setTransformFlag(64, !1)), this._worldMatrix;
        }, function(e) {
            null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix), 
            Ht.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix, 
            this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(64, !1);
        }), Transform3D.TRANSFORM_LOCALQUATERNION = 1, Transform3D.TRANSFORM_LOCALEULER = 2, 
        Transform3D.TRANSFORM_LOCALMATRIX = 4, Transform3D.TRANSFORM_WORLDPOSITION = 8, 
        Transform3D.TRANSFORM_WORLDQUATERNION = 16, Transform3D.TRANSFORM_WORLDSCALE = 32, 
        Transform3D.TRANSFORM_WORLDMATRIX = 64, Transform3D.TRANSFORM_WORLDEULER = 128, 
        i(Transform3D, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempVector32", function() {
            return this._tempVector32 = new Te();
        }, "_tempVector33", function() {
            return this._tempVector33 = new Te();
        }, "_tempQuaternion0", function() {
            return this._tempQuaternion0 = new he();
        }, "_tempMatrix0", function() {
            return this._tempMatrix0 = new Ht();
        }, "_angleToRandin", function() {
            return this._angleToRandin = 180 / Math.PI;
        } ]), Transform3D;
    }()), Zt = function(e) {
        function Animator() {
            this._linkAvatarSpritesData = {}, this._keyframeNodeOwners = [], this._linkAvatarSprites = [], 
            this._renderableSprites = [], this.cullingMode = 2, Animator.__super.call(this), 
            this._controllerLayers = [], this._linkSprites = {}, this._speed = 1, this._keyframeNodeOwnerMap = {}, 
            this._updateMark = 0;
        }
        r(Animator, "laya.d3.component.Animator", f);
        var t = Animator.prototype;
        return t._linkToSprites = function(e) {
            for (var t in e) {
                for (var n = this.owner, i = e[t], r = 0, a = i.length; r < a; r++) {
                    var o = i[r];
                    if ("" === o) break;
                    if (!(n = n.getChildByName(o))) break;
                }
                n && this.linkSprite3DToAvatarNode(t, n);
            }
        }, t._addKeyframeNodeOwner = function(e, t, n) {
            var i = t._indexInList, r = t.fullPath, a = this._keyframeNodeOwnerMap[r];
            if (a) a.referenceCount++, e[i] = a; else {
                for (var s = n, l = 0, h = t.propertyCount; l < h && (s = s[t.getPropertyByIndex(l)]); l++) ;
                (a = this._keyframeNodeOwnerMap[r] = new Nt()).fullPath = r, a.indexInList = this._keyframeNodeOwners.length, 
                a.referenceCount = 1, a.propertyOwner = n;
                var u = t.propertyCount, c = o(u);
                for (l = 0; l < u; l++) c[l] = t.getPropertyByIndex(l);
                if (a.property = c, a.type = t.type, s) if (0 === t.type) a.defaultValue = s; else {
                    var d = new s.constructor();
                    s.cloneTo(d), a.defaultValue = d;
                }
                this._keyframeNodeOwners.push(a), e[i] = a;
            }
        }, t._removeKeyframeNodeOwner = function(e, t) {
            var n = t.fullPath, i = this._keyframeNodeOwnerMap[n];
            i && (i.referenceCount--, 0 === i.referenceCount && (delete this._keyframeNodeOwnerMap[n], 
            this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(i), 1)), e[t._indexInList] = null);
        }, t._getOwnersByClip = function(e) {
            var t = e._clip._nodes, n = t.count, i = e._nodeOwners;
            i.length = n;
            for (var r = 0; r < n; r++) {
                for (var a = t.getNodeByIndex(r), o = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, s = 0, l = a.ownerPathCount; s < l; s++) {
                    var h = a.getOwnerPathByIndex(s);
                    if ("" === h) break;
                    if (!(o = o.getChildByName(h))) break;
                }
                if (o) {
                    var u = a.propertyOwner;
                    u && (o = o[u]), o && this._addKeyframeNodeOwner(i, a, o);
                }
            }
        }, t._updatePlayer = function(e, t, n, i) {
            var r = e._clip._duration * (e.clipEnd - e.clipStart), a = t._elapsedTime, o = a + n;
            t._lastElapsedTime = a, t._elapsedTime = o;
            var s = o / r;
            t._normalizedTime = s;
            var l = s % 1;
            t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = r;
            var h = e._scripts;
            if (!i && o >= r) {
                if (t._finish = !0, t._elapsedTime = r, t._normalizedPlayTime = 1, h) for (var u = 0, c = h.length; u < c; u++) h[u].onStateExit();
            } else if (h) for (u = 0, c = h.length; u < c; u++) h[u].onStateUpdate();
        }, t._eventScript = function(e, t, n, i, r) {
            if (r) for (var a = t.length; n < a; n++) {
                var o = t[n];
                if (!(o.time <= i)) break;
                for (var s = 0, l = e.length; s < l; s++) {
                    var h = e[s], u = h[o.eventName];
                    u && u.apply(h, o.params);
                }
            } else for (;n >= 0 && (o = t[n]).time >= i; n--) for (s = 0, l = e.length; s < l; s++) (u = (h = e[s])[o.eventName]) && u.apply(h, o.params);
            return n;
        }, t._updateEventScript = function(e, t) {
            var n = this.owner._scripts;
            if (n) {
                var i = e._clip, r = i._events, a = i._duration, o = t._elapsedTime, s = o % a, l = Math.abs(Math.floor(o / a) - Math.floor(t._lastElapsedTime / a)), h = t._elapsedTime >= t._lastElapsedTime;
                if (t._lastIsFront !== h && (h ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = h), 
                0 == l) t._playEventIndex = this._eventScript(n, r, t._playEventIndex, s, h); else if (h) {
                    this._eventScript(n, r, t._playEventIndex, a, !0);
                    for (var u = 0, c = l - 1; u < c; u++) this._eventScript(n, r, 0, a, !0);
                    t._playEventIndex = this._eventScript(n, r, 0, s, !0);
                } else {
                    this._eventScript(n, r, t._playEventIndex, 0, !1);
                    var d = r.length - 1;
                    for (u = 0, c = l - 1; u < c; u++) this._eventScript(n, r, d, 0, !1);
                    t._playEventIndex = this._eventScript(n, r, d, s, !1);
                }
            }
        }, t._updateClipDatas = function(e, t, n, i) {
            var r = e._clip, a = r._duration, o = e.clipStart * a + n._normalizedPlayTime * n._duration, s = e._currentFrameIndices, l = n._elapsedTime > n._lastElapsedTime;
            r._evaluateClipDatasRealTime(r._nodes, o, s, t, l);
        }, t._applyFloat = function(e, t, n, i, r, a, o) {
            if (n.updateMark === this._updateMark) if (i) e[t] += r * o; else {
                var s = e[t];
                e[t] = s + r * (o - s);
            } else if (a) e[t] = i ? n.defaultValue + o : o; else if (i) e[t] = n.defaultValue + r * o; else {
                var l = n.defaultValue;
                e[t] = l + r * (o - l);
            }
        }, t._applyPositionAndRotationEuler = function(e, t, n, i, r, a) {
            if (e.updateMark === this._updateMark) if (t) a.x += n * r.x, a.y += n * r.y, a.z += n * r.z; else {
                var o = a.x, s = a.y, l = a.z;
                a.x = o + n * (r.x - o), a.y = s + n * (r.y - s), a.z = l + n * (r.z - l);
            } else if (i) if (t) {
                var h = e.defaultValue;
                a.x = h.x + r.x, a.y = h.y + r.y, a.z = h.z + r.z;
            } else a.x = r.x, a.y = r.y, a.z = r.z; else if (h = e.defaultValue, t) a.x = h.x + n * r.x, 
            a.y = h.y + n * r.y, a.z = h.z + n * r.z; else {
                var u = h.x, c = h.y, d = h.z;
                a.x = u + n * (r.x - u), a.y = c + n * (r.y - c), a.z = d + n * (r.z - d);
            }
        }, t._applyRotation = function(e, t, n, i, r, a) {
            if (e.updateMark === this._updateMark) if (t) {
                var o = Animator._tempQuaternion1;
                ke.quaternionWeight(r, n, o), o.normalize(o), he.multiply(a, o, a);
            } else he.lerp(a, r, n, a); else if (i) if (t) {
                var s = e.defaultValue;
                he.multiply(s, r, a);
            } else a.x = r.x, a.y = r.y, a.z = r.z, a.w = r.w; else s = e.defaultValue, t ? (o = Animator._tempQuaternion1, 
            ke.quaternionWeight(r, n, o), o.normalize(o), he.multiply(s, o, a)) : he.lerp(s, r, n, a);
        }, t._applyScale = function(e, t, n, i, r, a) {
            if (e.updateMark === this._updateMark) if (t) {
                var o = Animator._tempVector31;
                ke.scaleWeight(r, n, o), a.x = a.x * o.x, a.y = a.y * o.y, a.z = a.z * o.z;
            } else ke.scaleBlend(a, r, n, a); else if (i) if (t) {
                var s = e.defaultValue;
                a.x = s.x * r.x, a.y = s.y * r.y, a.z = s.z * r.z;
            } else a.x = r.x, a.y = r.y, a.z = r.z; else s = e.defaultValue, t ? (o = Animator._tempVector31, 
            ke.scaleWeight(r, n, o), a.x = s.x * o.x, a.y = s.y * o.y, a.z = s.z * o.z) : ke.scaleBlend(s, r, n, a);
        }, t._applyCrossData = function(e, t, n, i, r, a, o) {
            var s = e.propertyOwner;
            if (s) {
                switch (e.type) {
                  case 0:
                    for (var l = e.property, h = l.length - 1, u = 0; u < h && (s = s[l[u]]); u++) ;
                    var c = r + o * (a - r);
                    this._applyFloat(s, l[h], e, t, n, i, c);
                    break;

                  case 1:
                    var d = s.localPosition, _ = Animator._tempVector30, f = r.x, m = r.y, p = r.z;
                    _.x = f + o * (a.x - f), _.y = m + o * (a.y - m), _.z = p + o * (a.z - p), this._applyPositionAndRotationEuler(e, t, n, i, _, d), 
                    s.localPosition = d;
                    break;

                  case 2:
                    var T = s.localRotation, S = Animator._tempQuaternion0;
                    he.lerp(r, a, o, S), this._applyRotation(e, t, n, i, S, T), s.localRotation = T;
                    break;

                  case 3:
                    var E = s.localScale, v = Animator._tempVector30;
                    ke.scaleBlend(r, a, o, v), this._applyScale(e, t, n, i, v, E), s.localScale = E;
                    break;

                  case 4:
                    var g = s.localRotationEuler, x = Animator._tempVector30;
                    f = r.x, m = r.y, p = r.z, x.x = f + o * (a.x - f), x.y = m + o * (a.y - m), x.z = p + o * (a.z - p), 
                    this._applyPositionAndRotationEuler(e, t, n, i, x, g), s.localRotationEuler = g;
                }
                e.updateMark = this._updateMark;
            }
        }, t._setClipDatasToNode = function(e, t, n, i) {
            for (var r = e._clip._nodes, a = e._nodeOwners, o = 0, s = r.count; o < s; o++) {
                var l = a[o];
                if (l) {
                    var h = l.propertyOwner;
                    if (h) {
                        switch (l.type) {
                          case 0:
                            for (var u = l.property, c = u.length - 1, d = 0; d < c && (h = h[u[d]]); d++) ;
                            this._applyFloat(h, u[c], l, t, n, i, r.getNodeByIndex(o).data);
                            break;

                          case 1:
                            var _ = h.localPosition;
                            this._applyPositionAndRotationEuler(l, t, n, i, r.getNodeByIndex(o).data, _), h.localPosition = _;
                            break;

                          case 2:
                            var f = h.localRotation;
                            this._applyRotation(l, t, n, i, r.getNodeByIndex(o).data, f), h.localRotation = f;
                            break;

                          case 3:
                            var m = h.localScale;
                            this._applyScale(l, t, n, i, r.getNodeByIndex(o).data, m), h.localScale = m;
                            break;

                          case 4:
                            var p = h.localRotationEuler;
                            this._applyPositionAndRotationEuler(l, t, n, i, r.getNodeByIndex(o).data, p), h.localRotationEuler = p;
                        }
                        l.updateMark = this._updateMark;
                    }
                }
            }
        }, t._setCrossClipDatasToNode = function(e, t, n, i, r) {
            for (var a = e._crossNodesOwners, o = e._crossNodesOwnersCount, s = e.blendingMode !== wt.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, h = e._destCrossClipNodeIndices, u = n._clip._nodes, c = n._nodeOwners, d = e._srcCrossClipNodeIndices, _ = t._nodeOwners, f = t._clip._nodes, m = 0; m < o; m++) {
                var p = a[m];
                if (p) {
                    var T = d[m], S = h[m], E = -1 !== T ? f.getNodeByIndex(T).data : c[S].defaultValue, v = -1 !== S ? u.getNodeByIndex(S).data : _[T].defaultValue;
                    this._applyCrossData(p, s, l, r, E, v, i);
                }
            }
        }, t._setFixedCrossClipDatasToNode = function(e, t, n, i) {
            for (var r = e._crossNodesOwners, a = e._crossNodesOwnersCount, o = e.blendingMode !== wt.BLENDINGMODE_OVERRIDE, s = e.defaultWeight, l = e._destCrossClipNodeIndices, h = t._clip._nodes, u = 0; u < a; u++) {
                var c = r[u];
                if (c) {
                    var d = l[u], _ = c.crossFixedValue, f = -1 !== d ? h.getNodeByIndex(d).data : c.defaultValue;
                    this._applyCrossData(c, o, s, i, _, f, n);
                }
            }
        }, t._revertDefaultKeyframeNodes = function(e) {
            for (var t = e._nodeOwners, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                if (r) {
                    var a = r.propertyOwner;
                    if (a) switch (r.type) {
                      case 0:
                        for (var o = r.property, s = o.length - 1, l = 0; l < s && (a = a[o[l]]); l++) ;
                        a[o[s]] = r.defaultValue;
                        break;

                      case 1:
                        var h = a.localPosition, u = r.defaultValue;
                        h.x = u.x, h.y = u.y, h.z = u.z, a.localPosition = h;
                        break;

                      case 2:
                        var c = a.localRotation, d = r.defaultValue;
                        c.x = d.x, c.y = d.y, c.z = d.z, c.w = d.w, a.localRotation = c;
                        break;

                      case 3:
                        var _ = a.localScale;
                        u = r.defaultValue, _.x = u.x, _.y = u.y, _.z = u.z, a.localScale = _;
                        break;

                      case 4:
                        var f = a.localRotationEuler;
                        u = r.defaultValue, f.x = u.x, f.y = u.y, f.z = u.z, a.localRotationEuler = f;
                        break;

                      default:
                        throw "Animator:unknown type.";
                    }
                }
            }
        }, t._removeClip = function(e, t, n, i) {
            var r = i._clip;
            r._removeReference(), e.splice(n, 1), delete t[i.name];
            for (var a = e[n], o = r._nodes, s = a._nodeOwners, l = 0, h = o.count; l < h; l++) this._removeKeyframeNodeOwner(s, o.getNodeByIndex(l));
        }, t._onAdded = function() {
            var e = this.owner._parent;
            this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
        }, t._onDestroy = function() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) for (var n = this._controllerLayers[e]._states, i = 0, r = n.length; i < r; i++) n[i]._clip._removeReference();
            var a = this.owner._parent;
            this.owner._clearHierarchyAnimator(this, a ? a._hierarchyAnimator : null);
        }, t._onEnableInScene = function() {
            this.owner._scene._animatorPool.add(this);
        }, t._onDisableInScene = function() {
            this.owner._scene._animatorPool.remove(this);
        }, t._onEnable = function() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
            }
        }, t._handleSpriteOwnersBySprite = function(e, t, n) {
            for (var i = 0, r = this._controllerLayers.length; i < r; i++) for (var a = this._controllerLayers[i]._states, o = 0, s = a.length; o < s; o++) {
                var l = a[o], h = l._clip, u = t.join("/"), c = h._nodesMap[u];
                if (c) for (var d = l._nodeOwners, _ = 0, f = c.length; _ < f; _++) e ? this._addKeyframeNodeOwner(d, c[_], n) : this._removeKeyframeNodeOwner(d, c[_]);
            }
        }, t._parse = function(e) {
            var t = e.avatar;
            if (t) {
                this.avatar = g.getRes(t.path);
                var n = t.linkSprites;
                this._linkSprites = n, this._linkToSprites(n);
            }
            e.clipPaths;
            for (var i = e.playOnWake, r = e.layers, a = 0; a < r.length; a++) {
                var o = r[a], s = new wt(o.name);
                s.defaultWeight = 0 === a ? 1 : o.weight;
                var l = o.blendingMode;
                l && (s.blendingMode = l), this.addControllerLayer(s);
                for (var h = o.states, u = 0, c = h.length; u < c; u++) {
                    var d = h[u], _ = d.clipPath;
                    if (_) {
                        var f, m = d.name;
                        if (f = g.getRes(_)) {
                            var p = new Gt();
                            p.name = m, p.clip = f, this.addState(p, a), 0 === u && (this.getControllerLayer(a).defaultState = p);
                        }
                    }
                }
                void 0 !== i && (s.playOnWake = i);
            }
            var T = e.cullingMode;
            void 0 !== T && (this.cullingMode = T);
        }, t._update = function() {
            if (0 !== this._speed) {
                var e = !1;
                if (2 === this.cullingMode) {
                    e = !1;
                    for (var t = 0, n = this._renderableSprites.length; t < n; t++) if (this._renderableSprites[t]._render._visible) {
                        e = !0;
                        break;
                    }
                } else e = !0;
                this._updateMark++;
                var i = this.owner._scene.timer, r = i._delta / 1e3, a = i.scale;
                for (t = 0, n = this._controllerLayers.length; t < n; t++) {
                    var o = this._controllerLayers[t], s = o._playStateInfo, l = o._crossPlayStateInfo;
                    switch (_ = o.blendingMode !== wt.BLENDINGMODE_OVERRIDE, o._playType) {
                      case 0:
                        var h = o._currentPlayState, u = h._clip, c = this._speed * h.speed, d = s._finish;
                        if (d || this._updatePlayer(h, s, r * c, u.islooping), e) {
                            var _ = o.blendingMode !== wt.BLENDINGMODE_OVERRIDE;
                            this._updateClipDatas(h, _, s, a * c), this._setClipDatasToNode(h, _, o.defaultWeight, 0 === t), 
                            d || this._updateEventScript(h, s);
                        }
                        break;

                      case 1:
                        u = (h = o._currentPlayState)._clip;
                        var f = o._crossPlayState, m = f._clip, p = o._crossDuration, T = l._startPlayTime, S = m._duration - T, E = p > S ? S / p : 1, v = this._speed * f.speed;
                        this._updatePlayer(f, l, r * E * v, m.islooping);
                        var g = (l._elapsedTime - T) / E / p;
                        g >= 1 ? e && (this._updateClipDatas(f, _, l, a * v), this._setClipDatasToNode(f, _, o.defaultWeight, 0 === t), 
                        o._playType = 0, o._currentPlayState = f, l._cloneTo(s)) : (s._finish || (c = this._speed * h.speed, 
                        this._updatePlayer(h, s, r * c, u.islooping), e && this._updateClipDatas(h, _, s, a * c)), 
                        e && (this._updateClipDatas(f, _, l, a * E * v), this._setCrossClipDatasToNode(o, h, f, g, 0 === t))), 
                        e && (this._updateEventScript(h, s), this._updateEventScript(f, l));
                        break;

                      case 2:
                        m = (f = o._crossPlayState)._clip, p = o._crossDuration, T = l._startPlayTime, E = p > (S = m._duration - T) ? S / p : 1, 
                        v = this._speed * f.speed, this._updatePlayer(f, l, r * E * v, m.islooping), e && ((g = (l._elapsedTime - T) / E / p) >= 1 ? (this._updateClipDatas(f, _, l, a * v), 
                        this._setClipDatasToNode(f, _, 1, 0 === t), o._playType = 0, o._currentPlayState = f, 
                        l._cloneTo(s)) : (this._updateClipDatas(f, _, l, a * E * v), this._setFixedCrossClipDatasToNode(o, f, g, 0 === t)), 
                        this._updateEventScript(f, l));
                    }
                }
                e && this._avatar && (R.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices), 
                this._updateAvatarNodesToSprite());
            }
        }, t._cloneTo = function(e) {
            var t = e;
            t.avatar = this.avatar;
            for (var n = 0, i = this._controllerLayers.length; n < i; n++) {
                var r = this._controllerLayers[n];
                t.addControllerLayer(r.clone());
                for (var a = r._states, o = 0, s = a.length; o < s; o++) {
                    var l = a[o].clone();
                    t.addState(l, n), 0 == o && (t.getControllerLayer(n).defaultState = l);
                }
            }
            t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
        }, t.getDefaultState = function(e) {
            return void 0 === e && (e = 0), this._controllerLayers[e].defaultState;
        }, t.addState = function(e, t) {
            void 0 === t && (t = 0);
            var n = e.name, i = this._controllerLayers[t], r = i._statesMap, a = i._states;
            if (r[n]) throw "Animator:this stat's name has exist.";
            r[n] = e, a.push(e), e._clip._addReference(), this._getOwnersByClip(e);
        }, t.removeState = function(e, t) {
            void 0 === t && (t = 0);
            for (var n = this._controllerLayers[t], i = n._states, r = n._statesMap, a = -1, o = 0, s = i.length; o < s; o++) if (i[o] === e) {
                a = o;
                break;
            }
            -1 !== a && this._removeClip(i, r, a, e);
        }, t.addControllerLayer = function(e) {
            this._controllerLayers.push(e);
        }, t.getControllerLayer = function(e) {
            return void 0 === e && (e = 0), this._controllerLayers[e];
        }, t.getCurrentAnimatorPlayState = function(e) {
            return void 0 === e && (e = 0), this._controllerLayers[e]._playStateInfo;
        }, t.play = function(e, t, n) {
            void 0 === t && (t = 0), void 0 === n && (n = Number.NEGATIVE_INFINITY);
            var i = this._controllerLayers[t], r = i.defaultState;
            if (!e && !r) throw new Error("Animator:must have  default clip value,please set clip property.");
            var a = i._currentPlayState, o = i._playStateInfo, s = e ? i._statesMap[e] : r, l = s._clip._duration;
            a !== s ? (n !== Number.NEGATIVE_INFINITY ? o._resetPlayState(l * n) : o._resetPlayState(0), 
            null !== a && a !== s && this._revertDefaultKeyframeNodes(a), i._playType = 0, i._currentPlayState = s) : n !== Number.NEGATIVE_INFINITY && (o._resetPlayState(l * n), 
            i._playType = 0);
            var h = s._scripts;
            if (h) for (var u = 0, c = h.length; u < c; u++) h[u].onStateEnter();
        }, t.crossFade = function(e, t, n, i) {
            void 0 === n && (n = 0), void 0 === i && (i = Number.NEGATIVE_INFINITY);
            var r = this._controllerLayers[n], a = r._statesMap[e];
            if (a) {
                var o = r._playType;
                if (-1 === o) return void this.play(e, n, i);
                var s = r._crossPlayStateInfo, l = r._crossNodesOwners, h = r._crossNodesOwnersIndicesMap, u = r._currentPlayState, c = a._nodeOwners, d = r._destCrossClipNodeIndices, _ = a._clip, f = _._nodes, m = _._nodesDic;
                switch (o) {
                  case 0:
                    var p = u._nodeOwners, T = r._srcCrossClipNodeIndices, S = u._clip, E = S._nodes, v = S._nodesDic;
                    r._playType = 1;
                    for (var g = ++r._crossMark, x = r._crossNodesOwnersCount = 0, M = 0, y = E.count; M < y; M++) {
                        var D = E.getNodeByIndex(M), R = D._indexInList, C = p[R];
                        if (C) {
                            var I = D.fullPath;
                            T[x] = R;
                            var A = m[I];
                            d[x] = A ? A._indexInList : -1, h[I] = g, l[x] = C, x++;
                        }
                    }
                    for (M = 0, y = f.count; M < y; M++) {
                        var L = (A = f.getNodeByIndex(M))._indexInList, O = c[L];
                        if (O) {
                            var P = A.fullPath;
                            v[P] || (T[x] = -1, d[x] = L, h[P] = g, l[x] = O, x++);
                        }
                    }
                    break;

                  case 1:
                  case 2:
                    for (r._playType = 2, M = 0, y = l.length; M < y; M++) {
                        var V = l[M];
                        V.saveCrossFixedValue(), A = m[V.fullPath], d[M] = A ? A._indexInList : -1;
                    }
                    for (x = r._crossNodesOwnersCount, g = r._crossMark, M = 0, y = f.count; M < y; M++) (O = c[L = (A = f.getNodeByIndex(M))._indexInList]) && h[P = A.fullPath] !== g && (d[x] = L, 
                    h[P] = g, V = c[L], l[x] = V, V.saveCrossFixedValue(), x++);
                }
                r._crossNodesOwnersCount = x, r._crossPlayState = a, r._crossDuration = u._clip._duration * t, 
                i !== Number.NEGATIVE_INFINITY ? s._resetPlayState(_._duration * i) : s._resetPlayState(0);
            }
            var N = a._scripts;
            if (N) for (M = 0, y = N.length; M < y; M++) N[M].onStateEnter();
        }, t._getAvatarOwnersAndInitDatasAsync = function() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) for (var n = this._controllerLayers[e]._states, i = 0, r = n.length; i < r; i++) this._getOwnersByClip(n[i]);
            for (var a in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                var o = this._linkAvatarSpritesData[a];
                if (o) for (var s = 0, l = o.length; s < l; s++) this._isLinkSpriteToAnimationNode(o[s], a, !0);
            }
        }, t._isLinkSpriteToAnimationNode = function(e, t, n) {
            if (this._avatar) {
                var i = this._avatarNodeMap[t];
                if (i) if (n) {
                    e._transform._dummy = i.transform, this._linkAvatarSprites.push(e);
                    var r = i.transform, a = e.transform;
                    if (!a.owner.isStatic && r) {
                        var o = a.worldMatrix, s = this.owner._transform._parent;
                        if (s) ke.matrix4x4MultiplyMFM(s.worldMatrix, r.getWorldMatrix(), o); else for (var l = o.elements, h = r.getWorldMatrix(), u = 0; u < 16; u++) l[u] = h[u];
                        a.worldMatrix = o;
                    }
                } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
            }
        }, t._isLinkSpriteToAnimationNodeData = function(e, t, n) {
            var i = this._linkAvatarSpritesData[t];
            n ? (i || (this._linkAvatarSpritesData[t] = i = []), i.push(e)) : i.splice(e, 1);
        }, t._updateAvatarNodesToSprite = function() {
            for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                var n = this._linkAvatarSprites[e], i = n.transform._dummy, r = n.transform;
                if (!r.owner.isStatic && i) {
                    var a = r.worldMatrix, o = this.owner._transform;
                    ke.matrix4x4MultiplyMFM(o.worldMatrix, i.getWorldMatrix(), a), r.worldMatrix = a;
                }
            }
        }, t.linkSprite3DToAvatarNode = function(e, t) {
            return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), 
            !0;
        }, t.unLinkSprite3DToAvatarNode = function(e) {
            if (e._hierarchyAnimator === this) {
                var t = e.transform._dummy;
                if (t) {
                    var n = t._owner.name;
                    return this._isLinkSpriteToAnimationNodeData(e, n, !1), this._isLinkSpriteToAnimationNode(e, n, !1), 
                    !0;
                }
                return !1;
            }
            throw "Animator:sprite3D must belong to this Animator";
        }, t._updateAnimationNodeWorldMatix = function(e, t, n, i, r) {
            E.instance.updateAnimationNodeWorldMatix(e, t, n, r, i);
        }, a(0, t, "speed", function() {
            return this._speed;
        }, function(e) {
            this._speed = e;
        }), a(0, t, "avatar", function() {
            return this._avatar;
        }, function(e) {
            if (this._avatar !== e) if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(), 
            this.owner._changeHierarchyAnimatorAvatar(this, e); else {
                var t = this.owner._parent;
                this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
            }
        }), Animator._update = function(e) {
            for (var t = e._animatorPool, n = t.elements, i = 0, r = t.length; i < r; i++) {
                var a = n[i];
                a && a.enabled && a._update();
            }
        }, Animator._tempVector3Array0 = new Float32Array(3), Animator._tempVector3Array1 = new Float32Array(3), 
        Animator._tempQuaternionArray0 = new Float32Array(4), Animator._tempQuaternionArray1 = new Float32Array(4), 
        Animator.CULLINGMODE_ALWAYSANIMATE = 0, Animator.CULLINGMODE_CULLCOMPLETELY = 2, 
        i(Animator, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempQuaternion0", function() {
            return this._tempQuaternion0 = new he();
        }, "_tempQuaternion1", function() {
            return this._tempQuaternion1 = new he();
        } ]), Animator;
    }(), Kt = function(e) {
        function AnimationTransform3D(e, t, n, i, r) {
            AnimationTransform3D.__super.call(this), this._owner = e, this._children = [], this._localMatrix = new Float32Array(16), 
            R.supportWebGLPlusAnimation ? (this._localPosition = new G(0, 0, 0, t), this._localRotation = new U(0, 0, 0, 1, n), 
            this._localScale = new G(0, 0, 0, i), this._worldMatrix = r) : (this._localPosition = new Te(), 
            this._localRotation = new he(), this._localScale = new Te(), this._worldMatrix = new Float32Array(16)), 
            this._localQuaternionUpdate = !1, this._locaEulerlUpdate = !1, this._localUpdate = !1, 
            this._worldUpdate = !0;
        }
        r(AnimationTransform3D, "laya.d3.animation.AnimationTransform3D", T);
        var t = AnimationTransform3D.prototype;
        return t._getlocalMatrix = function() {
            return this._localUpdate && (ke._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix), 
            this._localUpdate = !1), this._localMatrix;
        }, t._onWorldTransform = function() {
            if (!this._worldUpdate) {
                this._worldUpdate = !0, this.event("transformchanged");
                for (var e = 0, t = this._children.length; e < t; e++) this._children[e]._onWorldTransform();
            }
        }, t.getWorldMatrix = function() {
            if (!R.supportWebGLPlusAnimation && this._worldUpdate) {
                if (null != this._parent) ke.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix); else {
                    var e = this._worldMatrix;
                    e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0, 
                    e[0] = e[5] = e[10] = e[15] = 1;
                }
                this._worldUpdate = !1;
            }
            return R.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1), 
            this._worldMatrix;
        }, t.setParent = function(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children, n = t.indexOf(this);
                    t.splice(n, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }, a(0, t, "localPosition", function() {
            return this._localPosition;
        }, function(e) {
            this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
        }), a(0, t, "localRotation", function() {
            if (this._localQuaternionUpdate) {
                var e = this._localRotationEuler;
                he.createFromYawPitchRoll(e.y / AnimationTransform3D._angleToRandin, e.x / AnimationTransform3D._angleToRandin, e.z / AnimationTransform3D._angleToRandin, this._localRotation), 
                this._localQuaternionUpdate = !1;
            }
            return this._localRotation;
        }, function(e) {
            this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1, 
            this._localUpdate = !0, this._onWorldTransform();
        }), a(0, t, "localScale", function() {
            return this._localScale;
        }, function(e) {
            this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
        }), a(0, t, "localRotationEuler", function() {
            if (this._locaEulerlUpdate) {
                this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                var e = AnimationTransform3D._tempVector3, t = this._localRotationEuler;
                t.x = e.y * AnimationTransform3D._angleToRandin, t.y = e.x * AnimationTransform3D._angleToRandin, 
                t.z = e.z * AnimationTransform3D._angleToRandin, this._locaEulerlUpdate = !1;
            }
            return this._localRotationEuler;
        }, function(e) {
            this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0, 
            this._localUpdate = !0, this._onWorldTransform();
        }), i(AnimationTransform3D, [ "_tempVector3", function() {
            return this._tempVector3 = new Te();
        }, "_angleToRandin", function() {
            return this._angleToRandin = 180 / Math.PI;
        } ]), AnimationTransform3D;
    }(), Qt = function(e) {
        function VertexBuffer3D(e, t, n, i) {
            if (this._vertexCount = 0, this._canRead = !1, this._dataType = 0, this._vertexDeclaration = null, 
            void 0 === n && (n = !1), void 0 === i && (i = 0), VertexBuffer3D.__super.call(this), 
            this._vertexCount = -1, this._bufferUsage = t, this._bufferType = 34962, this._canRead = n, 
            this._dataType = i, this._byteLength = e, this.bind(), E.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage), 
            n) switch (i) {
              case 0:
                this._buffer = new Float32Array(e / 4);
                break;

              case 1:
                this._buffer = new Uint8Array(e);
            }
        }
        r(VertexBuffer3D, "laya.d3.graphics.VertexBuffer3D", e);
        var t = VertexBuffer3D.prototype;
        return t.bind = function() {
            return h._bindedVertexBuffer !== this._glBuffer && (E.instance.bindBuffer(34962, this._glBuffer), 
            h._bindedVertexBuffer = this._glBuffer, !0);
        }, t.setData = function(e, t, n, i) {
            if (void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 4294967295), 
            this.bind(), 0 !== n || 4294967295 !== i) switch (this._dataType) {
              case 0:
                e = new Float32Array(e.buffer, 4 * n, i);
                break;

              case 1:
                e = new Uint8Array(e.buffer, n, i);
            }
            switch (this._dataType) {
              case 0:
                E.instance.bufferSubData(this._bufferType, 4 * t, e);
                break;

              case 1:
                E.instance.bufferSubData(this._bufferType, t, e);
            }
            this._canRead && this._buffer.set(e, t);
        }, t.getData = function() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }, t.destroy = function() {
            e.prototype.destroy.call(this), this._buffer = null, this._vertexDeclaration = null;
        }, a(0, t, "vertexDeclaration", function() {
            return this._vertexDeclaration;
        }, function(e) {
            this._vertexDeclaration !== e && (this._vertexDeclaration = e, this._vertexCount = e ? this._byteLength / e.vertexStride : -1);
        }), a(0, t, "vertexCount", function() {
            return this._vertexCount;
        }), a(0, t, "canRead", function() {
            return this._canRead;
        }), VertexBuffer3D.DATATYPE_FLOAT32ARRAY = 0, VertexBuffer3D.DATATYPE_UINT8ARRAY = 1, 
        VertexBuffer3D;
    }(h), jt = (function(e) {
        function ConstraintComponent() {
            this._nativeConstraint = null, this._breakingImpulseThreshold = NaN, this._connectedBody = null, 
            this._feedbackEnabled = !1, ConstraintComponent.__super.call(this);
        }
        r(ConstraintComponent, "laya.d3.physics.constraints.ConstraintComponent", f);
        var t = ConstraintComponent.prototype;
        t._onDestroy = function() {
            X._physics3D.destroy(this._nativeConstraint), this._nativeConstraint = null;
        }, a(0, t, "breakingImpulseThreshold", function() {
            return this._breakingImpulseThreshold;
        }, function(e) {
            this._nativeConstraint.BreakingImpulseThreshold = e, this._breakingImpulseThreshold = e;
        }), a(0, t, "enabled", function() {
            return n.superGet(f, this, "enabled");
        }, function(e) {
            this._nativeConstraint.IsEnabled = e, n.superSet(f, this, "enabled", e);
        }), a(0, t, "appliedImpulse", function() {
            return this._feedbackEnabled || (this._nativeConstraint.EnableFeedback(!0), this._feedbackEnabled = !0), 
            this._nativeConstraint.AppliedImpulse;
        }), a(0, t, "connectedBody", function() {
            return this._connectedBody;
        }, function(e) {
            this._connectedBody = e;
        });
    }(), function(e) {
        function IndexBuffer3D(e, t, n, i) {
            this._indexType = null, this._indexTypeByteCount = 0, this._indexCount = 0, this._canRead = !1, 
            void 0 === n && (n = 35044), void 0 === i && (i = !1), IndexBuffer3D.__super.call(this), 
            this._indexType = e, this._indexCount = t, this._bufferUsage = n, this._bufferType = 34963, 
            this._canRead = i;
            var r;
            if ("ushort" == e) this._indexTypeByteCount = 2; else {
                if ("ubyte" != e) throw new Error("unidentification index type.");
                this._indexTypeByteCount = 1;
            }
            r = this._indexTypeByteCount * t, this._byteLength = r;
            var a = u._curBindedBufferState;
            a ? a._bindedIndexBuffer === this ? E.instance.bufferData(this._bufferType, r, this._bufferUsage) : (a.unBind(), 
            this.bind(), E.instance.bufferData(this._bufferType, r, this._bufferUsage), a.bind()) : (this.bind(), 
            E.instance.bufferData(this._bufferType, r, this._bufferUsage)), i && ("ushort" == e ? this._buffer = new Uint16Array(t) : "ubyte" == e && (this._buffer = new Uint8Array(t)));
        }
        r(IndexBuffer3D, "laya.d3.graphics.IndexBuffer3D", e);
        var t = IndexBuffer3D.prototype;
        return t._bindForVAO = function() {
            if (!u._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
            E.instance.bindBuffer(34963, this._glBuffer);
        }, t.bind = function() {
            if (u._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
            return h._bindedIndexBuffer !== this._glBuffer && (E.instance.bindBuffer(34963, this._glBuffer), 
            h._bindedIndexBuffer = this._glBuffer, !0);
        }, t.setData = function(e, t, n, i) {
            void 0 === t && (t = 0), void 0 === n && (n = 0), void 0 === i && (i = 4294967295);
            var r = 0;
            "ushort" == this._indexType ? (r = 2, 0 === n && 4294967295 === i || (e = new Uint16Array(e.buffer, n * r, i))) : "ubyte" == this._indexType && (r = 1, 
            0 === n && 4294967295 === i || (e = new Uint8Array(e.buffer, n * r, i)));
            var a = u._curBindedBufferState;
            if (a ? a._bindedIndexBuffer === this ? E.instance.bufferSubData(this._bufferType, t * r, e) : (a.unBind(), 
            this.bind(), E.instance.bufferSubData(this._bufferType, t * r, e), a.bind()) : (this.bind(), 
            E.instance.bufferSubData(this._bufferType, t * r, e)), this._canRead) if (0 !== t || 0 !== n || 4294967295 !== i) {
                var o = this._buffer.length - t;
                i > o && (i = o);
                for (var s = 0; s < i; s++) this._buffer[t + s] = e[s];
            } else this._buffer = e;
        }, t.getData = function() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }, t.destroy = function() {
            e.prototype.destroy.call(this), this._buffer = null;
        }, a(0, t, "indexType", function() {
            return this._indexType;
        }), a(0, t, "indexTypeByteCount", function() {
            return this._indexTypeByteCount;
        }), a(0, t, "indexCount", function() {
            return this._indexCount;
        }), a(0, t, "canRead", function() {
            return this._canRead;
        }), IndexBuffer3D.INDEXTYPE_UBYTE = "ubyte", IndexBuffer3D.INDEXTYPE_USHORT = "ushort", 
        IndexBuffer3D;
    }(h)), qt = function(e) {
        function ShaderPass(e, t, n, i) {
            this._renderState = new Z(), this._owner = e, this._cacheSharders = [], this._publicValidDefine = 0, 
            this._spriteValidDefine = 0, this._materialValidDefine = 0, this._validDefineMap = {}, 
            ShaderPass.__super.call(this, t, n, null, this._validDefineMap);
            var r = this._owner._publicDefinesMap, a = this._owner._spriteDefinesMap, o = this._owner._materialDefinesMap;
            for (var s in this._validDefineMap) null != r[s] ? this._publicValidDefine |= r[s] : null != a[s] ? this._spriteValidDefine |= a[s] : null != o[s] && (this._materialValidDefine |= o[s]);
            this._stateMap = i;
        }
        r(ShaderPass, "laya.d3.shader.ShaderPass", A);
        var t = ShaderPass.prototype;
        return t._definesToNameDic = function(e, t) {
            for (var n = {}, i = 1, r = 0; r < 32 && !((i = 1 << r) > e); r++) {
                e & i && (n[t[i]] = "");
            }
            return n;
        }, t._compileToTree = function(e, t, n, i, r) {
            var a, o, s, l, h, u, c, d = 0, _ = 0, f = 0, m = 0;
            for (_ = n; _ < t.length; _++) if (!((s = t[_]).length < 1) && 0 !== (d = s.indexOf("//"))) {
                if (d >= 0 && (s = s.substr(0, d)), a = c || new L(i), c = null, a.text = s, (d = s.indexOf("#")) >= 0) {
                    for (l = "#", m = d + 1, f = s.length; m < f; m++) {
                        var p = s.charAt(m);
                        if (" " === p || "\t" === p || "?" === p) break;
                        l += p;
                    }
                    switch (a.name = l, l) {
                      case "#ifdef":
                      case "#ifndef":
                        if (a.setParent(e), e = a, r) for (u = s.substr(m).split(A._splitToWordExps3), m = 0; m < u.length; m++) (s = u[m]).length && (r[s] = !0);
                        continue;

                      case "#if":
                      case "#elif":
                        if (a.setParent(e), e = a, r) for (u = s.substr(m).split(A._splitToWordExps3), m = 0; m < u.length; m++) (s = u[m]).length && "defined" != s && (r[s] = !0);
                        continue;

                      case "#else":
                        o = (e = e.parent).childs[e.childs.length - 1], a.setParent(e), e = a;
                        continue;

                      case "#endif":
                        o = (e = e.parent).childs[e.childs.length - 1], a.setParent(e);
                        continue;

                      case "#include":
                        u = A.splitToWords(s, null);
                        var T = A.includes[u[1]];
                        if (!T) throw "ShaderCompile error no this include file:" + u[1];
                        if ((d = u[0].indexOf("?")) < 0) {
                            a.setParent(e), s = T.getWith("with" == u[2] ? u[3] : null), this._compileToTree(a, s.split("\n"), 0, i, r), 
                            a.text = "";
                            continue;
                        }
                        a.setCondition(u[0].substr(d + 1), 1), a.text = T.getWith("with" == u[2] ? u[3] : null);
                        break;

                      case "#import":
                        h = (u = A.splitToWords(s, null))[1], i.push({
                            node: a,
                            file: A.includes[h],
                            ofs: a.text.length
                        });
                        continue;
                    }
                } else {
                    if ((o = e.childs[e.childs.length - 1]) && !o.name) {
                        i.length > 0 && A.splitToWords(s, o), c = a, o.text += "\n" + s;
                        continue;
                    }
                    i.length > 0 && A.splitToWords(s, a);
                }
                a.setParent(e);
            }
        }, t.withCompile = function(e, t, n) {
            var i, r, a;
            if (e &= this._publicValidDefine, t &= this._spriteValidDefine, n &= this._materialValidDefine, 
            r = this._cacheSharders[e]) if (a = r[t]) {
                if (i = a[n]) return i;
            } else a = r[t] = []; else a = (r = this._cacheSharders[e] = [])[t] = [];
            var o, s = this._definesToNameDic(e, this._owner._publicDefines), l = this._definesToNameDic(t, this._owner._spriteDefines), h = this._definesToNameDic(n, this._owner._materialDefines);
            if (Ve.debugMode) {
                var u = "";
                for (o in s) u += o + " ";
                var c = "";
                for (o in l) c += o + " ";
                var d = "";
                for (o in h) d += o + " ";
                b.shaderHighPrecision || (e += Ve.SHADERDEFINE_HIGHPRECISION), console.log("%cShader3DDebugMode---(Name:" + this._owner._owner._name + " PassIndex:" + this._owner._passes.indexOf(this) + " PublicDefine:" + e + " SpriteDefine:" + t + " MaterialDefine:" + n + " PublicDefineGroup:" + u + " SpriteDefineGroup:" + c + "MaterialDefineGroup: " + d + ")---ShaderCompile3DDebugMode", "color:green");
            }
            var _ = {}, f = "";
            if (s) for (o in s) f += "#define " + o + "\n", _[o] = !0;
            if (l) for (o in l) f += "#define " + o + "\n", _[o] = !0;
            if (h) for (o in h) f += "#define " + o + "\n", _[o] = !0;
            var m = this._VS.toscript(_, []), p = "";
            0 == m[0].indexOf("#version") && (p = m[0] + "\n", m.shift());
            var T = this._PS.toscript(_, []), S = "";
            return 0 == T[0].indexOf("#version") && (S = T[0] + "\n", T.shift()), i = new Wn(p + f + m.join("\n"), S + f + T.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this), 
            a[n] = i, i;
        }, a(0, t, "renderState", function() {
            return this._renderState;
        }), ShaderPass;
    }(), Jt = function(e) {
        function BufferState() {
            BufferState.__super.call(this);
        }
        r(BufferState, "laya.d3.core.BufferState", u);
        var t = BufferState.prototype;
        return t.applyVertexBuffer = function(e) {
            if (u._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            var t = E.instance, n = e.vertexDeclaration, i = null;
            for (var r in i = R.supportWebGLPlusRendering ? n._shaderValues._nativeArray : n._shaderValues.getData(), 
            e.bind(), i) {
                var a = parseInt(r), o = i[r];
                t.enableVertexAttribArray(a), t.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]);
            }
        }, t.applyVertexBuffers = function(e) {
            if (u._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            for (var t = E.instance, n = 0, i = e.length; n < i; n++) {
                var r = e[n], a = r.vertexDeclaration, o = null;
                for (var s in o = R.supportWebGLPlusRendering ? a._shaderValues._nativeArray : a._shaderValues.getData(), 
                r.bind(), o) {
                    var l = parseInt(s), h = o[s];
                    t.enableVertexAttribArray(l), t.vertexAttribPointer(l, h[0], h[1], !!h[2], h[3], h[4]);
                }
            }
        }, t.applyInstanceVertexBuffer = function(e) {
            if (F._angleInstancedArrays) {
                if (u._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var t = E.instance, n = e.vertexDeclaration, i = null;
                for (var r in i = R.supportWebGLPlusRendering ? n._shaderValues._nativeArray : n._shaderValues.getData(), 
                e.bind(), i) {
                    var a = parseInt(r), o = i[r];
                    t.enableVertexAttribArray(a), t.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]), 
                    F._angleInstancedArrays.vertexAttribDivisorANGLE(a, 1);
                }
            }
        }, t.applyIndexBuffer = function(e) {
            if (u._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
        }, BufferState;
    }(), $t = function(e) {
        function ConeShape() {
            this.angle = NaN, this.radius = NaN, this.length = NaN, this.emitType = 0, ConeShape.__super.call(this), 
            this.angle = 25 / 180 * Math.PI, this.radius = 1, this.length = 5, this.emitType = 0, 
            this.randomDirection = !1;
        }
        r(ConeShape, "laya.d3.core.particleShuriKen.module.shape.ConeShape", e);
        var t = ConeShape.prototype;
        return t._getShapeBoundBox = function(e) {
            var t = this.radius + this.length * Math.sin(this.angle), n = this.length * Math.cos(this.angle), i = e.min;
            i.x = i.y = -t, i.z = 0;
            var r = e.max;
            r.x = r.y = t, r.z = n;
        }, t._getSpeedBoundBox = function(e) {
            var t = Math.sin(this.angle), n = e.min;
            n.x = n.y = -t, n.z = 0;
            var i = e.max;
            i.x = i.y = t, i.z = 1;
        }, t.generatePositionAndDirection = function(e, t, n, i) {
            var r, a = ConeShape._tempPositionPoint, o = NaN, s = NaN, l = Math.cos(this.angle), h = Math.sin(this.angle);
            switch (this.emitType) {
              case 0:
                n ? (n.seed = i[16], Lt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, n), 
                i[16] = n.seed) : Lt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), 
                o = a.x, s = a.y, e.x = o * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (n ? (n.seed = i[17], 
                Lt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, n), i[17] = n.seed) : Lt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), 
                r = ConeShape._tempDirectionPoint, t.x = r.x * h, t.y = r.y * h) : (t.x = o * h, 
                t.y = s * h), t.z = l;
                break;

              case 1:
                n ? (n.seed = i[16], Lt._randomPointUnitCircle(ConeShape._tempPositionPoint, n), 
                i[16] = n.seed) : Lt._randomPointUnitCircle(ConeShape._tempPositionPoint), o = a.x, 
                s = a.y, e.x = o * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (n ? (n.seed = i[17], 
                Lt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, n), i[17] = n.seed) : Lt._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint), 
                r = ConeShape._tempDirectionPoint, t.x = r.x * h, t.y = r.y * h) : (t.x = o * h, 
                t.y = s * h), t.z = l;
                break;

              case 2:
                n ? (n.seed = i[16], Lt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, n)) : Lt._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), 
                o = a.x, s = a.y, e.x = o * this.radius, e.y = s * this.radius, e.z = 0, t.x = o * h, 
                t.y = s * h, t.z = l, Te.normalize(t, t), n ? (Te.scale(t, this.length * n.getFloat(), t), 
                i[16] = n.seed) : Te.scale(t, this.length * Math.random(), t), Te.add(e, t, e), 
                this.randomDirection && (n ? (n.seed = i[17], Lt._randomPointUnitSphere(t, n), i[17] = n.seed) : Lt._randomPointUnitSphere(t));
                break;

              case 3:
                n ? (n.seed = i[16], Lt._randomPointUnitCircle(ConeShape._tempPositionPoint, n)) : Lt._randomPointUnitCircle(ConeShape._tempPositionPoint), 
                o = a.x, s = a.y, e.x = o * this.radius, e.y = s * this.radius, e.z = 0, t.x = o * h, 
                t.y = s * h, t.z = l, Te.normalize(t, t), n ? (Te.scale(t, this.length * n.getFloat(), t), 
                i[16] = n.seed) : Te.scale(t, this.length * Math.random(), t), Te.add(e, t, e), 
                this.randomDirection && (n ? (n.seed = i[17], Lt._randomPointUnitSphere(t, n), i[17] = n.seed) : Lt._randomPointUnitSphere(t));
                break;

              default:
                throw new Error("ConeShape:emitType is invalid.");
            }
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.angle = this.angle, n.radius = this.radius, n.length = this.length, n.emitType = this.emitType, 
            n.randomDirection = this.randomDirection;
        }, i(ConeShape, [ "_tempPositionPoint", function() {
            return this._tempPositionPoint = new Se();
        }, "_tempDirectionPoint", function() {
            return this._tempDirectionPoint = new Se();
        } ]), ConeShape;
    }(k), en = function(e) {
        function SphereColliderShape(e) {
            SphereColliderShape.__super.call(this), void 0 === e && (e = .5), this._radius = e, 
            this._type = 1, this._nativeShape = new X._physics3D.btSphereShape(e);
        }
        r(SphereColliderShape, "laya.d3.physics.shape.SphereColliderShape", W);
        var t = SphereColliderShape.prototype;
        return t.clone = function() {
            var e = new SphereColliderShape(this._radius);
            return this.cloneTo(e), e;
        }, a(0, t, "radius", function() {
            return this._radius;
        }), SphereColliderShape;
    }(), tn = function(e) {
        function CircleShape() {
            this.radius = NaN, this.arc = NaN, this.emitFromEdge = !1, CircleShape.__super.call(this), 
            this.radius = 1, this.arc = 2 * Math.PI, this.emitFromEdge = !1, this.randomDirection = !1;
        }
        r(CircleShape, "laya.d3.core.particleShuriKen.module.shape.CircleShape", e);
        var t = CircleShape.prototype;
        return t._getShapeBoundBox = function(e) {
            var t = e.min;
            t.x = t.z = -this.radius, t.y = 0;
            var n = e.max;
            n.x = n.z = this.radius, n.y = 0;
        }, t._getSpeedBoundBox = function(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var n = e.max;
            n.x = n.y = 1, n.z = 0;
        }, t.generatePositionAndDirection = function(e, t, n, i) {
            var r = CircleShape._tempPositionPoint;
            n ? (n.seed = i[16], this.emitFromEdge ? Lt._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, n) : Lt._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, n), 
            i[16] = n.seed) : this.emitFromEdge ? Lt._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : Lt._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint), 
            e.x = -r.x, e.y = r.y, e.z = 0, Te.scale(e, this.radius, e), this.randomDirection ? n ? (n.seed = i[17], 
            Lt._randomPointUnitSphere(t, n), i[17] = n.seed) : Lt._randomPointUnitSphere(t) : e.cloneTo(t);
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.radius = this.radius, n.arc = this.arc, n.emitFromEdge = this.emitFromEdge, n.randomDirection = this.randomDirection;
        }, i(CircleShape, [ "_tempPositionPoint", function() {
            return this._tempPositionPoint = new Se();
        } ]), CircleShape;
    }(k), nn = function(e) {
        function BlitCMD() {
            this._source = null, this._dest = null, this._shader = null, this._shaderData = null, 
            this._subShader = 0, BlitCMD.__super.call(this);
        }
        r(BlitCMD, "laya.d3.core.render.command.BlitCMD", q);
        var t = BlitCMD.prototype;
        return t.run = function() {
            this._shaderData.setTexture(lt.SCREENTEXTURE_ID, this._source);
            var e = this._dest;
            e && e._start();
            for (var t = this._shader.getSubShaderAt(this._subShader)._passes, n = 0, i = t.length; n < i; n++) {
                var r = t[n].withCompile(0, 0, 0);
                r.bind(), this._shaderData && r.uploadUniforms(r._materialUniformParamsMap, this._shaderData, !0), 
                r.uploadRenderStateBlendDepth(this._shaderData), r.uploadRenderStateFrontFace(this._shaderData, !0, null), 
                Un.instance.render();
            }
            e && e._end();
        }, t.recover = function() {
            BlitCMD._pool.push(this), this._dest = null, this._shader = null, this._shaderData = null;
        }, BlitCMD.create = function(e, t, n, i, r) {
            var a;
            return void 0 === r && (r = 0), (a = BlitCMD._pool.length > 0 ? BlitCMD._pool.pop() : new BlitCMD())._source = e, 
            a._dest = t, a._shader = n, a._shaderData = i, a._subShader = r, a;
        }, BlitCMD._pool = [], BlitCMD;
    }(), rn = function(e) {
        function CastShadowList() {
            CastShadowList.__super.call(this);
        }
        r(CastShadowList, "laya.d3.CastShadowList", $);
        var t = CastShadowList.prototype;
        return t.add = function(e) {
            if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
            this._add(e), e._indexInCastShadowList = this.length++;
        }, t.remove = function(e) {
            var t = e._indexInCastShadowList;
            if (this.length--, t !== this.length) {
                var n = this.elements[this.length];
                this.elements[t] = n, n._indexInCastShadowList = t;
            }
            e._indexInCastShadowList = -1;
        }, CastShadowList;
    }(), an = function(e) {
        function CapsuleColliderShape(e, t, n) {
            switch (CapsuleColliderShape.__super.call(this), void 0 === e && (e = .5), void 0 === t && (t = 1.25), 
            void 0 === n && (n = 1), this._radius = e, this._length = t, this._orientation = n, 
            this._type = 3, n) {
              case 0:
                this._nativeShape = new X._physics3D.btCapsuleShapeX(e, t - 2 * e);
                break;

              case 1:
                this._nativeShape = new X._physics3D.btCapsuleShape(e, t - 2 * e);
                break;

              case 2:
                this._nativeShape = new X._physics3D.btCapsuleShapeZ(e, t - 2 * e);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        r(CapsuleColliderShape, "laya.d3.physics.shape.CapsuleColliderShape", e);
        var t = CapsuleColliderShape.prototype;
        return t._setScale = function(t) {
            var n = CapsuleColliderShape._tempVector30;
            switch (this.orientation) {
              case 0:
                n.x = t.x, n.y = n.z = Math.max(t.y, t.z);
                break;

              case 1:
                n.y = t.y, n.x = n.z = Math.max(t.x, t.z);
                break;

              case 2:
                n.z = t.z, n.x = n.y = Math.max(t.x, t.y);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
            e.prototype._setScale.call(this, n);
        }, t.clone = function() {
            var e = new CapsuleColliderShape(this._radius, this._length, this._orientation);
            return this.cloneTo(e), e;
        }, a(0, t, "radius", function() {
            return this._radius;
        }), a(0, t, "length", function() {
            return this._length;
        }), a(0, t, "orientation", function() {
            return this._orientation;
        }), i(CapsuleColliderShape, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        } ]), CapsuleColliderShape;
    }(W), on = function(e) {
        function SubMesh(e) {
            this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null, 
            this._subIndexBufferCount = null, this._skinAnimationDatas = null, this._indexInMesh = 0, 
            this._vertexStart = 0, this._indexStart = 0, this._indexCount = 0, this._indices = null, 
            this._vertexBuffer = null, this._indexBuffer = null, this._id = 0, SubMesh.__super.call(this), 
            this._id = ++SubMesh._uniqueIDCounter, this._mesh = e, this._boneIndicesList = [], 
            this._subIndexBufferStart = [], this._subIndexBufferCount = [];
        }
        r(SubMesh, "laya.d3.resource.models.SubMesh", e);
        var t = SubMesh.prototype;
        return t._getType = function() {
            return SubMesh._type;
        }, t._render = function(e) {
            this._mesh._bufferState.bind();
            var t = e.renderElement.render._skinnedData;
            if (t) for (var n = t[this._indexInMesh], i = this._boneIndicesList.length, r = 0; r < i; r++) e.shader.uploadCustomUniform(yi.BONES, n[r]), 
            E.instance.drawElements(4, this._subIndexBufferCount[r], 5123, 2 * this._subIndexBufferStart[r]); else E.instance.drawElements(4, this._indexCount, 5123, 2 * this._indexStart);
            P.trianglesFaces += this._indexCount / 3, P.renderBatches++;
        }, t.getIndices = function() {
            return this._indices;
        }, t.destroy = function() {
            this._destroyed || (e.prototype.destroy.call(this), this._indexBuffer.destroy(), 
            this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null, 
            this._subIndexBufferCount = null, this._skinAnimationDatas = null);
        }, SubMesh._uniqueIDCounter = 0, i(SubMesh, [ "_type", function() {
            return this._type = te._typeCounter++;
        } ]), SubMesh;
    }(te), sn = function(e) {
        function ShurikenParticleSystem(e) {
            ShurikenParticleSystem.__super.call(this), this._tempRotationMatrix = new Ht(), 
            this._uvLength = new Se(), this._bufferState = new Jt(), this._firstActiveElement = 0, 
            this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0, 
            this._owner = e, this._ownerRender = e.particleRenderer, this._boundingBoxCorners = o(8, null), 
            this._boundingSphere = new Ce(new Te(), Number.MAX_VALUE), this._boundingBox = new zt(new Te(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new Te(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)), 
            this._currentTime = 0, this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1, 
            this._burstsIndex = 0, this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0, 
            this._simulateUpdate = !1, this._bufferMaxParticles = 1, this.duration = 5, this.looping = !0, 
            this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0, 
            this.startDelayMax = 0, this._startLifetimeType = 0, this._startLifetimeConstant = 5, 
            this._startLifeTimeGradient = new We(), this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 5, 
            this._startLifeTimeGradientMin = new We(), this._startLifeTimeGradientMax = new We(), 
            this._maxStartLifetime = 5, this.startSpeedType = 0, this.startSpeedConstant = 5, 
            this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 5, this.threeDStartSize = !1, 
            this.startSizeType = 0, this.startSizeConstant = 1, this.startSizeConstantSeparate = new Te(1, 1, 1), 
            this.startSizeConstantMin = 0, this.startSizeConstantMax = 1, this.startSizeConstantMinSeparate = new Te(0, 0, 0), 
            this.startSizeConstantMaxSeparate = new Te(1, 1, 1), this.threeDStartRotation = !1, 
            this.startRotationType = 0, this.startRotationConstant = 0, this.startRotationConstantSeparate = new Te(0, 0, 0), 
            this.startRotationConstantMin = 0, this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = new Te(0, 0, 0), 
            this.startRotationConstantMaxSeparate = new Te(0, 0, 0), this.randomizeRotationDirection = 0, 
            this.startColorType = 0, this.startColorConstant = new me(1, 1, 1, 1), this.startColorConstantMin = new me(1, 1, 1, 1), 
            this.startColorConstantMax = new me(1, 1, 1, 1), this.gravityModifier = 0, this.simulationSpace = 1, 
            this.scaleMode = 0, this.playOnAwake = !0, this._rand = new Ne(0), this.autoRandomSeed = !0, 
            this.randomSeed = new Uint32Array(1), this._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length), 
            this.isPerformanceMode = !0, this._emission = new Re(), this._emission.enbale = !0;
        }
        r(ShurikenParticleSystem, "laya.d3.core.particleShuriKen.ShurikenParticleSystem", e);
        var t = ShurikenParticleSystem.prototype;
        return n.imps(t, {
            "laya.d3.core.IClone": !0
        }), t._getVertexBuffer = function(e) {
            return void 0 === e && (e = 0), 0 === e ? this._vertexBuffer : null;
        }, t._getIndexBuffer = function() {
            return this._indexBuffer;
        }, t._generateBoundingSphere = function() {
            var e = this._boundingSphere.center;
            e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
        }, t._generateBoundingBox = function() {
            var e = this._owner.particleRenderer, t = this._boundingBox.min, n = this._boundingBox.max, i = 0, r = 0, a = NaN;
            switch (this.startLifetimeType) {
              case 0:
                a = this.startLifetimeConstant;
                break;

              case 1:
                a = -Number.MAX_VALUE;
                var o = o;
                for (i = 0, r = o.gradientCount; i < r; i++) a = Math.max(a, o.getValueByIndex(i));
                break;

              case 2:
                a = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                break;

              case 3:
                a = -Number.MAX_VALUE;
                var s = s;
                for (i = 0, r = s.gradientCount; i < r; i++) a = Math.max(a, s.getValueByIndex(i));
                var l = l;
                for (i = 0, r = l.gradientCount; i < r; i++) a = Math.max(a, l.getValueByIndex(i));
            }
            var h, u, c, d, _ = NaN, f = NaN;
            switch (this.startSpeedType) {
              case 0:
                _ = f = this.startSpeedConstant;
                break;

              case 1:
                break;

              case 2:
                _ = this.startLifetimeConstantMin, f = this.startLifetimeConstantMax;
            }
            this._shape && this._shape.enable || (h = u = Te._ZERO, c = Te._ZERO, d = Te._UnitZ);
            var m, p, T = new Te(c.x * _, c.y * _, c.z * _), S = new Te(d.x * f, d.y * f, d.z * f);
            if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) {
                var E = this._velocityOverLifetime.velocity;
                switch (E.type) {
                  case 0:
                    E.constant;
                    break;

                  case 1:
                    new Te(E.gradientX.getAverageValue(), E.gradientY.getAverageValue(), E.gradientZ.getAverageValue());
                    break;

                  case 2:
                    E.constantMin, E.constantMax;
                    break;

                  case 3:
                    new Te(E.gradientXMin.getAverageValue(), E.gradientYMin.getAverageValue(), E.gradientZMin.getAverageValue()), 
                    new Te(E.gradientXMax.getAverageValue(), E.gradientYMax.getAverageValue(), E.gradientZMax.getAverageValue());
                }
            }
            var v, g, x = this._owner.transform, M = x.position, y = ShurikenParticleSystem._tempVector39, D = e.renderMode;
            switch (this.scaleMode) {
              case 0:
                var R = x.scale;
                m = R, y.x = R.x, y.y = R.z, y.z = R.y, 1 === D && (p = R);
                break;

              case 1:
                var C = x.localScale;
                m = C, y.x = C.x, y.y = C.z, y.z = C.y, 1 === D && (p = C);
                break;

              case 2:
                m = x.scale, y.x = y.y = y.z = 1, 1 === D && (p = Te._ONE);
            }
            switch (this._velocityOverLifetime && this._velocityOverLifetime.enbale || (v = new Te(T.x * a, T.y * a, T.z * a), 
            g = new Te(S.x * a, S.y * a, S.z * a), 2 != this.scaleMode ? (Te.add(h, v, t), Te.multiply(m, t, t), 
            Te.add(u, g, n), Te.multiply(m, n, n)) : (Te.multiply(m, h, t), Te.add(t, v, t), 
            Te.multiply(m, u, n), Te.add(n, g, n))), this.simulationSpace) {
              case 0:
                break;

              case 1:
                Te.add(t, M, t), Te.add(n, M, n);
            }
            var I = NaN, A = NaN;
            switch (this.startSizeType) {
              case 0:
                if (this.threeDStartSize) {
                    var L = L;
                    I = Math.max(L.x, L.y), 1 === D && (A = L.y);
                } else I = this.startSizeConstant, 1 === D && (A = this.startSizeConstant);
                break;

              case 1:
                break;

              case 2:
                if (this.threeDStartSize) {
                    var O = O;
                    I = Math.max(O.x, O.y), 1 === D && (A = O.y);
                } else I = this.startSizeConstantMax, 1 === D && (A = this.startSizeConstantMax);
            }
            if (this._sizeOverLifetime && this._sizeOverLifetime.enbale) {
                this._sizeOverLifetime.size;
                I *= this._sizeOverLifetime.size.getMaxSizeInGradient();
            }
            var P = ShurikenParticleSystem._tempVector30, V = NaN, N = NaN;
            switch (D) {
              case 0:
                V = I * ShurikenParticleSystem.halfKSqrtOf2, Te.scale(y, I, P), Te.subtract(t, P, t), 
                Te.add(n, P, n);
                break;

              case 1:
                var B = ShurikenParticleSystem._tempVector31, w = ShurikenParticleSystem._tempVector32, b = ShurikenParticleSystem._tempVector33, F = ShurikenParticleSystem._tempVector34;
                this._velocityOverLifetime && this._velocityOverLifetime.enbale || (Te.multiply(p, S, w), 
                Te.multiply(p, T, b));
                var U = A * e.stretchedBillboardLengthScale, z = Te.scalarLength(w) * e.stretchedBillboardSpeedScale + U, G = Te.scalarLength(b) * e.stretchedBillboardSpeedScale + U, H = ShurikenParticleSystem._tempVector35, k = ShurikenParticleSystem._tempVector36;
                Te.normalize(w, H), Te.scale(H, z, F), Te.subtract(g, F, F), Te.normalize(b, k), 
                Te.scale(k, G, B), Te.add(v, B, B), V = I * ShurikenParticleSystem.halfKSqrtOf2, 
                Te.scale(y, V, P);
                var W = ShurikenParticleSystem._tempVector37, X = ShurikenParticleSystem._tempVector38;
                Te.scale(H, .5, W), Te.scale(k, .5, X), Te.multiply(W, y, W), Te.multiply(X, y, X), 
                Te.add(t, X, t), Te.min(t, F, t), Te.subtract(t, P, t), Te.subtract(n, W, n), Te.max(n, B, n), 
                Te.add(n, P, n);
                break;

              case 2:
                N = .5 * (I *= Math.cos(.7853981633974483)), P.x = y.x * N, P.y = y.z * N, Te.subtract(t, P, t), 
                Te.add(n, P, n);
                break;

              case 3:
                N = .5 * (I *= Math.cos(.7853981633974483)), Te.scale(y, N, P), Te.subtract(t, P, t), 
                Te.add(n, P, n);
            }
            this._boundingBox.getCorners(this._boundingBoxCorners);
        }, t._updateEmission = function() {
            if (this.isAlive) if (this._simulateUpdate) this._simulateUpdate = !1; else {
                var e = this._startUpdateLoopCount === P.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                e = Math.min(ShurikenParticleSystem._maxElapsedTime, e), this._updateParticles(e);
            }
        }, t._updateParticles = function(e) {
            (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e, 
            this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e, 
            this._totalDelayTime < this._playStartDelay || this._emission.enbale && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
        }, t._updateParticlesSimulationRestart = function(e) {
            this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0, 
            this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0, 
            this._totalDelayTime = 0, this._currentTime = e;
            var t = e;
            t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enbale && this._advanceTime(e, e);
        }, t._retireActiveParticles = function() {
            for (;this._firstActiveElement != this._firstNewElement; ) {
                var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride, t = e + this._timeIndex;
                if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
            }
        }, t._freeRetiredParticles = function() {
            for (;this._firstRetiredElement != this._firstActiveElement; ) {
                var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                if (this.isPerformanceMode && e < 3) break;
                this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
            }
        }, t._burst = function(e, t) {
            for (var n = 0, i = this._emission._bursts, r = i.length; this._burstsIndex < r; this._burstsIndex++) {
                var a = i[this._burstsIndex], o = a.time;
                if (!(e <= o && o < t)) break;
                var s = 0;
                this.autoRandomSeed ? s = M.lerp(a.minCount, a.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0], 
                s = M.lerp(a.minCount, a.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed), 
                n += s;
            }
            return n;
        }, t._advanceTime = function(e, t) {
            var n = 0, i = this._emissionTime;
            this._emissionTime += e;
            var r = 0;
            if (this._emissionTime > this.duration) {
                if (!this.looping) {
                    for (r = Math.min(this.maxParticles - this.aliveParticleCount, r), n = 0; n < r; n++) this.emit(t);
                    return this._isPlaying = !1, void this.stop();
                }
                r += this._burst(i, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0, 
                r += this._burst(0, this._emissionTime);
            } else r += this._burst(i, this._emissionTime);
            for (r = Math.min(this.maxParticles - this.aliveParticleCount, r), n = 0; n < r; n++) this.emit(t);
            var a = this.emission.emissionRate;
            if (a > 0) {
                var o = 1 / a;
                for (this._frameRateTime += o, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime); ) this._frameRateTime += o;
                this._frameRateTime = Math.floor(t / o) * o;
            }
        }, t._initBufferDatas = function() {
            this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy());
            var e = this._ownerRender, t = e.renderMode;
            if (-1 !== t && this.maxParticles > 0) {
                var n, i, r = 0, a = 0, o = 0, s = 0, l = 0, h = 0, u = 0, c = e.mesh;
                if (4 === t) {
                    if (c) {
                        if (c._vertexBuffers.length > 1) throw new Error("ShurikenParticleSystem: submesh Count mesh be One or all subMeshes have the same vertexDeclaration.");
                        i = wn.vertexDeclaration, this._floatCountPerVertex = i.vertexStride / 4, this._startLifeTimeIndex = 12, 
                        this._timeIndex = 16, this._vertexStride = c._vertexBuffers[0].vertexCount;
                        var d = this._bufferMaxParticles * this._vertexStride, _ = d % 65535;
                        if (Math.floor(d / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                        h = i.vertexStride * _, this._vertexBuffer = new Qt(h, 35048), this._vertexBuffer.vertexDeclaration = i, 
                        this._vertices = new Float32Array(this._floatCountPerVertex * _), this._indexStride = c._indexBuffer.indexCount;
                        var f = c._indexBuffer.getData(), m = this._bufferMaxParticles * this._indexStride;
                        for (this._indexBuffer = new jt("ushort", m, 35044), n = new Uint16Array(m), u = h + 2 * m, 
                        s = 0, r = 0; r < this._bufferMaxParticles; r++) {
                            var p = r * this._vertexStride;
                            for (a = 0, o = f.length; a < o; a++) n[s++] = p + f[a];
                        }
                        this._indexBuffer.setData(n), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
                        this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                    }
                } else {
                    for (i = Bn.vertexDeclaration, this._floatCountPerVertex = i.vertexStride / 4, this._startLifeTimeIndex = 7, 
                    this._timeIndex = 11, this._vertexStride = 4, h = i.vertexStride * this._bufferMaxParticles * this._vertexStride, 
                    this._vertexBuffer = new Qt(h, 35048), this._vertexBuffer.vertexDeclaration = i, 
                    this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride), 
                    r = 0; r < this._bufferMaxParticles; r++) l = r * this._floatCountPerVertex * this._vertexStride, 
                    this._vertices[l] = -.5, this._vertices[l + 1] = -.5, this._vertices[l + 2] = 0, 
                    this._vertices[l + 3] = 1, l += this._floatCountPerVertex, this._vertices[l] = .5, 
                    this._vertices[l + 1] = -.5, this._vertices[l + 2] = 1, this._vertices[l + 3] = 1, 
                    l += this._floatCountPerVertex, this._vertices[l] = .5, this._vertices[l + 1] = .5, 
                    this._vertices[l + 2] = 1, this._vertices[l + 3] = 0, l += this._floatCountPerVertex, 
                    this._vertices[l] = -.5, this._vertices[l + 1] = .5, this._vertices[l + 2] = 0, 
                    this._vertices[l + 3] = 0;
                    for (this._indexStride = 6, this._indexBuffer = new jt("ushort", 6 * this._bufferMaxParticles, 35044), 
                    n = new Uint16Array(6 * this._bufferMaxParticles), r = 0; r < this._bufferMaxParticles; r++) {
                        s = 6 * r;
                        var T = r * this._vertexStride, S = T + 2;
                        n[s++] = T, n[s++] = S, n[s++] = T + 1, n[s++] = T, n[s++] = T + 3, n[s++] = S;
                    }
                    this._indexBuffer.setData(n), u = h + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(), 
                    this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer), 
                    this._bufferState.unBind();
                }
                C._addMemory(u, u);
            }
        }, t.destroy = function() {
            e.prototype.destroy.call(this);
            var t = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
            C._addMemory(-t, -t), this._bufferState.destroy(), this._vertexBuffer.destroy(), 
            this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null, 
            this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null, 
            this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null, 
            this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null, 
            this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null, 
            this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null, 
            this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null, 
            this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null, 
            this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
        }, t.emit = function(e) {
            var t = ShurikenParticleSystem._tempPosition, n = ShurikenParticleSystem._tempDirection;
            return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, n) : this._shape.generatePositionAndDirection(t, n, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0, 
            n.x = n.y = 0, n.z = 1), this.addParticle(t, n, e);
        }, t.addParticle = function(e, t, n) {
            Te.normalize(t, t);
            var i = this._firstFreeElement + 1;
            if (i >= this._bufferMaxParticles && (i = 0), i === this._firstRetiredElement) return !1;
            if (Ke.create(this, this._ownerRender, this._owner.transform), this._currentTime - n >= Ke.startLifeTime) return !0;
            var r = NaN, a = NaN, o = NaN, s = NaN, l = NaN, h = NaN, u = NaN, c = this._velocityOverLifetime && this._velocityOverLifetime.enbale;
            if (c) {
                var d = this._velocityOverLifetime.velocity.type;
                2 === d || 3 === d ? this.autoRandomSeed ? (r = Math.random(), a = Math.random(), 
                o = Math.random()) : (this._rand.seed = this._randomSeeds[9], r = this._rand.getFloat(), 
                a = this._rand.getFloat(), o = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : c = !1;
            } else c = !1;
            var _ = this._colorOverLifetime && this._colorOverLifetime.enbale;
            _ ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? s = Math.random() : (this._rand.seed = this._randomSeeds[10], 
            s = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : _ = !1 : _ = !1;
            var f = this._sizeOverLifetime && this._sizeOverLifetime.enbale;
            f ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? l = Math.random() : (this._rand.seed = this._randomSeeds[11], 
            l = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : f = !1 : f = !1;
            var m = this._rotationOverLifetime && this._rotationOverLifetime.enbale;
            if (m) {
                var p = this._rotationOverLifetime.angularVelocity.type;
                2 === p || 3 === p ? this.autoRandomSeed ? h = Math.random() : (this._rand.seed = this._randomSeeds[12], 
                h = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : m = !1;
            } else m = !1;
            var T = this._textureSheetAnimation && this._textureSheetAnimation.enable;
            T ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? u = Math.random() : (this._rand.seed = this._randomSeeds[15], 
            u = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : T = !1 : T = !1;
            var S, E = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride, v = Ke.startUVInfo[0], g = Ke.startUVInfo[1], x = Ke.startUVInfo[2], M = Ke.startUVInfo[3], y = 0, D = 0, R = 0, C = 0, I = 0, A = this._ownerRender;
            if (4 === A.renderMode) {
                var L = A.mesh._vertexBuffers[0];
                S = L.getData();
                var O = L.vertexDeclaration;
                D = O.getVertexElementByUsage(0).offset / 4;
                var P = O.getVertexElementByUsage(1);
                R = P ? P.offset / 4 : -1;
                var V = O.getVertexElementByUsage(2);
                C = V ? V.offset / 4 : -1, y = O.vertexStride / 4, I = 0;
            } else {
                this._vertices[E + 2] = x, this._vertices[E + 3] = M + g;
                var N = E + this._floatCountPerVertex;
                this._vertices[N + 2] = x + v, this._vertices[N + 3] = M + g;
                var B = N + this._floatCountPerVertex;
                this._vertices[B + 2] = x + v, this._vertices[B + 3] = M;
                var w = B + this._floatCountPerVertex;
                this._vertices[w + 2] = x, this._vertices[w + 3] = M;
            }
            for (var b = E, F = E + this._floatCountPerVertex * this._vertexStride; b < F; b += this._floatCountPerVertex) {
                var U = 0;
                if (4 === A.renderMode) {
                    U = b;
                    var z = y * I++, G = z + D;
                    this._vertices[U++] = S[G++], this._vertices[U++] = S[G++], this._vertices[U++] = S[G], 
                    -1 === R ? (this._vertices[U++] = 1, this._vertices[U++] = 1, this._vertices[U++] = 1, 
                    this._vertices[U++] = 1) : (G = z + R, this._vertices[U++] = S[G++], this._vertices[U++] = S[G++], 
                    this._vertices[U++] = S[G++], this._vertices[U++] = S[G]), -1 === C ? (this._vertices[U++] = 0, 
                    this._vertices[U++] = 0) : (G = z + C, this._vertices[U++] = x + S[G++] * v, this._vertices[U++] = M + S[G] * g);
                } else U = b + 4;
                switch (this._vertices[U++] = e.x, this._vertices[U++] = e.y, this._vertices[U++] = e.z, 
                this._vertices[U++] = Ke.startLifeTime, this._vertices[U++] = t.x, this._vertices[U++] = t.y, 
                this._vertices[U++] = t.z, this._vertices[U++] = n, this._vertices[U++] = Ke.startColor.x, 
                this._vertices[U++] = Ke.startColor.y, this._vertices[U++] = Ke.startColor.z, this._vertices[U++] = Ke.startColor.w, 
                this._vertices[U++] = Ke.startSize[0], this._vertices[U++] = Ke.startSize[1], this._vertices[U++] = Ke.startSize[2], 
                this._vertices[U++] = Ke.startRotation[0], this._vertices[U++] = Ke.startRotation[1], 
                this._vertices[U++] = Ke.startRotation[2], this._vertices[U++] = Ke.startSpeed, 
                _ && (this._vertices[U + 1] = s), f && (this._vertices[U + 2] = l), m && (this._vertices[U + 3] = h), 
                T && (this._vertices[U + 4] = u), c && (this._vertices[U + 5] = r, this._vertices[U + 6] = a, 
                this._vertices[U + 7] = o), this.simulationSpace) {
                  case 0:
                    U += 8, this._vertices[U++] = Ke.simulationWorldPostion[0], this._vertices[U++] = Ke.simulationWorldPostion[1], 
                    this._vertices[U++] = Ke.simulationWorldPostion[2], this._vertices[U++] = Ke.simulationWorldRotation[0], 
                    this._vertices[U++] = Ke.simulationWorldRotation[1], this._vertices[U++] = Ke.simulationWorldRotation[2], 
                    this._vertices[U++] = Ke.simulationWorldRotation[3];
                    break;

                  case 1:
                    break;

                  default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
            }
            return this._firstFreeElement = i, !0;
        }, t.addNewParticlesToVertexBuffer = function() {
            var e = 0;
            this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * this._vertexStride * this._floatCountPerVertex, 
            this._vertexBuffer.setData(this._vertices, e, e, (this._firstFreeElement - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex)) : (e = this._firstNewElement * this._vertexStride * this._floatCountPerVertex, 
            this._vertexBuffer.setData(this._vertices, e, e, (this._bufferMaxParticles - this._firstNewElement) * this._vertexStride * this._floatCountPerVertex), 
            this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices, 0, 0, this._firstFreeElement * this._vertexStride * this._floatCountPerVertex)), 
            this._firstNewElement = this._firstFreeElement;
        }, t._getType = function() {
            return ShurikenParticleSystem._type;
        }, t._prepareRender = function(e) {
            return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(), 
            this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
        }, t._render = function(e) {
            this._bufferState.bind();
            var t = 0, n = E.instance;
            this._firstActiveElement < this._firstFreeElement ? (t = (this._firstFreeElement - this._firstActiveElement) * this._indexStride, 
            n.drawElements(4, t, 5123, 2 * this._firstActiveElement * this._indexStride), P.trianglesFaces += t / 3, 
            P.renderBatches++) : (t = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride, 
            n.drawElements(4, t, 5123, 2 * this._firstActiveElement * this._indexStride), P.trianglesFaces += t / 3, 
            P.renderBatches++, this._firstFreeElement > 0 && (t = this._firstFreeElement * this._indexStride, 
            n.drawElements(4, t, 5123, 0), P.trianglesFaces += t / 3, P.renderBatches++));
        }, t.play = function() {
            if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1, 
            this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed) for (var e = 0, t = this._randomSeeds.length; e < t; e++) this._randomSeeds[e] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[e];
            switch (this.startDelayType) {
              case 0:
                this._playStartDelay = this.startDelay;
                break;

              case 1:
                this.autoRandomSeed ? this._playStartDelay = M.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2], 
                this._playStartDelay = M.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()), 
                this._randomSeeds[2] = this._rand.seed);
                break;

              default:
                throw new Error("Utils3D: startDelayType is invalid.");
            }
            this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = P.loopCount;
        }, t.pause = function() {
            this._isPaused = !0;
        }, t.simulate = function(e, t) {
            void 0 === t && (t = !0), this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1, 
            this._updateParticles(e)), this.pause();
        }, t.stop = function() {
            this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
        }, t.cloneTo = function(e) {
            var t = e;
            t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm, 
            t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin, 
            t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime, 
            t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant, 
            this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin, 
            t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin), 
            this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType, 
            t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin, 
            t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize, 
            t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant, 
            this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin, 
            t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate), 
            this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation, 
            t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant, 
            this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin, 
            t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate), 
            this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate), 
            t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType, 
            this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin), 
            this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier, 
            t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake, 
            t.maxParticles = this.maxParticles, this._emission && (t._emission = this._emission.clone()), 
            this.shape && (t.shape = this.shape.clone()), this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()), 
            this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()), 
            this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()), 
            this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()), 
            t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting, 
            t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay, 
            t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime, 
            t._burstsIndex = this._burstsIndex;
        }, t.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, t, "maxParticles", function() {
            return this._bufferMaxParticles - 1;
        }, function(e) {
            var t = e + 1;
            t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
        }), a(0, t, "isEmitting", function() {
            return this._isEmitting;
        }), a(0, t, "isAlive", function() {
            return !!(this._isPlaying || this.aliveParticleCount > 0);
        }), a(0, t, "shape", function() {
            return this._shape;
        }, function(e) {
            this._shape !== e && (e && e.enable ? this._owner._render._defineDatas.add(xi.SHADERDEFINE_SHAPE) : this._owner._render._defineDatas.remove(xi.SHADERDEFINE_SHAPE), 
            this._shape = e);
        }), a(0, t, "rotationOverLifetime", function() {
            return this._rotationOverLifetime;
        }, function(e) {
            var t = this._owner._render._defineDatas, n = this._owner._render._shaderValues;
            if (e) {
                var i = e.angularVelocity;
                if (!i) return;
                var r = i.separateAxes, a = i.type;
                if (e.enbale) switch (r ? t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIME), 
                a) {
                  case 0:
                    t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                    break;

                  case 1:
                    t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                    break;

                  case 2:
                    t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                    break;

                  case 3:
                    t.add(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                } else t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIME), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
                t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
                t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                switch (a) {
                  case 0:
                    r ? n.setVector3(xi.ROLANGULARVELOCITYCONSTSEPRARATE, i.constantSeparate) : n.setNumber(xi.ROLANGULARVELOCITYCONST, i.constant);
                    break;

                  case 1:
                    r ? (n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTX, i.gradientX._elements), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTY, i.gradientY._elements), 
                    n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTZ, i.gradientZ._elements)) : n.setBuffer(xi.ROLANGULARVELOCITYGRADIENT, i.gradient._elements);
                    break;

                  case 2:
                    r ? (n.setVector3(xi.ROLANGULARVELOCITYCONSTSEPRARATE, i.constantMinSeparate), n.setVector3(xi.ROLANGULARVELOCITYCONSTMAXSEPRARATE, i.constantMaxSeparate)) : (n.setNumber(xi.ROLANGULARVELOCITYCONST, i.constantMin), 
                    n.setNumber(xi.ROLANGULARVELOCITYCONSTMAX, i.constantMax));
                    break;

                  case 3:
                    r ? (n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTX, i.gradientXMin._elements), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTXMAX, i.gradientXMax._elements), 
                    n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTY, i.gradientYMin._elements), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTYMAX, i.gradientYMax._elements), 
                    n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTZ, i.gradientZMin._elements), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTZMAX, i.gradientZMax._elements)) : (n.setBuffer(xi.ROLANGULARVELOCITYGRADIENT, i.gradientMin._elements), 
                    n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTMAX, i.gradientMax._elements));
                }
            } else t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIME), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), 
            t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), 
            t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.remove(xi.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES), 
            n.setVector(xi.ROLANGULARVELOCITYCONSTSEPRARATE, null), n.setVector(xi.ROLANGULARVELOCITYCONSTMAXSEPRARATE, null), 
            n.setNumber(xi.ROLANGULARVELOCITYCONST, void 0), n.setNumber(xi.ROLANGULARVELOCITYCONSTMAX, void 0), 
            n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTX, null), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTXMAX, null), 
            n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTY, null), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTYMAX, null), 
            n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTZ, null), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTZMAX, null), 
            n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTWMAX, null), n.setBuffer(xi.ROLANGULARVELOCITYGRADIENT, null), 
            n.setBuffer(xi.ROLANGULARVELOCITYGRADIENTMAX, null);
            this._rotationOverLifetime = e;
        }), a(0, t, "emission", function() {
            return this._emission;
        }), a(0, t, "emissionTime", function() {
            return this._emissionTime > this.duration ? this.duration : this._emissionTime;
        }), a(0, t, "aliveParticleCount", function() {
            return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
        }), a(0, t, "isPlaying", function() {
            return this._isPlaying;
        }), a(0, t, "isPaused", function() {
            return this._isPaused;
        }), a(0, t, "startLifetimeType", function() {
            return this._startLifetimeType;
        }, function(e) {
            var t = 0, n = 0;
            switch (this.startLifetimeType) {
              case 0:
                this._maxStartLifetime = this.startLifetimeConstant;
                break;

              case 1:
                this._maxStartLifetime = -Number.MAX_VALUE;
                var i = i;
                for (t = 0, n = i.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                break;

              case 2:
                this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                break;

              case 3:
                this._maxStartLifetime = -Number.MAX_VALUE;
                var r = r;
                for (t = 0, n = r.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, r.getValueByIndex(t));
                var a = a;
                for (t = 0, n = a.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
            }
            this._startLifetimeType = e;
        }), a(0, t, "startLifetimeConstant", function() {
            return this._startLifetimeConstant;
        }, function(e) {
            0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
        }), a(0, t, "startLifetimeConstantMin", function() {
            return this._startLifetimeConstantMin;
        }, function(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)), 
            this._startLifetimeConstantMin = e;
        }), a(0, t, "startLifeTimeGradient", function() {
            return this._startLifeTimeGradient;
        }, function(e) {
            if (1 === this._startLifetimeType) {
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (var t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradient = e;
        }), a(0, t, "startLifetimeConstantMax", function() {
            return this._startLifetimeConstantMax;
        }, function(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)), 
            this._startLifetimeConstantMax = e;
        }), a(0, t, "startLifeTimeGradientMin", function() {
            return this._startLifeTimeGradientMin;
        }, function(e) {
            if (3 === this._startLifetimeType) {
                var t = 0, n = 0;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                for (t = 0, n = this._startLifeTimeGradientMax.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
            }
            this._startLifeTimeGradientMin = e;
        }), a(0, t, "startLifeTimeGradientMax", function() {
            return this._startLifeTimeGradientMax;
        }, function(e) {
            if (3 === this._startLifetimeType) {
                var t = 0, n = 0;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, n = this._startLifeTimeGradientMin.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                for (t = 0, n = e.gradientCount; t < n; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradientMax = e;
        }), a(0, t, "velocityOverLifetime", function() {
            return this._velocityOverLifetime;
        }, function(e) {
            var t = this._owner._render._defineDatas, n = this._owner._render._shaderValues;
            if (e) {
                var i = e.velocity, r = i.type;
                if (e.enbale) switch (r) {
                  case 0:
                    t.add(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                    break;

                  case 1:
                    t.add(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                    break;

                  case 2:
                    t.add(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                    break;

                  case 3:
                    t.add(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                } else t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
                t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                switch (r) {
                  case 0:
                    n.setVector3(xi.VOLVELOCITYCONST, i.constant);
                    break;

                  case 1:
                    n.setBuffer(xi.VOLVELOCITYGRADIENTX, i.gradientX._elements), n.setBuffer(xi.VOLVELOCITYGRADIENTY, i.gradientY._elements), 
                    n.setBuffer(xi.VOLVELOCITYGRADIENTZ, i.gradientZ._elements);
                    break;

                  case 2:
                    n.setVector3(xi.VOLVELOCITYCONST, i.constantMin), n.setVector3(xi.VOLVELOCITYCONSTMAX, i.constantMax);
                    break;

                  case 3:
                    n.setBuffer(xi.VOLVELOCITYGRADIENTX, i.gradientXMin._elements), n.setBuffer(xi.VOLVELOCITYGRADIENTXMAX, i.gradientXMax._elements), 
                    n.setBuffer(xi.VOLVELOCITYGRADIENTY, i.gradientYMin._elements), n.setBuffer(xi.VOLVELOCITYGRADIENTYMAX, i.gradientYMax._elements), 
                    n.setBuffer(xi.VOLVELOCITYGRADIENTZ, i.gradientZMin._elements), n.setBuffer(xi.VOLVELOCITYGRADIENTZMAX, i.gradientZMax._elements);
                }
                n.setInt(xi.VOLSPACETYPE, e.space);
            } else t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), 
            t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.remove(xi.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE), 
            n.setVector(xi.VOLVELOCITYCONST, null), n.setBuffer(xi.VOLVELOCITYGRADIENTX, null), 
            n.setBuffer(xi.VOLVELOCITYGRADIENTY, null), n.setBuffer(xi.VOLVELOCITYGRADIENTZ, null), 
            n.setVector(xi.VOLVELOCITYCONST, null), n.setVector(xi.VOLVELOCITYCONSTMAX, null), 
            n.setBuffer(xi.VOLVELOCITYGRADIENTX, null), n.setBuffer(xi.VOLVELOCITYGRADIENTXMAX, null), 
            n.setBuffer(xi.VOLVELOCITYGRADIENTY, null), n.setBuffer(xi.VOLVELOCITYGRADIENTYMAX, null), 
            n.setBuffer(xi.VOLVELOCITYGRADIENTZ, null), n.setBuffer(xi.VOLVELOCITYGRADIENTZMAX, null), 
            n.setInt(xi.VOLSPACETYPE, void 0);
            this._velocityOverLifetime = e;
        }), a(0, t, "colorOverLifetime", function() {
            return this._colorOverLifetime;
        }, function(e) {
            var t = this._owner._render._defineDatas, n = this._owner._render._shaderValues;
            if (e) {
                var i = e.color;
                if (e.enbale) switch (i.type) {
                  case 1:
                    t.add(xi.SHADERDEFINE_COLOROVERLIFETIME);
                    break;

                  case 3:
                    t.add(xi.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                } else t.remove(xi.SHADERDEFINE_COLOROVERLIFETIME), t.remove(xi.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                switch (i.type) {
                  case 1:
                    var r = i.gradient;
                    n.setBuffer(xi.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), n.setBuffer(xi.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements);
                    break;

                  case 3:
                    var a = i.gradientMin, o = i.gradientMax;
                    n.setBuffer(xi.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), n.setBuffer(xi.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements), 
                    n.setBuffer(xi.MAXCOLOROVERLIFEGRADIENTALPHAS, o._alphaElements), n.setBuffer(xi.MAXCOLOROVERLIFEGRADIENTCOLORS, o._rgbElements);
                }
            } else t.remove(xi.SHADERDEFINE_COLOROVERLIFETIME), t.remove(xi.SHADERDEFINE_RANDOMCOLOROVERLIFETIME), 
            n.setBuffer(xi.COLOROVERLIFEGRADIENTALPHAS, r._alphaElements), n.setBuffer(xi.COLOROVERLIFEGRADIENTCOLORS, r._rgbElements), 
            n.setBuffer(xi.COLOROVERLIFEGRADIENTALPHAS, a._alphaElements), n.setBuffer(xi.COLOROVERLIFEGRADIENTCOLORS, a._rgbElements), 
            n.setBuffer(xi.MAXCOLOROVERLIFEGRADIENTALPHAS, o._alphaElements), n.setBuffer(xi.MAXCOLOROVERLIFEGRADIENTCOLORS, o._rgbElements);
            this._colorOverLifetime = e;
        }), a(0, t, "sizeOverLifetime", function() {
            return this._sizeOverLifetime;
        }, function(e) {
            var t = this._owner._render._defineDatas, n = this._owner._render._shaderValues;
            if (e) {
                var i = e.size, r = i.separateAxes, a = i.type;
                if (e.enbale) switch (a) {
                  case 0:
                    r ? t.add(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.add(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                    break;

                  case 2:
                    r ? t.add(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.add(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                } else t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
                t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                switch (a) {
                  case 0:
                    r ? (n.setBuffer(xi.SOLSIZEGRADIENTX, i.gradientX._elements), n.setBuffer(xi.SOLSIZEGRADIENTY, i.gradientY._elements), 
                    n.setBuffer(xi.SOLSizeGradientZ, i.gradientZ._elements)) : n.setBuffer(xi.SOLSIZEGRADIENT, i.gradient._elements);
                    break;

                  case 2:
                    r ? (n.setBuffer(xi.SOLSIZEGRADIENTX, i.gradientXMin._elements), n.setBuffer(xi.SOLSIZEGRADIENTXMAX, i.gradientXMax._elements), 
                    n.setBuffer(xi.SOLSIZEGRADIENTY, i.gradientYMin._elements), n.setBuffer(xi.SOLSIZEGRADIENTYMAX, i.gradientYMax._elements), 
                    n.setBuffer(xi.SOLSizeGradientZ, i.gradientZMin._elements), n.setBuffer(xi.SOLSizeGradientZMAX, i.gradientZMax._elements)) : (n.setBuffer(xi.SOLSIZEGRADIENT, i.gradientMin._elements), 
                    n.setBuffer(xi.SOLSizeGradientMax, i.gradientMax._elements));
                }
            } else t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), 
            t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.remove(xi.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE), 
            n.setBuffer(xi.SOLSIZEGRADIENTX, null), n.setBuffer(xi.SOLSIZEGRADIENTXMAX, null), 
            n.setBuffer(xi.SOLSIZEGRADIENTY, null), n.setBuffer(xi.SOLSIZEGRADIENTYMAX, null), 
            n.setBuffer(xi.SOLSizeGradientZ, null), n.setBuffer(xi.SOLSizeGradientZMAX, null), 
            n.setBuffer(xi.SOLSIZEGRADIENT, null), n.setBuffer(xi.SOLSizeGradientMax, null);
            this._sizeOverLifetime = e;
        }), a(0, t, "textureSheetAnimation", function() {
            return this._textureSheetAnimation;
        }, function(e) {
            var t = this._owner._render._defineDatas, n = this._owner._render._shaderValues;
            if (e) {
                var i = e.frame, r = i.type;
                if (e.enable) switch (r) {
                  case 1:
                    t.add(xi.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                    break;

                  case 3:
                    t.add(xi.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                } else t.remove(xi.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.remove(xi.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                if (1 === r || 3 === r) {
                    n.setNumber(xi.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                    var a = e.tiles, o = this._uvLength;
                    o.x = 1 / a.x, o.y = 1 / a.y, n.setVector2(xi.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                }
                switch (r) {
                  case 1:
                    n.setBuffer(xi.TEXTURESHEETANIMATIONGRADIENTUVS, i.frameOverTimeData._elements);
                    break;

                  case 3:
                    n.setBuffer(xi.TEXTURESHEETANIMATIONGRADIENTUVS, i.frameOverTimeDataMin._elements), 
                    n.setBuffer(xi.TEXTURESHEETANIMATIONGRADIENTMAXUVS, i.frameOverTimeDataMax._elements);
                }
            } else t.remove(xi.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.remove(xi.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE), 
            n.setNumber(xi.TEXTURESHEETANIMATIONCYCLES, void 0), n.setVector(xi.TEXTURESHEETANIMATIONSUBUVLENGTH, null), 
            n.setBuffer(xi.TEXTURESHEETANIMATIONGRADIENTUVS, null), n.setBuffer(xi.TEXTURESHEETANIMATIONGRADIENTMAXUVS, null);
            this._textureSheetAnimation = e;
        }), ShurikenParticleSystem.halfKSqrtOf2 = .71, i(ShurikenParticleSystem, [ "_RANDOMOFFSET", function() {
            return this._RANDOMOFFSET = new Uint32Array([ 592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447 ]);
        }, "_maxElapsedTime", function() {
            return this._maxElapsedTime = 1 / 3;
        }, "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempVector32", function() {
            return this._tempVector32 = new Te();
        }, "_tempVector33", function() {
            return this._tempVector33 = new Te();
        }, "_tempVector34", function() {
            return this._tempVector34 = new Te();
        }, "_tempVector35", function() {
            return this._tempVector35 = new Te();
        }, "_tempVector36", function() {
            return this._tempVector36 = new Te();
        }, "_tempVector37", function() {
            return this._tempVector37 = new Te();
        }, "_tempVector38", function() {
            return this._tempVector38 = new Te();
        }, "_tempVector39", function() {
            return this._tempVector39 = new Te();
        }, "_tempPosition", function() {
            return this._tempPosition = new Te();
        }, "_tempDirection", function() {
            return this._tempDirection = new Te();
        }, "_type", function() {
            return this._type = te._typeCounter++;
        } ]), ShurikenParticleSystem;
    }(te), ln = (function(e) {
        function StaticPlaneColliderShape(e, t) {
            StaticPlaneColliderShape.__super.call(this), this._normal = e, this._offset = t, 
            this._type = 6, StaticPlaneColliderShape._nativeNormal.setValue(-e.x, e.y, e.z), 
            this._nativeShape = new X._physics3D.btStaticPlaneShape(StaticPlaneColliderShape._nativeNormal, t);
        }
        r(StaticPlaneColliderShape, "laya.d3.physics.shape.StaticPlaneColliderShape", W), 
        StaticPlaneColliderShape.prototype.clone = function() {
            var e = new StaticPlaneColliderShape(this._normal, this._offset);
            return this.cloneTo(e), e;
        }, i(StaticPlaneColliderShape, [ "_nativeNormal", function() {
            return this._nativeNormal = new X._physics3D.btVector3(0, 0, 0);
        } ]);
    }(), function(e) {
        function MeshRenderDynamicBatchManager() {
            this._instanceBatchOpaqueMarks = [], this._vertexBatchOpaqueMarks = [], this._cacheBufferStates = [], 
            MeshRenderDynamicBatchManager.__super.call(this), xn.instance = new xn(), this._updateCountMark = 0;
        }
        r(MeshRenderDynamicBatchManager, "laya.d3.graphics.MeshRenderDynamicBatchManager", e);
        var t = MeshRenderDynamicBatchManager.prototype;
        return t.getInstanceBatchOpaquaMark = function(e, t, n, i) {
            var r = this._instanceBatchOpaqueMarks[e] || (this._instanceBatchOpaqueMarks[e] = []), a = r[t ? 0 : 1] || (r[t ? 0 : 1] = []), o = a[n] || (a[n] = []);
            return o[i] || (o[i] = new pt());
        }, t.getVertexBatchOpaquaMark = function(e, t, n, i) {
            var r = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []), a = r[t ? 0 : 1] || (r[t ? 0 : 1] = []), o = a[n] || (a[n] = []);
            return o[i] || (o[i] = new pt());
        }, t._getBufferState = function(e) {
            var t = this._cacheBufferStates[e.id];
            if (!t) {
                var n = xn.instance;
                (t = new Jt()).bind();
                var i = n._vertexBuffer;
                i.vertexDeclaration = e, t.applyVertexBuffer(i), t.applyIndexBuffer(n._indexBuffer), 
                t.unBind(), this._cacheBufferStates[e.id] = t;
            }
            return t;
        }, t._getBatchRenderElementFromPool = function() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new Nn(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
            e.vertexBatchElementList = [], e.instanceBatchElementList = []), e;
        }, t._clear = function() {
            e.prototype._clear.call(this), this._updateCountMark++;
        }, i(MeshRenderDynamicBatchManager, [ "instance", function() {
            return this.instance = new MeshRenderDynamicBatchManager();
        } ]), MeshRenderDynamicBatchManager;
    }(ee)), hn = function(e) {
        function BoxColliderShape(e, t, n) {
            BoxColliderShape.__super.call(this), void 0 === e && (e = 1), void 0 === t && (t = 1), 
            void 0 === n && (n = 1), this._sizeX = e, this._sizeY = t, this._sizeZ = n, this._type = 0, 
            BoxColliderShape._nativeSize.setValue(e / 2, t / 2, n / 2), this._nativeShape = new X._physics3D.btBoxShape(BoxColliderShape._nativeSize);
        }
        r(BoxColliderShape, "laya.d3.physics.shape.BoxColliderShape", W);
        var t = BoxColliderShape.prototype;
        return t.clone = function() {
            var e = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
            return this.cloneTo(e), e;
        }, a(0, t, "sizeX", function() {
            return this._sizeX;
        }), a(0, t, "sizeY", function() {
            return this._sizeY;
        }), a(0, t, "sizeZ", function() {
            return this._sizeZ;
        }), i(BoxColliderShape, [ "_nativeSize", function() {
            return this._nativeSize = new X._physics3D.btVector3(0, 0, 0);
        } ]), BoxColliderShape;
    }(), un = function(e) {
        function SimpleSingletonList() {
            SimpleSingletonList.__super.call(this);
        }
        r(SimpleSingletonList, "laya.d3.component.SimpleSingletonList", $);
        var t = SimpleSingletonList.prototype;
        return t.add = function(e) {
            -1 === e._getIndexInList() && (this._add(e), e._setIndexInList(this.length++));
        }, t.remove = function(e) {
            var t = e._getIndexInList();
            if (this.length--, t !== this.length) {
                var n = this.elements[this.length];
                this.elements[t] = n, n._setIndexInList(t);
            }
            e._setIndexInList(-1);
        }, SimpleSingletonList;
    }(), cn = function(e) {
        function PhysicsUpdateList() {
            PhysicsUpdateList.__super.call(this);
        }
        r(PhysicsUpdateList, "laya.d3.physics.PhysicsUpdateList", $);
        var t = PhysicsUpdateList.prototype;
        return t.add = function(e) {
            if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
            this._add(e), e._inPhysicUpdateListIndex = this.length++;
        }, t.remove = function(e) {
            var t = e._inPhysicUpdateListIndex;
            if (this.length--, t !== this.length) {
                var n = this.elements[this.length];
                this.elements[t] = n, n._inPhysicUpdateListIndex = t;
            }
            e._inPhysicUpdateListIndex = -1;
        }, PhysicsUpdateList;
    }(), dn = function(e) {
        function SubMeshStaticBatch(e, t, n) {
            SubMeshStaticBatch.__super.call(this), this._bufferState = new Jt(), this._batchID = SubMeshStaticBatch._batchIDCounter++, 
            this._batchElements = [], this._currentBatchVertexCount = 0, this._currentBatchIndexCount = 0, 
            this._vertexDeclaration = n, this.batchOwner = e, this.number = t;
        }
        r(SubMeshStaticBatch, "laya.d3.graphics.SubMeshStaticBatch", te);
        var t = SubMeshStaticBatch.prototype;
        return n.imps(t, {
            "laya.resource.IDispose": !0
        }), t._getStaticBatchBakedVertexs = function(e, t, n, i, r, a) {
            var o, s = a._vertexBuffers[0], l = s.vertexDeclaration, h = l.getVertexElementByUsage(0).offset / 4, u = l.getVertexElementByUsage(3), c = u ? u.offset / 4 : -1, d = l.getVertexElementByUsage(1), _ = d ? d.offset / 4 : -1, f = l.getVertexElementByUsage(2), m = f ? f.offset / 4 : -1, p = l.getVertexElementByUsage(7), T = p ? p.offset / 4 : -1, S = l.getVertexElementByUsage(4), E = S ? S.offset / 4 : -1, v = l.vertexStride / 4, g = s.getData();
            n ? (n.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40), o = SubMeshStaticBatch._tempMatrix4x41, 
            Ht.multiply(SubMeshStaticBatch._tempMatrix4x40, i.worldMatrix, o)) : o = i.worldMatrix;
            var x = SubMeshStaticBatch._tempQuaternion0;
            o.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, x, SubMeshStaticBatch._tempVector31);
            for (var M = r.lightmapScaleOffset, y = a.vertexCount, D = 0; D < y; D++) {
                var R = D * v, C = 18 * (D + t);
                ke.transformVector3ArrayToVector3ArrayCoordinate(g, R + h, o, e, C + 0), -1 !== c && ke.transformVector3ArrayByQuat(g, R + c, x, e, C + 3);
                var I = 0, A = 0, L = C + 6;
                if (-1 !== _) {
                    var O = R + _;
                    for (I = 0, A = 4; I < A; I++) e[L + I] = g[O + I];
                } else for (I = 0, A = 4; I < A; I++) e[L + I] = 1;
                if (-1 !== m) {
                    var P = R + m;
                    e[C + 10] = g[P], e[C + 11] = g[P + 1];
                }
                if (M && (-1 !== T ? ke.transformLightingMapTexcoordArray(g, R + T, M, e, C + 12) : ke.transformLightingMapTexcoordArray(g, R + m, M, e, C + 12)), 
                -1 !== E) {
                    var V = R + E;
                    e[C + 14] = g[V], e[C + 15] = g[V + 1], e[C + 16] = g[V + 2], e[C + 17] = g[V + 3];
                }
            }
            return y;
        }, t.addTest = function(e) {
            var t = e.meshFilter.sharedMesh.vertexCount;
            return !(this._currentBatchVertexCount + t > 65535);
        }, t.add = function(e) {
            var t = e._render._staticBatch;
            t && t.remove(e);
            var n = e.meshFilter.sharedMesh, i = n.vertexCount;
            this._batchElements.push(e);
            var r = e._render;
            r._isPartOfStaticBatch = !0, r._staticBatch = this;
            for (var a = r._renderElements, o = 0, s = a.length; o < s; o++) a[o].staticBatch = this;
            this._currentBatchIndexCount += n._indexBuffer.indexCount, this._currentBatchVertexCount += i;
        }, t.remove = function(e) {
            var t = e.meshFilter.sharedMesh, n = this._batchElements.indexOf(e);
            if (-1 !== n) {
                this._batchElements.splice(n, 1);
                e._render;
                for (var i = e._render._renderElements, r = 0, a = i.length; r < a; r++) i[r].staticBatch = null;
                var o = t.vertexCount;
                this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount, 
                this._currentBatchVertexCount = this._currentBatchVertexCount - o, e._render._isPartOfStaticBatch = !1;
            }
        }, t.finishInit = function() {
            this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(), 
            C._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
            var e = 0, t = 0, n = this.batchOwner, i = this._vertexDeclaration.vertexStride / 4, r = new Float32Array(i * this._currentBatchVertexCount), a = new Uint16Array(this._currentBatchIndexCount);
            this._vertexBuffer = new Qt(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, 35044), 
            this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new jt("ushort", this._currentBatchIndexCount, 35044);
            for (var o = 0, s = this._batchElements.length; o < s; o++) {
                for (var l = this._batchElements[o], h = l.meshFilter.sharedMesh, u = this._getStaticBatchBakedVertexs(r, e, n ? n._transform : null, l._transform, l._render, h), c = h._indexBuffer.getData(), d = e, _ = t + c.length, f = l._render._renderElements, m = 0, p = h.subMeshCount; m < p; m++) {
                    var T = h._subMeshes[m], S = t + T._indexStart, E = f[m];
                    E.staticBatchIndexStart = S, E.staticBatchIndexEnd = S + T._indexCount;
                }
                a.set(c, t);
                var v = 0;
                if (n ? l._transform._isFrontFaceInvert !== n.transform._isFrontFaceInvert : l._transform._isFrontFaceInvert) for (v = t; v < _; v += 3) {
                    a[v] = d + a[v];
                    var g = a[v + 1], x = a[v + 2];
                    a[v + 1] = d + x, a[v + 2] = d + g;
                } else for (v = t; v < _; v += 3) a[v] = d + a[v], a[v + 1] = d + a[v + 1], a[v + 2] = d + a[v + 2];
                t += c.length, e += u;
            }
            this._vertexBuffer.setData(r), this._indexBuffer.setData(a);
            var M = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            C._addGPUMemory(M), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
        }, t._render = function(e) {
            this._bufferState.bind();
            for (var t = e.renderElement.staticBatchElementList, n = 0, i = 0, r = t.length, a = 1; a < r; a++) {
                if (t[a - 1].staticBatchIndexEnd !== t[a].staticBatchIndexStart) {
                    var o = t[n].staticBatchIndexStart, s = t[i].staticBatchIndexEnd - o;
                    E.instance.drawElements(4, s, 5123, 2 * o), n = ++i, P.trianglesFaces += s / 3;
                } else i++;
            }
            o = t[n].staticBatchIndexStart, s = t[i].staticBatchIndexEnd - o, E.instance.drawElements(4, s, 5123, 2 * o), 
            P.renderBatches++, P.savedRenderBatches += r - 1, P.trianglesFaces += s / 3;
        }, t.dispose = function() {
            var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            C._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null, this._vertexDeclaration = null, 
            this._bufferState.destroy(), this._vertexBuffer.destroy(), this._indexBuffer.destroy(), 
            this._vertexBuffer = null, this._indexBuffer = null, this._bufferState = null;
        }, SubMeshStaticBatch.maxBatchVertexCount = 65535, SubMeshStaticBatch._batchIDCounter = 0, 
        i(SubMeshStaticBatch, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempQuaternion0", function() {
            return this._tempQuaternion0 = new he();
        }, "_tempMatrix4x40", function() {
            return this._tempMatrix4x40 = new Ht();
        }, "_tempMatrix4x41", function() {
            return this._tempMatrix4x41 = new Ht();
        } ]), SubMeshStaticBatch;
    }(), _n = function(e) {
        function TrailGeometry(e) {
            this._floatCountPerVertices1 = 8, this._floatCountPerVertices2 = 1, this._increaseSegementCount = 128, 
            this._activeIndex = 0, this._endIndex = 0, this._needAddFirstVertex = !1, this._isTempEndVertex = !1, 
            this._subBirthTime = null, this._subDistance = null, this._segementCount = 0, this._vertices1 = null, 
            this._vertices2 = null, this._vertexBuffer1 = null, this._vertexBuffer2 = null, 
            this._owner = null, TrailGeometry.__super.call(this), this._lastFixedVertexPosition = new Te(), 
            this._bufferState = new Jt(), this._owner = e, this._resizeData(this._increaseSegementCount, this._bufferState);
        }
        r(TrailGeometry, "laya.d3.core.trail.TrailGeometry", e);
        var t = TrailGeometry.prototype;
        return t._resizeData = function(e, t) {
            this._segementCount = this._increaseSegementCount, this._subBirthTime = new Float32Array(e), 
            this._subDistance = new Float32Array(e);
            var n = 2 * e, i = tt.vertexDeclaration1, r = tt.vertexDeclaration2, a = [], o = n * i.vertexStride, s = n * r.vertexStride, l = o + s;
            this._vertices1 = new Float32Array(n * this._floatCountPerVertices1), this._vertexBuffer1 = new Qt(o, 35044, !1), 
            this._vertexBuffer1.vertexDeclaration = i, this._vertices2 = new Float32Array(n * this._floatCountPerVertices2), 
            this._vertexBuffer2 = new Qt(s, 35048, !1), this._vertexBuffer2.vertexDeclaration = r, 
            a.push(this._vertexBuffer1), a.push(this._vertexBuffer2), t.bind(), t.applyVertexBuffers(a), 
            t.unBind(), C._addMemory(l, l);
        }, t._resetData = function() {
            var e = this._endIndex - this._activeIndex;
            e == this._segementCount && (this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy(), 
            this._segementCount += this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState)), 
            this._vertexBuffer1.setData(this._vertices1, 0, 2 * this._floatCountPerVertices1 * this._activeIndex, 2 * this._floatCountPerVertices1 * e), 
            this._vertexBuffer2.setData(this._vertices2, 0, 2 * this._floatCountPerVertices2 * this._activeIndex, 2 * this._floatCountPerVertices2 * e);
            var t = 4 * this._activeIndex, n = new Float32Array(this._subDistance.buffer, t, e), i = new Float32Array(this._subBirthTime.buffer, t, e);
            this._subDistance.set(n, 0), this._subBirthTime.set(i, 0), this._endIndex = e, this._activeIndex = 0;
        }, t._updateTrail = function(e, t, n) {
            Te.equals(t, n) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, n) : this._addTrailByNextPosition(e, n));
        }, t._addTrailByFirstPosition = function(e, t) {
            this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0, 
            this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition), 
            this._needAddFirstVertex = !0;
        }, t._addTrailByNextPosition = function(e, t) {
            var n = TrailGeometry._tempVector30, i = TrailGeometry._tempVector31;
            Te.subtract(t, this._lastFixedVertexPosition, n);
            var r = TrailGeometry._tempVector32;
            switch (this._owner.alignment) {
              case 0:
                e.transform.getForward(r), Te.cross(n, r, i);
                break;

              case 1:
                this._owner._owner.transform.getForward(r), Te.cross(n, r, i);
            }
            Te.normalize(i, i), Te.scale(i, this._owner.widthMultiplier / 2, i);
            var a = Te.scalarLength(n), o = 0, s = NaN;
            this._needAddFirstVertex && (this._updateVerticesByPositionData(t, i, this._endIndex - 1), 
            this._needAddFirstVertex = !1), a - this._owner.minVertexDistance >= ie.zeroTolerance ? (this._isTempEndVertex ? (o = this._endIndex - 1, 
            s = a - this._subDistance[o], this._updateVerticesByPosition(t, i, a, o), this._owner._totalLength += s) : (this._endIndex === this._segementCount && this._resetData(), 
            this._updateVerticesByPosition(t, i, a, this._endIndex), this._owner._totalLength += a, 
            this._endIndex++), t.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (o = this._endIndex - 1, 
            s = a - this._subDistance[o], this._updateVerticesByPosition(t, i, a, o), this._owner._totalLength += s) : (this._endIndex === this._segementCount && this._resetData(), 
            this._updateVerticesByPosition(t, i, a, this._endIndex), this._owner._totalLength += a, 
            this._endIndex++), this._isTempEndVertex = !0);
        }, t._updateVerticesByPositionData = function(e, t, n) {
            var i = 2 * this._floatCountPerVertices1 * n, r = this._owner._curtime;
            this._vertices1[i] = e.x, this._vertices1[i + 1] = e.y, this._vertices1[i + 2] = e.z, 
            this._vertices1[i + 3] = -t.x, this._vertices1[i + 4] = -t.y, this._vertices1[i + 5] = -t.z, 
            this._vertices1[i + 6] = r, this._vertices1[i + 7] = 1, this._vertices1[i + 8] = e.x, 
            this._vertices1[i + 9] = e.y, this._vertices1[i + 10] = e.z, this._vertices1[i + 11] = t.x, 
            this._vertices1[i + 12] = t.y, this._vertices1[i + 13] = t.z, this._vertices1[i + 14] = r, 
            this._vertices1[i + 15] = 0;
            var a = 2 * this._floatCountPerVertices1;
            this._vertexBuffer1.setData(this._vertices1, i, i, a);
        }, t._updateVerticesByPosition = function(e, t, n, i) {
            this._updateVerticesByPositionData(e, t, i), this._subDistance[i] = n, this._subBirthTime[i] = this._owner._curtime;
        }, t._updateVertexBufferUV = function() {
            for (var e = this._endIndex, t = 0, n = this._activeIndex, i = e; n < i; n++) {
                n !== this._activeIndex && (t += this._subDistance[n]);
                var r = NaN;
                r = 0 == this._owner.textureMode ? 1 - t / this._owner._totalLength : 1 - (this._owner._totalLength - t), 
                this._vertices2[2 * n] = r, this._vertices2[2 * n + 1] = r;
            }
            var a = 2 * this._activeIndex;
            this._vertexBuffer2.setData(this._vertices2, a, a, 2 * e - a);
        }, t._updateDisappear = function() {
            for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + ie.zeroTolerance; t++) {
                var n = t + 1;
                if (n !== e && (this._owner._totalLength -= this._subDistance[n]), this._isTempEndVertex && n === e - 1) {
                    this._floatCountPerVertices1;
                    var i = this._lastFixedVertexPosition;
                    i.x = this._vertices1[0], i.y = this._vertices1[1], i.z = this._vertices1[2], this._isTempEndVertex = !1;
                }
                this._activeIndex++;
            }
        }, t._getType = function() {
            return TrailGeometry._type;
        }, t._prepareRender = function(e) {
            return this._endIndex - this._activeIndex > 1;
        }, t._render = function(e) {
            this._bufferState.bind();
            var t = 2 * this._activeIndex, n = 2 * this._endIndex - t;
            E.instance.drawArrays(5, t, n), P.renderBatches++, P.trianglesFaces += n - 2;
        }, t.destroy = function() {
            e.prototype.destroy.call(this);
            var t = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
            C._addMemory(-t, -t), this._bufferState.destroy(), this._vertexBuffer1.destroy(), 
            this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null, 
            this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null, 
            this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null;
        }, i(TrailGeometry, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        }, "_tempVector32", function() {
            return this._tempVector32 = new Te();
        }, "_type", function() {
            return this._type = te._typeCounter++;
        } ]), TrailGeometry;
    }(te), fn = function(e) {
        function CompoundColliderShape() {
            CompoundColliderShape.__super.call(this), this._childColliderShapes = [], this._type = 5, 
            this._nativeShape = new X._physics3D.btCompoundShape();
        }
        r(CompoundColliderShape, "laya.d3.physics.shape.CompoundColliderShape", e);
        var t = CompoundColliderShape.prototype;
        return t._clearChildShape = function(e) {
            e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
        }, t._addReference = function() {}, t._removeReference = function() {}, t._updateChildTransform = function(e) {
            var t = e.localOffset, n = e.localRotation, i = W._nativeVector30, r = W._nativQuaternion0, a = W._nativeTransform0;
            i.setValue(-t.x, t.y, t.z), r.setValue(-n.x, n.y, n.z, -n.w), a.setOrigin(i), a.setRotation(r), 
            this._nativeShape.updateChildTransform(e._indexInCompound, a, !0);
        }, t.addChildShape = function(e) {
            if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
            e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length, 
            this._childColliderShapes.push(e);
            var t = e.localOffset, n = e.localRotation;
            CompoundColliderShape._nativeOffset.setValue(-t.x, t.y, t.z), CompoundColliderShape._nativRotation.setValue(-n.x, n.y, n.z, -n.w), 
            CompoundColliderShape._nativeTransform.setOrigin(CompoundColliderShape._nativeOffset), 
            CompoundColliderShape._nativeTransform.setRotation(CompoundColliderShape._nativRotation);
            var i = this._nativeShape.getLocalScaling();
            this._nativeShape.setLocalScaling(CompoundColliderShape._nativeVector3One), this._nativeShape.addChildShape(CompoundColliderShape._nativeTransform, e._nativeShape), 
            this._nativeShape.setLocalScaling(i), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
        }, t.removeChildShape = function(e) {
            if (e._compoundParent === this) {
                var t = e._indexInCompound;
                this._clearChildShape(e);
                var n = this._childColliderShapes[this._childColliderShapes.length - 1];
                n._indexInCompound = t, this._childColliderShapes[t] = n, this._childColliderShapes.pop(), 
                this._nativeShape.removeChildShapeByIndex(t);
            }
        }, t.clearChildShape = function() {
            for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this._clearChildShape(this._childColliderShapes[e]), 
            this._nativeShape.removeChildShapeByIndex(0);
            this._childColliderShapes.length = 0;
        }, t.getChildShapeCount = function() {
            return this._childColliderShapes.length;
        }, t.cloneTo = function(e) {
            var t = e;
            t.clearChildShape();
            for (var n = 0, i = this._childColliderShapes.length; n < i; n++) t.addChildShape(this._childColliderShapes[n].clone());
        }, t.clone = function() {
            var e = new CompoundColliderShape();
            return this.cloneTo(e), e;
        }, t.destroy = function() {
            e.prototype.destroy.call(this);
            for (var t = 0, n = this._childColliderShapes.length; t < n; t++) {
                var i = this._childColliderShapes[t];
                0 === i._referenceCount && i.destroy();
            }
        }, i(CompoundColliderShape, [ "_nativeVector3One", function() {
            return this._nativeVector3One = new X._physics3D.btVector3(1, 1, 1);
        }, "_nativeTransform", function() {
            return this._nativeTransform = new X._physics3D.btTransform();
        }, "_nativeOffset", function() {
            return this._nativeOffset = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativRotation", function() {
            return this._nativRotation = new X._physics3D.btQuaternion(0, 0, 0, 1);
        } ]), CompoundColliderShape;
    }(W), mn = function(e) {
        function PixelLineFilter(e, t) {
            this._floatCountPerVertices = 7, this._owner = null, this._vertexBuffer = null, 
            this._vertices = null, this._maxLineCount = 0, this._lineCount = 0, PixelLineFilter.__super.call(this), 
            this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE, this._bufferState = new Jt();
            var n = 2 * t;
            this._owner = e, this._maxLineCount = t, this._vertices = new Float32Array(n * this._floatCountPerVertices), 
            this._vertexBuffer = new Qt(Xe.vertexDeclaration.vertexStride * n, 35044, !1), this._vertexBuffer.vertexDeclaration = Xe.vertexDeclaration, 
            this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.unBind();
        }
        r(PixelLineFilter, "laya.d3.core.pixelLine.PixelLineFilter", e);
        var t = PixelLineFilter.prototype;
        return t._getType = function() {
            return PixelLineFilter._type;
        }, t._resizeLineData = function(e) {
            var t = 2 * e, n = this._vertices;
            this._vertexBuffer.destroy(), this._maxLineCount = e;
            var i = t * this._floatCountPerVertices;
            this._vertices = new Float32Array(i), this._vertexBuffer = new Qt(Xe.vertexDeclaration.vertexStride * t, 35044, !1), 
            this._vertexBuffer.vertexDeclaration = Xe.vertexDeclaration, i < n.length ? (this._vertices.set(new Float32Array(n.buffer, 0, i)), 
            this._vertexBuffer.setData(this._vertices, 0, 0, i)) : (this._vertices.set(n), this._vertexBuffer.setData(this._vertices, 0, 0, n.length)), 
            this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.unBind();
        }, t._updateLineVertices = function(e, t, n, i, r) {
            t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z), 
            i && (this._vertices[e + 3] = i.r, this._vertices[e + 4] = i.g, this._vertices[e + 5] = i.b, 
            this._vertices[e + 6] = i.a), n && (this._vertices[e + 7] = n.x, this._vertices[e + 8] = n.y, 
            this._vertices[e + 9] = n.z), r && (this._vertices[e + 10] = r.r, this._vertices[e + 11] = r.g, 
            this._vertices[e + 12] = r.b, this._vertices[e + 13] = r.a), this._minUpdate = Math.min(this._minUpdate, e), 
            this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
        }, t._removeLineData = function(e) {
            var t = 2 * this._floatCountPerVertices, n = e + 1, i = e * t, r = new Float32Array(this._vertices.buffer, n * t * 4, (this._lineCount - n) * t);
            this._vertices.set(r, i), this._minUpdate = i, this._maxUpdate = i + 2 * this._floatCountPerVertices, 
            this._lineCount--;
        }, t._updateLineData = function(e, t, n, i, r) {
            var a = e * (2 * this._floatCountPerVertices);
            this._updateLineVertices(a, t, n, i, r);
        }, t._updateLineDatas = function(e, t) {
            for (var n = 2 * this._floatCountPerVertices, i = t.length, r = 0; r < i; r++) {
                var a = t[r];
                this._updateLineVertices((e + r) * n, a.startPosition, a.endPosition, a.startColor, a.endColor);
            }
        }, t._getLineData = function(e, t) {
            var n = t.startPosition, i = t.startColor, r = t.endPosition, a = t.endColor, o = this._vertices, s = e * this._floatCountPerVertices * 2;
            n.x = o[s + 0], n.y = o[s + 1], n.z = o[s + 2], i.r = o[s + 3], i.g = o[s + 4], 
            i.b = o[s + 5], i.a = o[s + 6], r.x = o[s + 7], r.y = o[s + 8], r.z = o[s + 9], 
            a.r = o[s + 10], a.g = o[s + 11], a.b = o[s + 12], a.a = o[s + 13];
        }, t._prepareRender = function(e) {
            return !0;
        }, t._render = function(e) {
            this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices, this._minUpdate, this._minUpdate, this._maxUpdate - this._minUpdate), 
            this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0 && (this._bufferState.bind(), 
            E.instance.drawArrays(1, 0, 2 * this._lineCount), P.renderBatches++);
        }, t.destroy = function() {
            this._destroyed || (e.prototype.destroy.call(this), this._bufferState.destroy(), 
            this._vertexBuffer.destroy(), this._bufferState = null, this._vertexBuffer = null, 
            this._vertices = null);
        }, i(PixelLineFilter, [ "_type", function() {
            return this._type = te._typeCounter++;
        } ]), PixelLineFilter;
    }(te), pn = function(e) {
        function CylinderColliderShape(e, t, n) {
            switch (this._radius = 1, this._height = .5, CylinderColliderShape.__super.call(this), 
            void 0 === e && (e = .5), void 0 === t && (t = 1), void 0 === n && (n = 1), this._radius = e, 
            this._height = t, this._orientation = n, this._type = 2, n) {
              case 0:
                CylinderColliderShape._nativeSize.setValue(t / 2, e, e), this._nativeShape = new X._physics3D.btCylinderShapeX(CylinderColliderShape._nativeSize);
                break;

              case 1:
                CylinderColliderShape._nativeSize.setValue(e, t / 2, e), this._nativeShape = new X._physics3D.btCylinderShape(CylinderColliderShape._nativeSize);
                break;

              case 2:
                CylinderColliderShape._nativeSize.setValue(e, e, t / 2), this._nativeShape = new X._physics3D.btCylinderShapeZ(CylinderColliderShape._nativeSize);
                break;

              default:
                throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        r(CylinderColliderShape, "laya.d3.physics.shape.CylinderColliderShape", W);
        var t = CylinderColliderShape.prototype;
        return t.clone = function() {
            var e = new CylinderColliderShape(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }, a(0, t, "radius", function() {
            return this._radius;
        }), a(0, t, "height", function() {
            return this._height;
        }), a(0, t, "orientation", function() {
            return this._orientation;
        }), i(CylinderColliderShape, [ "_nativeSize", function() {
            return this._nativeSize = new X._physics3D.btVector3(0, 0, 0);
        } ]), CylinderColliderShape;
    }(), Tn = function(e) {
        function FloatKeyframe() {
            FloatKeyframe.__super.call(this);
        }
        return r(FloatKeyframe, "laya.d3.core.FloatKeyframe", e), FloatKeyframe.prototype.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.inTangent = this.inTangent, n.outTangent = this.outTangent, n.value = this.value;
        }, FloatKeyframe;
    }(fe), Sn = function(e) {
        function SubMeshInstanceBatch() {
            this.maxInstanceCount = 1024, SubMeshInstanceBatch.__super.call(this), this.instanceWorldMatrixData = new Float32Array(16 * this.maxInstanceCount), 
            this.instanceMVPMatrixData = new Float32Array(16 * this.maxInstanceCount), this.instanceWorldMatrixBuffer = new Qt(4 * this.instanceWorldMatrixData.length, 35048), 
            this.instanceMVPMatrixBuffer = new Qt(4 * this.instanceMVPMatrixData.length, 35048), 
            this.instanceWorldMatrixBuffer.vertexDeclaration = De.instanceWorldMatrixDeclaration, 
            this.instanceMVPMatrixBuffer.vertexDeclaration = De.instanceMVPMatrixDeclaration;
        }
        return r(SubMeshInstanceBatch, "laya.d3.graphics.SubMeshInstanceBatch", te), SubMeshInstanceBatch.prototype._render = function(e) {
            var t = e.renderElement, n = t.instanceSubMesh, i = t.instanceBatchElementList.length, r = n._indexCount;
            n._mesh._instanceBufferState.bind(), F._angleInstancedArrays.drawElementsInstancedANGLE(4, r, 5123, 2 * n._indexStart, i), 
            P.renderBatches++, P.savedRenderBatches += i - 1, P.trianglesFaces += r * i / 3;
        }, i(SubMeshInstanceBatch, [ "instance", function() {
            return this.instance = new SubMeshInstanceBatch();
        } ]), SubMeshInstanceBatch;
    }(), En = function(e) {
        function OctreeMotionList() {
            OctreeMotionList.__super.call(this);
        }
        r(OctreeMotionList, "laya.d3.core.scene.OctreeMotionList", $);
        var t = OctreeMotionList.prototype;
        return t.add = function(e) {
            if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
            this._add(e), e._setIndexInMotionList(this.length++);
        }, t.remove = function(e) {
            var t = e._getIndexInMotionList();
            if (this.length--, t !== this.length) {
                var n = this.elements[this.length];
                this.elements[t] = n, n._inPhysicUpdateListIndex = t;
            }
            e._setIndexInMotionList(-1);
        }, OctreeMotionList;
    }(), vn = function(e) {
        function SetRenderTargetCMD() {
            this._renderTexture = null, SetRenderTargetCMD.__super.call(this);
        }
        r(SetRenderTargetCMD, "laya.d3.core.render.command.SetRenderTargetCMD", q);
        var t = SetRenderTargetCMD.prototype;
        return t.run = function() {
            this._renderTexture._start();
        }, t.recover = function() {
            SetRenderTargetCMD._pool.push(this), this._renderTexture = null;
        }, SetRenderTargetCMD.create = function(e) {
            var t;
            return (t = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD())._renderTexture = e, 
            t;
        }, SetRenderTargetCMD._pool = [], SetRenderTargetCMD;
    }(), gn = function(e) {
        function MeshRenderStaticBatchManager() {
            this._opaqueBatchMarks = [], MeshRenderStaticBatchManager.__super.call(this), this._updateCountMark = 0;
        }
        r(MeshRenderStaticBatchManager, "laya.d3.graphics.MeshRenderStaticBatchManager", e);
        var t = MeshRenderStaticBatchManager.prototype;
        return t._compare = function(e, t) {
            var n = e._render, i = t._render, r = e.meshFilter.sharedMesh, a = t.meshFilter.sharedMesh, o = n.lightmapIndex - i.lightmapIndex;
            if (0 === o) {
                var s = (n.receiveShadow ? 1 : 0) - (i.receiveShadow ? 1 : 0);
                if (0 === s) {
                    var l = n.sharedMaterial.id - i.sharedMaterial.id;
                    if (0 === l) {
                        var h = r._vertexBuffers[0].vertexDeclaration.id - a._vertexBuffers[0].vertexDeclaration.id;
                        return 0 === h ? a._indexBuffer.indexCount - r._indexBuffer.indexCount : h;
                    }
                    return l;
                }
                return s;
            }
            return o;
        }, t._getBatchRenderElementFromPool = function() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new Nn(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e, 
            e.staticBatchElementList = []), e;
        }, t._getStaticBatch = function(e, t) {
            var n = e ? e.id : 0, i = this._staticBatches[n];
            return i || (i = this._staticBatches[n] = []), i[t] || (i[t] = new dn(e, t, MeshRenderStaticBatchManager._verDec));
        }, t._initStaticBatchs = function(e) {
            this._quickSort(this._initBatchSprites, 0, this._initBatchSprites.length - 1);
            for (var t, n = !1, i = 0, r = 0, a = this._initBatchSprites.length; r < a; r++) {
                var o = this._initBatchSprites[r];
                if (n) t.addTest(o) ? t.add(o) : (n = !1, i++); else r !== a - 1 && ((t = this._getStaticBatch(e, i)).add(o), 
                n = !0);
            }
            for (var s in this._staticBatches) {
                var l = this._staticBatches[s];
                for (r = 0, a = l.length; r < a; r++) l[r].finishInit();
            }
            this._initBatchSprites.length = 0;
        }, t._destroyRenderSprite = function(e) {
            var t = e._render._staticBatch;
            if (t.remove(e), 0 === t._batchElements.length) {
                var n = t.batchOwner, i = n ? n.id : 0, r = this._staticBatches[i];
                r[t.number] = null, t.dispose();
                for (var a = !0, o = 0; o < r.length; o++) r[o] && (a = !1);
                a && delete this._staticBatches[i];
            }
        }, t._clear = function() {
            e.prototype._clear.call(this), this._updateCountMark++;
        }, t._garbageCollection = function() {
            for (var e in this._staticBatches) for (var t = this._staticBatches[e], n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                0 === r._batchElements.length && (r.dispose(), t.splice(n, 1), n--, 0 === --i && delete this._staticBatches[e]);
            }
        }, t.getBatchOpaquaMark = function(e, t, n, i) {
            var r = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []), a = r[t] || (r[t] = []), o = a[n] || (a[n] = []);
            return o[i] || (o[i] = new pt());
        }, i(MeshRenderStaticBatchManager, [ "_verDec", function() {
            return this._verDec = De.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
        }, "instance", function() {
            return this.instance = new MeshRenderStaticBatchManager();
        } ]), MeshRenderStaticBatchManager;
    }(j), xn = function(e) {
        function SubMeshDynamicBatch() {
            this._vertices = null, this._indices = null, this._positionOffset = 0, this._normalOffset = 0, 
            this._colorOffset = 0, this._uv0Offset = 0, this._uv1Offset = 0, this._sTangentOffset = 0, 
            this._vertexBuffer = null, this._indexBuffer = null, SubMeshDynamicBatch.__super.call(this), 
            this._bufferState = new Jt();
            var e = 32e3 * De.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride;
            this._vertices = new Float32Array(e / 4), this._vertexBuffer = new Qt(e, 35048), 
            this._indices = new Int16Array(32e3), this._indexBuffer = new jt("ushort", this._indices.length, 35048);
            var t = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            C._addMemory(t, t);
        }
        r(SubMeshDynamicBatch, "laya.d3.graphics.SubMeshDynamicBatch", te);
        var t = SubMeshDynamicBatch.prototype;
        return t._getBatchVertices = function(e, t, n, i, r, a) {
            var o = e.vertexStride / 4, s = a._vertexBuffer.getData(), l = (r.render.lightmapScaleOffset, 
            r._dynamicMultiSubMesh), h = r._dynamicVertexCount;
            r._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, h);
            for (var u = r._dynamicWorldPositions, c = r._dynamicWorldNormals, d = a._indices, _ = 0; _ < h; _++) {
                var f = (l ? d[_] : _) * o, m = (_ + n) * o, p = 3 * _, T = m + this._positionOffset;
                t[T] = u[p], t[T + 1] = u[p + 1], t[T + 2] = u[p + 2], -1 !== this._normalOffset && (t[T = m + this._normalOffset] = c[p], 
                t[T + 1] = c[p + 1], t[T + 2] = c[p + 2]), -1 !== this._colorOffset && (T = m + this._colorOffset, 
                p = f + this._colorOffset, t[T] = s[p], t[T + 1] = s[p + 1], t[T + 2] = s[p + 2], 
                t[T + 3] = s[p + 3]), -1 !== this._uv0Offset && (T = m + this._uv0Offset, p = f + this._uv0Offset, 
                t[T] = s[p], t[T + 1] = s[p + 1]), -1 !== this._sTangentOffset && (T = m + this._sTangentOffset, 
                p = f + this._sTangentOffset, t[T] = s[p], t[T + 1] = s[p + 1], t[T + 2] = s[p + 2], 
                t[T + 3] = s[p + 3], T = m + this._sTangentOffset, p = f + this._sTangentOffset, 
                t[T] = s[p], t[T + 1] = s[p + 1], t[T + 2] = s[p + 2], t[T + 3] = s[p + 3]);
            }
        }, t._getBatchIndices = function(e, t, n, i, r, a) {
            var o = r._indices, s = 0, l = 0, h = 0, u = i._isFrontFaceInvert;
            if (a) if (u) for (s = 0, l = o.length; s < l; s += 3) {
                var c = n + s;
                e[h = t + s] = c, e[h + 1] = c + 2, e[h + 2] = c + 1;
            } else for (s = l, l = o.length; s < l; s += 3) c = n + s, e[h = t + s] = c, e[h + 1] = c + 1, 
            e[h + 2] = c + 2; else if (u) for (s = 0, l = o.length; s < l; s += 3) e[h = t + s] = n + o[s], 
            e[h + 1] = n + o[s + 2], e[h + 2] = n + o[s + 1]; else for (s = l, l = o.length; s < l; s += 3) e[h = t + s] = n + o[s], 
            e[h + 1] = n + o[s + 1], e[h + 2] = n + o[s + 2];
        }, t._flush = function(e, t) {
            this._vertexBuffer.setData(this._vertices, 0, 0, e * (this._vertexBuffer.vertexDeclaration.vertexStride / 4)), 
            this._indexBuffer.setData(this._indices, 0, 0, t), E.instance.drawElements(4, t, 5123, 0);
        }, t._prepareRender = function(e) {
            var t = e.renderElement.vertexBatchVertexDeclaration;
            this._bufferState = ln.instance._getBufferState(t), this._positionOffset = t.getVertexElementByUsage(0).offset / 4;
            var n = t.getVertexElementByUsage(3);
            this._normalOffset = n ? n.offset / 4 : -1;
            var i = t.getVertexElementByUsage(1);
            this._colorOffset = i ? i.offset / 4 : -1;
            var r = t.getVertexElementByUsage(2);
            this._uv0Offset = r ? r.offset / 4 : -1;
            var a = t.getVertexElementByUsage(7);
            this._uv1Offset = a ? a.offset / 4 : -1;
            var o = t.getVertexElementByUsage(4);
            return this._sTangentOffset = o ? o.offset / 4 : -1, !0;
        }, t._render = function(e) {
            this._bufferState.bind();
            for (var t = e.renderElement, n = t.vertexBatchVertexDeclaration, i = t.vertexBatchElementList, r = 0, a = 0, o = (n.vertexStride, 
            0), s = i.length, l = 0; l < s; l++) {
                var h = i[l], u = h._geometry, c = u._indexCount;
                a + c > 32e3 && (this._flush(r, a), o++, P.trianglesFaces += a / 3, r = a = 0);
                var d = h._transform;
                this._getBatchVertices(n, this._vertices, r, d, h, u), this._getBatchIndices(this._indices, a, r, d, u, h._dynamicMultiSubMesh), 
                r += h._dynamicVertexCount, a += c;
            }
            this._flush(r, a), o++, P.renderBatches += o, P.savedRenderBatches += s - o, P.trianglesFaces += a / 3;
        }, SubMeshDynamicBatch.maxAllowVertexCount = 10, SubMeshDynamicBatch.maxAllowAttribueCount = 900, 
        SubMeshDynamicBatch.maxIndicesCount = 32e3, SubMeshDynamicBatch.instance = null, 
        SubMeshDynamicBatch;
    }(), Mn = function(e) {
        function SkyBox() {
            SkyBox.__super.call(this);
            var e = new Float32Array([ -.5, .5, -.5, .5, .5, -.5, .5, .5, .5, -.5, .5, .5, -.5, -.5, -.5, .5, -.5, -.5, .5, -.5, .5, -.5, -.5, .5 ]), t = new Uint8Array([ 0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0 ]), n = De.getVertexDeclaration("POSITION");
            this._vertexBuffer = new Qt(8 * n.vertexStride, 35044, !1), this._vertexBuffer.vertexDeclaration = n, 
            this._indexBuffer = new jt("ubyte", 36, 35044, !1), this._vertexBuffer.setData(e), 
            this._indexBuffer.setData(t);
            var i = new Jt();
            i.bind(), i.applyVertexBuffer(this._vertexBuffer), i.applyIndexBuffer(this._indexBuffer), 
            i.unBind(), this._bufferState = i;
        }
        return r(SkyBox, "laya.d3.resource.models.SkyBox", Le), SkyBox.prototype._render = function(e) {
            E.instance.drawElements(4, 36, 5121, 0), P.trianglesFaces += 12, P.renderBatches++;
        }, SkyBox.__init__ = function() {
            SkyBox.instance = new SkyBox();
        }, SkyBox.instance = null, SkyBox;
    }(), yn = function(e) {
        function MeshColliderShape() {
            this._mesh = null, this._convex = !1, MeshColliderShape.__super.call(this);
        }
        r(MeshColliderShape, "laya.d3.physics.shape.MeshColliderShape", e);
        var t = MeshColliderShape.prototype;
        return t._setScale = function(e) {
            this._compoundParent ? this.updateLocalTransformations() : (W._nativeScale.setValue(e.x, e.y, e.z), 
            this._nativeShape.setLocalScaling(W._nativeScale), this._nativeShape.updateBound());
        }, t.cloneTo = function(t) {
            var n = t;
            n.convex = this._convex, n.mesh = this._mesh, e.prototype.cloneTo.call(this, t);
        }, t.clone = function() {
            var e = new MeshColliderShape();
            return this.cloneTo(e), e;
        }, t.destroy = function() {
            this._nativeShape && (X._physics3D.destroy(this._nativeShape), this._nativeShape = null);
        }, a(0, t, "mesh", function() {
            return this._mesh;
        }, function(e) {
            if (this._mesh !== e) {
                var t = X._physics3D;
                this._mesh && t.destroy(this._nativeShape), e && (this._nativeShape = new t.btGImpactMeshShape(e._getPhysicMesh()), 
                this._nativeShape.updateBound()), this._mesh = e;
            }
        }), a(0, t, "convex", function() {
            return this._convex;
        }, function(e) {
            this._convex = e;
        }), MeshColliderShape;
    }(W), Dn = function(e) {
        function HemisphereShape() {
            this.radius = NaN, this.emitFromShell = !1, HemisphereShape.__super.call(this), 
            this.radius = 1, this.emitFromShell = !1, this.randomDirection = !1;
        }
        r(HemisphereShape, "laya.d3.core.particleShuriKen.module.shape.HemisphereShape", e);
        var t = HemisphereShape.prototype;
        return t._getShapeBoundBox = function(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var n = e.max;
            n.x = n.y = this.radius, n.z = 0;
        }, t._getSpeedBoundBox = function(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var n = e.max;
            n.x = n.y = n.z = 1;
        }, t.generatePositionAndDirection = function(e, t, n, i) {
            n ? (n.seed = i[16], this.emitFromShell ? Lt._randomPointUnitSphere(e, n) : Lt._randomPointInsideUnitSphere(e, n), 
            i[16] = n.seed) : this.emitFromShell ? Lt._randomPointUnitSphere(e) : Lt._randomPointInsideUnitSphere(e), 
            Te.scale(e, this.radius, e);
            var r = e.z;
            r < 0 && (e.z = -1 * r), this.randomDirection ? n ? (n.seed = i[17], Lt._randomPointUnitSphere(t, n), 
            i[17] = n.seed) : Lt._randomPointUnitSphere(t) : e.cloneTo(t);
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.radius = this.radius, n.emitFromShell = this.emitFromShell, n.randomDirection = this.randomDirection;
        }, HemisphereShape;
    }(k), Rn = function(e) {
        function TerrainFilter(e, t, n, i, r, a, s, l) {
            this._owner = null, this._gridSize = NaN, this.memorySize = 0, this._numberVertices = 0, 
            this._maxNumberIndices = 0, this._currentNumberIndices = 0, this._numberTriangle = 0, 
            this._vertexBuffer = null, this._indexBuffer = null, this._indexArrayBuffer = null, 
            this._boundingBoxCorners = null, this._leafs = null, this._leafNum = 0, this._terrainHeightData = null, 
            this._terrainHeightDataWidth = 0, this._terrainHeightDataHeight = 0, this._chunkOffsetX = 0, 
            this._chunkOffsetZ = 0, this._cameraCoordinateInverse = !1, this._cameraPos = null, 
            this._currentLOD = 0, this._perspectiveFactor = NaN, this._LODTolerance = 0, this._boundingSphere = null, 
            this._boundingBox = null, TerrainFilter.__super.call(this), this._bufferState = new Jt(), 
            this._owner = e, this._cameraPos = new Te(), this._chunkOffsetX = t, this._chunkOffsetZ = n, 
            this._gridSize = i, this._terrainHeightData = r, this._terrainHeightDataWidth = a, 
            this._terrainHeightDataHeight = s, this._leafNum = ce.CHUNK_GRID_NUM / ce.LEAF_GRID_NUM * (ce.CHUNK_GRID_NUM / ce.LEAF_GRID_NUM), 
            this._leafs = o(this._leafNum), this._cameraCoordinateInverse = l;
            for (var h = 0; h < this._leafNum; h++) this._leafs[h] = new ce();
            this.recreateResource();
        }
        r(TerrainFilter, "laya.d3.terrain.TerrainFilter", te);
        var t = TerrainFilter.prototype;
        return t.recreateResource = function() {
            this._currentNumberIndices = 0, this._numberTriangle = 0;
            var e = ce.LEAF_VERTEXT_COUNT, t = ce.LEAF_MAX_INDEX_COUNT;
            this._numberVertices = e * this._leafNum, this._maxNumberIndices = t * this._leafNum, 
            this._indexArrayBuffer = new Uint16Array(this._maxNumberIndices);
            var n = je.vertexDeclaration, i = n.vertexStride / 4, r = new Float32Array(this._numberVertices * i), a = ce.CHUNK_GRID_NUM / ce.LEAF_GRID_NUM, o = 0, s = 0, l = 0;
            for (o = 0; o < this._leafNum; o++) s = o % a, l = Math.floor(o / a), this._leafs[o].calcVertextBuffer(this._chunkOffsetX, this._chunkOffsetZ, s * ce.LEAF_GRID_NUM, l * ce.LEAF_GRID_NUM, this._gridSize, r, o * ce.LEAF_PLANE_VERTEXT_COUNT, i, this._terrainHeightData, this._terrainHeightDataWidth, this._terrainHeightDataHeight, this._cameraCoordinateInverse);
            for (o = 0; o < this._leafNum; o++) s = o % a, l = Math.floor(o / a), this._leafs[o].calcSkirtVertextBuffer(this._chunkOffsetX, this._chunkOffsetZ, s * ce.LEAF_GRID_NUM, l * ce.LEAF_GRID_NUM, this._gridSize, r, this._leafNum * ce.LEAF_PLANE_VERTEXT_COUNT + o * ce.LEAF_SKIRT_VERTEXT_COUNT, i, this._terrainHeightData, this._terrainHeightDataWidth, this._terrainHeightDataHeight);
            this.assembleIndexInit(), this._vertexBuffer = new Qt(n.vertexStride * this._numberVertices, 35044, !1), 
            this._vertexBuffer.vertexDeclaration = n, this._indexBuffer = new jt("ushort", this._maxNumberIndices, 35044, !1), 
            this._vertexBuffer.setData(r), this._indexBuffer.setData(this._indexArrayBuffer), 
            this.memorySize = 2 * (this._vertexBuffer._byteLength + this._indexBuffer._byteLength), 
            this.calcOriginalBoudingBoxAndSphere(), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
        }, t.setLODLevel = function(e) {
            if (4 != e.length) return !0;
            var t = (e[0] + 1 << 24) + (e[1] + 1 << 16) + (e[2] + 1 << 8) + (e[3] + 1);
            return this._currentLOD != t && (this._currentLOD = t, !0);
        }, t.assembleIndexInit = function() {
            this._currentNumberIndices = 0, this._numberTriangle = 0;
            for (var e = 0, t = 0; t < this._leafNum; t++) {
                var n = ce.getPlaneLODIndex(t, 0);
                this._indexArrayBuffer.set(n, e), e += n.length;
                var i = ce.getSkirtLODIndex(t, 0);
                this._indexArrayBuffer.set(i, e), e += i.length, this._currentNumberIndices += n.length + i.length;
            }
            this._numberTriangle = this._currentNumberIndices / 3;
        }, t.isNeedAssemble = function(e, t) {
            var n = Math.min(e.viewport.width, e.viewport.height) / (2 * Math.tan(Math.PI * e.fieldOfView / 180));
            return this._perspectiveFactor != n ? (this._perspectiveFactor = n, 1) : this._LODTolerance != ti.LOD_TOLERANCE_VALUE ? (this._LODTolerance = ti.LOD_TOLERANCE_VALUE, 
            1) : 0 == Te.equals(t, this._cameraPos) ? (this._cameraPos.x = t.x, this._cameraPos.y = t.y, 
            this._cameraPos.z = t.z, 2) : 0;
        }, t.assembleIndex = function(e, t) {
            var n = this.isNeedAssemble(e, t);
            if (n > 0) {
                for (var i = 0; i < this._leafNum; i++) TerrainFilter._TEMP_ARRAY_BUFFER[i] = this._leafs[i].determineLod(t, this._perspectiveFactor, ti.LOD_TOLERANCE_VALUE, 1 == n);
                if (this.setLODLevel(TerrainFilter._TEMP_ARRAY_BUFFER)) {
                    this._currentNumberIndices = 0, this._numberTriangle = 0;
                    var r = 0;
                    for (i = 0; i < this._leafNum; i++) {
                        var a = TerrainFilter._TEMP_ARRAY_BUFFER[i], o = ce.getPlaneLODIndex(i, a);
                        this._indexArrayBuffer.set(o, r), r += o.length;
                        var s = ce.getSkirtLODIndex(i, a);
                        this._indexArrayBuffer.set(s, r), r += s.length, this._currentNumberIndices += o.length + s.length;
                    }
                    return this._numberTriangle = this._currentNumberIndices / 3, !0;
                }
            }
            return !1;
        }, t.calcOriginalBoudingBoxAndSphere = function() {
            for (var e = new Se(2147483647, -2147483647), t = 0; t < this._leafNum; t++) e.x = this._leafs[t]._sizeOfY.x < e.x ? this._leafs[t]._sizeOfY.x : e.x, 
            e.y = this._leafs[t]._sizeOfY.y > e.y ? this._leafs[t]._sizeOfY.y : e.y;
            var n = new Te(this._chunkOffsetX * ce.CHUNK_GRID_NUM * this._gridSize, e.x, this._chunkOffsetZ * ce.CHUNK_GRID_NUM * this._gridSize), i = new Te((this._chunkOffsetX + 1) * ce.CHUNK_GRID_NUM * this._gridSize, e.y, (this._chunkOffsetZ + 1) * ce.CHUNK_GRID_NUM * this._gridSize);
            ce.__ADAPT_MATRIX__ && (Te.transformV3ToV3(n, ce.__ADAPT_MATRIX__, n), Te.transformV3ToV3(i, ce.__ADAPT_MATRIX__, i)), 
            this._boundingBox = new zt(n, i);
            var r = new Te();
            Te.subtract(i, n, r), Te.scale(r, .5, r);
            var a = new Te();
            Te.add(n, r, a), this._boundingSphere = new Ce(a, Te.scalarLength(r)), this._boundingBoxCorners = o(8, null), 
            this._boundingBox.getCorners(this._boundingBoxCorners);
        }, t.calcLeafBoudingBox = function(e) {
            for (var t = 0; t < this._leafNum; t++) this._leafs[t].calcLeafBoudingBox(e);
        }, t.calcLeafBoudingSphere = function(e, t) {
            for (var n = 0; n < this._leafNum; n++) this._leafs[n].calcLeafBoudingSphere(e, t);
        }, t._getVertexBuffer = function(e) {
            return void 0 === e && (e = 0), 0 == e ? this._vertexBuffer : null;
        }, t._getIndexBuffer = function() {
            return this._indexBuffer;
        }, t._getType = function() {
            return TerrainFilter._type;
        }, t._prepareRender = function(e) {
            return !0;
        }, t._render = function(e) {
            this._bufferState.bind(), E.instance.drawElements(ti.RENDER_LINE_MODEL ? 1 : 4, this._currentNumberIndices, 5123, 0), 
            P.trianglesFaces += this._numberTriangle, P.renderBatches++;
        }, t.destroy = function() {
            this._owner = null, this._bufferState.destroy(), this._vertexBuffer && this._vertexBuffer.destroy(), 
            this._indexBuffer && this._indexBuffer.destroy();
        }, i(TerrainFilter, [ "_TEMP_ARRAY_BUFFER", function() {
            return this._TEMP_ARRAY_BUFFER = new Uint32Array(ce.CHUNK_GRID_NUM / ce.LEAF_GRID_NUM * ce.CHUNK_GRID_NUM / ce.LEAF_GRID_NUM);
        }, "_type", function() {
            return this._type = te._typeCounter++;
        } ]), TerrainFilter;
    }(), Cn = (function(e) {
        function BloomEffect() {
            this._shader = null, this._pyramid = null, this._intensity = 0, this._threshold = 1, 
            this._softKnee = .5, this._diffusion = 7, this._anamorphicRatio = 0, this._dirtIntensity = 0, 
            this.clamp = 65472, this.fastMode = !1, this.dirtTexture = null, BloomEffect.__super.call(this), 
            this._shaderData = new ue(), this._linearColor = new Me(), this._shaderThreshold = new me(), 
            this._shaderParams = new me(), this._shaderSetting = new me(), this._dirtTileOffset = new me(), 
            this.color = new Me(1, 1, 1, 1), this._shader = Ve.find("PostProcessBloom"), this._pyramid = new Array(32);
        }
        r(BloomEffect, "laya.d3.core.render.BloomEffect", we);
        var t = BloomEffect.prototype;
        t.render = function(e) {
            var t = e.command, n = e.camera.viewport;
            this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, B.whiteTexture);
            var i, r = this._anamorphicRatio, a = r < 0 ? -r : 0, o = r > 0 ? r : 0, s = Math.floor(n.width / (2 - a)), l = Math.floor(n.height / (2 - o)), h = Math.max(s, l);
            i = Math.log2(h) + this._diffusion - 10;
            var u = Math.floor(i), c = Math.min(Math.max(u, 1), 16), d = .5 + i - u;
            this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, d);
            var _ = ke.gammaToLinearSpace(this.threshold), f = _ * this._softKnee + 1e-5;
            this._shaderThreshold.setValue(_, _ - f, 2 * f, .25 / f), this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
            var m = ke.gammaToLinearSpace(this.clamp);
            this._shaderParams.setValue(m, 0, 0, 0), this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
            for (var p = this.fastMode ? 1 : 0, T = e.source, S = 0; S < c; S++) {
                var E = 2 * S, v = E + 1, g = 0 == S ? 0 + p : 2 + p, x = pi.getTemporary(s, l, 0, 3, 1), M = pi.getTemporary(s, l, 0, 3, 1);
                this._pyramid[E] = x, this._pyramid[v] = M, t.blit(T, x, this._shader, this._shaderData, g), 
                T = x, s = Math.max(s / 2, 1), l = Math.max(l / 2, 1);
            }
            var y = this._pyramid[2 * c - 3];
            for (S = c - 2; S >= 0; S--) v = (E = 2 * S) + 1, x = this._pyramid[E], M = this._pyramid[v], 
            t.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, x), t.blit(y, M, this._shader, this._shaderData, 4 + p), 
            y = M;
            var D = this._linearColor;
            this.color.toLinear(D);
            var R = Math.pow(2, this._intensity / 10) - 1, C = this._shaderSetting;
            this._shaderSetting.setValue(d, R, this._dirtIntensity, c);
            var I = I || B.blackTexture, A = I.width / I.height, L = n.width / n.height, O = this._dirtTileOffset;
            O.setValue(1, 1, 0, 0), A > L ? O.setValue(L / A, 1, .5 * (1 - O.x), 0) : A < L && O.setValue(1, A / L, 0, .5 * (1 - O.y));
            var P = e.compositeShaderData, V = e.compositeDefineData;
            for (this.fastMode ? V.add(Rt.SHADERDEFINE_BLOOM_LOW) : V.add(Rt.SHADERDEFINE_BLOOM), 
            P.setVector(Rt.SHADERVALUE_BLOOM_DIRTTILEOFFSET, O), P.setVector(Rt.SHADERVALUE_BLOOM_SETTINGS, C), 
            P.setVector(Rt.SHADERVALUE_BLOOM_COLOR, new me(D.r, D.g, D.b, D.a)), P.setTexture(Rt.SHADERVALUE_BLOOM_DIRTTEX, I), 
            P.setTexture(Rt.SHADERVALUE_BLOOMTEX, y), S = 0; S < c; S++) v = (E = 2 * S) + 1, 
            this._pyramid[E] != y && pi.setReleaseTemporary(this._pyramid[E]), this._pyramid[v] != y && pi.setReleaseTemporary(this._pyramid[v]);
            e.tempRenderTextures.push(y);
        }, a(0, t, "softKnee", function() {
            return this._softKnee;
        }, function(e) {
            this._softKnee = Math.min(Math.max(e, 0), 1);
        }), a(0, t, "intensity", function() {
            return this._intensity;
        }, function(e) {
            this._intensity = Math.max(e, 0);
        }), a(0, t, "threshold", function() {
            return this._threshold;
        }, function(e) {
            this._threshold = Math.max(e, 0);
        }), a(0, t, "anamorphicRatio", function() {
            return this._anamorphicRatio;
        }, function(e) {
            this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
        }), a(0, t, "diffusion", function() {
            return this._diffusion;
        }, function(e) {
            this._diffusion = Math.min(Math.max(e, 1), 10);
        }), a(0, t, "dirtIntensity", function() {
            return this._dirtIntensity;
        }, function(e) {
            this._dirtIntensity = Math.max(e, 0);
        }), BloomEffect.SUBSHADER_PREFILTER13 = 0, BloomEffect.SUBSHADER_PREFILTER4 = 1, 
        BloomEffect.SUBSHADER_DOWNSAMPLE13 = 2, BloomEffect.SUBSHADER_DOWNSAMPLE4 = 3, BloomEffect.SUBSHADER_UPSAMPLETENT = 4, 
        BloomEffect.SUBSHADER_UPSAMPLEBOX = 5, BloomEffect.MAXPYRAMIDSIZE = 16, i(BloomEffect, [ "SHADERVALUE_MAINTEX", function() {
            return this.SHADERVALUE_MAINTEX = Ve.propertyNameToID("u_MainTex");
        }, "SHADERVALUE_AUTOEXPOSURETEX", function() {
            return this.SHADERVALUE_AUTOEXPOSURETEX = Ve.propertyNameToID("u_AutoExposureTex");
        }, "SHADERVALUE_SAMPLESCALE", function() {
            return this.SHADERVALUE_SAMPLESCALE = Ve.propertyNameToID("u_SampleScale");
        }, "SHADERVALUE_THRESHOLD", function() {
            return this.SHADERVALUE_THRESHOLD = Ve.propertyNameToID("u_Threshold");
        }, "SHADERVALUE_PARAMS", function() {
            return this.SHADERVALUE_PARAMS = Ve.propertyNameToID("u_Params");
        }, "SHADERVALUE_BLOOMTEX", function() {
            return this.SHADERVALUE_BLOOMTEX = Ve.propertyNameToID("u_BloomTex");
        } ]);
    }(), function(e) {
        function SetShaderDataTextureCMD() {
            this._shaderData = null, this._nameID = 0, this._texture = null, SetShaderDataTextureCMD.__super.call(this);
        }
        r(SetShaderDataTextureCMD, "laya.d3.core.render.command.SetShaderDataTextureCMD", q);
        var t = SetShaderDataTextureCMD.prototype;
        return t.run = function() {
            this._shaderData.setTexture(this._nameID, this._texture);
        }, t.recover = function() {
            SetShaderDataTextureCMD._pool.push(this), this._shaderData = null, this._nameID = 0, 
            this._texture = null;
        }, SetShaderDataTextureCMD.create = function(e, t, n) {
            var i;
            return (i = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD())._shaderData = e, 
            i._nameID = t, i._texture = n, i;
        }, SetShaderDataTextureCMD._pool = [], SetShaderDataTextureCMD;
    }()), In = function(e) {
        function SphereShape() {
            this.radius = NaN, this.emitFromShell = !1, SphereShape.__super.call(this), this.radius = 1, 
            this.emitFromShell = !1, this.randomDirection = !1;
        }
        r(SphereShape, "laya.d3.core.particleShuriKen.module.shape.SphereShape", e);
        var t = SphereShape.prototype;
        return t._getShapeBoundBox = function(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var n = e.max;
            n.x = n.y = n.z = this.radius;
        }, t._getSpeedBoundBox = function(e) {
            var t = e.min;
            t.x = t.y = t.z = -1;
            var n = e.max;
            n.x = n.y = n.z = 1;
        }, t.generatePositionAndDirection = function(e, t, n, i) {
            n ? (n.seed = i[16], this.emitFromShell ? Lt._randomPointUnitSphere(e, n) : Lt._randomPointInsideUnitSphere(e, n), 
            i[16] = n.seed) : this.emitFromShell ? Lt._randomPointUnitSphere(e) : Lt._randomPointInsideUnitSphere(e), 
            Te.scale(e, this.radius, e), this.randomDirection ? n ? (n.seed = i[17], Lt._randomPointUnitSphere(t, n), 
            i[17] = n.seed) : Lt._randomPointUnitSphere(t) : e.cloneTo(t);
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.radius = this.radius, n.emitFromShell = this.emitFromShell, n.randomDirection = this.randomDirection;
        }, SphereShape;
    }(k), An = function(e) {
        function Vector3Keyframe() {
            Vector3Keyframe.__super.call(this), this.inTangent = new Te(), this.outTangent = new Te(), 
            this.value = new Te();
        }
        return r(Vector3Keyframe, "laya.d3.core.Vector3Keyframe", e), Vector3Keyframe.prototype.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            this.inTangent.cloneTo(n.inTangent), this.outTangent.cloneTo(n.outTangent), this.value.cloneTo(n.value);
        }, Vector3Keyframe;
    }(fe), Ln = function(e) {
        function SkyDome(e, t) {
            this._stacks = 0, this._slices = 0, SkyDome.__super.call(this), void 0 === e && (e = 48), 
            void 0 === t && (t = 48), this._stacks = e, this._slices = t;
            for (var n = ne.vertexDeclaration, i = n.vertexStride / 4, r = (this._stacks + 1) * (this._slices + 1), a = 3 * this._stacks * (this._slices + 1) * 2, o = new Float32Array(r * i), s = new Uint16Array(a), l = Math.PI / this._stacks, h = 2 * Math.PI / this._slices, u = 0, c = 0, d = 0, _ = 0; _ < this._stacks + 1; _++) for (var f = Math.sin(_ * l), m = Math.cos(_ * l), p = 0; p < this._slices + 1; p++) {
                var T = f * Math.sin(p * h), S = f * Math.cos(p * h);
                o[c + 0] = T * SkyDome._radius, o[c + 1] = m * SkyDome._radius, o[c + 2] = S * SkyDome._radius, 
                o[c + 3] = -p / this._slices + .75, o[c + 4] = _ / this._stacks, c += i, _ != this._stacks - 1 && (s[d++] = u + 1, 
                s[d++] = u, s[d++] = u + (this._slices + 1), s[d++] = u + (this._slices + 1), s[d++] = u, 
                s[d++] = u + this._slices, u++);
            }
            this._vertexBuffer = new Qt(4 * o.length, 35044, !1), this._vertexBuffer.vertexDeclaration = n, 
            this._indexBuffer = new jt("ushort", s.length, 35044, !1), this._vertexBuffer.setData(o), 
            this._indexBuffer.setData(s);
            var E = new Jt();
            E.bind(), E.applyVertexBuffer(this._vertexBuffer), E.applyIndexBuffer(this._indexBuffer), 
            E.unBind(), this._bufferState = E;
        }
        r(SkyDome, "laya.d3.resource.models.SkyDome", Le);
        var t = SkyDome.prototype;
        return t._render = function(e) {
            var t = this._indexBuffer.indexCount;
            E.instance.drawElements(4, t, 5123, 0), P.trianglesFaces += t / 3, P.renderBatches++;
        }, a(0, t, "stacks", function() {
            return this._stacks;
        }), a(0, t, "slices", function() {
            return this._slices;
        }), SkyDome.__init__ = function() {
            SkyDome.instance = new SkyDome();
        }, SkyDome._radius = 1, SkyDome.instance = null, SkyDome;
    }(), On = function(e) {
        function ConeColliderShape(e, t, n) {
            switch (this._radius = 1, this._height = .5, ConeColliderShape.__super.call(this), 
            void 0 === e && (e = .5), void 0 === t && (t = 1), void 0 === n && (n = 1), this._radius = e, 
            this._height = t, this._orientation = n, this._type = 2, n) {
              case 0:
                this._nativeShape = new X._physics3D.btConeShapeX(e, t);
                break;

              case 1:
                this._nativeShape = new X._physics3D.btConeShape(e, t);
                break;

              case 2:
                this._nativeShape = new X._physics3D.btConeShapeZ(e, t);
                break;

              default:
                throw "ConeColliderShape:unknown orientation.";
            }
        }
        r(ConeColliderShape, "laya.d3.physics.shape.ConeColliderShape", W);
        var t = ConeColliderShape.prototype;
        return t.clone = function() {
            var e = new ConeColliderShape(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }, a(0, t, "radius", function() {
            return this._radius;
        }), a(0, t, "height", function() {
            return this._height;
        }), a(0, t, "orientation", function() {
            return this._orientation;
        }), ConeColliderShape;
    }(), Pn = function(e) {
        function BoxShape() {
            this.x = NaN, this.y = NaN, this.z = NaN, BoxShape.__super.call(this), this.x = 1, 
            this.y = 1, this.z = 1, this.randomDirection = !1;
        }
        r(BoxShape, "laya.d3.core.particleShuriKen.module.shape.BoxShape", e);
        var t = BoxShape.prototype;
        return t._getShapeBoundBox = function(e) {
            var t = e.min;
            t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
            var n = e.max;
            n.x = .5 * this.x, n.y = .5 * this.y, n.z = .5 * this.z;
        }, t._getSpeedBoundBox = function(e) {
            var t = e.min;
            t.x = 0, t.y = 0, t.z = 0;
            var n = e.max;
            n.x = 0, n.y = 1, n.z = 0;
        }, t.generatePositionAndDirection = function(e, t, n, i) {
            n ? (n.seed = i[16], Lt._randomPointInsideHalfUnitBox(e, n), i[16] = n.seed) : Lt._randomPointInsideHalfUnitBox(e), 
            e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? n ? (n.seed = i[17], 
            Lt._randomPointUnitSphere(t, n), i[17] = n.seed) : Lt._randomPointUnitSphere(t) : (t.x = 0, 
            t.y = 0, t.z = 1);
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n.x = this.x, n.y = this.y, n.z = this.z, n.randomDirection = this.randomDirection;
        }, BoxShape;
    }(k), Vn = function(e) {
        function QuaternionKeyframe() {
            QuaternionKeyframe.__super.call(this), this.inTangent = new me(), this.outTangent = new me(), 
            this.value = new he();
        }
        return r(QuaternionKeyframe, "laya.d3.core.QuaternionKeyframe", e), QuaternionKeyframe.prototype.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            this.inTangent.cloneTo(n.inTangent), this.outTangent.cloneTo(n.outTangent), this.value.cloneTo(n.value);
        }, QuaternionKeyframe;
    }(fe), Nn = function(e) {
        function SubMeshRenderElement() {
            SubMeshRenderElement.__super.call(this), this._dynamicWorldPositionNormalNeedUpdate = !0;
        }
        r(SubMeshRenderElement, "laya.d3.core.render.SubMeshRenderElement", e);
        var t = SubMeshRenderElement.prototype;
        return t._onWorldMatrixChanged = function() {
            this._dynamicWorldPositionNormalNeedUpdate = !0;
        }, t._computeWorldPositionsAndNormals = function(e, t, n, i) {
            if (this._dynamicWorldPositionNormalNeedUpdate) {
                for (var r = this._geometry, a = r._vertexBuffer, o = a.vertexDeclaration.vertexStride / 4, s = a.getData(), l = this._transform.worldMatrix, h = this._transform.rotation, u = r._indices, c = 0; c < i; c++) {
                    var d = (n ? u[c] : c) * o, _ = 3 * c;
                    ke.transformVector3ArrayToVector3ArrayCoordinate(s, d + e, l, this._dynamicWorldPositions, _), 
                    -1 !== t && ke.transformVector3ArrayByQuat(s, d + t, h, this._dynamicWorldNormals, _);
                }
                this._dynamicWorldPositionNormalNeedUpdate = !1;
            }
        }, t.setTransform = function(e) {
            this._transform !== e && (this._transform && this._transform.off("transformchanged", this, this._onWorldMatrixChanged), 
            e && e.on("transformchanged", this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0, 
            this._transform = e);
        }, t.setGeometry = function(e) {
            if (this._geometry !== e) {
                var t = e, n = t._mesh;
                if (n) {
                    var i = n._subMeshCount > 1, r = i ? t._indexCount : n._vertexCount;
                    if (r <= 10) {
                        var a = 3 * r;
                        this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(a), 
                        this._dynamicWorldNormals = new Float32Array(a), this._dynamicVertexCount = r, this._dynamicMultiSubMesh = i;
                    } else this._dynamicVertexBatch = !1;
                }
                this._geometry = e;
            }
        }, t.addToOpaqueRenderQueue = function(e, t) {
            var n = this.staticBatch, i = t.elements;
            if (n) {
                var r = gn.instance, a = r.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, n._batchID);
                if (r._updateCountMark === a.updateMark) {
                    var o = a.indexInList;
                    if (a.batched) i[o].staticBatchElementList.push(this); else {
                        var s = i[o], l = s.render, h = r._getBatchRenderElementFromPool();
                        h.renderType = 1, h.setGeometry(n), h.material = s.material;
                        var u = n.batchOwner, c = u ? u._transform : null;
                        h.setTransform(c), h.render = l;
                        var d = h.staticBatchElementList;
                        d.length = 0, d.push(s), d.push(this), i[o] = h, a.batched = !0;
                    }
                } else a.updateMark = r._updateCountMark, a.indexInList = i.length, a.batched = !1, 
                i.push(this);
            } else if (this.material._shader._enableInstancing && F._angleInstancedArrays) {
                var _ = this._geometry, f = ln.instance, m = f.getInstanceBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, _._id);
                if (f._updateCountMark === m.updateMark) {
                    var p = m.indexInList;
                    if (m.batched) {
                        var T = i[p].instanceBatchElementList;
                        T.length === Sn.instance.maxInstanceCount ? (m.updateMark = f._updateCountMark, 
                        m.indexInList = i.length, m.batched = !1, i.push(this)) : T.push(this);
                    } else {
                        var S = i[p], E = S.render, v = f._getBatchRenderElementFromPool();
                        v.renderType = 2, v.setGeometry(Sn.instance), v.material = S.material, v.setTransform(null), 
                        v.render = E, v.instanceSubMesh = _;
                        var g = v.instanceBatchElementList;
                        g.length = 0, g.push(S), g.push(this), i[p] = v, m.batched = !0;
                    }
                } else m.updateMark = f._updateCountMark, m.indexInList = i.length, m.batched = !1, 
                i.push(this);
            } else if (this._dynamicVertexBatch) {
                var x = this._geometry._vertexBuffer.vertexDeclaration, M = ln.instance, y = M.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, x.id);
                if (M._updateCountMark === y.updateMark) {
                    var D = y.indexInList;
                    if (y.batched) i[D].vertexBatchElementList.push(this); else {
                        var R = i[D], C = R.render, I = M._getBatchRenderElementFromPool();
                        I.renderType = 3, I.setGeometry(xn.instance), I.material = R.material, I.setTransform(null), 
                        I.render = C, I.vertexBatchVertexDeclaration = x;
                        var A = I.vertexBatchElementList;
                        A.length = 0, A.push(R), A.push(this), i[D] = I, y.batched = !0;
                    }
                } else y.updateMark = M._updateCountMark, y.indexInList = i.length, y.batched = !1, 
                i.push(this);
            } else i.push(this);
        }, t.addToTransparentRenderQueue = function(e, t) {
            var n = this.staticBatch, i = t.elements;
            if (n) {
                var r = gn.instance, a = t.lastTransparentRenderElement;
                if (a) {
                    var o = a.render;
                    if (a._geometry._getType() !== this._geometry._getType() || a.staticBatch !== n || a.material !== this.material || o.receiveShadow !== this.render.receiveShadow || o.lightmapIndex !== this.render.lightmapIndex) i.push(this), 
                    t.lastTransparentBatched = !1; else {
                        if (t.lastTransparentBatched) i[i.length - 1].staticBatchElementList.push(this); else {
                            var s = r._getBatchRenderElementFromPool();
                            s.renderType = 1, s.setGeometry(n), s.material = a.material;
                            var l = n.batchOwner, h = l ? l._transform : null;
                            s.setTransform(h), s.render = this.render;
                            var u = s.staticBatchElementList;
                            u.length = 0, u.push(a), u.push(this), i[i.length - 1] = s;
                        }
                        t.lastTransparentBatched = !0;
                    }
                } else i.push(this), t.lastTransparentBatched = !1;
            } else if (this.material._shader._enableInstancing && F._angleInstancedArrays) {
                var c = this._geometry, d = ln.instance, _ = t.lastTransparentRenderElement;
                if (_) {
                    var f = _.render;
                    if (_._geometry._getType() !== this._geometry._getType() || _._geometry !== c || _.material !== this.material || f.receiveShadow !== this.render.receiveShadow || f.lightmapIndex !== this.render.lightmapIndex) i.push(this), 
                    t.lastTransparentBatched = !1; else {
                        if (t.lastTransparentBatched) i[i.length - 1].instanceBatchElementList.push(this); else {
                            var m = d._getBatchRenderElementFromPool();
                            m.renderType = 2, m.setGeometry(Sn.instance), m.material = _.material, m.setTransform(null), 
                            m.render = this.render, m.instanceSubMesh = c;
                            var p = m.instanceBatchElementList;
                            p.length = 0, p.push(_), p.push(this), i[i.length - 1] = m;
                        }
                        t.lastTransparentBatched = !0;
                    }
                } else i.push(this), t.lastTransparentBatched = !1;
            } else if (this._dynamicVertexBatch) {
                var T = this._geometry._vertexBuffer.vertexDeclaration, S = ln.instance, E = t.lastTransparentRenderElement;
                if (E) {
                    var v = E.render;
                    if (E._geometry._getType() !== this._geometry._getType() || E._geometry._vertexBuffer._vertexDeclaration !== T || E.material !== this.material || v.receiveShadow !== this.render.receiveShadow || v.lightmapIndex !== this.render.lightmapIndex) i.push(this), 
                    t.lastTransparentBatched = !1; else {
                        if (t.lastTransparentBatched) i[i.length - 1].vertexBatchElementList.push(this); else {
                            var g = S._getBatchRenderElementFromPool();
                            g.renderType = 3, g.setGeometry(xn.instance), g.material = E.material, g.setTransform(null), 
                            g.render = this.render, g.vertexBatchVertexDeclaration = T;
                            var x = g.vertexBatchElementList;
                            x.length = 0, x.push(E), x.push(this), i[i.length - 1] = g;
                        }
                        t.lastTransparentBatched = !0;
                    }
                } else i.push(this), t.lastTransparentBatched = !1;
            } else i.push(this);
            t.lastTransparentRenderElement = this;
        }, t.destroy = function() {
            e.prototype.destroy.call(this), this._dynamicWorldPositions = null, this._dynamicWorldNormals = null, 
            this.staticBatch = null, this.staticBatchElementList = null, this.vertexBatchElementList = null, 
            this.vertexBatchVertexDeclaration = null;
        }, SubMeshRenderElement._maxInstanceCount = 1024, i(SubMeshRenderElement, [ "_instanceMatrixData", function() {
            return this._instanceMatrixData = new Float32Array(16 * SubMeshRenderElement._maxInstanceCount);
        }, "_instanceMatrixBuffer", function() {
            return this._instanceMatrixBuffer = new Qt(4 * SubMeshRenderElement._instanceMatrixData.length, 35048);
        } ]), SubMeshRenderElement;
    }(Ie), Bn = function(e) {
        function VertexShurikenParticleBillboard(e, t, n, i, r, a, o, s, l, h, u, c, d, _) {
            this._cornerTextureCoordinate = null, this._positionStartLifeTime = null, this._velocity = null, 
            this._startColor = null, this._startSize = null, this._startRotation0 = null, this._startRotation1 = null, 
            this._startRotation2 = null, this._startLifeTime = NaN, this._time = NaN, this._startSpeed = NaN, 
            this._randoms0 = null, this._randoms1 = null, this._simulationWorldPostion = null, 
            VertexShurikenParticleBillboard.__super.call(this), this._cornerTextureCoordinate = e, 
            this._positionStartLifeTime = t, this._velocity = n, this._startColor = i, this._startSize = r, 
            this._startRotation0 = a, this._startRotation1 = o, this._startRotation2 = s, this._startLifeTime = l, 
            this._time = h, this._startSpeed = u, this._randoms0 = this.random0, this._randoms1 = this.random1, 
            this._simulationWorldPostion = _;
        }
        r(VertexShurikenParticleBillboard, "laya.d3.graphics.Vertex.VertexShurikenParticleBillboard", de);
        var t = VertexShurikenParticleBillboard.prototype;
        return a(0, t, "cornerTextureCoordinate", function() {
            return this._cornerTextureCoordinate;
        }), a(0, t, "random1", function() {
            return this._randoms1;
        }), a(0, t, "startRotation2", function() {
            return this._startRotation2;
        }), a(0, t, "positionStartLifeTime", function() {
            return this._positionStartLifeTime;
        }), a(0, t, "velocity", function() {
            return this._velocity;
        }), a(0, t, "random0", function() {
            return this._randoms0;
        }), a(0, t, "startSize", function() {
            return this._startSize;
        }), a(0, t, "startColor", function() {
            return this._startColor;
        }), a(0, t, "startRotation0", function() {
            return this._startRotation0;
        }), a(0, t, "startRotation1", function() {
            return this._startRotation1;
        }), a(0, t, "startLifeTime", function() {
            return this._startLifeTime;
        }), a(0, t, "time", function() {
            return this._time;
        }), a(0, t, "startSpeed", function() {
            return this._startSpeed;
        }), a(0, t, "simulationWorldPostion", function() {
            return this._simulationWorldPostion;
        }), a(1, VertexShurikenParticleBillboard, "vertexDeclaration", function() {
            return VertexShurikenParticleBillboard._vertexDeclaration;
        }, laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration), i(VertexShurikenParticleBillboard, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(152, [ new ze(0, "vector4", 0), new ze(16, "vector4", 4), new ze(32, "vector4", 5), new ze(48, "vector4", 6), new ze(64, "vector3", 8), new ze(76, "vector3", 9), new ze(88, "single", 10), new ze(92, "vector4", 11), new ze(108, "vector4", 12), new ze(124, "vector3", 13), new ze(136, "vector4", 14) ]);
        } ]), VertexShurikenParticleBillboard;
    }(), wn = function(e) {
        function VertexShurikenParticleMesh(e, t, n, i, r, a, o, s, l, h, u, c, d, _) {
            this._cornerTextureCoordinate = null, this._positionStartLifeTime = null, this._velocity = null, 
            this._startColor = null, this._startSize = null, this._startRotation0 = null, this._startRotation1 = null, 
            this._startRotation2 = null, this._startLifeTime = NaN, this._time = NaN, this._startSpeed = NaN, 
            this._randoms0 = null, this._randoms1 = null, this._simulationWorldPostion = null, 
            VertexShurikenParticleMesh.__super.call(this), this._cornerTextureCoordinate = e, 
            this._positionStartLifeTime = t, this._velocity = n, this._startColor = i, this._startSize = r, 
            this._startRotation0 = a, this._startRotation1 = o, this._startRotation2 = s, this._startLifeTime = l, 
            this._time = h, this._startSpeed = u, this._randoms0 = this.random0, this._randoms1 = this.random1, 
            this._simulationWorldPostion = _;
        }
        r(VertexShurikenParticleMesh, "laya.d3.graphics.Vertex.VertexShurikenParticleMesh", de);
        var t = VertexShurikenParticleMesh.prototype;
        return a(0, t, "cornerTextureCoordinate", function() {
            return this._cornerTextureCoordinate;
        }), a(0, t, "velocity", function() {
            return this._velocity;
        }), a(0, t, "position", function() {
            return this._positionStartLifeTime;
        }), a(0, t, "random0", function() {
            return this._randoms0;
        }), a(0, t, "startSize", function() {
            return this._startSize;
        }), a(0, t, "startColor", function() {
            return this._startColor;
        }), a(0, t, "startRotation0", function() {
            return this._startRotation0;
        }), a(0, t, "startRotation1", function() {
            return this._startRotation1;
        }), a(0, t, "random1", function() {
            return this._randoms1;
        }), a(0, t, "startRotation2", function() {
            return this._startRotation2;
        }), a(0, t, "startLifeTime", function() {
            return this._startLifeTime;
        }), a(0, t, "time", function() {
            return this._time;
        }), a(0, t, "startSpeed", function() {
            return this._startSpeed;
        }), a(0, t, "simulationWorldPostion", function() {
            return this._simulationWorldPostion;
        }), a(1, VertexShurikenParticleMesh, "vertexDeclaration", function() {
            return VertexShurikenParticleMesh._vertexDeclaration;
        }, laya.d3.graphics.Vertex.VertexShuriKenParticle._$SET_vertexDeclaration), i(VertexShurikenParticleMesh, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(172, [ new ze(0, "vector3", 1), new ze(12, "vector4", 2), new ze(28, "vector2", 3), new ze(36, "vector4", 4), new ze(52, "vector4", 5), new ze(68, "vector4", 6), new ze(84, "vector3", 8), new ze(96, "vector3", 9), new ze(108, "single", 10), new ze(112, "vector4", 11), new ze(128, "vector4", 12), new ze(144, "vector3", 13), new ze(156, "vector4", 14) ]);
        } ]), VertexShurikenParticleMesh;
    }(), bn = function(e) {
        function Sprite3D(e, t) {
            this._needProcessCollisions = !1, this._needProcessTriggers = !1, Sprite3D.__super.call(this), 
            void 0 === t && (t = !1), this._id = ++Sprite3D._uniqueIDCounter, this._transform = new Yt(this), 
            this._isStatic = t, this.layer = 0, this.name = e || "New Sprite3D";
        }
        r(Sprite3D, "laya.d3.core.Sprite3D", e);
        var t = Sprite3D.prototype;
        return n.imps(t, {
            "laya.resource.ICreateResource": !0
        }), t._setCreateURL = function(e) {
            this._url = w.formatURL(e);
        }, t._changeAnimatorsToLinkSprite3D = function(e, t, n) {
            var i = this.getComponent(Zt);
            if (i && (i.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(i, t, n)), this._parent && this._parent instanceof laya.d3.core.Sprite3D) {
                n.unshift(this._parent.name);
                var r = this._parent;
                r._hierarchyAnimator && r._changeAnimatorsToLinkSprite3D(e, t, n);
            }
        }, t._setHierarchyAnimator = function(e, t) {
            this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
            for (var n = 0, i = this._children.length; n < i; n++) {
                var r = this._children[n];
                r._hierarchyAnimator == t && r._setHierarchyAnimator(e, t);
            }
        }, t._clearHierarchyAnimator = function(e, t) {
            this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
            for (var n = 0, i = this._children.length; n < i; n++) {
                var r = this._children[n];
                r._hierarchyAnimator == e && r._clearHierarchyAnimator(e, t);
            }
        }, t._changeHierarchyAnimatorAvatar = function(e, t) {
            this._changeAnimatorAvatar(t);
            for (var n = 0, i = this._children.length; n < i; n++) {
                var r = this._children[n];
                r._hierarchyAnimator == e && r._changeHierarchyAnimatorAvatar(e, t);
            }
        }, t._changeAnimatorToLinkSprite3DNoAvatar = function(e, t, n) {
            e._handleSpriteOwnersBySprite(t, n, this);
            for (var i = 0, r = this._children.length; i < r; i++) {
                var a = this._children[i], o = n.length;
                n.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(e, t, n), n.splice(o, 1);
            }
        }, t._changeHierarchyAnimator = function(e) {
            this._hierarchyAnimator = e;
        }, t._changeAnimatorAvatar = function(e) {}, t._onAdded = function() {
            if (this._parent instanceof laya.d3.core.Sprite3D) {
                var t = this._parent;
                this.transform._setParent(t.transform), t._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(t._hierarchyAnimator, null), 
                t._changeAnimatorsToLinkSprite3D(this, !0, [ this.name ]));
            }
            e.prototype._onAdded.call(this);
        }, t._onRemoved = function() {
            if (e.prototype._onRemoved.call(this), this._parent instanceof laya.d3.core.Sprite3D) {
                var t = this._parent;
                this.transform._setParent(null), t._hierarchyAnimator && (this._hierarchyAnimator == t._hierarchyAnimator && this._clearHierarchyAnimator(t._hierarchyAnimator, null), 
                t._changeAnimatorsToLinkSprite3D(this, !1, [ this.name ]));
            }
        }, t._parse = function(e, t) {
            if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active), 
            null != e.name && (this.name = e.name), void 0 !== e.position) {
                var n = this.transform.localPosition;
                n.fromArray(e.position), this.transform.localPosition = n;
            }
            if (void 0 !== e.rotationEuler) {
                var i = this.transform.localRotationEuler;
                i.fromArray(e.rotationEuler), this.transform.localRotationEuler = i;
            }
            if (void 0 !== e.rotation) {
                var r = this.transform.localRotation;
                r.fromArray(e.rotation), this.transform.localRotation = r;
            }
            if (void 0 !== e.scale) {
                var a = this.transform.localScale;
                a.fromArray(e.scale), this.transform.localScale = a;
            }
            null != e.layer && (this.layer = e.layer);
        }, t._cloneTo = function(t, n, i) {
            if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
            var r = t;
            r.name = this.name, r.destroyed = this.destroyed, r.active = this.active;
            var a = r.transform.localPosition;
            this.transform.localPosition.cloneTo(a), r.transform.localPosition = a;
            var o = r.transform.localRotation;
            this.transform.localRotation.cloneTo(o), r.transform.localRotation = o;
            var s = r.transform.localScale;
            this.transform.localScale.cloneTo(s), r.transform.localScale = s, r._isStatic = this._isStatic, 
            r.layer = this.layer, e.prototype._cloneTo.call(this, r, n, i);
        }, t.clone = function() {
            var e = Sprite3D._createSprite3DInstance(this);
            return Sprite3D._parseSprite3DInstance(this, e, this, e), e;
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._transform = null, this._scripts = null, this._url && g.clearRes(this._url));
        }, a(0, t, "id", function() {
            return this._id;
        }), a(0, t, "url", function() {
            return this._url;
        }), a(0, t, "layer", function() {
            return this._layer;
        }, function(e) {
            if (this._layer !== e) {
                if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                this._layer = e;
            }
        }), a(0, t, "transform", function() {
            return this._transform;
        }), a(0, t, "isStatic", function() {
            return this._isStatic;
        }), Sprite3D._parse = function(e, t, n) {
            var i, r = e.data, a = [];
            switch (e.version) {
              case "LAYAHIERARCHY:02":
                i = ke._createNodeByJson02(r, a);
                break;

              default:
                i = ke._createNodeByJson(r, a);
            }
            return j.combine(i, a), i;
        }, Sprite3D.__init__ = function() {}, Sprite3D.instantiate = function(e, t, n, i, r) {
            void 0 === n && (n = !0);
            var a = e.clone();
            t && t.addChild(a);
            var o = a.transform;
            if (n) {
                var s = o.worldMatrix;
                e.transform.worldMatrix.cloneTo(s), o.worldMatrix = s;
            } else i && (o.position = i), r && (o.rotation = r);
            return a;
        }, Sprite3D.load = function(e, t) {
            n.loader.create(e, t, null, "HIERARCHY");
        }, Sprite3D._createSprite3DInstance = function(e) {
            for (var t = new e.constructor(), n = e._children, i = 0, r = n.length; i < r; i++) {
                var a = Sprite3D._createSprite3DInstance(n[i]);
                t.addChild(a);
            }
            return t;
        }, Sprite3D._parseSprite3DInstance = function(e, t, n, i) {
            for (var r = n._children, a = i._children, o = 0, s = r.length; o < s; o++) Sprite3D._parseSprite3DInstance(e, t, r[o], a[o]);
            n._cloneTo(i, e, t);
        }, Sprite3D._uniqueIDCounter = 0, i(Sprite3D, [ "WORLDMATRIX", function() {
            return this.WORLDMATRIX = Ve.propertyNameToID("u_WorldMat");
        }, "MVPMATRIX", function() {
            return this.MVPMATRIX = Ve.propertyNameToID("u_MvpMatrix");
        } ]), Sprite3D;
    }(y), Fn = function(e) {
        function BaseMaterial() {
            this._shaderValues = null, BaseMaterial.__super.call(this), this._defineDatas = new Ue(), 
            this._disablePublicDefineDatas = new Ue(), this._shaderValues = new ue(this), this.renderQueue = 2e3, 
            this._alphaTest = !1;
        }
        r(BaseMaterial, "laya.d3.core.material.BaseMaterial", e);
        var t = BaseMaterial.prototype;
        return n.imps(t, {
            "laya.d3.core.IClone": !0
        }), t._removeTetxureReference = function() {
            var e = this._shaderValues.getData();
            for (var t in e) {
                var n = e[t];
                n && n instanceof laya.resource.BaseTexture && n._removeReference();
            }
        }, t._addReference = function(t) {
            void 0 === t && (t = 1), e.prototype._addReference.call(this, t);
            var n = this._shaderValues.getData();
            for (var i in n) {
                var r = n[i];
                r && r instanceof laya.resource.BaseTexture && r._addReference();
            }
        }, t._removeReference = function(t) {
            void 0 === t && (t = 1), e.prototype._removeReference.call(this, t), this._removeTetxureReference();
        }, t._disposeResource = function() {
            this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
        }, t.setShaderName = function(e) {
            if (this._shader = Ve.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
        }, t.cloneTo = function(e) {
            var t = e;
            t.name = this.name, t.renderQueue = this.renderQueue, this._disablePublicDefineDatas.cloneTo(t._disablePublicDefineDatas), 
            this._defineDatas.cloneTo(t._defineDatas), this._shaderValues.cloneTo(t._shaderValues);
        }, t.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, t, "alphaTestValue", function() {
            return this._shaderValues.getNumber(BaseMaterial.ALPHATESTVALUE);
        }, function(e) {
            this._shaderValues.setNumber(BaseMaterial.ALPHATESTVALUE, e);
        }), a(0, t, "alphaTest", function() {
            return this._alphaTest;
        }, function(e) {
            this._alphaTest = e, e ? this._defineDatas.add(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST) : this._defineDatas.remove(laya.d3.core.material.BaseMaterial.SHADERDEFINE_ALPHATEST);
        }), BaseMaterial.load = function(e, t) {
            n.loader.create(e, t, null, "MATERIAL");
        }, BaseMaterial.__init__ = function() {
            BaseMaterial.SHADERDEFINE_ALPHATEST = BaseMaterial.shaderDefines.registerDefine("ALPHATEST");
        }, BaseMaterial._parse = function(e, t, n) {
            var i, r = e, a = r.props, o = a.type.split("."), s = l.window;
            if (o.forEach(function(e) {
                s = s[e];
            }), "function" != typeof s) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
            switch (i = new s(), r.version) {
              case "LAYAMATERIAL:01":
              case "LAYAMATERIAL:02":
                var h = 0, u = 0;
                for (var c in a) switch (c) {
                  case "vectors":
                    var d = a[c];
                    for (h = 0, u = d.length; h < u; h++) {
                        var _ = d[h], f = _.value;
                        switch (f.length) {
                          case 2:
                            i[_.name] = new Se(f[0], f[1]);
                            break;

                          case 3:
                            i[_.name] = new Te(f[0], f[1], f[2]);
                            break;

                          case 4:
                            i[_.name] = new me(f[0], f[1], f[2], f[3]);
                            break;

                          default:
                            throw new Error("BaseMaterial:unkonwn color length.");
                        }
                    }
                    break;

                  case "textures":
                    var m = a[c];
                    for (h = 0, u = m.length; h < u; h++) {
                        var p = m[h], T = p.path;
                        T && (i[p.name] = g.getRes(T));
                    }
                    break;

                  case "defines":
                    var S = a[c];
                    for (h = 0, u = S.length; h < u; h++) {
                        var E = i._shader.getSubShaderAt(0).getMaterialDefineByName(S[h]);
                        i._defineDatas.add(E);
                    }
                    break;

                  case "renderStates":
                    var v = a[c][0], x = i;
                    x.blend = v.blend, x.cull = v.cull, x.depthTest = v.depthTest, x.depthWrite = v.depthWrite, 
                    x.blendSrc = v.srcBlend, x.blendDst = v.dstBlend;
                    break;

                  case "cull":
                    i.cull = a[c];
                    break;

                  case "blend":
                    i.blend = a[c];
                    break;

                  case "depthWrite":
                    i.depthWrite = a[c];
                    break;

                  case "srcBlend":
                    i.blendSrc = a[c];
                    break;

                  case "dstBlend":
                    i.blendDst = a[c];
                    break;

                  default:
                    i[c] = a[c];
                }
                break;

              default:
                throw new Error("BaseMaterial:unkonwn version.");
            }
            return i;
        }, BaseMaterial.RENDERQUEUE_OPAQUE = 2e3, BaseMaterial.RENDERQUEUE_ALPHATEST = 2450, 
        BaseMaterial.RENDERQUEUE_TRANSPARENT = 3e3, BaseMaterial.SHADERDEFINE_ALPHATEST = 0, 
        i(BaseMaterial, [ "ALPHATESTVALUE", function() {
            return this.ALPHATESTVALUE = Ve.propertyNameToID("u_AlphaTestValue");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe();
        } ]), BaseMaterial;
    }(C), Un = function(e) {
        function ScreenQuad() {
            this._vertexBuffer = null, ScreenQuad.__super.call(this), this._bufferState = new Jt(), 
            this._vertexBuffer = new Qt(64, 35044, !1), this._vertexBuffer.vertexDeclaration = laya.d3.core.render.ScreenQuad._vertexDeclaration, 
            this._vertexBuffer.setData(ScreenQuad._vertices), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer), 
            this._bufferState.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength);
        }
        r(ScreenQuad, "laya.d3.core.render.ScreenQuad", e);
        var t = ScreenQuad.prototype;
        return t.render = function() {
            this._bufferState.bind(), E.instance.drawArrays(5, 0, 4), P.renderBatches++;
        }, t.destroy = function() {
            e.prototype.destroy.call(this), this._bufferState.destroy(), this._vertexBuffer.destroy(), 
            this._setGPUMemory(0);
        }, ScreenQuad.__init__ = function() {
            ScreenQuad.instance = new ScreenQuad(), ScreenQuad.instance.lock = !0;
        }, ScreenQuad.SCREENQUAD_POSITION_UV = 0, ScreenQuad.instance = null, i(ScreenQuad, [ "_vertexDeclaration", function() {
            return this._vertexDeclaration = new ft(16, [ new ze(0, "vector4", 0) ]);
        }, "_vertices", function() {
            return this._vertices = new Float32Array([ 1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1 ]);
        } ]), ScreenQuad;
    }(C), zn = function(e) {
        function Avatar() {
            this._rootNode = null, this._nativeNodeCount = 0, this._nativeCurCloneCount = 0, 
            Avatar.__super.call(this);
        }
        r(Avatar, "laya.d3.core.Avatar", C);
        var t = Avatar.prototype;
        return n.imps(t, {
            "laya.d3.core.IClone": !0
        }), t._initCloneToAnimator = function(e, t) {
            t._avatarNodeMap[e.name] = e;
            for (var n = 0, i = e.getChildCount(); n < i; n++) this._initCloneToAnimator(e.getChildByIndex(n), t);
        }, t._parseNode = function(e, t) {
            var n = e.props.name;
            t.name = n;
            var i = e.props, r = t.transform, a = r.localPosition, o = r.localRotation, s = r.localScale;
            a.fromArray(i.translate), o.fromArray(i.rotation), s.fromArray(i.scale), r.localPosition = a, 
            r.localRotation = o, r.localScale = s;
            for (var l = e.child, h = 0, u = l.length; h < u; h++) {
                var c = l[h], d = new Dt(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                t.addChild(d), R.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(c, d);
            }
        }, t._cloneDatasToAnimator = function(e) {
            var t;
            t = this._rootNode.clone();
            var n = this._rootNode.transform, i = t.transform, r = i.localPosition, a = i.localRotation, o = i.localScale;
            n.localPosition.cloneTo(r), n.localRotation.cloneTo(a), n.localScale.cloneTo(o), 
            i.localPosition = r, i.localRotation = a, i.localScale = o, e._avatarNodeMap = {}, 
            this._initCloneToAnimator(t, e);
        }, t.cloneTo = function(e) {
            var t = e, n = this._rootNode.clone();
            t._rootNode = n;
        }, t.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, t._cloneDatasToAnimatorNative = function(e) {
            var t = new Float32Array(3 * this._nativeNodeCount), n = new Float32Array(4 * this._nativeNodeCount), i = new Float32Array(3 * this._nativeNodeCount), r = new Float32Array(16 * this._nativeNodeCount), a = new Int16Array(this._nativeNodeCount);
            e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = n, e._animationNodeLocalScales = i, 
            e._animationNodeWorldMatrixs = r, e._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
            var o = this._rootNode._cloneNative(t, n, i, r, a, -1, this), s = this._rootNode.transform, l = o.transform, h = l.localPosition, u = l.localRotation, c = l.localScale;
            s.localPosition.cloneTo(h), s.localRotation.cloneTo(u), s.localScale.cloneTo(c), 
            l.localPosition = h, l.localRotation = u, l.localScale = c, e._avatarNodeMap = {}, 
            this._initCloneToAnimator(o, e);
        }, Avatar._parse = function(e, t, n) {
            var i = new Avatar();
            if (i._rootNode = new Dt(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)), 
            R.supportWebGLPlusAnimation && i._nativeNodeCount++, e.version) {
                var r = e.rootNode;
                r && i._parseNode(r, i._rootNode);
            }
            return i;
        }, Avatar.load = function(e, t) {
            n.loader.create(e, t, null, "AVATAR");
        }, Avatar;
    }(), Gn = function(e) {
        function Mesh() {
            this._nativeTriangleMesh = null, this._bounds = null, this._subMeshCount = 0, this._subMeshes = null, 
            this._vertexBuffers = null, this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null, 
            this._inverseBindPosesBuffer = null, this._bindPoseIndices = null, this._skinDataPathMarks = null, 
            this._vertexCount = 0, this._tempVector30 = new Te(), this._tempVector31 = new Te(), 
            this._tempVector32 = new Te(), this._bufferState = new Jt(), this._instanceBufferState = new Jt(), 
            Mesh.__super.call(this), this._subMeshes = [], this._vertexBuffers = [], this._skinDataPathMarks = [];
        }
        r(Mesh, "laya.d3.resource.models.Mesh", C);
        var t = Mesh.prototype;
        return n.imps(t, {
            "laya.d3.core.IClone": !0
        }), t._getPositionElement = function(e) {
            for (var t = e.vertexDeclaration.vertexElements, n = 0, i = t.length; n < i; n++) {
                var r = t[n];
                if ("vector3" === r.elementFormat && 0 === r.elementUsage) return r;
            }
            return null;
        }, t._generateBoundingObject = function() {
            var e = this._tempVector30, t = this._tempVector31;
            e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
            for (var n = this._vertexBuffers.length, i = 0; i < n; i++) for (var r = this._vertexBuffers[i], a = this._getPositionElement(r), o = r.getData(), s = r.vertexDeclaration.vertexStride / 4, l = a.offset / 4, h = 0, u = o.length; h < u; h += s) {
                var c = h + l, d = o[c], _ = o[c + 1], f = o[c + 2];
                e.x = Math.min(e.x, d), e.y = Math.min(e.y, _), e.z = Math.min(e.z, f), t.x = Math.max(t.x, d), 
                t.y = Math.max(t.y, _), t.z = Math.max(t.z, f);
            }
            this._bounds = new Mt(e, t);
        }, t._setSubMeshes = function(e) {
            this._subMeshes = e, this._subMeshCount = e.length;
            for (var t = 0; t < this._subMeshCount; t++) e[t]._indexInMesh = t;
            this._generateBoundingObject();
        }, t._getSubMesh = function(e) {
            return this._subMeshes[e];
        }, t._setBuffer = function(e, t) {
            var n = this._bufferState;
            n.bind(), n.applyVertexBuffers(e), n.applyIndexBuffer(t), n.unBind();
            var i = this._instanceBufferState;
            i.bind(), i.applyVertexBuffers(e), i.applyInstanceVertexBuffer(Sn.instance.instanceWorldMatrixBuffer), 
            i.applyInstanceVertexBuffer(Sn.instance.instanceMVPMatrixBuffer), i.applyIndexBuffer(t), 
            i.unBind();
        }, t._disposeResource = function() {
            for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e].destroy();
            for (this._nativeTriangleMesh && X._physics3D.destroy(this._nativeTriangleMesh), 
            e = 0, t = this._vertexBuffers.length; e < t; e++) this._vertexBuffers[e].destroy();
            this._indexBuffer.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), this._bufferState.destroy(), 
            this._instanceBufferState.destroy(), this._bufferState = null, this._instanceBufferState = null, 
            this._vertexBuffers = null, this._indexBuffer = null, this._subMeshes = null, this._nativeTriangleMesh = null, 
            this._vertexBuffers = null, this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null;
        }, t._getPhysicMesh = function() {
            if (!this._nativeTriangleMesh) {
                for (var e = new X._physics3D.btTriangleMesh(), t = Mesh._nativeTempVector30, n = Mesh._nativeTempVector31, i = Mesh._nativeTempVector32, r = this._tempVector30, a = this._tempVector31, o = this._tempVector32, s = this._vertexBuffers[0], l = this._getPositionElement(s), h = s.getData(), u = s.vertexDeclaration.vertexStride / 4, c = l.offset / 4, d = this._indexBuffer.getData(), _ = 0, f = d.length; _ < f; _ += 3) {
                    var m = d[_] * u + c, p = d[_ + 1] * u + c, T = d[_ + 2] * u + c;
                    r.setValue(h[m], h[m + 1], h[m + 2]), a.setValue(h[p], h[p + 1], h[p + 2]), o.setValue(h[T], h[T + 1], h[T + 2]), 
                    ke._convertToBulletVec3(r, t, !0), ke._convertToBulletVec3(a, n, !0), ke._convertToBulletVec3(o, i, !0), 
                    e.addTriangle(t, n, i, !0);
                }
                this._nativeTriangleMesh = e;
            }
            return this._nativeTriangleMesh;
        }, t.cloneTo = function(e) {
            for (var t = e, n = 0; n < this._vertexBuffers.length; n++) {
                var i = this._vertexBuffers[n], r = new Qt(i._byteLength, i.bufferUsage, i.canRead);
                r.vertexDeclaration = i.vertexDeclaration, r.setData(i.getData().slice()), t._vertexBuffers.push(r), 
                t._vertexCount += r.vertexCount;
            }
            var a = this._indexBuffer, s = new jt("ushort", a.indexCount, a.bufferUsage, a.canRead);
            s.setData(a.getData().slice()), t._indexBuffer = s, t._setBuffer(t._vertexBuffers, s), 
            t._setCPUMemory(this.cpuMemory), t._setGPUMemory(this.gpuMemory);
            var l = this._boneNames, h = t._boneNames = o(l.length);
            for (n = 0; n < l.length; n++) h[n] = l[n];
            var u = this._inverseBindPoses, c = t._inverseBindPoses = o(u.length);
            for (n = 0; n < u.length; n++) c[n] = u[n];
            for (t._bindPoseIndices = new Uint16Array(this._bindPoseIndices), n = 0; n < this._skinDataPathMarks.length; n++) t._skinDataPathMarks[n] = this._skinDataPathMarks[n].slice();
            for (n = 0; n < this.subMeshCount; n++) {
                var d = this._subMeshes[n], _ = d._subIndexBufferStart, f = d._subIndexBufferCount, m = d._boneIndicesList, p = new on(t);
                p._subIndexBufferStart.length = _.length, p._subIndexBufferCount.length = f.length, 
                p._boneIndicesList.length = m.length;
                for (var T = 0; T < _.length; T++) p._subIndexBufferStart[T] = _[T];
                for (T = 0; T < f.length; T++) p._subIndexBufferCount[T] = f[T];
                for (T = 0; T < m.length; T++) p._boneIndicesList[T] = new Uint16Array(m[T]);
                p._indexBuffer = s, p._indexStart = d._indexStart, p._indexCount = d._indexCount, 
                p._indices = new Uint16Array(s.getData().buffer, 2 * d._indexStart, d._indexCount);
                var S = t._vertexBuffers[0];
                p._vertexBuffer = S, t._subMeshes.push(p);
            }
            t._setSubMeshes(t._subMeshes);
        }, t.clone = function() {
            var e = new this.constructor();
            return this.cloneTo(e), e;
        }, a(0, t, "inverseAbsoluteBindPoses", function() {
            return this._inverseBindPoses;
        }), a(0, t, "vertexCount", function() {
            return this._vertexCount;
        }), a(0, t, "subMeshCount", function() {
            return this._subMeshCount;
        }), a(0, t, "bounds", function() {
            return this._bounds;
        }), Mesh._parse = function(e, t, n) {
            var i = new Mesh();
            return ge.read(e, i, i._subMeshes), i;
        }, Mesh.load = function(e, t) {
            n.loader.create(e, t, null, "MESH");
        }, i(Mesh, [ "_nativeTempVector30", function() {
            return this._nativeTempVector30 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeTempVector31", function() {
            return this._nativeTempVector31 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeTempVector32", function() {
            return this._nativeTempVector32 = new X._physics3D.btVector3(0, 0, 0);
        } ]), Mesh;
    }(), Hn = function(e) {
        function TerrainHeightData(e, t, n, i) {
            this._terrainHeightData = null, this._width = 0, this._height = 0, this._bitType = 0, 
            this._value = NaN, TerrainHeightData.__super.call(this), this._width = e, this._height = t, 
            this._bitType = n, this._value = i;
        }
        return r(TerrainHeightData, "laya.d3.terrain.TerrainHeightData", C), TerrainHeightData._pharse = function(e, t, n) {
            var i, r = new TerrainHeightData(n[0], n[1], n[2], n[3]), a = NaN;
            8 == r._bitType ? (i = new Uint8Array(e), a = 1 / 255) : 16 == r._bitType && (i = new Int16Array(e), 
            a = 1 / 32766), r._terrainHeightData = new Float32Array(r._height * r._width);
            for (var o = 0, s = r._height * r._width; o < s; o++) r._terrainHeightData[o] = i[o] * a * r._value / 2;
        }, TerrainHeightData.load = function(e, t, i, r, a, o) {
            n.loader.create(e, t, null, "TERRAINHEIGHTDATA", [ i, r, a, o ], null, 1, !1);
        }, TerrainHeightData;
    }(), kn = function(e) {
        function AnimationClip() {
            AnimationClip.__super.call(this), this._nodes = new qe(), this._events = [];
        }
        r(AnimationClip, "laya.d3.animation.AnimationClip", C);
        var t = AnimationClip.prototype;
        return t.duration = function() {
            return this._duration;
        }, t._hermiteInterpolate = function(e, t, n, i) {
            var r = e.outTangent, a = t.inTangent;
            if (Number.isFinite(r) && Number.isFinite(a)) {
                var o = n * n, s = o * n, l = s - 2 * o + n, h = s - o, u = -2 * s + 3 * o;
                return (2 * s - 3 * o + 1) * e.value + l * r * i + h * a * i + u * t.value;
            }
            return e.value;
        }, t._hermiteInterpolateVector3 = function(e, t, n, i, r) {
            var a = e.value, o = e.outTangent, s = t.value, l = t.inTangent, h = n * n, u = h * n, c = 2 * u - 3 * h + 1, d = u - 2 * h + n, _ = u - h, f = -2 * u + 3 * h, m = o.x, p = l.x;
            Number.isFinite(m) && Number.isFinite(p) ? r.x = c * a.x + d * m * i + _ * p * i + f * s.x : r.x = a.x, 
            m = o.y, p = l.y, Number.isFinite(m) && Number.isFinite(p) ? r.y = c * a.y + d * m * i + _ * p * i + f * s.y : r.y = a.y, 
            m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? r.z = c * a.z + d * m * i + _ * p * i + f * s.z : r.z = a.z;
        }, t._hermiteInterpolateQuaternion = function(e, t, n, i, r) {
            var a = e.value, o = e.outTangent, s = t.value, l = t.inTangent, h = n * n, u = h * n, c = 2 * u - 3 * h + 1, d = u - 2 * h + n, _ = u - h, f = -2 * u + 3 * h, m = o.x, p = l.x;
            Number.isFinite(m) && Number.isFinite(p) ? r.x = c * a.x + d * m * i + _ * p * i + f * s.x : r.x = a.x, 
            m = o.y, p = l.y, Number.isFinite(m) && Number.isFinite(p) ? r.y = c * a.y + d * m * i + _ * p * i + f * s.y : r.y = a.y, 
            m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? r.z = c * a.z + d * m * i + _ * p * i + f * s.z : r.z = a.z, 
            m = o.w, p = l.w, Number.isFinite(m) && Number.isFinite(p) ? r.w = c * a.w + d * m * i + _ * p * i + f * s.w : r.w = a.w;
        }, t._evaluateClipDatasRealTime = function(e, t, n, i, r) {
            for (var a = 0, o = e.count; a < o; a++) {
                var s = e.getNodeByIndex(a), l = s.type, h = 0, u = s._keyFrames, c = u.length, d = n[a];
                if (r) for (-1 !== d && t < u[d].time && (d = -1, n[a] = d), h = d + 1; h < c && !(u[h].time > t); ) d++, 
                h++, n[a] = d; else for ((h = d + 1) !== c && t > u[h].time && (d = c - 1, n[a] = d), 
                h = d + 1; d > -1 && !(u[d].time < t); ) d--, h--, n[a] = d;
                var _ = h === c;
                switch (l) {
                  case 0:
                    if (-1 !== d) {
                        var f = u[d];
                        if (_) s.data = f.value; else {
                            var m = u[h], p = m.time - f.time, T = NaN;
                            T = 0 !== p ? (t - f.time) / p : 0, s.data = this._hermiteInterpolate(f, m, T, p);
                        }
                    } else s.data = u[0].value;
                    i && (s.data -= u[0].value);
                    break;

                  case 1:
                  case 4:
                    var S = s.data;
                    if (this._evaluateFrameNodeVector3DatasRealTime(u, d, _, t, S), i) {
                        var E = u[0].value;
                        S.x -= E.x, S.y -= E.y, S.z -= E.z;
                    }
                    break;

                  case 2:
                    var v = s.data;
                    if (this._evaluateFrameNodeQuaternionDatasRealTime(u, d, _, t, v), i) {
                        var g = AnimationClip._tempQuaternion0, x = u[0].value;
                        ke.quaternionConjugate(x, g), he.multiply(g, v, v);
                    }
                    break;

                  case 3:
                    S = s.data, this._evaluateFrameNodeVector3DatasRealTime(u, d, _, t, S), i && (E = u[0].value, 
                    S.x /= E.x, S.y /= E.y, S.z /= E.z);
                    break;

                  default:
                    throw "AnimationClip:unknown node type.";
                }
            }
        }, t._evaluateClipDatasRealTimeForNative = function(e, t, n, i) {
            E.instance.evaluateClipDatasRealTime(e._nativeObj, t, n, i);
        }, t._evaluateFrameNodeVector3DatasRealTime = function(e, t, n, i, r) {
            if (-1 !== t) {
                var a = e[t];
                if (n) {
                    var o = a.value;
                    r.x = o.x, r.y = o.y, r.z = o.z;
                } else {
                    var s = e[t + 1], l = NaN, h = a.time, u = s.time - h;
                    l = 0 !== u ? (i - h) / u : 0, this._hermiteInterpolateVector3(a, s, l, u, r);
                }
            } else {
                var c = e[0].value;
                r.x = c.x, r.y = c.y, r.z = c.z;
            }
        }, t._evaluateFrameNodeQuaternionDatasRealTime = function(e, t, n, i, r) {
            if (-1 !== t) {
                var a = e[t];
                if (n) {
                    var o = a.value;
                    r.x = o.x, r.y = o.y, r.z = o.z, r.w = o.w;
                } else {
                    var s = e[t + 1], l = NaN, h = a.time, u = s.time - h;
                    l = 0 !== u ? (i - h) / u : 0, this._hermiteInterpolateQuaternion(a, s, l, u, r);
                }
            } else {
                var c = e[0].value;
                r.x = c.x, r.y = c.y, r.z = c.z, r.w = c.w;
            }
        }, t._binarySearchEventIndex = function(e) {
            for (var t = 0, n = this._events.length - 1, i = 0; t <= n; ) {
                i = Math.floor((t + n) / 2);
                var r = this._events[i].time;
                if (r == e) return i;
                r > e ? n = i - 1 : t = i + 1;
            }
            return t;
        }, t.addEvent = function(e) {
            var t = this._binarySearchEventIndex(e.time);
            this._events.splice(t, 0, e);
        }, t._disposeResource = function() {
            this._nodes = null, this._nodesMap = null;
        }, AnimationClip._parse = function(e, t, n) {
            var i = new AnimationClip(), r = new c(e), a = r.readUTFString();
            switch (a) {
              case "LAYAANIMATION:03":
                Fe.parse(i, r);
                break;

              case "LAYAANIMATION:04":
              case "LAYAANIMATION:COMPRESSION_04":
                be.parse(i, r, a);
                break;

              default:
                throw "unknown animationClip version.";
            }
            return i;
        }, AnimationClip.load = function(e, t) {
            n.loader.create(e, t, null, "ANIMATIONCLIP");
        }, i(AnimationClip, [ "_tempQuaternion0", function() {
            return this._tempQuaternion0 = new he();
        } ]), AnimationClip;
    }(), Wn = function(e) {
        function ShaderInstance(e, t, n, i, r) {
            this._stateParamsMap = [], this._uploadMark = -1, this._uploadRenderType = -1, ShaderInstance.__super.call(this), 
            this._vs = e, this._ps = t, this._attributeMap = n, this._uniformMap = i, this._shaderPass = r, 
            this._create(), this.lock = !0;
        }
        r(ShaderInstance, "laya.d3.shader.ShaderInstance", C);
        var t = ShaderInstance.prototype;
        return t._create = function() {
            var e = E.instance;
            for (var t in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, 35633), 
            this._pshader = this._createShader(e, this._ps, 35632), e.attachShader(this._program, this._vshader), 
            e.attachShader(this._program, this._pshader), this._attributeMap) e.bindAttribLocation(this._program, this._attributeMap[t], t);
            if (e.linkProgram(this._program), !R.isConchApp && Ve.debugMode && !e.getProgramParameter(this._program, 35714)) throw e.getProgramInfoLog(this._program);
            var n = [], i = [], r = [], a = [], o = [];
            this._customUniformParamsMap = [];
            var s = e.getProgramParameter(this._program, 35718);
            F.useProgram(e, this._program), this._curActTexIndex = 0;
            var l, h = 0, u = 0;
            for (h = 0; h < s; h++) {
                var c = e.getActiveUniform(this._program, h), d = c.name;
                (l = new vt()).location = e.getUniformLocation(this._program, d), d.indexOf("[0]") > 0 ? (l.name = d = d.substr(0, d.length - 3), 
                l.isArray = !0) : (l.name = d, l.isArray = !1), l.type = c.type, this._addShaderUnifiormFun(l);
                var _ = this._uniformMap[d];
                if (null != _) switch (l.dataOffset = Ve.propertyNameToID(d), _) {
                  case 0:
                    o.push(l);
                    break;

                  case 1:
                    a.push(l);
                    break;

                  case 2:
                    r.push(l);
                    break;

                  case 3:
                    i.push(l);
                    break;

                  case 4:
                    n.push(l);
                    break;

                  default:
                    throw new Error("Shader3D: period is unkonw.");
                }
            }
            for (this._sceneUniformParamsMap = E.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0), 
            h = 0, u = n.length; h < u; h++) this._sceneUniformParamsMap.addShaderUniform(n[h]);
            for (this._cameraUniformParamsMap = E.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0), 
            h = 0, u = i.length; h < u; h++) this._cameraUniformParamsMap.addShaderUniform(i[h]);
            for (this._spriteUniformParamsMap = E.instance.createCommandEncoder(4 * r.length * 5 + 4, 64, !0), 
            h = 0, u = r.length; h < u; h++) this._spriteUniformParamsMap.addShaderUniform(r[h]);
            for (this._materialUniformParamsMap = E.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0), 
            h = 0, u = a.length; h < u; h++) this._materialUniformParamsMap.addShaderUniform(a[h]);
            for (this._customUniformParamsMap.length = o.length, h = 0, u = o.length; h < u; h++) {
                var f = o[h];
                this._customUniformParamsMap[f.dataOffset] = f;
            }
            var m = this._shaderPass._stateMap;
            for (var p in m) this._stateParamsMap[m[p]] = Ve.propertyNameToID(p);
        }, t._getRenderState = function(e, t) {
            var n = this._stateParamsMap[t];
            return null == n ? null : e[n];
        }, t._disposeResource = function() {
            E.instance.deleteShader(this._vshader), E.instance.deleteShader(this._pshader), 
            E.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null, 
            this._setGPUMemory(0), this._curActTexIndex = 0;
        }, t._addShaderUnifiormFun = function(e) {
            var t = E.instance;
            e.caller = this;
            var n = e.isArray;
            switch (e.type) {
              case 35670:
                e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                break;

              case 5124:
                e.fun = n ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                break;

              case 5126:
                e.fun = n ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                break;

              case 35664:
                e.fun = n ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                break;

              case 35665:
                e.fun = n ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                break;

              case 35666:
                e.fun = n ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                break;

              case 35674:
                e.fun = this._uniformMatrix2fv;
                break;

              case 35675:
                e.fun = this._uniformMatrix3fv;
                break;

              case 35676:
                e.fun = n ? this._uniformMatrix4fv : this._uniformMatrix4f;
                break;

              case 35678:
                t.uniform1i(e.location, this._curActTexIndex), e.textureID = F._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_sampler2D;
                break;

              case 35679:
                t.uniform1i(e.location, this._curActTexIndex), e.textureID = F._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_sampler3D;
                break;

              case 35680:
                t.uniform1i(e.location, this._curActTexIndex), e.textureID = F._glTextureIDs[this._curActTexIndex++], 
                e.fun = this._uniform_samplerCube;
                break;

              default:
                throw new Error("compile shader err!");
            }
        }, t._createShader = function(e, t, n) {
            var i = e.createShader(n);
            if (e.shaderSource(i, t), e.compileShader(i), Ve.debugMode && !e.getShaderParameter(i, 35713)) throw e.getShaderInfoLog(i);
            return i;
        }, t._uniform1f = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t ? (E.instance.uniform1f(e.location, n[0] = t), 1) : 0;
        }, t._uniform1fv = function(e, t) {
            if (t.length < 4) {
                var n = e.uploadedValue;
                return n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] ? (E.instance.uniform1fv(e.location, t), 
                n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], 1) : 0;
            }
            return E.instance.uniform1fv(e.location, t), 1;
        }, t._uniform_vec2 = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t.x || n[1] !== t.y ? (E.instance.uniform2f(e.location, n[0] = t.x, n[1] = t.y), 
            1) : 0;
        }, t._uniform_vec2v = function(e, t) {
            if (t.length < 2) {
                var n = e.uploadedValue;
                return n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] ? (E.instance.uniform2fv(e.location, t), 
                n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3], 1) : 0;
            }
            return E.instance.uniform2fv(e.location, t), 1;
        }, t._uniform_vec3 = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t.x || n[1] !== t.y || n[2] !== t.z ? (E.instance.uniform3f(e.location, n[0] = t.x, n[1] = t.y, n[2] = t.z), 
            1) : 0;
        }, t._uniform_vec3v = function(e, t) {
            return E.instance.uniform3fv(e.location, t), 1;
        }, t._uniform_vec4 = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t.x || n[1] !== t.y || n[2] !== t.z || n[3] !== t.w ? (E.instance.uniform4f(e.location, n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w), 
            1) : 0;
        }, t._uniform_vec4v = function(e, t) {
            return E.instance.uniform4fv(e.location, t), 1;
        }, t._uniformMatrix2fv = function(e, t) {
            return E.instance.uniformMatrix2fv(e.location, !1, t), 1;
        }, t._uniformMatrix3fv = function(e, t) {
            return E.instance.uniformMatrix3fv(e.location, !1, t), 1;
        }, t._uniformMatrix4f = function(e, t) {
            var n = t.elements;
            return E.instance.uniformMatrix4fv(e.location, !1, n), 1;
        }, t._uniformMatrix4fv = function(e, t) {
            return E.instance.uniformMatrix4fv(e.location, !1, t), 1;
        }, t._uniform1i = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t ? (E.instance.uniform1i(e.location, n[0] = t), 1) : 0;
        }, t._uniform1iv = function(e, t) {
            return E.instance.uniform1iv(e.location, t), 1;
        }, t._uniform_ivec2 = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t[0] || n[1] !== t[1] ? (E.instance.uniform2i(e.location, n[0] = t[0], n[1] = t[1]), 
            1) : 0;
        }, t._uniform_ivec2v = function(e, t) {
            return E.instance.uniform2iv(e.location, t), 1;
        }, t._uniform_vec3i = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] ? (E.instance.uniform3i(e.location, n[0] = t[0], n[1] = t[1], n[2] = t[2]), 
            1) : 0;
        }, t._uniform_vec3vi = function(e, t) {
            return E.instance.uniform3iv(e.location, t), 1;
        }, t._uniform_vec4i = function(e, t) {
            var n = e.uploadedValue;
            return n[0] !== t[0] || n[1] !== t[1] || n[2] !== t[2] || n[3] !== t[3] ? (E.instance.uniform4i(e.location, n[0] = t[0], n[1] = t[1], n[2] = t[2], n[3] = t[3]), 
            1) : 0;
        }, t._uniform_vec4vi = function(e, t) {
            return E.instance.uniform4iv(e.location, t), 1;
        }, t._uniform_sampler2D = function(e, t) {
            var n = t._getSource() || t.defaulteTexture._getSource(), i = E.instance;
            return F.activeTexture(i, e.textureID), F.bindTexture(i, 3553, n), 0;
        }, t._uniform_sampler3D = function(e, t) {
            var n = t._getSource() || t.defaulteTexture._getSource(), i = E.instance;
            return F.activeTexture(i, e.textureID), F.bindTexture(i, 32879, n), 0;
        }, t._uniform_samplerCube = function(e, t) {
            var n = t._getSource() || t.defaulteTexture._getSource(), i = E.instance;
            return F.activeTexture(i, e.textureID), F.bindTexture(i, 34067, n), 0;
        }, t.bind = function() {
            return F.useProgram(E.instance, this._program);
        }, t.uploadUniforms = function(e, t, n) {
            P.shaderCall += v.uploadShaderUniforms(E.instance, e, t, n);
        }, t.uploadRenderStateBlendDepth = function(e) {
            var t = E.instance, n = this._shaderPass.renderState, i = e.getData(), r = this._getRenderState(i, 13), a = this._getRenderState(i, 12), o = this._getRenderState(i, 1);
            switch (null == r && (r = n.depthWrite), null == a && (a = n.depthTest), null == o && (o = n.blend), 
            F.setDepthMask(t, r), 0 === a ? F.setDepthTest(t, !1) : (F.setDepthTest(t, !0), 
            F.setDepthFunc(t, a)), o) {
              case 0:
                F.setBlend(t, !1);
                break;

              case 1:
                F.setBlend(t, !0);
                var s = this._getRenderState(i, 2);
                null == s && (s = n.srcBlend);
                var l = this._getRenderState(i, 3);
                null == l && (l = n.dstBlend), F.setBlendFunc(t, s, l);
                break;

              case 2:
                F.setBlend(t, !0);
                var h = this._getRenderState(i, 4);
                null == h && (h = n.srcBlendRGB);
                var u = this._getRenderState(i, 5);
                null == u && (u = n.dstBlendRGB);
                var c = this._getRenderState(i, 6);
                null == c && (c = n.srcBlendAlpha);
                var d = this._getRenderState(i, 7);
                null == d && (d = n.dstBlendAlpha), F.setBlendFuncSeperate(t, h, u, c, d);
            }
        }, t.uploadRenderStateFrontFace = function(e, t, n) {
            var i = E.instance, r = this._shaderPass.renderState, a = e.getData(), o = this._getRenderState(a, 0);
            null == o && (o = r.cull);
            var s = 0;
            switch (o) {
              case 0:
                F.setCullFace(i, !1);
                break;

              case 1:
                F.setCullFace(i, !0), s = t ? n && n._isFrontFaceInvert ? 2305 : 2304 : n && n._isFrontFaceInvert ? 2304 : 2305, 
                F.setFrontFace(i, s);
                break;

              case 2:
                F.setCullFace(i, !0), s = t ? n && n._isFrontFaceInvert ? 2304 : 2305 : n && n._isFrontFaceInvert ? 2305 : 2304, 
                F.setFrontFace(i, s);
            }
        }, t.uploadCustomUniform = function(e, t) {
            P.shaderCall += v.uploadCustomUniform(E.instance, this._customUniformParamsMap, e, t);
        }, t._uniformMatrix2fvForNative = function(e, t) {
            return E.instance.uniformMatrix2fvEx(e.location, !1, t), 1;
        }, t._uniformMatrix3fvForNative = function(e, t) {
            return E.instance.uniformMatrix3fvEx(e.location, !1, t), 1;
        }, t._uniformMatrix4fvForNative = function(e, t) {
            return E.instance.uniformMatrix4fvEx(e.location, !1, t), 1;
        }, ShaderInstance;
    }(), Xn = (function(e) {
        function TerrainRes() {
            this._version = NaN, this._cameraCoordinateInverse = !1, this._gridSize = NaN, this._chunkNumX = 0, 
            this._chunkNumZ = 0, this._heightDataX = 0, this._heightDataZ = 0, this._heightDataBitType = 0, 
            this._heightDataValue = NaN, this._heightDataUrl = null, this._detailTextureInfos = null, 
            this._chunkInfos = null, this._heightData = null, this._materialInfo = null, this._alphaMaps = null, 
            this._normalMaps = null, TerrainRes.__super.call(this);
        }
        r(TerrainRes, "laya.d3.terrain.TerrainRes", C);
        var t = TerrainRes.prototype;
        t.parseData = function(e) {
            var t = e[0], n = e[1];
            if (this._version = t.version, 1 == this._version) {
                this._cameraCoordinateInverse = t.cameraCoordinateInverse, this._gridSize = t.gridSize, 
                this._chunkNumX = t.chunkNumX, this._chunkNumZ = t.chunkNumZ;
                var i = t.heightData;
                if (this._heightDataX = i.numX, this._heightDataZ = i.numZ, this._heightDataBitType = i.bitType, 
                this._heightDataValue = i.value, this._heightDataUrl = n[i.url], this._materialInfo = new se(), 
                t.material) {
                    var r = t.material.ambient, a = t.material.diffuse, s = t.material.specular;
                    this._materialInfo.ambientColor = new Te(r[0], r[1], r[2]), this._materialInfo.diffuseColor = new Te(a[0], a[1], a[2]), 
                    this._materialInfo.specularColor = new me(s[0], s[1], s[2], s[3]);
                }
                var l = t.detailTexture;
                this._detailTextureInfos = o(l.length);
                for (var h = 0; h < l.length; h++) {
                    var u = l[h], c = new It();
                    c.diffuseTexture = n[u.diffuse], c.normalTexture = u.normal ? n[u.normal] : null, 
                    u.scale ? c.scale = new Se(u.scale[0], u.scale[1]) : c.scale = new Se(1, 1), u.offset ? c.offset = new Se(u.offset[0], u.offset[1]) : c.offset = new Se(0, 0), 
                    this._detailTextureInfos[h] = c;
                }
                var d = t.alphaMap;
                for (this._alphaMaps = o(d.length), h = 0; h < this._alphaMaps.length; h++) this._alphaMaps[h] = t.alphaMap[h];
                var _ = t.normalMap;
                for (this._normalMaps = o(_.length), h = 0; h < this._normalMaps.length; h++) this._normalMaps[h] = t.normalMap[h];
                var f = t.chunkInfo;
                if (this._chunkNumX * this._chunkNumZ != f.length) return alert("terrain data error"), 
                !1;
                for (this._chunkInfos = o(f.length), h = 0; h < f.length; h++) {
                    var m = f[h], p = new Et(), T = m.alphaMap.length, S = m.detailID.length;
                    if (T != S) return alert("terrain chunk data error"), !1;
                    p.alphaMap = o(T), p.detailID = o(S), p.normalMap = n[this._normalMaps[m.normalMap]];
                    for (var E = 0; E < T; E++) {
                        p.alphaMap[E] = n[this._alphaMaps[m.alphaMap[E]]];
                        var v = m.detailID[E], x = v.length;
                        p.detailID[E] = new Uint8Array(x);
                        for (var M = 0; M < x; M++) p.detailID[E][M] = v[M];
                    }
                    this._chunkInfos[h] = p;
                }
                this._heightData = g.getRes(this._heightDataUrl), this.onLoadTerrainComplete(this._heightData);
            }
            return !0;
        }, t.onLoadTerrainComplete = function(e) {}, TerrainRes._parse = function(e, t, n) {
            var i = new TerrainRes();
            return i.parseData(e), i;
        }, TerrainRes.load = function(e, t) {
            n.loader.create(e, t, null, "TERRAIN", null, null, 1, !1);
        };
    }(), function(e) {
        function ShurikenParticleRenderer(e) {
            this._finalGravity = new Te(), this._tempRotationMatrix = new Ht(), ShurikenParticleRenderer.__super.call(this, e), 
            this._defaultBoundBox = new zt(new Te(), new Te()), this._renderMode = -1, this.stretchedBillboardCameraSpeedScale = 0, 
            this.stretchedBillboardSpeedScale = 0, this.stretchedBillboardLengthScale = 1;
        }
        r(ShurikenParticleRenderer, "laya.d3.core.particleShuriKen.ShurikenParticleRenderer", e);
        var t = ShurikenParticleRenderer.prototype;
        return t._calculateBoundingBox = function() {
            var e = this._bounds.getMin();
            e.x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE, e.z = -Number.MAX_VALUE, this._bounds.setMin(e);
            var t = this._bounds.getMax();
            if (t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE, t.z = Number.MAX_VALUE, this._bounds.setMax(t), 
            R.supportWebGLPlusCulling) {
                e = this._bounds.getMin(), t = this._bounds.getMax();
                var n = Bt._cullingBuffer;
                n[this._cullingBufferIndex + 1] = e.x, n[this._cullingBufferIndex + 2] = e.y, n[this._cullingBufferIndex + 3] = e.z, 
                n[this._cullingBufferIndex + 4] = t.x, n[this._cullingBufferIndex + 5] = t.y, n[this._cullingBufferIndex + 6] = t.z;
            }
        }, t._needRender = function(e) {
            return !e || 0 !== e.containsBoundBox(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
        }, t._renderUpdate = function(e, t) {
            var n = this._owner.particleSystem, i = this._shaderValues, r = this._owner.transform;
            switch (n.simulationSpace) {
              case 0:
                break;

              case 1:
                i.setVector3(xi.WORLDPOSITION, r.position), i.setQuaternion(xi.WORLDROTATION, r.rotation);
                break;

              default:
                throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
            switch (n.scaleMode) {
              case 0:
                var a = r.scale;
                i.setVector3(xi.POSITIONSCALE, a), i.setVector3(xi.SIZESCALE, a);
                break;

              case 1:
                var o = r.localScale;
                i.setVector3(xi.POSITIONSCALE, o), i.setVector3(xi.SIZESCALE, o);
                break;

              case 2:
                i.setVector3(xi.POSITIONSCALE, r.scale), i.setVector3(xi.SIZESCALE, Te._ONE);
            }
            Te.scale(Ut.gravity, n.gravityModifier, this._finalGravity), i.setVector3(xi.GRAVITY, this._finalGravity), 
            i.setInt(xi.SIMULATIONSPACE, n.simulationSpace), i.setBool(xi.THREEDSTARTROTATION, n.threeDStartRotation), 
            i.setInt(xi.SCALINGMODE, n.scaleMode), i.setNumber(xi.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale), 
            i.setNumber(xi.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale), 
            i.setNumber(xi.CURRENTTIME, n._currentTime);
        }, t._destroy = function() {
            e.prototype._destroy.call(this), this._mesh && (this._mesh._removeReference(), this._mesh = null);
        }, a(0, t, "renderMode", function() {
            return this._renderMode;
        }, function(e) {
            if (this._renderMode !== e) {
                var t = this._defineDatas;
                switch (this._renderMode) {
                  case 0:
                    t.remove(xi.SHADERDEFINE_RENDERMODE_BILLBOARD);
                    break;

                  case 1:
                    t.remove(xi.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                    break;

                  case 2:
                    t.remove(xi.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                    break;

                  case 3:
                    t.remove(xi.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                    break;

                  case 4:
                    t.remove(xi.SHADERDEFINE_RENDERMODE_MESH);
                }
                switch (this._renderMode = e, e) {
                  case 0:
                    t.add(xi.SHADERDEFINE_RENDERMODE_BILLBOARD);
                    break;

                  case 1:
                    t.add(xi.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                    break;

                  case 2:
                    t.add(xi.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                    break;

                  case 3:
                    t.add(xi.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                    break;

                  case 4:
                    t.add(xi.SHADERDEFINE_RENDERMODE_MESH);
                    break;

                  default:
                    throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                }
                this._owner.particleSystem._initBufferDatas();
            }
        }), a(0, t, "mesh", function() {
            return this._mesh;
        }, function(e) {
            this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e, 
            e && e._addReference(), this._owner.particleSystem._initBufferDatas());
        }), a(0, t, "bounds", function() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1), 
            this._bounds;
        }), ShurikenParticleRenderer;
    }(Xt)), Yn = function(e) {
        function PhysicsTriggerComponent(e, t) {
            this._isTrigger = !1, PhysicsTriggerComponent.__super.call(this, e, t);
        }
        r(PhysicsTriggerComponent, "laya.d3.physics.PhysicsTriggerComponent", e);
        var t = PhysicsTriggerComponent.prototype;
        return t._onAdded = function() {
            e.prototype._onAdded.call(this), this.isTrigger = this._isTrigger;
        }, t._cloneTo = function(t) {
            e.prototype._cloneTo.call(this, t), t.isTrigger = this._isTrigger;
        }, a(0, t, "isTrigger", function() {
            return this._isTrigger;
        }, function(e) {
            if (this._isTrigger = e, this._nativeColliderObject) {
                var t = this._nativeColliderObject.getCollisionFlags();
                e ? 0 == (4 & t) && this._nativeColliderObject.setCollisionFlags(4 | t) : 0 != (4 & t) && this._nativeColliderObject.setCollisionFlags(4 ^ t);
            }
        }), PhysicsTriggerComponent;
    }(Wt), Zn = (function(e) {
        function CharacterController(e, t, n, i) {
            this._maxSlope = 45, this._jumpSpeed = 10, this._fallSpeed = 55, this._upAxis = new Te(0, 1, 0), 
            this._gravity = new Te(0, 3 * -9.8, 0), void 0 === e && (e = .1), void 0 === n && (n = 1), 
            void 0 === i && (i = Ut.COLLISIONFILTERGROUP_ALLFILTER), this._stepHeight = e, t && (this._upAxis = t), 
            CharacterController.__super.call(this, n, i);
        }
        r(CharacterController, "laya.d3.physics.CharacterController", e);
        var t = CharacterController.prototype;
        t._constructCharacter = function() {
            var e = X._physics3D;
            this._nativeKinematicCharacter && e.destroy(this._nativeKinematicCharacter);
            var t = CharacterController._nativeTempVector30;
            t.setValue(this._upAxis.x, this._upAxis.y, this._upAxis.z), this._nativeKinematicCharacter = new e.btKinematicCharacterController(this._nativeColliderObject, this._colliderShape._nativeShape, this._stepHeight, t), 
            this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed, 
            this.gravity = this._gravity;
        }, t._onShapeChange = function(t) {
            e.prototype._onShapeChange.call(this, t), this._constructCharacter();
        }, t._onAdded = function() {
            var t = new X._physics3D.btPairCachingGhostObject();
            t.setUserIndex(this.id), t.setCollisionFlags(16), this._nativeColliderObject = t, 
            this._colliderShape && this._constructCharacter(), e.prototype._onAdded.call(this);
        }, t._addToSimulation = function() {
            this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
        }, t._removeFromSimulation = function() {
            this._simulation._removeCharacter(this);
            var e = this._simulation._characters;
            e.splice(e.indexOf(this), 1);
        }, t._cloneTo = function(t) {
            e.prototype._cloneTo.call(this, t);
            var n = t;
            n.stepHeight = this._stepHeight, n.upAxis = this._upAxis, n.maxSlope = this._maxSlope, 
            n.jumpSpeed = this._jumpSpeed, n.fallSpeed = this._fallSpeed, n.gravity = this._gravity;
        }, t._onDestroy = function() {
            X._physics3D.destroy(this._nativeKinematicCharacter), e.prototype._onDestroy.call(this), 
            this._nativeKinematicCharacter = null;
        }, t.move = function(e) {
            var t = Wt._nativeVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeKinematicCharacter.setWalkDirection(t);
        }, t.jump = function(e) {
            if (e) {
                var t = Wt._nativeVector30;
                ke._convertToBulletVec3(e, t, !0), this._nativeKinematicCharacter.jump(t);
            } else this._nativeKinematicCharacter.jump();
        }, a(0, t, "fallSpeed", function() {
            return this._fallSpeed;
        }, function(e) {
            this._fallSpeed = e, this._nativeKinematicCharacter.setFallSpeed(e);
        }), a(0, t, "stepHeight", function() {
            return this._stepHeight;
        }, function(e) {
            this._stepHeight = e, this._constructCharacter();
        }), a(0, t, "jumpSpeed", function() {
            return this._jumpSpeed;
        }, function(e) {
            this._jumpSpeed = e, this._nativeKinematicCharacter.setJumpSpeed(e);
        }), a(0, t, "gravity", function() {
            return this._gravity;
        }, function(e) {
            this._gravity = e;
            var t = CharacterController._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeKinematicCharacter.setGravity(t);
        }), a(0, t, "maxSlope", function() {
            return this._maxSlope;
        }, function(e) {
            this._maxSlope = e, this._nativeKinematicCharacter.setMaxSlope(e / 180 * Math.PI);
        }), a(0, t, "isGrounded", function() {
            return this._nativeKinematicCharacter.onGround();
        }), a(0, t, "upAxis", function() {
            return this._upAxis;
        }, function(e) {
            this._upAxis = e, this._constructCharacter();
        }), CharacterController.UPAXIS_X = 0, CharacterController.UPAXIS_Y = 1, CharacterController.UPAXIS_Z = 2, 
        i(CharacterController, [ "_nativeTempVector30", function() {
            return this._nativeTempVector30 = new X._physics3D.btVector3(0, 0, 0);
        } ]);
    }(Wt), function(e) {
        function TerrainRender(e) {
            this._terrainSprite3DOwner = null, this._projectionViewWorldMatrix = null, TerrainRender.__super.call(this, e), 
            this._terrainSprite3DOwner = e, this._projectionViewWorldMatrix = new Ht();
        }
        r(TerrainRender, "laya.d3.terrain.TerrainRender", e);
        var t = TerrainRender.prototype;
        return t._needRender = function(e) {
            return !e || 0 !== e.containsBoundBox(this._bounds._getBoundBox());
        }, t._calculateBoundingBox = function() {}, t._renderUpdate = function(e, t) {
            this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, t.worldMatrix);
        }, t._renderUpdateWithCamera = function(e, t) {
            var n = e.projectionViewMatrix;
            Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix);
        }, t._destroy = function() {
            e.prototype._destroy.call(this), this._terrainSprite3DOwner = null;
        }, TerrainRender;
    }(Xt)), Kn = function(e) {
        function MeshRenderer(e) {
            MeshRenderer.__super.call(this, e), this._projectionViewWorldMatrix = new Ht();
        }
        r(MeshRenderer, "laya.d3.core.MeshRenderer", e);
        var t = MeshRenderer.prototype;
        return t._onMeshChange = function(e) {
            this._boundsChange = !0;
        }, t._calculateBoundingBox = function() {
            var e = this._owner.meshFilter.sharedMesh;
            if (e) {
                var t = this._owner.transform.worldMatrix;
                e.bounds._tranform(t, this._bounds);
            }
            if (R.supportWebGLPlusCulling) {
                var n = this._bounds.getMin(), i = this._bounds.getMax(), r = Bt._cullingBuffer;
                r[this._cullingBufferIndex + 1] = n.x, r[this._cullingBufferIndex + 2] = n.y, r[this._cullingBufferIndex + 3] = n.z, 
                r[this._cullingBufferIndex + 4] = i.x, r[this._cullingBufferIndex + 5] = i.y, r[this._cullingBufferIndex + 6] = i.z;
            }
        }, t._changeRenderObjectsByMesh = function(e) {
            var t = e.subMeshCount;
            this._renderElements.length = t;
            for (var n = 0; n < t; n++) {
                var i = this._renderElements[n];
                if (!i) {
                    var r = this.sharedMaterials[n];
                    (i = this._renderElements[n] = new Nn()).setTransform(this._owner._transform), i.render = this, 
                    i.material = r || ci.defaultMaterial;
                }
                i.setGeometry(e._getSubMesh(n));
            }
        }, t._needRender = function(e) {
            return !e || 0 !== e.containsBoundBox(this.bounds._getBoundBox());
        }, t._renderUpdate = function(e, t) {
            var n = e.renderElement;
            switch (n.renderType) {
              case 0:
                this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, t.worldMatrix);
                break;

              case 1:
                this._oriDefineValue = this._defineDatas.value, t ? this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, Ht.DEFAULT), 
                this._defineDatas.add(Si.SHADERDEFINE_UV1), this._defineDatas.remove(Jn.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                break;

              case 3:
                this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, Ht.DEFAULT);
                break;

              case 2:
                for (var i = Sn.instance.instanceWorldMatrixData, r = n.instanceBatchElementList, a = r.length, o = 0; o < a; o++) i.set(r[o]._transform.worldMatrix.elements, 16 * o);
                Sn.instance.instanceWorldMatrixBuffer.setData(i, 0, 0, 16 * a), this._defineDatas.add(Si.SHADERDEFINE_GPU_INSTANCE);
            }
        }, t._renderUpdateWithCamera = function(e, t) {
            var n = e.projectionViewMatrix, i = e.renderElement;
            switch (i.renderType) {
              case 0:
              case 1:
              case 3:
                t ? (Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(bn.MVPMATRIX, n);
                break;

              case 2:
                for (var r = Sn.instance.instanceMVPMatrixData, a = i.instanceBatchElementList, o = a.length, s = 0; s < o; s++) {
                    var l = a[s]._transform.worldMatrix;
                    ke.mulMatrixByArray(n.elements, 0, l.elements, 0, r, 16 * s);
                }
                Sn.instance.instanceMVPMatrixBuffer.setData(r, 0, 0, 16 * o);
            }
        }, t._renderUpdateWithCameraForNative = function(e, t) {
            var n = e.projectionViewMatrix, i = e.renderElement;
            switch (i.renderType) {
              case 0:
                t ? (Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(bn.MVPMATRIX, n);
                break;

              case 1:
              case 3:
                var r = ue._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                ue.setRuntimeValueMode(!1), t ? (Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), 
                this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(bn.MVPMATRIX, n), 
                ue.setRuntimeValueMode(r);
                break;

              case 2:
                for (var a = Sn.instance.instanceMVPMatrixData, o = i.instanceBatchElementList, s = o.length, l = 0; l < s; l++) {
                    var h = o[l]._transform.worldMatrix;
                    ke.mulMatrixByArray(n.elements, 0, h.elements, 0, a, 16 * l);
                }
                Sn.instance.instanceMVPMatrixBuffer.setData(a, 0, 0, 16 * s);
            }
        }, t._revertBatchRenderUpdate = function(e) {
            switch (e.renderElement.renderType) {
              case 1:
                this._defineDatas.value = this._oriDefineValue;
                break;

              case 2:
                this._defineDatas.remove(Si.SHADERDEFINE_GPU_INSTANCE);
            }
        }, t._destroy = function() {
            this._isPartOfStaticBatch && gn.instance._destroyRenderSprite(this._owner), e.prototype._destroy.call(this);
        }, i(MeshRenderer, [ "_tempVector30", function() {
            return this._tempVector30 = new Te();
        }, "_tempVector31", function() {
            return this._tempVector31 = new Te();
        } ]), MeshRenderer;
    }(Xt), Qn = function(e) {
        function TrailRenderer(e) {
            this._projectionViewWorldMatrix = new Ht(), TrailRenderer.__super.call(this, e);
        }
        r(TrailRenderer, "laya.d3.core.trail.TrailRenderer", e);
        var t = TrailRenderer.prototype;
        return t._calculateBoundingBox = function() {
            var e = this._bounds.getMin();
            e.x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE, e.z = -Number.MAX_VALUE, this._bounds.setMin(e);
            var t = this._bounds.getMax();
            if (t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE, t.z = Number.MAX_VALUE, this._bounds.setMax(t), 
            R.supportWebGLPlusCulling) {
                e = this._bounds.getMin(), t = this._bounds.getMax();
                var n = Bt._cullingBuffer;
                n[this._cullingBufferIndex + 1] = e.x, n[this._cullingBufferIndex + 2] = e.y, n[this._cullingBufferIndex + 3] = e.z, 
                n[this._cullingBufferIndex + 4] = t.x, n[this._cullingBufferIndex + 5] = t.y, n[this._cullingBufferIndex + 6] = t.z;
            }
        }, t._needRender = function(e) {
            return !0;
        }, t._renderUpdate = function(t, n) {
            e.prototype._renderUpdate.call(this, t, n), this._owner.trailFilter._update(t);
        }, t._renderUpdateWithCamera = function(e, t) {
            var n = e.projectionViewMatrix;
            t ? (Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(bn.MVPMATRIX, n);
        }, TrailRenderer;
    }(Xt), jn = function(e) {
        function PixelLineRenderer(e) {
            this._projectionViewWorldMatrix = null, PixelLineRenderer.__super.call(this, e), 
            this._projectionViewWorldMatrix = new Ht();
        }
        r(PixelLineRenderer, "laya.d3.core.pixelLine.PixelLineRenderer", Xt);
        var t = PixelLineRenderer.prototype;
        return t._calculateBoundingBox = function() {
            var e = this._bounds.getMin();
            e.x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE, e.z = -Number.MAX_VALUE, this._bounds.setMin(e);
            var t = this._bounds.getMax();
            if (t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE, t.z = Number.MAX_VALUE, this._bounds.setMax(t), 
            R.supportWebGLPlusCulling) {
                e = this._bounds.getMin(), t = this._bounds.getMax();
                var n = Bt._cullingBuffer;
                n[this._cullingBufferIndex + 1] = e.x, n[this._cullingBufferIndex + 2] = e.y, n[this._cullingBufferIndex + 3] = e.z, 
                n[this._cullingBufferIndex + 4] = t.x, n[this._cullingBufferIndex + 5] = t.y, n[this._cullingBufferIndex + 6] = t.z;
            }
        }, t._renderUpdateWithCamera = function(e, t) {
            var n = e.projectionViewMatrix, i = this._shaderValues;
            if (t) {
                var r = t.worldMatrix;
                i.setMatrix4x4(bn.WORLDMATRIX, r), Ht.multiply(n, r, this._projectionViewWorldMatrix), 
                i.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix);
            } else i.setMatrix4x4(bn.WORLDMATRIX, Ht.DEFAULT), i.setMatrix4x4(bn.MVPMATRIX, n);
        }, PixelLineRenderer;
    }(), qn = function(e) {
        function Scene3D() {
            this._reflectionMode = 1, this._enableLightCount = 3, this.enableLight = !0, this._time = 0, 
            Scene3D.__super.call(this), this._lights = [], this._lightmaps = [], this._skyRenderer = new mt(), 
            this._input = new Ze(), this._timer = n.timer, this._collsionTestList = [], this._renders = new un(), 
            this._opaqueQueue = new At(!1), this._transparentQueue = new At(!0), this._cameraPool = [], 
            this._animatorPool = new un(), this._scriptPool = new un(), this._castShadowRenders = new rn(), 
            this.currentCreationLayer = Math.pow(2, 0), this._key = new N(), this._pickIdToSprite = new Object(), 
            X._enbalePhysics && (this._physicsSimulation = new kt(X.physicsSettings)), this._defineDatas = new Ue(), 
            this._shaderValues = new ue(null), this.parallelSplitShadowMaps = [], this.enableFog = !1, 
            this.fogStart = 300, this.fogRange = 1e3, this.fogColor = new Te(.7, .7, .7), this.ambientColor = new Te(.212, .227, .259), 
            this.reflectionIntensity = 1, b.shaderHighPrecision && this._defineDatas.add(Ve.SHADERDEFINE_HIGHPRECISION), 
            R.supportWebGLPlusCulling && (this._cullingBufferIndices = new Int32Array(1024), 
            this._cullingBufferResult = new Int32Array(1024)), this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.RANGEATTENUATIONTEXTURE, He._rangeAttenTex), 
            this._scene = this, X._enbalePhysics && !kt.disableSimulation && this._input.__init__(R.canvas, this);
            var e = X._config;
            if (e.octreeCulling && (this._octree = new Je(e.octreeInitialSize, e.octreeInitialCenter, e.octreeMinNodeSize, e.octreeLooseness)), 
            X._config.debugFrustumCulling) {
                this._debugTool = new Mi();
                var t = new ri();
                t.renderQueue = 3e3, t.alphaTest = !1, t.depthWrite = !1, t.cull = 2, t.blend = 1, 
                t.blendSrc = 770, t.blendDst = 771, t.depthTest = 513, this._debugTool.pixelLineRenderer.sharedMaterial = t;
            }
        }
        r(Scene3D, "laya.d3.core.scene.Scene3D", e);
        var t = Scene3D.prototype;
        return n.imps(t, {
            "laya.webgl.submit.ISubmit": !0,
            "laya.resource.ICreateResource": !0
        }), t._allotPickColorByID = function(e, t) {
            var n = Math.floor(e / 65025);
            e -= 255 * n * 255;
            var i = Math.floor(e / 255), r = e -= 255 * i;
            t.x = n / 255, t.y = i / 255, t.z = r / 255, t.w = 1;
        }, t._searchIDByPickColor = function(e) {
            return 255 * e.x * 255 + 255 * e.y + e.z;
        }, t._setLightmapToChildNode = function(e) {
            e instanceof laya.d3.core.RenderableSprite3D && e._render._applyLightMapParams();
            for (var t = e._children, n = 0, i = t.length; n < i; n++) this._setLightmapToChildNode(t[n]);
        }, t._update = function() {
            var e = this.timer._delta / 1e3;
            this._time += e, this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.TIME, this._time);
            var t = this._physicsSimulation;
            X._enbalePhysics && !kt.disableSimulation && (t._updatePhysicsTransformFromRender(), 
            Wt._addUpdateList = !1, t._simulate(e), t._updateCharacters(), Wt._addUpdateList = !0, 
            t._updateCollisions(), t._eventScripts(), this._input._update()), this._updateScript(), 
            Zt._update(this), this._lateUpdateScript();
        }, t._binarySearchIndexInCameraPool = function(e) {
            for (var t = 0, n = this._cameraPool.length - 1, i = 0; t <= n; ) {
                i = Math.floor((t + n) / 2);
                var r = this._cameraPool[i]._renderingOrder;
                if (r == e._renderingOrder) return i;
                r > e._renderingOrder ? n = i - 1 : t = i + 1;
            }
            return t;
        }, t._setCreateURL = function(e) {
            this._url = w.formatURL(e);
        }, t._getGroup = function() {
            return this._group;
        }, t._setGroup = function(e) {
            this._group = e;
        }, t._updateScript = function() {
            for (var e = this._scriptPool, t = e.elements, n = 0, i = e.length; n < i; n++) {
                var r = t[n];
                r && r.enabled && r.onUpdate();
            }
        }, t._lateUpdateScript = function() {
            for (var e = this._scriptPool, t = e.elements, n = 0, i = e.length; n < i; n++) {
                var r = t[n];
                r && r.enabled && r.onLateUpdate();
            }
        }, t._preRenderScript = function() {
            for (var e = this._scriptPool, t = e.elements, n = 0, i = e.length; n < i; n++) {
                var r = t[n];
                r && r.enabled && r.onPreRender();
            }
        }, t._postRenderScript = function() {
            for (var e = this._scriptPool, t = e.elements, n = 0, i = e.length; n < i; n++) {
                var r = t[n];
                r && r.enabled && r.onPostRender();
            }
        }, t._prepareSceneToRender = function() {
            var e = this._lights.length;
            if (e > 0) for (var t = 0, n = 0; n < e && !(this._lights[n]._prepareToScene() && ++t >= this._enableLightCount); n++) ;
        }, t._addCamera = function(e) {
            for (var t = this._binarySearchIndexInCameraPool(e), n = e._renderingOrder, i = this._cameraPool.length; t < i && this._cameraPool[t]._renderingOrder <= n; ) t++;
            this._cameraPool.splice(t, 0, e);
        }, t._removeCamera = function(e) {
            this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
        }, t._preCulling = function(e, t) {
            Bt.renderObjectCulling(t, this, e, this._renders);
        }, t._clear = function(e, t) {
            var n = t.viewport, i = t.camera, r = i.getRenderTexture(), a = n.width, o = n.height, s = n.x, l = i._getCanvasHeight() - n.y - o;
            e.viewport(s, l, a, o);
            var h = 0, u = i.clearFlag;
            switch (1 !== u || i.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (u = 0), 
            u) {
              case 0:
                var c = i.clearColor;
                if (e.enable(3089), e.scissor(s, l, a, o), c ? e.clearColor(c.x, c.y, c.z, c.w) : e.clearColor(0, 0, 0, 0), 
                r) switch (h = 16384, r.depthStencilFormat) {
                  case 0:
                    h |= 256;
                    break;

                  case 1:
                    h |= 1024;
                    break;

                  case 2:
                    h |= 256, h |= 1024;
                } else h = 16640;
                F.setDepthMask(e, !0), e.clear(h), e.disable(3089);
                break;

              case 1:
              case 2:
                if (e.enable(3089), e.scissor(s, l, a, o), r) switch (r.depthStencilFormat) {
                  case 0:
                    h = 256;
                    break;

                  case 1:
                    h = 1024;
                    break;

                  case 2:
                    h = 1280;
                } else h = 256;
                F.setDepthMask(e, !0), e.clear(h), e.disable(3089);
                break;

              case 3:
                break;

              default:
                throw new Error("BaseScene:camera clearFlag invalid.");
            }
        }, t._renderScene = function(e, t, n, i) {
            var r = t.camera;
            r.transform.position;
            if (r.getRenderTexture() ? this._opaqueQueue._render(t, !0, n, i) : this._opaqueQueue._render(t, !1, n, i), 
            1 === r.clearFlag && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)), 
            r.getRenderTexture() ? this._transparentQueue._render(t, !0, n, i) : this._transparentQueue._render(t, !1, n, i), 
            r._applyPostProcessCommandBuffers(), X._config.debugFrustumCulling) for (var a = this._debugTool._render._renderElements, o = 0, s = a.length; o < s; o++) a[o]._render(t, !1, n, i);
        }, t._parse = function(e, t) {
            var n = e.lightmaps;
            if (n) {
                for (var i = n.length, r = o(i), a = 0; a < i; a++) r[a] = g.getRes(n[a].path);
                this.setlightmaps(r);
            }
            var s = e.ambientColor;
            if (s) {
                var l = this.ambientColor;
                l.fromArray(s), this.ambientColor = l;
            }
            var h = e.sky;
            if (h) switch (this._skyRenderer.material = g.getRes(h.material.path), h.mesh) {
              case "SkyBox":
                this._skyRenderer.mesh = Mn.instance;
                break;

              case "SkyDome":
                this._skyRenderer.mesh = Ln.instance;
                break;

              default:
                this.skyRenderer.mesh = Mn.instance;
            }
            var u = e.reflectionTexture;
            u && (this.customReflection = g.getRes(u)), this.enableFog = e.enableFog, this.fogStart = e.fogStart, 
            this.fogRange = e.fogRange;
            var c = e.fogColor;
            if (c) {
                var d = this.fogColor;
                d.fromArray(c), this.fogColor = d;
            }
        }, t._onActive = function() {
            laya.display.Node.prototype._onActive.call(this), n.stage._scene3Ds.push(this);
        }, t._onInActive = function() {
            laya.display.Node.prototype._onInActive.call(this);
            var e = n.stage._scene3Ds;
            e.splice(e.indexOf(this), 1);
        }, t._addLight = function(e) {
            this._lights.indexOf(e) < 0 && this._lights.push(e);
        }, t._removeLight = function(e) {
            var t = this._lights.indexOf(e);
            t >= 0 && this._lights.splice(t, 1);
        }, t._addRenderObject = function(e) {
            if (this._octree) this._octree.add(e); else if (this._renders.add(e), R.supportWebGLPlusCulling) {
                var t = e._getIndexInList(), n = this._cullingBufferIndices.length;
                if (t >= n) {
                    var i = this._cullingBufferIndices, r = this._cullingBufferResult;
                    this._cullingBufferIndices = new Int32Array(n + 1024), this._cullingBufferResult = new Int32Array(n + 1024), 
                    this._cullingBufferIndices.set(i, 0), this._cullingBufferResult.set(r, 0);
                }
                this._cullingBufferIndices[t] = e._cullingBufferIndex;
            }
        }, t._removeRenderObject = function(e) {
            var t;
            this._octree ? this._octree.remove(e) : (R.supportWebGLPlusCulling && (t = this._renders.elements[this._renders.length - 1]), 
            this._renders.remove(e), R.supportWebGLPlusCulling && (this._cullingBufferIndices[t._getIndexInList()] = t._cullingBufferIndex));
        }, t._addShadowCastRenderObject = function(e) {
            this._octree || this._castShadowRenders.add(e);
        }, t._removeShadowCastRenderObject = function(e) {
            this._octree || this._castShadowRenders.remove(e);
        }, t._getRenderQueue = function(e) {
            return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
        }, t.setlightmaps = function(e) {
            for (var t = this._lightmaps, n = 0, i = t.length; n < i; n++) t[n]._removeReference();
            if (!e) throw new Error("Scene3D: value value can't be null.");
            var r = e.length;
            for (t.length = r, n = 0; n < r; n++) {
                var a = e[n];
                a._addReference(), t[n] = a;
            }
            for (n = 0, i = this._children.length; n < i; n++) this._setLightmapToChildNode(this._children[n]);
        }, t.getlightmaps = function() {
            return this._lightmaps.slice();
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._skyRenderer.destroy(), this._skyRenderer = null, this._lights = null, this._lightmaps = null, 
            this._renderTargetTexture = null, this._shaderValues = null, this._renders = null, 
            this._castShadowRenders = null, this._cameraPool = null, this._octree = null, this.parallelSplitShadowMaps = null, 
            this._physicsSimulation && this._physicsSimulation._destroy(), g.clearRes(this.url));
        }, t.render = function(e, t, n) {
            e._curSubmit = V.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
        }, t.renderSubmit = function() {
            E.instance;
            this._prepareSceneToRender();
            var e, t, n = 0;
            for (n = 0, t = (e = this._cameraPool.length) - 1; n < e; n++) {
                R.supportWebGLPlusRendering && ue.setRuntimeValueMode(n == t);
                var i = this._cameraPool[n];
                i.enableRender && i.render();
            }
            return p.set2DRenderConfig(), 1;
        }, t.getRenderType = function() {
            return 0;
        }, t.releaseRender = function() {}, t.reUse = function(e, t) {
            return 0;
        }, a(0, t, "fogColor", function() {
            return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.FOGCOLOR);
        }, function(e) {
            this._shaderValues.setVector3(laya.d3.core.scene.Scene3D.FOGCOLOR, e);
        }), a(0, t, "enableFog", function() {
            return this._enableFog;
        }, function(e) {
            this._enableFog !== e && (this._enableFog = e, e ? this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG) : this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_FOG));
        }), a(0, t, "url", function() {
            return this._url;
        }), a(0, t, "fogStart", function() {
            return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGSTART);
        }, function(e) {
            this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGSTART, e);
        }), a(0, t, "reflectionIntensity", function() {
            return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY);
        }, function(e) {
            e = Math.max(Math.min(e, 1), 0), this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.REFLETIONINTENSITY, e);
        }), a(0, t, "skyRenderer", function() {
            return this._skyRenderer;
        }), a(0, t, "fogRange", function() {
            return this._shaderValues.getNumber(laya.d3.core.scene.Scene3D.FOGRANGE);
        }, function(e) {
            this._shaderValues.setNumber(laya.d3.core.scene.Scene3D.FOGRANGE, e);
        }), a(0, t, "ambientColor", function() {
            return this._shaderValues.getVector(laya.d3.core.scene.Scene3D.AMBIENTCOLOR);
        }, function(e) {
            this._shaderValues.setVector3(laya.d3.core.scene.Scene3D.AMBIENTCOLOR, e);
        }), a(0, t, "customReflection", function() {
            return this._shaderValues.getTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE);
        }, function(e) {
            this._shaderValues.setTexture(laya.d3.core.scene.Scene3D.REFLECTIONTEXTURE, e), 
            e ? this._defineDatas.add(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP) : this._defineDatas.remove(laya.d3.core.scene.Scene3D.SHADERDEFINE_REFLECTMAP);
        }), a(0, t, "physicsSimulation", function() {
            return this._physicsSimulation;
        }), a(0, t, "reflectionMode", function() {
            return this._reflectionMode;
        }, function(e) {
            this._reflectionMode = e;
        }), a(0, t, "timer", function() {
            return this._timer;
        }, function(e) {
            this._timer = e;
        }), a(0, t, "input", function() {
            return this._input;
        }), Scene3D._parse = function(e, t, n) {
            var i, r = e.data, a = [];
            switch (e.version) {
              case "LAYAHIERARCHY:02":
                i = ke._createNodeByJson02(r, a);
                break;

              default:
                i = ke._createNodeByJson(r, a);
            }
            return j.combine(null, a), i;
        }, Scene3D.load = function(e, t) {
            n.loader.create(e, t, null, "HIERARCHY");
        }, Scene3D.REFLECTIONMODE_SKYBOX = 0, Scene3D.REFLECTIONMODE_CUSTOM = 1, Scene3D.SHADERDEFINE_FOG = 0, 
        Scene3D.SHADERDEFINE_DIRECTIONLIGHT = 0, Scene3D.SHADERDEFINE_POINTLIGHT = 0, Scene3D.SHADERDEFINE_SPOTLIGHT = 0, 
        Scene3D.SHADERDEFINE_CAST_SHADOW = 0, Scene3D.SHADERDEFINE_SHADOW_PSSM1 = 0, Scene3D.SHADERDEFINE_SHADOW_PSSM2 = 0, 
        Scene3D.SHADERDEFINE_SHADOW_PSSM3 = 0, Scene3D.SHADERDEFINE_SHADOW_PCF_NO = 0, Scene3D.SHADERDEFINE_SHADOW_PCF1 = 0, 
        Scene3D.SHADERDEFINE_SHADOW_PCF2 = 0, Scene3D.SHADERDEFINE_SHADOW_PCF3 = 0, Scene3D.SHADERDEFINE_REFLECTMAP = 0, 
        i(Scene3D, [ "FOGCOLOR", function() {
            return this.FOGCOLOR = Ve.propertyNameToID("u_FogColor");
        }, "FOGSTART", function() {
            return this.FOGSTART = Ve.propertyNameToID("u_FogStart");
        }, "FOGRANGE", function() {
            return this.FOGRANGE = Ve.propertyNameToID("u_FogRange");
        }, "LIGHTDIRECTION", function() {
            return this.LIGHTDIRECTION = Ve.propertyNameToID("u_DirectionLight.Direction");
        }, "LIGHTDIRCOLOR", function() {
            return this.LIGHTDIRCOLOR = Ve.propertyNameToID("u_DirectionLight.Color");
        }, "POINTLIGHTPOS", function() {
            return this.POINTLIGHTPOS = Ve.propertyNameToID("u_PointLight.Position");
        }, "POINTLIGHTRANGE", function() {
            return this.POINTLIGHTRANGE = Ve.propertyNameToID("u_PointLight.Range");
        }, "POINTLIGHTATTENUATION", function() {
            return this.POINTLIGHTATTENUATION = Ve.propertyNameToID("u_PointLight.Attenuation");
        }, "POINTLIGHTCOLOR", function() {
            return this.POINTLIGHTCOLOR = Ve.propertyNameToID("u_PointLight.Color");
        }, "SPOTLIGHTPOS", function() {
            return this.SPOTLIGHTPOS = Ve.propertyNameToID("u_SpotLight.Position");
        }, "SPOTLIGHTDIRECTION", function() {
            return this.SPOTLIGHTDIRECTION = Ve.propertyNameToID("u_SpotLight.Direction");
        }, "SPOTLIGHTSPOTANGLE", function() {
            return this.SPOTLIGHTSPOTANGLE = Ve.propertyNameToID("u_SpotLight.Spot");
        }, "SPOTLIGHTRANGE", function() {
            return this.SPOTLIGHTRANGE = Ve.propertyNameToID("u_SpotLight.Range");
        }, "SPOTLIGHTCOLOR", function() {
            return this.SPOTLIGHTCOLOR = Ve.propertyNameToID("u_SpotLight.Color");
        }, "SHADOWDISTANCE", function() {
            return this.SHADOWDISTANCE = Ve.propertyNameToID("u_shadowPSSMDistance");
        }, "SHADOWLIGHTVIEWPROJECT", function() {
            return this.SHADOWLIGHTVIEWPROJECT = Ve.propertyNameToID("u_lightShadowVP");
        }, "SHADOWMAPPCFOFFSET", function() {
            return this.SHADOWMAPPCFOFFSET = Ve.propertyNameToID("u_shadowPCFoffset");
        }, "SHADOWMAPTEXTURE1", function() {
            return this.SHADOWMAPTEXTURE1 = Ve.propertyNameToID("u_shadowMap1");
        }, "SHADOWMAPTEXTURE2", function() {
            return this.SHADOWMAPTEXTURE2 = Ve.propertyNameToID("u_shadowMap2");
        }, "SHADOWMAPTEXTURE3", function() {
            return this.SHADOWMAPTEXTURE3 = Ve.propertyNameToID("u_shadowMap3");
        }, "AMBIENTCOLOR", function() {
            return this.AMBIENTCOLOR = Ve.propertyNameToID("u_AmbientColor");
        }, "REFLECTIONTEXTURE", function() {
            return this.REFLECTIONTEXTURE = Ve.propertyNameToID("u_ReflectTexture");
        }, "REFLETIONINTENSITY", function() {
            return this.REFLETIONINTENSITY = Ve.propertyNameToID("u_ReflectIntensity");
        }, "TIME", function() {
            return this.TIME = Ve.propertyNameToID("u_Time");
        }, "ANGLEATTENUATIONTEXTURE", function() {
            return this.ANGLEATTENUATIONTEXTURE = Ve.propertyNameToID("u_AngleTexture");
        }, "RANGEATTENUATIONTEXTURE", function() {
            return this.RANGEATTENUATIONTEXTURE = Ve.propertyNameToID("u_RangeTexture");
        }, "POINTLIGHTMATRIX", function() {
            return this.POINTLIGHTMATRIX = Ve.propertyNameToID("u_PointLightMatrix");
        }, "SPOTLIGHTMATRIX", function() {
            return this.SPOTLIGHTMATRIX = Ve.propertyNameToID("u_SpotLightMatrix");
        } ]), Scene3D;
    }(O), Jn = function(e) {
        function RenderableSprite3D(e) {
            this.pickColor = null, this._render = null, RenderableSprite3D.__super.call(this, e);
        }
        r(RenderableSprite3D, "laya.d3.core.RenderableSprite3D", e);
        var t = RenderableSprite3D.prototype;
        return t._onInActive = function() {
            laya.display.Node.prototype._onInActive.call(this);
            var e = this._scene;
            e._removeRenderObject(this._render), this._render.castShadow && e._removeShadowCastRenderObject(this._render);
        }, t._onActive = function() {
            laya.display.Node.prototype._onActive.call(this);
            var e = this._scene;
            e._addRenderObject(this._render), this._render.castShadow && e._addShadowCastRenderObject(this._render);
        }, t._onActiveInScene = function() {
            if (laya.display.Node.prototype._onActiveInScene.call(this), X._editerEnvironment) {
                var e = this._scene, t = new me();
                e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(laya.d3.core.RenderableSprite3D.PICKCOLOR, t);
            }
        }, t._addToInitStaticBatchManager = function() {}, t._setBelongScene = function(e) {
            laya.display.Node.prototype._setBelongScene.call(this, e), this._render._setBelongScene(e);
        }, t._setUnBelongScene = function() {
            this._render._defineDatas.remove(laya.d3.core.RenderableSprite3D.SAHDERDEFINE_LIGHTMAP), 
            laya.display.Node.prototype._setUnBelongScene.call(this);
        }, t._changeHierarchyAnimator = function(t) {
            if (this._hierarchyAnimator) {
                var n = this._hierarchyAnimator._renderableSprites;
                n.splice(n.indexOf(this), 1);
            }
            t && t._renderableSprites.push(this), e.prototype._changeHierarchyAnimator.call(this, t);
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), e.prototype.destroy.call(this, t), this._render._destroy(), 
            this._render = null;
        }, RenderableSprite3D.__init__ = function() {
            RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = RenderableSprite3D.shaderDefines.registerDefine("RECEIVESHADOW"), 
            RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = RenderableSprite3D.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV"), 
            RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = RenderableSprite3D.shaderDefines.registerDefine("LIGHTMAP");
        }, RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = 0, RenderableSprite3D.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = 0, 
        RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = 0, i(RenderableSprite3D, [ "LIGHTMAPSCALEOFFSET", function() {
            return this.LIGHTMAPSCALEOFFSET = Ve.propertyNameToID("u_LightmapScaleOffset");
        }, "LIGHTMAP", function() {
            return this.LIGHTMAP = Ve.propertyNameToID("u_LightMap");
        }, "PICKCOLOR", function() {
            return this.PICKCOLOR = Ve.propertyNameToID("u_PickColor");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe();
        } ]), RenderableSprite3D;
    }(bn), $n = function(e) {
        function UnlitMaterial() {
            this._albedoIntensity = 1, this._enableVertexColor = !1, this._albedoColor = new me(1, 1, 1, 1), 
            UnlitMaterial.__super.call(this), this.setShaderName("Unlit"), this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new me(1, 1, 1, 1)), 
            this.renderMode = 0;
        }
        r(UnlitMaterial, "laya.d3.core.material.UnlitMaterial", Fn);
        var t = UnlitMaterial.prototype;
        return a(0, t, "_ColorB", function() {
            return this._albedoColor.z;
        }, function(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorR", function() {
            return this._albedoColor.x;
        }, function(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "albedoColorA", function() {
            return this._ColorA;
        }, function(e) {
            this._ColorA = e;
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "_ColorG", function() {
            return this._albedoColor.y;
        }, function(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorA", function() {
            return this._albedoColor.w;
        }, function(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_AlbedoIntensity", function() {
            return this._albedoIntensity;
        }, function(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                me.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
            }
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "_Cutoff", function() {
            return this.alphaTestValue;
        }, function(e) {
            this.alphaTestValue = e;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "albedoColorR", function() {
            return this._ColorR;
        }, function(e) {
            this._ColorR = e;
        }), a(0, t, "albedoColorG", function() {
            return this._ColorG;
        }, function(e) {
            this._ColorG = e;
        }), a(0, t, "albedoColorB", function() {
            return this._ColorB;
        }, function(e) {
            this._ColorB = e;
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "albedoColor", function() {
            return this._albedoColor;
        }, function(e) {
            var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
            me.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
        }), a(0, t, "albedoIntensity", function() {
            return this._albedoIntensity;
        }, function(e) {
            this._AlbedoIntensity = e;
        }), a(0, t, "enableVertexColor", function() {
            return this._enableVertexColor;
        }, function(e) {
            this._enableVertexColor = e, e ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }), a(0, t, "albedoTexture", function() {
            return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE), 
            this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, e);
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.UnlitMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, e);
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 0:
                this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513;
                break;

              case 1:
                this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513;
                break;

              case 2:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513;
                break;

              default:
                throw new Error("UnlitMaterial : renderMode value error.");
            }
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(UnlitMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(UnlitMaterial.CULL, e);
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(UnlitMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(UnlitMaterial.BLEND, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(UnlitMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(UnlitMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, e);
        }), UnlitMaterial.__init__ = function() {
            UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = UnlitMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), 
            UnlitMaterial.SHADERDEFINE_TILINGOFFSET = UnlitMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = UnlitMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
        }, UnlitMaterial.RENDERMODE_OPAQUE = 0, UnlitMaterial.RENDERMODE_CUTOUT = 1, UnlitMaterial.RENDERMODE_TRANSPARENT = 2, 
        UnlitMaterial.RENDERMODE_ADDTIVE = 3, UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = 0, 
        UnlitMaterial.SHADERDEFINE_TILINGOFFSET = 0, UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = 0, 
        i(UnlitMaterial, [ "ALBEDOTEXTURE", function() {
            return this.ALBEDOTEXTURE = Ve.propertyNameToID("u_AlbedoTexture");
        }, "ALBEDOCOLOR", function() {
            return this.ALBEDOCOLOR = Ve.propertyNameToID("u_AlbedoColor");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new UnlitMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), UnlitMaterial;
    }(), ei = function(e) {
        function LightSprite() {
            this._intensityColor = null, this._intensity = NaN, this._shadow = !1, this._shadowFarPlane = 0, 
            this._shadowMapSize = 0, this._shadowMapCount = 0, this._shadowMapPCFType = 0, this._parallelSplitShadowMap = null, 
            this._lightmapBakedType = 0, this.color = null, LightSprite.__super.call(this), 
            this._intensity = 1, this._intensityColor = new Te(), this.color = new Te(1, 1, 1), 
            this._shadow = !1, this._shadowFarPlane = 8, this._shadowMapSize = 512, this._shadowMapCount = 1, 
            this._shadowMapPCFType = 0, this._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME;
        }
        r(LightSprite, "laya.d3.core.light.LightSprite", e);
        var t = LightSprite.prototype;
        return t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n);
            var i = t.color;
            this.color.fromArray(i), this.intensity = t.intensity, this.lightmapBakedType = t.lightmapBakedType;
        }, t._onActive = function() {
            laya.display.Node.prototype._onActive.call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._addLight(this);
        }, t._onInActive = function() {
            laya.display.Node.prototype._onInActive.call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._scene._removeLight(this);
        }, t._prepareToScene = function() {
            return !1;
        }, a(0, t, "lightmapBakedType", function() {
            return this._lightmapBakedType;
        }, function(e) {
            this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this._scene._addLight(this) : this._scene._removeLight(this)));
        }), a(0, t, "shadowPCFType", function() {
            return this._shadowMapPCFType;
        }, function(e) {
            this._shadowMapPCFType = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(e);
        }), a(0, t, "intensity", function() {
            return this._intensity;
        }, function(e) {
            this._intensity = e;
        }), a(0, t, "shadow", function() {
            return this._shadow;
        }, function(e) {
            throw new Error("LightSprite: must override it.");
        }), a(0, t, "shadowDistance", function() {
            return this._shadowFarPlane;
        }, function(e) {
            this._shadowFarPlane = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(e);
        }), a(0, t, "shadowPSSMCount", function() {
            return this._shadowMapCount;
        }, function(e) {
            this._shadowMapCount = e, this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = e);
        }), a(0, t, "shadowResolution", function() {
            return this._shadowMapSize;
        }, function(e) {
            this._shadowMapSize = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(e);
        }), a(0, t, "diffuseColor", function() {
            return console.log("LightSprite: discard property,please use color property instead."), 
            this.color;
        }, function(e) {
            console.log("LightSprite: discard property,please use color property instead."), 
            this.color = e;
        }), LightSprite.LIGHTMAPBAKEDTYPE_REALTIME = 0, LightSprite.LIGHTMAPBAKEDTYPE_MIXED = 1, 
        LightSprite.LIGHTMAPBAKEDTYPE_BAKED = 2, LightSprite;
    }(bn), ti = function(e) {
        function Terrain(e) {
            this._terrainRes = null, this._lightmapScaleOffset = null, Terrain.__super.call(this), 
            this._lightmapScaleOffset = new me(1, 1, 0, 0), e && (this._terrainRes = e, this.buildTerrain(e));
        }
        r(Terrain, "laya.d3.terrain.Terrain", e);
        var t = Terrain.prototype;
        return t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n), this.terrainRes = g.getRes(t.dataPath);
            var i = t.lightmapIndex;
            null != i && this.setLightmapIndex(i);
            var r = t.lightmapScaleOffset;
            r && this.setLightmapScaleOffset(new me(r[0], r[1], r[2], r[3]));
        }, t.setLightmapIndex = function(e) {
            for (var t = 0; t < this._children.length; t++) {
                this._children[t].terrainRender.lightmapIndex = e;
            }
        }, t.setLightmapScaleOffset = function(e) {
            if (e) {
                e.cloneTo(this._lightmapScaleOffset);
                for (var t = 0; t < this._children.length; t++) {
                    this._children[t].terrainRender.lightmapScaleOffset = this._lightmapScaleOffset;
                }
            }
        }, t.disableLight = function() {
            for (var e = 0, t = this._children.length; e < t; e++) for (var n = this._children[e], i = 0, r = n._render.sharedMaterials.length; i < r; i++) {
                n._render.sharedMaterials[i].disableLight();
            }
        }, t.buildTerrain = function(e) {
            for (var t = e._chunkNumX, n = e._chunkNumZ, i = e._heightData, r = 0, a = 0; a < n; a++) for (var o = 0; o < t; o++) {
                for (var s = new Ri(o, a, e._gridSize, i._terrainHeightData, i._width, i._height, e._cameraCoordinateInverse), l = e._chunkInfos[r++], h = 0; h < l.alphaMap.length; h++) {
                    var u = l.detailID[h].length, c = u > 0 ? e._detailTextureInfos[l.detailID[h][0]].diffuseTexture : null, d = u > 1 ? e._detailTextureInfos[l.detailID[h][1]].diffuseTexture : null, _ = u > 2 ? e._detailTextureInfos[l.detailID[h][2]].diffuseTexture : null, f = u > 3 ? e._detailTextureInfos[l.detailID[h][3]].diffuseTexture : null, m = u > 0 ? e._detailTextureInfos[l.detailID[h][0]].scale : null, p = u > 1 ? e._detailTextureInfos[l.detailID[h][1]].scale : null, T = u > 2 ? e._detailTextureInfos[l.detailID[h][2]].scale : null, S = u > 3 ? e._detailTextureInfos[l.detailID[h][3]].scale : null;
                    s.buildRenderElementAndMaterial(u, l.normalMap, l.alphaMap[h], c, d, _, f, e._materialInfo.ambientColor, e._materialInfo.diffuseColor, e._materialInfo.specularColor, m ? m.x : 1, m ? m.y : 1, p ? p.x : 1, p ? p.y : 1, T ? T.x : 1, T ? T.y : 1, S ? S.x : 1, S ? S.y : 1);
                }
                s.terrainRender.receiveShadow = !0, s.terrainRender.lightmapScaleOffset = this._lightmapScaleOffset, 
                this.addChild(s);
            }
        }, t.width = function() {
            return this._terrainRes._chunkNumX * ce.CHUNK_GRID_NUM * this._terrainRes._gridSize;
        }, t.depth = function() {
            return this._terrainRes._chunkNumZ * ce.CHUNK_GRID_NUM * this._terrainRes._gridSize;
        }, t.getHeightXZ = function(e, t) {
            if (!this._terrainRes) return NaN;
            if (e -= this.transform.position.x, t -= this.transform.position.z, Terrain.__VECTOR3__ || (Terrain.__VECTOR3__ = new Te()), 
            Terrain.__VECTOR3__.x = e, Terrain.__VECTOR3__.y = 0, Terrain.__VECTOR3__.z = t, 
            Te.transformV3ToV3(Terrain.__VECTOR3__, ce.__ADAPT_MATRIX_INV__, Terrain.__VECTOR3__), 
            e = Terrain.__VECTOR3__.x, t = Terrain.__VECTOR3__.z, e < 0 || e > this.width() || t < 0 || t > this.depth()) return NaN;
            var n = this._terrainRes._gridSize, i = parseInt("" + e / n), r = parseInt("" + t / n), a = e - i * n, o = t - r * n, s = NaN, l = this._terrainRes._heightData;
            return a + o > n ? (s = l._terrainHeightData[(r + 1 - 1) * l._width + i + 1]) + (l._terrainHeightData[(r + 1 - 1) * l._width + i] - s) * ((n - a) / n) + (l._terrainHeightData[(r - 1) * l._width + i + 1] - s) * ((n - o) / n) : (s = l._terrainHeightData[Math.max(0, r - 1) * l._width + i]) + (l._terrainHeightData[Math.min(l._width * l._height - 1, (r + 1 - 1) * l._width + i)] - s) * (o / n) + (l._terrainHeightData[Math.min(l._width * l._height - 1, Math.max(0, r - 1) * l._width + i + 1)] - s) * (a / n);
        }, a(0, t, "terrainRes", null, function(e) {
            e && (this._terrainRes = e, this.buildTerrain(e));
        }), Terrain.load = function(e) {
            n.loader.create(e, null, null, "TERRAIN", null, null, 1, !1);
        }, Terrain.RENDER_LINE_MODEL = !1, Terrain.LOD_TOLERANCE_VALUE = 4, Terrain.LOD_DISTANCE_FACTOR = 2, 
        Terrain.__VECTOR3__ = null, Terrain;
    }(bn), ni = function(e) {
        function TrailMaterial() {
            this._color = null, TrailMaterial.__super.call(this), this.setShaderName("Trail"), 
            this._color = new me(1, 1, 1, 1), this._shaderValues.setVector(TrailMaterial.TINTCOLOR, new me(1, 1, 1, 1)), 
            this.renderMode = 0;
        }
        r(TrailMaterial, "laya.d3.core.trail.TrailMaterial", Fn);
        var t = TrailMaterial.prototype;
        return a(0, t, "_TintColorB", function() {
            return this._color.z;
        }, function(e) {
            this._color.z = e, this.color = this._color;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "texture", function() {
            return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, e);
        }), a(0, t, "_TintColorR", function() {
            return this._color.x;
        }, function(e) {
            this._color.x = e, this.color = this._color;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "_TintColorG", function() {
            return this._color.y;
        }, function(e) {
            this._color.y = e, this.color = this._color;
        }), a(0, t, "_TintColorA", function() {
            return this._color.w;
        }, function(e) {
            this._color.w = e, this.color = this._color;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 1:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 1, this.depthTest = 513, this._defineDatas.add(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              case 0:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513, 
                this._defineDatas.remove(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("TrailMaterial : renderMode value error.");
            }
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "colorR", function() {
            return this._TintColorR;
        }, function(e) {
            this._TintColorR = e;
        }), a(0, t, "colorG", function() {
            return this._TintColorG;
        }, function(e) {
            this._TintColorG = e;
        }), a(0, t, "colorB", function() {
            return this._TintColorB;
        }, function(e) {
            this._TintColorB = e;
        }), a(0, t, "colorA", function() {
            return this._TintColorA;
        }, function(e) {
            this._TintColorA = e;
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(TrailMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(TrailMaterial.BLEND, e);
        }), a(0, t, "color", function() {
            return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
        }, function(e) {
            this._shaderValues.setVector(TrailMaterial.TINTCOLOR, e);
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(TrailMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(TrailMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.trail.TrailMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(TrailMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(TrailMaterial.CULL, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(TrailMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(TrailMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, e);
        }), TrailMaterial.__init__ = function() {
            TrailMaterial.SHADERDEFINE_MAINTEXTURE = TrailMaterial.shaderDefines.registerDefine("MAINTEXTURE"), 
            TrailMaterial.SHADERDEFINE_TILINGOFFSET = TrailMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            TrailMaterial.SHADERDEFINE_ADDTIVEFOG = TrailMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
        }, TrailMaterial.RENDERMODE_ALPHABLENDED = 0, TrailMaterial.RENDERMODE_ADDTIVE = 1, 
        TrailMaterial.SHADERDEFINE_MAINTEXTURE = 0, TrailMaterial.SHADERDEFINE_TILINGOFFSET = 0, 
        TrailMaterial.SHADERDEFINE_ADDTIVEFOG = 0, i(TrailMaterial, [ "defaultMaterial", function() {
            return this.defaultMaterial = new TrailMaterial();
        }, "MAINTEXTURE", function() {
            return this.MAINTEXTURE = Ve.propertyNameToID("u_MainTexture");
        }, "TINTCOLOR", function() {
            return this.TINTCOLOR = Ve.propertyNameToID("u_MainColor");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), TrailMaterial;
    }(), ii = function(e) {
        function SkyProceduralMaterial() {
            this._sunDisk = 0, SkyProceduralMaterial.__super.call(this), this.setShaderName("SkyBoxProcedural"), 
            this.sunDisk = 1, this.sunSize = .04, this.sunSizeConvergence = 5, this.atmosphereThickness = 1, 
            this.skyTint = new me(.5, .5, .5, 1), this.groundTint = new me(.369, .349, .341, 1), 
            this.exposure = 1.3;
        }
        r(SkyProceduralMaterial, "laya.d3.core.material.SkyProceduralMaterial", Fn);
        var t = SkyProceduralMaterial.prototype;
        return a(0, t, "exposure", function() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
        }, function(e) {
            e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, e);
        }), a(0, t, "sunSize", function() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
        }, function(e) {
            e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, e);
        }), a(0, t, "sunDisk", function() {
            return this._sunDisk;
        }, function(e) {
            switch (e) {
              case 1:
                this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE), this._defineDatas.add(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                break;

              case 2:
                this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), this._defineDatas.add(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                break;

              case 0:
                this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY), this._defineDatas.remove(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                break;

              default:
                throw "SkyBoxProceduralMaterial: unknown sun value.";
            }
            this._sunDisk = e;
        }), a(0, t, "sunSizeConvergence", function() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
        }, function(e) {
            e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, e);
        }), a(0, t, "atmosphereThickness", function() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
        }, function(e) {
            e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, e);
        }), a(0, t, "groundTint", function() {
            return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
        }, function(e) {
            this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, e);
        }), a(0, t, "skyTint", function() {
            return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
        }, function(e) {
            this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, e);
        }), SkyProceduralMaterial.__init__ = function() {
            SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_HIGH_QUALITY"), 
            SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = SkyProceduralMaterial.shaderDefines.registerDefine("SUN_SIMPLE");
        }, SkyProceduralMaterial.SUN_NODE = 0, SkyProceduralMaterial.SUN_HIGH_QUALITY = 1, 
        SkyProceduralMaterial.SUN_SIMPLE = 2, SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = 0, 
        SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = 0, i(SkyProceduralMaterial, [ "SUNSIZE", function() {
            return this.SUNSIZE = Ve.propertyNameToID("u_SunSize");
        }, "SUNSIZECONVERGENCE", function() {
            return this.SUNSIZECONVERGENCE = Ve.propertyNameToID("u_SunSizeConvergence");
        }, "ATMOSPHERETHICKNESS", function() {
            return this.ATMOSPHERETHICKNESS = Ve.propertyNameToID("u_AtmosphereThickness");
        }, "SKYTINT", function() {
            return this.SKYTINT = Ve.propertyNameToID("u_SkyTint");
        }, "GROUNDTINT", function() {
            return this.GROUNDTINT = Ve.propertyNameToID("u_GroundTint");
        }, "EXPOSURE", function() {
            return this.EXPOSURE = Ve.propertyNameToID("u_Exposure");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new SkyProceduralMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), SkyProceduralMaterial;
    }(), ri = function(e) {
        function PixelLineMaterial() {
            PixelLineMaterial.__super.call(this), this.setShaderName("LineShader"), this._shaderValues.setVector(PixelLineMaterial.COLOR, new me(1, 1, 1, 1));
        }
        r(PixelLineMaterial, "laya.d3.core.pixelLine.PixelLineMaterial", Fn);
        var t = PixelLineMaterial.prototype;
        return a(0, t, "blend", function() {
            return this._shaderValues.getInt(PixelLineMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(PixelLineMaterial.BLEND, e);
        }), a(0, t, "color", function() {
            return this._shaderValues.getVector(PixelLineMaterial.COLOR);
        }, function(e) {
            this._shaderValues.setVector(PixelLineMaterial.COLOR, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(PixelLineMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(PixelLineMaterial.CULL, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, e);
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, e);
        }), i(PixelLineMaterial, [ "COLOR", function() {
            return this.COLOR = Ve.propertyNameToID("u_Color");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new PixelLineMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        } ]), PixelLineMaterial;
    }(), ai = function(e) {
        function BaseCamera(e, t) {
            BaseCamera.__super.call(this), this._skyRenderer = new mt(), this._forward = new Te(), 
            this._up = new Te(), this.clearColor = new me(100 / 255, 149 / 255, 237 / 255, 1), 
            void 0 === e && (e = .3), void 0 === t && (t = 1e3), this._shaderValues = new ue(null), 
            this._fieldOfView = 60, this._useUserProjectionMatrix = !1, this._orthographic = !1, 
            this._orthographicVerticalSize = 10, this.renderingOrder = 0, this._nearPlane = e, 
            this._farPlane = t, this.cullingMask = 2147483647, this.clearFlag = 0, this.useOcclusionCulling = !0, 
            this._calculateProjectionMatrix(), n.stage.on("resize", this, this._onScreenSizeChanged);
        }
        r(BaseCamera, "laya.d3.core.BaseCamera", e);
        var t = BaseCamera.prototype;
        return t._sortCamerasByRenderingOrder = function() {
            if (this.displayedInStage) for (var e = this.scene._cameraPool, t = e.length - 1, n = 0; n < t; n++) if (e[n].renderingOrder > e[t].renderingOrder) {
                var i = e[n];
                e[n] = e[t], e[t] = i;
            }
        }, t._calculateProjectionMatrix = function() {}, t._onScreenSizeChanged = function() {
            this._calculateProjectionMatrix();
        }, t._prepareCameraToRender = function() {
            this.transform.getForward(this._forward), this.transform.getUp(this._up);
            var e = this._shaderValues;
            e.setVector3(laya.d3.core.BaseCamera.CAMERAPOS, this.transform.position), e.setVector3(laya.d3.core.BaseCamera.CAMERADIRECTION, this._forward), 
            e.setVector3(laya.d3.core.BaseCamera.CAMERAUP, this._up);
        }, t._prepareCameraViewProject = function(e, t, n, i) {
            var r = this._shaderValues;
            r.setMatrix4x4(laya.d3.core.BaseCamera.VIEWMATRIX, e), r.setMatrix4x4(laya.d3.core.BaseCamera.PROJECTMATRIX, t), 
            r.setMatrix4x4(laya.d3.core.BaseCamera.VIEWPROJECTMATRIX, n), this.transform.worldMatrix.cloneTo(BaseCamera._tempMatrix4x40), 
            BaseCamera._tempMatrix4x40.transpose(), Ht.multiply(t, BaseCamera._tempMatrix4x40, i), 
            r.setMatrix4x4(laya.d3.core.BaseCamera.VPMATRIX_NO_TRANSLATE, i);
        }, t.render = function(e, t) {}, t.addLayer = function(e) {
            this.cullingMask |= Math.pow(2, e);
        }, t.removeLayer = function(e) {
            this.cullingMask &= ~Math.pow(2, e);
        }, t.addAllLayers = function() {
            this.cullingMask = 2147483647;
        }, t.removeAllLayers = function() {
            this.cullingMask = 0;
        }, t.resetProjectionMatrix = function() {
            this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
        }, t._onActive = function() {
            this._scene._addCamera(this), laya.display.Node.prototype._onActive.call(this);
        }, t._onInActive = function() {
            this._scene._removeCamera(this), laya.display.Node.prototype._onInActive.call(this);
        }, t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n);
            var i = t.clearFlag;
            void 0 !== i && (this.clearFlag = i), this.orthographic = t.orthographic, this.fieldOfView = t.fieldOfView, 
            this.nearPlane = t.nearPlane, this.farPlane = t.farPlane;
            var r = t.clearColor;
            this.clearColor = new me(r[0], r[1], r[2], r[3]);
            var a = t.skyboxMaterial;
            a && (this._skyRenderer.material = g.getRes(a.path));
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this._skyRenderer.destroy(), this._skyRenderer = null, 
            n.stage.off("resize", this, this._onScreenSizeChanged), e.prototype.destroy.call(this, t);
        }, a(0, t, "renderingOrder", function() {
            return this._renderingOrder;
        }, function(e) {
            this._renderingOrder = e, this._sortCamerasByRenderingOrder();
        }), a(0, t, "skyRenderer", function() {
            return this._skyRenderer;
        }), a(0, t, "orthographic", function() {
            return this._orthographic;
        }, function(e) {
            this._orthographic = e, this._calculateProjectionMatrix();
        }), a(0, t, "fieldOfView", function() {
            return this._fieldOfView;
        }, function(e) {
            this._fieldOfView = e, this._calculateProjectionMatrix();
        }), a(0, t, "nearPlane", function() {
            return this._nearPlane;
        }, function(e) {
            this._nearPlane = e, this._calculateProjectionMatrix();
        }), a(0, t, "farPlane", function() {
            return this._farPlane;
        }, function(e) {
            this._farPlane = e, this._calculateProjectionMatrix();
        }), a(0, t, "orthographicVerticalSize", function() {
            return this._orthographicVerticalSize;
        }, function(e) {
            this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
        }), BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", BaseCamera.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", 
        BaseCamera.CLEARFLAG_SOLIDCOLOR = 0, BaseCamera.CLEARFLAG_SKY = 1, BaseCamera.CLEARFLAG_DEPTHONLY = 2, 
        BaseCamera.CLEARFLAG_NONE = 3, i(BaseCamera, [ "_tempMatrix4x40", function() {
            return this._tempMatrix4x40 = new Ht();
        }, "CAMERAPOS", function() {
            return this.CAMERAPOS = Ve.propertyNameToID("u_CameraPos");
        }, "VIEWMATRIX", function() {
            return this.VIEWMATRIX = Ve.propertyNameToID("u_View");
        }, "PROJECTMATRIX", function() {
            return this.PROJECTMATRIX = Ve.propertyNameToID("u_Projection");
        }, "VIEWPROJECTMATRIX", function() {
            return this.VIEWPROJECTMATRIX = Ve.propertyNameToID("u_ViewProjection");
        }, "VPMATRIX_NO_TRANSLATE", function() {
            return this.VPMATRIX_NO_TRANSLATE = Ve.propertyNameToID("u_MvpMatrix");
        }, "CAMERADIRECTION", function() {
            return this.CAMERADIRECTION = Ve.propertyNameToID("u_CameraDirection");
        }, "CAMERAUP", function() {
            return this.CAMERAUP = Ve.propertyNameToID("u_CameraUp");
        }, "_invertYScaleMatrix", function() {
            return this._invertYScaleMatrix = new Ht(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }, "_invertYProjectionMatrix", function() {
            return this._invertYProjectionMatrix = new Ht();
        }, "_invertYProjectionViewMatrix", function() {
            return this._invertYProjectionViewMatrix = new Ht();
        } ]), BaseCamera;
    }(bn), oi = function(e) {
        function PBRStandardMaterial() {
            this._albedoColor = null, this._emissionColor = null, PBRStandardMaterial.__super.call(this), 
            this.setShaderName("PBRStandard"), this._albedoColor = new me(1, 1, 1, 1), this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, new me(1, 1, 1, 1)), 
            this._emissionColor = new me(0, 0, 0, 0), this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, new me(0, 0, 0, 0)), 
            this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0), this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, .5), 
            this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSOURCE, 0), 
            this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, 1), 
            this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, .001), this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, !1), 
            this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, !0), this._shaderValues.setNumber(Fn.ALPHATESTVALUE, .5), 
            this._disablePublicDefineDatas.remove(qn.SHADERDEFINE_REFLECTMAP), this.renderMode = 0;
        }
        r(PBRStandardMaterial, "laya.d3.core.material.PBRStandardMaterial", e);
        var t = PBRStandardMaterial.prototype;
        return t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            this._albedoColor.cloneTo(n._albedoColor), this._emissionColor.cloneTo(n._emissionColor);
        }, a(0, t, "_Parallax", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.PARALLAXSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.PARALLAXSCALE, e);
        }), a(0, t, "_ColorB", function() {
            return this._albedoColor.z;
        }, function(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorR", function() {
            return this._albedoColor.x;
        }, function(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorG", function() {
            return this._albedoColor.y;
        }, function(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "metallic", function() {
            return this._Metallic;
        }, function(e) {
            this._Metallic = Math.max(0, Math.min(1, e));
        }), a(0, t, "_GlossMapScale", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESSSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESSSCALE, e);
        }), a(0, t, "_Glossiness", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.SMOOTHNESS);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.SMOOTHNESS, e);
        }), a(0, t, "_ColorA", function() {
            return this._albedoColor.w;
        }, function(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "enableReflection", function() {
            return this._shaderValues.getBool(PBRStandardMaterial.ENABLEREFLECT);
        }, function(e) {
            this._shaderValues.setBool(PBRStandardMaterial.ENABLEREFLECT, !0), e ? this._disablePublicDefineDatas.remove(qn.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(qn.SHADERDEFINE_REFLECTMAP);
        }), a(0, t, "_Metallic", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, e);
        }), a(0, t, "_BumpScale", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.NORMALSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.NORMALSCALE, e);
        }), a(0, t, "_OcclusionStrength", function() {
            return this._shaderValues.getNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH);
        }, function(e) {
            this._shaderValues.setNumber(PBRStandardMaterial.OCCLUSIONSTRENGTH, e);
        }), a(0, t, "_EmissionColorR", function() {
            return this._emissionColor.x;
        }, function(e) {
            this._emissionColor.x = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(PBRStandardMaterial.TILINGOFFSET, e);
        }), a(0, t, "_EmissionColorG", function() {
            return this._emissionColor.y;
        }, function(e) {
            this._emissionColor.y = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(PBRStandardMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "_EmissionColorB", function() {
            return this._emissionColor.z;
        }, function(e) {
            this._emissionColor.z = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "_EmissionColorA", function() {
            return this._emissionColor.w;
        }, function(e) {
            this._emissionColor.w = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "albedoColorA", function() {
            return this._ColorA;
        }, function(e) {
            this._ColorA = e;
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "_Cutoff", function() {
            return this.alphaTestValue;
        }, function(e) {
            this.alphaTestValue = e;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRStandardMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "albedoColorR", function() {
            return this._ColorR;
        }, function(e) {
            this._ColorR = e;
        }), a(0, t, "albedoColorG", function() {
            return this._ColorG;
        }, function(e) {
            this._ColorG = e;
        }), a(0, t, "albedoColorB", function() {
            return this._ColorB;
        }, function(e) {
            this._ColorB = e;
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "albedoColor", function() {
            return this._albedoColor;
        }, function(e) {
            this._albedoColor = e, this._shaderValues.setVector(PBRStandardMaterial.ALBEDOCOLOR, e);
        }), a(0, t, "albedoTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.ALBEDOTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.ALBEDOTEXTURE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(PBRStandardMaterial.CULL, e);
        }), a(0, t, "parallaxTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.PARALLAXTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.PARALLAXTEXTURE, e);
        }), a(0, t, "normalTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.NORMALTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.NORMALTEXTURE, e);
        }), a(0, t, "emissionColor", function() {
            return this._shaderValues.getVector(PBRStandardMaterial.EMISSIONCOLOR);
        }, function(e) {
            this._shaderValues.setVector(PBRStandardMaterial.EMISSIONCOLOR, e);
        }), a(0, t, "parallaxTextureScale", function() {
            return this._Parallax;
        }, function(e) {
            this._Parallax = Math.max(.005, Math.min(.08, e));
        }), a(0, t, "normalTextureScale", function() {
            return this._BumpScale;
        }, function(e) {
            this._BumpScale = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "occlusionTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.OCCLUSIONTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.OCCLUSIONTEXTURE, e);
        }), a(0, t, "occlusionTextureStrength", function() {
            return this._OcclusionStrength;
        }, function(e) {
            this._OcclusionStrength = Math.max(0, Math.min(1, e));
        }), a(0, t, "enableEmission", function() {
            return this._shaderValues.getBool(PBRStandardMaterial.ENABLEEMISSION);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSION), 
            this._shaderValues.setBool(PBRStandardMaterial.ENABLEEMISSION, e);
        }), a(0, t, "metallicGlossTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, e);
        }), a(0, t, "emissionColorA", function() {
            return this._EmissionColorA;
        }, function(e) {
            this._EmissionColorA = e;
        }), a(0, t, "smoothness", function() {
            return this._Glossiness;
        }, function(e) {
            this._Glossiness = Math.max(0, Math.min(1, e));
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(PBRStandardMaterial.BLEND_DST, e);
        }), a(0, t, "smoothnessTextureScale", function() {
            return this._GlossMapScale;
        }, function(e) {
            this._GlossMapScale = Math.max(0, Math.min(1, e));
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(PBRStandardMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(PBRStandardMaterial.DEPTH_WRITE, e);
        }), a(0, t, "smoothnessSource", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.SMOOTHNESSSOURCE);
        }, function(e) {
            e ? (this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
            this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 1)) : (this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
            this._shaderValues.setInt(PBRStandardMaterial.SMOOTHNESSSOURCE, 0));
        }), a(0, t, "emissionColorR", function() {
            return this._EmissionColorR;
        }, function(e) {
            this._EmissionColorR = e;
        }), a(0, t, "emissionColorG", function() {
            return this._EmissionColorG;
        }, function(e) {
            this._EmissionColorG = e;
        }), a(0, t, "emissionColorB", function() {
            return this._EmissionColorB;
        }, function(e) {
            this._EmissionColorB = e;
        }), a(0, t, "emissionTexture", function() {
            return this._shaderValues.getTexture(PBRStandardMaterial.EMISSIONTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE), 
            this._shaderValues.setTexture(PBRStandardMaterial.EMISSIONTEXTURE, e);
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 0:
                this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 1:
                this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 2:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513, 
                this._defineDatas.remove(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 3:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 1, this.blendDst = 771, this.depthTest = 513, this._defineDatas.add(PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              default:
                throw new Error("PBRSpecularMaterial : renderMode value error.");
            }
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(PBRStandardMaterial.BLEND, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(PBRStandardMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(PBRStandardMaterial.DEPTH_TEST, e);
        }), PBRStandardMaterial.__init__ = function() {
            PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("METALLICGLOSSTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRStandardMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"), 
            PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("NORMALTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_EMISSION = PBRStandardMaterial.shaderDefines.registerDefine("EMISSION"), 
            PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRStandardMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE"), 
            PBRStandardMaterial.SHADERDEFINE_REFLECTMAP = PBRStandardMaterial.shaderDefines.registerDefine("REFLECTMAP"), 
            PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET = PBRStandardMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRStandardMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
        }, PBRStandardMaterial.SmoothnessSource_MetallicGlossTexture_Alpha = 0, PBRStandardMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1, 
        PBRStandardMaterial.RENDERMODE_OPAQUE = 0, PBRStandardMaterial.RENDERMODE_CUTOUT = 1, 
        PBRStandardMaterial.RENDERMODE_FADE = 2, PBRStandardMaterial.RENDERMODE_TRANSPARENT = 3, 
        PBRStandardMaterial.SHADERDEFINE_ALBEDOTEXTURE = 0, PBRStandardMaterial.SHADERDEFINE_NORMALTEXTURE = 0, 
        PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = 0, PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = 0, 
        PBRStandardMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = 0, PBRStandardMaterial.SHADERDEFINE_PARALLAXTEXTURE = 0, 
        PBRStandardMaterial.SHADERDEFINE_EMISSION = 0, PBRStandardMaterial.SHADERDEFINE_EMISSIONTEXTURE = 0, 
        PBRStandardMaterial.SHADERDEFINE_REFLECTMAP = 0, PBRStandardMaterial.SHADERDEFINE_TILINGOFFSET = 0, 
        PBRStandardMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = 0, PBRStandardMaterial.SMOOTHNESSSOURCE = -1, 
        PBRStandardMaterial.ENABLEEMISSION = -1, PBRStandardMaterial.ENABLEREFLECT = -1, 
        i(PBRStandardMaterial, [ "ALBEDOTEXTURE", function() {
            return this.ALBEDOTEXTURE = Ve.propertyNameToID("u_AlbedoTexture");
        }, "METALLICGLOSSTEXTURE", function() {
            return this.METALLICGLOSSTEXTURE = Ve.propertyNameToID("u_MetallicGlossTexture");
        }, "NORMALTEXTURE", function() {
            return this.NORMALTEXTURE = Ve.propertyNameToID("u_NormalTexture");
        }, "PARALLAXTEXTURE", function() {
            return this.PARALLAXTEXTURE = Ve.propertyNameToID("u_ParallaxTexture");
        }, "OCCLUSIONTEXTURE", function() {
            return this.OCCLUSIONTEXTURE = Ve.propertyNameToID("u_OcclusionTexture");
        }, "EMISSIONTEXTURE", function() {
            return this.EMISSIONTEXTURE = Ve.propertyNameToID("u_EmissionTexture");
        }, "ALBEDOCOLOR", function() {
            return this.ALBEDOCOLOR = Ve.propertyNameToID("u_AlbedoColor");
        }, "EMISSIONCOLOR", function() {
            return this.EMISSIONCOLOR = Ve.propertyNameToID("u_EmissionColor");
        }, "METALLIC", function() {
            return this.METALLIC = Ve.propertyNameToID("u_metallic");
        }, "SMOOTHNESS", function() {
            return this.SMOOTHNESS = Ve.propertyNameToID("u_smoothness");
        }, "SMOOTHNESSSCALE", function() {
            return this.SMOOTHNESSSCALE = Ve.propertyNameToID("u_smoothnessScale");
        }, "OCCLUSIONSTRENGTH", function() {
            return this.OCCLUSIONSTRENGTH = Ve.propertyNameToID("u_occlusionStrength");
        }, "NORMALSCALE", function() {
            return this.NORMALSCALE = Ve.propertyNameToID("u_normalScale");
        }, "PARALLAXSCALE", function() {
            return this.PARALLAXSCALE = Ve.propertyNameToID("u_parallaxScale");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new PBRStandardMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), PBRStandardMaterial;
    }(Fn), si = function(e) {
        function ShurikenParticleMaterial() {
            ShurikenParticleMaterial.__super.call(this), this.setShaderName("PARTICLESHURIKEN"), 
            this._color = new me(1, 1, 1, 1), this.renderMode = 0;
        }
        r(ShurikenParticleMaterial, "laya.d3.core.particleShuriKen.ShurikenParticleMaterial", Fn);
        var t = ShurikenParticleMaterial.prototype;
        return a(0, t, "_TintColorB", function() {
            return this._color.z;
        }, function(e) {
            this._color.z = e, this.color = this._color;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "texture", function() {
            return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP), 
            this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, e);
        }), a(0, t, "_TintColorR", function() {
            return this._color.x;
        }, function(e) {
            this._color.x = e, this.color = this._color;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "_TintColorG", function() {
            return this._color.y;
        }, function(e) {
            this._color.y = e, this.color = this._color;
        }), a(0, t, "_TintColorA", function() {
            return this._color.w;
        }, function(e) {
            this._color.w = e, this.color = this._color;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 1:
                this.renderQueue = 3e3, this.depthWrite = !1, this.cull = 0, this.blend = 1, this.blendSrc = 770, 
                this.blendDst = 1, this.alphaTest = !1, this._defineDatas.add(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              case 0:
                this.renderQueue = 3e3, this.depthWrite = !1, this.cull = 0, this.blend = 1, this.blendSrc = 770, 
                this.blendDst = 771, this.alphaTest = !1, this._defineDatas.remove(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("ShurikenParticleMaterial : renderMode value error.");
            }
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "colorR", function() {
            return this._TintColorR;
        }, function(e) {
            this._TintColorR = e;
        }), a(0, t, "colorG", function() {
            return this._TintColorG;
        }, function(e) {
            this._TintColorG = e;
        }), a(0, t, "colorB", function() {
            return this._TintColorB;
        }, function(e) {
            this._TintColorB = e;
        }), a(0, t, "colorA", function() {
            return this._TintColorA;
        }, function(e) {
            this._TintColorA = e;
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, e);
        }), a(0, t, "color", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR), 
            this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, e);
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.particleShuriKen.ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(ShurikenParticleMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(ShurikenParticleMaterial.CULL, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, e);
        }), ShurikenParticleMaterial.__init__ = function() {
            ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = ShurikenParticleMaterial.shaderDefines.registerDefine("DIFFUSEMAP"), 
            ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = ShurikenParticleMaterial.shaderDefines.registerDefine("TINTCOLOR"), 
            ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = ShurikenParticleMaterial.shaderDefines.registerDefine("ADDTIVEFOG"), 
            ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = ShurikenParticleMaterial.shaderDefines.registerDefine("TILINGOFFSET");
        }, ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED = 0, ShurikenParticleMaterial.RENDERMODE_ADDTIVE = 1, 
        ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = 0, ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = 0, 
        ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = 0, ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = 0, 
        i(ShurikenParticleMaterial, [ "DIFFUSETEXTURE", function() {
            return this.DIFFUSETEXTURE = Ve.propertyNameToID("u_texture");
        }, "TINTCOLOR", function() {
            return this.TINTCOLOR = Ve.propertyNameToID("u_Tintcolor");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new ShurikenParticleMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), ShurikenParticleMaterial;
    }(), li = function(e) {
        function EffectMaterial() {
            this._color = null, EffectMaterial.__super.call(this), this.setShaderName("Effect"), 
            this._color = new me(1, 1, 1, 1), this._shaderValues.setVector(EffectMaterial.TINTCOLOR, new me(1, 1, 1, 1)), 
            this.renderMode = 0;
        }
        r(EffectMaterial, "laya.d3.core.material.EffectMaterial", Fn);
        var t = EffectMaterial.prototype;
        return a(0, t, "_TintColorB", function() {
            return this._color.z;
        }, function(e) {
            this._color.z = e, this.color = this._color;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "texture", function() {
            return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, e);
        }), a(0, t, "_TintColorR", function() {
            return this._color.x;
        }, function(e) {
            this._color.x = e, this.color = this._color;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "_TintColorG", function() {
            return this._color.y;
        }, function(e) {
            this._color.y = e, this.color = this._color;
        }), a(0, t, "_TintColorA", function() {
            return this._color.w;
        }, function(e) {
            this._color.w = e, this.color = this._color;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 0:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 1, this.depthTest = 513, this._defineDatas.add(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              case 1:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 0, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513, 
                this._defineDatas.remove(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                break;

              default:
                throw new Error("MeshEffectMaterial : renderMode value error.");
            }
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "colorR", function() {
            return this._TintColorR;
        }, function(e) {
            this._TintColorR = e;
        }), a(0, t, "colorG", function() {
            return this._TintColorG;
        }, function(e) {
            this._TintColorG = e;
        }), a(0, t, "colorB", function() {
            return this._TintColorB;
        }, function(e) {
            this._TintColorB = e;
        }), a(0, t, "colorA", function() {
            return this._TintColorA;
        }, function(e) {
            this._TintColorA = e;
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(EffectMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(EffectMaterial.BLEND, e);
        }), a(0, t, "color", function() {
            return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
        }, function(e) {
            this._shaderValues.setVector(EffectMaterial.TINTCOLOR, e);
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(EffectMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(EffectMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.EffectMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(EffectMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(EffectMaterial.CULL, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(EffectMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(EffectMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, e);
        }), EffectMaterial.__init__ = function() {
            EffectMaterial.SHADERDEFINE_MAINTEXTURE = EffectMaterial.shaderDefines.registerDefine("MAINTEXTURE"), 
            EffectMaterial.SHADERDEFINE_TILINGOFFSET = EffectMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            EffectMaterial.SHADERDEFINE_ADDTIVEFOG = EffectMaterial.shaderDefines.registerDefine("ADDTIVEFOG");
        }, EffectMaterial.RENDERMODE_ADDTIVE = 0, EffectMaterial.RENDERMODE_ALPHABLENDED = 1, 
        EffectMaterial.SHADERDEFINE_MAINTEXTURE = 0, EffectMaterial.SHADERDEFINE_TILINGOFFSET = 0, 
        EffectMaterial.SHADERDEFINE_ADDTIVEFOG = 0, i(EffectMaterial, [ "defaultMaterial", function() {
            return this.defaultMaterial = new EffectMaterial();
        }, "MAINTEXTURE", function() {
            return this.MAINTEXTURE = Ve.propertyNameToID("u_AlbedoTexture");
        }, "TINTCOLOR", function() {
            return this.TINTCOLOR = Ve.propertyNameToID("u_AlbedoColor");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), EffectMaterial;
    }(), hi = function(e) {
        function WaterPrimaryMaterial() {
            WaterPrimaryMaterial.__super.call(this), this.setShaderName("WaterPrimary"), this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new me(.172, .463, .435, 0)), 
            this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15), this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new me(19, 9, -16, -7));
        }
        r(WaterPrimaryMaterial, "laya.d3.core.material.WaterPrimaryMaterial", Fn);
        var t = WaterPrimaryMaterial.prototype;
        return a(0, t, "waveSpeed", function() {
            return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
        }, function(e) {
            this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, e);
        }), a(0, t, "horizonColor", function() {
            return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
        }, function(e) {
            this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, e);
        }), a(0, t, "mainTexture", function() {
            return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE), 
            this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, e);
        }), a(0, t, "normalTexture", function() {
            return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE), 
            this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, e);
        }), a(0, t, "waveScale", function() {
            return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
        }, function(e) {
            this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, e);
        }), WaterPrimaryMaterial.__init__ = function() {
            WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("MAINTEXTURE"), 
            WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = WaterPrimaryMaterial.shaderDefines.registerDefine("NORMALTEXTURE");
        }, WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = 0, WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = 0, 
        i(WaterPrimaryMaterial, [ "HORIZONCOLOR", function() {
            return this.HORIZONCOLOR = Ve.propertyNameToID("u_HorizonColor");
        }, "MAINTEXTURE", function() {
            return this.MAINTEXTURE = Ve.propertyNameToID("u_MainTexture");
        }, "NORMALTEXTURE", function() {
            return this.NORMALTEXTURE = Ve.propertyNameToID("u_NormalTexture");
        }, "WAVESCALE", function() {
            return this.WAVESCALE = Ve.propertyNameToID("u_WaveScale");
        }, "WAVESPEED", function() {
            return this.WAVESPEED = Ve.propertyNameToID("u_WaveSpeed");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new WaterPrimaryMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), WaterPrimaryMaterial;
    }(), ui = function(e) {
        function ExtendTerrainMaterial() {
            this._enableLighting = !0, ExtendTerrainMaterial.__super.call(this), this.setShaderName("ExtendTerrain"), 
            this.renderMode = 1;
        }
        r(ExtendTerrainMaterial, "laya.d3.core.material.ExtendTerrainMaterial", Fn);
        var t = ExtendTerrainMaterial.prototype;
        return t._setDetailNum = function(e) {
            switch (e) {
              case 1:
                this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 2:
                this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 3:
                this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 4:
                this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                break;

              case 5:
                this._defineDatas.add(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
            }
        }, a(0, t, "diffuseScaleOffset2", null, function(e) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, e);
        }), a(0, t, "splatAlphaTexture", function() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
        }, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, e);
        }), a(0, t, "diffuseScaleOffset3", null, function(e) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, e);
        }), a(0, t, "diffuseTexture1", null, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, e), this._setDetailNum(1);
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 1:
                this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, this.blend = 0, this.depthTest = 513;
                break;

              case 2:
                this.renderQueue = 2e3, this.depthWrite = !1, this.cull = 2, this.blend = 1, this.blendSrc = 770, 
                this.blendDst = 771, this.depthTest = 515;
                break;

              default:
                throw new Error("ExtendTerrainMaterial:renderMode value error.");
            }
        }), a(0, t, "diffuseTexture2", function() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
        }, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, e), this._setDetailNum(2);
        }), a(0, t, "diffuseScaleOffset1", null, function(e) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, e);
        }), a(0, t, "diffuseTexture3", function() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
        }, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, e), this._setDetailNum(3);
        }), a(0, t, "diffuseTexture4", function() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
        }, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, e), this._setDetailNum(4);
        }), a(0, t, "diffuseTexture5", function() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
        }, function(e) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, e), this._setDetailNum(5);
        }), a(0, t, "diffuseScaleOffset4", null, function(e) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, e);
        }), a(0, t, "diffuseScaleOffset5", null, function(e) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, e);
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, e);
        }), a(0, t, "enableLighting", function() {
            return this._enableLighting;
        }, function(e) {
            this._enableLighting !== e && (e ? this._disablePublicDefineDatas.remove(qn.SHADERDEFINE_POINTLIGHT | qn.SHADERDEFINE_SPOTLIGHT | qn.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(qn.SHADERDEFINE_POINTLIGHT | qn.SHADERDEFINE_SPOTLIGHT | qn.SHADERDEFINE_DIRECTIONLIGHT), 
            this._enableLighting = e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(ExtendTerrainMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(ExtendTerrainMaterial.CULL, e);
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, e);
        }), ExtendTerrainMaterial.__init__ = function() {
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1"), 
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2"), 
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3"), 
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4"), 
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = ExtendTerrainMaterial.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
        }, ExtendTerrainMaterial.RENDERMODE_OPAQUE = 1, ExtendTerrainMaterial.RENDERMODE_TRANSPARENT = 2, 
        ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = 0, ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = 0, 
        ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = 0, ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = 0, 
        ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = 0, i(ExtendTerrainMaterial, [ "SPLATALPHATEXTURE", function() {
            return this.SPLATALPHATEXTURE = Ve.propertyNameToID("u_SplatAlphaTexture");
        }, "DIFFUSETEXTURE1", function() {
            return this.DIFFUSETEXTURE1 = Ve.propertyNameToID("u_DiffuseTexture1");
        }, "DIFFUSETEXTURE2", function() {
            return this.DIFFUSETEXTURE2 = Ve.propertyNameToID("u_DiffuseTexture2");
        }, "DIFFUSETEXTURE3", function() {
            return this.DIFFUSETEXTURE3 = Ve.propertyNameToID("u_DiffuseTexture3");
        }, "DIFFUSETEXTURE4", function() {
            return this.DIFFUSETEXTURE4 = Ve.propertyNameToID("u_DiffuseTexture4");
        }, "DIFFUSETEXTURE5", function() {
            return this.DIFFUSETEXTURE5 = Ve.propertyNameToID("u_DiffuseTexture5");
        }, "DIFFUSESCALEOFFSET1", function() {
            return this.DIFFUSESCALEOFFSET1 = Ve.propertyNameToID("u_DiffuseScaleOffset1");
        }, "DIFFUSESCALEOFFSET2", function() {
            return this.DIFFUSESCALEOFFSET2 = Ve.propertyNameToID("u_DiffuseScaleOffset2");
        }, "DIFFUSESCALEOFFSET3", function() {
            return this.DIFFUSESCALEOFFSET3 = Ve.propertyNameToID("u_DiffuseScaleOffset3");
        }, "DIFFUSESCALEOFFSET4", function() {
            return this.DIFFUSESCALEOFFSET4 = Ve.propertyNameToID("u_DiffuseScaleOffset4");
        }, "DIFFUSESCALEOFFSET5", function() {
            return this.DIFFUSESCALEOFFSET5 = Ve.propertyNameToID("u_DiffuseScaleOffset5");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), ExtendTerrainMaterial;
    }(), ci = function(e) {
        function BlinnPhongMaterial() {
            this._enableVertexColor = !1, BlinnPhongMaterial.__super.call(this), this.setShaderName("BLINNPHONG"), 
            this._albedoIntensity = 1, this._albedoColor = new me(1, 1, 1, 1);
            var e = this._shaderValues;
            e.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new me(1, 1, 1, 1)), e.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new me(1, 1, 1, 1)), 
            e.setNumber(BlinnPhongMaterial.SHININESS, .078125), e.setNumber(Fn.ALPHATESTVALUE, .5), 
            e.setVector(BlinnPhongMaterial.TILINGOFFSET, new me(1, 1, 0, 0)), this._enableLighting = !0, 
            this.renderMode = 0;
        }
        r(BlinnPhongMaterial, "laya.d3.core.material.BlinnPhongMaterial", e);
        var t = BlinnPhongMaterial.prototype;
        return t.disableFog = function() {
            this._disablePublicDefineDatas.add(qn.SHADERDEFINE_FOG);
        }, t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            n._enableLighting = this._enableLighting, n._albedoIntensity = this._albedoIntensity, 
            n._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(n._albedoColor);
        }, a(0, t, "_SpecColorG", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y;
        }, function(e) {
            this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = e;
        }), a(0, t, "_ColorB", function() {
            return this._albedoColor.z;
        }, function(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorR", function() {
            return this._albedoColor.x;
        }, function(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "albedoColorA", function() {
            return this._ColorA;
        }, function(e) {
            this._ColorA = e;
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "_SpecColorB", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z;
        }, function(e) {
            this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = e;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 0:
                this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513;
                break;

              case 1:
                this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513;
                break;

              case 2:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513;
                break;

              default:
                throw new Error("Material:renderMode value error.");
            }
        }), a(0, t, "_SpecColorR", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x;
        }, function(e) {
            this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = e;
        }), a(0, t, "_ColorG", function() {
            return this._albedoColor.y;
        }, function(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorA", function() {
            return this._albedoColor.w;
        }, function(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "specularColor", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
        }, function(e) {
            this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, e);
        }), a(0, t, "albedoColorB", function() {
            return this._ColorB;
        }, function(e) {
            this._ColorB = e;
        }), a(0, t, "_SpecColorA", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w;
        }, function(e) {
            this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = e;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "_AlbedoIntensity", function() {
            return this._albedoIntensity;
        }, function(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                me.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
            }
        }), a(0, t, "specularColorA", function() {
            return this._SpecColorA;
        }, function(e) {
            this._SpecColorA = e;
        }), a(0, t, "_Shininess", function() {
            return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
        }, function(e) {
            e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, e);
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "_Cutoff", function() {
            return this.alphaTestValue;
        }, function(e) {
            this.alphaTestValue = e;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "albedoTexture", function() {
            return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP), 
            this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, e);
        }), a(0, t, "enableVertexColor", function() {
            return this._enableVertexColor;
        }, function(e) {
            this._enableVertexColor = e, e ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }), a(0, t, "albedoColor", function() {
            return this._albedoColor;
        }, function(e) {
            var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
            me.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, e);
        }), a(0, t, "enableLighting", function() {
            return this._enableLighting;
        }, function(e) {
            this._enableLighting !== e && (e ? this._disablePublicDefineDatas.remove(qn.SHADERDEFINE_POINTLIGHT | qn.SHADERDEFINE_SPOTLIGHT | qn.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(qn.SHADERDEFINE_POINTLIGHT | qn.SHADERDEFINE_SPOTLIGHT | qn.SHADERDEFINE_DIRECTIONLIGHT), 
            this._enableLighting = e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, e);
        }), a(0, t, "albedoColorR", function() {
            return this._ColorR;
        }, function(e) {
            this._ColorR = e;
        }), a(0, t, "albedoColorG", function() {
            return this._ColorG;
        }, function(e) {
            this._ColorG = e;
        }), a(0, t, "albedoIntensity", function() {
            return this._albedoIntensity;
        }, function(e) {
            this._AlbedoIntensity = e;
        }), a(0, t, "specularColorR", function() {
            return this._SpecColorR;
        }, function(e) {
            this._SpecColorR = e;
        }), a(0, t, "specularColorG", function() {
            return this._SpecColorG;
        }, function(e) {
            this._SpecColorG = e;
        }), a(0, t, "specularColorB", function() {
            return this._SpecColorB;
        }, function(e) {
            this._SpecColorB = e;
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, e);
        }), a(0, t, "shininess", function() {
            return this._Shininess;
        }, function(e) {
            this._Shininess = e;
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(BlinnPhongMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(BlinnPhongMaterial.CULL, e);
        }), a(0, t, "normalTexture", function() {
            return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_NORMALMAP), 
            this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, e);
        }), a(0, t, "specularTexture", function() {
            return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._defineDatas.remove(laya.d3.core.material.BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP), 
            this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, e);
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(BlinnPhongMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(BlinnPhongMaterial.BLEND, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, e);
        }), BlinnPhongMaterial.__init__ = function() {
            BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = BlinnPhongMaterial.shaderDefines.registerDefine("DIFFUSEMAP"), 
            BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = BlinnPhongMaterial.shaderDefines.registerDefine("NORMALMAP"), 
            BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = BlinnPhongMaterial.shaderDefines.registerDefine("SPECULARMAP"), 
            BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = BlinnPhongMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = BlinnPhongMaterial.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
        }, BlinnPhongMaterial.SPECULARSOURCE_DIFFUSEMAPALPHA = 0, BlinnPhongMaterial.SPECULARSOURCE_SPECULARMAP = 0, 
        BlinnPhongMaterial.RENDERMODE_OPAQUE = 0, BlinnPhongMaterial.RENDERMODE_CUTOUT = 1, 
        BlinnPhongMaterial.RENDERMODE_TRANSPARENT = 2, BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = 0, 
        BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = 0, BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = 0, 
        BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = 0, BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = 0, 
        i(BlinnPhongMaterial, [ "ALBEDOTEXTURE", function() {
            return this.ALBEDOTEXTURE = Ve.propertyNameToID("u_DiffuseTexture");
        }, "NORMALTEXTURE", function() {
            return this.NORMALTEXTURE = Ve.propertyNameToID("u_NormalTexture");
        }, "SPECULARTEXTURE", function() {
            return this.SPECULARTEXTURE = Ve.propertyNameToID("u_SpecularTexture");
        }, "ALBEDOCOLOR", function() {
            return this.ALBEDOCOLOR = Ve.propertyNameToID("u_DiffuseColor");
        }, "MATERIALSPECULAR", function() {
            return this.MATERIALSPECULAR = Ve.propertyNameToID("u_MaterialSpecular");
        }, "SHININESS", function() {
            return this.SHININESS = Ve.propertyNameToID("u_Shininess");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new BlinnPhongMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), BlinnPhongMaterial;
    }(Fn), di = function(e) {
        function TerrainMaterial() {
            this._diffuseScale1 = null, this._diffuseScale2 = null, this._diffuseScale3 = null, 
            this._diffuseScale4 = null, TerrainMaterial.__super.call(this), this.setShaderName("Terrain"), 
            this.renderMode = 1, this._diffuseScale1 = new Se(), this._diffuseScale2 = new Se(), 
            this._diffuseScale3 = new Se(), this._diffuseScale4 = new Se(), this.ambientColor = new Te(.6, .6, .6), 
            this.diffuseColor = new Te(1, 1, 1), this.specularColor = new me(.2, .2, .2, 32);
        }
        r(TerrainMaterial, "laya.d3.core.material.TerrainMaterial", e);
        var t = TerrainMaterial.prototype;
        return t.setDiffuseScale1 = function(e, t) {
            this._diffuseScale1.x = e, this._diffuseScale1.y = t, this._shaderValues.setVector2(6, this._diffuseScale1);
        }, t.setDiffuseScale2 = function(e, t) {
            this._diffuseScale2.x = e, this._diffuseScale2.y = t, this._shaderValues.setVector2(7, this._diffuseScale2);
        }, t.setDiffuseScale3 = function(e, t) {
            this._diffuseScale3.x = e, this._diffuseScale3.y = t, this._shaderValues.setVector2(8, this._diffuseScale3);
        }, t.setDiffuseScale4 = function(e, t) {
            this._diffuseScale4.x = e, this._diffuseScale4.y = t, this._shaderValues.setVector2(9, this._diffuseScale4);
        }, t.setDetailNum = function(e) {
            switch (e) {
              case 1:
                this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                break;

              case 2:
                this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                break;

              case 3:
                this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                break;

              case 4:
                this._defineDatas.add(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM4), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM1), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM2), 
                this._defineDatas.remove(laya.d3.core.material.TerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
            }
        }, t.disableLight = function() {
            this._disablePublicDefineDatas.add(qn.SHADERDEFINE_POINTLIGHT | qn.SHADERDEFINE_SPOTLIGHT | qn.SHADERDEFINE_DIRECTIONLIGHT);
        }, t.setShaderName = function(t) {
            e.prototype.setShaderName.call(this, t);
        }, a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 1:
                this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, this.blend = 0, this.depthTest = 513;
                break;

              case 2:
                this.renderQueue = 2e3, this.depthWrite = !1, this.cull = 2, this.blend = 1, this.blendSrc = 770, 
                this.blendDst = 771, this.depthTest = 515;
                break;

              default:
                throw new Error("TerrainMaterial:renderMode value error.");
            }
        }), a(0, t, "diffuseTexture2", function() {
            return this._shaderValues.getTexture(3);
        }, function(e) {
            this._shaderValues.setTexture(3, e);
        }), a(0, t, "ambientColor", function() {
            return this._shaderValues.getVector(10);
        }, function(e) {
            this._shaderValues.setVector3(10, e);
        }), a(0, t, "diffuseTexture4", function() {
            return this._shaderValues.getTexture(5);
        }, function(e) {
            this._shaderValues.setTexture(5, e);
        }), a(0, t, "diffuseColor", function() {
            return this._shaderValues.getVector(11);
        }, function(e) {
            this._shaderValues.setVector3(11, e);
        }), a(0, t, "diffuseTexture1", function() {
            return this._shaderValues.getTexture(2);
        }, function(e) {
            this._shaderValues.setTexture(2, e);
        }), a(0, t, "specularColor", function() {
            return this._shaderValues.getVector(12);
        }, function(e) {
            this._shaderValues.setVector(12, e);
        }), a(0, t, "diffuseTexture3", function() {
            return this._shaderValues.getTexture(4);
        }, function(e) {
            this._shaderValues.setTexture(4, e);
        }), a(0, t, "splatAlphaTexture", function() {
            return this._shaderValues.getTexture(0);
        }, function(e) {
            this._shaderValues.setTexture(0, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(TerrainMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(TerrainMaterial.CULL, e);
        }), a(0, t, "normalTexture", function() {
            return this._shaderValues.getTexture(1);
        }, function(e) {
            this._shaderValues.setTexture(1, e);
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(TerrainMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(TerrainMaterial.DEPTH_WRITE, e);
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(TerrainMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(TerrainMaterial.BLEND, e);
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(TerrainMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(TerrainMaterial.BLEND_SRC, e);
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(TerrainMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(TerrainMaterial.BLEND_DST, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(TerrainMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(TerrainMaterial.DEPTH_TEST, e);
        }), TerrainMaterial.__init__ = function() {
            TerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM1"), 
            TerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM2"), 
            TerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM4"), 
            TerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = TerrainMaterial.shaderDefines.registerDefine("DETAIL_NUM3");
        }, TerrainMaterial.RENDERMODE_OPAQUE = 1, TerrainMaterial.RENDERMODE_TRANSPARENT = 2, 
        TerrainMaterial.SPLATALPHATEXTURE = 0, TerrainMaterial.NORMALTEXTURE = 1, TerrainMaterial.DIFFUSETEXTURE1 = 2, 
        TerrainMaterial.DIFFUSETEXTURE2 = 3, TerrainMaterial.DIFFUSETEXTURE3 = 4, TerrainMaterial.DIFFUSETEXTURE4 = 5, 
        TerrainMaterial.DIFFUSESCALE1 = 6, TerrainMaterial.DIFFUSESCALE2 = 7, TerrainMaterial.DIFFUSESCALE3 = 8, 
        TerrainMaterial.DIFFUSESCALE4 = 9, TerrainMaterial.MATERIALAMBIENT = 10, TerrainMaterial.MATERIALDIFFUSE = 11, 
        TerrainMaterial.MATERIALSPECULAR = 12, TerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = 0, 
        TerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = 0, TerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = 0, 
        TerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = 0, i(TerrainMaterial, [ "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new TerrainMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), TerrainMaterial;
    }(Fn), _i = function(e) {
        function SkyBoxMaterial() {
            SkyBoxMaterial.__super.call(this), this.setShaderName("SkyBox");
        }
        r(SkyBoxMaterial, "laya.d3.core.material.SkyBoxMaterial", Fn);
        var t = SkyBoxMaterial.prototype;
        return a(0, t, "tintColor", function() {
            return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
        }, function(e) {
            this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, e);
        }), a(0, t, "exposure", function() {
            return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
        }, function(e) {
            this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, e);
        }), a(0, t, "rotation", function() {
            return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
        }, function(e) {
            this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, e);
        }), a(0, t, "textureCube", function() {
            return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
        }, function(e) {
            this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, e);
        }), i(SkyBoxMaterial, [ "TINTCOLOR", function() {
            return this.TINTCOLOR = Ve.propertyNameToID("u_TintColor");
        }, "EXPOSURE", function() {
            return this.EXPOSURE = Ve.propertyNameToID("u_Exposure");
        }, "ROTATION", function() {
            return this.ROTATION = Ve.propertyNameToID("u_Rotation");
        }, "TEXTURECUBE", function() {
            return this.TEXTURECUBE = Ve.propertyNameToID("u_CubeTexture");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new SkyBoxMaterial();
        } ]), SkyBoxMaterial;
    }(), fi = function(e) {
        function PBRSpecularMaterial() {
            this._albedoColor = null, this._specularColor = null, this._emissionColor = null, 
            PBRSpecularMaterial.__super.call(this), this.setShaderName("PBRSpecular"), this._albedoColor = new me(1, 1, 1, 1), 
            this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, new me(1, 1, 1, 1)), 
            this._emissionColor = new me(0, 0, 0, 0), this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, new me(0, 0, 0, 0)), 
            this._specularColor = new me(.2, .2, .2, .2), this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new me(.2, .2, .2, .2)), 
            this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, .5), this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, 1), 
            this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0), this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, 1), 
            this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, 1), this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, .001), 
            this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, !1), this._shaderValues.setNumber(Fn.ALPHATESTVALUE, .5), 
            this.renderMode = 0;
        }
        r(PBRSpecularMaterial, "laya.d3.core.material.PBRSpecularMaterial", e);
        var t = PBRSpecularMaterial.prototype;
        return t.cloneTo = function(t) {
            e.prototype.cloneTo.call(this, t);
            var n = t;
            this._albedoColor.cloneTo(n._albedoColor), this._specularColor.cloneTo(n._specularColor), 
            this._emissionColor.cloneTo(n._emissionColor);
        }, a(0, t, "emissionTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.EMISSIONTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.EMISSIONTEXTURE, e);
        }), a(0, t, "_SpecColorG", function() {
            return this._specularColor.y;
        }, function(e) {
            this._specularColor.y = e, this.specularColor = this._specularColor;
        }), a(0, t, "_ColorB", function() {
            return this._albedoColor.z;
        }, function(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_ColorR", function() {
            return this._albedoColor.x;
        }, function(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "albedoColorA", function() {
            return this._ColorA;
        }, function(e) {
            this._ColorA = e;
        }), a(0, t, "_MainTex_STX", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).x;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }), a(0, t, "_SpecColorB", function() {
            return this._specularColor.z;
        }, function(e) {
            this._specularColor.z = e, this.specularColor = this._specularColor;
        }), a(0, t, "renderMode", null, function(e) {
            switch (e) {
              case 0:
                this.alphaTest = !1, this.renderQueue = 2e3, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 1:
                this.renderQueue = 2450, this.alphaTest = !0, this.depthWrite = !0, this.cull = 2, 
                this.blend = 0, this.depthTest = 513, this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 2:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 770, this.blendDst = 771, this.depthTest = 513, 
                this._defineDatas.remove(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              case 3:
                this.renderQueue = 3e3, this.alphaTest = !1, this.depthWrite = !1, this.cull = 2, 
                this.blend = 1, this.blendSrc = 1, this.blendDst = 771, this.depthTest = 513, this._defineDatas.add(PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY);
                break;

              default:
                throw new Error("PBRSpecularMaterial : renderMode value error.");
            }
        }), a(0, t, "_SpecColorR", function() {
            return this._specularColor.x;
        }, function(e) {
            this._specularColor.x = e, this.specularColor = this._specularColor;
        }), a(0, t, "_ColorG", function() {
            return this._albedoColor.y;
        }, function(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "_Glossiness", function() {
            return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESS);
        }, function(e) {
            this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESS, e);
        }), a(0, t, "_ColorA", function() {
            return this._albedoColor.w;
        }, function(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }), a(0, t, "specularColor", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
        }, function(e) {
            this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, e);
        }), a(0, t, "albedoColorB", function() {
            return this._ColorB;
        }, function(e) {
            this._ColorB = e;
        }), a(0, t, "_SpecColorA", function() {
            return this._specularColor.w;
        }, function(e) {
            this._specularColor.w = e, this.specularColor = this._specularColor;
        }), a(0, t, "_GlossMapScale", function() {
            return this._shaderValues.getNumber(PBRSpecularMaterial.SMOOTHNESSSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRSpecularMaterial.SMOOTHNESSSCALE, e);
        }), a(0, t, "_BumpScale", function() {
            return this._shaderValues.getNumber(PBRSpecularMaterial.NORMALSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRSpecularMaterial.NORMALSCALE, e);
        }), a(0, t, "_Parallax", function() {
            return this._shaderValues.getNumber(PBRSpecularMaterial.PARALLAXSCALE);
        }, function(e) {
            this._shaderValues.setNumber(PBRSpecularMaterial.PARALLAXSCALE, e);
        }), a(0, t, "_OcclusionStrength", function() {
            return this._shaderValues.getNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH);
        }, function(e) {
            this._shaderValues.setNumber(PBRSpecularMaterial.OCCLUSIONSTRENGTH, e);
        }), a(0, t, "_EmissionColorR", function() {
            return this._emissionColor.x;
        }, function(e) {
            this._emissionColor.x = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "tilingOffset", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
        }, function(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET), 
            this._shaderValues.setVector(PBRSpecularMaterial.TILINGOFFSET, e);
        }), a(0, t, "_EmissionColorG", function() {
            return this._emissionColor.y;
        }, function(e) {
            this._emissionColor.y = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "blendSrc", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_SRC);
        }, function(e) {
            this._shaderValues.setInt(PBRSpecularMaterial.BLEND_SRC, e);
        }), a(0, t, "tilingOffsetW", function() {
            return this._MainTex_STW;
        }, function(e) {
            this._MainTex_STW = e;
        }), a(0, t, "_EmissionColorB", function() {
            return this._emissionColor.z;
        }, function(e) {
            this._emissionColor.z = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "_EmissionColorA", function() {
            return this._emissionColor.w;
        }, function(e) {
            this._emissionColor.w = e, this.emissionColor = this._emissionColor;
        }), a(0, t, "_MainTex_STY", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).y;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }), a(0, t, "_MainTex_STZ", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).z;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }), a(0, t, "_Cutoff", function() {
            return this.alphaTestValue;
        }, function(e) {
            this.alphaTestValue = e;
        }), a(0, t, "_MainTex_STW", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET).w;
        }, function(e) {
            var t = this._shaderValues.getVector(PBRSpecularMaterial.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }), a(0, t, "albedoColorR", function() {
            return this._ColorR;
        }, function(e) {
            this._ColorR = e;
        }), a(0, t, "albedoColorG", function() {
            return this._ColorG;
        }, function(e) {
            this._ColorG = e;
        }), a(0, t, "tilingOffsetX", function() {
            return this._MainTex_STX;
        }, function(e) {
            this._MainTex_STX = e;
        }), a(0, t, "albedoColor", function() {
            return this._albedoColor;
        }, function(e) {
            this._albedoColor = e, this._shaderValues.setVector(PBRSpecularMaterial.ALBEDOCOLOR, e);
        }), a(0, t, "albedoTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.ALBEDOTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.ALBEDOTEXTURE, e);
        }), a(0, t, "cull", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.CULL);
        }, function(e) {
            this._shaderValues.setInt(PBRSpecularMaterial.CULL, e);
        }), a(0, t, "parallaxTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.PARALLAXTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.PARALLAXTEXTURE, e);
        }), a(0, t, "normalTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.NORMALTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.NORMALTEXTURE, e);
        }), a(0, t, "emissionColor", function() {
            return this._shaderValues.getVector(PBRSpecularMaterial.EMISSIONCOLOR);
        }, function(e) {
            this._shaderValues.setVector(PBRSpecularMaterial.EMISSIONCOLOR, e);
        }), a(0, t, "parallaxTextureScale", function() {
            return this._Parallax;
        }, function(e) {
            this._Parallax = Math.max(.005, Math.min(.08, e));
        }), a(0, t, "normalTextureScale", function() {
            return this._BumpScale;
        }, function(e) {
            this._BumpScale = e;
        }), a(0, t, "tilingOffsetZ", function() {
            return this._MainTex_STZ;
        }, function(e) {
            this._MainTex_STZ = e;
        }), a(0, t, "occlusionTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.OCCLUSIONTEXTURE, e);
        }), a(0, t, "occlusionTextureStrength", function() {
            return this._OcclusionStrength;
        }, function(e) {
            this._OcclusionStrength = Math.max(0, Math.min(1, e));
        }), a(0, t, "specularTexture", function() {
            return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE), 
            this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, e);
        }), a(0, t, "specularColorR", function() {
            return this._SpecColorR;
        }, function(e) {
            this._SpecColorR = e;
        }), a(0, t, "smoothness", function() {
            return this._Glossiness;
        }, function(e) {
            this._Glossiness = Math.max(0, Math.min(1, e));
        }), a(0, t, "specularColorG", function() {
            return this._SpecColorG;
        }, function(e) {
            this._SpecColorG = e;
        }), a(0, t, "specularColorB", function() {
            return this._SpecColorB;
        }, function(e) {
            this._SpecColorB = e;
        }), a(0, t, "specularColorA", function() {
            return this._SpecColorA;
        }, function(e) {
            this._SpecColorA = e;
        }), a(0, t, "blendDst", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.BLEND_DST);
        }, function(e) {
            this._shaderValues.setInt(PBRSpecularMaterial.BLEND_DST, e);
        }), a(0, t, "smoothnessTextureScale", function() {
            return this._GlossMapScale;
        }, function(e) {
            this._GlossMapScale = Math.max(0, Math.min(1, e));
        }), a(0, t, "depthWrite", function() {
            return this._shaderValues.getBool(PBRSpecularMaterial.DEPTH_WRITE);
        }, function(e) {
            this._shaderValues.setBool(PBRSpecularMaterial.DEPTH_WRITE, e);
        }), a(0, t, "smoothnessSource", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.SMOOTHNESSSOURCE);
        }, function(e) {
            e ? (this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
            this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 1)) : (this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), 
            this._shaderValues.setInt(PBRSpecularMaterial.SMOOTHNESSSOURCE, 0));
        }), a(0, t, "enableEmission", function() {
            return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEEMISSION);
        }, function(e) {
            e ? this._defineDatas.add(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION) : this._defineDatas.remove(laya.d3.core.material.PBRSpecularMaterial.SHADERDEFINE_EMISSION), 
            this._shaderValues.setBool(PBRSpecularMaterial.ENABLEEMISSION, e);
        }), a(0, t, "enableReflection", function() {
            return this._shaderValues.getBool(PBRSpecularMaterial.ENABLEREFLECT);
        }, function(e) {
            this._shaderValues.setBool(PBRSpecularMaterial.ENABLEREFLECT, !0), e ? this._disablePublicDefineDatas.remove(qn.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(qn.SHADERDEFINE_REFLECTMAP);
        }), a(0, t, "tilingOffsetY", function() {
            return this._MainTex_STY;
        }, function(e) {
            this._MainTex_STY = e;
        }), a(0, t, "blend", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.BLEND);
        }, function(e) {
            this._shaderValues.setInt(PBRSpecularMaterial.BLEND, e);
        }), a(0, t, "depthTest", function() {
            return this._shaderValues.getInt(PBRSpecularMaterial.DEPTH_TEST);
        }, function(e) {
            this._shaderValues.setInt(PBRSpecularMaterial.DEPTH_TEST, e);
        }), PBRSpecularMaterial.__init__ = function() {
            PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("ALBEDOTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("SPECULARTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = PBRSpecularMaterial.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"), 
            PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("NORMALTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("PARALLAXTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("OCCLUSIONTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_EMISSION = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSION"), 
            PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE = PBRSpecularMaterial.shaderDefines.registerDefine("EMISSIONTEXTURE"), 
            PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET = PBRSpecularMaterial.shaderDefines.registerDefine("TILINGOFFSET"), 
            PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = PBRSpecularMaterial.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
        }, PBRSpecularMaterial.SmoothnessSource_SpecularTexture_Alpha = 0, PBRSpecularMaterial.SmoothnessSource_AlbedoTexture_Alpha = 1, 
        PBRSpecularMaterial.RENDERMODE_OPAQUE = 0, PBRSpecularMaterial.RENDERMODE_CUTOUT = 1, 
        PBRSpecularMaterial.RENDERMODE_FADE = 2, PBRSpecularMaterial.RENDERMODE_TRANSPARENT = 3, 
        PBRSpecularMaterial.SHADERDEFINE_ALBEDOTEXTURE = 0, PBRSpecularMaterial.SHADERDEFINE_NORMALTEXTURE = 0, 
        PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = 0, PBRSpecularMaterial.SHADERDEFINE_SPECULARTEXTURE = 0, 
        PBRSpecularMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = 0, PBRSpecularMaterial.SHADERDEFINE_PARALLAXTEXTURE = 0, 
        PBRSpecularMaterial.SHADERDEFINE_EMISSION = 0, PBRSpecularMaterial.SHADERDEFINE_EMISSIONTEXTURE = 0, 
        PBRSpecularMaterial.SHADERDEFINE_TILINGOFFSET = 0, PBRSpecularMaterial.SHADERDEFINE_ALPHAPREMULTIPLY = 0, 
        PBRSpecularMaterial.SMOOTHNESSSOURCE = -1, PBRSpecularMaterial.ENABLEEMISSION = -1, 
        PBRSpecularMaterial.ENABLEREFLECT = -1, i(PBRSpecularMaterial, [ "ALBEDOTEXTURE", function() {
            return this.ALBEDOTEXTURE = Ve.propertyNameToID("u_AlbedoTexture");
        }, "SPECULARTEXTURE", function() {
            return this.SPECULARTEXTURE = Ve.propertyNameToID("u_SpecularTexture");
        }, "NORMALTEXTURE", function() {
            return this.NORMALTEXTURE = Ve.propertyNameToID("u_NormalTexture");
        }, "PARALLAXTEXTURE", function() {
            return this.PARALLAXTEXTURE = Ve.propertyNameToID("u_ParallaxTexture");
        }, "OCCLUSIONTEXTURE", function() {
            return this.OCCLUSIONTEXTURE = Ve.propertyNameToID("u_OcclusionTexture");
        }, "EMISSIONTEXTURE", function() {
            return this.EMISSIONTEXTURE = Ve.propertyNameToID("u_EmissionTexture");
        }, "ALBEDOCOLOR", function() {
            return this.ALBEDOCOLOR = Ve.propertyNameToID("u_AlbedoColor");
        }, "SPECULARCOLOR", function() {
            return this.SPECULARCOLOR = Ve.propertyNameToID("u_SpecularColor");
        }, "EMISSIONCOLOR", function() {
            return this.EMISSIONCOLOR = Ve.propertyNameToID("u_EmissionColor");
        }, "SMOOTHNESS", function() {
            return this.SMOOTHNESS = Ve.propertyNameToID("u_smoothness");
        }, "SMOOTHNESSSCALE", function() {
            return this.SMOOTHNESSSCALE = Ve.propertyNameToID("u_smoothnessScale");
        }, "OCCLUSIONSTRENGTH", function() {
            return this.OCCLUSIONSTRENGTH = Ve.propertyNameToID("u_occlusionStrength");
        }, "NORMALSCALE", function() {
            return this.NORMALSCALE = Ve.propertyNameToID("u_normalScale");
        }, "PARALLAXSCALE", function() {
            return this.PARALLAXSCALE = Ve.propertyNameToID("u_parallaxScale");
        }, "TILINGOFFSET", function() {
            return this.TILINGOFFSET = Ve.propertyNameToID("u_TilingOffset");
        }, "CULL", function() {
            return this.CULL = Ve.propertyNameToID("s_Cull");
        }, "BLEND", function() {
            return this.BLEND = Ve.propertyNameToID("s_Blend");
        }, "BLEND_SRC", function() {
            return this.BLEND_SRC = Ve.propertyNameToID("s_BlendSrc");
        }, "BLEND_DST", function() {
            return this.BLEND_DST = Ve.propertyNameToID("s_BlendDst");
        }, "DEPTH_TEST", function() {
            return this.DEPTH_TEST = Ve.propertyNameToID("s_DepthTest");
        }, "DEPTH_WRITE", function() {
            return this.DEPTH_WRITE = Ve.propertyNameToID("s_DepthWrite");
        }, "defaultMaterial", function() {
            return this.defaultMaterial = new PBRSpecularMaterial();
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Fn.shaderDefines);
        } ]), PBRSpecularMaterial;
    }(Fn), mi = (function(t) {
        function Rigidbody3D(e, t) {
            this._isKinematic = !1, this._mass = 1, this._angularDamping = 0, this._linearDamping = 0, 
            this._overrideGravity = !1, this._detectCollisions = !0, this._gravity = new Te(0, -10, 0), 
            this._totalTorque = new Te(0, 0, 0), this._linearVelocity = new Te(), this._angularVelocity = new Te(), 
            this._linearFactor = new Te(1, 1, 1), this._angularFactor = new Te(1, 1, 1), void 0 === e && (e = 1), 
            void 0 === t && (t = Ut.COLLISIONFILTERGROUP_ALLFILTER), Rigidbody3D.__super.call(this, e, t);
        }
        r(Rigidbody3D, "laya.d3.physics.Rigidbody3D", t);
        var n = Rigidbody3D.prototype;
        n._updateMass = function(e) {
            this._nativeColliderObject && this._colliderShape && (this._colliderShape._nativeShape.calculateLocalInertia(e, Rigidbody3D._nativeInertia), 
            this._nativeColliderObject.setMassProps(e, Rigidbody3D._nativeInertia), this._nativeColliderObject.updateInertiaTensor());
        }, n._delegateMotionStateGetWorldTransform = function(e) {}, n._delegateMotionStateSetWorldTransform = function(e) {
            var t = this._rigidbody;
            t._simulation._updatedRigidbodies++;
            var n = X._physics3D, i = n.wrapPointer(e, n.btTransform);
            t._updateTransformComponent(i);
        }, n._delegateMotionStateGetWorldTransformNative = function(e, t) {}, n._delegateMotionStateSetWorldTransformNative = function(e, t) {
            var n = e;
            n._simulation._updatedRigidbodies++;
            var i = X._physics3D, r = i.wrapPointer(t, i.btTransform);
            n._updateTransformComponent(r);
        }, n._onScaleChange = function(e) {
            laya.d3.physics.PhysicsComponent.prototype._onScaleChange.call(this, e), this._updateMass(this._isKinematic ? 0 : this._mass);
        }, n._delegateMotionStateClear = function() {
            this._rigidbody = null;
        }, n._onAdded = function() {
            var n = X._physics3D, i = new n.LayaMotionState();
            null != e.conch && n.LayaMotionState.prototype.setRigidbody ? (i.setRigidbody(this), 
            i.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative), 
            i.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative)) : (i.getWorldTransform = this._delegateMotionStateGetWorldTransform, 
            i.setWorldTransform = this._delegateMotionStateSetWorldTransform), i.clear = this._delegateMotionStateClear, 
            i._rigidbody = this, this._nativeMotionState = i;
            var r = new n.btRigidBodyConstructionInfo(0, i, null, Rigidbody3D._nativeVector3Zero), a = new n.btRigidBody(r);
            a.setUserIndex(this.id), this._nativeColliderObject = a, t.prototype._onAdded.call(this), 
            this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor, 
            this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping, 
            this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic, 
            n.destroy(r);
        }, n._onShapeChange = function(e) {
            laya.d3.physics.PhysicsComponent.prototype._onShapeChange.call(this, e), this._isKinematic ? this._updateMass(0) : (this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform()), 
            this._updateMass(this._mass));
        }, n._parse = function(e) {
            null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
            null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
            null != e.mass && (this.mass = e.mass), null != e.isKinematic && (this.isKinematic = e.isKinematic), 
            null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e.angularDamping && (this.angularDamping = e.angularDamping), 
            null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), e.gravity && (this.gravity.fromArray(e.gravity), 
            this.gravity = this.gravity), laya.d3.physics.PhysicsComponent.prototype._parse.call(this, e), 
            this._parseShape(e.shapes);
        }, n._onDestroy = function() {
            var e = X._physics3D;
            this._nativeMotionState.clear(), e.destroy(this._nativeMotionState), laya.d3.physics.PhysicsComponent.prototype._onDestroy.call(this), 
            this._nativeMotionState = null, this._gravity = null, this._totalTorque = null, 
            this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null, 
            this._angularFactor = null;
        }, n._addToSimulation = function() {
            this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
        }, n._removeFromSimulation = function() {
            this._simulation._removeRigidBody(this);
        }, n._cloneTo = function(e) {
            t.prototype._cloneTo.call(this, e);
            var n = e;
            n.isKinematic = this._isKinematic, n.mass = this._mass, n.gravity = this._gravity, 
            n.angularDamping = this._angularDamping, n.linearDamping = this._linearDamping, 
            n.overrideGravity = this._overrideGravity, n.linearVelocity = this._linearVelocity, 
            n.angularVelocity = this._angularVelocity, n.linearFactor = this._linearFactor, 
            n.angularFactor = this._angularFactor, n.detectCollisions = this._detectCollisions;
        }, n.applyForce = function(e, t) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var n = Rigidbody3D._nativeTempVector30;
            if (n.setValue(-e.x, e.y, e.z), t) {
                var i = Rigidbody3D._nativeTempVector31;
                i.setValue(-t.x, t.y, t.z), this._nativeColliderObject.applyForce(n, i);
            } else this._nativeColliderObject.applyCentralForce(n);
        }, n.applyTorque = function(e) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = Rigidbody3D._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeColliderObject.applyTorque(t);
        }, n.applyImpulse = function(e, t) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            Rigidbody3D._nativeImpulse.setValue(-e.x, e.y, e.z), t ? (Rigidbody3D._nativeImpulseOffset.setValue(-t.x, t.y, t.z), 
            this._nativeColliderObject.applyImpulse(Rigidbody3D._nativeImpulse, Rigidbody3D._nativeImpulseOffset)) : this._nativeColliderObject.applyCentralImpulse(Rigidbody3D._nativeImpulse);
        }, n.applyTorqueImpulse = function(e) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = Rigidbody3D._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeColliderObject.applyTorqueImpulse(t);
        }, n.wakeUp = function() {
            this._nativeColliderObject && this._nativeColliderObject.activate(!1);
        }, n.clearForces = function() {
            var e = this._nativeColliderObject;
            if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            e.clearForces();
            var t = Rigidbody3D._nativeVector3Zero;
            e.setInterpolationAngularVelocity(t), e.setLinearVelocity(t), e.setInterpolationAngularVelocity(t), 
            e.setAngularVelocity(t);
        }, a(0, n, "angularDamping", function() {
            return this._angularDamping;
        }, function(e) {
            this._angularDamping = e, this._nativeColliderObject && this._nativeColliderObject.setDamping(this._linearDamping, e);
        }), a(0, n, "mass", function() {
            return this._mass;
        }, function(e) {
            e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
        }), a(0, n, "linearDamping", function() {
            return this._linearDamping;
        }, function(e) {
            this._linearDamping = e, this._nativeColliderObject && this._nativeColliderObject.setDamping(e, this._angularDamping);
        }), a(0, n, "isKinematic", function() {
            return this._isKinematic;
        }, function(e) {
            this._isKinematic = e;
            var t = !!(this._simulation && this._enabled && this._colliderShape);
            t && this._removeFromSimulation();
            var n = this._nativeColliderObject, i = n.getCollisionFlags();
            e ? (i |= 2, n.setCollisionFlags(i), this._nativeColliderObject.forceActivationState(4), 
            this._enableProcessCollisions = !1, this._updateMass(0)) : ((2 & i) > 0 && (i ^= 2), 
            n.setCollisionFlags(i), this._nativeColliderObject.setActivationState(1), this._enableProcessCollisions = !0, 
            this._updateMass(this._mass));
            var r = Rigidbody3D._nativeVector3Zero;
            n.setInterpolationLinearVelocity(r), n.setLinearVelocity(r), n.setInterpolationAngularVelocity(r), 
            n.setAngularVelocity(r), t && this._addToSimulation();
        }), a(0, n, "gravity", function() {
            return this._gravity;
        }, function(e) {
            this._gravity = e, Rigidbody3D._nativeGravity.setValue(-e.x, e.y, e.z), this._nativeColliderObject.setGravity(Rigidbody3D._nativeGravity);
        }), a(0, n, "overrideGravity", function() {
            return this._overrideGravity;
        }, function(e) {
            if (this._overrideGravity = e, this._nativeColliderObject) {
                var t = this._nativeColliderObject.getFlags();
                e ? 0 == (1 & t) && this._nativeColliderObject.setFlags(1 | t) : (1 & t) > 0 && this._nativeColliderObject.setFlags(1 ^ t);
            }
        }), a(0, n, "totalForce", function() {
            return this._nativeColliderObject ? this._nativeColliderObject.getTotalForce() : null;
        }), a(0, n, "linearVelocity", function() {
            return this._nativeColliderObject && ke._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(), this._linearVelocity, !0), 
            this._linearVelocity;
        }, function(e) {
            if (this._linearVelocity = e, this._nativeColliderObject) {
                var t = Rigidbody3D._nativeTempVector30;
                ke._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setLinearVelocity(t);
            }
        }), a(0, n, "detectCollisions", function() {
            return this._detectCollisions;
        }, function(e) {
            this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this), 
            this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
        }), a(0, n, "linearFactor", function() {
            return this._nativeColliderObject ? this._linearFactor : null;
        }, function(e) {
            if (this._linearFactor = e, this._nativeColliderObject) {
                var t = Rigidbody3D._nativeTempVector30;
                ke._convertToBulletVec3(e, t, !1), this._nativeColliderObject.setLinearFactor(t);
            }
        }), a(0, n, "angularFactor", function() {
            return this._nativeColliderObject ? this._angularFactor : null;
        }, function(e) {
            if (this._angularFactor = e, this._nativeColliderObject) {
                var t = Rigidbody3D._nativeTempVector30;
                ke._convertToBulletVec3(e, t, !1), this._nativeColliderObject.setAngularFactor(t);
            }
        }), a(0, n, "angularVelocity", function() {
            return this._nativeColliderObject && ke._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(), this._angularVelocity, !0), 
            this._angularVelocity;
        }, function(e) {
            if (this._angularVelocity = e, this._nativeColliderObject) {
                var t = Rigidbody3D._nativeTempVector30;
                ke._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setAngularVelocity(t);
            }
        }), a(0, n, "totalTorque", function() {
            if (this._nativeColliderObject) {
                var e = this._nativeColliderObject.getTotalTorque(), t = this._totalTorque;
                t.x = -e.x, t.y = e.y, t.z = e.z;
            }
            return null;
        }), a(0, n, "isSleeping", function() {
            return !!this._nativeColliderObject && 2 === this._nativeColliderObject.getActivationState();
        }), a(0, n, "sleepLinearVelocity", function() {
            return this._nativeColliderObject.getLinearSleepingThreshold();
        }, function(e) {
            this._nativeColliderObject.setSleepingThresholds(e, this._nativeColliderObject.getAngularSleepingThreshold());
        }), a(0, n, "sleepAngularVelocity", function() {
            return this._nativeColliderObject.getAngularSleepingThreshold();
        }, function(e) {
            this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(), e);
        }), Rigidbody3D.TYPE_STATIC = 0, Rigidbody3D.TYPE_DYNAMIC = 1, Rigidbody3D.TYPE_KINEMATIC = 2, 
        Rigidbody3D._BT_DISABLE_WORLD_GRAVITY = 1, Rigidbody3D._BT_ENABLE_GYROPSCOPIC_FORCE = 2, 
        i(Rigidbody3D, [ "_nativeTempVector30", function() {
            return this._nativeTempVector30 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeTempVector31", function() {
            return this._nativeTempVector31 = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeVector3Zero", function() {
            return this._nativeVector3Zero = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeInertia", function() {
            return this._nativeInertia = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeImpulse", function() {
            return this._nativeImpulse = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeImpulseOffset", function() {
            return this._nativeImpulseOffset = new X._physics3D.btVector3(0, 0, 0);
        }, "_nativeGravity", function() {
            return this._nativeGravity = new X._physics3D.btVector3(0, 0, 0);
        } ]);
    }(Yn), function(e) {
        function PhysicsCollider(e, t) {
            void 0 === e && (e = 1), void 0 === t && (t = Ut.COLLISIONFILTERGROUP_ALLFILTER), 
            PhysicsCollider.__super.call(this, e, t);
        }
        r(PhysicsCollider, "laya.d3.physics.PhysicsCollider", e);
        var t = PhysicsCollider.prototype;
        t._addToSimulation = function() {
            this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
        }, t._removeFromSimulation = function() {
            this._simulation._removePhysicsCollider(this);
        }, t._onTransformChanged = function(e) {
            (e &= 56) && (this._transformFlag |= e, this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
        }, t._parse = function(e) {
            null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction), 
            null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger), 
            laya.d3.physics.PhysicsComponent.prototype._parse.call(this, e), this._parseShape(e.shapes);
        }, t._onAdded = function() {
            var t = new X._physics3D.btCollisionObject();
            t.setUserIndex(this.id), t.forceActivationState(5);
            var n = t.getCollisionFlags();
            this.owner.isStatic ? ((2 & n) > 0 && (n ^= 2), n |= 1) : ((1 & n) > 0 && (n ^= 1), 
            n |= 2), t.setCollisionFlags(n), this._nativeColliderObject = t, e.prototype._onAdded.call(this);
        };
    }(Yn), function(e) {
        function SkinnedMeshRenderer(e) {
            this._bones = [], this._skinnedDataLoopMarks = [], this._localBounds = new Mt(Te._ZERO, Te._ZERO), 
            this._cacheAnimationNode = [], SkinnedMeshRenderer.__super.call(this, e);
        }
        r(SkinnedMeshRenderer, "laya.d3.core.SkinnedMeshRenderer", e);
        var t = SkinnedMeshRenderer.prototype;
        return t._computeSkinnedData = function() {
            if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && this._cacheRootBone) for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._bindPoseIndices, n = this._cacheMesh._skinDataPathMarks, i = 0, r = this._cacheMesh.subMeshCount; i < r; i++) for (var a = this._cacheMesh._getSubMesh(i)._boneIndicesList, o = this._skinnedData[i], s = 0, l = a.length; s < l; s++) {
                var h = a[s];
                R.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, h, t, o[s]) : this._computeSubSkinnedData(e, h, t, o[s], n);
            }
        }, t._computeSubSkinnedData = function(e, t, n, i, r) {
            for (var a = 0, o = t.length; a < o; a++) {
                var s = t[a];
                if (this._skinnedDataLoopMarks[s] === P.loopCount) for (var l = r[s], h = this._skinnedData[l[0]][l[1]], u = 16 * l[2], c = 16 * a, d = 0; d < 16; d++) i[c + d] = h[u + d]; else {
                    if (this._cacheRootBone) {
                        var _ = n[s];
                        ke._mulMatrixArray(this._bones[_].transform.worldMatrix.elements, e[_], i, 16 * a);
                    } else ke._mulMatrixArray(this._cacheAnimationNode[s].transform.getWorldMatrix(), e[n[s]], i, 16 * a);
                    this._skinnedDataLoopMarks[s] = P.loopCount;
                }
            }
        }, t._boundChange = function() {
            this._boundsChange = !0;
        }, t._onMeshChange = function(t) {
            e.prototype._onMeshChange.call(this, t), this._cacheMesh = t;
            var n = t.subMeshCount;
            this._skinnedData = o(n), this._skinnedDataLoopMarks.length = t._bindPoseIndices.length;
            for (var i = 0; i < n; i++) for (var r = t._getSubMesh(i)._boneIndicesList, a = r.length, s = this._skinnedData[i] = o(a), l = 0; l < a; l++) s[l] = new Float32Array(16 * r[l].length);
            this._bones || this._cacheAvatar && t && this._getCacheAnimationNodes();
        }, t._setCacheAnimator = function(e) {
            this._cacheAnimator = e, this._defineDatas.add(yi.SHADERDEFINE_BONE), this._setRootNode();
        }, t._calculateBoundingBox = function() {
            if (this._cacheRootBone) this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds); else if (this._cacheAnimator && this._rootBone) {
                var t = SkinnedMeshRenderer._tempMatrix4x4;
                ke.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), t), 
                this._localBounds._tranform(t, this._bounds);
            } else e.prototype._calculateBoundingBox.call(this);
            if (R.supportWebGLPlusCulling) {
                var n = this._bounds.getMin(), i = this._bounds.getMax(), r = Bt._cullingBuffer;
                r[this._cullingBufferIndex + 1] = n.x, r[this._cullingBufferIndex + 2] = n.y, r[this._cullingBufferIndex + 3] = n.z, 
                r[this._cullingBufferIndex + 4] = i.x, r[this._cullingBufferIndex + 5] = i.y, r[this._cullingBufferIndex + 6] = i.z;
            }
        }, t._changeRenderObjectsByMesh = function(e) {
            var t = e.subMeshCount;
            this._renderElements.length = t;
            for (var n = 0; n < t; n++) {
                var i = this._renderElements[n];
                if (!i) {
                    var r = this.sharedMaterials[n];
                    (i = this._renderElements[n] = new Ie()).setTransform(this._owner._transform), i.render = this, 
                    i.material = r || ci.defaultMaterial;
                }
                i.setGeometry(e._getSubMesh(n));
            }
        }, t._renderUpdate = function(e, t) {
            if (this._cacheAnimator) if (this._computeSkinnedData(), this._cacheRootBone) this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, Ht.DEFAULT); else {
                var n = this._cacheAnimator.owner._transform;
                this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, n.worldMatrix);
            } else this._shaderValues.setMatrix4x4(bn.WORLDMATRIX, t.worldMatrix);
        }, t._renderUpdateWithCamera = function(e, t) {
            var n = e.projectionViewMatrix;
            if (this._cacheRootBone) this._shaderValues.setMatrix4x4(bn.MVPMATRIX, n); else {
                if (this._cacheAnimator) {
                    var i = this._cacheAnimator.owner._transform;
                    Ht.multiply(n, i.worldMatrix, this._projectionViewWorldMatrix);
                } else Ht.multiply(n, t.worldMatrix, this._projectionViewWorldMatrix);
                this._shaderValues.setMatrix4x4(bn.MVPMATRIX, this._projectionViewWorldMatrix);
            }
        }, t._destroy = function() {
            e.prototype._destroy.call(this), this._cacheRootBone ? this._cacheRootBone.transform.off("transformchanged", this, this._boundChange) : this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off("transformchanged", this, this._boundChange);
        }, t._setRootBone = function(e) {
            this._rootBone = e, this._setRootNode();
        }, t._setRootNode = function() {
            var e;
            e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null, 
            this._cacheRootAnimationNode != e && (this._boundChange(), this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off("transformchanged", this, this._boundChange), 
            e && e.transform.on("transformchanged", this, this._boundChange), this._cacheRootAnimationNode = e);
        }, t._getCacheAnimationNodes = function() {
            var e = this._cacheMesh._boneNames, t = this._cacheMesh._bindPoseIndices, n = t.length;
            if (R.supportWebGLPlusAnimation) {
                this._cacheAnimationNodeIndices = new Uint16Array(n);
                var i = this._cacheAnimator._avatarNodeMap;
                for (o = 0; o < n; o++) {
                    var r = i[e[t[o]]];
                    this._cacheAnimationNodeIndices[o] = r._worldMatrixIndex;
                }
            } else {
                this._cacheAnimationNode.length = n;
                for (var a = this._cacheAnimator._avatarNodeMap, o = 0; o < n; o++) {
                    var s = a[e[t[o]]];
                    this._cacheAnimationNode[o] = s;
                }
            }
        }, t._setCacheAvatar = function(e) {
            this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._defineDatas.add(yi.SHADERDEFINE_BONE), 
            this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
        }, t._computeSubSkinnedDataNative = function(e, t, n, i, r, a) {
            E.instance.computeSubSkinnedData(e, t, n, i, r, a);
        }, a(0, t, "localBounds", function() {
            return this._localBounds;
        }, function(e) {
            this._localBounds = e;
        }), a(0, t, "rootBone", function() {
            return this._cacheRootBone;
        }, function(e) {
            this._cacheRootBone != e && (this._cacheRootBone && this._cacheRootBone.transform.off("transformchanged", this, this._boundChange), 
            e.transform.on("transformchanged", this, this._boundChange), this._cacheRootBone = e, 
            this._boundChange());
        }), a(0, t, "bones", function() {
            return this._bones;
        }), a(0, t, "bounds", function() {
            return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(), 
            this._boundsChange = !1), this._bounds;
        }), i(SkinnedMeshRenderer, [ "_tempMatrix4x4", function() {
            return this._tempMatrix4x4 = new Ht();
        } ]), SkinnedMeshRenderer;
    }(Kn)), pi = function(e) {
        function RenderTexture(e, t, n, i) {
            void 0 === n && (n = 0), void 0 === i && (i = 0), RenderTexture.__super.call(this, n, !1), 
            this._glTextureType = 3553, this._width = e, this._height = t, this._depthStencilFormat = i, 
            this._create(e, t);
        }
        r(RenderTexture, "laya.d3.resource.RenderTexture", s);
        var t = RenderTexture.prototype;
        return t._create = function(e, t) {
            var n = E.instance;
            this._frameBuffer = n.createFramebuffer(), F.bindTexture(n, this._glTextureType, this._glTexture);
            var i = this._getGLFormat();
            if (n.texImage2D(this._glTextureType, 0, i, e, t, 0, i, 5121, null), this._setGPUMemory(e * t * 4), 
            n.bindFramebuffer(36160, this._frameBuffer), n.framebufferTexture2D(36160, 36064, 3553, this._glTexture, 0), 
            3 !== this._depthStencilFormat) switch (this._depthStencilBuffer = n.createRenderbuffer(), 
            n.bindRenderbuffer(36161, this._depthStencilBuffer), this._depthStencilFormat) {
              case 0:
                n.renderbufferStorage(36161, 33189, e, t), n.framebufferRenderbuffer(36160, 36096, 36161, this._depthStencilBuffer);
                break;

              case 1:
                n.renderbufferStorage(36161, 36168, e, t), n.framebufferRenderbuffer(36160, 36128, 36161, this._depthStencilBuffer);
                break;

              case 2:
                n.renderbufferStorage(36161, 34041, e, t), n.framebufferRenderbuffer(36160, 33306, 36161, this._depthStencilBuffer);
                break;

              default:
                throw "RenderTexture: unkonw depth format.";
            }
            n.bindFramebuffer(36160, null), n.bindRenderbuffer(36161, null), this._setWarpMode(10242, this._wrapModeU), 
            this._setWarpMode(10243, this._wrapModeV), this._setFilterMode(this._filterMode), 
            this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource();
        }, t._start = function() {
            E.instance.bindFramebuffer(36160, this._frameBuffer), RenderTexture._currentActive = this, 
            this._readyed = !1;
        }, t._end = function() {
            E.instance.bindFramebuffer(36160, null), RenderTexture._currentActive = null, this._readyed = !0;
        }, t.getData = function(e, t, n, i, r) {
            if (R.isConchApp && 2 == conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
            var a = E.instance;
            return a.bindFramebuffer(36160, this._frameBuffer), 36053 === a.checkFramebufferStatus(36160) ? (a.readPixels(e, t, n, i, 6408, 5121, r), 
            a.bindFramebuffer(36160, null), r) : (a.bindFramebuffer(36160, null), null);
        }, t.getDataAsync = function(e, t, n, i, r) {
            var a = E.instance;
            a.bindFramebuffer(36160, this._frameBuffer), a.readPixelsAsync(e, t, n, i, 6408, 5121, function(e) {
                r(new Uint8Array(e));
            }), a.bindFramebuffer(36160, null);
        }, t._disposeResource = function() {
            if (this._frameBuffer) {
                var e = E.instance;
                e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer), 
                this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null, 
                this._setGPUMemory(0);
            }
        }, a(0, t, "depthStencilFormat", function() {
            return this._depthStencilFormat;
        }), a(0, t, "defaulteTexture", function() {
            return B.grayTexture;
        }), a(1, RenderTexture, "currentActive", function() {
            return RenderTexture._currentActive;
        }, laya.resource.BaseTexture._$SET_currentActive), RenderTexture.getTemporary = function(e, t, n, i, r) {
            void 0 === n && (n = 0), void 0 === i && (i = 0), void 0 === r && (r = 1);
            var a = 1e7 * r + 1e6 * i + 1e5 * n + 1e4 * t + e, o = RenderTexture._temporaryMap[a];
            if (!o || o && 0 === o.length) {
                var s = new RenderTexture(e, t, n, i);
                return s.filterMode = r, s;
            }
            return o.pop();
        }, RenderTexture.setReleaseTemporary = function(e) {
            var t = 1e7 * e.filterMode + 1e6 * e.depthStencilFormat + 1e5 * e.format + 1e4 * e.height + e.width, n = RenderTexture._temporaryMap[t];
            n || (RenderTexture._temporaryMap[t] = n = []), n.push(e);
        }, RenderTexture._temporaryMap = {}, RenderTexture._currentActive = null, RenderTexture;
    }(), Ti = function(e) {
        function TextureCube(e, t) {
            void 0 === e && (e = 0), void 0 === t && (t = !1), TextureCube.__super.call(this, e, t), 
            this._glTextureType = 34067;
        }
        r(TextureCube, "laya.d3.resource.TextureCube", s);
        var t = TextureCube.prototype;
        return t.setSixSideImageSources = function(e, t) {
            void 0 === t && (t = !1);
            for (var n = 0, i = 0, r = 0; r < 6; r++) {
                var a = e[r];
                if (!a) return void console.log("TextureCube: image Source can't be null.");
                var o = a.width, s = a.height;
                if (r > 0 && n !== o) return void console.log("TextureCube: each side image's width and height must same.");
                if ((n = o) !== (i = s)) return void console.log("TextureCube: each side image's width and height must same.");
            }
            this._width = n, this._height = i;
            var l = E.instance;
            F.bindTexture(l, this._glTextureType, this._glTexture);
            var h = this._getGLFormat();
            if (R.isConchApp) {
                if (1 == t) for (var u = 0; u < 6; u++) e[u].setPremultiplyAlpha(t);
                l.texImage2D(34073, 0, 6408, 6408, 5121, e[0]), l.texImage2D(34074, 0, 6408, 6408, 5121, e[1]), 
                l.texImage2D(34069, 0, 6408, 6408, 5121, e[2]), l.texImage2D(34070, 0, 6408, 6408, 5121, e[3]), 
                l.texImage2D(34071, 0, 6408, 6408, 5121, e[4]), l.texImage2D(34072, 0, 6408, 6408, 5121, e[5]);
            } else t && l.pixelStorei(37441, !0), l.texImage2D(34073, 0, h, h, 5121, e[0]), 
            l.texImage2D(34074, 0, h, h, 5121, e[1]), l.texImage2D(34069, 0, h, h, 5121, e[2]), 
            l.texImage2D(34070, 0, h, h, 5121, e[3]), l.texImage2D(34071, 0, h, h, 5121, e[4]), 
            l.texImage2D(34072, 0, h, h, 5121, e[5]), t && l.pixelStorei(37441, !1);
            this._mipmap && this._isPot(n) && this._isPot(i) ? (l.generateMipmap(this._glTextureType), 
            this._setGPUMemory(n * i * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(n * i * 4 * 6), 
            this._setWarpMode(10242, this._wrapModeU), this._setWarpMode(10243, this._wrapModeV), 
            this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
        }, t.setSixSidePixels = function(e, t, n) {
            if (e <= 0 || t <= 0) throw new Error("TextureCube:width or height must large than 0.");
            if (!n) throw new Error("TextureCube:pixels can't be null.");
            this._width = e, this._height = t;
            var i = E.instance;
            F.bindTexture(i, this._glTextureType, this._glTexture);
            var r = this._getGLFormat();
            i.texImage2D(34073, 0, r, e, t, 0, r, 5121, n[0]), i.texImage2D(34074, 0, r, e, t, 0, r, 5121, n[1]), 
            i.texImage2D(34069, 0, r, e, t, 0, r, 5121, n[2]), i.texImage2D(34070, 0, r, e, t, 0, r, 5121, n[3]), 
            i.texImage2D(34071, 0, r, e, t, 0, r, 5121, n[4]), i.texImage2D(34072, 0, r, e, t, 0, r, 5121, n[5]), 
            this._mipmap && this._isPot(e) && this._isPot(t) ? (i.generateMipmap(this._glTextureType), 
            this._setGPUMemory(e * t * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(e * t * 4 * 6), 
            this._setWarpMode(10242, this._wrapModeU), this._setWarpMode(10243, this._wrapModeV), 
            this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
        }, t._recoverResource = function() {}, a(0, t, "defaulteTexture", function() {
            return TextureCube.grayTexture;
        }), TextureCube.__init__ = function() {
            var e = new Uint8Array(3);
            e[0] = 128, e[1] = 128, e[2] = 128, TextureCube.grayTexture = new TextureCube(0, !1), 
            TextureCube.grayTexture.setSixSidePixels(1, 1, [ e, e, e, e, e, e ]), TextureCube.grayTexture.lock = !0;
        }, TextureCube._parse = function(e, t, n) {
            var i = n ? new TextureCube(n[0], n[1]) : new TextureCube();
            return i.setSixSideImageSources(e), i;
        }, TextureCube.load = function(e, t) {
            n.loader.create(e, t, null, "TEXTURECUBE");
        }, TextureCube.grayTexture = null, TextureCube;
    }(), Si = function(e) {
        function MeshSprite3D(e, t) {
            MeshSprite3D.__super.call(this, t), this._meshFilter = new $e(this), this._render = new Kn(this), 
            e && (this._meshFilter.sharedMesh = e);
        }
        r(MeshSprite3D, "laya.d3.core.MeshSprite3D", e);
        var t = MeshSprite3D.prototype;
        return t._parse = function(e, t) {
            laya.d3.core.Sprite3D.prototype._parse.call(this, e, t);
            var n = this.meshRenderer, i = e.lightmapIndex;
            null != i && (n.lightmapIndex = i);
            var r = e.lightmapScaleOffset;
            r && (n.lightmapScaleOffset = new me(r[0], r[1], r[2], r[3])), null != e.meshPath && (this.meshFilter.sharedMesh = g.getRes(e.meshPath)), 
            null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
            var a = e.materials;
            if (a) {
                var o = n.sharedMaterials, s = a.length;
                o.length = s;
                for (var l = 0; l < s; l++) o[l] = g.getRes(a[l].path);
                n.sharedMaterials = o;
            }
        }, t._addToInitStaticBatchManager = function() {
            gn.instance._addBatchSprite(this);
        }, t._cloneTo = function(e, t, n) {
            var i = e;
            i._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
            var r = this._render, a = i._render;
            a.enable = r.enable, a.sharedMaterials = r.sharedMaterials, a.castShadow = r.castShadow;
            var o = r.lightmapScaleOffset;
            o && (a.lightmapScaleOffset = o.clone()), a.lightmapIndex = r.lightmapIndex, a.receiveShadow = r.receiveShadow, 
            a.sortingFudge = r.sortingFudge, laya.d3.core.Sprite3D.prototype._cloneTo.call(this, e, t, n);
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._meshFilter.destroy());
        }, a(0, t, "meshFilter", function() {
            return this._meshFilter;
        }), a(0, t, "meshRenderer", function() {
            return this._render;
        }), MeshSprite3D.__init__ = function() {
            MeshSprite3D.SHADERDEFINE_UV0 = MeshSprite3D.shaderDefines.registerDefine("UV"), 
            MeshSprite3D.SHADERDEFINE_COLOR = MeshSprite3D.shaderDefines.registerDefine("COLOR"), 
            MeshSprite3D.SHADERDEFINE_UV1 = MeshSprite3D.shaderDefines.registerDefine("UV1"), 
            MeshSprite3D.SHADERDEFINE_GPU_INSTANCE = MeshSprite3D.shaderDefines.registerDefine("GPU_INSTANCE"), 
            j._registerManager(gn.instance), ee._registerManager(ln.instance);
        }, MeshSprite3D.SHADERDEFINE_UV0 = 0, MeshSprite3D.SHADERDEFINE_COLOR = 0, MeshSprite3D.SHADERDEFINE_UV1 = 0, 
        MeshSprite3D.SHADERDEFINE_GPU_INSTANCE = 0, i(MeshSprite3D, [ "shaderDefines", function() {
            return this.shaderDefines = new pe(Jn.shaderDefines);
        } ]), MeshSprite3D;
    }(Jn), Ei = function(e) {
        function SpotLight() {
            this._direction = null, this._spotAngle = NaN, this._range = NaN, SpotLight.__super.call(this), 
            this._spotAngle = 30, this._range = 10, this._direction = new Te();
        }
        r(SpotLight, "laya.d3.core.light.SpotLight", e);
        var t = SpotLight.prototype;
        return t._onActive = function() {
            e.prototype._onActive.call(this), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this.scene._defineDatas.add(qn.SHADERDEFINE_SPOTLIGHT);
        }, t._onInActive = function() {
            e.prototype._onInActive.call(this), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this.scene._defineDatas.remove(qn.SHADERDEFINE_SPOTLIGHT);
        }, t._prepareToScene = function() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                e._defineDatas;
                var t = e._shaderValues;
                return Te.scale(this.color, this._intensity, this._intensityColor), t.setVector3(qn.SPOTLIGHTCOLOR, this._intensityColor), 
                t.setVector3(qn.SPOTLIGHTPOS, this.transform.position), this.transform.worldMatrix.getForward(this._direction), 
                Te.normalize(this._direction, this._direction), t.setVector3(qn.SPOTLIGHTDIRECTION, this._direction), 
                t.setNumber(qn.SPOTLIGHTRANGE, this.range), t.setNumber(qn.SPOTLIGHTSPOTANGLE, this.spotAngle * Math.PI / 180), 
                !0;
            }
            return !1;
        }, t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n), this.range = t.range, this.spotAngle = t.spotAngle;
        }, a(0, t, "spotAngle", function() {
            return this._spotAngle;
        }, function(e) {
            this._spotAngle = Math.max(Math.min(e, 180), 0);
        }), a(0, t, "range", function() {
            return this._range;
        }, function(e) {
            this._range = e;
        }), i(SpotLight, [ "_tempMatrix0", function() {
            return this._tempMatrix0 = new Ht();
        }, "_tempMatrix1", function() {
            return this._tempMatrix1 = new Ht();
        } ]), SpotLight;
    }(ei), vi = function(e) {
        function DirectionLight() {
            this._direction = null, DirectionLight.__super.call(this), this._direction = new Te();
        }
        r(DirectionLight, "laya.d3.core.light.DirectionLight", e);
        var t = DirectionLight.prototype;
        return t._initShadow = function() {
            if (this._shadow) this._parallelSplitShadowMap = new Be(), this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap), 
            this.transform.worldMatrix.getForward(this._direction), Te.normalize(this._direction, this._direction), 
            this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType); else {
                var e = this._scene._defineDatas, t = this.scene.parallelSplitShadowMaps;
                t.splice(t.indexOf(this._parallelSplitShadowMap), 1), this._parallelSplitShadowMap.disposeAllRenderTarget(), 
                this._parallelSplitShadowMap = null, e.remove(qn.SHADERDEFINE_SHADOW_PSSM1), e.remove(qn.SHADERDEFINE_SHADOW_PSSM2), 
                e.remove(qn.SHADERDEFINE_SHADOW_PSSM3);
            }
        }, t._onActive = function() {
            e.prototype._onActive.call(this), this._shadow && this._initShadow(), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.add(qn.SHADERDEFINE_DIRECTIONLIGHT);
        }, t._onInActive = function() {
            e.prototype._onInActive.call(this), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.remove(qn.SHADERDEFINE_DIRECTIONLIGHT);
        }, t._prepareToScene = function() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                e._defineDatas;
                var t = e._shaderValues;
                return Te.scale(this.color, this._intensity, this._intensityColor), t.setVector3(qn.LIGHTDIRCOLOR, this._intensityColor), 
                this.transform.worldMatrix.getForward(this._direction), Te.normalize(this._direction, this._direction), 
                t.setVector3(qn.LIGHTDIRECTION, this._direction), !0;
            }
            return !1;
        }, a(0, t, "shadow", e.prototype._$get_shadow, function(e) {
            this._shadow !== e && (this._shadow = e, this.scene && this._initShadow());
        }), DirectionLight;
    }(ei), gi = function(e) {
        function TrailSprite3D() {
            TrailSprite3D.__super.call(this, this.name), this._render = new Qn(this), this._geometryFilter = new et(this);
        }
        r(TrailSprite3D, "laya.d3.core.trail.TrailSprite3D", e);
        var t = TrailSprite3D.prototype;
        return t._parse = function(e, t) {
            laya.d3.core.Sprite3D.prototype._parse.call(this, e, t);
            var n = this._render, i = this._geometryFilter, r = 0, a = 0, o = e.materials;
            if (o) {
                var s = n.sharedMaterials, l = o.length;
                for (s.length = l, r = 0; r < l; r++) s[r] = g.getRes(o[r].path);
                n.sharedMaterials = s;
            }
            i.time = e.time, i.minVertexDistance = e.minVertexDistance, i.widthMultiplier = e.widthMultiplier, 
            i.textureMode = e.textureMode, null != e.alignment && (i.alignment = e.alignment);
            var h = [], u = e.widthCurve;
            for (r = 0, a = u.length; r < a; r++) {
                var c = new Tn();
                c.time = u[r].time, c.inTangent = u[r].inTangent, c.outTangent = u[r].outTangent, 
                c.value = u[r].value, h.push(c);
            }
            i.widthCurve = h;
            var d = e.colorGradient, _ = d.colorKeys, f = d.alphaKeys, m = new le(_.length, f.length);
            for (m.mode = d.mode, r = 0, a = _.length; r < a; r++) {
                var p = _[r];
                m.addColorRGB(p.time, new Me(p.value[0], p.value[1], p.value[2], 1));
            }
            for (r = 0, a = f.length; r < a; r++) {
                var T = f[r];
                m.addColorAlpha(T.time, T.value);
            }
            i.colorGradient = m;
        }, t._onActive = function() {
            e.prototype._onActive.call(this), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
        }, t._cloneTo = function(e, t, n) {
            laya.d3.core.Sprite3D.prototype._cloneTo.call(this, e, t, n);
            var i, r = 0, a = e, o = a.trailFilter;
            o.time = this.trailFilter.time, o.minVertexDistance = this.trailFilter.minVertexDistance, 
            o.widthMultiplier = this.trailFilter.widthMultiplier, o.textureMode = this.trailFilter.textureMode;
            var s = this.trailFilter.widthCurve, l = [];
            for (r = 0, i = s.length; r < i; r++) {
                var h = new Tn();
                s[r].cloneTo(h), l.push(h);
            }
            o.widthCurve = l;
            var u = new le(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
            this.trailFilter.colorGradient.cloneTo(u), o.colorGradient = u, a.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._geometryFilter.destroy(), this._geometryFilter = null);
        }, a(0, t, "trailFilter", function() {
            return this._geometryFilter;
        }), a(0, t, "trailRenderer", function() {
            return this._render;
        }), TrailSprite3D.__init__ = function() {
            TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND = TrailSprite3D.shaderDefines.registerDefine("GRADIENTMODE_BLEND");
        }, TrailSprite3D.SHADERDEFINE_GRADIENTMODE_BLEND = 0, i(TrailSprite3D, [ "CURTIME", function() {
            return this.CURTIME = Ve.propertyNameToID("u_CurTime");
        }, "LIFETIME", function() {
            return this.LIFETIME = Ve.propertyNameToID("u_LifeTime");
        }, "WIDTHCURVE", function() {
            return this.WIDTHCURVE = Ve.propertyNameToID("u_WidthCurve");
        }, "WIDTHCURVEKEYLENGTH", function() {
            return this.WIDTHCURVEKEYLENGTH = Ve.propertyNameToID("u_WidthCurveKeyLength");
        }, "GRADIENTCOLORKEY", function() {
            return this.GRADIENTCOLORKEY = Ve.propertyNameToID("u_GradientColorkey");
        }, "GRADIENTALPHAKEY", function() {
            return this.GRADIENTALPHAKEY = Ve.propertyNameToID("u_GradientAlphakey");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Jn.shaderDefines);
        } ]), TrailSprite3D;
    }(Jn), xi = function(e) {
        function ShuriKenParticle3D() {
            ShuriKenParticle3D.__super.call(this, null), this._render = new Xn(this), this._particleSystem = new sn(this);
            var e = this._render._renderElements[0] = new Ie();
            e.setTransform(this._transform), e.render = this._render, e.setGeometry(this._particleSystem), 
            e.material = si.defaultMaterial;
        }
        r(ShuriKenParticle3D, "laya.d3.core.particleShuriKen.ShuriKenParticle3D", e);
        var t = ShuriKenParticle3D.prototype;
        return t._initParticleVelocity = function(e) {
            for (var t = new We(), n = e.velocitys, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.add(a.key, a.value);
            }
            return t;
        }, t._initParticleColor = function(e) {
            var t = new le(4, 4), n = e.alphas, i = 0, r = 0;
            for (i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                3 === i && 1 !== a.key && (a.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")), 
                t.addColorAlpha(a.key, a.value);
            }
            var o = e.rgbs;
            for (i = 0, r = o.length; i < r; i++) {
                var s = o[i], l = s.value;
                3 === i && 1 !== s.key && (s.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")), 
                t.addColorRGB(s.key, new Me(l[0], l[1], l[2], 1));
            }
            return t;
        }, t._initParticleSize = function(e) {
            for (var t = new We(), n = e.sizes, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.add(a.key, a.value);
            }
            return t;
        }, t._initParticleRotation = function(e) {
            for (var t = new We(), n = e.angularVelocitys, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.add(a.key, a.value / 180 * Math.PI);
            }
            return t;
        }, t._initParticleFrame = function(e) {
            for (var t = new at(), n = e.frames, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.add(a.key, a.value);
            }
            return t;
        }, t._parse = function(e, t) {
            laya.d3.core.Sprite3D.prototype._parse.call(this, e, t);
            var n, i = Math.PI / 180, r = 0, a = 0, o = this.particleRenderer, s = e.material;
            s && (n = g.getRes(s.path)), o.sharedMaterial = n;
            var l = e.meshPath;
            l && (o.mesh = g.getRes(l)), o.renderMode = e.renderMode, o.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale, 
            o.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, o.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale, 
            o.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
            var h = this.particleSystem;
            h.isPerformanceMode = e.isPerformanceMode, h.duration = e.duration, h.looping = e.looping, 
            h.prewarm = e.prewarm, h.startDelayType = e.startDelayType, h.startDelay = e.startDelay, 
            h.startDelayMin = e.startDelayMin, h.startDelayMax = e.startDelayMax, h.startLifetimeType = e.startLifetimeType, 
            h.startLifetimeConstant = e.startLifetimeConstant, h.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(e.startLifetimeGradient), 
            h.startLifetimeConstantMin = e.startLifetimeConstantMin, h.startLifetimeConstantMax = e.startLifetimeConstantMax, 
            h.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMin), 
            h.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMax), 
            h.startSpeedType = e.startSpeedType, h.startSpeedConstant = e.startSpeedConstant, 
            h.startSpeedConstantMin = e.startSpeedConstantMin, h.startSpeedConstantMax = e.startSpeedConstantMax, 
            h.threeDStartSize = e.threeDStartSize, h.startSizeType = e.startSizeType, h.startSizeConstant = e.startSizeConstant;
            var u = e.startSizeConstantSeparate, c = h.startSizeConstantSeparate;
            c.x = u[0], c.y = u[1], c.z = u[2], h.startSizeConstantMin = e.startSizeConstantMin, 
            h.startSizeConstantMax = e.startSizeConstantMax;
            var d = e.startSizeConstantMinSeparate, _ = h.startSizeConstantMinSeparate;
            _.x = d[0], _.y = d[1], _.z = d[2];
            var f = e.startSizeConstantMaxSeparate, m = h.startSizeConstantMaxSeparate;
            m.x = f[0], m.y = f[1], m.z = f[2], h.threeDStartRotation = e.threeDStartRotation, 
            h.startRotationType = e.startRotationType, h.startRotationConstant = e.startRotationConstant * i;
            var p = e.startRotationConstantSeparate, T = h.startRotationConstantSeparate;
            T.x = p[0] * i, T.y = p[1] * i, T.z = p[2] * i, h.startRotationConstantMin = e.startRotationConstantMin * i, 
            h.startRotationConstantMax = e.startRotationConstantMax * i;
            var S = e.startRotationConstantMinSeparate, E = h.startRotationConstantMinSeparate;
            E.x = S[0] * i, E.y = S[1] * i, E.z = S[2] * i;
            var v = e.startRotationConstantMaxSeparate, x = h.startRotationConstantMaxSeparate;
            x.x = v[0] * i, x.y = v[1] * i, x.z = v[2] * i, h.randomizeRotationDirection = e.randomizeRotationDirection, 
            h.startColorType = e.startColorType;
            var M = e.startColorConstant, y = h.startColorConstant;
            y.x = M[0], y.y = M[1], y.z = M[2], y.w = M[3];
            var D = e.startColorConstantMin, R = h.startColorConstantMin;
            R.x = D[0], R.y = D[1], R.z = D[2], R.w = D[3];
            var C = e.startColorConstantMax, I = h.startColorConstantMax;
            I.x = C[0], I.y = C[1], I.z = C[2], I.w = C[3], h.gravityModifier = e.gravityModifier, 
            h.simulationSpace = e.simulationSpace, h.scaleMode = e.scaleMode, h.playOnAwake = e.playOnAwake, 
            h.maxParticles = e.maxParticles;
            var A = e.autoRandomSeed;
            null != A && (h.autoRandomSeed = A);
            var L = e.randomSeed;
            null != L && (h.randomSeed[0] = L);
            var O = e.emission, P = h.emission;
            if (O) {
                P.emissionRate = O.emissionRate;
                var V = O.bursts;
                if (V) for (r = 0, a = V.length; r < a; r++) {
                    var N = V[r];
                    P.addBurst(new nt(N.time, N.min, N.max));
                }
                P.enbale = O.enable;
            } else P.enbale = !1;
            var B = e.shape;
            if (B) {
                var w;
                switch (B.shapeType) {
                  case 0:
                    var b;
                    w = b = new In(), b.radius = B.sphereRadius, b.emitFromShell = B.sphereEmitFromShell, 
                    b.randomDirection = B.sphereRandomDirection;
                    break;

                  case 1:
                    var F;
                    w = F = new Dn(), F.radius = B.hemiSphereRadius, F.emitFromShell = B.hemiSphereEmitFromShell, 
                    F.randomDirection = B.hemiSphereRandomDirection;
                    break;

                  case 2:
                    var U;
                    w = U = new $t(), U.angle = B.coneAngle * i, U.radius = B.coneRadius, U.length = B.coneLength, 
                    U.emitType = B.coneEmitType, U.randomDirection = B.coneRandomDirection;
                    break;

                  case 3:
                    var z;
                    w = z = new Pn(), z.x = B.boxX, z.y = B.boxY, z.z = B.boxZ, z.randomDirection = B.boxRandomDirection;
                    break;

                  case 7:
                    var G;
                    w = G = new tn(), G.radius = B.circleRadius, G.arc = B.circleArc * i, G.emitFromEdge = B.circleEmitFromEdge, 
                    G.randomDirection = B.circleRandomDirection;
                    break;

                  default:
                    var k;
                    w = k = new tn(), k.radius = B.circleRadius, k.arc = B.circleArc * i, k.emitFromEdge = B.circleEmitFromEdge, 
                    k.randomDirection = B.circleRandomDirection;
                }
                w.enable = B.enable, h.shape = w;
            }
            var W = e.velocityOverLifetime;
            if (W) {
                var X, Z = W.velocity;
                switch (Z.type) {
                  case 0:
                    var K = Z.constant;
                    X = xt.createByConstant(new Te(K[0], K[1], K[2]));
                    break;

                  case 1:
                    X = xt.createByGradient(this._initParticleVelocity(Z.gradientX), this._initParticleVelocity(Z.gradientY), this._initParticleVelocity(Z.gradientZ));
                    break;

                  case 2:
                    var Q = Z.constantMin, j = Z.constantMax;
                    X = xt.createByRandomTwoConstant(new Te(Q[0], Q[1], Q[2]), new Te(j[0], j[1], j[2]));
                    break;

                  case 3:
                    X = xt.createByRandomTwoGradient(this._initParticleVelocity(Z.gradientXMin), this._initParticleVelocity(Z.gradientXMax), this._initParticleVelocity(Z.gradientYMin), this._initParticleVelocity(Z.gradientYMax), this._initParticleVelocity(Z.gradientZMin), this._initParticleVelocity(Z.gradientZMax));
                }
                var q = new ve(X);
                q.space = W.space, q.enbale = W.enable, h.velocityOverLifetime = q;
            }
            var J = e.colorOverLifetime;
            if (J) {
                var $, ee = J.color;
                switch (ee.type) {
                  case 0:
                    var te = ee.constant;
                    $ = re.createByConstant(new me(te[0], te[1], te[2], te[3]));
                    break;

                  case 1:
                    $ = re.createByGradient(this._initParticleColor(ee.gradient));
                    break;

                  case 2:
                    var ne = ee.constantMin, ie = ee.constantMax;
                    $ = re.createByRandomTwoConstant(new me(ne[0], ne[1], ne[2], ne[3]), new me(ie[0], ie[1], ie[2], ie[3]));
                    break;

                  case 3:
                    $ = re.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                }
                var ae = new H($);
                ae.enbale = J.enable, h.colorOverLifetime = ae;
            }
            var oe = e.sizeOverLifetime;
            if (oe) {
                var se, le = oe.size;
                switch (le.type) {
                  case 0:
                    se = le.separateAxes ? St.createByGradientSeparate(this._initParticleSize(le.gradientX), this._initParticleSize(le.gradientY), this._initParticleSize(le.gradientZ)) : St.createByGradient(this._initParticleSize(le.gradient));
                    break;

                  case 1:
                    if (le.separateAxes) {
                        var he = le.constantMinSeparate, ue = le.constantMaxSeparate;
                        se = St.createByRandomTwoConstantSeparate(new Te(he[0], he[1], he[2]), new Te(ue[0], ue[1], ue[2]));
                    } else se = St.createByRandomTwoConstant(le.constantMin, le.constantMax);
                    break;

                  case 2:
                    se = le.separateAxes ? St.createByRandomTwoGradientSeparate(this._initParticleSize(le.gradientXMin), this._initParticleSize(le.gradientYMin), this._initParticleSize(le.gradientZMin), this._initParticleSize(le.gradientXMax), this._initParticleSize(le.gradientYMax), this._initParticleSize(le.gradientZMax)) : St.createByRandomTwoGradient(this._initParticleSize(le.gradientMin), this._initParticleSize(le.gradientMax));
                }
                var ce = new _e(se);
                ce.enbale = oe.enable, h.sizeOverLifetime = ce;
            }
            var de = e.rotationOverLifetime;
            if (de) {
                var fe, pe = de.angularVelocity;
                switch (pe.type) {
                  case 0:
                    if (pe.separateAxes) {
                        var Ee = pe.constantSeparate;
                        fe = ht.createByConstantSeparate(new Te(Ee[0] * i, Ee[1] * i, Ee[2] * i));
                    } else fe = ht.createByConstant(pe.constant * i);
                    break;

                  case 1:
                    fe = pe.separateAxes ? ht.createByGradientSeparate(this._initParticleRotation(pe.gradientX), this._initParticleRotation(pe.gradientY), this._initParticleRotation(pe.gradientZ)) : ht.createByGradient(this._initParticleRotation(pe.gradient));
                    break;

                  case 2:
                    if (pe.separateAxes) {
                        var ge = pe.constantMinSeparate, xe = pe.constantMaxSeparate;
                        fe = ht.createByRandomTwoConstantSeparate(new Te(ge[0] * i, ge[1] * i, ge[2] * i), new Te(xe[0] * i, xe[1] * i, xe[2] * i));
                    } else fe = ht.createByRandomTwoConstant(pe.constantMin * i, pe.constantMax * i);
                    break;

                  case 3:
                    pe.separateAxes || (fe = ht.createByRandomTwoGradient(this._initParticleRotation(pe.gradientMin), this._initParticleRotation(pe.gradientMax)));
                }
                var Me = new Pt(fe);
                Me.enbale = de.enable, h.rotationOverLifetime = Me;
            }
            var ye = e.textureSheetAnimation;
            if (ye) {
                var De, Re = ye.frame;
                switch (Re.type) {
                  case 0:
                    De = Y.createByConstant(Re.constant);
                    break;

                  case 1:
                    De = Y.createByOverTime(this._initParticleFrame(Re.overTime));
                    break;

                  case 2:
                    De = Y.createByRandomTwoConstant(Re.constantMin, Re.constantMax);
                    break;

                  case 3:
                    De = Y.createByRandomTwoOverTime(this._initParticleFrame(Re.overTimeMin), this._initParticleFrame(Re.overTimeMax));
                }
                var Ce, Ie = ye.startFrame;
                switch (Ie.type) {
                  case 0:
                    Ce = yt.createByConstant(Ie.constant);
                    break;

                  case 1:
                    Ce = yt.createByRandomTwoConstant(Ie.constantMin, Ie.constantMax);
                }
                var Ae = new Oe(De, Ce);
                Ae.enable = ye.enable;
                var Le = ye.tiles;
                Ae.tiles = new Se(Le[0], Le[1]), Ae.type = ye.type, Ae.randomRow = ye.randomRow;
                var Pe = ye.rowIndex;
                void 0 !== Pe && (Ae.rowIndex = Pe), Ae.cycles = ye.cycles, h.textureSheetAnimation = Ae;
            }
        }, t._activeHierarchy = function(e) {
            laya.display.Node.prototype._activeHierarchy.call(this, e), this.particleSystem.playOnAwake && this.particleSystem.play();
        }, t._inActiveHierarchy = function(e) {
            laya.display.Node.prototype._inActiveHierarchy.call(this, e), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
        }, t._cloneTo = function(e, t, n) {
            var i = e, r = i._particleSystem;
            this._particleSystem.cloneTo(r);
            var a = i._render, o = this._render;
            a.sharedMaterials = o.sharedMaterials, a.enable = o.enable, a.renderMode = o.renderMode, 
            a.mesh = o.mesh, a.stretchedBillboardCameraSpeedScale = o.stretchedBillboardCameraSpeedScale, 
            a.stretchedBillboardSpeedScale = o.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = o.stretchedBillboardLengthScale, 
            a.sortingFudge = o.sortingFudge, laya.d3.core.Sprite3D.prototype._cloneTo.call(this, e, t, n);
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._particleSystem.destroy(), this._particleSystem = null);
        }, a(0, t, "particleSystem", function() {
            return this._particleSystem;
        }), a(0, t, "particleRenderer", function() {
            return this._render;
        }), ShuriKenParticle3D.__init__ = function() {
            ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("SPHERHBILLBOARD"), 
            ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("STRETCHEDBILLBOARD"), 
            ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("HORIZONTALBILLBOARD"), 
            ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = ShuriKenParticle3D.shaderDefines.registerDefine("VERTICALBILLBOARD"), 
            ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("COLOROVERLIFETIME"), 
            ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME"), 
            ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT"), 
            ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT"), 
            ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = ShuriKenParticle3D.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIME"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS"), 
            ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES"), 
            ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE"), 
            ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE"), 
            ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES"), 
            ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = ShuriKenParticle3D.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"), 
            ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH = ShuriKenParticle3D.shaderDefines.registerDefine("RENDERMODE_MESH"), 
            ShuriKenParticle3D.SHADERDEFINE_SHAPE = ShuriKenParticle3D.shaderDefines.registerDefine("SHAPE");
        }, ShuriKenParticle3D._initStartLife = function(e) {
            for (var t = new We(), n = e.startLifetimes, i = 0, r = n.length; i < r; i++) {
                var a = n[i];
                t.add(a.key, a.value);
            }
            return t;
        }, ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_BILLBOARD = 0, ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = 0, 
        ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = 0, ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = 0, 
        ShuriKenParticle3D.SHADERDEFINE_COLOROVERLIFETIME = 0, ShuriKenParticle3D.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = 0, 
        ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = 0, ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = 0, ShuriKenParticle3D.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = 0, ShuriKenParticle3D.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIME = 0, ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = 0, ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = 0, ShuriKenParticle3D.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = 0, 
        ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVE = 0, ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = 0, ShuriKenParticle3D.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = 0, 
        ShuriKenParticle3D.SHADERDEFINE_RENDERMODE_MESH = 0, ShuriKenParticle3D.SHADERDEFINE_SHAPE = 0, 
        i(ShuriKenParticle3D, [ "WORLDPOSITION", function() {
            return this.WORLDPOSITION = Ve.propertyNameToID("u_WorldPosition");
        }, "WORLDROTATION", function() {
            return this.WORLDROTATION = Ve.propertyNameToID("u_WorldRotation");
        }, "POSITIONSCALE", function() {
            return this.POSITIONSCALE = Ve.propertyNameToID("u_PositionScale");
        }, "SIZESCALE", function() {
            return this.SIZESCALE = Ve.propertyNameToID("u_SizeScale");
        }, "SCALINGMODE", function() {
            return this.SCALINGMODE = Ve.propertyNameToID("u_ScalingMode");
        }, "GRAVITY", function() {
            return this.GRAVITY = Ve.propertyNameToID("u_Gravity");
        }, "THREEDSTARTROTATION", function() {
            return this.THREEDSTARTROTATION = Ve.propertyNameToID("u_ThreeDStartRotation");
        }, "STRETCHEDBILLBOARDLENGTHSCALE", function() {
            return this.STRETCHEDBILLBOARDLENGTHSCALE = Ve.propertyNameToID("u_StretchedBillboardLengthScale");
        }, "STRETCHEDBILLBOARDSPEEDSCALE", function() {
            return this.STRETCHEDBILLBOARDSPEEDSCALE = Ve.propertyNameToID("u_StretchedBillboardSpeedScale");
        }, "SIMULATIONSPACE", function() {
            return this.SIMULATIONSPACE = Ve.propertyNameToID("u_SimulationSpace");
        }, "CURRENTTIME", function() {
            return this.CURRENTTIME = Ve.propertyNameToID("u_CurrentTime");
        }, "VOLVELOCITYCONST", function() {
            return this.VOLVELOCITYCONST = Ve.propertyNameToID("u_VOLVelocityConst");
        }, "VOLVELOCITYGRADIENTX", function() {
            return this.VOLVELOCITYGRADIENTX = Ve.propertyNameToID("u_VOLVelocityGradientX");
        }, "VOLVELOCITYGRADIENTY", function() {
            return this.VOLVELOCITYGRADIENTY = Ve.propertyNameToID("u_VOLVelocityGradientY");
        }, "VOLVELOCITYGRADIENTZ", function() {
            return this.VOLVELOCITYGRADIENTZ = Ve.propertyNameToID("u_VOLVelocityGradientZ");
        }, "VOLVELOCITYCONSTMAX", function() {
            return this.VOLVELOCITYCONSTMAX = Ve.propertyNameToID("u_VOLVelocityConstMax");
        }, "VOLVELOCITYGRADIENTXMAX", function() {
            return this.VOLVELOCITYGRADIENTXMAX = Ve.propertyNameToID("u_VOLVelocityGradientMaxX");
        }, "VOLVELOCITYGRADIENTYMAX", function() {
            return this.VOLVELOCITYGRADIENTYMAX = Ve.propertyNameToID("u_VOLVelocityGradientMaxY");
        }, "VOLVELOCITYGRADIENTZMAX", function() {
            return this.VOLVELOCITYGRADIENTZMAX = Ve.propertyNameToID("u_VOLVelocityGradientMaxZ");
        }, "VOLSPACETYPE", function() {
            return this.VOLSPACETYPE = Ve.propertyNameToID("u_VOLSpaceType");
        }, "COLOROVERLIFEGRADIENTALPHAS", function() {
            return this.COLOROVERLIFEGRADIENTALPHAS = Ve.propertyNameToID("u_ColorOverLifeGradientAlphas");
        }, "COLOROVERLIFEGRADIENTCOLORS", function() {
            return this.COLOROVERLIFEGRADIENTCOLORS = Ve.propertyNameToID("u_ColorOverLifeGradientColors");
        }, "MAXCOLOROVERLIFEGRADIENTALPHAS", function() {
            return this.MAXCOLOROVERLIFEGRADIENTALPHAS = Ve.propertyNameToID("u_MaxColorOverLifeGradientAlphas");
        }, "MAXCOLOROVERLIFEGRADIENTCOLORS", function() {
            return this.MAXCOLOROVERLIFEGRADIENTCOLORS = Ve.propertyNameToID("u_MaxColorOverLifeGradientColors");
        }, "SOLSIZEGRADIENT", function() {
            return this.SOLSIZEGRADIENT = Ve.propertyNameToID("u_SOLSizeGradient");
        }, "SOLSIZEGRADIENTX", function() {
            return this.SOLSIZEGRADIENTX = Ve.propertyNameToID("u_SOLSizeGradientX");
        }, "SOLSIZEGRADIENTY", function() {
            return this.SOLSIZEGRADIENTY = Ve.propertyNameToID("u_SOLSizeGradientY");
        }, "SOLSizeGradientZ", function() {
            return this.SOLSizeGradientZ = Ve.propertyNameToID("u_SOLSizeGradientZ");
        }, "SOLSizeGradientMax", function() {
            return this.SOLSizeGradientMax = Ve.propertyNameToID("u_SOLSizeGradientMax");
        }, "SOLSIZEGRADIENTXMAX", function() {
            return this.SOLSIZEGRADIENTXMAX = Ve.propertyNameToID("u_SOLSizeGradientMaxX");
        }, "SOLSIZEGRADIENTYMAX", function() {
            return this.SOLSIZEGRADIENTYMAX = Ve.propertyNameToID("u_SOLSizeGradientMaxY");
        }, "SOLSizeGradientZMAX", function() {
            return this.SOLSizeGradientZMAX = Ve.propertyNameToID("u_SOLSizeGradientMaxZ");
        }, "ROLANGULARVELOCITYCONST", function() {
            return this.ROLANGULARVELOCITYCONST = Ve.propertyNameToID("u_ROLAngularVelocityConst");
        }, "ROLANGULARVELOCITYCONSTSEPRARATE", function() {
            return this.ROLANGULARVELOCITYCONSTSEPRARATE = Ve.propertyNameToID("u_ROLAngularVelocityConstSeprarate");
        }, "ROLANGULARVELOCITYGRADIENT", function() {
            return this.ROLANGULARVELOCITYGRADIENT = Ve.propertyNameToID("u_ROLAngularVelocityGradient");
        }, "ROLANGULARVELOCITYGRADIENTX", function() {
            return this.ROLANGULARVELOCITYGRADIENTX = Ve.propertyNameToID("u_ROLAngularVelocityGradientX");
        }, "ROLANGULARVELOCITYGRADIENTY", function() {
            return this.ROLANGULARVELOCITYGRADIENTY = Ve.propertyNameToID("u_ROLAngularVelocityGradientY");
        }, "ROLANGULARVELOCITYGRADIENTZ", function() {
            return this.ROLANGULARVELOCITYGRADIENTZ = Ve.propertyNameToID("u_ROLAngularVelocityGradientZ");
        }, "ROLANGULARVELOCITYCONSTMAX", function() {
            return this.ROLANGULARVELOCITYCONSTMAX = Ve.propertyNameToID("u_ROLAngularVelocityConstMax");
        }, "ROLANGULARVELOCITYCONSTMAXSEPRARATE", function() {
            return this.ROLANGULARVELOCITYCONSTMAXSEPRARATE = Ve.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate");
        }, "ROLANGULARVELOCITYGRADIENTMAX", function() {
            return this.ROLANGULARVELOCITYGRADIENTMAX = Ve.propertyNameToID("u_ROLAngularVelocityGradientMax");
        }, "ROLANGULARVELOCITYGRADIENTXMAX", function() {
            return this.ROLANGULARVELOCITYGRADIENTXMAX = Ve.propertyNameToID("u_ROLAngularVelocityGradientMaxX");
        }, "ROLANGULARVELOCITYGRADIENTYMAX", function() {
            return this.ROLANGULARVELOCITYGRADIENTYMAX = Ve.propertyNameToID("u_ROLAngularVelocityGradientMaxY");
        }, "ROLANGULARVELOCITYGRADIENTZMAX", function() {
            return this.ROLANGULARVELOCITYGRADIENTZMAX = Ve.propertyNameToID("u_ROLAngularVelocityGradientMaxZ");
        }, "ROLANGULARVELOCITYGRADIENTWMAX", function() {
            return this.ROLANGULARVELOCITYGRADIENTWMAX = Ve.propertyNameToID("u_ROLAngularVelocityGradientMaxW");
        }, "TEXTURESHEETANIMATIONCYCLES", function() {
            return this.TEXTURESHEETANIMATIONCYCLES = Ve.propertyNameToID("u_TSACycles");
        }, "TEXTURESHEETANIMATIONSUBUVLENGTH", function() {
            return this.TEXTURESHEETANIMATIONSUBUVLENGTH = Ve.propertyNameToID("u_TSASubUVLength");
        }, "TEXTURESHEETANIMATIONGRADIENTUVS", function() {
            return this.TEXTURESHEETANIMATIONGRADIENTUVS = Ve.propertyNameToID("u_TSAGradientUVs");
        }, "TEXTURESHEETANIMATIONGRADIENTMAXUVS", function() {
            return this.TEXTURESHEETANIMATIONGRADIENTMAXUVS = Ve.propertyNameToID("u_TSAMaxGradientUVs");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Jn.shaderDefines);
        } ]), ShuriKenParticle3D;
    }(Jn), Mi = function(e) {
        function PixelLineSprite3D(e, t) {
            this._geometryFilter = null, void 0 === e && (e = 2), PixelLineSprite3D.__super.call(this, t), 
            this._geometryFilter = new mn(this, e), this._render = new jn(this), this._changeRenderObjects(this._render, 0, ri.defaultMaterial);
        }
        r(PixelLineSprite3D, "laya.d3.core.pixelLine.PixelLineSprite3D", Jn);
        var t = PixelLineSprite3D.prototype;
        return t._changeRenderObjects = function(e, t, n) {
            var i = this._render._renderElements;
            n || (n = ri.defaultMaterial);
            var r = i[t];
            r || (r = i[t] = new Ie()), r.setTransform(this._transform), r.setGeometry(this._geometryFilter), 
            r.render = this._render, r.material = n;
        }, t.addLine = function(e, t, n, i) {
            if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
            this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, n, i);
        }, t.addLines = function(e) {
            var t = this._geometryFilter._lineCount, n = e.length;
            if (t + n > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
            this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += n;
        }, t.removeLine = function(e) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._removeLineData(e);
        }, t.setLine = function(e, t, n, i, r) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._updateLineData(e, t, n, i, r);
        }, t.getLine = function(e, t) {
            if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._getLineData(e, t);
        }, t.clear = function() {
            this._geometryFilter._lineCount = 0;
        }, a(0, t, "maxLineCount", function() {
            return this._geometryFilter._maxLineCount;
        }, function(e) {
            this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
        }), a(0, t, "pixelLineRenderer", function() {
            return this._render;
        }), a(0, t, "lineCount", function() {
            return this._geometryFilter._lineCount;
        }, function(e) {
            if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
            this._geometryFilter._lineCount = e;
        }), PixelLineSprite3D;
    }(), yi = function(e) {
        function SkinnedMeshSprite3D(e, t) {
            SkinnedMeshSprite3D.__super.call(this, t), this._meshFilter = new $e(this), this._render = new mi(this), 
            e && (this._meshFilter.sharedMesh = e);
        }
        r(SkinnedMeshSprite3D, "laya.d3.core.SkinnedMeshSprite3D", e);
        var t = SkinnedMeshSprite3D.prototype;
        return t._parse = function(e, t) {
            laya.d3.core.Sprite3D.prototype._parse.call(this, e, t);
            var n = this.skinnedMeshRenderer, i = e.lightmapIndex;
            null != i && (n.lightmapIndex = i);
            var r, a = e.lightmapScaleOffset;
            if (a && (n.lightmapScaleOffset = new me(a[0], a[1], a[2], a[3])), r = e.meshPath) {
                var o = g.getRes(r);
                o && (this.meshFilter.sharedMesh = o);
            }
            var s = e.materials;
            if (s) {
                var l = n.sharedMaterials, h = s.length;
                l.length = h;
                for (var u = 0; u < h; u++) l[u] = g.getRes(s[u].path);
                n.sharedMaterials = l;
            }
            var c = e.boundBox, d = c.min, _ = c.max;
            if (n.localBounds.setMin(new Te(d[0], d[1], d[2])), n.localBounds.setMax(new Te(_[0], _[1], _[2])), 
            t) {
                var f = e.rootBone;
                n.rootBone = t[f];
                var m, p = e.bones;
                for (u = 0, m = p.length; u < m; u++) n.bones.push(t[p[u]]);
            } else e.rootBone && n._setRootBone(e.rootBone);
        }, t._changeHierarchyAnimator = function(t) {
            e.prototype._changeHierarchyAnimator.call(this, t), this.skinnedMeshRenderer._setCacheAnimator(t);
        }, t._changeAnimatorAvatar = function(e) {
            this.skinnedMeshRenderer._setCacheAvatar(e);
        }, t._cloneTo = function(e, t, n) {
            var i = e;
            i.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
            var r = this._render, a = i._render;
            a.enable = r.enable, a.sharedMaterials = r.sharedMaterials, a.castShadow = r.castShadow;
            var o = r.lightmapScaleOffset;
            o && (a.lightmapScaleOffset = o.clone()), a.receiveShadow = r.receiveShadow, a.sortingFudge = r.sortingFudge, 
            a._rootBone = r._rootBone;
            var s = r.bones, l = a.bones, h = s.length;
            l.length = h;
            var u = r.rootBone;
            if (u) {
                var c = ke._getHierarchyPath(t, u, SkinnedMeshSprite3D._tempArray0);
                a.rootBone = c ? ke._getNodeByHierarchyPath(n, c) : u;
            }
            for (var d = 0; d < s.length; d++) c = ke._getHierarchyPath(t, s[d], SkinnedMeshSprite3D._tempArray0), 
            l[d] = c ? ke._getNodeByHierarchyPath(n, c) : s[d];
            var _ = r.localBounds;
            _ && _.cloneTo(a.localBounds), laya.d3.core.Sprite3D.prototype._cloneTo.call(this, e, t, n);
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._meshFilter.destroy());
        }, a(0, t, "meshFilter", function() {
            return this._meshFilter;
        }), a(0, t, "skinnedMeshRenderer", function() {
            return this._render;
        }), SkinnedMeshSprite3D.__init__ = function() {
            SkinnedMeshSprite3D.SHADERDEFINE_BONE = SkinnedMeshSprite3D.shaderDefines.registerDefine("BONE");
        }, SkinnedMeshSprite3D._tempArray0 = [], SkinnedMeshSprite3D.SHADERDEFINE_BONE = 0, 
        i(SkinnedMeshSprite3D, [ "BONES", function() {
            return this.BONES = Ve.propertyNameToID("u_Bones");
        }, "shaderDefines", function() {
            return this.shaderDefines = new pe(Si.shaderDefines);
        } ]), SkinnedMeshSprite3D;
    }(Jn), Di = function(e) {
        function PointLight() {
            this._range = NaN, this._lightMatrix = new Ht(), PointLight.__super.call(this), 
            this._range = 6;
        }
        r(PointLight, "laya.d3.core.light.PointLight", e);
        var t = PointLight.prototype;
        return t._onActive = function() {
            e.prototype._onActive.call(this), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.add(qn.SHADERDEFINE_POINTLIGHT);
        }, t._onInActive = function() {
            e.prototype._onInActive.call(this), this._lightmapBakedType !== ei.LIGHTMAPBAKEDTYPE_BAKED && this._scene._defineDatas.remove(qn.SHADERDEFINE_POINTLIGHT);
        }, t._prepareToScene = function() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                e._defineDatas;
                var t = e._shaderValues;
                Te.scale(this.color, this._intensity, this._intensityColor), t.setVector3(qn.POINTLIGHTCOLOR, this._intensityColor), 
                t.setVector3(qn.POINTLIGHTPOS, this.transform.position), t.setNumber(qn.POINTLIGHTRANGE, this.range);
                var n = this._lightMatrix, i = n.elements;
                n.identity(), i[0] = i[5] = i[10] = 1 / this._range;
                var r = PointLight._tempMatrix0;
                return this.transform.worldMatrix.invert(r), Ht.multiply(n, r, n), t.setMatrix4x4(qn.POINTLIGHTMATRIX, n), 
                !0;
            }
            return !1;
        }, t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n), this.range = t.range;
        }, a(0, t, "range", function() {
            return this._range;
        }, function(e) {
            this._range = e;
        }), i(PointLight, [ "_tempMatrix0", function() {
            return this._tempMatrix0 = new Ht();
        } ]), PointLight;
    }(ei), Ri = function(e) {
        function TerrainChunk(e, t, n, i, r, a, o, s) {
            this._terrainFilter = null, TerrainChunk.__super.call(this, s), this._terrainFilter = new Rn(this, e, t, n, i, r, a, o), 
            this._render = new Zn(this);
        }
        r(TerrainChunk, "laya.d3.terrain.TerrainChunk", e);
        var t = TerrainChunk.prototype;
        return t.buildRenderElementAndMaterial = function(e, t, n, i, r, a, o, s, l, h, u, c, d, _, f, m, p, T) {
            void 0 === u && (u = 1), void 0 === c && (c = 1), void 0 === d && (d = 1), void 0 === _ && (_ = 1), 
            void 0 === f && (f = 1), void 0 === m && (m = 1), void 0 === p && (p = 1), void 0 === T && (T = 1);
            var S = new di();
            l && (S.diffuseColor = l), s && (S.ambientColor = s), h && (S.specularColor = h), 
            S.splatAlphaTexture = g.getRes(n), S.normalTexture = t ? g.getRes(t) : null, S.diffuseTexture1 = i ? g.getRes(i) : null, 
            S.diffuseTexture2 = r ? g.getRes(r) : null, S.diffuseTexture3 = a ? g.getRes(a) : null, 
            S.diffuseTexture4 = o ? g.getRes(o) : null, S.setDiffuseScale1(u, c), S.setDiffuseScale2(d, _), 
            S.setDiffuseScale3(f, m), S.setDiffuseScale4(p, T), S.setDetailNum(e), 0 != this._render._renderElements.length && (S.renderMode = 2);
            var E = new Ie();
            E.setTransform(this._transform), E.render = this._render, E.setGeometry(this._terrainFilter), 
            this._render._renderElements.push(E), this._render.sharedMaterial = S;
        }, t._cloneTo = function(e, t, n) {
            console.log("Terrain Chunk can't clone");
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this.destroyed || (e.prototype.destroy.call(this, t), 
            this._terrainFilter.destroy(), this._terrainFilter = null);
        }, a(0, t, "terrainFilter", function() {
            return this._terrainFilter;
        }), a(0, t, "terrainRender", function() {
            return this._render;
        }), TerrainChunk;
    }(Jn), Ci = function(e) {
        function Camera(e, t, n) {
            this._updateViewMatrix = !0, this._offScreenRenderTexture = null, this._alwaysUseRenderTexture = !1, 
            this._renderTexture = null, this._postProcess = null, this.enableRender = !0, this._screenShaderData = new ue(), 
            this._postProcessCommandBuffers = [], void 0 === e && (e = 0), void 0 === t && (t = .3), 
            void 0 === n && (n = 1e3), this._viewMatrix = new Ht(), this._projectionMatrix = new Ht(), 
            this._projectionViewMatrix = new Ht(), this._projectionViewMatrixNoTranslateScale = new Ht(), 
            this._viewport = new Ct(0, 0, 0, 0), this._normalizedViewport = new Ct(0, 0, 1, 1), 
            this._aspectRatio = e, this._boundFrustum = new Vt(Ht.DEFAULT), R.supportWebGLPlusCulling && (this._boundFrustumBuffer = new Float32Array(24)), 
            Camera.__super.call(this, t, n), this.transform.on("transformchanged", this, this._onTransformChanged);
        }
        r(Camera, "laya.d3.core.Camera", e);
        var t = Camera.prototype;
        return t._isLayerVisible = function(e) {
            return 0 != (Math.pow(2, e) & this.cullingMask);
        }, t._onTransformChanged = function(e) {
            (e &= 64) && (this._updateViewMatrix = !0);
        }, t._calculationViewport = function(e, t, n) {
            var i = e.x * t, r = e.y * n, a = i + Math.max(e.width * t, 0), o = r + Math.max(e.height * n, 0), s = Math.ceil(i), l = Math.ceil(r), h = Math.floor(a), u = Math.floor(o), c = s - i >= .5 ? Math.floor(i) : s, d = l - r >= .5 ? Math.floor(r) : l, _ = a - h >= .5 ? Math.ceil(a) : h, f = o - u >= .5 ? Math.ceil(o) : u;
            this._viewport.x = c, this._viewport.y = d, this._viewport.width = _ - c, this._viewport.height = f - d;
        }, t._parse = function(t, n) {
            e.prototype._parse.call(this, t, n);
            var i = t.viewport;
            this.normalizedViewport = new Ct(i[0], i[1], i[2], i[3]);
        }, t._calculateProjectionMatrix = function() {
            if (!this._useUserProjectionMatrix) if (this._orthographic) {
                var e = this.orthographicVerticalSize * this.aspectRatio * .5, t = .5 * this.orthographicVerticalSize;
                Ht.createOrthoOffCenter(-e, e, -t, t, this.nearPlane, this.farPlane, this._projectionMatrix);
            } else Ht.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
        }, t._getCanvasHeight = function() {
            return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : J.clientHeight;
        }, t._applyPostProcessCommandBuffers = function() {
            for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) this._postProcessCommandBuffers[e]._apply();
        }, t._needForceSetRenderTexture = function() {
            return this._alwaysUseRenderTexture && !this._offScreenRenderTexture;
        }, t.render = function(e, t) {
            if (this._scene) {
                var n = this._needForceSetRenderTexture();
                n && (this._renderTexture = pi.getTemporary(J.clientWidth, J.clientHeight, 0, 0, 1));
                var i, r, a = E.instance, o = J._instance, s = o.scene = this._scene;
                if (s.parallelSplitShadowMaps[0]) {
                    ue.setRuntimeValueMode(!1);
                    var l = s.parallelSplitShadowMaps[0];
                    l._calcAllLightCameraInfo(this), s._defineDatas.add(qn.SHADERDEFINE_CAST_SHADOW);
                    for (var h = 0, u = l.shadowMapCount; h < u; h++) {
                        var c = l.cameras[h];
                        o.camera = c, o.projectionViewMatrix = c.projectionViewMatrix, Bt.renderObjectCulling(c, s, o, s._castShadowRenders);
                        var d = l.cameras[h + 1].renderTarget;
                        d._start(), o.camera = c, o.viewport = c.viewport, c._prepareCameraToRender(), c._prepareCameraViewProject(c.viewMatrix, c.projectionMatrix, o.projectionViewMatrix, c._projectionViewMatrixNoTranslateScale), 
                        s._clear(a, o), s._opaqueQueue._render(o, !1), d._end();
                    }
                    s._defineDatas.remove(qn.SHADERDEFINE_CAST_SHADOW), ue.setRuntimeValueMode(!0);
                }
                o.camera = this, s._preRenderScript(), i = o.viewMatrix = this.viewMatrix;
                var _ = this._renderTexture;
                if (_ ? (_._start(), Ht.multiply(ai._invertYScaleMatrix, this._projectionMatrix, ai._invertYProjectionMatrix), 
                Ht.multiply(ai._invertYScaleMatrix, this.projectionViewMatrix, ai._invertYProjectionViewMatrix), 
                r = o.projectionMatrix = ai._invertYProjectionMatrix, o.projectionViewMatrix = ai._invertYProjectionViewMatrix) : (r = o.projectionMatrix = this._projectionMatrix, 
                o.projectionViewMatrix = this.projectionViewMatrix), o.viewport = this.viewport, 
                this._prepareCameraToRender(), this._prepareCameraViewProject(i, r, o.projectionViewMatrix, this._projectionViewMatrixNoTranslateScale), 
                s._preCulling(o, this), s._clear(a, o), s._renderScene(a, o, e, t), s._postRenderScript(), 
                _ && _._end(), this._postProcess && this._postProcess._render(), n) {
                    var f = nn.create(this._renderTexture, null, lt.screenShader, this._screenShaderData);
                    f.run(), f.recover(), pi.setReleaseTemporary(this._renderTexture);
                }
            }
        }, t.viewportPointToRay = function(e, t) {
            ct.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }, t.normalizedViewportPointToRay = function(e, t) {
            var n = Camera._tempVector20, i = this.viewport;
            n.x = e.x * i.width, n.y = e.y * i.height, ct.calculateCursorRay(n, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }, t.worldToViewportPoint = function(e, t) {
            Ht.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
            this.viewport.project(e, this._projectionViewMatrix, t), t.x = t.x / n.stage.clientScaleX, 
            t.y = t.y / n.stage.clientScaleY;
        }, t.worldToNormalizedViewportPoint = function(e, t) {
            Ht.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix), 
            this.normalizedViewport.project(e, this._projectionViewMatrix, t), t.x = t.x / n.stage.clientScaleX, 
            t.y = t.y / n.stage.clientScaleY;
        }, t.convertScreenCoordToOrthographicCoord = function(e, t) {
            if (this._orthographic) {
                var n = J.clientWidth, i = J.clientHeight, r = this.orthographicVerticalSize * this.aspectRatio / n, a = this.orthographicVerticalSize / i;
                return t.x = (-n / 2 + e.x) * r, t.y = (i / 2 - e.y) * a, t.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane, 
                Te.transformCoordinate(t, this.transform.worldMatrix, t), !0;
            }
            return !1;
        }, t.destroy = function(t) {
            void 0 === t && (t = !0), this._offScreenRenderTexture = null, this.transform.off("transformchanged", this, this._onTransformChanged), 
            e.prototype.destroy.call(this, t);
        }, t.addCommandBuffer = function(e, t) {
            switch (e) {
              case 0:
                this._postProcessCommandBuffers.push(t);
                break;

              default:
                throw "Camera:unknown event.";
            }
        }, t.removeCommandBuffer = function(e, t) {
            switch (e) {
              case 0:
                var n = this._postProcessCommandBuffers.indexOf(t);
                -1 !== n && this._postProcessCommandBuffers.splice(n, 1);
                break;

              default:
                throw "Camera:unknown event.";
            }
        }, t.removeCommandBuffers = function(e) {
            switch (e) {
              case 0:
                this._postProcessCommandBuffers.length = 0;
                break;

              default:
                throw "Camera:unknown event.";
            }
        }, t.getRenderTexture = function() {
            return this._renderTexture;
        }, a(0, t, "renderTarget", function() {
            return this._offScreenRenderTexture;
        }, function(e) {
            this._offScreenRenderTexture !== e && (this._offScreenRenderTexture = e, this._renderTexture = e, 
            this._calculateProjectionMatrix());
        }), a(0, t, "projectionViewMatrix", function() {
            return Ht.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix), 
            this._projectionViewMatrix;
        }), a(0, t, "aspectRatio", function() {
            if (0 === this._aspectRatio) {
                var e = this.viewport;
                return e.width / e.height;
            }
            return this._aspectRatio;
        }, function(e) {
            if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
            this._aspectRatio = e, this._calculateProjectionMatrix();
        }), a(0, t, "boundFrustum", function() {
            if (this._boundFrustum.matrix = this.projectionViewMatrix, R.supportWebGLPlusCulling) {
                var e = this._boundFrustum.near, t = this._boundFrustum.far, n = this._boundFrustum.left, i = this._boundFrustum.right, r = this._boundFrustum.top, a = this._boundFrustum.bottom, o = e.normal, s = t.normal, l = n.normal, h = i.normal, u = r.normal, c = a.normal, d = this._boundFrustumBuffer;
                d[0] = o.x, d[1] = o.y, d[2] = o.z, d[3] = e.distance, d[4] = s.x, d[5] = s.y, d[6] = s.z, 
                d[7] = t.distance, d[8] = l.x, d[9] = l.y, d[10] = l.z, d[11] = n.distance, d[12] = h.x, 
                d[13] = h.y, d[14] = h.z, d[15] = i.distance, d[16] = u.x, d[17] = u.y, d[18] = u.z, 
                d[19] = r.distance, d[20] = c.x, d[21] = c.y, d[22] = c.z, d[23] = a.distance;
            }
            return this._boundFrustum;
        }), a(0, t, "viewport", function() {
            return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, J.clientWidth, J.clientHeight), 
            this._viewport;
        }, function(e) {
            var t = 0, n = 0;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, n = this._offScreenRenderTexture.height) : (t = J.clientWidth, 
            n = J.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / n, 
            this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / n, 
            this._calculationViewport(this._normalizedViewport, t, n), this._calculateProjectionMatrix();
        }), a(0, t, "alwaysUseRenderTexture", function() {
            return this._alwaysUseRenderTexture;
        }, function(e) {
            this._alwaysUseRenderTexture = e;
        }), a(0, t, "normalizedViewport", function() {
            return this._normalizedViewport;
        }, function(e) {
            var t = 0, n = 0;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, n = this._offScreenRenderTexture.height) : (t = J.clientWidth, 
            n = J.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport), 
            this._calculationViewport(e, t, n), this._calculateProjectionMatrix();
        }), a(0, t, "projectionMatrix", function() {
            return this._projectionMatrix;
        }, function(e) {
            this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
        }), a(0, t, "viewMatrix", function() {
            if (this._updateViewMatrix) {
                var e = this.transform.scale, t = e.x, n = e.y, i = e.z, r = this._viewMatrix.elements;
                this.transform.worldMatrix.cloneTo(this._viewMatrix), r[0] /= t, r[1] /= t, r[2] /= t, 
                r[4] /= n, r[5] /= n, r[6] /= n, r[8] /= i, r[9] /= i, r[10] /= i, this._viewMatrix.invert(this._viewMatrix), 
                this._updateViewMatrix = !1;
            }
            return this._viewMatrix;
        }), a(0, t, "postProcess", function() {
            return this._postProcess;
        }, function(e) {
            this._postProcess = e, this.alwaysUseRenderTexture = !0;
            var t = new lt();
            this.addCommandBuffer(0, t), e._init(this, t);
        }), Camera.CAMERAEVENT_POSTPROCESS = 0, Camera._updateMark = 0, i(Camera, [ "_tempVector20", function() {
            return this._tempVector20 = new Se();
        } ]), Camera;
    }(ai);
    !function(e) {
        function MeshTerrainSprite3D(e, t, n) {
            this._minX = NaN, this._minZ = NaN, this._cellSize = null, this._heightMap = null, 
            MeshTerrainSprite3D.__super.call(this, e, n), this._heightMap = t, this._cellSize = new Se();
        }
        r(MeshTerrainSprite3D, "laya.d3.core.MeshTerrainSprite3D", Si);
        var t = MeshTerrainSprite3D.prototype;
        t._disableRotation = function() {
            var e = this.transform.rotation;
            e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
        }, t._getScaleX = function() {
            var e = this.transform.worldMatrix.elements, t = e[0], n = e[1], i = e[2];
            return Math.sqrt(t * t + n * n + i * i);
        }, t._getScaleZ = function() {
            var e = this.transform.worldMatrix.elements, t = e[8], n = e[9], i = e[10];
            return Math.sqrt(t * t + n * n + i * i);
        }, t._initCreateFromMesh = function(e, t) {
            this._heightMap = Ge.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
            var n = this.meshFilter.sharedMesh.bounds, i = n.getMin();
            n.getMax();
            this._minX = i.x, this._minZ = i.z;
        }, t._initCreateFromMeshHeightMap = function(e, t, n) {
            var i = this.meshFilter.sharedMesh.bounds;
            this._heightMap = Ge.createFromImage(e, t, n), this._computeCellSize(i);
            var r = i.getMin();
            i.getMax();
            this._minX = r.x, this._minZ = r.z;
        }, t._computeCellSize = function(e) {
            var t = e.getMin(), n = e.getMax(), i = t.x, r = t.z, a = n.x - i, o = n.z - r;
            this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = o / (this._heightMap.height - 1);
        }, t._update = function(e) {
            this._disableRotation();
        }, t.getHeight = function(e, t) {
            MeshTerrainSprite3D._tempVector3.x = e, MeshTerrainSprite3D._tempVector3.y = 0, 
            MeshTerrainSprite3D._tempVector3.z = t, this._disableRotation();
            var n = this.transform.worldMatrix;
            n.invert(MeshTerrainSprite3D._tempMatrix4x4), Te.transformCoordinate(MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4, MeshTerrainSprite3D._tempVector3), 
            e = MeshTerrainSprite3D._tempVector3.x, t = MeshTerrainSprite3D._tempVector3.z;
            var i = (e - this._minX) / this._cellSize.x, r = (t - this._minZ) / this._cellSize.y, a = Math.floor(r), o = Math.floor(i), s = i - o, l = r - a, h = n.elements, u = h[4], c = h[5], d = h[6], _ = Math.sqrt(u * u + c * c + d * d), f = h[13], m = this._heightMap.getHeight(a, o + 1), p = this._heightMap.getHeight(a + 1, o);
            if (isNaN(m) || isNaN(p)) return NaN;
            if (s + l <= 1) {
                var T = this._heightMap.getHeight(a, o);
                return isNaN(T) ? NaN : (T + s * (m - T) + l * (p - T)) * _ + f;
            }
            var S = this._heightMap.getHeight(a + 1, o + 1);
            return isNaN(S) ? NaN : (S + (1 - s) * (p - S) + (1 - l) * (m - S)) * _ + f;
        }, a(0, t, "minX", function() {
            var e = this.transform.worldMatrix.elements;
            return this._minX * this._getScaleX() + e[12];
        }), a(0, t, "width", function() {
            return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
        }), a(0, t, "minZ", function() {
            var e = this.transform.worldMatrix.elements;
            return this._minZ * this._getScaleZ() + e[14];
        }), a(0, t, "depth", function() {
            return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
        }), MeshTerrainSprite3D.createFromMesh = function(e, t, n, i) {
            var r = new MeshTerrainSprite3D(e, null, i);
            return r._initCreateFromMesh(t, n), r;
        }, MeshTerrainSprite3D.createFromMeshAndHeightMap = function(e, t, n, i, r) {
            var a = new MeshTerrainSprite3D(e, null, r);
            return a._initCreateFromMeshHeightMap(t, n, i), a;
        }, i(MeshTerrainSprite3D, [ "_tempVector3", function() {
            return this._tempVector3 = new Te();
        }, "_tempMatrix4x4", function() {
            return this._tempMatrix4x4 = new Ht();
        } ]);
    }();
}(window, document, Laya);