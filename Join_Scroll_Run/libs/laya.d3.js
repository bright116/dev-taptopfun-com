! function(require, module, exports) {
	"use strict";

	function _typeof(e) {
		return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
			return typeof e
		} : function(e) {
			return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ?
				"symbol" : typeof e
		})(e)
	}

	function set(e, t, r, n) {
		return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(e, t, r, n) {
			var i, a = _superPropBase(e, t);
			if (a) {
				if ((i = Object.getOwnPropertyDescriptor(a, t)).set) return i.set.call(n, r), !0;
				if (!i.writable) return !1
			}
			if (i = Object.getOwnPropertyDescriptor(n, t)) {
				if (!i.writable) return !1;
				i.value = r, Object.defineProperty(n, t, i)
			} else _defineProperty(n, t, r);
			return !0
		})(e, t, r, n)
	}

	function _set(e, t, r, n, i) {
		if (!set(e, t, r, n || e) && i) throw new Error("failed to set property");
		return r
	}

	function _defineProperty(e, t, r) {
		return t in e ? Object.defineProperty(e, t, {
			value: r,
			enumerable: !0,
			configurable: !0,
			writable: !0
		}) : e[t] = r, e
	}

	function _get(e, t, r) {
		return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, r) {
			var n = _superPropBase(e, t);
			if (n) {
				var i = Object.getOwnPropertyDescriptor(n, t);
				return i.get ? i.get.call(r) : i.value
			}
		})(e, t, r || e)
	}

	function _superPropBase(e, t) {
		for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)););
		return e
	}

	function _possibleConstructorReturn(e, t) {
		return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t
	}

	function _assertThisInitialized(e) {
		if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		return e
	}

	function _getPrototypeOf(e) {
		return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
			return e.__proto__ || Object.getPrototypeOf(e)
		})(e)
	}

	function _inherits(e, t) {
		if ("function" != typeof t && null !== t) throw new TypeError(
			"Super expression must either be null or a function");
		e.prototype = Object.create(t && t.prototype, {
			constructor: {
				value: e,
				writable: !0,
				configurable: !0
			}
		}), t && _setPrototypeOf(e, t)
	}

	function _setPrototypeOf(e, t) {
		return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
			return e.__proto__ = t, e
		})(e, t)
	}

	function _classCallCheck(e, t) {
		if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
	}

	function _defineProperties(e, t) {
		for (var r = 0; r < t.length; r++) {
			var n = t[r];
			n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object
				.defineProperty(e, n.key, n)
		}
	}

	function _createClass(e, t, r) {
		return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e
	}! function(e, t) {
		var r = function() {
			function MathUtils3D() {
				_classCallCheck(this, MathUtils3D)
			}
			return _createClass(MathUtils3D, null, [{
				key: "isZero",
				value: function(e) {
					return Math.abs(e) < MathUtils3D.zeroTolerance
				}
			}, {
				key: "nearEqual",
				value: function(e, t) {
					return !!MathUtils3D.isZero(e - t)
				}
			}, {
				key: "fastInvSqrt",
				value: function(e) {
					return MathUtils3D.isZero(e) ? e : 1 / Math.sqrt(e)
				}
			}]), MathUtils3D
		}();
		r.zeroTolerance = 1e-6, r.MaxValue = 340282347e30, r.MinValue = -340282347e30, r.Deg2Rad = Math.PI / 180;
		var n = function() {
			function Vector2() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
				_classCallCheck(this, Vector2), this.x = e, this.y = t
			}
			return _createClass(Vector2, [{
				key: "setValue",
				value: function(e, t) {
					this.x = e, this.y = t
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.x = e[t + 0], this.y = e[t + 1]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t.x = this.x, t.y = this.y
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Vector2;
					return this.cloneTo(e), e
				}
			}, {
				key: "forNativeElement",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) :
						this.elements = new Float32Array([this.x, this.y]), Vector2
						.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1)
				}
			}], [{
				key: "scale",
				value: function(e, t, r) {
					r.x = e.x * t, r.y = e.y * t
				}
			}, {
				key: "dot",
				value: function(e, t) {
					return e.x * t.x + e.y * t.y
				}
			}, {
				key: "normalize",
				value: function(e, t) {
					var r = e.x,
						n = e.y,
						i = r * r + n * n;
					i > 0 && (i = 1 / Math.sqrt(i), t.x = r * i, t.y = n * i)
				}
			}, {
				key: "scalarLength",
				value: function(e) {
					var t = e.x,
						r = e.y;
					return Math.sqrt(t * t + r * r)
				}
			}, {
				key: "rewriteNumProperty",
				value: function(e, t, r) {
					Object.defineProperty(e, t, {
						get: function() {
							return this.elements[r]
						},
						set: function(e) {
							this.elements[r] = e
						}
					})
				}
			}]), Vector2
		}();
		n.ZERO = new n(0, 0), n.ONE = new n(1, 1);
		var i = function() {
			function Vector4() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
				_classCallCheck(this, Vector4), this.x = e, this.y = t, this.z = r, this.w = n
			}
			return _createClass(Vector4, [{
				key: "setValue",
				value: function(e, t, r, n) {
					this.x = e, this.y = t, this.z = r, this.w = n
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Vector4;
					return this.cloneTo(e), e
				}
			}, {
				key: "length",
				value: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w *
						this.w)
				}
			}, {
				key: "lengthSquared",
				value: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
			}, {
				key: "forNativeElement",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y,
							this.elements[2] = this.z, this.elements[3] = this.w) : this.elements =
						new Float32Array([this.x, this.y, this.z, this.w]), n.rewriteNumProperty(
							this, "x", 0), n.rewriteNumProperty(this, "y", 1), n.rewriteNumProperty(
							this, "z", 2), n.rewriteNumProperty(this, "w", 3)
				}
			}], [{
				key: "lerp",
				value: function(e, t, r, n) {
					var i = e.x,
						a = e.y,
						o = e.z,
						s = e.w;
					n.x = i + r * (t.x - i), n.y = a + r * (t.y - a), n.z = o + r * (t.z - o), n.w =
						s + r * (t.w - s)
				}
			}, {
				key: "transformByM4x4",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = e.w,
						s = t.elements;
					r.x = n * s[0] + i * s[4] + a * s[8] + o * s[12], r.y = n * s[1] + i * s[5] +
						a * s[9] + o * s[13], r.z = n * s[2] + i * s[6] + a * s[10] + o * s[14], r
						.w = n * s[3] + i * s[7] + a * s[11] + o * s[15]
				}
			}, {
				key: "equals",
				value: function(e, t) {
					return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y),
							Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r
						.nearEqual(Math.abs(e.w), Math.abs(t.w))
				}
			}, {
				key: "normalize",
				value: function(e, t) {
					var r = e.length();
					if (r > 0) {
						var n = 1 / r;
						t.x = e.x * n, t.y = e.y * n, t.z = e.z * n, t.w = e.w * n
					}
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w
				}
			}, {
				key: "subtract",
				value: function(e, t, r) {
					r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r.w = e.w - t.w
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r.w = e.w * t.w
				}
			}, {
				key: "scale",
				value: function(e, t, r) {
					r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w * t
				}
			}, {
				key: "Clamp",
				value: function(e, t, r, n) {
					var i = e.x,
						a = e.y,
						o = e.z,
						s = e.w,
						l = t.x,
						u = t.y,
						c = t.z,
						h = t.w,
						_ = r.x,
						d = r.y,
						f = r.z,
						m = r.w;
					i = (i = i > _ ? _ : i) < l ? l : i, a = (a = a > d ? d : a) < u ? u : a, o = (
							o = o > f ? f : o) < c ? c : o, s = (s = s > m ? m : s) < h ? h : s, n
						.x = i, n.y = a, n.z = o, n.w = s
				}
			}, {
				key: "distanceSquared",
				value: function(e, t) {
					var r = e.x - t.x,
						n = e.y - t.y,
						i = e.z - t.z,
						a = e.w - t.w;
					return r * r + n * n + i * i + a * a
				}
			}, {
				key: "distance",
				value: function(e, t) {
					var r = e.x - t.x,
						n = e.y - t.y,
						i = e.z - t.z,
						a = e.w - t.w;
					return Math.sqrt(r * r + n * n + i * i + a * a)
				}
			}, {
				key: "dot",
				value: function(e, t) {
					return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
				}
			}, {
				key: "min",
				value: function(e, t, r) {
					r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z), r
						.w = Math.min(e.w, t.w)
				}
			}, {
				key: "max",
				value: function(e, t, r) {
					r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z), r
						.w = Math.max(e.w, t.w)
				}
			}]), Vector4
		}();
		i.ZERO = new i, i.ONE = new i(1, 1, 1, 1), i.UnitX = new i(1, 0, 0, 0), i.UnitY = new i(0, 1, 0, 0), i.UnitZ =
			new i(0, 0, 1, 0), i.UnitW = new i(0, 0, 0, 1);
		var a, o = function() {
			function Vector3() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
				arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
				_classCallCheck(this, Vector3), this.x = e, this.y = t, this.z = r
			}
			return _createClass(Vector3, [{
				key: "setValue",
				value: function(e, t, r) {
					this.x = e, this.y = t, this.z = r
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t.x = this.x, t.y = this.y, t.z = this.z
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Vector3;
					return this.cloneTo(e), e
				}
			}, {
				key: "toDefault",
				value: function() {
					this.x = 0, this.y = 0, this.z = 0
				}
			}, {
				key: "forNativeElement",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y,
							this.elements[2] = this.z) : this.elements = new Float32Array([this.x,
							this.y, this.z
						]), n.rewriteNumProperty(this, "x", 0), n.rewriteNumProperty(this, "y", 1),
						n.rewriteNumProperty(this, "z", 2)
				}
			}], [{
				key: "distanceSquared",
				value: function(e, t) {
					var r = e.x - t.x,
						n = e.y - t.y,
						i = e.z - t.z;
					return r * r + n * n + i * i
				}
			}, {
				key: "distance",
				value: function(e, t) {
					var r = e.x - t.x,
						n = e.y - t.y,
						i = e.z - t.z;
					return Math.sqrt(r * r + n * n + i * i)
				}
			}, {
				key: "min",
				value: function(e, t, r) {
					r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z)
				}
			}, {
				key: "max",
				value: function(e, t, r) {
					r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z)
				}
			}, {
				key: "transformQuat",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.x,
						s = t.y,
						l = t.z,
						u = t.w,
						c = u * n + s * a - l * i,
						h = u * i + l * n - o * a,
						_ = u * a + o * i - s * n,
						d = -o * n - s * i - l * a;
					r.x = c * u + d * -o + h * -l - _ * -s, r.y = h * u + d * -s + _ * -o - c * -l,
						r.z = _ * u + d * -l + c * -s - h * -o
				}
			}, {
				key: "scalarLength",
				value: function(e) {
					var t = e.x,
						r = e.y,
						n = e.z;
					return Math.sqrt(t * t + r * r + n * n)
				}
			}, {
				key: "scalarLengthSquared",
				value: function(e) {
					var t = e.x,
						r = e.y,
						n = e.z;
					return t * t + r * r + n * n
				}
			}, {
				key: "normalize",
				value: function(e, t) {
					var r = e.x,
						n = e.y,
						i = e.z,
						a = r * r + n * n + i * i;
					a > 0 && (a = 1 / Math.sqrt(a), t.x = r * a, t.y = n * a, t.z = i * a)
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z
				}
			}, {
				key: "scale",
				value: function(e, t, r) {
					r.x = e.x * t, r.y = e.y * t, r.z = e.z * t
				}
			}, {
				key: "lerp",
				value: function(e, t, r, n) {
					var i = e.x,
						a = e.y,
						o = e.z;
					n.x = i + r * (t.x - i), n.y = a + r * (t.y - a), n.z = o + r * (t.z - o)
				}
			}, {
				key: "transformV3ToV3",
				value: function(e, t, r) {
					var n = Vector3._tempVector4;
					Vector3.transformV3ToV4(e, t, n), r.x = n.x, r.y = n.y, r.z = n.z
				}
			}, {
				key: "transformV3ToV4",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.elements;
					r.x = n * o[0] + i * o[4] + a * o[8] + o[12], r.y = n * o[1] + i * o[5] + a * o[
						9] + o[13], r.z = n * o[2] + i * o[6] + a * o[10] + o[14], r.w = n * o[
						3] + i * o[7] + a * o[11] + o[15]
				}
			}, {
				key: "TransformNormal",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.elements;
					r.x = n * o[0] + i * o[4] + a * o[8], r.y = n * o[1] + i * o[5] + a * o[9], r
						.z = n * o[2] + i * o[6] + a * o[10]
				}
			}, {
				key: "transformCoordinate",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.elements,
						s = n * o[3] + i * o[7] + a * o[11] + o[15];
					r.x = (n * o[0] + i * o[4] + a * o[8] + o[12]) / s, r.y = (n * o[1] + i * o[5] +
							a * o[9] + o[13]) / s, r.z = (n * o[2] + i * o[6] + a * o[10] + o[14]) /
						s
				}
			}, {
				key: "Clamp",
				value: function(e, t, r, n) {
					var i = e.x,
						a = e.y,
						o = e.z,
						s = t.x,
						l = t.y,
						u = t.z,
						c = r.x,
						h = r.y,
						_ = r.z;
					i = (i = i > c ? c : i) < s ? s : i, a = (a = a > h ? h : a) < l ? l : a, o = (
						o = o > _ ? _ : o) < u ? u : o, n.x = i, n.y = a, n.z = o
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z
				}
			}, {
				key: "subtract",
				value: function(e, t, r) {
					r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z
				}
			}, {
				key: "cross",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.x,
						s = t.y,
						l = t.z;
					r.x = i * l - a * s, r.y = a * o - n * l, r.z = n * s - i * o
				}
			}, {
				key: "dot",
				value: function(e, t) {
					return e.x * t.x + e.y * t.y + e.z * t.z
				}
			}, {
				key: "equals",
				value: function(e, t) {
					return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z)
				}
			}]), Vector3
		}();
		o._tempVector4 = new i, o._ZERO = new o(0, 0, 0), o._ONE = new o(1, 1, 1), o._NegativeUnitX = new o(-1, 0, 0), o
			._UnitX = new o(1, 0, 0), o._UnitY = new o(0, 1, 0), o._UnitZ = new o(0, 0, 1), o._ForwardRH = new o(0, 0, -
				1), o._ForwardLH = new o(0, 0, 1), o._Up = new o(0, 1, 0), (a = e.PBRRenderQuality || (e
				.PBRRenderQuality = {}))[a.High = 0] = "High", a[a.Low = 1] = "Low";
		var s = function() {
			function Matrix3x3() {
				_classCallCheck(this, Matrix3x3);
				var e = this.elements = new Float32Array(9);
				e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1
			}
			return _createClass(Matrix3x3, [{
				key: "determinant",
				value: function() {
					var e = this.elements,
						t = e[0],
						r = e[1],
						n = e[2],
						i = e[3],
						a = e[4],
						o = e[5],
						s = e[6],
						l = e[7],
						u = e[8];
					return t * (u * a - o * l) + r * (-u * i + o * s) + n * (l * i - a * s)
				}
			}, {
				key: "translate",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = n[4],
						u = n[5],
						c = n[6],
						h = n[7],
						_ = n[8],
						d = e.x,
						f = e.y;
					r[0] = i, r[1] = a, r[2] = o, r[3] = s, r[4] = l, r[5] = u, r[6] = d * i + f *
						s + c, r[7] = d * a + f * l + h, r[8] = d * o + f * u + _
				}
			}, {
				key: "rotate",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = n[4],
						u = n[5],
						c = n[6],
						h = n[7],
						_ = n[8],
						d = Math.sin(e),
						f = Math.cos(e);
					r[0] = f * i + d * s, r[1] = f * a + d * l, r[2] = f * o + d * u, r[3] = f * s -
						d * i, r[4] = f * l - d * a, r[5] = f * u - d * o, r[6] = c, r[7] = h, r[
						8] = _
				}
			}, {
				key: "scale",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements,
						i = e.x,
						a = e.y;
					r[0] = i * n[0], r[1] = i * n[1], r[2] = i * n[2], r[3] = a * n[3], r[4] = a *
						n[4], r[5] = a * n[5], r[6] = n[6], r[7] = n[7], r[8] = n[8]
				}
			}, {
				key: "invert",
				value: function(e) {
					var t = e.elements,
						r = this.elements,
						n = r[0],
						i = r[1],
						a = r[2],
						o = r[3],
						s = r[4],
						l = r[5],
						u = r[6],
						c = r[7],
						h = r[8],
						_ = h * s - l * c,
						d = -h * o + l * u,
						f = c * o - s * u,
						m = n * _ + i * d + a * f;
					m || (e = null), m = 1 / m, t[0] = _ * m, t[1] = (-h * i + a * c) * m, t[2] = (
						l * i - a * s) * m, t[3] = d * m, t[4] = (h * n - a * u) * m, t[5] = (-
						l * n + a * o) * m, t[6] = f * m, t[7] = (-c * n + i * u) * m, t[8] = (
						s * n - i * o) * m
				}
			}, {
				key: "transpose",
				value: function(e) {
					var t = e.elements,
						r = this.elements;
					if (e === this) {
						var n = r[1],
							i = r[2],
							a = r[5];
						t[1] = r[3], t[2] = r[6], t[3] = n, t[5] = r[7], t[6] = i, t[7] = a
					} else t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] =
						r[7], t[6] = r[2], t[7] = r[5], t[8] = r[8]
				}
			}, {
				key: "identity",
				value: function() {
					var e = this.elements;
					e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
						e[8] = 1
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t, r, n;
					if ((r = this.elements) !== (n = e.elements))
						for (t = 0; t < 9; ++t) n[t] = r[t]
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Matrix3x3;
					return this.cloneTo(e), e
				}
			}], [{
				key: "createRotationQuaternion",
				value: function(e, t) {
					var r = e.x,
						n = e.y,
						i = e.z,
						a = e.w,
						o = r * r,
						s = n * n,
						l = i * i,
						u = r * n,
						c = i * a,
						h = i * r,
						_ = n * a,
						d = n * i,
						f = r * a,
						m = t.elements;
					m[0] = 1 - 2 * (s + l), m[1] = 2 * (u + c), m[2] = 2 * (h - _), m[3] = 2 * (u -
							c), m[4] = 1 - 2 * (l + o), m[5] = 2 * (d + f), m[6] = 2 * (h + _), m[
						7] = 2 * (d - f), m[8] = 1 - 2 * (s + o)
				}
			}, {
				key: "createFromTranslation",
				value: function(e, t) {
					var r = t.elements;
					r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 1, r[5] = 0, r[6] = e.x, r[7] = e
						.y, r[8] = 1
				}
			}, {
				key: "createFromRotation",
				value: function(e, t) {
					var r = t.elements,
						n = Math.sin(e),
						i = Math.cos(e);
					r[0] = i, r[1] = n, r[2] = 0, r[3] = -n, r[4] = i, r[5] = 0, r[6] = 0, r[7] = 0,
						r[8] = 1
				}
			}, {
				key: "createFromScaling",
				value: function(e, t) {
					var r = t.elements;
					r[0] = e.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = e.y, r[5] = 0, r[6] = 0, r[7] =
						0, r[8] = e.z
				}
			}, {
				key: "createFromMatrix4x4",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements;
					n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[4], n[4] = r[5], n[5] = r[6], n[
						6] = r[8], n[7] = r[9], n[8] = r[10]
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = e.elements,
						i = t.elements,
						a = r.elements,
						o = n[0],
						s = n[1],
						l = n[2],
						u = n[3],
						c = n[4],
						h = n[5],
						_ = n[6],
						d = n[7],
						f = n[8],
						m = i[0],
						p = i[1],
						T = i[2],
						E = i[3],
						g = i[4],
						y = i[5],
						S = i[6],
						v = i[7],
						R = i[8];
					a[0] = m * o + p * u + T * _, a[1] = m * s + p * c + T * v, a[2] = m * l + p *
						h + T * f, a[3] = E * o + g * u + y * _, a[4] = E * s + g * c + y * d, a[
						5] = E * l + g * h + y * f, a[6] = S * o + v * u + R * _, a[7] = S * s + v *
						c + R * d, a[8] = S * l + v * h + R * f
				}
			}, {
				key: "lookAt",
				value: function(e, t, r, n) {
					o.subtract(e, t, Matrix3x3._tempV30), o.normalize(Matrix3x3._tempV30, Matrix3x3
							._tempV30), o.cross(r, Matrix3x3._tempV30, Matrix3x3._tempV31), o
						.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31), o.cross(Matrix3x3
							._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
					var i = Matrix3x3._tempV30,
						a = Matrix3x3._tempV31,
						s = Matrix3x3._tempV32,
						l = n.elements;
					l[0] = a.x, l[3] = a.y, l[6] = a.z, l[1] = s.x, l[4] = s.y, l[7] = s.z, l[2] = i
						.x, l[5] = i.y, l[8] = i.z
				}
			}]), Matrix3x3
		}();
		s.DEFAULT = new s, s._tempV30 = new o, s._tempV31 = new o, s._tempV32 = new o;
		var l = function ILaya3D() {
			_classCallCheck(this, ILaya3D)
		};
		l.Shader3D = null, l.Scene3D = null, l.MeshRenderStaticBatchManager = null, l.MeshRenderDynamicBatchManager =
			null, l.SubMeshDynamicBatch = null, l.Laya3D = null, l.Matrix4x4 = null, l.Physics3D = null, l
			.ShadowLightType = null;
		var u = function() {
			function Quaternion() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
				arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
				_classCallCheck(this, Quaternion), this.x = e, this.y = t, this.z = r, this.w = n
			}
			return _createClass(Quaternion, [{
				key: "scaling",
				value: function(e, t) {
					t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e
				}
			}, {
				key: "normalize",
				value: function(e) {
					var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
					t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this
						.z * t, e.w = this.w * t)
				}
			}, {
				key: "length",
				value: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w *
						this.w)
				}
			}, {
				key: "rotateX",
				value: function(e, t) {
					e *= .5;
					var r = Math.sin(e),
						n = Math.cos(e);
					t.x = this.x * n + this.w * r, t.y = this.y * n + this.z * r, t.z = this.z * n -
						this.y * r, t.w = this.w * n - this.x * r
				}
			}, {
				key: "rotateY",
				value: function(e, t) {
					e *= .5;
					var r = Math.sin(e),
						n = Math.cos(e);
					t.x = this.x * n - this.z * r, t.y = this.y * n + this.w * r, t.z = this.z * n +
						this.x * r, t.w = this.w * n - this.y * r
				}
			}, {
				key: "rotateZ",
				value: function(e, t) {
					e *= .5;
					var r = Math.sin(e),
						n = Math.cos(e);
					t.x = this.x * n + this.y * r, t.y = this.y * n - this.x * r, t.z = this.z * n +
						this.w * r, t.w = this.w * n - this.z * r
				}
			}, {
				key: "getYawPitchRoll",
				value: function(e) {
					o.transformQuat(o._ForwardRH, this, Quaternion.TEMPVector31), o.transformQuat(o
						._Up, this, Quaternion.TEMPVector32);
					var t = Quaternion.TEMPVector32;
					Quaternion.angleTo(o._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
					var r = Quaternion.TEMPVector33;
					r.x == Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(t.z, t.x), r.z = 0) : r.x ==
						-Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(-t.z, -t.x), r.z = 0) : (l
							.Matrix4x4.createRotationY(-r.y, l.Matrix4x4.TEMPMatrix0), l.Matrix4x4
							.createRotationX(-r.x, l.Matrix4x4.TEMPMatrix1), o.transformCoordinate(
								Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix0, Quaternion
								.TEMPVector32), o.transformCoordinate(Quaternion.TEMPVector32, l
								.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32), r.z = Quaternion
							.arcTanAngle(t.y, -t.x)), r.y <= -Math.PI && (r.y = Math.PI), r.z <= -
						Math.PI && (r.z = Math.PI), r.y >= Math.PI && r.z >= Math.PI && (r.y = 0, r
							.z = 0, r.x = Math.PI - r.x);
					var n = e;
					n.x = r.y, n.y = r.x, n.z = r.z
				}
			}, {
				key: "invert",
				value: function(e) {
					var t = this.x,
						r = this.y,
						n = this.z,
						i = this.w,
						a = t * t + r * r + n * n + i * i,
						o = a ? 1 / a : 0;
					e.x = -t * o, e.y = -r * o, e.z = -n * o, e.w = i * o
				}
			}, {
				key: "identity",
				value: function() {
					this.x = 0, this.y = 0, this.z = 0, this.w = 1
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w)
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Quaternion;
					return this.cloneTo(e), e
				}
			}, {
				key: "equals",
				value: function(e) {
					return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this
						.z, e.z) && r.nearEqual(this.w, e.w)
				}
			}, {
				key: "lengthSquared",
				value: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
			}, {
				key: "forNativeElement",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y,
							this.elements[2] = this.z, this.elements[3] = this.w) : this.elements =
						new Float32Array([this.x, this.y, this.z, this.w]), n.rewriteNumProperty(
							this, "x", 0), n.rewriteNumProperty(this, "y", 1), n.rewriteNumProperty(
							this, "z", 2), n.rewriteNumProperty(this, "w", 3)
				}
			}], [{
				key: "createFromYawPitchRoll",
				value: function(e, t, r, n) {
					var i = .5 * r,
						a = .5 * t,
						o = .5 * e,
						s = Math.sin(i),
						l = Math.cos(i),
						u = Math.sin(a),
						c = Math.cos(a),
						h = Math.sin(o),
						_ = Math.cos(o);
					n.x = _ * u * l + h * c * s, n.y = h * c * l - _ * u * s, n.z = _ * c * s - h *
						u * l, n.w = _ * c * l + h * u * s
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = e.w,
						s = t.x,
						l = t.y,
						u = t.z,
						c = t.w,
						h = i * u - a * l,
						_ = a * s - n * u,
						d = n * l - i * s,
						f = n * s + i * l + a * u;
					r.x = n * c + s * o + h, r.y = i * c + l * o + _, r.z = a * c + u * o + d, r.w =
						o * c - f
				}
			}, {
				key: "arcTanAngle",
				value: function(e, t) {
					return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) :
						e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0
				}
			}, {
				key: "angleTo",
				value: function(e, t, r) {
					o.subtract(t, e, Quaternion.TEMPVector30), o.normalize(Quaternion.TEMPVector30,
							Quaternion.TEMPVector30), r.x = Math.asin(Quaternion.TEMPVector30.y), r
						.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion
							.TEMPVector30.x)
				}
			}, {
				key: "createFromAxisAngle",
				value: function(e, t, r) {
					t *= .5;
					var n = Math.sin(t);
					r.x = n * e.x, r.y = n * e.y, r.z = n * e.z, r.w = Math.cos(t)
				}
			}, {
				key: "createFromMatrix4x4",
				value: function(e, t) {
					var r, n, i = e.elements,
						a = i[0] + i[5] + i[10];
					a > 0 ? (r = Math.sqrt(a + 1), t.w = .5 * r, r = .5 / r, t.x = (i[6] - i[9]) *
							r, t.y = (i[8] - i[2]) * r, t.z = (i[1] - i[4]) * r) : i[0] >= i[5] &&
						i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])), t.x =
							.5 * r, t.y = (i[1] + i[4]) * n, t.z = (i[2] + i[8]) * n, t.w = (i[6] -
								i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] - i[
							0] - i[10])), t.x = (i[4] + i[1]) * n, t.y = .5 * r, t.z = (i[9] +
							i[6]) * n, t.w = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 + i[
								10] - i[0] - i[5])), t.x = (i[8] + i[2]) * n, t.y = (i[9] + i[6]) *
							n, t.z = .5 * r, t.w = (i[1] - i[4]) * n)
				}
			}, {
				key: "slerp",
				value: function(e, t, r, n) {
					var i, a, o, s, l, u = e.x,
						c = e.y,
						h = e.z,
						_ = e.w,
						d = t.x,
						f = t.y,
						m = t.z,
						p = t.w;
					return (a = u * d + c * f + h * m + _ * p) < 0 && (a = -a, d = -d, f = -f, m = -
							m, p = -p), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math
							.sin((1 - r) * i) / o, l = Math.sin(r * i) / o) : (s = 1 - r, l = r), n
						.x = s * u + l * d, n.y = s * c + l * f, n.z = s * h + l * m, n.w = s * _ +
						l * p, n
				}
			}, {
				key: "lerp",
				value: function(e, t, r, n) {
					var i = 1 - r;
					Quaternion.dot(e, t) >= 0 ? (n.x = i * e.x + r * t.x, n.y = i * e.y + r * t.y, n
						.z = i * e.z + r * t.z, n.w = i * e.w + r * t.w) : (n.x = i * e.x - r *
						t.x, n.y = i * e.y - r * t.y, n.z = i * e.z - r * t.z, n.w = i * e.w -
						r * t.w), n.normalize(n)
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w
				}
			}, {
				key: "dot",
				value: function(e, t) {
					return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w
				}
			}, {
				key: "rotationLookAt",
				value: function(e, t, r) {
					Quaternion.lookAt(o._ZERO, e, t, r)
				}
			}, {
				key: "lookAt",
				value: function(e, t, r, n) {
					s.lookAt(e, t, r, Quaternion._tempMatrix3x3), Quaternion.rotationMatrix(
						Quaternion._tempMatrix3x3, n)
				}
			}, {
				key: "invert",
				value: function(e, t) {
					var n = e.lengthSquared();
					r.isZero(n) || (n = 1 / n, t.x = -e.x * n, t.y = -e.y * n, t.z = -e.z * n, t.w =
						e.w * n)
				}
			}, {
				key: "rotationMatrix",
				value: function(e, t) {
					var r, n, i = e.elements,
						a = i[0],
						o = i[1],
						s = i[2],
						l = i[3],
						u = i[4],
						c = i[5],
						h = i[6],
						_ = i[7],
						d = i[8],
						f = a + u + d;
					f > 0 ? (r = Math.sqrt(f + 1), t.w = .5 * r, r = .5 / r, t.x = (c - _) * r, t
						.y = (h - s) * r, t.z = (o - l) * r) : a >= u && a >= d ? (n = .5 / (r =
						Math.sqrt(1 + a - u - d)), t.x = .5 * r, t.y = (o + l) * n, t.z = (
						s + h) * n, t.w = (c - _) * n) : u > d ? (n = .5 / (r = Math.sqrt(1 +
							u - a - d)), t.x = (l + o) * n, t.y = .5 * r, t.z = (_ + c) * n, t
						.w = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a - u)), t.x = (h +
						s) * n, t.y = (_ + c) * n, t.z = .5 * r, t.w = (o - l) * n)
				}
			}]), Quaternion
		}();
		u.TEMPVector30 = new o, u.TEMPVector31 = new o, u.TEMPVector32 = new o, u.TEMPVector33 = new o, u
			._tempMatrix3x3 = new s, u.DEFAULT = new u, u.NAN = new u(NaN, NaN, NaN, NaN);
		var c = function() {
			function Matrix4x4() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
					i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
					a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
					o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
					s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0,
					l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
					u = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
					c = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1,
					h = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0,
					_ = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0,
					d = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0,
					f = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0,
					m = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1,
					p = arguments.length > 16 && void 0 !== arguments[16] ? arguments[16] : null;
				_classCallCheck(this, Matrix4x4);
				var T = this.elements = p || new Float32Array(16);
				T[0] = e, T[1] = t, T[2] = r, T[3] = n, T[4] = i, T[5] = a, T[6] = o, T[7] = s, T[8] = l, T[9] = u,
					T[10] = c, T[11] = h, T[12] = _, T[13] = d, T[14] = f, T[15] = m
			}
			return _createClass(Matrix4x4, [{
				key: "setRotation",
				value: function(e) {
					var t = e.x,
						r = e.y,
						n = e.z,
						i = e.w,
						a = t * t,
						o = r * r,
						s = n * n,
						l = t * r,
						u = n * i,
						c = n * t,
						h = r * i,
						_ = r * n,
						d = t * i,
						f = this.elements;
					f[0] = 1 - 2 * (o + s), f[1] = 2 * (l + u), f[2] = 2 * (c - h), f[4] = 2 * (l -
							u), f[5] = 1 - 2 * (s + a), f[6] = 2 * (_ + d), f[8] = 2 * (c + h), f[
						9] = 2 * (_ - d), f[10] = 1 - 2 * (o + a)
				}
			}, {
				key: "setPosition",
				value: function(e) {
					var t = this.elements;
					t[12] = e.x, t[13] = e.y, t[14] = e.z
				}
			}, {
				key: "getElementByRowColumn",
				value: function(e, t) {
					if (e < 0 || e > 3) throw new Error(
						"row Rows and columns for matrices run from 0 to 3, inclusive.");
					if (t < 0 || t > 3) throw new Error(
						"column Rows and columns for matrices run from 0 to 3, inclusive.");
					return this.elements[4 * e + t]
				}
			}, {
				key: "setElementByRowColumn",
				value: function(e, t, r) {
					if (e < 0 || e > 3) throw new Error(
						"row Rows and columns for matrices run from 0 to 3, inclusive.");
					if (t < 0 || t > 3) throw new Error(
						"column Rows and columns for matrices run from 0 to 3, inclusive.");
					this.elements[4 * e + t] = r
				}
			}, {
				key: "equalsOtherMatrix",
				value: function(e) {
					var t = this.elements,
						n = e.elements;
					return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2],
							n[2]) && r.nearEqual(t[3], n[3]) && r.nearEqual(t[4], n[4]) && r
						.nearEqual(t[5], n[5]) && r.nearEqual(t[6], n[6]) && r.nearEqual(t[7], n[
						7]) && r.nearEqual(t[8], n[8]) && r.nearEqual(t[9], n[9]) && r.nearEqual(t[
							10], n[10]) && r.nearEqual(t[11], n[11]) && r.nearEqual(t[12], n[12]) &&
						r.nearEqual(t[13], n[13]) && r.nearEqual(t[14], n[14]) && r.nearEqual(t[15],
							n[15])
				}
			}, {
				key: "decomposeTransRotScale",
				value: function(e, t, r) {
					var n = Matrix4x4._tempMatrix4x4;
					return this.decomposeTransRotMatScale(e, n, r) ? (u.createFromMatrix4x4(n, t), !
						0) : (t.identity(), !1)
				}
			}, {
				key: "decomposeTransRotMatScale",
				value: function(e, t, n) {
					var i = this.elements,
						a = e,
						s = t.elements,
						l = n;
					a.x = i[12], a.y = i[13], a.z = i[14];
					var u = i[0],
						c = i[1],
						h = i[2],
						_ = i[4],
						d = i[5],
						f = i[6],
						m = i[8],
						p = i[9],
						T = i[10],
						E = l.x = Math.sqrt(u * u + c * c + h * h),
						g = l.y = Math.sqrt(_ * _ + d * d + f * f),
						y = l.z = Math.sqrt(m * m + p * p + T * T);
					if (r.isZero(E) || r.isZero(g) || r.isZero(y)) return s[1] = s[2] = s[3] = s[
						4] = s[6] = s[7] = s[8] = s[9] = s[11] = s[12] = s[13] = s[14] = 0, s[
						0] = s[5] = s[10] = s[15] = 1, !1;
					var S = Matrix4x4._tempVector0;
					S.x = m / y, S.y = p / y, S.z = T / y;
					var v = Matrix4x4._tempVector1;
					v.x = u / E, v.y = c / E, v.z = h / E;
					var R = Matrix4x4._tempVector2;
					o.cross(S, v, R);
					var C = Matrix4x4._tempVector1;
					return o.cross(R, S, C), s[3] = s[7] = s[11] = s[12] = s[13] = s[14] = 0, s[
						15] = 1, s[0] = C.x, s[1] = C.y, s[2] = C.z, s[4] = R.x, s[5] = R.y, s[6] =
						R.z, s[8] = S.x, s[9] = S.y, s[10] = S.z, s[0] * u + s[1] * c + s[2] * h <
						0 && (l.x = -E), s[4] * _ + s[5] * d + s[6] * f < 0 && (l.y = -g), s[8] *
						m + s[9] * p + s[10] * T < 0 && (l.z = -y), !0
				}
			}, {
				key: "decomposeYawPitchRoll",
				value: function(e) {
					var t = Math.asin(-this.elements[9]);
					e.y = t, Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1],
						this.elements[5]), e.x = Math.atan2(this.elements[8], this.elements[
						10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]), e.x = 0)
				}
			}, {
				key: "normalize",
				value: function() {
					var e = this.elements,
						t = e[0],
						r = e[1],
						n = e[2],
						i = Math.sqrt(t * t + r * r + n * n);
					if (!i) return e[0] = 0, e[1] = 0, void(e[2] = 0);
					1 != i && (i = 1 / i, e[0] = t * i, e[1] = r * i, e[2] = n * i)
				}
			}, {
				key: "transpose",
				value: function() {
					var e, t;
					return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8],
						e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] =
						t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t,
						this
				}
			}, {
				key: "invert",
				value: function(e) {
					var t = this.elements,
						r = e.elements,
						n = t[0],
						i = t[1],
						a = t[2],
						o = t[3],
						s = t[4],
						l = t[5],
						u = t[6],
						c = t[7],
						h = t[8],
						_ = t[9],
						d = t[10],
						f = t[11],
						m = t[12],
						p = t[13],
						T = t[14],
						E = t[15],
						g = n * l - i * s,
						y = n * u - a * s,
						S = n * c - o * s,
						v = i * u - a * l,
						R = i * c - o * l,
						C = a * c - o * u,
						M = h * p - _ * m,
						D = h * T - d * m,
						x = h * E - f * m,
						A = _ * T - d * p,
						I = _ * E - f * p,
						L = d * E - f * T,
						P = g * L - y * I + S * A + v * x - R * D + C * M;
					0 !== Math.abs(P) && (P = 1 / P, r[0] = (l * L - u * I + c * A) * P, r[1] = (a *
							I - i * L - o * A) * P, r[2] = (p * C - T * R + E * v) * P, r[3] = (
							d * R - _ * C - f * v) * P, r[4] = (u * x - s * L - c * D) * P, r[
						5] = (n * L - a * x + o * D) * P, r[6] = (T * S - m * C - E * y) * P, r[
							7] = (h * C - d * S + f * y) * P, r[8] = (s * I - l * x + c * M) *
						P, r[9] = (i * x - n * I - o * M) * P, r[10] = (m * R - p * S + E * g) *
						P, r[11] = (_ * S - h * R - f * g) * P, r[12] = (l * D - s * A - u *
						M) * P, r[13] = (n * A - i * D + a * M) * P, r[14] = (p * y - m * v -
							T * g) * P, r[15] = (h * v - _ * y + d * g) * P)
				}
			}, {
				key: "identity",
				value: function() {
					var e = this.elements;
					e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] =
						e[14] = 0, e[0] = e[5] = e[10] = e[15] = 1
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t, r, n;
					if ((r = this.elements) !== (n = e.elements))
						for (t = 0; t < 16; ++t) n[t] = r[t]
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Matrix4x4;
					return this.cloneTo(e), e
				}
			}, {
				key: "getTranslationVector",
				value: function(e) {
					var t = this.elements;
					e.x = t[12], e.y = t[13], e.z = t[14]
				}
			}, {
				key: "setTranslationVector",
				value: function(e) {
					var t = this.elements,
						r = e;
					t[12] = r.x, t[13] = r.y, t[14] = r.z
				}
			}, {
				key: "getForward",
				value: function(e) {
					var t = this.elements;
					e.x = -t[8], e.y = -t[9], e.z = -t[10]
				}
			}, {
				key: "setForward",
				value: function(e) {
					var t = this.elements;
					t[8] = -e.x, t[9] = -e.y, t[10] = -e.z
				}
			}, {
				key: "getInvertFront",
				value: function() {
					this.decomposeTransRotScale(Matrix4x4._tempVector0, Matrix4x4._tempQuaternion,
						Matrix4x4._tempVector1);
					var e = Matrix4x4._tempVector1,
						t = e.x < 0;
					return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t
				}
			}], [{
				key: "createRotationX",
				value: function(e, t) {
					var r = t.elements,
						n = Math.sin(e),
						i = Math.cos(e);
					r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0, r[
						0] = r[15] = 1, r[5] = r[10] = i, r[6] = n, r[9] = -n
				}
			}, {
				key: "createRotationY",
				value: function(e, t) {
					var r = t.elements,
						n = Math.sin(e),
						i = Math.cos(e);
					r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[
						5] = r[15] = 1, r[0] = r[10] = i, r[2] = -n, r[8] = n
				}
			}, {
				key: "createRotationZ",
				value: function(e, t) {
					var r = t.elements,
						n = Math.sin(e),
						i = Math.cos(e);
					r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[
						10] = r[15] = 1, r[0] = r[5] = i, r[1] = n, r[4] = -n
				}
			}, {
				key: "createRotationYawPitchRoll",
				value: function(e, t, r, n) {
					u.createFromYawPitchRoll(e, t, r, Matrix4x4._tempQuaternion), Matrix4x4
						.createRotationQuaternion(Matrix4x4._tempQuaternion, n)
				}
			}, {
				key: "createRotationAxis",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = Math.cos(t),
						s = Math.sin(t),
						l = n * n,
						u = i * i,
						c = a * a,
						h = n * i,
						_ = n * a,
						d = i * a,
						f = r.elements;
					f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + o * (1 -
							l), f[1] = h - o * h + s * a, f[2] = _ - o * _ - s * i, f[4] = h - o *
						h - s * a, f[5] = u + o * (1 - u), f[6] = d - o * d + s * n, f[8] = _ - o *
						_ + s * i, f[9] = d - o * d - s * n, f[10] = c + o * (1 - c)
				}
			}, {
				key: "createRotationQuaternion",
				value: function(e, t) {
					var r = t.elements,
						n = e.x,
						i = e.y,
						a = e.z,
						o = e.w,
						s = n * n,
						l = i * i,
						u = a * a,
						c = n * i,
						h = a * o,
						_ = a * n,
						d = i * o,
						f = i * a,
						m = n * o;
					r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0, r[15] = 1, r[0] = 1 - 2 * (l +
							u), r[1] = 2 * (c + h), r[2] = 2 * (_ - d), r[4] = 2 * (c - h), r[5] =
						1 - 2 * (u + s), r[6] = 2 * (f + m), r[8] = 2 * (_ + d), r[9] = 2 * (f - m),
						r[10] = 1 - 2 * (l + s)
				}
			}, {
				key: "createTranslate",
				value: function(e, t) {
					var r = t.elements;
					r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0, r[0] = r[5] =
						r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z
				}
			}, {
				key: "createScaling",
				value: function(e, t) {
					var r = t.elements;
					r[0] = e.x, r[5] = e.y, r[10] = e.z, r[1] = r[4] = r[8] = r[12] = r[9] = r[13] =
						r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0, r[15] = 1
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = t.elements,
						i = e.elements,
						a = r.elements,
						o = n[0],
						s = n[1],
						l = n[2],
						u = n[3],
						c = n[4],
						h = n[5],
						_ = n[6],
						d = n[7],
						f = n[8],
						m = n[9],
						p = n[10],
						T = n[11],
						E = n[12],
						g = n[13],
						y = n[14],
						S = n[15],
						v = i[0],
						R = i[1],
						C = i[2],
						M = i[3],
						D = i[4],
						x = i[5],
						A = i[6],
						I = i[7],
						L = i[8],
						P = i[9],
						O = i[10],
						N = i[11],
						b = i[12],
						k = i[13],
						w = i[14],
						B = i[15];
					a[0] = o * v + s * D + l * L + u * b, a[1] = o * R + s * x + l * P + u * k, a[
						2] = o * C + s * A + l * O + u * w, a[3] = o * M + s * I + l * N + u * B, a[
							4] = c * v + h * D + _ * L + d * b, a[5] = c * R + h * x + _ * P + d *
						k, a[6] = c * C + h * A + _ * O + d * w, a[7] = c * M + h * I + _ * N + d *
						B, a[8] = f * v + m * D + p * L + T * b, a[9] = f * R + m * x + p * P + T *
						k, a[10] = f * C + m * A + p * O + T * w, a[11] = f * M + m * I + p * N +
						T * B, a[12] = E * v + g * D + y * L + S * b, a[13] = E * R + g * x + y *
						P + S * k, a[14] = E * C + g * A + y * O + S * w, a[15] = E * M + g * I +
						y * N + S * B
				}
			}, {
				key: "multiplyForNative",
				value: function(e, r, n) {
					t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, n.elements)
				}
			}, {
				key: "createFromQuaternion",
				value: function(e, t) {
					var r = t.elements,
						n = e.x,
						i = e.y,
						a = e.z,
						o = e.w,
						s = n + n,
						l = i + i,
						u = a + a,
						c = n * s,
						h = i * s,
						_ = i * l,
						d = a * s,
						f = a * l,
						m = a * u,
						p = o * s,
						T = o * l,
						E = o * u;
					r[0] = 1 - _ - m, r[1] = h + E, r[2] = d - T, r[3] = 0, r[4] = h - E, r[5] = 1 -
						c - m, r[6] = f + p, r[7] = 0, r[8] = d + T, r[9] = f - p, r[10] = 1 - c -
						_, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1
				}
			}, {
				key: "createAffineTransformation",
				value: function(e, t, r, n) {
					var i = n.elements,
						a = t.x,
						o = t.y,
						s = t.z,
						l = t.w,
						u = a + a,
						c = o + o,
						h = s + s,
						_ = a * u,
						d = a * c,
						f = a * h,
						m = o * c,
						p = o * h,
						T = s * h,
						E = l * u,
						g = l * c,
						y = l * h,
						S = r.x,
						v = r.y,
						R = r.z;
					i[0] = (1 - (m + T)) * S, i[1] = (d + y) * S, i[2] = (f - g) * S, i[3] = 0, i[
						4] = (d - y) * v, i[5] = (1 - (_ + T)) * v, i[6] = (p + E) * v, i[7] = 0, i[
							8] = (f + g) * R, i[9] = (p - E) * R, i[10] = (1 - (_ + m)) * R, i[11] =
						0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1
				}
			}, {
				key: "createLookAt",
				value: function(e, t, r, n) {
					var i = n.elements,
						a = Matrix4x4._tempVector0,
						s = Matrix4x4._tempVector1,
						l = Matrix4x4._tempVector2;
					o.subtract(e, t, l), o.normalize(l, l), o.cross(r, l, a), o.normalize(a, a), o
						.cross(l, a, s), i[3] = i[7] = i[11] = 0, i[15] = 1, i[0] = a.x, i[4] = a.y,
						i[8] = a.z, i[1] = s.x, i[5] = s.y, i[9] = s.z, i[2] = l.x, i[6] = l.y, i[
							10] = l.z, i[12] = -o.dot(a, e), i[13] = -o.dot(s, e), i[14] = -o.dot(l,
							e)
				}
			}, {
				key: "createPerspective",
				value: function(e, t, r, n, i) {
					var a = 1 / Math.tan(.5 * e),
						o = r / (a / t),
						s = r / a;
					Matrix4x4.createPerspectiveOffCenter(-o, o, -s, s, r, n, i)
				}
			}, {
				key: "createPerspectiveOffCenter",
				value: function(e, t, r, n, i, a, o) {
					var s = o.elements,
						l = a / (a - i);
					s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0, s[0] = 2 *
						i / (t - e), s[5] = 2 * i / (n - r), s[8] = (e + t) / (t - e), s[9] = (n +
							r) / (n - r), s[10] = -l, s[11] = -1, s[14] = -i * l
				}
			}, {
				key: "createOrthoOffCenter",
				value: function(e, t, r, n, i, a, o) {
					var s = o.elements,
						l = 1 / (a - i);
					s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0, s[15] = 1, s[
						0] = 2 / (t - e), s[5] = 2 / (n - r), s[10] = -l, s[12] = (e + t) / (e -
						t), s[13] = (n + r) / (r - n), s[14] = -i * l
				}
			}, {
				key: "billboard",
				value: function(e, t, n, i, a, s) {
					o.subtract(e, t, Matrix4x4._tempVector0);
					var l = o.scalarLengthSquared(Matrix4x4._tempVector0);
					r.isZero(l) ? (o.scale(a, -1, Matrix4x4._tempVector1), Matrix4x4._tempVector1
						.cloneTo(Matrix4x4._tempVector0)) : o.scale(Matrix4x4._tempVector0, 1 /
						Math.sqrt(l), Matrix4x4._tempVector0), o.cross(i, Matrix4x4
						._tempVector0, Matrix4x4._tempVector2), o.normalize(Matrix4x4
						._tempVector2, Matrix4x4._tempVector2), o.cross(Matrix4x4._tempVector0,
						Matrix4x4._tempVector2, Matrix4x4._tempVector3);
					var u = Matrix4x4._tempVector2,
						c = Matrix4x4._tempVector3,
						h = Matrix4x4._tempVector0,
						_ = e,
						d = s.elements;
					d[0] = u.x, d[1] = u.y, d[2] = u.z, d[3] = 0, d[4] = c.x, d[5] = c.y, d[6] = c
						.z, d[7] = 0, d[8] = h.x, d[9] = h.y, d[10] = h.z, d[11] = 0, d[12] = _.x,
						d[13] = _.y, d[14] = _.z, d[15] = 1
				}
			}, {
				key: "translation",
				value: function(e, t) {
					var r = t.elements;
					r[0] = r[5] = r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z
				}
			}]), Matrix4x4
		}();
		c._tempMatrix4x4 = new c, c.TEMPMatrix0 = new c, c.TEMPMatrix1 = new c, c._tempVector0 = new o, c._tempVector1 =
			new o, c._tempVector2 = new o, c._tempVector3 = new o, c._tempQuaternion = new u, c.DEFAULT = new c, c
			.ZERO = new c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		var h = function() {
			function ColliderShape() {
				_classCallCheck(this, ColliderShape), this._scale = new o(1, 1, 1), this._centerMatrix = new c, this
					._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this
					._attatchedCollisionObject = null, this._referenceCount = 0, this._localOffset = new o(0, 0, 0),
					this._localRotation = new u(0, 0, 0, 1), this.needsCustomCollisionCallback = !1
			}
			return _createClass(ColliderShape, [{
				key: "_setScale",
				value: function(e) {
					if (this._compoundParent) this.updateLocalTransformations();
					else {
						var t = l.Physics3D._bullet;
						t.btVector3_setValue(ColliderShape._btScale, e.x, e.y, e.z), t
							.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale)
					}
				}
			}, {
				key: "_addReference",
				value: function() {
					this._referenceCount++
				}
			}, {
				key: "_removeReference",
				value: function() {
					this._referenceCount--
				}
			}, {
				key: "updateLocalTransformations",
				value: function() {
					if (this._compoundParent) {
						var e = ColliderShape._tempVector30;
						o.multiply(this.localOffset, this._scale, e), ColliderShape
							._createAffineTransformation(e, this.localRotation, this._centerMatrix
								.elements)
					} else ColliderShape._createAffineTransformation(this.localOffset, this
						.localRotation, this._centerMatrix.elements)
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t
							.localRotation), t.localOffset = t.localOffset, t.localRotation = t
						.localRotation
				}
			}, {
				key: "clone",
				value: function() {
					return null
				}
			}, {
				key: "destroy",
				value: function() {
					this._btShape && (l.Physics3D._bullet.btCollisionShape_destroy(this._btShape),
						this._btShape = null)
				}
			}, {
				key: "type",
				get: function() {
					return this._type
				}
			}, {
				key: "localOffset",
				get: function() {
					return this._localOffset
				},
				set: function(e) {
					this._localOffset = e, this._compoundParent && this._compoundParent
						._updateChildTransform(this)
				}
			}, {
				key: "localRotation",
				get: function() {
					return this._localRotation
				},
				set: function(e) {
					this._localRotation = e, this._compoundParent && this._compoundParent
						._updateChildTransform(this)
				}
			}], [{
				key: "__init__",
				value: function() {
					var e = l.Physics3D._bullet;
					ColliderShape._btScale = e.btVector3_create(1, 1, 1), ColliderShape
						._btVector30 = e.btVector3_create(0, 0, 0), ColliderShape._btQuaternion0 = e
						.btQuaternion_create(0, 0, 0, 1), ColliderShape._btTransform0 = e
						.btTransform_create()
				}
			}, {
				key: "_createAffineTransformation",
				value: function(e, t, r) {
					var n = t.x,
						i = t.y,
						a = t.z,
						o = t.w,
						s = n + n,
						l = i + i,
						u = a + a,
						c = n * s,
						h = n * l,
						_ = n * u,
						d = i * l,
						f = i * u,
						m = a * u,
						p = o * s,
						T = o * l,
						E = o * u;
					r[0] = 1 - (d + m), r[1] = h + E, r[2] = _ - T, r[3] = 0, r[4] = h - E, r[5] =
						1 - (c + m), r[6] = f + p, r[7] = 0, r[8] = _ + T, r[9] = f - p, r[10] = 1 -
						(c + d), r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1
				}
			}]), ColliderShape
		}();
		h.SHAPEORIENTATION_UPX = 0, h.SHAPEORIENTATION_UPY = 1, h.SHAPEORIENTATION_UPZ = 2, h.SHAPETYPES_BOX = 0, h
			.SHAPETYPES_SPHERE = 1, h.SHAPETYPES_CYLINDER = 2, h.SHAPETYPES_CAPSULE = 3, h.SHAPETYPES_CONVEXHULL = 4, h
			.SHAPETYPES_COMPOUND = 5, h.SHAPETYPES_STATICPLANE = 6, h.SHAPETYPES_CONE = 7, h._tempVector30 = new o;
		var _ = function(e) {
				function StaticPlaneColliderShape(e, t) {
					var r;
					_classCallCheck(this, StaticPlaneColliderShape), (r = _possibleConstructorReturn(this,
							_getPrototypeOf(StaticPlaneColliderShape).call(this)))._normal = e, r._offset = t, r._type =
						h.SHAPETYPES_STATICPLANE;
					var n = l.Physics3D._bullet;
					return n.btVector3_setValue(StaticPlaneColliderShape._btNormal, -e.x, e.y, e.z), r._btShape = n
						.btStaticPlaneShape_create(StaticPlaneColliderShape._btNormal, t), r
				}
				return _inherits(StaticPlaneColliderShape, e), _createClass(StaticPlaneColliderShape, [{
					key: "clone",
					value: function() {
						var e = new StaticPlaneColliderShape(this._normal, this._offset);
						return this.cloneTo(e), e
					}
				}], [{
					key: "__init__",
					value: function() {
						StaticPlaneColliderShape._btNormal = l.Physics3D._bullet.btVector3_create(0, 0,
							0)
					}
				}]), StaticPlaneColliderShape
			}(h),
			d = function(e) {
				function CompoundColliderShape() {
					var e;
					return _classCallCheck(this, CompoundColliderShape), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(CompoundColliderShape).call(this)))._childColliderShapes = [], e._type = h
						.SHAPETYPES_COMPOUND, e._btShape = l.Physics3D._bullet.btCompoundShape_create(), e
				}
				return _inherits(CompoundColliderShape, e), _createClass(CompoundColliderShape, [{
					key: "_clearChildShape",
					value: function(e) {
						e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1
					}
				}, {
					key: "_addReference",
					value: function() {}
				}, {
					key: "_removeReference",
					value: function() {}
				}, {
					key: "_updateChildTransform",
					value: function(e) {
						var t = l.Physics3D._bullet,
							r = e.localOffset,
							n = e.localRotation,
							i = h._btVector30,
							a = h._btQuaternion0,
							o = h._btTransform0;
						t.btVector3_setValue(i, -r.x, r.y, r.z), t.btQuaternion_setValue(a, -n.x, n.y, n
							.z, -n.w), t.btTransform_setOrigin(o, i), t.btTransform_setRotation(o,
							a), t.btCompoundShape_updateChildTransform(this._btShape, e
							._indexInCompound, o, !0)
					}
				}, {
					key: "addChildShape",
					value: function(e) {
						if (e._attatched)
						throw "CompoundColliderShape: this shape has attatched to other entity.";
						e._attatched = !0, e._compoundParent = this, e._indexInCompound = this
							._childColliderShapes.length, this._childColliderShapes.push(e);
						var t = e.localOffset,
							r = e.localRotation,
							n = l.Physics3D._bullet;
						n.btVector3_setValue(CompoundColliderShape._btOffset, -t.x, t.y, t.z), n
							.btQuaternion_setValue(CompoundColliderShape._btRotation, -r.x, r.y, r.z, -r
								.w), n.btTransform_setOrigin(CompoundColliderShape._btTransform,
								CompoundColliderShape._btOffset), n.btTransform_setRotation(
								CompoundColliderShape._btTransform, CompoundColliderShape._btRotation);
						var i = n.btCollisionShape_getLocalScaling(this._btShape);
						n.btCollisionShape_setLocalScaling(this._btShape, CompoundColliderShape
								._btVector3One), n.btCompoundShape_addChildShape(this._btShape,
								CompoundColliderShape._btTransform, e._btShape), n
							.btCollisionShape_setLocalScaling(this._btShape, i), this
							._attatchedCollisionObject && (this._attatchedCollisionObject
								.colliderShape = this)
					}
				}, {
					key: "removeChildShape",
					value: function(e) {
						if (e._compoundParent === this) {
							var t = e._indexInCompound;
							this._clearChildShape(e);
							var r = this._childColliderShapes[this._childColliderShapes.length - 1];
							r._indexInCompound = t, this._childColliderShapes[t] = r, this
								._childColliderShapes.pop(), l.Physics3D._bullet
								.btCompoundShape_removeChildShapeByIndex(this._btShape, t)
						}
					}
				}, {
					key: "clearChildShape",
					value: function() {
						for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this
							._clearChildShape(this._childColliderShapes[e]), l.Physics3D._bullet
							.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
						this._childColliderShapes.length = 0
					}
				}, {
					key: "getChildShapeCount",
					value: function() {
						return this._childColliderShapes.length
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.clearChildShape();
						for (var r = 0, n = this._childColliderShapes.length; r < n; r++) t
							.addChildShape(this._childColliderShapes[r].clone())
					}
				}, {
					key: "clone",
					value: function() {
						var e = new CompoundColliderShape;
						return this.cloneTo(e), e
					}
				}, {
					key: "destroy",
					value: function() {
						_get(_getPrototypeOf(CompoundColliderShape.prototype), "destroy", this).call(
							this);
						for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
							var r = this._childColliderShapes[e];
							0 === r._referenceCount && r.destroy()
						}
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = l.Physics3D._bullet;
						CompoundColliderShape._btVector3One = e.btVector3_create(1, 1, 1),
							CompoundColliderShape._btTransform = e.btTransform_create(),
							CompoundColliderShape._btOffset = e.btVector3_create(0, 0, 0),
							CompoundColliderShape._btRotation = e.btQuaternion_create(0, 0, 0, 1)
					}
				}]), CompoundColliderShape
			}(h),
			f = function(e) {
				function Transform3D(e) {
					var t;
					return _classCallCheck(this, Transform3D), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							Transform3D).call(this)))._localPosition = new o(0, 0, 0), t._localRotation = new u(0, 0, 0,
							1), t._localScale = new o(1, 1, 1), t._localRotationEuler = new o(0, 0, 0), t._localMatrix =
						new c, t._position = new o(0, 0, 0), t._rotation = new u(0, 0, 0, 1), t._scale = new o(1, 1, 1),
						t._rotationEuler = new o(0, 0, 0), t._worldMatrix = new c, t._children = null, t._parent = null,
						t._dummy = null, t._transformFlag = 0, t._owner = e, t._children = [], t._setTransformFlag(
							Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D
							.TRANSFORM_LOCALMATRIX, !1), t._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION |
							Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D
							.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, !0), t
				}
				return _inherits(Transform3D, e), _createClass(Transform3D, [{
					key: "_getScaleMatrix",
					value: function() {
						var e = Transform3D._tempQuaternion0,
							t = Transform3D._tempMatrix3x30,
							r = Transform3D._tempMatrix3x31,
							n = Transform3D._tempMatrix3x32;
						return s.createFromMatrix4x4(this.worldMatrix, r), this.rotation.invert(e), s
							.createRotationQuaternion(e, t), s.multiply(t, r, n), n
					}
				}, {
					key: "_setTransformFlag",
					value: function(e, t) {
						t ? this._transformFlag |= e : this._transformFlag &= ~e
					}
				}, {
					key: "_getTransformFlag",
					value: function(e) {
						return 0 != (this._transformFlag & e)
					}
				}, {
					key: "_setParent",
					value: function(e) {
						if (this._parent !== e) {
							if (this._parent) {
								var t = this._parent._children,
									r = t.indexOf(this);
								t.splice(r, 1)
							}
							e && (e._children.push(this), e && this._onWorldTransform()), this._parent =
								e
						}
					}
				}, {
					key: "_onWorldPositionRotationTransform",
					value: function() {
						if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER))) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
								.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION |
								Transform3D.TRANSFORM_WORLDEULER, !0), this.event(t.Event
								.TRANSFORM_CHANGED, this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldPositionRotationTransform()
						}
					}
				}, {
					key: "_onWorldPositionScaleTransform",
					value: function() {
						if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
									.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, !0),
								this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldPositionScaleTransform()
						}
					}
				}, {
					key: "_onWorldPositionTransform",
					value: function() {
						if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
								.TRANSFORM_WORLDPOSITION, !0), this.event(t.Event.TRANSFORM_CHANGED,
								this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldPositionTransform()
						}
					}
				}, {
					key: "_onWorldRotationTransform",
					value: function() {
						if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
									.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0),
								this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldPositionRotationTransform()
						}
					}
				}, {
					key: "_onWorldScaleTransform",
					value: function() {
						if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this
							._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
								.TRANSFORM_WORLDSCALE, !0), this.event(t.Event.TRANSFORM_CHANGED,
								this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldPositionScaleTransform()
						}
					}
				}, {
					key: "_onWorldTransform",
					value: function() {
						if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) && this
								._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))) {
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D
								.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION |
								Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE,
								!0), this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
							for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
								._onWorldTransform()
						}
					}
				}, {
					key: "translate",
					value: function(e) {
						var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
						t ? (c.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0), o
							.transformCoordinate(e, Transform3D._tempMatrix0, Transform3D
								._tempVector30), o.add(this.localPosition, Transform3D
								._tempVector30, this._localPosition), this.localPosition = this
							._localPosition) : (o.add(this.position, e, this._position), this
							.position = this._position)
					}
				}, {
					key: "rotate",
					value: function(e) {
						var t, r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
							n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						n ? t = e : (o.scale(e, Math.PI / 180, Transform3D._tempVector30), t =
							Transform3D._tempVector30), u.createFromYawPitchRoll(t.y, t.x, t.z,
							Transform3D._tempQuaternion0), r ? (u.multiply(this._localRotation,
								Transform3D._tempQuaternion0, this._localRotation), this
							.localRotation = this._localRotation) : (u.multiply(Transform3D
								._tempQuaternion0, this.rotation, this._rotation), this.rotation =
							this._rotation)
					}
				}, {
					key: "getForward",
					value: function(e) {
						var t = this.worldMatrix.elements;
						e.x = -t[8], e.y = -t[9], e.z = -t[10]
					}
				}, {
					key: "getUp",
					value: function(e) {
						var t = this.worldMatrix.elements;
						e.x = t[4], e.y = t[5], e.z = t[6]
					}
				}, {
					key: "getRight",
					value: function(e) {
						var t = this.worldMatrix.elements;
						e.x = t[0], e.y = t[1], e.z = t[2]
					}
				}, {
					key: "lookAt",
					value: function(e, t) {
						var n, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
						if (i) {
							if (n = this._localPosition, Math.abs(n.x - e.x) < r.zeroTolerance && Math
								.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r
								.zeroTolerance) return;
							u.lookAt(this._localPosition, e, t, this._localRotation), this
								._localRotation.invert(this._localRotation), this.localRotation = this
								._localRotation
						} else {
							var a = this.position;
							if (n = a, Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r
								.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance) return;
							u.lookAt(a, e, t, this._rotation), this._rotation.invert(this._rotation),
								this.rotation = this._rotation
						}
					}
				}, {
					key: "getWorldLossyScale",
					value: function() {
						if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
							if (null !== this._parent) {
								var e = this._getScaleMatrix().elements;
								this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8]
							} else this._localScale.cloneTo(this._scale);
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1)
						}
						return this._scale
					}
				}, {
					key: "setWorldLossyScale",
					value: function(e) {
						if (null !== this._parent) {
							var t = Transform3D._tempMatrix3x33,
								r = Transform3D._tempMatrix3x33,
								n = r.elements,
								i = this._parent._getScaleMatrix();
							i.invert(i), s.createFromScaling(e, t), s.multiply(i, t, r), this
								._localScale.x = n[0], this._localScale.y = n[4], this._localScale.z =
								n[8]
						} else e.cloneTo(this._localScale);
						this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale),
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1)
					}
				}, {
					key: "_isFrontFaceInvert",
					get: function() {
						var e = this.getWorldLossyScale(),
							t = e.x < 0;
						return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t
					}
				}, {
					key: "owner",
					get: function() {
						return this._owner
					}
				}, {
					key: "worldNeedUpdate",
					get: function() {
						return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX)
					}
				}, {
					key: "localPositionX",
					get: function() {
						return this._localPosition.x
					},
					set: function(e) {
						this._localPosition.x = e, this.localPosition = this._localPosition
					}
				}, {
					key: "localPositionY",
					get: function() {
						return this._localPosition.y
					},
					set: function(e) {
						this._localPosition.y = e, this.localPosition = this._localPosition
					}
				}, {
					key: "localPositionZ",
					get: function() {
						return this._localPosition.z
					},
					set: function(e) {
						this._localPosition.z = e, this.localPosition = this._localPosition
					}
				}, {
					key: "localPosition",
					get: function() {
						return this._localPosition
					},
					set: function(e) {
						this._localPosition !== e && e.cloneTo(this._localPosition), this
							._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0), this
							._onWorldPositionTransform()
					}
				}, {
					key: "localRotationX",
					get: function() {
						return this.localRotation.x
					},
					set: function(e) {
						this._localRotation.x = e, this.localRotation = this._localRotation
					}
				}, {
					key: "localRotationY",
					get: function() {
						return this.localRotation.y
					},
					set: function(e) {
						this._localRotation.y = e, this.localRotation = this._localRotation
					}
				}, {
					key: "localRotationZ",
					get: function() {
						return this.localRotation.z
					},
					set: function(e) {
						this._localRotation.z = e, this.localRotation = this._localRotation
					}
				}, {
					key: "localRotationW",
					get: function() {
						return this.localRotation.w
					},
					set: function(e) {
						this._localRotation.w = e, this.localRotation = this._localRotation
					}
				}, {
					key: "localRotation",
					get: function() {
						if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
							var e = this._localRotationEuler;
							u.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D
								._angleToRandin, e.z / Transform3D._angleToRandin, this
								._localRotation), this._setTransformFlag(Transform3D
								.TRANSFORM_LOCALQUATERNION, !1)
						}
						return this._localRotation
					},
					set: function(e) {
						this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation
							.normalize(this._localRotation), this._setTransformFlag(Transform3D
								.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !0), this
							._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1), this
							._onWorldRotationTransform()
					}
				}, {
					key: "localScaleX",
					get: function() {
						return this._localScale.x
					},
					set: function(e) {
						this._localScale.x = e, this.localScale = this._localScale
					}
				}, {
					key: "localScaleY",
					get: function() {
						return this._localScale.y
					},
					set: function(e) {
						this._localScale.y = e, this.localScale = this._localScale
					}
				}, {
					key: "localScaleZ",
					get: function() {
						return this._localScale.z
					},
					set: function(e) {
						this._localScale.z = e, this.localScale = this._localScale
					}
				}, {
					key: "localScale",
					get: function() {
						return this._localScale
					},
					set: function(e) {
						this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(
							Transform3D.TRANSFORM_LOCALMATRIX, !0), this._onWorldScaleTransform()
					}
				}, {
					key: "localRotationEulerX",
					get: function() {
						return this.localRotationEuler.x
					},
					set: function(e) {
						this._localRotationEuler.x = e, this.localRotationEuler = this
							._localRotationEuler
					}
				}, {
					key: "localRotationEulerY",
					get: function() {
						return this.localRotationEuler.y
					},
					set: function(e) {
						this._localRotationEuler.y = e, this.localRotationEuler = this
							._localRotationEuler
					}
				}, {
					key: "localRotationEulerZ",
					get: function() {
						return this.localRotationEuler.z
					},
					set: function(e) {
						this._localRotationEuler.z = e, this.localRotationEuler = this
							._localRotationEuler
					}
				}, {
					key: "localRotationEuler",
					get: function() {
						if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
							this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
							var e = Transform3D._tempVector30,
								t = this._localRotationEuler;
							t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D
								._angleToRandin, t.z = e.z * Transform3D._angleToRandin, this
								._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1)
						}
						return this._localRotationEuler
					},
					set: function(e) {
						this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this
							._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1), this
							._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D
								.TRANSFORM_LOCALMATRIX, !0), this._onWorldRotationTransform()
					}
				}, {
					key: "localMatrix",
					get: function() {
						return this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX) && (c
							.createAffineTransformation(this._localPosition, this.localRotation,
								this._localScale, this._localMatrix), this._setTransformFlag(
								Transform3D.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix
					},
					set: function(e) {
						this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix
							.decomposeTransRotScale(this._localPosition, this._localRotation, this
								._localScale), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER,
								!0), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1), this
							._onWorldTransform()
					}
				}, {
					key: "position",
					get: function() {
						if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
							if (null != this._parent) {
								var e = this.worldMatrix.elements;
								this._position.x = e[12], this._position.y = e[13], this._position.z =
									e[14]
							} else this._localPosition.cloneTo(this._position);
							this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1)
						}
						return this._position
					},
					set: function(e) {
						if (null != this._parent) {
							var t = Transform3D._tempMatrix0;
							this._parent.worldMatrix.invert(t), o.transformCoordinate(e, t, this
								._localPosition)
						} else e.cloneTo(this._localPosition);
						this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this
							._position), this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION,
							!1)
					}
				}, {
					key: "rotation",
					get: function() {
						return this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && (null !=
								this._parent ? u.multiply(this._parent.rotation, this.localRotation,
									this._rotation) : this.localRotation.cloneTo(this._rotation), this
								._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)), this
							._rotation
					},
					set: function(e) {
						null != this._parent ? (this._parent.rotation.invert(Transform3D
								._tempQuaternion0), u.multiply(Transform3D._tempQuaternion0, e, this
								._localRotation)) : e.cloneTo(this._localRotation), this.localRotation =
							this._localRotation, e !== this._rotation && e.cloneTo(this._rotation), this
							._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)
					}
				}, {
					key: "rotationEuler",
					get: function() {
						if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
							this.rotation.getYawPitchRoll(Transform3D._tempVector30);
							var e = Transform3D._tempVector30,
								t = this._rotationEuler;
							t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D
								._angleToRandin, t.z = e.z * Transform3D._angleToRandin, this
								._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1)
						}
						return this._rotationEuler
					},
					set: function(e) {
						u.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D
								._angleToRandin, e.z / Transform3D._angleToRandin, this._rotation), this
							.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this
								._rotationEuler), this._setTransformFlag(Transform3D
								.TRANSFORM_WORLDEULER, !1)
					}
				}, {
					key: "worldMatrix",
					get: function() {
						return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && (null !=
								this._parent ? c.multiply(this._parent.worldMatrix, this.localMatrix,
									this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
								this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)), this
							._worldMatrix
					},
					set: function(e) {
						null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix
								.invert(this._localMatrix), c.multiply(this._localMatrix, e, this
									._localMatrix)), this.localMatrix = this._localMatrix, this
							._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(
								Transform3D.TRANSFORM_WORLDMATRIX, !1)
					}
				}, {
					key: "scale",
					get: function() {
						return console.warn(
								"Transfrm3D: discard function,please use getWorldLossyScale instead."),
							this.getWorldLossyScale()
					},
					set: function(e) {
						console.warn(
								"Transfrm3D: discard function,please use setWorldLossyScale instead."),
							this.setWorldLossyScale(e)
					}
				}]), Transform3D
			}(t.EventDispatcher);
		f._tempVector30 = new o, f._tempQuaternion0 = new u, f._tempMatrix0 = new c, f._tempMatrix3x30 = new s, f
			._tempMatrix3x31 = new s, f._tempMatrix3x32 = new s, f._tempMatrix3x33 = new s, f
			.TRANSFORM_LOCALQUATERNION = 1, f.TRANSFORM_LOCALEULER = 2, f.TRANSFORM_LOCALMATRIX = 4, f
			.TRANSFORM_WORLDPOSITION = 8, f.TRANSFORM_WORLDQUATERNION = 16, f.TRANSFORM_WORLDSCALE = 32, f
			.TRANSFORM_WORLDMATRIX = 64, f.TRANSFORM_WORLDEULER = 128, f._angleToRandin = 180 / Math.PI;
		var m = function() {
			function Physics3DUtils() {
				_classCallCheck(this, Physics3DUtils)
			}
			return _createClass(Physics3DUtils, null, [{
				key: "setColliderCollision",
				value: function(e, t, r) {}
			}, {
				key: "getIColliderCollision",
				value: function(e, t) {
					return !1
				}
			}]), Physics3DUtils
		}();
		m.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, m.COLLISIONFILTERGROUP_STATICFILTER = 2, m
			.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, m.COLLISIONFILTERGROUP_DEBRISFILTER = 8, m
			.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, m.COLLISIONFILTERGROUP_CHARACTERFILTER = 32, m
			.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, m.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128, m
			.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, m.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512, m
			.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, m.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048, m
			.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, m.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192, m
			.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, m.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768, m
			.COLLISIONFILTERGROUP_ALLFILTER = -1, m.gravity = new o(0, -9.81, 0);
		var p = function(e) {
				function BoxColliderShape() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
					_classCallCheck(this, BoxColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							BoxColliderShape).call(this)))._sizeX = t, e._sizeY = r, e._sizeZ = n, e._type = h
						.SHAPETYPES_BOX;
					var i = l.Physics3D._bullet;
					return i.btVector3_setValue(BoxColliderShape._btSize, t / 2, r / 2, n / 2), e._btShape = i
						.btBoxShape_create(BoxColliderShape._btSize), e
				}
				return _inherits(BoxColliderShape, e), _createClass(BoxColliderShape, [{
					key: "clone",
					value: function() {
						var e = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
						return this.cloneTo(e), e
					}
				}, {
					key: "sizeX",
					get: function() {
						return this._sizeX
					}
				}, {
					key: "sizeY",
					get: function() {
						return this._sizeY
					}
				}, {
					key: "sizeZ",
					get: function() {
						return this._sizeZ
					}
				}], [{
					key: "__init__",
					value: function() {
						BoxColliderShape._btSize = l.Physics3D._bullet.btVector3_create(0, 0, 0)
					}
				}]), BoxColliderShape
			}(h),
			T = function(e) {
				function CapsuleColliderShape() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1.25,
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
					_classCallCheck(this, CapsuleColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							CapsuleColliderShape).call(this)))._radius = t, e._length = r, e._orientation = n, e._type =
						h.SHAPETYPES_CAPSULE;
					var i = l.Physics3D._bullet;
					switch (n) {
						case h.SHAPEORIENTATION_UPX:
							e._btShape = i.btCapsuleShapeX_create(t, r - 2 * t);
							break;
						case h.SHAPEORIENTATION_UPY:
							e._btShape = i.btCapsuleShape_create(t, r - 2 * t);
							break;
						case h.SHAPEORIENTATION_UPZ:
							e._btShape = i.btCapsuleShapeZ_create(t, r - 2 * t);
							break;
						default:
							throw "CapsuleColliderShape:unknown orientation."
					}
					return e
				}
				return _inherits(CapsuleColliderShape, e), _createClass(CapsuleColliderShape, [{
					key: "_setScale",
					value: function(e) {
						var t = CapsuleColliderShape._tempVector30;
						switch (this.orientation) {
							case h.SHAPEORIENTATION_UPX:
								t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
								break;
							case h.SHAPEORIENTATION_UPY:
								t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
								break;
							case h.SHAPEORIENTATION_UPZ:
								t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
								break;
							default:
								throw "CapsuleColliderShape:unknown orientation."
						}
						_get(_getPrototypeOf(CapsuleColliderShape.prototype), "_setScale", this).call(
							this, t)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new CapsuleColliderShape(this._radius, this._length, this._orientation);
						return this.cloneTo(e), e
					}
				}, {
					key: "radius",
					get: function() {
						return this._radius
					}
				}, {
					key: "length",
					get: function() {
						return this._length
					}
				}, {
					key: "orientation",
					get: function() {
						return this._orientation
					}
				}]), CapsuleColliderShape
			}(h);
		T._tempVector30 = new o;
		var E = function(e) {
				function ConeColliderShape() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
					_classCallCheck(this, ConeColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							ConeColliderShape).call(this)))._radius = 1, e._height = .5, e._radius = t, e._height = r, e
						._orientation = n, e._type = h.SHAPETYPES_CYLINDER;
					var i = l.Physics3D._bullet;
					switch (n) {
						case h.SHAPEORIENTATION_UPX:
							e._btShape = i.btConeShapeX_create(t, r);
							break;
						case h.SHAPEORIENTATION_UPY:
							e._btShape = i.btConeShape_create(t, r);
							break;
						case h.SHAPEORIENTATION_UPZ:
							e._btShape = i.btConeShapeZ_create(t, r);
							break;
						default:
							throw "ConeColliderShape:unknown orientation."
					}
					return e
				}
				return _inherits(ConeColliderShape, e), _createClass(ConeColliderShape, [{
					key: "clone",
					value: function() {
						var e = new ConeColliderShape(this._radius, this._height, this._orientation);
						return this.cloneTo(e), e
					}
				}, {
					key: "radius",
					get: function() {
						return this._radius
					}
				}, {
					key: "height",
					get: function() {
						return this._height
					}
				}, {
					key: "orientation",
					get: function() {
						return this._orientation
					}
				}]), ConeColliderShape
			}(h),
			g = function(e) {
				function CylinderColliderShape() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : h.SHAPEORIENTATION_UPY;
					_classCallCheck(this, CylinderColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							CylinderColliderShape).call(this)))._radius = 1, e._height = .5, e._radius = t, e._height =
						r, e._orientation = n, e._type = h.SHAPETYPES_CYLINDER;
					var i = l.Physics3D._bullet;
					switch (n) {
						case h.SHAPEORIENTATION_UPX:
							i.btVector3_setValue(CylinderColliderShape._btSize, r / 2, t, t), e._btShape = i
								.btCylinderShapeX_create(CylinderColliderShape._btSize);
							break;
						case h.SHAPEORIENTATION_UPY:
							i.btVector3_setValue(CylinderColliderShape._btSize, t, r / 2, t), e._btShape = i
								.btCylinderShape_create(CylinderColliderShape._btSize);
							break;
						case h.SHAPEORIENTATION_UPZ:
							i.btVector3_setValue(CylinderColliderShape._btSize, t, t, r / 2), e._btShape = i
								.btCylinderShapeZ_create(CylinderColliderShape._btSize);
							break;
						default:
							throw "CapsuleColliderShape:unknown orientation."
					}
					return e
				}
				return _inherits(CylinderColliderShape, e), _createClass(CylinderColliderShape, [{
					key: "clone",
					value: function() {
						var e = new CylinderColliderShape(this._radius, this._height, this
						._orientation);
						return this.cloneTo(e), e
					}
				}, {
					key: "radius",
					get: function() {
						return this._radius
					}
				}, {
					key: "height",
					get: function() {
						return this._height
					}
				}, {
					key: "orientation",
					get: function() {
						return this._orientation
					}
				}], [{
					key: "__init__",
					value: function() {
						CylinderColliderShape._btSize = l.Physics3D._bullet.btVector3_create(0, 0, 0)
					}
				}]), CylinderColliderShape
			}(h),
			y = function(e) {
				function MeshColliderShape() {
					var e;
					return _classCallCheck(this, MeshColliderShape), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(MeshColliderShape).call(this)))._mesh = null, e._convex = !1, e
				}
				return _inherits(MeshColliderShape, e), _createClass(MeshColliderShape, [{
					key: "_setScale",
					value: function(e) {
						if (this._compoundParent) this.updateLocalTransformations();
						else {
							var t = l.Physics3D._bullet;
							t.btVector3_setValue(h._btScale, e.x, e.y, e.z), t
								.btCollisionShape_setLocalScaling(this._btShape, h._btScale), t
								.btGImpactShapeInterface_updateBound(this._btShape)
						}
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.convex = this._convex, t.mesh = this._mesh, _get(_getPrototypeOf(
							MeshColliderShape.prototype), "cloneTo", this).call(this, e)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new MeshColliderShape;
						return this.cloneTo(e), e
					}
				}, {
					key: "destroy",
					value: function() {
						this._btShape && (l.Physics3D._bullet.btCollisionShape_destroy(this._btShape),
							this._btShape = null)
					}
				}, {
					key: "mesh",
					get: function() {
						return this._mesh
					},
					set: function(e) {
						if (this._mesh !== e) {
							var t = l.Physics3D._bullet;
							this._mesh && t.btCollisionShape_destroy(this._btShape), e && (this
								._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()), t
								.btGImpactShapeInterface_updateBound(this._btShape)), this._mesh = e
						}
					}
				}, {
					key: "convex",
					get: function() {
						return this._convex
					},
					set: function(e) {
						this._convex = e
					}
				}]), MeshColliderShape
			}(h),
			S = function(e) {
				function SphereColliderShape() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5;
					return _classCallCheck(this, SphereColliderShape), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(SphereColliderShape).call(this)))._radius = t, e._type = h
						.SHAPETYPES_SPHERE, e._btShape = l.Physics3D._bullet.btSphereShape_create(t), e
				}
				return _inherits(SphereColliderShape, e), _createClass(SphereColliderShape, [{
					key: "clone",
					value: function() {
						var e = new SphereColliderShape(this._radius);
						return this.cloneTo(e), e
					}
				}, {
					key: "radius",
					get: function() {
						return this._radius
					}
				}]), SphereColliderShape
			}(h),
			v = function(e) {
				function PhysicsComponent(e, t) {
					var r;
					return _classCallCheck(this, PhysicsComponent), (r = _possibleConstructorReturn(this,
							_getPrototypeOf(PhysicsComponent).call(this)))._restitution = 0, r._friction = .5, r
						._rollingFriction = 0, r._ccdMotionThreshold = 0, r._ccdSweptSphereRadius = 0, r
						._collisionGroup = m.COLLISIONFILTERGROUP_DEFAULTFILTER, r._canCollideWith = m
						.COLLISIONFILTERGROUP_ALLFILTER, r._colliderShape = null, r._transformFlag = 2147483647, r
						._controlBySimulation = !1, r._enableProcessCollisions = !0, r._inPhysicUpdateListIndex = -1, r
						.canScaleShape = !0, r._collisionGroup = e, r._canCollideWith = t, PhysicsComponent
						._physicObjectsMap[r.id] = _assertThisInitialized(r), r
				}
				return _inherits(PhysicsComponent, e), _createClass(PhysicsComponent, [{
					key: "_parseShape",
					value: function(e) {
						var t = e.length;
						if (1 === t) {
							var r = PhysicsComponent._creatShape(e[0]);
							this.colliderShape = r
						} else {
							for (var n = new d, i = 0; i < t; i++) r = PhysicsComponent._creatShape(e[
								i]), n.addChildShape(r);
							this.colliderShape = n
						}
					}
				}, {
					key: "_onScaleChange",
					value: function(e) {
						this._colliderShape._setScale(e)
					}
				}, {
					key: "_onEnable",
					value: function() {
						this._simulation = this.owner._scene.physicsSimulation, l.Physics3D._bullet
							.btCollisionObject_setContactProcessingThreshold(this._btColliderObject,
								1e30), this._colliderShape && (this._derivePhysicsTransformation(!0),
								this._addToSimulation())
					}
				}, {
					key: "_onDisable",
					value: function() {
						this._colliderShape && (this._removeFromSimulation(), -1 !== this
							._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(
								this)), this._simulation = null
					}
				}, {
					key: "_onDestroy",
					value: function() {
						delete PhysicsComponent._physicObjectsMap[this.id], l.Physics3D._bullet
							.btCollisionObject_destroy(this._btColliderObject), this._colliderShape
							.destroy(), _get(_getPrototypeOf(PhysicsComponent.prototype), "_onDestroy",
								this).call(this), this._btColliderObject = null, this._colliderShape =
							null, this._simulation = null, this.owner.transform.off(t.Event
								.TRANSFORM_CHANGED, this, this._onTransformChanged)
					}
				}, {
					key: "_isValid",
					value: function() {
						return this._simulation && this._colliderShape && this._enabled
					}
				}, {
					key: "_parse",
					value: function(e) {
						null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e
							.canCollideWith && (this.canCollideWith = e.canCollideWith), null != e
							.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold),
							null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e
								.ccdSweptSphereRadius)
					}
				}, {
					key: "_setTransformFlag",
					value: function(e, t) {
						t ? this._transformFlag |= e : this._transformFlag &= ~e
					}
				}, {
					key: "_getTransformFlag",
					value: function(e) {
						return 0 != (this._transformFlag & e)
					}
				}, {
					key: "_addToSimulation",
					value: function() {}
				}, {
					key: "_removeFromSimulation",
					value: function() {}
				}, {
					key: "_derivePhysicsTransformation",
					value: function(e) {
						var t = l.Physics3D._bullet,
							r = this._btColliderObject,
							n = t.btCollisionObject_getWorldTransform(r);
						this._innerDerivePhysicsTransformation(n, e), t
							.btCollisionObject_setWorldTransform(r, n)
					}
				}, {
					key: "_innerDerivePhysicsTransformation",
					value: function(e, t) {
						var r = l.Physics3D._bullet,
							n = this.owner._transform;
						if (t || this._getTransformFlag(f.TRANSFORM_WORLDPOSITION)) {
							var i = this._colliderShape.localOffset,
								a = n.position,
								s = PhysicsComponent._btVector30;
							if (0 !== i.x || 0 !== i.y || 0 !== i.z) {
								var u = PhysicsComponent._tempVector30,
									c = n.worldMatrix;
								o.transformCoordinate(i, c, u), r.btVector3_setValue(s, -u.x, u.y, u.z)
							} else r.btVector3_setValue(s, -a.x, a.y, a.z);
							r.btTransform_setOrigin(e, s), this._setTransformFlag(f
								.TRANSFORM_WORLDPOSITION, !1)
						}
						if (t || this._getTransformFlag(f.TRANSFORM_WORLDQUATERNION)) {
							var h = this._colliderShape.localRotation,
								_ = PhysicsComponent._btQuaternion0,
								d = n.rotation;
							if (0 !== h.x || 0 !== h.y || 0 !== h.z || 1 !== h.w) {
								var m = PhysicsComponent._tempQuaternion0;
								PhysicsComponent.physicQuaternionMultiply(d.x, d.y, d.z, d.w, h, m), r
									.btQuaternion_setValue(_, -m.x, m.y, m.z, -m.w)
							} else r.btQuaternion_setValue(_, -d.x, d.y, d.z, -d.w);
							r.btTransform_setRotation(e, _), this._setTransformFlag(f
								.TRANSFORM_WORLDQUATERNION, !1)
						}(t || this._getTransformFlag(f.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(n
							.getWorldLossyScale()), this._setTransformFlag(f.TRANSFORM_WORLDSCALE, !
							1))
					}
				}, {
					key: "_updateTransformComponent",
					value: function(e) {
						var t = l.Physics3D._bullet,
							r = this._colliderShape,
							n = r.localOffset,
							i = r.localRotation,
							a = this.owner._transform,
							s = a.position,
							u = a.rotation,
							c = t.btTransform_getOrigin(e),
							h = t.btTransform_getRotation(e),
							_ = -t.btQuaternion_x(h),
							d = t.btQuaternion_y(h),
							f = t.btQuaternion_z(h),
							m = -t.btQuaternion_w(h);
						if (0 !== i.x || 0 !== i.y || 0 !== i.z || 1 !== i.w) {
							var p = PhysicsComponent._tempQuaternion0;
							i.invert(p), PhysicsComponent.physicQuaternionMultiply(_, d, f, m, p, u)
						} else u.x = _, u.y = d, u.z = f, u.w = m;
						if (a.rotation = u, 0 !== n.x || 0 !== n.y || 0 !== n.z) {
							var T = t.btCollisionShape_getLocalScaling(r._btShape),
								E = PhysicsComponent._tempVector30;
							E.x = n.x * t.btVector3_x(T), E.y = n.y * t.btVector3_y(T), E.z = n.z * t
								.btVector3_z(T), o.transformQuat(E, u, E), s.x = -t.btVector3_x(c) - E
								.x, s.y = t.btVector3_y(c) - E.y, s.z = t.btVector3_z(c) - E.z
						} else s.x = -t.btVector3_x(c), s.y = t.btVector3_y(c), s.z = t.btVector3_z(c);
						a.position = s
					}
				}, {
					key: "_onShapeChange",
					value: function(e) {
						var t = this._btColliderObject,
							r = l.Physics3D._bullet,
							n = r.btCollisionObject_getCollisionFlags(t);
						e.needsCustomCollisionCallback ? 0 == (n & PhysicsComponent
								.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && r
							.btCollisionObject_setCollisionFlags(t, n | PhysicsComponent
								.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (n & PhysicsComponent
								.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && r
							.btCollisionObject_setCollisionFlags(t, n ^ PhysicsComponent
								.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK)
					}
				}, {
					key: "_onAdded",
					value: function() {
						this.enabled = this._enabled, this.restitution = this._restitution, this
							.friction = this._friction, this.rollingFriction = this._rollingFriction,
							this.ccdMotionThreshold = this._ccdMotionThreshold, this
							.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(
								t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged)
					}
				}, {
					key: "_onTransformChanged",
					value: function(e) {
						!PhysicsComponent._addUpdateList && this._controlBySimulation || (e &= f
							.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f
							.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e, this._isValid() &&
							-1 === this._inPhysicUpdateListIndex && this._simulation
							._physicsUpdateList.add(this))
					}
				}, {
					key: "_cloneTo",
					value: function(e) {
						var t = e;
						t.restitution = this._restitution, t.friction = this._friction, t
							.rollingFriction = this._rollingFriction, t.ccdMotionThreshold = this
							._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius, t
							.collisionGroup = this._collisionGroup, t.canCollideWith = this
							._canCollideWith, t.canScaleShape = this.canScaleShape, this
							._colliderShape && (t.colliderShape = this._colliderShape.clone())
					}
				}, {
					key: "restitution",
					get: function() {
						return this._restitution
					},
					set: function(e) {
						this._restitution = e, this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_setRestitution(this._btColliderObject, e)
					}
				}, {
					key: "friction",
					get: function() {
						return this._friction
					},
					set: function(e) {
						this._friction = e, this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_setFriction(this._btColliderObject, e)
					}
				}, {
					key: "rollingFriction",
					get: function() {
						return this._rollingFriction
					},
					set: function(e) {
						this._rollingFriction = e, this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_setRollingFriction(this._btColliderObject, e)
					}
				}, {
					key: "ccdMotionThreshold",
					get: function() {
						return this._ccdMotionThreshold
					},
					set: function(e) {
						this._ccdMotionThreshold = e, this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e)
					}
				}, {
					key: "ccdSweptSphereRadius",
					get: function() {
						return this._ccdSweptSphereRadius
					},
					set: function(e) {
						this._ccdSweptSphereRadius = e, this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e)
					}
				}, {
					key: "isActive",
					get: function() {
						return !!this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_isActive(this._btColliderObject)
					}
				}, {
					key: "colliderShape",
					get: function() {
						return this._colliderShape
					},
					set: function(e) {
						var t = this._colliderShape;
						if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this
							._colliderShape = e, e) {
							if (e._attatched)
							throw "PhysicsComponent: this shape has attatched to other entity.";
							if (e._attatched = !0, e._attatchedCollisionObject = this, this
								._btColliderObject) {
								l.Physics3D._bullet.btCollisionObject_setCollisionShape(this
									._btColliderObject, e._btShape);
								var r = this._simulation && this._enabled;
								r && t && this._removeFromSimulation(), this._onShapeChange(e), r && (
									this._derivePhysicsTransformation(!0), this._addToSimulation())
							}
						} else this._simulation && this._enabled && t && this._removeFromSimulation()
					}
				}, {
					key: "simulation",
					get: function() {
						return this._simulation
					}
				}, {
					key: "collisionGroup",
					get: function() {
						return this._collisionGroup
					},
					set: function(e) {
						this._collisionGroup !== e && (this._collisionGroup = e, this._simulation &&
							this._colliderShape && this._enabled && (this._removeFromSimulation(),
								this._addToSimulation()))
					}
				}, {
					key: "canCollideWith",
					get: function() {
						return this._canCollideWith
					},
					set: function(e) {
						this._canCollideWith !== e && (this._canCollideWith = e, this._simulation &&
							this._colliderShape && this._enabled && (this._removeFromSimulation(),
								this._addToSimulation()))
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = l.Physics3D._bullet;
						PhysicsComponent._btVector30 = e.btVector3_create(0, 0, 0), PhysicsComponent
							._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1)
					}
				}, {
					key: "_createAffineTransformationArray",
					value: function(e, t, r, n, i, a, o, s, l) {
						var u = n + n,
							c = i + i,
							h = a + a,
							_ = n * u,
							d = n * c,
							f = n * h,
							m = i * c,
							p = i * h,
							T = a * h,
							E = o * u,
							g = o * c,
							y = o * h,
							S = s[0],
							v = s[1],
							R = s[2];
						l[0] = (1 - (m + T)) * S, l[1] = (d + y) * S, l[2] = (f - g) * S, l[3] = 0, l[
							4] = (d - y) * v, l[5] = (1 - (_ + T)) * v, l[6] = (p + E) * v, l[7] = 0, l[
								8] = (f + g) * R, l[9] = (p - E) * R, l[10] = (1 - (_ + m)) * R, l[11] =
							0, l[12] = e, l[13] = t, l[14] = r, l[15] = 1
					}
				}, {
					key: "_creatShape",
					value: function(e) {
						var r;
						switch (e.type) {
							case "BoxColliderShape":
								var n = e.size;
								r = n ? new p(n[0], n[1], n[2]) : new p;
								break;
							case "SphereColliderShape":
								r = new S(e.radius);
								break;
							case "CapsuleColliderShape":
								r = new T(e.radius, e.height, e.orientation);
								break;
							case "MeshColliderShape":
								var i = new y;
								e.mesh && (i.mesh = t.Loader.getRes(e.mesh)), r = i;
								break;
							case "ConeColliderShape":
								r = new E(e.radius, e.height, e.orientation);
								break;
							case "CylinderColliderShape":
								r = new g(e.radius, e.height, e.orientation);
								break;
							default:
								throw "unknown shape type."
						}
						if (e.center) {
							var a = r.localOffset;
							a.fromArray(e.center), r.localOffset = a
						}
						return r
					}
				}, {
					key: "physicVector3TransformQuat",
					value: function(e, t, r, n, i, a) {
						var o = e.x,
							s = e.y,
							l = e.z,
							u = i * o + r * l - n * s,
							c = i * s + n * o - t * l,
							h = i * l + t * s - r * o,
							_ = -t * o - r * s - n * l;
						a.x = u * i + _ * -t + c * -n - h * -r, a.y = c * i + _ * -r + h * -t - u * -n,
							a.z = h * i + _ * -n + u * -r - c * -t
					}
				}, {
					key: "physicQuaternionMultiply",
					value: function(e, t, r, n, i, a) {
						var o = i.x,
							s = i.y,
							l = i.z,
							u = i.w,
							c = t * l - r * s,
							h = r * o - e * l,
							_ = e * s - t * o,
							d = e * o + t * s + r * l;
						a.x = e * u + o * n + c, a.y = t * u + s * n + h, a.z = r * u + l * n + _, a.w =
							n * u - d
					}
				}]), PhysicsComponent
			}(t.Component);
		v.ACTIVATIONSTATE_ACTIVE_TAG = 1, v.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, v.ACTIVATIONSTATE_WANTS_DEACTIVATION =
			3, v.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, v.ACTIVATIONSTATE_DISABLE_SIMULATION = 5, v
			.COLLISIONFLAGS_STATIC_OBJECT = 1, v.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, v
			.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4, v.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, v
			.COLLISIONFLAGS_CHARACTER_OBJECT = 16, v.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, v
			.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64, v._tempVector30 = new o, v._tempQuaternion0 = new u,
			v._tempQuaternion1 = new u, v._tempMatrix4x40 = new c, v._physicObjectsMap = {}, v._addUpdateList = !0;
		var R = function() {
				function SingletonList() {
					_classCallCheck(this, SingletonList), this.elements = [], this.length = 0
				}
				return _createClass(SingletonList, [{
					key: "_add",
					value: function(e) {
						this.length === this.elements.length ? this.elements.push(e) : this.elements[
							this.length] = e
					}
				}, {
					key: "add",
					value: function(e) {
						this.length === this.elements.length ? this.elements.push(e) : this.elements[
							this.length] = e, this.length++
					}
				}]), SingletonList
			}(),
			C = function(e) {
				function PhysicsUpdateList() {
					return _classCallCheck(this, PhysicsUpdateList), _possibleConstructorReturn(this, _getPrototypeOf(
						PhysicsUpdateList).call(this))
				}
				return _inherits(PhysicsUpdateList, e), _createClass(PhysicsUpdateList, [{
					key: "add",
					value: function(e) {
						if (-1 !== e._inPhysicUpdateListIndex)
						throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
						this._add(e), e._inPhysicUpdateListIndex = this.length++
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._inPhysicUpdateListIndex;
						if (this.length--, t !== this.length) {
							var r = this.elements[this.length];
							this.elements[t] = r, r._inPhysicUpdateListIndex = t
						}
						e._inPhysicUpdateListIndex = -1
					}
				}]), PhysicsUpdateList
			}(R),
			M = function ContactPoint() {
				_classCallCheck(this, ContactPoint), this._idCounter = 0, this.colliderA = null, this.colliderB = null,
					this.distance = 0, this.normal = new o, this.positionOnA = new o, this.positionOnB = new o, this
					._id = ++this._idCounter
			},
			D = function HitResult() {
				_classCallCheck(this, HitResult), this.succeeded = !1, this.collider = null, this.point = new o, this
					.normal = new o, this.hitFraction = 0
			},
			x = function() {
				function Collision() {
					_classCallCheck(this, Collision), this._lastUpdateFrame = -2147483648, this._updateFrame = -
						2147483648, this._isTrigger = !1, this.contacts = []
				}
				return _createClass(Collision, [{
					key: "_setUpdateFrame",
					value: function(e) {
						this._lastUpdateFrame = this._updateFrame, this._updateFrame = e
					}
				}]), Collision
			}(),
			A = function() {
				function CollisionTool() {
					_classCallCheck(this, CollisionTool), this._hitResultsPoolIndex = 0, this._hitResultsPool = [], this
						._contactPonintsPoolIndex = 0, this._contactPointsPool = [], this._collisionsPool = [], this
						._collisions = {}
				}
				return _createClass(CollisionTool, [{
					key: "getHitResult",
					value: function() {
						var e = this._hitResultsPool[this._hitResultsPoolIndex++];
						return e || (e = new D, this._hitResultsPool.push(e)), e
					}
				}, {
					key: "recoverAllHitResultsPool",
					value: function() {
						this._hitResultsPoolIndex = 0
					}
				}, {
					key: "getContactPoints",
					value: function() {
						var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
						return e || (e = new M, this._contactPointsPool.push(e)), e
					}
				}, {
					key: "recoverAllContactPointsPool",
					value: function() {
						this._contactPonintsPoolIndex = 0
					}
				}, {
					key: "getCollision",
					value: function(e, t) {
						var r, n = e.id,
							i = t.id,
							a = this._collisions[n];
						return a && (r = a[i]), r || (a || (a = {}, this._collisions[n] = a), (r = 0 ===
								this._collisionsPool.length ? new x : this._collisionsPool.pop())
							._colliderA = e, r._colliderB = t, a[i] = r), r
					}
				}, {
					key: "recoverCollision",
					value: function(e) {
						var t = e._colliderA.id,
							r = e._colliderB.id;
						this._collisions[t][r] = null, this._collisionsPool.push(e)
					}
				}, {
					key: "garbageCollection",
					value: function() {
						for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0,
								this._contactPonintsPoolIndex = 0, this._contactPointsPool.length = 0,
								this._collisionsPool.length = 0, this._collisionsPool) {
							var t = this._collisionsPool[e],
								r = !0;
							for (var n in t) t[n] ? r = !1 : delete t[n];
							r && delete this._collisionsPool[e]
						}
					}
				}]), CollisionTool
			}(),
			I = function() {
				function PhysicsSimulation(e) {
					arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					_classCallCheck(this, PhysicsSimulation), this._gravity = new o(0, -10, 0), this._btVector3Zero = l
						.Physics3D._bullet.btVector3_create(0, 0, 0), this._btDefaultQuaternion = l.Physics3D._bullet
						.btQuaternion_create(0, 0, 0, -1), this._collisionsUtils = new A, this
						._previousFrameCollisions = [], this._currentFrameCollisions = [], this._currentConstraint = {},
						this._physicsUpdateList = new C, this._characters = [], this._updatedRigidbodies = 0, this
						.maxSubSteps = 1, this.fixedTimeStep = 1 / 60, this.maxSubSteps = e.maxSubSteps, this
						.fixedTimeStep = e.fixedTimeStep;
					var t = l.Physics3D._bullet;
					this._btCollisionConfiguration = t.btDefaultCollisionConfiguration_create(), this._btDispatcher = t
						.btCollisionDispatcher_create(this._btCollisionConfiguration), this._btBroadphase = t
						.btDbvtBroadphase_create(), t.btOverlappingPairCache_setInternalGhostPairCallback(t
							.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), t
							.btGhostPairCallback_create());
					var r = e.flags;
					if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._btCollisionWorld = new t
						.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration);
					else {
						if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT)
						throw "PhysicsSimulation:SoftBody processing is not yet available";
						var n = t.btSequentialImpulseConstraintSolver_create();
						this._btDiscreteDynamicsWorld = t.btDiscreteDynamicsWorld_create(this._btDispatcher, this
								._btBroadphase, n, this._btCollisionConfiguration), this._btCollisionWorld = this
							._btDiscreteDynamicsWorld
					}
					this._btDiscreteDynamicsWorld && (this._btSolverInfo = t.btDynamicsWorld_getSolverInfo(this
							._btDiscreteDynamicsWorld), this._btDispatchInfo = t.btCollisionWorld_getDispatchInfo(
							this._btDiscreteDynamicsWorld)), this._btClosestRayResultCallback = t
						.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero), this
						._btAllHitsRayResultCallback = t.AllHitsRayResultCallback_create(this._btVector3Zero, this
							._btVector3Zero), this._btClosestConvexResultCallback = t
						.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero), this
						._btAllConvexResultCallback = t.AllConvexResultCallback_create(this._btVector3Zero, this
							._btVector3Zero), this.setHitsRayResultCallbackFlag(), t
						.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher)
				}
				return _createClass(PhysicsSimulation, [{
					key: "_simulate",
					value: function(e) {
						this._updatedRigidbodies = 0;
						var t = l.Physics3D._bullet;
						this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this
								._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t
							.PerformDiscreteCollisionDetection(this._btCollisionWorld)
					}
				}, {
					key: "_destroy",
					value: function() {
						var e = l.Physics3D._bullet;
						this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this
								._btDiscreteDynamicsWorld), this._btDiscreteDynamicsWorld = null) : (e
								.btCollisionWorld_destroy(this._btCollisionWorld), this
								._btCollisionWorld = null), e.btDbvtBroadphase_destroy(this
								._btBroadphase), this._btBroadphase = null, e
							.btCollisionDispatcher_destroy(this._btDispatcher), this._btDispatcher =
							null, e.btDefaultCollisionConfiguration_destroy(this
								._btCollisionConfiguration), this._btCollisionConfiguration = null
					}
				}, {
					key: "_addPhysicsCollider",
					value: function(e, t, r) {
						l.Physics3D._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld,
							e._btColliderObject, t, r)
					}
				}, {
					key: "_removePhysicsCollider",
					value: function(e) {
						l.Physics3D._bullet.btCollisionWorld_removeCollisionObject(this
							._btCollisionWorld, e._btColliderObject)
					}
				}, {
					key: "_addRigidBody",
					value: function(e, t, r) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld,
							e._btColliderObject, t, r)
					}
				}, {
					key: "_removeRigidBody",
					value: function(e) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet.btDiscreteDynamicsWorld_removeRigidBody(this
							._btCollisionWorld, e._btColliderObject)
					}
				}, {
					key: "_addCharacter",
					value: function(e, t, r) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						var n = l.Physics3D._bullet;
						n.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e
							._btColliderObject, t, r), n.btDynamicsWorld_addAction(this
							._btCollisionWorld, e._btKinematicCharacter)
					}
				}, {
					key: "_removeCharacter",
					value: function(e) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						var t = l.Physics3D._bullet;
						t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e
							._btColliderObject), t.btDynamicsWorld_removeAction(this
							._btCollisionWorld, e._btKinematicCharacter)
					}
				}, {
					key: "raycastFromTo",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							a = l.Physics3D._bullet,
							o = this._btClosestRayResultCallback,
							s = PhysicsSimulation._btTempVector30,
							u = PhysicsSimulation._btTempVector31;
						if (a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(u, -t.x, t.y,
								t.z), a.ClosestRayResultCallback_set_m_rayFromWorld(o, s), a
							.ClosestRayResultCallback_set_m_rayToWorld(o, u), a
							.RayResultCallback_set_m_collisionFilterGroup(o, n), a
							.RayResultCallback_set_m_collisionFilterMask(o, i), a
							.RayResultCallback_set_m_collisionObject(o, null), a
							.RayResultCallback_set_m_closestHitFraction(o, 1), a
							.btCollisionWorld_rayTest(this._btCollisionWorld, s, u, o), a
							.RayResultCallback_hasHit(o)) {
							if (r) {
								r.succeeded = !0, r.collider = v._physicObjectsMap[a
										.btCollisionObject_getUserIndex(a
											.RayResultCallback_get_m_collisionObject(o))], r
									.hitFraction = a.RayResultCallback_get_m_closestHitFraction(o);
								var c = a.ClosestRayResultCallback_get_m_hitPointWorld(o),
									h = r.point;
								h.x = -a.btVector3_x(c), h.y = a.btVector3_y(c), h.z = a.btVector3_z(c);
								var _ = a.ClosestRayResultCallback_get_m_hitNormalWorld(o),
									d = r.normal;
								d.x = -a.btVector3_x(_), d.y = a.btVector3_y(_), d.z = a.btVector3_z(_)
							}
							return !0
						}
						return r && (r.succeeded = !1), !1
					}
				}, {
					key: "raycastAllFromTo",
					value: function(e, t, r) {
						var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							a = l.Physics3D._bullet,
							o = this._btAllHitsRayResultCallback,
							s = PhysicsSimulation._btTempVector30,
							u = PhysicsSimulation._btTempVector31;
						r.length = 0, a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(u, -
								t.x, t.y, t.z), a.AllHitsRayResultCallback_set_m_rayFromWorld(o, s), a
							.AllHitsRayResultCallback_set_m_rayToWorld(o, u), a
							.RayResultCallback_set_m_collisionFilterGroup(o, n), a
							.RayResultCallback_set_m_collisionFilterMask(o, i);
						var c = a.AllHitsRayResultCallback_get_m_collisionObjects(o),
							h = a.AllHitsRayResultCallback_get_m_hitPointWorld(o),
							_ = a.AllHitsRayResultCallback_get_m_hitNormalWorld(o),
							d = a.AllHitsRayResultCallback_get_m_hitFractions(o);
						a.tBtCollisionObjectArray_clear(c), a.tVector3Array_clear(h), a
							.tVector3Array_clear(_), a.tScalarArray_clear(d), a
							.btCollisionWorld_rayTest(this._btCollisionWorld, s, u, o);
						var f = a.tBtCollisionObjectArray_size(c);
						if (f > 0) {
							this._collisionsUtils.recoverAllHitResultsPool();
							for (var p = 0; p < f; p++) {
								var T = this._collisionsUtils.getHitResult();
								r.push(T), T.succeeded = !0, T.collider = v._physicObjectsMap[a
									.btCollisionObject_getUserIndex(a.tBtCollisionObjectArray_at(c,
										p))], T.hitFraction = a.tScalarArray_at(d, p);
								var E = a.tVector3Array_at(h, p),
									g = T.point;
								g.x = -a.btVector3_x(E), g.y = a.btVector3_y(E), g.z = a.btVector3_z(E);
								var y = a.tVector3Array_at(_, p),
									S = T.normal;
								S.x = -a.btVector3_x(y), S.y = a.btVector3_y(y), S.z = a.btVector3_z(y)
							}
							return !0
						}
						return !1
					}
				}, {
					key: "rayCast",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
							2147483647,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							a = e.origin,
							s = PhysicsSimulation._tempVector30;
						return o.normalize(e.direction, s), o.scale(s, r, s), o.add(a, s, s), this
							.raycastFromTo(a, s, t, n, i)
					}
				}, {
					key: "rayCastAll",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
							2147483647,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							a = e.origin,
							s = PhysicsSimulation._tempVector30;
						return o.normalize(e.direction, s), o.scale(s, r, s), o.add(a, s, s), this
							.raycastAllFromTo(a, s, t, n, i)
					}
				}, {
					key: "shapeCast",
					value: function(e, t, r) {
						var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
							a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
							o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
							c = l.Physics3D._bullet,
							h = this._btClosestConvexResultCallback,
							_ = PhysicsSimulation._btTempVector30,
							d = PhysicsSimulation._btTempVector31,
							f = PhysicsSimulation._btTempQuaternion0,
							p = PhysicsSimulation._btTempQuaternion1,
							T = PhysicsSimulation._btTempTransform0,
							E = PhysicsSimulation._btTempTransform1,
							g = e._btShape;
						if (c.btVector3_setValue(_, -t.x, t.y, t.z), c.btVector3_setValue(d, -r.x, r.y,
								r.z), c.ConvexResultCallback_set_m_collisionFilterGroup(h, o), c
							.ConvexResultCallback_set_m_collisionFilterMask(h, s), c
							.btTransform_setOrigin(T, _), c.btTransform_setOrigin(E, d), i ? (c
								.btQuaternion_setValue(f, -i.x, i.y, i.z, -i.w), c
								.btTransform_setRotation(T, f)) : c.btTransform_setRotation(T, this
								._btDefaultQuaternion), a ? (c.btQuaternion_setValue(p, -a.x, a.y, a.z,
								-a.w), c.btTransform_setRotation(E, p)) : c.btTransform_setRotation(E,
								this._btDefaultQuaternion), c
							.ClosestConvexResultCallback_set_m_hitCollisionObject(h, null), c
							.ConvexResultCallback_set_m_closestHitFraction(h, 1), c
							.btCollisionWorld_convexSweepTest(this._btCollisionWorld, g, T, E, h, u), c
							.ConvexResultCallback_hasHit(h)) {
							if (n) {
								n.succeeded = !0, n.collider = v._physicObjectsMap[c
										.btCollisionObject_getUserIndex(c
											.ClosestConvexResultCallback_get_m_hitCollisionObject(h))],
									n.hitFraction = c.ConvexResultCallback_get_m_closestHitFraction(h);
								var y = c.ClosestConvexResultCallback_get_m_hitPointWorld(h),
									S = c.ClosestConvexResultCallback_get_m_hitNormalWorld(h),
									R = n.point,
									C = n.normal;
								R.x = -c.btVector3_x(y), R.y = c.btVector3_y(y), R.z = c.btVector3_z(y),
									C.x = -c.btVector3_x(S), C.y = c.btVector3_y(S), C.z = c
									.btVector3_z(S)
							}
							return !0
						}
						return n && (n.succeeded = !1), !1
					}
				}, {
					key: "shapeCastAll",
					value: function(e, t, r, n) {
						var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
							a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
							o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : m
							.COLLISIONFILTERGROUP_ALLFILTER,
							u = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
							c = l.Physics3D._bullet,
							h = this._btAllConvexResultCallback,
							_ = PhysicsSimulation._btTempVector30,
							d = PhysicsSimulation._btTempVector31,
							f = PhysicsSimulation._btTempQuaternion0,
							p = PhysicsSimulation._btTempQuaternion1,
							T = PhysicsSimulation._btTempTransform0,
							E = PhysicsSimulation._btTempTransform1,
							g = e._btShape;
						n.length = 0, c.btVector3_setValue(_, -t.x, t.y, t.z), c.btVector3_setValue(d, -
								r.x, r.y, r.z), c.ConvexResultCallback_set_m_collisionFilterGroup(h, o),
							c.ConvexResultCallback_set_m_collisionFilterMask(h, s), c
							.btTransform_setOrigin(T, _), c.btTransform_setOrigin(E, d), i ? (c
								.btQuaternion_setValue(f, -i.x, i.y, i.z, -i.w), c
								.btTransform_setRotation(T, f)) : c.btTransform_setRotation(T, this
								._btDefaultQuaternion), a ? (c.btQuaternion_setValue(p, -a.x, a.y, a.z,
								-a.w), c.btTransform_setRotation(E, p)) : c.btTransform_setRotation(E,
								this._btDefaultQuaternion);
						var y = c.AllConvexResultCallback_get_m_collisionObjects(h),
							S = c.AllConvexResultCallback_get_m_hitPointWorld(h),
							R = c.AllConvexResultCallback_get_m_hitNormalWorld(h),
							C = c.AllConvexResultCallback_get_m_hitFractions(h);
						c.tVector3Array_clear(S), c.tVector3Array_clear(R), c.tScalarArray_clear(C), c
							.tBtCollisionObjectArray_clear(y), c.btCollisionWorld_convexSweepTest(this
								._btCollisionWorld, g, T, E, h, u);
						var M = c.tBtCollisionObjectArray_size(y);
						if (M > 0) {
							this._collisionsUtils.recoverAllHitResultsPool();
							for (var D = 0; D < M; D++) {
								var x = this._collisionsUtils.getHitResult();
								n.push(x), x.succeeded = !0, x.collider = v._physicObjectsMap[c
									.btCollisionObject_getUserIndex(c.tBtCollisionObjectArray_at(y,
										D))], x.hitFraction = c.tScalarArray_at(C, D);
								var A = c.tVector3Array_at(S, D),
									I = x.point;
								I.x = -c.btVector3_x(A), I.y = c.btVector3_y(A), I.z = c.btVector3_z(A);
								var L = c.tVector3Array_at(R, D),
									P = x.normal;
								P.x = -c.btVector3_x(L), P.y = c.btVector3_y(L), P.z = c.btVector3_z(L)
							}
							return !0
						}
						return !1
					}
				}, {
					key: "addConstraint",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
						if (!this._btDiscreteDynamicsWorld)
						throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet.btCollisionWorld_addConstraint(this
							._btDiscreteDynamicsWorld, e._btConstraint, t), this._currentConstraint[
							e.id] = e
					}
				}, {
					key: "removeConstraint",
					value: function(e) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet.btCollisionWorld_removeConstraint(this
								._btDiscreteDynamicsWorld, e._btConstraint), delete this
							._currentConstraint[e.id]
					}
				}, {
					key: "setHitsRayResultCallbackFlag",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
							t = l.Physics3D._bullet;
						t.RayResultCallback_set_m_flags(this._btAllHitsRayResultCallback, e), t
							.RayResultCallback_set_m_flags(this._btClosestRayResultCallback, e)
					}
				}, {
					key: "_updatePhysicsTransformFromRender",
					value: function() {
						for (var e = this._physicsUpdateList.elements, t = 0, r = this
								._physicsUpdateList.length; t < r; t++) {
							var n = e[t];
							n._derivePhysicsTransformation(!1), n._inPhysicUpdateListIndex = -1
						}
						this._physicsUpdateList.length = 0
					}
				}, {
					key: "_updateCharacters",
					value: function() {
						for (var e = 0, t = this._characters.length; e < t; e++) {
							var r = this._characters[e];
							r._updateTransformComponent(l.Physics3D._bullet
								.btCollisionObject_getWorldTransform(r._btColliderObject))
						}
					}
				}, {
					key: "_updateCollisions",
					value: function() {
						this._collisionsUtils.recoverAllContactPointsPool();
						var e = this._currentFrameCollisions;
						this._currentFrameCollisions = this._previousFrameCollisions, this
							._currentFrameCollisions.length = 0, this._previousFrameCollisions = e;
						for (var r = t.Stat.loopCount, n = l.Physics3D._bullet, i = n
								.btDispatcher_getNumManifolds(this._btDispatcher), a = 0; a < i; a++) {
							var o, s = n.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, a),
								u = v._physicObjectsMap[n.btCollisionObject_getUserIndex(n
									.btPersistentManifold_getBody0(s))],
								c = v._physicObjectsMap[n.btCollisionObject_getUserIndex(n
									.btPersistentManifold_getBody1(s))],
								h = null,
								_ = null;
							if ((u.isTrigger || c.isTrigger) && (u.owner._needProcessTriggers || c.owner
									._needProcessTriggers))
								for (var d = n.btPersistentManifold_getNumContacts(s), f = 0; f <
									d; f++) {
									var m = n.btPersistentManifold_getContactPoint(s, f),
										p = n.btManifoldPoint_getDistance(m);
									if (p <= 0) {
										_ = (h = this._collisionsUtils.getCollision(u, c)).contacts, (
											o = h._updateFrame !== r) && (h._isTrigger = !0, _
											.length = 0);
										break
									}
								} else if ((u.owner._needProcessCollisions || c.owner
										._needProcessCollisions) && (u._enableProcessCollisions || c
										._enableProcessCollisions))
									for (d = n.btPersistentManifold_getNumContacts(s), f = 0; f <
										d; f++)
										if (m = n.btPersistentManifold_getContactPoint(s, f), (p = n
												.btManifoldPoint_getDistance(m)) <= 0) {
											var T = this._collisionsUtils.getContactPoints();
											T.colliderA = u, T.colliderB = c, T.distance = p;
											var E = n.btManifoldPoint_get_m_normalWorldOnB(m),
												g = T.normal;
											g.x = -n.btVector3_x(E), g.y = n.btVector3_y(E), g.z = n
												.btVector3_z(E);
											var y = n.btManifoldPoint_get_m_positionWorldOnA(m),
												S = T.positionOnA;
											S.x = -n.btVector3_x(y), S.y = n.btVector3_y(y), S.z = n
												.btVector3_z(y);
											var R = n.btManifoldPoint_get_m_positionWorldOnB(m),
												C = T.positionOnB;
											C.x = -n.btVector3_x(R), C.y = n.btVector3_y(R), C.z = n
												.btVector3_z(R), h || (_ = (h = this._collisionsUtils
													.getCollision(u, c)).contacts, (o = h
													._updateFrame !== r) && (h._isTrigger = !1, _
													.length = 0)), _.push(T)
										} h && o && (this._currentFrameCollisions.push(h), h
								._setUpdateFrame(r))
						}
					}
				}, {
					key: "_eventScripts",
					value: function() {
						for (var e = t.Stat.loopCount, r = 0, n = this._currentFrameCollisions
							.length; r < n; r++) {
							var i = this._currentFrameCollisions[r],
								a = i._colliderA,
								o = i._colliderB;
							if (!a.destroyed && !o.destroyed)
								if (e - i._lastUpdateFrame == 1) {
									var s = a.owner,
										l = s._scripts;
									if (l)
										if (i._isTrigger) {
											if (s._needProcessTriggers)
												for (var u = 0, c = l.length; u < c; u++) l[u]
													.onTriggerStay(o)
										} else if (s._needProcessCollisions)
										for (u = 0, c = l.length; u < c; u++) i.other = o, l[u]
											.onCollisionStay(i);
									var h = o.owner,
										_ = h._scripts;
									if (_)
										if (i._isTrigger) {
											if (h._needProcessTriggers)
												for (u = 0, c = _.length; u < c; u++) _[u]
													.onTriggerStay(a)
										} else if (h._needProcessCollisions)
										for (u = 0, c = _.length; u < c; u++) i.other = a, _[u]
											.onCollisionStay(i)
								} else {
									if (l = (s = a.owner)._scripts)
										if (i._isTrigger) {
											if (s._needProcessTriggers)
												for (u = 0, c = l.length; u < c; u++) l[u]
													.onTriggerEnter(o)
										} else if (s._needProcessCollisions)
										for (u = 0, c = l.length; u < c; u++) i.other = o, l[u]
											.onCollisionEnter(i);
									if (_ = (h = o.owner)._scripts)
										if (i._isTrigger) {
											if (h._needProcessTriggers)
												for (u = 0, c = _.length; u < c; u++) _[u]
													.onTriggerEnter(a)
										} else if (h._needProcessCollisions)
										for (u = 0, c = _.length; u < c; u++) i.other = a, _[u]
											.onCollisionEnter(i)
								}
						}
						for (r = 0, n = this._previousFrameCollisions.length; r < n; r++) {
							var d = this._previousFrameCollisions[r],
								f = d._colliderA,
								m = d._colliderB;
							if (!f.destroyed && !m.destroyed && e - d._updateFrame == 1) {
								if (this._collisionsUtils.recoverCollision(d), l = (s = f.owner)
									._scripts)
									if (d._isTrigger) {
										if (s._needProcessTriggers)
											for (u = 0, c = l.length; u < c; u++) l[u].onTriggerExit(m)
									} else if (s._needProcessCollisions)
									for (u = 0, c = l.length; u < c; u++) d.other = m, l[u]
										.onCollisionExit(d);
								if (_ = (h = m.owner)._scripts)
									if (d._isTrigger) {
										if (h._needProcessTriggers)
											for (u = 0, c = _.length; u < c; u++) _[u].onTriggerExit(f)
									} else if (h._needProcessCollisions)
									for (u = 0, c = _.length; u < c; u++) d.other = f, _[u]
										.onCollisionExit(d)
							}
						}
						for (var p in this._currentConstraint) {
							var T = this._currentConstraint[p],
								E = T.owner._scripts;
							if (T.enabled && T._isBreakConstrained() && E && 0 != E.length)
								for (r = 0, n = E.length; r < n; r++) E[r].onJointBreak()
						}
					}
				}, {
					key: "clearForces",
					value: function() {
						if (!this._btDiscreteDynamicsWorld)
						throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet.btDiscreteDynamicsWorld_clearForces(this
							._btDiscreteDynamicsWorld)
					}
				}, {
					key: "continuousCollisionDetection",
					get: function() {
						return l.Physics3D._bullet.btCollisionWorld_get_m_useContinuous(this
							._btDispatchInfo)
					},
					set: function(e) {
						l.Physics3D._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo,
							e)
					}
				}, {
					key: "gravity",
					get: function() {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						return this._gravity
					},
					set: function(e) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
						this._gravity = e;
						var t = l.Physics3D._bullet,
							r = PhysicsSimulation._btTempVector30;
						t.btVector3_setValue(r, -e.x, e.y, e.z), t.btDiscreteDynamicsWorld_setGravity(
							this._btDiscreteDynamicsWorld, r)
					}
				}, {
					key: "speculativeContactRestitution",
					get: function() {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
						return l.Physics3D._bullet
							.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this
								._btDiscreteDynamicsWorld)
					},
					set: function(e) {
						if (!this._btDiscreteDynamicsWorld)
						throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
						l.Physics3D._bullet
							.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this
								._btDiscreteDynamicsWorld, e)
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = l.Physics3D._bullet;
						PhysicsSimulation._btTempVector30 = e.btVector3_create(0, 0, 0),
							PhysicsSimulation._btTempVector31 = e.btVector3_create(0, 0, 0),
							PhysicsSimulation._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1),
							PhysicsSimulation._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1),
							PhysicsSimulation._btTempTransform0 = e.btTransform_create(),
							PhysicsSimulation._btTempTransform1 = e.btTransform_create()
					}
				}, {
					key: "createConstraint",
					value: function() {}
				}]), PhysicsSimulation
			}();
		I.PHYSICSENGINEFLAGS_NONE = 0, I.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, I.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT =
			2, I.PHYSICSENGINEFLAGS_MULTITHREADED = 4, I.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8, I
			.SOLVERMODE_RANDMIZE_ORDER = 1, I.SOLVERMODE_FRICTION_SEPARATE = 2, I.SOLVERMODE_USE_WARMSTARTING = 4, I
			.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, I.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32, I
			.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, I.SOLVERMODE_CACHE_FRIENDLY = 128, I
			.SOLVERMODE_SIMD = 256, I.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512, I
			.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, I.HITSRAYRESULTCALLBACK_FLAG_NONE = 0, I
			.HITSRAYRESULTCALLBACK_FLAG_FILTERBACKFACESS = 1, I.HITSRAYRESULTCALLBACK_FLAG_KEEPUNFILIPPEDNORMAL = 2, I
			.HITSRAYRESULTCALLBACK_FLAG_USESUBSIMPLEXCONVEXCASTRAYTEST = 4, I
			.HITSRAYRESULTCALLBACK_FLAG_USEGJKCONVEXCASTRAYTEST = 8, I.HITSRAYRESULTCALLBACK_FLAG_TERMINATOR =
			4294967295, I._tempVector30 = new o, I.disableSimulation = !1;
		var L = function() {
				function TextureGenerator() {
					_classCallCheck(this, TextureGenerator)
				}
				return _createClass(TextureGenerator, null, [{
					key: "lightAttenTexture",
					value: function(e, t, r, n, i, a) {
						var o = e / r,
							s = 1 / (1 + 25 * o);
						o >= .64 && (o > 1 ? s = 0 : s *= 1 - (o - .64) / .36), a[i] = Math.floor(255 *
							s + .5)
					}
				}, {
					key: "haloTexture",
					value: function(e, t, r, n, i, a) {
						var o = (e - (r >>= 1)) / r,
							s = (t - (n >>= 1)) / n,
							l = o * o + s * s;
						l > 1 && (l = 1), a[i] = Math.floor(255 * (1 - l) + .5)
					}
				}, {
					key: "_generateTexture2D",
					value: function(e, r, n, i) {
						var a = 0,
							o = 0;
						switch (e.format) {
							case t.TextureFormat.R8G8B8:
								o = 3;
								break;
							case t.TextureFormat.R8G8B8A8:
								o = 4;
								break;
							case t.TextureFormat.Alpha8:
								o = 1;
								break;
							default:
								throw "GeneratedTexture._generateTexture: unkonw texture format."
						}
						for (var s = new Uint8Array(r * n * o), l = 0; l < n; l++)
							for (var u = 0; u < r; u++) i(u, l, r, n, a, s), a += o;
						e.setPixels(s)
					}
				}]), TextureGenerator
			}(),
			P = function() {
				function Utils3D() {
					_classCallCheck(this, Utils3D)
				}
				return _createClass(Utils3D, null, [{
					key: "_createFloatTextureBuffer",
					value: function(e, r) {
						var n = new t.Texture2D(e, r, t.TextureFormat.R32G32B32A32, !1, !1);
						return n.filterMode = t.FilterMode.Point, n.wrapModeU = t.WarpMode.Clamp, n
							.wrapModeV = t.WarpMode.Clamp, n.anisoLevel = 0, n
					}
				}, {
					key: "_convertToLayaVec3",
					value: function(e, t, r) {
						var n = l.Physics3D._bullet;
						t.x = r ? -n.btVector3_x(e) : n.btVector3_x(e), t.y = n.btVector3_y(e), t.z = n
							.btVector3_z(e)
					}
				}, {
					key: "_convertToBulletVec3",
					value: function(e, t, r) {
						l.Physics3D._bullet.btVector3_setValue(t, r ? -e.x : e.x, e.y, e.z)
					}
				}, {
					key: "_rotationTransformScaleSkinAnimation",
					value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
						var _, d, f, m, p, T = Utils3D._tempArray16_0,
							E = Utils3D._tempArray16_1,
							g = Utils3D._tempArray16_2,
							y = n + n,
							S = i + i,
							v = a + a,
							R = n * y,
							C = i * y,
							M = i * S,
							D = a * y,
							x = a * S,
							A = a * v,
							I = o * y,
							L = o * S,
							P = o * v;
						for (T[15] = 1, T[0] = 1 - M - A, T[1] = C + P, T[2] = D - L, T[4] = C - P, T[
							5] = 1 - R - A, T[6] = x + I, T[8] = D + L, T[9] = x - I, T[10] = 1 - R - M,
							E[15] = 1, E[0] = s, E[5] = l, E[10] = u, _ = 0; _ < 4; _++) d = T[_], f =
							T[_ + 4], m = T[_ + 8], p = T[_ + 12], g[_] = d, g[_ + 4] = f, g[_ + 8] = m,
							g[_ + 12] = d * e + f * t + m * r + p;
						for (_ = 0; _ < 4; _++) d = g[_], f = g[_ + 4], m = g[_ + 8], p = g[_ + 12], c[
								_ + h] = d * E[0] + f * E[1] + m * E[2] + p * E[3], c[_ + h + 4] = d *
							E[4] + f * E[5] + m * E[6] + p * E[7], c[_ + h + 8] = d * E[8] + f * E[9] +
							m * E[10] + p * E[11], c[_ + h + 12] = d * E[12] + f * E[13] + m * E[14] +
							p * E[15]
					}
				}, {
					key: "_computeBoneAndAnimationDatasByBindPoseMatrxix",
					value: function(e, t, r, n, i, a) {
						var o, s, l = 0,
							u = 0,
							c = e.length;
						for (o = 0; o < c; l += e[o].keyframeWidth, u += 16, o++) Utils3D
							._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l +
								3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], n, u),
							0 != o && (s = 16 * e[o].parentIndex, Utils3D.mulMatrixByArray(n, s, n, u,
								n, u));
						var h = r.length;
						for (o = 0; o < h; o++) Utils3D.mulMatrixByArrayAndMatrixFast(n, 16 * a[o], r[
							o], i, 16 * o)
					}
				}, {
					key: "_computeAnimationDatasByArrayAndMatrixFast",
					value: function(e, t, r, n) {
						for (var i = 0, a = e.length; i < a; i++) Utils3D.mulMatrixByArrayAndMatrixFast(
							t, 16 * n[i], e[i], r, 16 * i)
					}
				}, {
					key: "_computeBoneAndAnimationDatasByBindPoseMatrxixOld",
					value: function(e, t, r, n, i) {
						var a, o, s = 0,
							l = 0,
							u = e.length;
						for (a = 0; a < u; s += e[a].keyframeWidth, l += 16, a++) Utils3D
							._rotationTransformScaleSkinAnimation(t[s + 7], t[s + 8], t[s + 9], t[s +
								3], t[s + 4], t[s + 5], t[s + 6], t[s + 0], t[s + 1], t[s + 2], n, l),
							0 != a && (o = 16 * e[a].parentIndex, Utils3D.mulMatrixByArray(n, o, n, l,
								n, l));
						var c = r.length;
						for (a = 0; a < c; a++) {
							var h = 16 * a;
							Utils3D.mulMatrixByArrayAndMatrixFast(n, h, r[a], i, h)
						}
					}
				}, {
					key: "_computeAnimationDatasByArrayAndMatrixFastOld",
					value: function(e, t, r) {
						for (var n = e.length, i = 0; i < n; i++) {
							var a = 16 * i;
							Utils3D.mulMatrixByArrayAndMatrixFast(t, a, e[i], r, a)
						}
					}
				}, {
					key: "_computeRootAnimationData",
					value: function(e, t, r) {
						for (var n = 0, i = 0, a = 0, o = e.length; n < o; i += e[n].keyframeWidth, a +=
							16, n++) Utils3D.createAffineTransformationArray(t[i + 0], t[i + 1], t[i +
							2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i + 8], t[
							i + 9], r, a)
					}
				}, {
					key: "transformVector3ArrayByQuat",
					value: function(e, t, r, n, i) {
						var a = e[t],
							o = e[t + 1],
							s = e[t + 2],
							l = r.x,
							u = r.y,
							c = r.z,
							h = r.w,
							_ = h * a + u * s - c * o,
							d = h * o + c * a - l * s,
							f = h * s + l * o - u * a,
							m = -l * a - u * o - c * s;
						n[i] = _ * h + m * -l + d * -c - f * -u, n[i + 1] = d * h + m * -u + f * -l -
							_ * -c, n[i + 2] = f * h + m * -c + _ * -u - d * -l
					}
				}, {
					key: "mulMatrixByArray",
					value: function(e, t, r, n, i, a) {
						var o, s, l, u, c;
						if (i === r) {
							for (r = Utils3D._tempArray16_3, o = 0; o < 16; ++o) r[o] = i[a + o];
							n = 0
						}
						for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[
								t + o + 12], i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c *
							r[n + 3], i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[
								n + 7], i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c *
							r[n + 11], i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] +
							c * r[n + 15]
					}
				}, {
					key: "mulMatrixByArrayFast",
					value: function(e, t, r, n, i, a) {
						var o, s, l, u, c;
						for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[
								t + o + 12], i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c *
							r[n + 3], i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[
								n + 7], i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c *
							r[n + 11], i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] +
							c * r[n + 15]
					}
				}, {
					key: "mulMatrixByArrayAndMatrixFast",
					value: function(e, t, r, n, i) {
						var a, o, s, l, u, c = r.elements,
							h = c[0],
							_ = c[1],
							d = c[2],
							f = c[3],
							m = c[4],
							p = c[5],
							T = c[6],
							E = c[7],
							g = c[8],
							y = c[9],
							S = c[10],
							v = c[11],
							R = c[12],
							C = c[13],
							M = c[14],
							D = c[15],
							x = t,
							A = t + 4,
							I = t + 8,
							L = t + 12,
							P = i,
							O = i + 4,
							N = i + 8,
							b = i + 12;
						for (a = 0; a < 4; a++) o = e[x + a], s = e[A + a], l = e[I + a], u = e[L + a],
							n[P + a] = o * h + s * _ + l * d + u * f, n[O + a] = o * m + s * p + l * T +
							u * E, n[N + a] = o * g + s * y + l * S + u * v, n[b + a] = o * R + s * C +
							l * M + u * D
					}
				}, {
					key: "createAffineTransformationArray",
					value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
						var _ = n + n,
							d = i + i,
							f = a + a,
							m = n * _,
							p = n * d,
							T = n * f,
							E = i * d,
							g = i * f,
							y = a * f,
							S = o * _,
							v = o * d,
							R = o * f;
						c[h + 0] = (1 - (E + y)) * s, c[h + 1] = (p + R) * s, c[h + 2] = (T - v) * s, c[
							h + 3] = 0, c[h + 4] = (p - R) * l, c[h + 5] = (1 - (m + y)) * l, c[h +
							6] = (g + S) * l, c[h + 7] = 0, c[h + 8] = (T + v) * u, c[h + 9] = (g -
							S) * u, c[h + 10] = (1 - (m + E)) * u, c[h + 11] = 0, c[h + 12] = e, c[
							h + 13] = t, c[h + 14] = r, c[h + 15] = 1
					}
				}, {
					key: "transformVector3ArrayToVector3ArrayCoordinate",
					value: function(e, t, r, n, i) {
						var a = e[t + 0],
							o = e[t + 1],
							s = e[t + 2],
							l = r.elements,
							u = a * l[3] + o * l[7] + s * l[11] + l[15];
						n[i] = a * l[0] + o * l[4] + s * l[8] + l[12] / u, n[i + 1] = a * l[1] + o * l[
								5] + s * l[9] + l[13] / u, n[i + 2] = a * l[2] + o * l[6] + s * l[10] +
							l[14] / u
					}
				}, {
					key: "transformVector3ArrayToVector3ArrayNormal",
					value: function(e, t, r, n, i) {
						var a = e[t + 0],
							o = e[t + 1],
							s = e[t + 2],
							l = r.elements;
						n[i] = a * l[0] + o * l[4] + s * l[8], n[i + 1] = a * l[1] + o * l[5] + s * l[
							9], n[i + 2] = a * l[2] + o * l[6] + s * l[10]
					}
				}, {
					key: "transformLightingMapTexcoordArray",
					value: function(e, t, r, n, i) {
						n[i + 0] = e[t + 0] * r.x + r.z, n[i + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w)
					}
				}, {
					key: "getURLVerion",
					value: function(e) {
						var t = e.indexOf("?");
						return t >= 0 ? e.substr(t) : null
					}
				}, {
					key: "_createAffineTransformationArray",
					value: function(e, t, r, n) {
						var i = t.x,
							a = t.y,
							o = t.z,
							s = t.w,
							l = i + i,
							u = a + a,
							c = o + o,
							h = i * l,
							_ = i * u,
							d = i * c,
							f = a * u,
							m = a * c,
							p = o * c,
							T = s * l,
							E = s * u,
							g = s * c,
							y = r.x,
							S = r.y,
							v = r.z;
						n[0] = (1 - (f + p)) * y, n[1] = (_ + g) * y, n[2] = (d - E) * y, n[3] = 0, n[
							4] = (_ - g) * S, n[5] = (1 - (h + p)) * S, n[6] = (m + T) * S, n[7] = 0, n[
								8] = (d + E) * v, n[9] = (m - T) * v, n[10] = (1 - (h + f)) * v, n[11] =
							0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1
					}
				}, {
					key: "_mulMatrixArray",
					value: function(e, t, r, n, i) {
						var a = t,
							o = e,
							s = n,
							l = a[r],
							u = a[r + 1],
							c = a[r + 2],
							h = a[r + 3],
							_ = a[r + 4],
							d = a[r + 5],
							f = a[r + 6],
							m = a[r + 7],
							p = a[r + 8],
							T = a[r + 9],
							E = a[r + 10],
							g = a[r + 11],
							y = a[r + 12],
							S = a[r + 13],
							v = a[r + 14],
							R = a[r + 15],
							C = o[0],
							M = o[1],
							D = o[2],
							x = o[3],
							A = o[4],
							I = o[5],
							L = o[6],
							P = o[7],
							O = o[8],
							N = o[9],
							b = o[10],
							k = o[11],
							w = o[12],
							B = o[13],
							V = o[14],
							F = o[15];
						s[i] = l * C + u * A + c * O + h * w, s[i + 1] = l * M + u * I + c * N + h * B,
							s[i + 2] = l * D + u * L + c * b + h * V, s[i + 3] = l * x + u * P + c * k +
							h * F, s[i + 4] = _ * C + d * A + f * O + m * w, s[i + 5] = _ * M + d * I +
							f * N + m * B, s[i + 6] = _ * D + d * L + f * b + m * V, s[i + 7] = _ * x +
							d * P + f * k + m * F, s[i + 8] = p * C + T * A + E * O + g * w, s[i + 9] =
							p * M + T * I + E * N + g * B, s[i + 10] = p * D + T * L + E * b + g * V, s[
								i + 11] = p * x + T * P + E * k + g * F, s[i + 12] = y * C + S * A + v *
							O + R * w, s[i + 13] = y * M + S * I + v * N + R * B, s[i + 14] = y * D +
							S * L + v * b + R * V, s[i + 15] = y * x + S * P + v * k + R * F
					}
				}, {
					key: "arcTanAngle",
					value: function(e, t) {
						return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) :
							e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0
					}
				}, {
					key: "angleTo",
					value: function(e, t, r) {
						o.subtract(t, e, u.TEMPVector30), o.normalize(u.TEMPVector30, u.TEMPVector30), r
							.x = Math.asin(u.TEMPVector30.y), r.y = Utils3D.arcTanAngle(-u.TEMPVector30
								.z, -u.TEMPVector30.x)
					}
				}, {
					key: "transformQuat",
					value: function(e, t, r) {
						var n = t,
							i = e.x,
							a = e.y,
							o = e.z,
							s = n[0],
							l = n[1],
							u = n[2],
							c = n[3],
							h = c * i + l * o - u * a,
							_ = c * a + u * i - s * o,
							d = c * o + s * a - l * i,
							f = -s * i - l * a - u * o;
						r.x = h * c + f * -s + _ * -u - d * -l, r.y = _ * c + f * -l + d * -s - h * -u,
							r.z = d * c + f * -u + h * -l - _ * -s
					}
				}, {
					key: "quaternionWeight",
					value: function(e, t, r) {
						r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w
					}
				}, {
					key: "quaternionConjugate",
					value: function(e, t) {
						t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w
					}
				}, {
					key: "scaleWeight",
					value: function(e, t, r) {
						var n = e.x,
							i = e.y,
							a = e.z;
						r.x = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t), r.y = i >
							0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), r.z = a > 0 ? Math
							.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t)
					}
				}, {
					key: "scaleBlend",
					value: function(e, t, r, n) {
						var i = Utils3D._tempVector3_0,
							a = Utils3D._tempVector3_1;
						Utils3D.scaleWeight(e, 1 - r, i), Utils3D.scaleWeight(t, r, a);
						var o = r > .5 ? t : e;
						n.x = o.x > 0 ? Math.abs(i.x * a.x) : -Math.abs(i.x * a.x), n.y = o.y > 0 ? Math
							.abs(i.y * a.y) : -Math.abs(i.y * a.y), n.z = o.z > 0 ? Math.abs(i.z * a
							.z) : -Math.abs(i.z * a.z)
					}
				}, {
					key: "matrix4x4MultiplyFFF",
					value: function(e, t, r) {
						var n, i, a, o, s;
						if (r === t)
							for (t = new Float32Array(16), n = 0; n < 16; ++n) t[n] = r[n];
						var l = t[0],
							u = t[1],
							c = t[2],
							h = t[3],
							_ = t[4],
							d = t[5],
							f = t[6],
							m = t[7],
							p = t[8],
							T = t[9],
							E = t[10],
							g = t[11],
							y = t[12],
							S = t[13],
							v = t[14],
							R = t[15];
						for (n = 0; n < 4; n++) i = e[n], a = e[n + 4], o = e[n + 8], s = e[n + 12], r[
								n] = i * l + a * u + o * c + s * h, r[n + 4] = i * _ + a * d + o * f +
							s * m, r[n + 8] = i * p + a * T + o * E + s * g, r[n + 12] = i * y + a * S +
							o * v + s * R
					}
				}, {
					key: "matrix4x4MultiplyFFFForNative",
					value: function(e, r, n) {
						t.LayaGL.instance.matrix4x4Multiply(e, r, n)
					}
				}, {
					key: "matrix4x4MultiplyMFM",
					value: function(e, t, r) {
						Utils3D.matrix4x4MultiplyFFF(e.elements, t, r.elements)
					}
				}, {
					key: "_buildTexture2D",
					value: function(e, r, n, i) {
						var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
							o = new t.Texture2D(e, r, n, a, !0);
						return o.anisoLevel = 1, o.filterMode = t.FilterMode.Point, L
							._generateTexture2D(o, e, r, i), o
					}
				}, {
					key: "_drawBound",
					value: function(e, t, r) {
						e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
						var n = Utils3D._tempVector3_0,
							i = Utils3D._tempVector3_1,
							a = t.min,
							o = t.max;
						n.setValue(a.x, a.y, a.z), i.setValue(o.x, a.y, a.z), e.addLine(n, i, r, r), n
							.setValue(a.x, a.y, a.z), i.setValue(a.x, a.y, o.z), e.addLine(n, i, r, r),
							n.setValue(o.x, a.y, a.z), i.setValue(o.x, a.y, o.z), e.addLine(n, i, r, r),
							n.setValue(a.x, a.y, o.z), i.setValue(o.x, a.y, o.z), e.addLine(n, i, r, r),
							n.setValue(a.x, a.y, a.z), i.setValue(a.x, o.y, a.z), e.addLine(n, i, r, r),
							n.setValue(a.x, a.y, o.z), i.setValue(a.x, o.y, o.z), e.addLine(n, i, r, r),
							n.setValue(o.x, a.y, a.z), i.setValue(o.x, o.y, a.z), e.addLine(n, i, r, r),
							n.setValue(o.x, a.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(n, i, r, r),
							n.setValue(a.x, o.y, a.z), i.setValue(o.x, o.y, a.z), e.addLine(n, i, r, r),
							n.setValue(a.x, o.y, a.z), i.setValue(a.x, o.y, o.z), e.addLine(n, i, r, r),
							n.setValue(o.x, o.y, a.z), i.setValue(o.x, o.y, o.z), e.addLine(n, i, r, r),
							n.setValue(a.x, o.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(n, i, r, r)
					}
				}, {
					key: "_getHierarchyPath",
					value: function(e, t, r) {
						r.length = 0;
						for (var n = t; n !== e;) {
							var i = n._parent;
							if (!i) return null;
							r.push(i.getChildIndex(n)), n = i
						}
						return r
					}
				}, {
					key: "_getNodeByHierarchyPath",
					value: function(e, t) {
						for (var r = e, n = t.length - 1; n >= 0; n--) r = r.getChildAt(t[n]);
						return r
					}
				}]), Utils3D
			}();
		P._tempVector3_0 = new o, P._tempVector3_1 = new o, P._tempArray16_0 = new Float32Array(16), P._tempArray16_1 =
			new Float32Array(16), P._tempArray16_2 = new Float32Array(16), P._tempArray16_3 = new Float32Array(16), P
			._compIdToNode = new Object;
		var O = function(e) {
			function CharacterController() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1,
					r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : m
					.COLLISIONFILTERGROUP_DEFAULTFILTER,
					i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : m
					.COLLISIONFILTERGROUP_ALLFILTER;
				return _classCallCheck(this, CharacterController), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(CharacterController).call(this, n, i)))._upAxis = new o(0, 1, 0), e
					._maxSlope = 45, e._jumpSpeed = 10, e._fallSpeed = 55, e._gravity = new o(0, 3 * -9.8, 0), e
					._btKinematicCharacter = null, e._stepHeight = t, r && (e._upAxis = r), e
					._controlBySimulation = !0, e
			}
			return _inherits(CharacterController, e), _createClass(CharacterController, [{
				key: "_constructCharacter",
				value: function() {
					var e = l.Physics3D._bullet;
					this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this
						._btKinematicCharacter);
					var t = CharacterController._btTempVector30;
					e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z), this
						._btKinematicCharacter = e.btKinematicCharacterController_create(this
							._btColliderObject, this._colliderShape._btShape, this._stepHeight, t),
						this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this
						.jumpSpeed = this._jumpSpeed, this.gravity = this._gravity
				}
			}, {
				key: "_onShapeChange",
				value: function(e) {
					_get(_getPrototypeOf(CharacterController.prototype), "_onShapeChange", this)
						.call(this, e), this._constructCharacter()
				}
			}, {
				key: "_onAdded",
				value: function() {
					var e = l.Physics3D._bullet,
						t = e.btPairCachingGhostObject_create();
					e.btCollisionObject_setUserIndex(t, this.id), e
						.btCollisionObject_setCollisionFlags(t, v.COLLISIONFLAGS_CHARACTER_OBJECT),
						this._btColliderObject = t, this._colliderShape && this
						._constructCharacter(), _get(_getPrototypeOf(CharacterController.prototype),
							"_onAdded", this).call(this)
				}
			}, {
				key: "_addToSimulation",
				value: function() {
					this._simulation._characters.push(this), this._simulation._addCharacter(this,
						this._collisionGroup, this._canCollideWith)
				}
			}, {
				key: "_removeFromSimulation",
				value: function() {
					this._simulation._removeCharacter(this);
					var e = this._simulation._characters;
					e.splice(e.indexOf(this), 1)
				}
			}, {
				key: "_cloneTo",
				value: function(e) {
					_get(_getPrototypeOf(CharacterController.prototype), "_cloneTo", this).call(
						this, e);
					var t = e;
					t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this
						._maxSlope, t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t
						.gravity = this._gravity
				}
			}, {
				key: "_onDestroy",
				value: function() {
					l.Physics3D._bullet.btKinematicCharacterController_destroy(this
							._btKinematicCharacter), _get(_getPrototypeOf(CharacterController
							.prototype), "_onDestroy", this).call(this), this
						._btKinematicCharacter = null
				}
			}, {
				key: "move",
				value: function(e) {
					var t = CharacterController._btVector30,
						r = l.Physics3D._bullet;
					r.btVector3_setValue(t, -e.x, e.y, e.z), r
						.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter,
							t)
				}
			}, {
				key: "jump",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = l.Physics3D._bullet,
						r = CharacterController._btVector30;
					e ? (P._convertToBulletVec3(e, r, !0), t.btKinematicCharacterController_jump(
						this._btKinematicCharacter, r)) : (t.btVector3_setValue(r, 0, 0, 0), t
						.btKinematicCharacterController_jump(this._btKinematicCharacter, r))
				}
			}, {
				key: "fallSpeed",
				get: function() {
					return this._fallSpeed
				},
				set: function(e) {
					this._fallSpeed = e, l.Physics3D._bullet
						.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e)
				}
			}, {
				key: "jumpSpeed",
				get: function() {
					return this._jumpSpeed
				},
				set: function(e) {
					this._jumpSpeed = e, l.Physics3D._bullet
						.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e)
				}
			}, {
				key: "gravity",
				get: function() {
					return this._gravity
				},
				set: function(e) {
					this._gravity = e;
					var t = l.Physics3D._bullet,
						r = CharacterController._btTempVector30;
					t.btVector3_setValue(r, -e.x, e.y, e.z), t
						.btKinematicCharacterController_setGravity(this._btKinematicCharacter, r)
				}
			}, {
				key: "maxSlope",
				get: function() {
					return this._maxSlope
				},
				set: function(e) {
					this._maxSlope = e, l.Physics3D._bullet
						.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e /
							180 * Math.PI)
				}
			}, {
				key: "isGrounded",
				get: function() {
					return l.Physics3D._bullet.btKinematicCharacterController_onGround(this
						._btKinematicCharacter)
				}
			}, {
				key: "stepHeight",
				get: function() {
					return this._stepHeight
				},
				set: function(e) {
					this._stepHeight = e, l.Physics3D._bullet
						.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e)
				}
			}, {
				key: "upAxis",
				get: function() {
					return this._upAxis
				},
				set: function(e) {
					this._upAxis = e;
					var t = CharacterController._btTempVector30;
					P._convertToBulletVec3(e, t, !1), l.Physics3D._bullet
						.btKinematicCharacterController_setUp(this._btKinematicCharacter, t)
				}
			}], [{
				key: "__init__",
				value: function() {
					CharacterController._btTempVector30 = l.Physics3D._bullet.btVector3_create(0, 0,
						0)
				}
			}]), CharacterController
		}(v);
		O.UPAXIS_X = 0, O.UPAXIS_Y = 1, O.UPAXIS_Z = 2;
		var N = function(e) {
				function PhysicsTriggerComponent(e, t) {
					var r;
					return _classCallCheck(this, PhysicsTriggerComponent), (r = _possibleConstructorReturn(this,
						_getPrototypeOf(PhysicsTriggerComponent).call(this, e, t)))._isTrigger = !1, r
				}
				return _inherits(PhysicsTriggerComponent, e), _createClass(PhysicsTriggerComponent, [{
					key: "_onAdded",
					value: function() {
						_get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_onAdded", this).call(
							this), this.isTrigger = this._isTrigger
					}
				}, {
					key: "_cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_cloneTo", this).call(
							this, e), e.isTrigger = this._isTrigger
					}
				}, {
					key: "isTrigger",
					get: function() {
						return this._isTrigger
					},
					set: function(e) {
						this._isTrigger = e;
						var t = l.Physics3D._bullet;
						if (this._btColliderObject) {
							var r = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
							e ? 0 == (r & v.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t
								.btCollisionObject_setCollisionFlags(this._btColliderObject, r | v
									.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (r & v
									.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t
								.btCollisionObject_setCollisionFlags(this._btColliderObject, r ^ v
									.COLLISIONFLAGS_NO_CONTACT_RESPONSE)
						}
					}
				}]), PhysicsTriggerComponent
			}(v),
			b = function(e) {
				function Rigidbody3D() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m
						.COLLISIONFILTERGROUP_DEFAULTFILTER,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m
						.COLLISIONFILTERGROUP_ALLFILTER;
					return _classCallCheck(this, Rigidbody3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							Rigidbody3D).call(this, t, r)))._isKinematic = !1, e._mass = 1, e._gravity = new o(0, -10,
							0), e._angularDamping = 0, e._linearDamping = 0, e._overrideGravity = !1, e._totalTorque =
						new o(0, 0, 0), e._totalForce = new o(0, 0, 0), e._linearVelocity = new o, e._angularVelocity =
						new o, e._linearFactor = new o(1, 1, 1), e._angularFactor = new o(1, 1, 1), e
						._detectCollisions = !0, e._controlBySimulation = !0, e
				}
				return _inherits(Rigidbody3D, e), _createClass(Rigidbody3D, [{
					key: "_updateMass",
					value: function(e) {
						if (this._btColliderObject && this._colliderShape) {
							var t = l.Physics3D._bullet;
							t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e,
									Rigidbody3D._btInertia), t.btRigidBody_setMassProps(this
									._btColliderObject, e, Rigidbody3D._btInertia), t
								.btRigidBody_updateInertiaTensor(this._btColliderObject)
						}
					}
				}, {
					key: "_onScaleChange",
					value: function(e) {
						_get(_getPrototypeOf(Rigidbody3D.prototype), "_onScaleChange", this).call(this,
							e), this._updateMass(this._isKinematic ? 0 : this._mass)
					}
				}, {
					key: "_derivePhysicsTransformation",
					value: function(e) {
						var t = l.Physics3D._bullet,
							r = this._btColliderObject,
							n = t.btCollisionObject_getWorldTransform(r),
							i = Rigidbody3D._btTransform0;
						t.btTransform_equal(i, n), this._innerDerivePhysicsTransformation(i, e), t
							.btRigidBody_setCenterOfMassTransform(r, i)
					}
				}, {
					key: "_onAdded",
					value: function() {
						var e = l.Physics3D._bullet,
							t = e.layaMotionState_create();
						e.layaMotionState_set_rigidBodyID(t, this._id), this._btLayaMotionState = t;
						var r = e.btRigidBodyConstructionInfo_create(0, t, null, Rigidbody3D
								._btVector3Zero),
							n = e.btRigidBody_create(r);
						e.btCollisionObject_setUserIndex(n, this.id), this._btColliderObject = n, _get(
								_getPrototypeOf(Rigidbody3D.prototype), "_onAdded", this).call(this),
							this.mass = this._mass, this.linearFactor = this._linearFactor, this
							.angularFactor = this._angularFactor, this.linearDamping = this
							._linearDamping, this.angularDamping = this._angularDamping, this
							.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this
							.isKinematic = this._isKinematic, e.btRigidBodyConstructionInfo_destroy(r)
					}
				}, {
					key: "_onEnable",
					value: function() {
						_get(_getPrototypeOf(Rigidbody3D.prototype), "_onEnable", this).call(this), this
							._constaintRigidbodyA && this._constaintRigidbodyA.connectedBody
							._simulation && (this._constaintRigidbodyA._createConstraint(), this
								._constaintRigidbodyA._onEnable()), this._constaintRigidbodyB && this
							._constaintRigidbodyB.ownBody._simulation && (this._constaintRigidbodyB
								._createConstraint(), this._constaintRigidbodyB._onEnable())
					}
				}, {
					key: "_onShapeChange",
					value: function(e) {
						if (_get(_getPrototypeOf(Rigidbody3D.prototype), "_onShapeChange", this).call(
								this, e), this._isKinematic) this._updateMass(0);
						else {
							var t = l.Physics3D._bullet;
							t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t
									.btCollisionObject_getWorldTransform(this._btColliderObject)), this
								._updateMass(this._mass)
						}
					}
				}, {
					key: "_parse",
					value: function(e) {
						if (null != e.friction && (this.friction = e.friction), null != e
							.rollingFriction && (this.rollingFriction = e.rollingFriction), null != e
							.restitution && (this.restitution = e.restitution), null != e.isTrigger && (
								this.isTrigger = e.isTrigger), null != e.mass && (this.mass = e.mass),
							null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e
							.angularDamping && (this.angularDamping = e.angularDamping), null != e
							.overrideGravity && (this.overrideGravity = e.overrideGravity), null != e
							.linearFactor) {
							var t = this.linearFactor;
							t.fromArray(e.linearFactor), this.linearFactor = t
						}
						if (null != e.angularFactor) {
							var r = this.angularFactor;
							r.fromArray(e.angularFactor), this.angularFactor = r
						}
						e.gravity && (this.gravity.fromArray(e.gravity), this.gravity = this.gravity),
							_get(_getPrototypeOf(Rigidbody3D.prototype), "_parse", this).call(this, e),
							this._parseShape(e.shapes), null != e.isKinematic && (this.isKinematic = e
								.isKinematic)
					}
				}, {
					key: "_onDestroy",
					value: function() {
						l.Physics3D._bullet.btMotionState_destroy(this._btLayaMotionState), _get(
								_getPrototypeOf(Rigidbody3D.prototype), "_onDestroy", this).call(this),
							this._btLayaMotionState = null, this._gravity = null, this._totalTorque =
							null, this._linearVelocity = null, this._angularVelocity = null, this
							._linearFactor = null, this._angularFactor = null, this
							.constaintRigidbodyA && this.constaintRigidbodyA._breakConstrained(), this
							.constaintRigidbodyB && (this.constaintRigidbodyB.connectedBody = null, this
								.constaintRigidbodyB._onDisable())
					}
				}, {
					key: "_addToSimulation",
					value: function() {
						this._simulation._addRigidBody(this, this._collisionGroup, this
							._detectCollisions ? this._canCollideWith : 0)
					}
				}, {
					key: "_removeFromSimulation",
					value: function() {
						this._simulation._removeRigidBody(this)
					}
				}, {
					key: "_cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(Rigidbody3D.prototype), "_cloneTo", this).call(this, e);
						var t = e;
						t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this
							._gravity, t.angularDamping = this._angularDamping, t.linearDamping = this
							._linearDamping, t.overrideGravity = this._overrideGravity, t
							.linearVelocity = this._linearVelocity, t.angularVelocity = this
							._angularVelocity, t.linearFactor = this._linearFactor, t.angularFactor =
							this._angularFactor, t.detectCollisions = this._detectCollisions
					}
				}, {
					key: "applyForce",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						if (null == this._btColliderObject)
						throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
						var r = l.Physics3D._bullet,
							n = Rigidbody3D._btTempVector30;
						if (r.btVector3_setValue(n, -e.x, e.y, e.z), t) {
							var i = Rigidbody3D._btTempVector31;
							r.btVector3_setValue(i, -t.x, t.y, t.z), r.btRigidBody_applyForce(this
								._btColliderObject, n, i)
						} else r.btRigidBody_applyCentralForce(this._btColliderObject, n)
					}
				}, {
					key: "applyTorque",
					value: function(e) {
						if (null == this._btColliderObject)
						throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
						var t = l.Physics3D._bullet,
							r = Rigidbody3D._btTempVector30;
						t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorque(this
							._btColliderObject, r)
					}
				}, {
					key: "applyImpulse",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						if (null == this._btColliderObject)
						throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
						var r = l.Physics3D._bullet;
						r.btVector3_setValue(Rigidbody3D._btImpulse, -e.x, e.y, e.z), t ? (r
								.btVector3_setValue(Rigidbody3D._btImpulseOffset, -t.x, t.y, t.z), r
								.btRigidBody_applyImpulse(this._btColliderObject, Rigidbody3D
									._btImpulse, Rigidbody3D._btImpulseOffset)) : r
							.btRigidBody_applyCentralImpulse(this._btColliderObject, Rigidbody3D
								._btImpulse)
					}
				}, {
					key: "applyTorqueImpulse",
					value: function(e) {
						if (null == this._btColliderObject)
						throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
						var t = l.Physics3D._bullet,
							r = Rigidbody3D._btTempVector30;
						t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorqueImpulse(this
							._btColliderObject, r)
					}
				}, {
					key: "wakeUp",
					value: function() {
						this._btColliderObject && l.Physics3D._bullet.btCollisionObject_activate(this
							._btColliderObject, !1)
					}
				}, {
					key: "clearForces",
					value: function() {
						var e = this._btColliderObject;
						if (null == e)
						throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
						var t = l.Physics3D._bullet;
						t.btRigidBody_clearForces(e);
						var r = Rigidbody3D._btVector3Zero;
						t.btCollisionObject_setInterpolationLinearVelocity(e, r), t
							.btRigidBody_setLinearVelocity(e, r), t
							.btCollisionObject_setInterpolationAngularVelocity(e, r), t
							.btRigidBody_setAngularVelocity(e, r)
					}
				}, {
					key: "mass",
					get: function() {
						return this._mass
					},
					set: function(e) {
						e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e)
					}
				}, {
					key: "isKinematic",
					get: function() {
						return this._isKinematic
					},
					set: function(e) {
						this._isKinematic = e, this._controlBySimulation = !e;
						var t = l.Physics3D._bullet,
							r = !!(this._simulation && this._enabled && this._colliderShape);
						r && this._removeFromSimulation();
						var n = this._btColliderObject,
							i = t.btCollisionObject_getCollisionFlags(n);
						e ? (i |= v.COLLISIONFLAGS_KINEMATIC_OBJECT, t
							.btCollisionObject_setCollisionFlags(n, i), t
							.btCollisionObject_forceActivationState(this._btColliderObject, v
								.ACTIVATIONSTATE_DISABLE_DEACTIVATION), this
							._enableProcessCollisions = !1, this._updateMass(0)) : ((i & v
								.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (i ^= v
								.COLLISIONFLAGS_KINEMATIC_OBJECT), t
							.btCollisionObject_setCollisionFlags(n, i), t
							.btCollisionObject_setActivationState(this._btColliderObject, v
								.ACTIVATIONSTATE_ACTIVE_TAG), this._enableProcessCollisions = !0,
							this._updateMass(this._mass));
						var a = Rigidbody3D._btVector3Zero;
						t.btCollisionObject_setInterpolationLinearVelocity(n, a), t
							.btRigidBody_setLinearVelocity(n, a), t
							.btCollisionObject_setInterpolationAngularVelocity(n, a), t
							.btRigidBody_setAngularVelocity(n, a), r && this._addToSimulation()
					}
				}, {
					key: "linearDamping",
					get: function() {
						return this._linearDamping
					},
					set: function(e) {
						this._linearDamping = e, this._btColliderObject && l.Physics3D._bullet
							.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping)
					}
				}, {
					key: "angularDamping",
					get: function() {
						return this._angularDamping
					},
					set: function(e) {
						this._angularDamping = e, this._btColliderObject && l.Physics3D._bullet
							.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e)
					}
				}, {
					key: "overrideGravity",
					get: function() {
						return this._overrideGravity
					},
					set: function(e) {
						this._overrideGravity = e;
						var t = l.Physics3D._bullet;
						if (this._btColliderObject) {
							var r = t.btRigidBody_getFlags(this._btColliderObject);
							e ? 0 == (r & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) && t
								.btRigidBody_setFlags(this._btColliderObject, r | Rigidbody3D
									._BT_DISABLE_WORLD_GRAVITY) : (r & Rigidbody3D
									._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this
									._btColliderObject, r ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY)
						}
					}
				}, {
					key: "gravity",
					get: function() {
						var e = l.Physics3D._bullet;
						return Rigidbody3D._btGravity = e.btRigidBody_getGravity(this
							._btColliderObject), P._convertToLayaVec3(Rigidbody3D._btGravity, this
								._gravity, !0), this._gravity
					},
					set: function(e) {
						this._gravity = e;
						var t = l.Physics3D._bullet;
						t.btVector3_setValue(Rigidbody3D._btGravity, -e.x, e.y, e.z), t
							.btRigidBody_setGravity(this._btColliderObject, Rigidbody3D._btGravity)
					}
				}, {
					key: "totalForce",
					get: function() {
						if (this._btColliderObject) {
							var e = l.Physics3D._bullet.btRigidBody_getTotalForce(this
								._btColliderObject);
							return P._convertToLayaVec3(e, this._totalForce, !0), this._totalForce
						}
						return null
					}
				}, {
					key: "linearFactor",
					get: function() {
						return this._linearFactor
					},
					set: function(e) {
						this._linearFactor = e;
						var t = Rigidbody3D._btTempVector30;
						P._convertToBulletVec3(e, t, !1), l.Physics3D._bullet
							.btRigidBody_setLinearFactor(this._btColliderObject, t)
					}
				}, {
					key: "linearVelocity",
					get: function() {
						return this._btColliderObject && P._convertToLayaVec3(l.Physics3D._bullet
							.btRigidBody_getLinearVelocity(this._btColliderObject), this
							._linearVelocity, !0), this._linearVelocity
					},
					set: function(e) {
						if (this._linearVelocity = e, this._btColliderObject) {
							var t = Rigidbody3D._btTempVector30;
							P._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), l
								.Physics3D._bullet.btRigidBody_setLinearVelocity(this._btColliderObject,
									t)
						}
					}
				}, {
					key: "angularFactor",
					get: function() {
						return this._angularFactor
					},
					set: function(e) {
						this._angularFactor = e;
						var t = Rigidbody3D._btTempVector30;
						P._convertToBulletVec3(e, t, !1), l.Physics3D._bullet
							.btRigidBody_setAngularFactor(this._btColliderObject, t)
					}
				}, {
					key: "angularVelocity",
					get: function() {
						return this._btColliderObject && P._convertToLayaVec3(l.Physics3D._bullet
							.btRigidBody_getAngularVelocity(this._btColliderObject), this
							._angularVelocity, !0), this._angularVelocity
					},
					set: function(e) {
						if (this._angularVelocity = e, this._btColliderObject) {
							var t = Rigidbody3D._btTempVector30;
							P._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), l
								.Physics3D._bullet.btRigidBody_setAngularVelocity(this
									._btColliderObject, t)
						}
					}
				}, {
					key: "totalTorque",
					get: function() {
						if (this._btColliderObject) {
							var e = l.Physics3D._bullet.btRigidBody_getTotalTorque(this
								._btColliderObject);
							return P._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque
						}
						return null
					}
				}, {
					key: "detectCollisions",
					get: function() {
						return this._detectCollisions
					},
					set: function(e) {
						this._detectCollisions !== e && (this._detectCollisions = e, this
							._colliderShape && this._enabled && this._simulation && (this
								._simulation._removeRigidBody(this), this._simulation._addRigidBody(
									this, this._collisionGroup, e ? this._canCollideWith : 0)))
					}
				}, {
					key: "isSleeping",
					get: function() {
						return !!this._btColliderObject && l.Physics3D._bullet
							.btCollisionObject_getActivationState(this._btColliderObject) === v
							.ACTIVATIONSTATE_ISLAND_SLEEPING
					}
				}, {
					key: "sleepLinearVelocity",
					get: function() {
						return l.Physics3D._bullet.btRigidBody_getLinearSleepingThreshold(this
							._btColliderObject)
					},
					set: function(e) {
						var t = l.Physics3D._bullet;
						t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t
							.btRigidBody_getAngularSleepingThreshold(this._btColliderObject))
					}
				}, {
					key: "sleepAngularVelocity",
					get: function() {
						return l.Physics3D._bullet.btRigidBody_getAngularSleepingThreshold(this
							._btColliderObject)
					},
					set: function(e) {
						var t = l.Physics3D._bullet;
						t.btRigidBody_setSleepingThresholds(this._btColliderObject, t
							.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e)
					}
				}, {
					key: "btColliderObject",
					get: function() {
						return this._btColliderObject
					}
				}, {
					key: "constaintRigidbodyA",
					set: function(e) {
						this._constaintRigidbodyA = e
					},
					get: function() {
						return this._constaintRigidbodyA
					}
				}, {
					key: "constaintRigidbodyB",
					set: function(e) {
						this._constaintRigidbodyB = e
					},
					get: function() {
						return this._constaintRigidbodyB
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = l.Physics3D._bullet;
						Rigidbody3D._btTempVector30 = e.btVector3_create(0, 0, 0), Rigidbody3D
							._btTempVector31 = e.btVector3_create(0, 0, 0), Rigidbody3D._btVector3Zero =
							e.btVector3_create(0, 0, 0), Rigidbody3D._btInertia = e.btVector3_create(0,
								0, 0), Rigidbody3D._btImpulse = e.btVector3_create(0, 0, 0), Rigidbody3D
							._btImpulseOffset = e.btVector3_create(0, 0, 0), Rigidbody3D._btGravity = e
							.btVector3_create(0, 0, 0), Rigidbody3D._btTransform0 = e
							.btTransform_create()
					}
				}]), Rigidbody3D
			}(N);
		b.TYPE_STATIC = 0, b.TYPE_DYNAMIC = 1, b.TYPE_KINEMATIC = 2, b._BT_DISABLE_WORLD_GRAVITY = 1, b
			._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
		var k = function() {
			function Physics3D() {
				_classCallCheck(this, Physics3D)
			}
			return _createClass(Physics3D, null, [{
				key: "__bulletinit__",
				value: function() {
					this._bullet = window.Physics3D, this._bullet && (_.__init__(), h.__init__(), d
						.__init__(), v.__init__(), I.__init__(), p.__init__(), g.__init__(), O
						.__init__(), b.__init__())
				}
			}, {
				key: "__cannoninit__",
				value: function() {
					this._cannon = window.CANNON, this._cannon && (t.CannonColliderShape.__init__(),
						t.CannonPhysicsComponent.__init__(), t.CannonPhysicsSimulation
						.__init__(), t.CannonBoxColliderShape.__init__(), t.CannonRigidbody3D
						.__init__())
				}
			}]), Physics3D
		}();
		k._bullet = null, k._cannon = null, k._enablePhysics = !1;
		var w = function() {
			function Config3D() {
				_classCallCheck(this, Config3D), this._defaultPhysicsMemory = 16, this._maxLightCount = 32, this
					._lightClusterCount = new o(12, 12, 12), this._editerEnvironment = !1, this.isAntialias = !0,
					this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.enableMultiLight = !
					0, this.octreeCulling = !1, this.octreeInitialSize = 64, this.octreeInitialCenter = new o(0, 0,
						0), this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, this.debugFrustumCulling = !1,
					this.pbrRenderQuality = e.PBRRenderQuality.High, this.isUseCannonPhysicsEngine = !1, this
					._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount
						.z - 1), this._maxLightCount)
			}
			return _createClass(Config3D, [{
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment =
						this._editerEnvironment, t.isAntialias = this.isAntialias, t.isAlpha = this
						.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha, t.isStencil = this
						.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter
						.cloneTo(t.octreeInitialCenter), t.octreeInitialSize = this
						.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize, t
						.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this
						.debugFrustumCulling, t.maxLightCount = this.maxLightCount, t
						.enableMultiLight = this.enableMultiLight;
					var r = t.lightClusterCount;
					this.lightClusterCount.cloneTo(r), t.lightClusterCount = r, t.pbrRenderQuality =
						this.pbrRenderQuality
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Config3D;
					return this.cloneTo(e), e
				}
			}, {
				key: "defaultPhysicsMemory",
				get: function() {
					return this._defaultPhysicsMemory
				},
				set: function(e) {
					if (e < 16) throw "defaultPhysicsMemory must large than 16M";
					this._defaultPhysicsMemory = e
				}
			}, {
				key: "maxLightCount",
				get: function() {
					return this._maxLightCount
				},
				set: function(e) {
					e > 2048 ? (this._maxLightCount = 2048, console.warn(
							"Config3D: maxLightCount must less equal 2048.")) : this
						._maxLightCount = e
				}
			}, {
				key: "lightClusterCount",
				get: function() {
					return this._lightClusterCount
				},
				set: function(e) {
					e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math
								.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)), console
							.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e
						.cloneTo(this._lightClusterCount);
					var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
					t < this._maxLightCount && console.warn(
							"Config3D: if the area light(PointLight、SpotLight) count is large than " +
							t + ",maybe the far away culster will ingonre some light."), this
						._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount)
				}
			}], [{
				key: "useCannonPhysics",
				get: function() {
					return Config3D._config.isUseCannonPhysicsEngine
				},
				set: function(e) {
					Config3D._config.isUseCannonPhysicsEngine = e, e && (k.__cannoninit__(), l
						.Scene3D.cannonPhysicsSettings || (l.Scene3D.cannonPhysicsSettings =
							new t.CannonPhysicsSettings))
				}
			}]), Config3D
		}();
		w._config = new w, window.Config3D = w;
		var B = function() {
				function KeyframeNode() {
					_classCallCheck(this, KeyframeNode), this._ownerPath = [], this._propertys = [], this
					._keyFrames = []
				}
				return _createClass(KeyframeNode, [{
					key: "_setOwnerPathCount",
					value: function(e) {
						this._ownerPath.length = e
					}
				}, {
					key: "_setOwnerPathByIndex",
					value: function(e, t) {
						this._ownerPath[e] = t
					}
				}, {
					key: "_joinOwnerPath",
					value: function(e) {
						return this._ownerPath.join(e)
					}
				}, {
					key: "_setPropertyCount",
					value: function(e) {
						this._propertys.length = e
					}
				}, {
					key: "_setPropertyByIndex",
					value: function(e, t) {
						this._propertys[e] = t
					}
				}, {
					key: "_joinProperty",
					value: function(e) {
						return this._propertys.join(e)
					}
				}, {
					key: "_setKeyframeCount",
					value: function(e) {
						this._keyFrames.length = e
					}
				}, {
					key: "_setKeyframeByIndex",
					value: function(e, t) {
						this._keyFrames[e] = t
					}
				}, {
					key: "getOwnerPathByIndex",
					value: function(e) {
						return this._ownerPath[e]
					}
				}, {
					key: "getPropertyByIndex",
					value: function(e) {
						return this._propertys[e]
					}
				}, {
					key: "getKeyframeByIndex",
					value: function(e) {
						return this._keyFrames[e]
					}
				}, {
					key: "ownerPathCount",
					get: function() {
						return this._ownerPath.length
					}
				}, {
					key: "propertyCount",
					get: function() {
						return this._propertys.length
					}
				}, {
					key: "keyFramesCount",
					get: function() {
						return this._keyFrames.length
					}
				}]), KeyframeNode
			}(),
			V = function AnimationEvent() {
				_classCallCheck(this, AnimationEvent)
			},
			F = function() {
				function Keyframe() {
					_classCallCheck(this, Keyframe)
				}
				return _createClass(Keyframe, [{
					key: "cloneTo",
					value: function(e) {
						e.time = this.time
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Keyframe;
						return this.cloneTo(e), e
					}
				}]), Keyframe
			}(),
			U = function(e) {
				function FloatKeyframe() {
					return _classCallCheck(this, FloatKeyframe), _possibleConstructorReturn(this, _getPrototypeOf(
						FloatKeyframe).call(this))
				}
				return _inherits(FloatKeyframe, e), _createClass(FloatKeyframe, [{
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(FloatKeyframe.prototype), "cloneTo", this).call(this, e);
						var t = e;
						t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this
							.value
					}
				}]), FloatKeyframe
			}(F),
			G = function(e) {
				function QuaternionKeyframe() {
					var e;
					return _classCallCheck(this, QuaternionKeyframe), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(QuaternionKeyframe).call(this))).inTangent = new i, e.outTangent = new i, e
						.value = new u, e
				}
				return _inherits(QuaternionKeyframe, e), _createClass(QuaternionKeyframe, [{
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(QuaternionKeyframe.prototype), "cloneTo", this).call(this,
							e);
						var t = e;
						this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this
							.value.cloneTo(t.value)
					}
				}]), QuaternionKeyframe
			}(F),
			H = function(e) {
				function Vector3Keyframe() {
					var e;
					return _classCallCheck(this, Vector3Keyframe), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(Vector3Keyframe).call(this))).inTangent = new o, e.outTangent = new o, e
						.value = new o, e
				}
				return _inherits(Vector3Keyframe, e), _createClass(Vector3Keyframe, [{
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(Vector3Keyframe.prototype), "cloneTo", this).call(this, e);
						var t = e;
						this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this
							.value.cloneTo(t.value)
					}
				}]), Vector3Keyframe
			}(F),
			z = function() {
				function AnimationClipParser03() {
					_classCallCheck(this, AnimationClipParser03)
				}
				return _createClass(AnimationClipParser03, null, [{
					key: "READ_DATA",
					value: function() {
						AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(),
							AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32()
					}
				}, {
					key: "READ_BLOCK",
					value: function() {
						for (var e = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader
								.getUint16(), t = AnimationClipParser03._BLOCK.blockStarts = [], r =
								AnimationClipParser03._BLOCK.blockLengths = [], n = 0; n < e; n++) t
							.push(AnimationClipParser03._reader.getUint32()), r.push(
								AnimationClipParser03._reader.getUint32())
					}
				}, {
					key: "READ_STRINGS",
					value: function() {
						var e = AnimationClipParser03._reader.getUint32(),
							t = AnimationClipParser03._reader.getUint16(),
							r = AnimationClipParser03._reader.pos;
						AnimationClipParser03._reader.pos = e + AnimationClipParser03._DATA.offset;
						for (var n = 0; n < t; n++) AnimationClipParser03._strings[n] =
							AnimationClipParser03._reader.readUTFString();
						AnimationClipParser03._reader.pos = r
					}
				}, {
					key: "parse",
					value: function(e, t) {
						AnimationClipParser03._animationClip = e, AnimationClipParser03._reader = t;
						t.__getBuffer();
						AnimationClipParser03.READ_DATA(), AnimationClipParser03.READ_BLOCK(),
							AnimationClipParser03.READ_STRINGS();
						for (var r = 0, n = AnimationClipParser03._BLOCK.count; r < n; r++) {
							var i = t.getUint16(),
								a = AnimationClipParser03._strings[i],
								o = AnimationClipParser03["READ_" + a];
							if (null == o) throw new Error("model file err,no this function:" + i +
								" " + a);
							o.call(null)
						}
					}
				}, {
					key: "READ_ANIMATIONS",
					value: function() {
						var e, t, r, n = AnimationClipParser03._reader,
							i = (n.__getBuffer(), []),
							a = n.getUint16();
						for (i.length = a, e = 0; e < a; e++) i[e] = n.getFloat32();
						var o = AnimationClipParser03._animationClip;
						o.name = AnimationClipParser03._strings[n.getUint16()];
						var s = o._duration = n.getFloat32();
						o.islooping = !!n.getByte(), o._frameRate = n.getInt16();
						var l = n.getInt16(),
							u = o._nodes;
						u.count = l;
						var c = o._nodesMap = {},
							h = o._nodesDic = {};
						for (e = 0; e < l; e++) {
							r = new B, u.setNodeByIndex(e, r), r._indexInList = e;
							var _ = r.type = n.getUint8(),
								d = n.getUint16();
							for (r._setOwnerPathCount(d), t = 0; t < d; t++) r._setOwnerPathByIndex(t,
								AnimationClipParser03._strings[n.getUint16()]);
							var f = r._joinOwnerPath("/"),
								m = c[f];
							m || (c[f] = m = []), m.push(r), r.propertyOwner = AnimationClipParser03
								._strings[n.getUint16()];
							var p = n.getUint16();
							for (r._setPropertyCount(p), t = 0; t < p; t++) r._setPropertyByIndex(t,
								AnimationClipParser03._strings[n.getUint16()]);
							var T = f + "." + r.propertyOwner + "." + r._joinProperty(".");
							h[T] = r, r.fullPath = T;
							var E = n.getUint16();
							for (r._setKeyframeCount(E), t = 0; t < E; t++) switch (_) {
								case 0:
									var g = new U;
									r._setKeyframeByIndex(t, g), g.time = i[n.getUint16()], g
										.inTangent = n.getFloat32(), g.outTangent = n.getFloat32(),
										g.value = n.getFloat32();
									break;
								case 1:
								case 3:
								case 4:
									var y = new H;
									r._setKeyframeByIndex(t, y), y.time = i[n.getUint16()];
									var S = y.inTangent,
										v = y.outTangent,
										R = y.value;
									S.x = n.getFloat32(), S.y = n.getFloat32(), S.z = n
									.getFloat32(), v.x = n.getFloat32(), v.y = n.getFloat32(), v.z =
										n.getFloat32(), R.x = n.getFloat32(), R.y = n.getFloat32(),
										R.z = n.getFloat32();
									break;
								case 2:
									var C = new G;
									r._setKeyframeByIndex(t, C), C.time = i[n.getUint16()];
									var M = C.inTangent,
										D = C.outTangent,
										x = C.value;
									M.x = n.getFloat32(), M.y = n.getFloat32(), M.z = n
									.getFloat32(), M.w = n.getFloat32(), D.x = n.getFloat32(), D.y =
										n.getFloat32(), D.z = n.getFloat32(), D.w = n.getFloat32(),
										x.x = n.getFloat32(), x.y = n.getFloat32(), x.z = n
										.getFloat32(), x.w = n.getFloat32();
									break;
								default:
									throw "AnimationClipParser03:unknown type."
							}
						}
						var A = n.getUint16();
						for (e = 0; e < A; e++) {
							var I, L = new V;
							L.time = Math.min(s, n.getFloat32()), L.eventName = AnimationClipParser03
								._strings[n.getUint16()];
							var P = n.getUint16();
							for (P > 0 && (L.params = I = []), t = 0; t < P; t++) {
								switch (n.getByte()) {
									case 0:
										I.push(!!n.getByte());
										break;
									case 1:
										I.push(n.getInt32());
										break;
									case 2:
										I.push(n.getFloat32());
										break;
									case 3:
										I.push(AnimationClipParser03._strings[n.getUint16()]);
										break;
									default:
										throw new Error("unknown type.")
								}
							}
							o.addEvent(L)
						}
					}
				}]), AnimationClipParser03
			}();
		z._strings = [], z._BLOCK = {
			count: 0
		}, z._DATA = {
			offset: 0,
			size: 0
		};
		var W = function() {
			function AnimationClipParser04() {
				_classCallCheck(this, AnimationClipParser04)
			}
			return _createClass(AnimationClipParser04, null, [{
				key: "READ_DATA",
				value: function() {
					AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(),
						AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32()
				}
			}, {
				key: "READ_BLOCK",
				value: function() {
					for (var e = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader
							.getUint16(), t = AnimationClipParser04._BLOCK.blockStarts = [], r =
							AnimationClipParser04._BLOCK.blockLengths = [], n = 0; n < e; n++) t
						.push(AnimationClipParser04._reader.getUint32()), r.push(
							AnimationClipParser04._reader.getUint32())
				}
			}, {
				key: "READ_STRINGS",
				value: function() {
					var e = AnimationClipParser04._reader.getUint32(),
						t = AnimationClipParser04._reader.getUint16(),
						r = AnimationClipParser04._reader.pos;
					AnimationClipParser04._reader.pos = e + AnimationClipParser04._DATA.offset;
					for (var n = 0; n < t; n++) AnimationClipParser04._strings[n] =
						AnimationClipParser04._reader.readUTFString();
					AnimationClipParser04._reader.pos = r
				}
			}, {
				key: "parse",
				value: function(e, t, r) {
					AnimationClipParser04._animationClip = e, AnimationClipParser04._reader = t,
						AnimationClipParser04._version = r, AnimationClipParser04.READ_DATA(),
						AnimationClipParser04.READ_BLOCK(), AnimationClipParser04.READ_STRINGS();
					for (var n = 0, i = AnimationClipParser04._BLOCK.count; n < i; n++) {
						var a = t.getUint16(),
							o = AnimationClipParser04._strings[a],
							s = AnimationClipParser04["READ_" + o];
						if (null == s) throw new Error("model file err,no this function:" + a +
							" " + o);
						s.call(null)
					}
					AnimationClipParser04._version = null, AnimationClipParser04._reader = null,
						AnimationClipParser04._animationClip = null
				}
			}, {
				key: "READ_ANIMATIONS",
				value: function() {
					var e, r, n, i = AnimationClipParser04._reader,
						a = (i.__getBuffer(), []),
						o = i.getUint16();
					for (a.length = o, e = 0; e < o; e++) a[e] = i.getFloat32();
					var s = AnimationClipParser04._animationClip;
					s.name = AnimationClipParser04._strings[i.getUint16()];
					var l = s._duration = i.getFloat32();
					s.islooping = !!i.getByte(), s._frameRate = i.getInt16();
					var u = i.getInt16(),
						c = s._nodes;
					c.count = u;
					var h = s._nodesMap = {},
						_ = s._nodesDic = {};
					for (e = 0; e < u; e++) {
						n = new B, c.setNodeByIndex(e, n), n._indexInList = e;
						var d = n.type = i.getUint8(),
							f = i.getUint16();
						for (n._setOwnerPathCount(f), r = 0; r < f; r++) n._setOwnerPathByIndex(r,
							AnimationClipParser04._strings[i.getUint16()]);
						var m = n._joinOwnerPath("/"),
							p = h[m];
						p || (h[m] = p = []), p.push(n), n.propertyOwner = AnimationClipParser04
							._strings[i.getUint16()];
						var T = i.getUint16();
						for (n._setPropertyCount(T), r = 0; r < T; r++) n._setPropertyByIndex(r,
							AnimationClipParser04._strings[i.getUint16()]);
						var E = m + "." + n.propertyOwner + "." + n._joinProperty(".");
						_[E] = n, n.fullPath = E;
						var g = i.getUint16();
						switch (n._setKeyframeCount(g), AnimationClipParser04._version) {
							case "LAYAANIMATION:04":
								for (r = 0; r < g; r++) switch (d) {
									case 0:
										var y = new U;
										n._setKeyframeByIndex(r, y), y.time = a[i.getUint16()],
											y.inTangent = i.getFloat32(), y.outTangent = i
											.getFloat32(), y.value = i.getFloat32();
										break;
									case 1:
									case 3:
									case 4:
										var S = new H;
										n._setKeyframeByIndex(r, S), S.time = a[i.getUint16()];
										var v = S.inTangent,
											R = S.outTangent,
											C = S.value;
										v.x = i.getFloat32(), v.y = i.getFloat32(), v.z = i
											.getFloat32(), R.x = i.getFloat32(), R.y = i
											.getFloat32(), R.z = i.getFloat32(), C.x = i
											.getFloat32(), C.y = i.getFloat32(), C.z = i
											.getFloat32();
										break;
									case 2:
										var M = new G;
										n._setKeyframeByIndex(r, M), M.time = a[i.getUint16()];
										var D = M.inTangent,
											x = M.outTangent,
											A = M.value;
										D.x = i.getFloat32(), D.y = i.getFloat32(), D.z = i
											.getFloat32(), D.w = i.getFloat32(), x.x = i
											.getFloat32(), x.y = i.getFloat32(), x.z = i
											.getFloat32(), x.w = i.getFloat32(), A.x = i
											.getFloat32(), A.y = i.getFloat32(), A.z = i
											.getFloat32(), A.w = i.getFloat32();
										break;
									default:
										throw "AnimationClipParser04:unknown type."
								}
								break;
							case "LAYAANIMATION:COMPRESSION_04":
								for (r = 0; r < g; r++) switch (d) {
									case 0:
										y = new U, n._setKeyframeByIndex(r, y), y.time = a[i
												.getUint16()], y.inTangent = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), y.outTangent = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), y
											.value = t.HalfFloatUtils.convertToNumber(i
												.getUint16());
										break;
									case 1:
									case 3:
									case 4:
										S = new H, n._setKeyframeByIndex(r, S), S.time = a[i
												.getUint16()], v = S.inTangent, R = S
											.outTangent, C = S.value, v.x = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), v.y = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), v
											.z = t.HalfFloatUtils.convertToNumber(i
										.getUint16()), R.x = t.HalfFloatUtils.convertToNumber(i
												.getUint16()), R.y = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), R.z = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), C
											.x = t.HalfFloatUtils.convertToNumber(i
										.getUint16()), C.y = t.HalfFloatUtils.convertToNumber(i
												.getUint16()), C.z = t.HalfFloatUtils
											.convertToNumber(i.getUint16());
										break;
									case 2:
										M = new G, n._setKeyframeByIndex(r, M), M.time = a[i
												.getUint16()], D = M.inTangent, x = M
											.outTangent, A = M.value, D.x = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), D.y = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), D
											.z = t.HalfFloatUtils.convertToNumber(i
										.getUint16()), D.w = t.HalfFloatUtils.convertToNumber(i
												.getUint16()), x.x = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), x.y = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), x
											.z = t.HalfFloatUtils.convertToNumber(i
										.getUint16()), x.w = t.HalfFloatUtils.convertToNumber(i
												.getUint16()), A.x = t.HalfFloatUtils
											.convertToNumber(i.getUint16()), A.y = t
											.HalfFloatUtils.convertToNumber(i.getUint16()), A
											.z = t.HalfFloatUtils.convertToNumber(i
										.getUint16()), A.w = t.HalfFloatUtils.convertToNumber(i
												.getUint16());
										break;
									default:
										throw "AnimationClipParser04:unknown type."
								}
						}
					}
					var I = i.getUint16();
					for (e = 0; e < I; e++) {
						var L, P = new V;
						P.time = Math.min(l, i.getFloat32()), P.eventName = AnimationClipParser04
							._strings[i.getUint16()];
						var O = i.getUint16();
						for (O > 0 && (P.params = L = []), r = 0; r < O; r++) {
							switch (i.getByte()) {
								case 0:
									L.push(!!i.getByte());
									break;
								case 1:
									L.push(i.getInt32());
									break;
								case 2:
									L.push(i.getFloat32());
									break;
								case 3:
									L.push(AnimationClipParser04._strings[i.getUint16()]);
									break;
								default:
									throw new Error("unknown type.")
							}
						}
						s.addEvent(P)
					}
				}
			}]), AnimationClipParser04
		}();
		W._strings = [], W._BLOCK = {
			count: 0
		}, W._DATA = {
			offset: 0,
			size: 0
		};
		var X = function() {
				function KeyframeNodeList() {
					_classCallCheck(this, KeyframeNodeList), this._nodes = []
				}
				return _createClass(KeyframeNodeList, [{
					key: "getNodeByIndex",
					value: function(e) {
						return this._nodes[e]
					}
				}, {
					key: "setNodeByIndex",
					value: function(e, t) {
						this._nodes[e] = t
					}
				}, {
					key: "count",
					get: function() {
						return this._nodes.length
					},
					set: function(e) {
						this._nodes.length = e
					}
				}]), KeyframeNodeList
			}(),
			Y = function(e) {
				function AnimationClip() {
					var e;
					return _classCallCheck(this, AnimationClip), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						AnimationClip).call(this)))._nodes = new X, e._animationEvents = [], e
				}
				return _inherits(AnimationClip, e), _createClass(AnimationClip, [{
					key: "duration",
					value: function() {
						return this._duration
					}
				}, {
					key: "_hermiteInterpolate",
					value: function(e, t, r, n) {
						var i = e.outTangent,
							a = t.inTangent;
						if (Number.isFinite(i) && Number.isFinite(a)) {
							var o = r * r,
								s = o * r,
								l = s - 2 * o + r,
								u = s - o,
								c = -2 * s + 3 * o;
							return (2 * s - 3 * o + 1) * e.value + l * i * n + u * a * n + c * t.value
						}
						return e.value
					}
				}, {
					key: "_hermiteInterpolateVector3",
					value: function(e, t, r, n, i) {
						var a = e.value,
							o = e.outTangent,
							s = t.value,
							l = t.inTangent,
							u = r * r,
							c = u * r,
							h = 2 * c - 3 * u + 1,
							_ = c - 2 * u + r,
							d = c - u,
							f = -2 * c + 3 * u,
							m = o.x,
							p = l.x;
						Number.isFinite(m) && Number.isFinite(p) ? i.x = h * a.x + _ * m * n + d * p *
							n + f * s.x : i.x = a.x, m = o.y, p = l.y, Number.isFinite(m) && Number
							.isFinite(p) ? i.y = h * a.y + _ * m * n + d * p * n + f * s.y : i.y = a.y,
							m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? i.z = h * a.z +
							_ * m * n + d * p * n + f * s.z : i.z = a.z
					}
				}, {
					key: "_hermiteInterpolateQuaternion",
					value: function(e, t, r, n, i) {
						var a = e.value,
							o = e.outTangent,
							s = t.value,
							l = t.inTangent,
							u = r * r,
							c = u * r,
							h = 2 * c - 3 * u + 1,
							_ = c - 2 * u + r,
							d = c - u,
							f = -2 * c + 3 * u,
							m = o.x,
							p = l.x;
						Number.isFinite(m) && Number.isFinite(p) ? i.x = h * a.x + _ * m * n + d * p *
							n + f * s.x : i.x = a.x, m = o.y, p = l.y, Number.isFinite(m) && Number
							.isFinite(p) ? i.y = h * a.y + _ * m * n + d * p * n + f * s.y : i.y = a.y,
							m = o.z, p = l.z, Number.isFinite(m) && Number.isFinite(p) ? i.z = h * a.z +
							_ * m * n + d * p * n + f * s.z : i.z = a.z, m = o.w, p = l.w, Number
							.isFinite(m) && Number.isFinite(p) ? i.w = h * a.w + _ * m * n + d * p * n +
							f * s.w : i.w = a.w
					}
				}, {
					key: "_evaluateClipDatasRealTime",
					value: function(e, t, r, n, i, a) {
						for (var o = 0, s = e.count; o < s; o++) {
							var l, c = e.getNodeByIndex(o),
								h = c.type,
								_ = c._keyFrames,
								d = _.length,
								f = r[o];
							if (i)
								for (-1 !== f && t < _[f].time && (f = -1, r[o] = f), l = f + 1; l <
									d && !(_[l].time > t);) f++, l++, r[o] = f;
							else
								for ((l = f + 1) !== d && t > _[l].time && (f = d - 1, r[o] = f), l =
									f + 1; f > -1 && !(_[f].time < t);) f--, l--, r[o] = f;
							var m = l === d;
							switch (h) {
								case 0:
									if (-1 !== f) {
										var p = _[f];
										if (m) a[o] = p.value;
										else {
											var T, E = _[l],
												g = E.time - p.time;
											T = 0 !== g ? (t - p.time) / g : 0, a[o] = this
												._hermiteInterpolate(p, E, T, g)
										}
									} else a[o] = _[0].value;
									n && (a[o] = a[o] - _[0].value);
									break;
								case 1:
								case 4:
									var y = a[o];
									if (this._evaluateFrameNodeVector3DatasRealTime(_, f, m, t, y), n) {
										var S = _[0].value;
										y.x -= S.x, y.y -= S.y, y.z -= S.z
									}
									break;
								case 2:
									var v = a[o];
									if (this._evaluateFrameNodeQuaternionDatasRealTime(_, f, m, t, v),
										n) {
										var R = AnimationClip._tempQuaternion0,
											C = _[0].value;
										P.quaternionConjugate(C, R), u.multiply(R, v, v)
									}
									break;
								case 3:
									y = a[o], this._evaluateFrameNodeVector3DatasRealTime(_, f, m, t,
										y), n && (S = _[0].value, y.x /= S.x, y.y /= S.y, y.z /= S.z);
									break;
								default:
									throw "AnimationClip:unknown node type."
							}
						}
					}
				}, {
					key: "_evaluateClipDatasRealTimeForNative",
					value: function(e, r, n, i) {
						t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, n, i)
					}
				}, {
					key: "_evaluateFrameNodeVector3DatasRealTime",
					value: function(e, t, r, n, i) {
						if (-1 !== t) {
							var a = e[t];
							if (r) {
								var o = a.value;
								i.x = o.x, i.y = o.y, i.z = o.z
							} else {
								var s, l = e[t + 1],
									u = a.time,
									c = l.time - u;
								s = 0 !== c ? (n - u) / c : 0, this._hermiteInterpolateVector3(a, l, s,
									c, i)
							}
						} else {
							var h = e[0].value;
							i.x = h.x, i.y = h.y, i.z = h.z
						}
					}
				}, {
					key: "_evaluateFrameNodeQuaternionDatasRealTime",
					value: function(e, t, r, n, i) {
						if (-1 !== t) {
							var a = e[t];
							if (r) {
								var o = a.value;
								i.x = o.x, i.y = o.y, i.z = o.z, i.w = o.w
							} else {
								var s, l = e[t + 1],
									u = a.time,
									c = l.time - u;
								s = 0 !== c ? (n - u) / c : 0, this._hermiteInterpolateQuaternion(a, l,
									s, c, i)
							}
						} else {
							var h = e[0].value;
							i.x = h.x, i.y = h.y, i.z = h.z, i.w = h.w
						}
					}
				}, {
					key: "_binarySearchEventIndex",
					value: function(e) {
						for (var t, r = 0, n = this._animationEvents.length - 1; r <= n;) {
							t = Math.floor((r + n) / 2);
							var i = this._animationEvents[t].time;
							if (i == e) return t;
							i > e ? n = t - 1 : r = t + 1
						}
						return r
					}
				}, {
					key: "addEvent",
					value: function(e) {
						var t = this._binarySearchEventIndex(e.time);
						this._animationEvents.splice(t, 0, e)
					}
				}, {
					key: "_disposeResource",
					value: function() {
						this._nodes = null, this._nodesMap = null
					}
				}], [{
					key: "_parse",
					value: function(e) {
						arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
							.length > 2 && void 0 !== arguments[2] && arguments[2];
						var r = new AnimationClip,
							n = new t.Byte(e),
							i = n.readUTFString();
						switch (i) {
							case "LAYAANIMATION:03":
								z.parse(r, n);
								break;
							case "LAYAANIMATION:04":
							case "LAYAANIMATION:COMPRESSION_04":
								W.parse(r, n, i);
								break;
							default:
								throw "unknown animationClip version."
						}
						return r
					}
				}, {
					key: "load",
					value: function(e, r) {
						t.ILaya.loader.create(e, r, null, AnimationClip.ANIMATIONCLIP)
					}
				}]), AnimationClip
			}(t.Resource);
		Y.ANIMATIONCLIP = "ANIMATIONCLIP", Y._tempQuaternion0 = new u;
		var j = function() {
				function AnimatorPlayState() {
					_classCallCheck(this, AnimatorPlayState), this._currentState = null
				}
				return _createClass(AnimatorPlayState, [{
					key: "_resetPlayState",
					value: function(e) {
						this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this
							._playEventIndex = 0, this._lastIsFront = !0
					}
				}, {
					key: "_cloneTo",
					value: function(e) {
						e._finish = this._finish, e._startPlayTime = this._startPlayTime, e
							._elapsedTime = this._elapsedTime, e._normalizedTime = this._normalizedTime,
							e._normalizedPlayTime = this._normalizedPlayTime, e._playEventIndex = this
							._playEventIndex, e._lastIsFront = this._lastIsFront
					}
				}, {
					key: "normalizedTime",
					get: function() {
						return this._normalizedTime
					}
				}, {
					key: "duration",
					get: function() {
						return this._duration
					}
				}, {
					key: "animatorState",
					get: function() {
						return this._currentState
					}
				}]), AnimatorPlayState
			}(),
			Z = function() {
				function AnimatorControllerLayer(e) {
					_classCallCheck(this, AnimatorControllerLayer), this._defaultState = null, this._referenceCount = 0,
						this._playType = -1, this._crossDuration = -1, this._crossMark = 0, this
						._crossNodesOwnersCount = 0, this._crossNodesOwners = [], this._crossNodesOwnersIndicesMap = {},
						this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], this._statesMap = {},
						this._states = [], this._playStateInfo = new j, this._crossPlayStateInfo = new j, this
						.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE, this.defaultWeight = 1, this
						.playOnWake = !0, this.name = e
				}
				return _createClass(AnimatorControllerLayer, [{
					key: "_removeClip",
					value: function(e, t, r, n) {
						var i = n._clip,
							a = e[r];
						if (e.splice(r, 1), delete t[n.name], this._animator) {
							var o = i._nodes,
								s = a._nodeOwners;
							i._removeReference();
							for (var l = 0, u = o.count; l < u; l++) this._animator
								._removeKeyframeNodeOwner(s, o.getNodeByIndex(l))
						}
					}
				}, {
					key: "_getReferenceCount",
					value: function() {
						return this._referenceCount
					}
				}, {
					key: "_addReference",
					value: function() {
						for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
								t = 0, r = this._states.length; t < r; t++) this._states[t]
							._addReference(e);
						this._referenceCount += e
					}
				}, {
					key: "_removeReference",
					value: function() {
						for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
								t = 0, r = this._states.length; t < r; t++) this._states[t]
							._removeReference(e);
						this._referenceCount -= e
					}
				}, {
					key: "_clearReference",
					value: function() {
						this._removeReference(-this._referenceCount)
					}
				}, {
					key: "getCurrentPlayState",
					value: function() {
						return this._playStateInfo
					}
				}, {
					key: "getAnimatorState",
					value: function(e) {
						var t = this._statesMap[e];
						return t || null
					}
				}, {
					key: "addState",
					value: function(e) {
						var t = e.name;
						if (this._statesMap[t])
						throw "AnimatorControllerLayer:this stat's name has exist.";
						this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip
							._addReference(), this._animator._getOwnersByClip(e))
					}
				}, {
					key: "removeState",
					value: function(e) {
						for (var t = this._states, r = -1, n = 0, i = t.length; n < i; n++)
							if (t[n] === e) {
								r = n;
								break
							} - 1 !== r && this._removeClip(t, this._statesMap, r, e)
					}
				}, {
					key: "destroy",
					value: function() {
						this._clearReference(), this._statesMap = null, this._states = null, this
							._playStateInfo = null, this._crossPlayStateInfo = null, this
							._defaultState = null
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this
							.defaultWeight, t.playOnWake = this.playOnWake
					}
				}, {
					key: "clone",
					value: function() {
						var e = new AnimatorControllerLayer(this.name);
						return this.cloneTo(e), e
					}
				}, {
					key: "defaultState",
					get: function() {
						return this._defaultState
					},
					set: function(e) {
						this._defaultState = e, this._statesMap[e.name] = e
					}
				}]), AnimatorControllerLayer
			}();
		Z.BLENDINGMODE_OVERRIDE = 0, Z.BLENDINGMODE_ADDTIVE = 1;
		var Q = function() {
				function AnimatorState() {
					_classCallCheck(this, AnimatorState), this._referenceCount = 0, this._clip = null, this
						._nodeOwners = [], this._currentFrameIndices = null, this._realtimeDatas = [], this._scripts =
						null, this.speed = 1, this.clipStart = 0, this.clipEnd = 1
				}
				return _createClass(AnimatorState, [{
					key: "_getReferenceCount",
					value: function() {
						return this._referenceCount
					}
				}, {
					key: "_addReference",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
						this._clip && this._clip._addReference(e), this._referenceCount += e
					}
				}, {
					key: "_removeReference",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
						this._clip && this._clip._removeReference(e), this._referenceCount -= e
					}
				}, {
					key: "_clearReference",
					value: function() {
						this._removeReference(-this._referenceCount)
					}
				}, {
					key: "_resetFrameIndices",
					value: function() {
						for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this
							._currentFrameIndices[e] = -1
					}
				}, {
					key: "addScript",
					value: function(e) {
						var t = new e;
						return this._scripts = this._scripts || [], this._scripts.push(t), t
					}
				}, {
					key: "getScript",
					value: function(e) {
						if (this._scripts)
							for (var t = 0, r = this._scripts.length; t < r; t++) {
								var n = this._scripts[t];
								if (n instanceof e) return n
							}
						return null
					}
				}, {
					key: "getScripts",
					value: function(e) {
						var t;
						if (this._scripts)
							for (var r = 0, n = this._scripts.length; r < n; r++) {
								var i = this._scripts[r];
								i instanceof e && (t = t || []).push(i)
							}
						return t
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t
							.clipEnd = this.clipEnd, t.clip = this._clip
					}
				}, {
					key: "clone",
					value: function() {
						var e = new AnimatorState;
						return this.cloneTo(e), e
					}
				}, {
					key: "clip",
					get: function() {
						return this._clip
					},
					set: function(e) {
						if (this._clip !== e) {
							if (this._clip && this._referenceCount > 0 && this._clip._removeReference(
									this._referenceCount), e) {
								var t = this._realtimeDatas,
									r = e._nodes,
									n = r.count;
								this._currentFrameIndices = new Int16Array(n), this
								._resetFrameIndices(), this._referenceCount > 0 && e._addReference(this
										._referenceCount), this._realtimeDatas.length = n;
								for (var i = 0; i < n; i++) switch (r.getNodeByIndex(i).type) {
									case 0:
										break;
									case 1:
									case 3:
									case 4:
										t[i] = new o;
										break;
									case 2:
										t[i] = new u;
										break;
									default:
										throw "AnimationClipParser04:unknown type."
								}
							}
							this._clip = e
						}
					}
				}]), AnimatorState
			}(),
			q = function() {
				function KeyframeNodeOwner() {
					_classCallCheck(this, KeyframeNodeOwner), this.indexInList = -1, this.referenceCount = 0, this
						.updateMark = -1, this.type = -1, this.fullPath = null, this.propertyOwner = null, this
						.property = null, this.defaultValue = null, this.value = null, this.crossFixedValue = null
				}
				return _createClass(KeyframeNodeOwner, [{
					key: "saveCrossFixedValue",
					value: function() {
						if (this.propertyOwner) switch (this.type) {
							case 0:
								this.crossFixedValue = this.value;
								break;
							case 1:
							case 3:
							case 4:
							case 2:
								this.value.cloneTo(this.crossFixedValue);
								break;
							default:
								throw "Animator:unknown type."
						}
					}
				}]), KeyframeNodeOwner
			}(),
			K = function(e) {
				function Animator() {
					var e;
					return _classCallCheck(this, Animator), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							Animator).call(this)))._keyframeNodeOwners = [], e._linkAvatarSpritesData = {}, e
						._linkAvatarSprites = [], e._renderableSprites = [], e.cullingMode = Animator
						.CULLINGMODE_CULLCOMPLETELY, e._controllerLayers = [], e._linkSprites = {}, e._speed = 1, e
						._keyframeNodeOwnerMap = {}, e._updateMark = 0, e
				}
				return _inherits(Animator, e), _createClass(Animator, [{
					key: "_linkToSprites",
					value: function(e) {
						for (var t in e) {
							for (var r = this.owner, n = e[t], i = 0, a = n.length; i < a; i++) {
								var o = n[i];
								if ("" === o) break;
								if (!(r = r.getChildByName(o))) break
							}
							r && this.linkSprite3DToAvatarNode(t, r)
						}
					}
				}, {
					key: "_addKeyframeNodeOwner",
					value: function(e, t, r) {
						var n = t._indexInList,
							i = t.fullPath,
							a = this._keyframeNodeOwnerMap[i];
						if (a) a.referenceCount++, e[n] = a;
						else {
							for (var o = r, s = 0, l = t.propertyCount; s < l && (o = o[t
									.getPropertyByIndex(s)]); s++);
							(a = this._keyframeNodeOwnerMap[i] = new q).fullPath = i, a.indexInList =
								this._keyframeNodeOwners.length, a.referenceCount = 1, a.propertyOwner =
								r;
							var u = t.propertyCount,
								c = [];
							for (s = 0; s < u; s++) c[s] = t.getPropertyByIndex(s);
							if (a.property = c, a.type = t.type, o)
								if (0 === t.type) a.defaultValue = o;
								else {
									var h = new o.constructor;
									o.cloneTo(h), a.defaultValue = h, a.value = new o.constructor, a
										.crossFixedValue = new o.constructor
								} this._keyframeNodeOwners.push(a), e[n] = a
						}
					}
				}, {
					key: "_removeKeyframeNodeOwner",
					value: function(e, t) {
						var r = t.fullPath,
							n = this._keyframeNodeOwnerMap[r];
						n && (n.referenceCount--, 0 === n.referenceCount && (delete this
							._keyframeNodeOwnerMap[r], this._keyframeNodeOwners.splice(this
								._keyframeNodeOwners.indexOf(n), 1)), e[t._indexInList] = null)
					}
				}, {
					key: "_getOwnersByClip",
					value: function(e) {
						var t = e._clip._nodes,
							r = t.count,
							n = e._nodeOwners;
						n.length = r;
						for (var i = 0; i < r; i++) {
							for (var a = t.getNodeByIndex(i), o = this._avatar ? this._avatarNodeMap[
										this._avatar._rootNode.name] : this.owner, s = 0, l = a
									.ownerPathCount; s < l; s++) {
								var u = a.getOwnerPathByIndex(s);
								if ("" === u) break;
								if (!(o = o.getChildByName(u))) break
							}
							if (o) {
								var c = a.propertyOwner;
								c && (o = o[c]), o && this._addKeyframeNodeOwner(n, a, o)
							}
						}
					}
				}, {
					key: "_updatePlayer",
					value: function(e, t, r, n) {
						var i = e._clip._duration * (e.clipEnd - e.clipStart),
							a = t._elapsedTime,
							o = a + r;
						t._lastElapsedTime = a, t._elapsedTime = o;
						var s = o / i;
						t._normalizedTime = s;
						var l = s % 1;
						t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = i;
						var u = e._scripts;
						if (!n && o >= i) {
							if (t._finish = !0, t._elapsedTime = i, t._normalizedPlayTime = 1, u)
								for (var c = 0, h = u.length; c < h; c++) u[c].onStateExit()
						} else if (u)
							for (c = 0, h = u.length; c < h; c++) u[c].onStateUpdate()
					}
				}, {
					key: "_eventScript",
					value: function(e, t, r, n, i) {
						if (i)
							for (var a = t.length; r < a; r++) {
								var o = t[r];
								if (!(o.time <= n)) break;
								for (var s = 0, l = e.length; s < l; s++) {
									var u = e[s],
										c = u[o.eventName];
									c && c.apply(u, o.params)
								}
							} else
								for (; r >= 0 && (o = t[r]).time >= n; r--)
									for (s = 0, l = e.length; s < l; s++)(c = (u = e[s])[o
										.eventName]) && c.apply(u, o.params);
						return r
					}
				}, {
					key: "_updateEventScript",
					value: function(e, t) {
						var r = this.owner._scripts;
						if (r) {
							var n = e._clip,
								i = n._animationEvents,
								a = n._duration,
								o = t._elapsedTime,
								s = o % a,
								l = Math.abs(Math.floor(o / a) - Math.floor(t._lastElapsedTime / a)),
								u = t._elapsedTime >= t._lastElapsedTime;
							t._lastIsFront !== u && (u ? t._playEventIndex++ : t._playEventIndex--, t
								._lastIsFront = u);
							var c = t._playEventIndex;
							if (u) {
								var h = this._eventScript(r, i, t._playEventIndex, l > 0 ? a : s, !0);
								c === t._playEventIndex && (t._playEventIndex = h);
								for (var _ = 0, d = l - 1; _ < d; _++) this._eventScript(r, i, 0, a, !
								0);
								l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, 0, s, !
									0))
							} else {
								h = this._eventScript(r, i, t._playEventIndex, l > 0 ? 0 : s, !1);
								c === t._playEventIndex && (t._playEventIndex = h);
								var f = i.length - 1;
								for (_ = 0, d = l - 1; _ < d; _++) this._eventScript(r, i, f, 0, !1);
								l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, f, s, !
									1))
							}
						}
					}
				}, {
					key: "_updateClipDatas",
					value: function(e, t, r, n) {
						var i = e._clip,
							a = i._duration,
							o = e.clipStart * a + r._normalizedPlayTime * r._duration,
							s = e._currentFrameIndices,
							l = r._elapsedTime > r._lastElapsedTime;
						i._evaluateClipDatasRealTime(i._nodes, o, s, t, l, e._realtimeDatas)
					}
				}, {
					key: "_applyFloat",
					value: function(e, t, r, n, i, a, o) {
						if (r.updateMark === this._updateMark)
							if (n) e[t] += i * o;
							else {
								var s = e[t];
								e[t] = s + i * (o - s)
							}
						else if (a) e[t] = n ? r.defaultValue + o : o;
						else if (n) e[t] = r.defaultValue + i * o;
						else {
							var l = r.defaultValue;
							e[t] = l + i * (o - l)
						}
					}
				}, {
					key: "_applyPositionAndRotationEuler",
					value: function(e, t, r, n, i, a) {
						if (e.updateMark === this._updateMark)
							if (t) a.x += r * i.x, a.y += r * i.y, a.z += r * i.z;
							else {
								var o = a.x,
									s = a.y,
									l = a.z;
								a.x = o + r * (i.x - o), a.y = s + r * (i.y - s), a.z = l + r * (i.z -
									l)
							}
						else if (n)
							if (t) {
								var u = e.defaultValue;
								a.x = u.x + i.x, a.y = u.y + i.y, a.z = u.z + i.z
							} else a.x = i.x, a.y = i.y, a.z = i.z;
						else if (u = e.defaultValue, t) a.x = u.x + r * i.x, a.y = u.y + r * i.y, a.z =
							u.z + r * i.z;
						else {
							var c = u.x,
								h = u.y,
								_ = u.z;
							a.x = c + r * (i.x - c), a.y = h + r * (i.y - h), a.z = _ + r * (i.z - _)
						}
					}
				}, {
					key: "_applyRotation",
					value: function(e, t, r, n, i, a) {
						if (e.updateMark === this._updateMark)
							if (t) {
								var o = Animator._tempQuaternion1;
								P.quaternionWeight(i, r, o), o.normalize(o), u.multiply(a, o, a)
							} else u.lerp(a, i, r, a);
						else if (n)
							if (t) {
								var s = e.defaultValue;
								u.multiply(s, i, a)
							} else a.x = i.x, a.y = i.y, a.z = i.z, a.w = i.w;
						else s = e.defaultValue, t ? (o = Animator._tempQuaternion1, P.quaternionWeight(
							i, r, o), o.normalize(o), u.multiply(s, o, a)) : u.lerp(s, i, r, a)
					}
				}, {
					key: "_applyScale",
					value: function(e, t, r, n, i, a) {
						if (e.updateMark === this._updateMark)
							if (t) {
								var o = Animator._tempVector31;
								P.scaleWeight(i, r, o), a.x = a.x * o.x, a.y = a.y * o.y, a.z = a.z * o
									.z
							} else P.scaleBlend(a, i, r, a);
						else if (n)
							if (t) {
								var s = e.defaultValue;
								a.x = s.x * i.x, a.y = s.y * i.y, a.z = s.z * i.z
							} else a.x = i.x, a.y = i.y, a.z = i.z;
						else s = e.defaultValue, t ? (o = Animator._tempVector31, P.scaleWeight(i, r,
							o), a.x = s.x * o.x, a.y = s.y * o.y, a.z = s.z * o.z) : P.scaleBlend(s,
							i, r, a)
					}
				}, {
					key: "_applyCrossData",
					value: function(e, t, r, n, i, a, o) {
						var s = e.propertyOwner;
						if (s) {
							switch (e.type) {
								case 0:
									for (var l = e.property, c = l.length - 1, h = 0; h < c && (s = s[l[
											h]]); h++);
									var _ = i + o * (a - i);
									e.value = _, this._applyFloat(s, l[c], e, t, r, n, _);
									break;
								case 1:
									var d = s.localPosition,
										f = e.value,
										m = i.x,
										p = i.y,
										T = i.z;
									f.x = m + o * (a.x - m), f.y = p + o * (a.y - p), f.z = T + o * (a
										.z - T), this._applyPositionAndRotationEuler(e, t, r, n, f,
										d), s.localPosition = d;
									break;
								case 2:
									var E = s.localRotation,
										g = e.value;
									u.lerp(i, a, o, g), this._applyRotation(e, t, r, n, g, E), s
										.localRotation = E;
									break;
								case 3:
									var y = s.localScale,
										S = e.value;
									P.scaleBlend(i, a, o, S), this._applyScale(e, t, r, n, S, y), s
										.localScale = y;
									break;
								case 4:
									var v = s.localRotationEuler,
										R = e.value;
									m = i.x, p = i.y, T = i.z, R.x = m + o * (a.x - m), R.y = p + o * (a
											.y - p), R.z = T + o * (a.z - T), this
										._applyPositionAndRotationEuler(e, t, r, n, R, v), s
										.localRotationEuler = v
							}
							e.updateMark = this._updateMark
						}
					}
				}, {
					key: "_setClipDatasToNode",
					value: function(e, t, r, n) {
						for (var i = e._realtimeDatas, a = e._clip._nodes, o = e._nodeOwners, s = 0, l =
								a.count; s < l; s++) {
							var u = o[s];
							if (u) {
								var c = u.propertyOwner;
								if (c) {
									switch (u.type) {
										case 0:
											for (var h = u.property, _ = h.length - 1, d = 0; d < _ && (
													c = c[h[d]]); d++);
											this._applyFloat(c, h[_], u, t, r, n, i[s]);
											break;
										case 1:
											var f = c.localPosition;
											this._applyPositionAndRotationEuler(u, t, r, n, i[s], f), c
												.localPosition = f;
											break;
										case 2:
											var m = c.localRotation;
											this._applyRotation(u, t, r, n, i[s], m), c.localRotation =
												m;
											break;
										case 3:
											var p = c.localScale;
											this._applyScale(u, t, r, n, i[s], p), c.localScale = p;
											break;
										case 4:
											var T = c.localRotationEuler;
											this._applyPositionAndRotationEuler(u, t, r, n, i[s], T), c
												.localRotationEuler = T
									}
									u.updateMark = this._updateMark
								}
							}
						}
					}
				}, {
					key: "_setCrossClipDatasToNode",
					value: function(e, t, r, n, i) {
						for (var a = e._crossNodesOwners, o = e._crossNodesOwnersCount, s = e
								.blendingMode !== Z.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, u = r
								._realtimeDatas, c = e._destCrossClipNodeIndices, h = r._nodeOwners, _ =
								t._realtimeDatas, d = e._srcCrossClipNodeIndices, f = t._nodeOwners, m =
								0; m < o; m++) {
							var p = a[m];
							if (p) {
								var T = d[m],
									E = c[m],
									g = -1 !== T ? _[T] : h[E].defaultValue,
									y = -1 !== E ? u[E] : f[T].defaultValue;
								this._applyCrossData(p, s, l, i, g, y, n)
							}
						}
					}
				}, {
					key: "_setFixedCrossClipDatasToNode",
					value: function(e, t, r, n) {
						for (var i = e._crossNodesOwners, a = e._crossNodesOwnersCount, o = e
								.blendingMode !== Z.BLENDINGMODE_OVERRIDE, s = e.defaultWeight, l = t
								._realtimeDatas, u = e._destCrossClipNodeIndices, c = 0; c < a; c++) {
							var h = i[c];
							if (h) {
								var _ = u[c],
									d = h.crossFixedValue,
									f = -1 !== _ ? l[_] : h.defaultValue;
								this._applyCrossData(h, o, s, n, d, f, r)
							}
						}
					}
				}, {
					key: "_revertDefaultKeyframeNodes",
					value: function(e) {
						for (var t = e._nodeOwners, r = 0, n = t.length; r < n; r++) {
							var i = t[r];
							if (i) {
								var a = i.propertyOwner;
								if (a) switch (i.type) {
									case 0:
										for (var o = i.property, s = o.length - 1, l = 0; l < s && (
												a = a[o[l]]); l++);
										a[o[s]] = i.defaultValue;
										break;
									case 1:
										var u = a.localPosition,
											c = i.defaultValue;
										u.x = c.x, u.y = c.y, u.z = c.z, a.localPosition = u;
										break;
									case 2:
										var h = a.localRotation,
											_ = i.defaultValue;
										h.x = _.x, h.y = _.y, h.z = _.z, h.w = _.w, a
											.localRotation = h;
										break;
									case 3:
										var d = a.localScale;
										c = i.defaultValue, d.x = c.x, d.y = c.y, d.z = c.z, a
											.localScale = d;
										break;
									case 4:
										var f = a.localRotationEuler;
										c = i.defaultValue, f.x = c.x, f.y = c.y, f.z = c.z, a
											.localRotationEuler = f;
										break;
									default:
										throw "Animator:unknown type."
								}
							}
						}
					}
				}, {
					key: "_onAdded",
					value: function() {
						var e = this.owner._parent;
						this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this
							.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, [])
					}
				}, {
					key: "_onDestroy",
					value: function() {
						for (var e = 0, t = this._controllerLayers.length; e < t; e++) this
							._controllerLayers[e]._removeReference();
						var r = this.owner._parent;
						this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null)
					}
				}, {
					key: "_onEnable",
					value: function() {
						this.owner._scene._animatorPool.add(this);
						for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
							if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this
								.play(null, e, 0)
						}
					}
				}, {
					key: "_onDisable",
					value: function() {
						this.owner._scene._animatorPool.remove(this)
					}
				}, {
					key: "_handleSpriteOwnersBySprite",
					value: function(e, t, r) {
						for (var n = 0, i = this._controllerLayers.length; n < i; n++)
							for (var a = this._controllerLayers[n]._states, o = 0, s = a.length; o <
								s; o++) {
								var l = a[o],
									u = l._clip,
									c = t.join("/"),
									h = u._nodesMap[c];
								if (h)
									for (var _ = l._nodeOwners, d = 0, f = h.length; d < f; d++) e ?
										this._addKeyframeNodeOwner(_, h[d], r) : this
										._removeKeyframeNodeOwner(_, h[d])
							}
					}
				}, {
					key: "_parse",
					value: function(e) {
						var r = e.avatar;
						if (r) {
							this.avatar = t.Loader.getRes(r.path);
							var n = r.linkSprites;
							this._linkSprites = n, this._linkToSprites(n)
						}
						e.clipPaths;
						for (var i = e.playOnWake, a = e.layers, o = 0; o < a.length; o++) {
							var s = a[o],
								l = new Z(s.name);
							l.defaultWeight = 0 === o ? 1 : s.weight;
							var u = s.blendingMode;
							u && (l.blendingMode = u), this.addControllerLayer(l);
							for (var c = s.states, h = 0, _ = c.length; h < _; h++) {
								var d = c[h],
									f = d.clipPath;
								if (f) {
									var m, p = d.name;
									if (m = t.Loader.getRes(f)) {
										var T = new Q;
										T.name = p, T.clip = m, l.addState(T), 0 === h && (this
											.getControllerLayer(o).defaultState = T)
									}
								}
							}
							void 0 !== i && (l.playOnWake = i)
						}
						var E = e.cullingMode;
						void 0 !== E && (this.cullingMode = E)
					}
				}, {
					key: "_update",
					value: function() {
						var e = this.owner._scene.timer,
							t = e._delta / 1e3;
						if (0 !== this._speed && 0 !== t) {
							var r;
							if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) {
								r = !1;
								for (var n = 0, i = this._renderableSprites.length; n < i; n++)
									if (this._renderableSprites[n]._render.isRender) {
										r = !0;
										break
									}
							} else r = !0;
							this._updateMark++;
							var a = e.scale;
							for (n = 0, i = this._controllerLayers.length; n < i; n++) {
								var o = this._controllerLayers[n],
									s = o._playStateInfo,
									l = o._crossPlayStateInfo;
								switch (d = o.blendingMode !== Z.BLENDINGMODE_OVERRIDE, o._playType) {
									case 0:
										var u = s._currentState,
											c = u._clip,
											h = this._speed * u.speed,
											_ = s._finish;
										if (_ || this._updatePlayer(u, s, t * h, c.islooping), r) {
											var d = o.blendingMode !== Z.BLENDINGMODE_OVERRIDE;
											this._updateClipDatas(u, d, s, a * h), this
												._setClipDatasToNode(u, d, o.defaultWeight, 0 === n),
												_ || this._updateEventScript(u, s)
										}
										break;
									case 1:
										c = (u = s._currentState)._clip;
										var f = o._crossPlayState,
											m = f._clip,
											p = o._crossDuration,
											T = l._startPlayTime,
											E = m._duration - T,
											g = p > E ? E / p : 1,
											y = this._speed * f.speed;
										this._updatePlayer(f, l, t * g * y, m.islooping);
										var S = (l._elapsedTime - T) / g / p;
										S >= 1 ? r && (this._updateClipDatas(f, d, l, a * y), this
												._setClipDatasToNode(f, d, o.defaultWeight, 0 === n), o
												._playType = 0, s._currentState = f, l._cloneTo(s)) : (s
												._finish || (h = this._speed * u.speed, this
													._updatePlayer(u, s, t * h, c.islooping), r && this
													._updateClipDatas(u, d, s, a * h)), r && (this
													._updateClipDatas(f, d, l, a * g * y), this
													._setCrossClipDatasToNode(o, u, f, S, 0 === n))),
											r && (this._updateEventScript(u, s), this
												._updateEventScript(f, l));
										break;
									case 2:
										m = (f = o._crossPlayState)._clip, p = o._crossDuration, T = l
											._startPlayTime, g = p > (E = m._duration - T) ? E / p : 1,
											y = this._speed * f.speed, this._updatePlayer(f, l, t * g *
												y, m.islooping), r && ((S = (l._elapsedTime - T) / g /
													p) >= 1 ? (this._updateClipDatas(f, d, l, a * y),
													this._setClipDatasToNode(f, d, 1, 0 === n), o
													._playType = 0, s._currentState = f, l._cloneTo(s)
													) : (this._updateClipDatas(f, d, l, a * g * y), this
													._setFixedCrossClipDatasToNode(o, f, S, 0 === n)),
												this._updateEventScript(f, l))
								}
							}
							r && this._avatar && this._updateAvatarNodesToSprite()
						}
					}
				}, {
					key: "_cloneTo",
					value: function(e) {
						var t = e;
						t.avatar = this.avatar, t.cullingMode = this.cullingMode;
						for (var r = 0, n = this._controllerLayers.length; r < n; r++) {
							var i = this._controllerLayers[r];
							t.addControllerLayer(i.clone());
							for (var a = i._states, o = 0, s = a.length; o < s; o++) {
								var l = a[o].clone(),
									u = t.getControllerLayer(r);
								u.addState(l), 0 == o && (u.defaultState = l)
							}
						}
						t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites)
					}
				}, {
					key: "getDefaultState",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
							t = this._controllerLayers[e];
						return t.defaultState
					}
				}, {
					key: "addState",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							r = this._controllerLayers[t];
						r.addState(e), console.warn(
							"Animator:this function is discard,please use animatorControllerLayer.addState() instead."
							)
					}
				}, {
					key: "removeState",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							r = this._controllerLayers[t];
						r.removeState(e), console.warn(
							"Animator:this function is discard,please use animatorControllerLayer.removeState() instead."
							)
					}
				}, {
					key: "addControllerLayer",
					value: function(e) {
						this._controllerLayers.push(e), e._animator = this, e._addReference();
						for (var t = e._states, r = 0, n = t.length; r < n; r++) this._getOwnersByClip(
							t[r])
					}
				}, {
					key: "getControllerLayer",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
						return this._controllerLayers[e]
					}
				}, {
					key: "play",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number
							.NEGATIVE_INFINITY,
							n = this._controllerLayers[t];
						if (n) {
							var i = n.defaultState;
							if (!e && !i) throw new Error(
								"Animator:must have default clip value,please set clip property."
								);
							var a = n._playStateInfo,
								o = a._currentState,
								s = e ? n._statesMap[e] : i,
								l = s._clip._duration;
							o !== s ? (r !== Number.NEGATIVE_INFINITY ? a._resetPlayState(l * r) : a
								._resetPlayState(0), null !== o && o !== s && this
								._revertDefaultKeyframeNodes(o), n._playType = 0, a._currentState =
								s) : r !== Number.NEGATIVE_INFINITY && (a._resetPlayState(l * r), n
								._playType = 0);
							var u = s._scripts;
							if (u)
								for (var c = 0, h = u.length; c < h; c++) u[c].onStateEnter()
						} else console.warn("Invalid layerIndex " + t + ".")
					}
				}, {
					key: "crossFade",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number
							.NEGATIVE_INFINITY,
							i = this._controllerLayers[r];
						if (i) {
							var a = i._statesMap[e];
							if (a) {
								var o = i._playType;
								if (-1 === o) return void this.play(e, r, n);
								var s = i._crossPlayStateInfo,
									l = i._crossNodesOwners,
									u = i._crossNodesOwnersIndicesMap,
									c = i._playStateInfo._currentState,
									h = a._nodeOwners,
									_ = i._destCrossClipNodeIndices,
									d = a._clip,
									f = d._nodes,
									m = d._nodesDic;
								switch (o) {
									case 0:
										var p = c._nodeOwners,
											T = i._srcCrossClipNodeIndices,
											E = c._clip,
											g = E._nodes,
											y = E._nodesDic;
										i._playType = 1;
										for (var S = ++i._crossMark, v = i._crossNodesOwnersCount = 0,
												R = 0, C = g.count; R < C; R++) {
											var M = g.getNodeByIndex(R),
												D = M._indexInList,
												x = p[D];
											if (x) {
												var A = M.fullPath;
												T[v] = D;
												var I = m[A];
												_[v] = I ? I._indexInList : -1, u[A] = S, l[v] = x, v++
											}
										}
										for (R = 0, C = f.count; R < C; R++) {
											var L = (I = f.getNodeByIndex(R))._indexInList,
												P = h[L];
											if (P) {
												var O = I.fullPath;
												y[O] || (T[v] = -1, _[v] = L, u[O] = S, l[v] = P, v++)
											}
										}
										break;
									case 1:
									case 2:
										for (i._playType = 2, R = 0, C = l.length; R < C; R++) {
											var N = l[R];
											N.saveCrossFixedValue(), I = m[N.fullPath], _[R] = I ? I
												._indexInList : -1
										}
										for (v = i._crossNodesOwnersCount, S = i._crossMark, R = 0, C =
											f.count; R < C; R++)(P = h[L = (I = f.getNodeByIndex(R))
											._indexInList]) && u[O = I.fullPath] !== S && (_[v] = L,
											u[O] = S, N = h[L], l[v] = N, N.saveCrossFixedValue(),
											v++)
								}
								i._crossNodesOwnersCount = v, i._crossPlayState = a, i._crossDuration =
									c._clip._duration * t, n !== Number.NEGATIVE_INFINITY ? s
									._resetPlayState(d._duration * n) : s._resetPlayState(0);
								var b = a._scripts;
								if (b)
									for (R = 0, C = b.length; R < C; R++) b[R].onStateEnter()
							} else console.warn("Invalid name " + r + ".")
						} else console.warn("Invalid layerIndex " + r + ".")
					}
				}, {
					key: "getCurrentAnimatorPlayState",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
						return this._controllerLayers[e]._playStateInfo
					}
				}, {
					key: "_isLinkSpriteToAnimationNodeData",
					value: function(e, t, r) {
						var n = this._linkAvatarSpritesData[t];
						if (r) n || (this._linkAvatarSpritesData[t] = n = []), n.push(e);
						else {
							var i = n.indexOf(e);
							n.splice(i, 1)
						}
					}
				}, {
					key: "_getAvatarOwnersAndInitDatasAsync",
					value: function() {
						for (var e = 0, t = this._controllerLayers.length; e < t; e++)
							for (var r = this._controllerLayers[e]._states, n = 0, i = r.length; n <
								i; n++) this._getOwnersByClip(r[n]);
						for (var a in this._avatar._cloneDatasToAnimator(this), this
								._linkAvatarSpritesData) {
							var o = this._linkAvatarSpritesData[a];
							if (o)
								for (var s = 0, l = o.length; s < l; s++) this
									._isLinkSpriteToAnimationNode(o[s], a, !0)
						}
					}
				}, {
					key: "_isLinkSpriteToAnimationNode",
					value: function(e, t, r) {
						if (this._avatar) {
							var n = this._avatarNodeMap[t];
							if (n)
								if (r) {
									e._transform._dummy = n.transform, this._linkAvatarSprites.push(e);
									var i = n.transform,
										a = e.transform;
									if (!a.owner.isStatic && i) {
										var o = a.worldMatrix,
											s = this.owner._transform._parent;
										if (s) P.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(),
											o);
										else
											for (var l = o.elements, u = i.getWorldMatrix(), c = 0; c <
												16; c++) l[c] = u[c];
										a.worldMatrix = o
									}
								} else e._transform._dummy = null, this._linkAvatarSprites.splice(this
									._linkAvatarSprites.indexOf(e), 1)
						}
					}
				}, {
					key: "_updateAvatarNodesToSprite",
					value: function() {
						for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
							var r = this._linkAvatarSprites[e],
								n = r.transform._dummy,
								i = r.transform;
							if (!i.owner.isStatic && n) {
								var a = i.worldMatrix,
									o = this.owner._transform;
								P.matrix4x4MultiplyMFM(o.worldMatrix, n.getWorldMatrix(), a), i
									.worldMatrix = a
							}
						}
					}
				}, {
					key: "linkSprite3DToAvatarNode",
					value: function(e, t) {
						return this._isLinkSpriteToAnimationNodeData(t, e, !0), this
							._isLinkSpriteToAnimationNode(t, e, !0), !0
					}
				}, {
					key: "unLinkSprite3DToAvatarNode",
					value: function(e) {
						var t = e.transform._dummy;
						if (t) {
							var r = t._owner.name;
							return this._isLinkSpriteToAnimationNodeData(e, r, !1), this
								._isLinkSpriteToAnimationNode(e, r, !1), !0
						}
						return !1
					}
				}, {
					key: "_updateAnimationNodeWorldMatix",
					value: function(e, r, n, i, a) {
						t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, n, a, i)
					}
				}, {
					key: "speed",
					get: function() {
						return this._speed
					},
					set: function(e) {
						this._speed = e
					}
				}, {
					key: "avatar",
					get: function() {
						return this._avatar
					},
					set: function(e) {
						if (this._avatar !== e)
							if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(), this
								.owner._changeHierarchyAnimatorAvatar(this, e);
							else {
								var t = this.owner._parent;
								this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator
									._avatar : null)
							}
					}
				}], [{
					key: "_update",
					value: function(e) {
						for (var t = e._animatorPool, r = t.elements, n = 0, i = t.length; n < i; n++) {
							var a = r[n];
							a && a.enabled && a._update()
						}
					}
				}]), Animator
			}(t.Component);
		K._tempVector30 = new o, K._tempVector31 = new o, K._tempQuaternion0 = new u, K._tempQuaternion1 = new u, K
			.CULLINGMODE_ALWAYSANIMATE = 0, K.CULLINGMODE_CULLCOMPLETELY = 2;
		var J = function RenderContext3D() {
			_classCallCheck(this, RenderContext3D), this.invertY = !1
		};
		J._instance = new J;
		var $ = function(e) {
			function RenderTexture(e, r) {
				var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat
					.R8G8B8,
					a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat
					.DEPTH_16;
				return _classCallCheck(this, RenderTexture), (n = _possibleConstructorReturn(this, _getPrototypeOf(
						RenderTexture).call(this, i, !1)))._inPool = !1, n._isCameraTarget = !1, n._glTextureType =
					t.LayaGL.instance.TEXTURE_2D, n._width = e, n._height = r, n._depthStencilFormat = a, n
					._mipmapCount = 1, n._create(e, r), n
			}
			return _inherits(RenderTexture, e), _createClass(RenderTexture, [{
				key: "_create",
				value: function(e, r) {
					var n = t.LayaGL.instance,
						i = n,
						a = this._glTextureType,
						o = t.LayaGL.layaGPUInstance,
						s = o._isWebGL2,
						l = this._format;
					if (this._frameBuffer = n.createFramebuffer(), n.bindFramebuffer(n.FRAMEBUFFER,
							this._frameBuffer), l !== t.RenderTextureFormat.Depth && l !== t
						.RenderTextureFormat.ShadowMap) {
						switch (t.WebGLContext.bindTexture(n, a, this._glTexture), l) {
							case t.RenderTextureFormat.R8G8B8:
								s ? i.texStorage2D(a, this._mipmapCount, i.RGB8, e, r) : n
									.texImage2D(a, 0, n.RGB, e, r, 0, n.RGB, n.UNSIGNED_BYTE, null);
								break;
							case t.RenderTextureFormat.R8G8B8A8:
								s ? i.texStorage2D(a, this._mipmapCount, i.RGBA8, e, r) : n
									.texImage2D(a, 0, n.RGBA, e, r, 0, n.RGBA, n.UNSIGNED_BYTE,
										null);
								break;
							case t.RenderTextureFormat.Alpha8:
								s ? i.texStorage2D(a, 0, i.R8, e, r) : n.texImage2D(a, 0, n.ALPHA,
									e, r, 0, n.ALPHA, n.UNSIGNED_BYTE, null);
								break;
							case t.RenderTextureFormat.R16G16B16A16:
								s ? i.texStorage2D(a, this._mipmapCount, i.RGBA16F, e, r) : n
									.texImage2D(a, 0, n.RGBA, e, r, 0, n.RGBA, o
										._oesTextureHalfFloat.HALF_FLOAT_OES, null)
						}
						n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D,
							this._glTexture, 0)
					}
					if (l == t.RenderTextureFormat.Depth || l == t.RenderTextureFormat.ShadowMap) {
						switch (t.WebGLContext.bindTexture(n, a, this._glTexture), this
							._depthStencilFormat) {
							case t.RenderTextureDepthFormat.DEPTH_16:
								s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH_COMPONENT16, e,
									r) : n.texImage2D(a, 0, n.DEPTH_COMPONENT, e, r, 0, n
										.DEPTH_COMPONENT, n.UNSIGNED_SHORT, null), n
									.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n
										.TEXTURE_2D, this._glTexture, 0);
								break;
							case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
								s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH24_STENCIL8, e, r) :
									n.texImage2D(a, 0, n.DEPTH_STENCIL, e, r, 0, n.DEPTH_STENCIL, o
										._webgl_depth_texture.UNSIGNED_INT_24_8_WEBGL, null), n
									.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT,
										n.TEXTURE_2D, this._glTexture, 0);
								break;
							default:
								throw "RenderTexture: depth format RenderTexture must use depthFormat with DEPTH_16 and DEPTHSTENCIL_16_8."
						}
						s && l == t.RenderTextureFormat.ShadowMap && i.texParameteri(a, i
							.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)
					} else if (this._depthStencilFormat !== t.RenderTextureDepthFormat
						.DEPTHSTENCIL_NONE) {
						switch (this._depthStencilBuffer = n.createRenderbuffer(), n
							.bindRenderbuffer(n.RENDERBUFFER, this._depthStencilBuffer), this
							._depthStencilFormat) {
							case t.RenderTextureDepthFormat.DEPTH_16:
								n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, e, r), n
									.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n
										.RENDERBUFFER, this._depthStencilBuffer);
								break;
							case t.RenderTextureDepthFormat.STENCIL_8:
								n.renderbufferStorage(n.RENDERBUFFER, n.STENCIL_INDEX8, e, r), n
									.framebufferRenderbuffer(n.FRAMEBUFFER, n.STENCIL_ATTACHMENT, n
										.RENDERBUFFER, this._depthStencilBuffer);
								break;
							case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
								n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, e, r), n
									.framebufferRenderbuffer(n.FRAMEBUFFER, n
										.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, this
										._depthStencilBuffer);
								break;
							default:
								throw "RenderTexture: unkonw depth format."
						}
						n.bindRenderbuffer(n.RENDERBUFFER, null)
					}
					n.bindFramebuffer(n.FRAMEBUFFER, null), this._setWarpMode(n.TEXTURE_WRAP_S, this
							._wrapModeU), this._setWarpMode(n.TEXTURE_WRAP_T, this._wrapModeV), this
						._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel),
						this._readyed = !0, this._activeResource(), this._setGPUMemory(e * r * 4)
				}
			}, {
				key: "_start",
				value: function() {
					var e = t.LayaGL.instance;
					e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), RenderTexture
						._currentActive = this, this._isCameraTarget && (J._instance.invertY = !0),
						this._readyed = !1
				}
			}, {
				key: "_end",
				value: function() {
					var e = t.LayaGL.instance;
					e.bindFramebuffer(e.FRAMEBUFFER, null), RenderTexture._currentActive = null,
						this._isCameraTarget && (J._instance.invertY = !1), this._readyed = !0
				}
			}, {
				key: "getData",
				value: function(e, r, n, i, a) {
					if (t.Render.isConchApp && 2 == window.conchConfig.threadMode)
					throw "native 2 thread mode use getDataAsync";
					var o = t.LayaGL.instance;
					return o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o
						.checkFramebufferStatus(o.FRAMEBUFFER) === o.FRAMEBUFFER_COMPLETE ? (o
							.readPixels(e, r, n, i, o.RGBA, o.UNSIGNED_BYTE, a), o.bindFramebuffer(o
								.FRAMEBUFFER, null), a) : (o.bindFramebuffer(o.FRAMEBUFFER, null),
							null)
				}
			}, {
				key: "_disposeResource",
				value: function() {
					if (this._frameBuffer) {
						var e = t.LayaGL.instance;
						e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e
							.deleteRenderbuffer(this._depthStencilBuffer), this._glTexture = null,
							this._frameBuffer = null, this._depthStencilBuffer = null, this
							._setGPUMemory(0)
					}
				}
			}, {
				key: "getDataAsync",
				value: function(e, r, n, i, a) {
					var o = t.LayaGL.instance;
					o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o.readPixelsAsync(e, r, n,
						i, o.RGBA, o.UNSIGNED_BYTE, (function(e) {
							a(new Uint8Array(e))
						})), o.bindFramebuffer(o.FRAMEBUFFER, null)
				}
			}, {
				key: "depthStencilFormat",
				get: function() {
					return this._depthStencilFormat
				}
			}, {
				key: "defaulteTexture",
				get: function() {
					return t.Texture2D.grayTexture
				}
			}], [{
				key: "createFromPool",
				value: function(e, r) {
					for (var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
							t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !==
							arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16, o =
							0, s = RenderTexture._pool.length; o < s; o++)
						if ((n = RenderTexture._pool[o])._width == e && n._height == r && n
							._format == i && n._depthStencilFormat == a) {
							n._inPool = !1;
							var l = RenderTexture._pool[s - 1];
							return RenderTexture._pool[o] = l, RenderTexture._pool.length -= 1, n
						} return (n = new RenderTexture(e, r, i, a)).lock = !0, n
				}
			}, {
				key: "recoverToPool",
				value: function(e) {
					e._inPool || (RenderTexture._pool.push(e), e._inPool = !0)
				}
			}, {
				key: "currentActive",
				get: function() {
					return RenderTexture._currentActive
				}
			}]), RenderTexture
		}(t.BaseTexture);
		$._pool = [];
		var ee = function() {
				function DefineDatas() {
					_classCallCheck(this, DefineDatas), this._mask = [], this._length = 0
				}
				return _createClass(DefineDatas, [{
					key: "_intersectionDefineDatas",
					value: function(e) {
						for (var t = e._mask, r = this._mask, n = this._length - 1; n >= 0; n--) {
							var i = r[n] & t[n];
							0 == i && n == this._length - 1 ? this._length-- : r[n] = i
						}
					}
				}, {
					key: "add",
					value: function(e) {
						var t = e._index,
							r = t + 1,
							n = this._mask,
							i = this._length;
						if (i < r) {
							for (n.length < r && (n.length = r); i < t; i++) n[i] = 0;
							n[t] = e._value, this._length = r
						} else n[t] |= e._value
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._index,
							r = this._mask,
							n = this._length - 1;
						if (!(t > n)) {
							var i = r[t] & ~e._value;
							t == n && 0 === i ? this._length-- : r[t] = i
						}
					}
				}, {
					key: "addDefineDatas",
					value: function(e) {
						var t = e._mask,
							r = e._length,
							n = this._mask,
							i = this._length;
						if (i < r) {
							n.length = r;
							for (var a = 0; a < i; a++) n[a] |= t[a];
							for (; a < r; a++) n[a] = t[a];
							this._length = r
						} else
							for (a = 0; a < r; a++) n[a] |= t[a]
					}
				}, {
					key: "removeDefineDatas",
					value: function(e) {
						for (var t = e._mask, r = this._mask, n = this._length - 1, i = Math.min(e
								._length, n); i >= 0; i--) {
							var a = r[i] & ~t[i];
							i == n && 0 === a ? (n--, this._length--) : r[i] = a
						}
					}
				}, {
					key: "has",
					value: function(e) {
						var t = e._index;
						return !(t >= this._length) && 0 != (this._mask[t] & e._value)
					}
				}, {
					key: "clear",
					value: function() {
						this._length = 0
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e,
							r = t._mask,
							n = this._mask,
							i = this._length;
						r.length = i;
						for (var a = 0; a < i; a++) r[a] = n[a];
						t._length = i
					}
				}, {
					key: "clone",
					value: function() {
						var e = new DefineDatas;
						return this.cloneTo(e), e
					}
				}]), DefineDatas
			}(),
			te = function(e) {
				function VertexBuffer3D(e, r) {
					var n, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
					_classCallCheck(this, VertexBuffer3D), (n = _possibleConstructorReturn(this, _getPrototypeOf(
						VertexBuffer3D).call(this)))._vertexDeclaration = null, n._float32Reader = null;
					var a = t.LayaGL.instance;
					return n._bufferUsage = r, n._bufferType = a.ARRAY_BUFFER, n._canRead = i, n._byteLength = e, n
						.bind(), a.bufferData(n._bufferType, n._byteLength, n._bufferUsage), i && (n._buffer =
							new Uint8Array(e), n._float32Reader = new Float32Array(n._buffer.buffer)), n
				}
				return _inherits(VertexBuffer3D, e), _createClass(VertexBuffer3D, [{
					key: "bind",
					value: function() {
						if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
							var e = t.LayaGL.instance;
							return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer
								._bindedVertexBuffer = this._glBuffer, !0
						}
						return !1
					}
				}, {
					key: "orphanStorage",
					value: function() {
						this.bind(), t.LayaGL.instance.bufferData(this._bufferType, this._byteLength,
							this._bufferUsage)
					}
				}, {
					key: "setData",
					value: function(e) {
						var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
							i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number
							.MAX_SAFE_INTEGER;
						this.bind();
						var a = 0 !== n || i !== Number.MAX_SAFE_INTEGER;
						if (a) {
							var o = new Uint8Array(e, n, i);
							t.LayaGL.instance.bufferSubData(this._bufferType, r, o), this._canRead &&
								this._buffer.set(o, r)
						} else t.LayaGL.instance.bufferSubData(this._bufferType, r, e), this._canRead &&
							this._buffer.set(new Uint8Array(e), r)
					}
				}, {
					key: "getUint8Data",
					value: function() {
						if (this._canRead) return this._buffer;
						throw new Error("Can't read data from VertexBuffer with only write flag!")
					}
				}, {
					key: "getFloat32Data",
					value: function() {
						if (this._canRead) return this._float32Reader;
						throw new Error("Can't read data from VertexBuffer with only write flag!")
					}
				}, {
					key: "markAsUnreadbale",
					value: function() {
						this._canRead = !1, this._buffer = null, this._float32Reader = null
					}
				}, {
					key: "destroy",
					value: function() {
						_get(_getPrototypeOf(VertexBuffer3D.prototype), "destroy", this).call(this),
							this._buffer = null, this._float32Reader = null, this._vertexDeclaration =
							null, this._byteLength = 0
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return this._vertexDeclaration
					},
					set: function(e) {
						this._vertexDeclaration = e
					}
				}, {
					key: "canRead",
					get: function() {
						return this._canRead
					}
				}]), VertexBuffer3D
			}(t.Buffer);
		te.DATATYPE_FLOAT32ARRAY = 0, te.DATATYPE_UINT8ARRAY = 1;
		var re = function() {
			function VertexElementFormat() {
				_classCallCheck(this, VertexElementFormat)
			}
			return _createClass(VertexElementFormat, null, [{
				key: "__init__",
				value: function() {
					var e = t.LayaGL.instance;
					VertexElementFormat._elementInfos = {
						single: [1, e.FLOAT, 0],
						vector2: [2, e.FLOAT, 0],
						vector3: [3, e.FLOAT, 0],
						vector4: [4, e.FLOAT, 0],
						color: [4, e.FLOAT, 0],
						byte4: [4, e.UNSIGNED_BYTE, 0],
						short2: [2, e.FLOAT, 0],
						short4: [4, e.FLOAT, 0],
						normalizedshort2: [2, e.FLOAT, 0],
						normalizedshort4: [4, e.FLOAT, 0],
						halfvector2: [2, e.FLOAT, 0],
						halfvector4: [4, e.FLOAT, 0]
					}
				}
			}, {
				key: "getElementInfos",
				value: function(e) {
					var t = VertexElementFormat._elementInfos[e];
					if (t) return t;
					throw "VertexElementFormat: this vertexElementFormat is not implement."
				}
			}]), VertexElementFormat
		}();
		re.Single = "single", re.Vector2 = "vector2", re.Vector3 = "vector3", re.Vector4 = "vector4", re.Color =
			"color", re.Byte4 = "byte4", re.Short2 = "short2", re.Short4 = "short4", re.NormalizedShort2 =
			"normalizedshort2", re.NormalizedShort4 = "normalizedshort4", re.HalfVector2 = "halfvector2", re
			.HalfVector4 = "halfvector4";
		var ne = function() {
			function ShaderData() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
				_classCallCheck(this, ShaderData), this._ownerResource = null, this._data = null, this
					._defineDatas = new ee, this._runtimeCopyValues = [], this._ownerResource = e, this._initData()
			}
			return _createClass(ShaderData, [{
				key: "_initData",
				value: function() {
					this._data = new Object
				}
			}, {
				key: "getData",
				value: function() {
					return this._data
				}
			}, {
				key: "addDefine",
				value: function(e) {
					this._defineDatas.add(e)
				}
			}, {
				key: "removeDefine",
				value: function(e) {
					this._defineDatas.remove(e)
				}
			}, {
				key: "hasDefine",
				value: function(e) {
					return this._defineDatas.has(e)
				}
			}, {
				key: "clearDefine",
				value: function() {
					this._defineDatas.clear()
				}
			}, {
				key: "getBool",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setBool",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getInt",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setInt",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getNumber",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setNumber",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getVector2",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setVector2",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getVector3",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setVector3",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getVector",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setVector",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getQuaternion",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setQuaternion",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getMatrix4x4",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setMatrix4x4",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getBuffer",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setBuffer",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "setTexture",
				value: function(e, t) {
					var r = this._data[e];
					this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount >
						0 && (r && r._removeReference(), t && t._addReference())
				}
			}, {
				key: "getTexture",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "setAttribute",
				value: function(e, t) {
					this._data[e] = t
				}
			}, {
				key: "getAttribute",
				value: function(e) {
					return this._data[e]
				}
			}, {
				key: "getLength",
				value: function() {
					return this._data.length
				}
			}, {
				key: "setLength",
				value: function(e) {
					this._data.length = e
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var r = e,
						a = r._data;
					for (var s in this._data) {
						var l = this._data[s];
						if (null != l)
							if ("number" == typeof l) a[s] = l;
							else if ("number" == typeof l) a[s] = l;
						else if ("boolean" == typeof l) a[s] = l;
						else if (l instanceof n) {
							var u = a[s] || (a[s] = new n);
							l.cloneTo(u), a[s] = u
						} else if (l instanceof o) {
							var h = a[s] || (a[s] = new o);
							l.cloneTo(h), a[s] = h
						} else if (l instanceof i) {
							var _ = a[s] || (a[s] = new i);
							l.cloneTo(_), a[s] = _
						} else if (l instanceof c) {
							var d = a[s] || (a[s] = new c);
							l.cloneTo(d), a[s] = d
						} else l instanceof t.BaseTexture && (a[s] = l)
					}
					this._defineDatas.cloneTo(r._defineDatas)
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ShaderData;
					return this.cloneTo(e), e
				}
			}, {
				key: "cloneToForNative",
				value: function(e) {
					var r = e;
					this._int32Data.length - r._int32Data.length > 0 && r
						.needRenewArrayBufferForNative(this._int32Data.length), r._int32Data.set(
							this._int32Data, 0);
					var a = r._nativeArray,
						s = this._nativeArray.length;
					a.length = s;
					for (var l = 0; l < s; l++) {
						var u = this._nativeArray[l];
						if (u)
							if ("number" == typeof u) a[l] = u, r.setNumber(l, u);
							else if ("number" == typeof u) a[l] = u, r.setInt(l, u);
						else if ("boolean" == typeof u) a[l] = u, r.setBool(l, u);
						else if (u instanceof n) {
							var h = a[l] || (a[l] = new n);
							u.cloneTo(h), a[l] = h, r.setVector2(l, h)
						} else if (u instanceof o) {
							var _ = a[l] || (a[l] = new o);
							u.cloneTo(_), a[l] = _, r.setVector3(l, _)
						} else if (u instanceof i) {
							var d = a[l] || (a[l] = new i);
							u.cloneTo(d), a[l] = d, r.setVector(l, d)
						} else if (u instanceof c) {
							var f = a[l] || (a[l] = new c);
							u.cloneTo(f), a[l] = f, r.setMatrix4x4(l, f)
						} else u instanceof t.BaseTexture && (a[l] = u, r.setTexture(l, u))
					}
					this._defineDatas.cloneTo(r._defineDatas)
				}
			}, {
				key: "_initDataForNative",
				value: function() {
					this._frameCount = -1, this._runtimeCopyValues.length = 0, this
						._nativeArray = [], this._data = new ArrayBuffer(32), this._int32Data =
						new Int32Array(this._data), this._float32Data = new Float32Array(this
						._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL
							.ARRAY_BUFFER_TYPE_DATA, !0)
				}
			}, {
				key: "needRenewArrayBufferForNative",
				value: function(e) {
					if (e >= this._int32Data.length) {
						var r = 4 * (e + 1),
							n = this._int32Data,
							i = this._data.conchRef,
							a = this._data._ptrID;
						this._data = new ArrayBuffer(r), this._int32Data = new Int32Array(this
								._data), this._float32Data = new Float32Array(this._data), this
							._data.conchRef = i, this._data._ptrID = a, n && this._int32Data.set(n,
								0);
						var o = t.LayaGL.instance;
						o.updateArrayBufferRef ? o.updateArrayBufferRef(this._data._ptrID, i
							.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(
							this._data._ptrID, i.isSyncToRender(), this._data)
					}
				}
			}, {
				key: "getDataForNative",
				value: function() {
					return this._nativeArray
				}
			}, {
				key: "getIntForNative",
				value: function(e) {
					return this._int32Data[e]
				}
			}, {
				key: "setIntForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this
						._nativeArray[e] = t
				}
			}, {
				key: "getBoolForNative",
				value: function(e) {
					return 1 == this._int32Data[e]
				}
			}, {
				key: "setBoolForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this
						._nativeArray[e] = t
				}
			}, {
				key: "getNumberForNative",
				value: function(e) {
					return this._float32Data[e]
				}
			}, {
				key: "setNumberForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this
						._nativeArray[e] = t
				}
			}, {
				key: "getMatrix4x4ForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setMatrix4x4ForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
					var r = this.setReferenceForNative(t.elements);
					this._int32Data[e] = r
				}
			}, {
				key: "getVectorForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setVectorForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t
						.forNativeElement();
					var r = this.setReferenceForNative(t.elements);
					this._int32Data[e] = r
				}
			}, {
				key: "getVector2ForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setVector2ForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t
						.forNativeElement();
					var r = this.setReferenceForNative(t.elements);
					this._int32Data[e] = r
				}
			}, {
				key: "getVector3ForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setVector3ForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t
						.forNativeElement();
					var r = this.setReferenceForNative(t.elements);
					this._int32Data[e] = r
				}
			}, {
				key: "getQuaternionForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setQuaternionForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t
						.forNativeElement();
					var r = this.setReferenceForNative(t.elements);
					this._int32Data[e] = r
				}
			}, {
				key: "getBufferForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setBufferForNative",
				value: function(e, t) {
					this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
					var r = this.setReferenceForNative(t);
					this._int32Data[e] = r
				}
			}, {
				key: "getAttributeForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setAttributeForNative",
				value: function(e, r) {
					this._nativeArray[e] = r, r._ptrID || t.LayaGL.instance.createArrayBufferRef(r,
							t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0), t.LayaGL.instance
						.syncBufferToRenderThread(r), this._int32Data[e] = r._ptrID
				}
			}, {
				key: "getTextureForNative",
				value: function(e) {
					return this._nativeArray[e]
				}
			}, {
				key: "setTextureForNative",
				value: function(e, t) {
					if (t) {
						this.needRenewArrayBufferForNative(e);
						var r = this._nativeArray[e];
						this._nativeArray[e] = t;
						var n = t._getSource() || t.defaulteTexture._getSource();
						this._int32Data[e] = n.id, this._ownerResource && this._ownerResource
							.referenceCount > 0 && (r && r._removeReference(), t && t
							._addReference())
					}
				}
			}, {
				key: "setReferenceForNative",
				value: function(e) {
					this.clearRuntimeCopyArray();
					var r = 0,
						n = 0;
					return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance
						.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL
							.ARRAY_BUFFER_REF_REFERENCE), r = 0, n = e.getPtrID(r)) : (t.LayaGL
						.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0,
							t.LayaGL.ARRAY_BUFFER_REF_COPY), r = e.getRefNum() - 1, n = e
						.getPtrID(r), this._runtimeCopyValues.push({
							obj: e,
							refID: r,
							ptrID: n
						})), t.LayaGL.instance.syncBufferToRenderThread(e, r), n
				}
			}, {
				key: "clearRuntimeCopyArray",
				value: function() {
					var e = t.Stat.loopCount;
					if (this._frameCount != e) {
						this._frameCount = e;
						for (var r = 0, n = this._runtimeCopyValues.length; r < n; r++) {
							this._runtimeCopyValues[r].obj.clearRefNum()
						}
						this._runtimeCopyValues.length = 0
					}
				}
			}], [{
				key: "setRuntimeValueMode",
				value: function(e) {
					ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e
				}
			}]), ShaderData
		}();
		ne._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
		var ie = function() {
			function VertexDeclaration(e, t) {
				_classCallCheck(this, VertexDeclaration), this._id = ++VertexDeclaration._uniqueIDCounter, this
					._vertexElementsDic = {}, this._vertexStride = e, this._vertexElements = t;
				var r = t.length;
				this._shaderValues = new ne(null);
				for (var n = 0; n < r; n++) {
					var i = t[n],
						a = i._elementUsage;
					this._vertexElementsDic[a] = i;
					var o = new Int32Array(5),
						s = re.getElementInfos(i._elementFormat);
					o[0] = s[0], o[1] = s[1], o[2] = s[2], o[3] = this._vertexStride, o[4] = i._offset, this
						._shaderValues.setAttribute(a, o)
				}
			}
			return _createClass(VertexDeclaration, [{
				key: "getVertexElementByIndex",
				value: function(e) {
					return this._vertexElements[e]
				}
			}, {
				key: "getVertexElementByUsage",
				value: function(e) {
					return this._vertexElementsDic[e]
				}
			}, {
				key: "id",
				get: function() {
					return this._id
				}
			}, {
				key: "vertexStride",
				get: function() {
					return this._vertexStride
				}
			}, {
				key: "vertexElementCount",
				get: function() {
					return this._vertexElements.length
				}
			}]), VertexDeclaration
		}();
		ie._uniqueIDCounter = 1;
		var ae = function() {
				function VertexElement(e, t, r) {
					_classCallCheck(this, VertexElement), this._offset = e, this._elementFormat = t, this
						._elementUsage = r
				}
				return _createClass(VertexElement, [{
					key: "offset",
					get: function() {
						return this._offset
					}
				}, {
					key: "elementFormat",
					get: function() {
						return this._elementFormat
					}
				}, {
					key: "elementUsage",
					get: function() {
						return this._elementUsage
					}
				}]), VertexElement
			}(),
			oe = function(e) {
				function BufferState() {
					return _classCallCheck(this, BufferState), _possibleConstructorReturn(this, _getPrototypeOf(
						BufferState).call(this))
				}
				return _inherits(BufferState, e), _createClass(BufferState, [{
					key: "applyVertexBuffer",
					value: function(e) {
						if (t.BufferStateBase._curBindedBufferState !== this)
						throw "BufferState: must call bind() function first.";
						var r = t.LayaGL.instance,
							n = e.vertexDeclaration,
							i = n._shaderValues.getData();
						for (var a in this.vertexDeclaration = n, e.bind(), i) {
							var o = parseInt(a),
								s = i[a];
							r.enableVertexAttribArray(o), r.vertexAttribPointer(o, s[0], s[1], !!s[2],
								s[3], s[4])
						}
					}
				}, {
					key: "applyVertexBuffers",
					value: function(e) {
						if (t.BufferStateBase._curBindedBufferState !== this)
						throw "BufferState: must call bind() function first.";
						for (var r = t.LayaGL.instance, n = 0, i = e.length; n < i; n++) {
							var a = e[n],
								o = a.vertexDeclaration._shaderValues.getData();
							for (var s in a.bind(), o) {
								var l = parseInt(s),
									u = o[s];
								r.enableVertexAttribArray(l), r.vertexAttribPointer(l, u[0], u[1], !!u[
									2], u[3], u[4])
							}
						}
					}
				}, {
					key: "applyInstanceVertexBuffer",
					value: function(e) {
						if (t.LayaGL.layaGPUInstance.supportInstance()) {
							if (t.BufferStateBase._curBindedBufferState !== this)
							throw "BufferState: must call bind() function first.";
							var r = t.LayaGL.instance,
								n = e.vertexDeclaration._shaderValues.getData();
							for (var i in e.bind(), n) {
								var a = parseInt(i),
									o = n[i];
								r.enableVertexAttribArray(a), r.vertexAttribPointer(a, o[0], o[1], !!o[
									2], o[3], o[4]), t.LayaGL.layaGPUInstance.vertexAttribDivisor(a,
									1)
							}
						}
					}
				}, {
					key: "applyIndexBuffer",
					value: function(e) {
						if (t.BufferStateBase._curBindedBufferState !== this)
						throw "BufferState: must call bind() function first.";
						this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e)
					}
				}]), BufferState
			}(t.BufferStateBase),
			se = function(e) {
				function ScreenQuad() {
					var e;
					_classCallCheck(this, ScreenQuad), (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenQuad)
						.call(this)))._bufferState = new oe, e._bufferStateInvertUV = new oe;
					var r = t.LayaGL.instance;
					return e._vertexBuffer = new te(64, r.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration =
						ScreenQuad._vertexDeclaration, e._vertexBuffer.setData(ScreenQuad._vertices.buffer), e
						._bufferState.bind(), e._bufferState.applyVertexBuffer(e._vertexBuffer), e._bufferState
					.unBind(), e._vertexBufferInvertUV = new te(64, r.STATIC_DRAW, !1), e._vertexBufferInvertUV
						.vertexDeclaration = ScreenQuad._vertexDeclaration, e._vertexBufferInvertUV.setData(ScreenQuad
							._verticesInvertUV.buffer), e._bufferStateInvertUV.bind(), e._bufferStateInvertUV
						.applyVertexBuffer(e._vertexBufferInvertUV), e._bufferStateInvertUV.unBind(), e._setGPUMemory(e
							._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength), e
				}
				return _inherits(ScreenQuad, e), _createClass(ScreenQuad, [{
					key: "render",
					value: function() {
						var e = t.LayaGL.instance;
						this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat
							.renderBatches++
					}
				}, {
					key: "renderInvertUV",
					value: function() {
						var e = t.LayaGL.instance;
						this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat
							.renderBatches++
					}
				}, {
					key: "destroy",
					value: function() {
						_get(_getPrototypeOf(ScreenQuad.prototype), "destroy", this).call(this), this
							._bufferState.destroy(), this._vertexBuffer.destroy(), this
							._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), this
							._setGPUMemory(0)
					}
				}], [{
					key: "__init__",
					value: function() {
						ScreenQuad._vertexDeclaration = new ie(16, [new ae(0, re.Vector4, ScreenQuad
								.SCREENQUAD_POSITION_UV)]), ScreenQuad.instance = new ScreenQuad,
							ScreenQuad.instance.lock = !0
					}
				}]), ScreenQuad
			}(t.Resource);
		se.SCREENQUAD_POSITION_UV = 0, se._vertices = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0,
			0
		]), se._verticesInvertUV = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);
		var le = function(e) {
			function ScreenTriangle() {
				var e;
				_classCallCheck(this, ScreenTriangle), (e = _possibleConstructorReturn(this, _getPrototypeOf(
					ScreenTriangle).call(this)))._bufferState = new oe, e._bufferStateInvertUV = new oe;
				var r = t.LayaGL.instance;
				return e._vertexBuffer = new te(48, r.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration =
					ScreenTriangle._vertexDeclaration, e._vertexBuffer.setData(ScreenTriangle._vertices.buffer), e
					._bufferState.bind(), e._bufferState.applyVertexBuffer(e._vertexBuffer), e._bufferState
				.unBind(), e._vertexBufferInvertUV = new te(48, r.STATIC_DRAW, !1), e._vertexBufferInvertUV
					.vertexDeclaration = ScreenTriangle._vertexDeclaration, e._vertexBufferInvertUV.setData(
						ScreenTriangle._verticesInvertUV.buffer), e._bufferStateInvertUV.bind(), e
					._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV), e._bufferStateInvertUV
					.unBind(), e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength), e
			}
			return _inherits(ScreenTriangle, e), _createClass(ScreenTriangle, [{
				key: "render",
				value: function() {
					var e = t.LayaGL.instance;
					this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat
						.renderBatches++
				}
			}, {
				key: "renderInvertUV",
				value: function() {
					var e = t.LayaGL.instance;
					this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat
						.renderBatches++
				}
			}, {
				key: "destroy",
				value: function() {
					_get(_getPrototypeOf(ScreenTriangle.prototype), "destroy", this).call(this),
						this._bufferState.destroy(), this._vertexBuffer.destroy(), this
						._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(), this
						._setGPUMemory(0)
				}
			}], [{
				key: "__init__",
				value: function() {
					ScreenTriangle._vertexDeclaration = new ie(16, [new ae(0, re.Vector4,
							ScreenTriangle.SCREENTRIANGLE_POSITION_UV)]), ScreenTriangle.instance =
						new ScreenTriangle, ScreenTriangle.instance.lock = !0
				}
			}]), ScreenTriangle
		}(t.Resource);
		le.SCREENTRIANGLE_POSITION_UV = 0, le._vertices = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]), le
			._verticesInvertUV = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]);
		var ue = function ShaderDefine(e, t) {
				_classCallCheck(this, ShaderDefine), this._index = e, this._value = t
			},
			ce = function() {
				function ShaderVariant(e, t, r, n) {
					_classCallCheck(this, ShaderVariant), this._subShaderIndex = 0, this._passIndex = 0, this.setValue(
						e, t, r, n)
				}
				return _createClass(ShaderVariant, [{
					key: "setValue",
					value: function(e, t, r, n) {
						if (!e) throw "ShaderVariantInfo:Shader can't be null.";
						var i = e.getSubShaderAt(t);
						if (!i) throw "ShaderVariantInfo:Shader don't have subShaderIndex of ".concat(t,
							".");
						var a = i._passes[r];
						if (!a) throw "ShaderVariantInfo:Shader don't have passIndex of ".concat(r,
						".");
						for (var o = a._validDefine, s = 0, u = n.length; s < u; s++) {
							var c = n[s];
							if (!o.has(l.Shader3D.getDefineByName(c)))
							throw "ShaderVariantInfo:Invalid defineName ".concat(c, " in ").concat(e
									._name, " subShaderIndex of ").concat(t, " passIndex of ")
								.concat(r, ".")
						}
						this._shader = e, this._subShaderIndex = t, this._passIndex = r, this
							._defineNames = n
					}
				}, {
					key: "equal",
					value: function(e) {
						if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex ||
							this._passIndex !== e._passIndex) return !1;
						var t = this._defineNames,
							r = e._defineNames;
						if (t.length !== r.length) return !1;
						for (var n = 0, i = this._defineNames.length; n < i; n++)
							if (t[n] !== r[n]) return !1;
						return !0
					}
				}, {
					key: "clone",
					value: function() {
						return new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex,
							this._defineNames.slice())
					}
				}, {
					key: "shader",
					get: function() {
						return this._shader
					}
				}, {
					key: "subShaderIndex",
					get: function() {
						return this._subShaderIndex
					}
				}, {
					key: "passIndex",
					get: function() {
						return this._passIndex
					}
				}, {
					key: "defineNames",
					get: function() {
						return this._defineNames
					}
				}]), ShaderVariant
			}(),
			he = function() {
				function ShaderVariantCollection() {
					_classCallCheck(this, ShaderVariantCollection), this._allCompiled = !1, this._variants = []
				}
				return _createClass(ShaderVariantCollection, [{
					key: "add",
					value: function(e) {
						for (var t = 0, r = this._variants.length; t < r; t++)
							if (this._variants[t].equal(e)) return !1;
						return this._variants.push(e.clone()), this._allCompiled = !1, !0
					}
				}, {
					key: "remove",
					value: function(e) {
						for (var t = 0, r = this._variants.length; t < r; t++)
							if (this._variants[t].equal(e)) return this._variants.splice(t, 1), !0;
						return !1
					}
				}, {
					key: "contatins",
					value: function(e) {
						for (var t = 0, r = this._variants.length; t < r; t++)
							if (this._variants[t].equal(e)) return !0;
						return !1
					}
				}, {
					key: "getByIndex",
					value: function(e) {
						return this._variants[e]
					}
				}, {
					key: "clear",
					value: function() {
						this._variants.length = 0
					}
				}, {
					key: "compile",
					value: function() {
						if (!this._allCompiled) {
							for (var e = this._variants, t = 0, r = e.length; t < r; t++) {
								var n = e[t];
								l.Shader3D.compileShaderByDefineNames(n._shader._name, n
									._subShaderIndex, n._passIndex, n._defineNames)
							}
							this._allCompiled = !0
						}
					}
				}, {
					key: "allCompiled",
					get: function() {
						return this._allCompiled
					}
				}, {
					key: "variantCount",
					get: function() {
						return this._variants.length
					}
				}]), ShaderVariantCollection
			}(),
			_e = function() {
				function Shader3D(e, t, r, n, i) {
					_classCallCheck(this, Shader3D), this._attributeMap = null, this._uniformMap = null, this
						._enableInstancing = !1, this._supportReflectionProbe = !1, this._subShaders = [], this._name =
						e, this._attributeMap = t, this._uniformMap = r, this._enableInstancing = n, this
						._supportReflectionProbe = i
				}
				return _createClass(Shader3D, [{
					key: "addSubShader",
					value: function(e) {
						this._subShaders.push(e), e._owner = this
					}
				}, {
					key: "getSubShaderAt",
					value: function(e) {
						return this._subShaders[e]
					}
				}, {
					key: "name",
					get: function() {
						return this._name
					}
				}], [{
					key: "_getNamesByDefineData",
					value: function(e, t) {
						var r = Shader3D._maskMap,
							n = e._mask;
						t.length = 0;
						for (var i = 0, a = e._length; i < a; i++)
							for (var o = r[i], s = n[i], l = 0; l < 32; l++) {
								var u = 1 << l;
								if (s > 0 && u > s) break;
								s & u && t.push(o[u])
							}
					}
				}, {
					key: "getDefineByName",
					value: function(e) {
						var t = Shader3D._defineMap[e];
						if (!t) {
							var r = Shader3D._maskMap,
								n = Shader3D._defineCounter,
								i = Math.floor(n / 32),
								a = 1 << n % 32;
							t = new ue(i, a), Shader3D._defineMap[e] = t, i == r.length && (r.length++,
								r[i] = {}), r[i][a] = e, Shader3D._defineCounter++
						}
						return t
					}
				}, {
					key: "propertyNameToID",
					value: function(e) {
						if (null != Shader3D._propertyNameMap[e]) return Shader3D._propertyNameMap[e];
						var t = Shader3D._propertyNameCounter++;
						return Shader3D._propertyNameMap[e] = t, t
					}
				}, {
					key: "getAttributeMapByDefine",
					value: function(e, t) {
						var r = {};
						for (var n in t) r[n] = t[n];
						for (var i = 0, a = e.length; i < a; i++) {
							switch (e[i]) {
								case "SIMPLEBONE":
									t.a_Texcoord1 && (r.a_SimpleTextureParams = t.a_Texcoord1, delete r
										.a_Texcoord1), r.a_SimpleTextureParams = 7
							}
						}
						return r
					}
				}, {
					key: "addInclude",
					value: function(e, r) {
						r = r.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, r)
					}
				}, {
					key: "compileShaderByDefineNames",
					value: function(e, t, r, n) {
						var i = Shader3D.find(e);
						if (i) {
							var a = i.getSubShaderAt(t);
							if (a) {
								var o = a._passes[r];
								if (o) {
									var s = Shader3D._compileDefineDatas;
									s.clear();
									for (var l = 0, u = n.length; l < u; l++) s.add(Shader3D
										.getDefineByName(n[l]));
									o.withCompile(s)
								} else console.warn("Shader3D: unknown passIndex.")
							} else console.warn("Shader3D: unknown subShaderIndex.")
						} else console.warn("Shader3D: unknown shader name.")
					}
				}, {
					key: "add",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
							i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
						return Shader3D._preCompileShader[e] = new Shader3D(e, t, r, n, i)
					}
				}, {
					key: "find",
					value: function(e) {
						return Shader3D._preCompileShader[e]
					}
				}, {
					key: "compileShader",
					value: function(e, t, r) {
						var n = Shader3D.find(e);
						if (n) {
							var i = n.getSubShaderAt(t);
							if (i) {
								var a = i._passes[r];
								if (a) {
									var o = Shader3D._compileDefineDatas,
										s = o._mask;
									s.length = 0;
									for (var l = 0, u = arguments.length <= 3 ? 0 : arguments.length -
										3; l < u; l++) s.push(l + 3 < 3 || arguments.length <= l + 3 ?
										void 0 : arguments[l + 3]);
									o._length = arguments.length <= 3 ? 0 : arguments.length - 3, a
										.withCompile(o)
								} else console.warn("Shader3D: unknown passIndex.")
							} else console.warn("Shader3D: unknown subShaderIndex.")
						} else console.warn("Shader3D: unknown shader name.")
					}
				}]), Shader3D
			}();
		_e._compileDefineDatas = new ee, _e.RENDER_STATE_CULL = 0, _e.RENDER_STATE_BLEND = 1, _e
			.RENDER_STATE_BLEND_SRC = 2, _e.RENDER_STATE_BLEND_DST = 3, _e.RENDER_STATE_BLEND_SRC_RGB = 4, _e
			.RENDER_STATE_BLEND_DST_RGB = 5, _e.RENDER_STATE_BLEND_SRC_ALPHA = 6, _e.RENDER_STATE_BLEND_DST_ALPHA = 7,
			_e.RENDER_STATE_BLEND_CONST_COLOR = 8, _e.RENDER_STATE_BLEND_EQUATION = 9, _e
			.RENDER_STATE_BLEND_EQUATION_RGB = 10, _e.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, _e
			.RENDER_STATE_DEPTH_TEST = 12, _e.RENDER_STATE_DEPTH_WRITE = 13, _e.PERIOD_CUSTOM = 0, _e.PERIOD_MATERIAL =
			1, _e.PERIOD_SPRITE = 2, _e.PERIOD_CAMERA = 3, _e.PERIOD_SCENE = 4, _e._propertyNameCounter = 0, _e
			._propertyNameMap = {}, _e._defineCounter = 0, _e._defineMap = {}, _e._preCompileShader = {}, _e
			._maskMap = [], _e.debugMode = !1, _e.debugShaderVariantCollection = new he;
		var de = function() {
			function Command() {
				_classCallCheck(this, Command), this._commandBuffer = null
			}
			return _createClass(Command, [{
				key: "run",
				value: function() {}
			}, {
				key: "recover",
				value: function() {
					this._commandBuffer = null
				}
			}, {
				key: "setContext",
				value: function(e) {
					this._context = e
				}
			}], [{
				key: "__init__",
				value: function() {
					Command._screenShaderData = new ne, Command._screenShader = _e.find(
						"BlitScreen")
				}
			}]), Command
		}();
		de.SCREENTEXTURE_NAME = "u_MainTex", de.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale", de
			.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", de.SCREENTEXTURE_ID = _e.propertyNameToID(de
				.SCREENTEXTURE_NAME), de.SCREENTEXTUREOFFSETSCALE_ID = _e.propertyNameToID(de
				.SCREENTEXTUREOFFSETSCALE_NAME), de.MAINTEXTURE_TEXELSIZE_ID = _e.propertyNameToID(de
				.MAINTEXTURE_TEXELSIZE_NAME);
		var fe = function(e) {
			function BlitScreenQuadCMD() {
				var e;
				return _classCallCheck(this, BlitScreenQuadCMD), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(BlitScreenQuadCMD).apply(this, arguments)))._source = null, e._dest = null,
					e._offsetScale = null, e._shader = null, e._shaderData = null, e._subShader = 0, e
					._sourceTexelSize = new i, e._screenType = 0, e._drawDefineCavans = !1, e
			}
			return _inherits(BlitScreenQuadCMD, e), _createClass(BlitScreenQuadCMD, [{
				key: "run",
				value: function() {
					var e;
					if (this._source) e = this._source;
					else {
						if (!this._commandBuffer._camera._internalRenderTexture)
						throw "camera internalRenderTexture is null,please set camera enableBuiltInRenderTexture";
						e = this._commandBuffer._camera._internalRenderTexture
					}
					var r = this._shader || de._screenShader,
						n = this._shaderData || de._screenShaderData,
						i = this._dest ? this._dest : this._drawDefineCavans ? this._dest : this
						._commandBuffer._camera._internalRenderTexture;
					t.LayaGL.instance.viewport(0, 0, i ? i.width : J.clientWidth, i ? i.height : J
							.clientHeight), n.setTexture(de.SCREENTEXTURE_ID, e), n.setVector(de
							.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitScreenQuadCMD
							._defaultOffsetScale), this._sourceTexelSize.setValue(1 / e.width, 1 / e
							.height, e.width, e.height), n.setVector(de.MAINTEXTURE_TEXELSIZE_ID,
							this._sourceTexelSize), $.currentActive && $.currentActive._end(), i &&
						i._start();
					for (var a = r.getSubShaderAt(this._subShader)._passes, o = 0, s = a.length; o <
						s; o++) {
						var l = BlitScreenQuadCMD._compileDefine;
						n._defineDatas.cloneTo(l);
						var u = a[o].withCompile(l);
						switch (u.bind(), u.uploadUniforms(u._materialUniformParamsMap, n, !0), u
							.uploadRenderStateBlendDepth(n), u.uploadRenderStateFrontFace(n, !1,
								null), this._screenType) {
							case BlitScreenQuadCMD._SCREENTYPE_QUAD:
								J._instance.invertY ? se.instance.renderInvertUV() : se.instance
									.render();
								break;
							case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
								J._instance.invertY ? le.instance.renderInvertUV() : le.instance
									.render();
								break;
							default:
								throw "BlitScreenQuadCMD:unknown screen Type."
						}
					}
					i && i._end()
				}
			}, {
				key: "recover",
				value: function() {
					BlitScreenQuadCMD._pool.push(this), this._source = null, this._dest = null, this
						._offsetScale = null, this._shader = null, this._shaderData = null, this
						._drawDefineCavans = !1, _get(_getPrototypeOf(BlitScreenQuadCMD.prototype),
							"recover", this).call(this)
				}
			}], [{
				key: "create",
				value: function(e, t) {
					var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
						null,
						i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
						a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
						o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
						s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] :
						BlitScreenQuadCMD._SCREENTYPE_QUAD,
						l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
						u = arguments.length > 8 && void 0 !== arguments[8] && arguments[8];
					return (r = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() :
							new BlitScreenQuadCMD)._source = e, r._dest = t, r._offsetScale = n, r
						._shader = i, r._shaderData = a, r._subShader = o, r._screenType = s, r
						._commandBuffer = l, r._drawDefineCavans = u, r
				}
			}]), BlitScreenQuadCMD
		}(de);
		fe._SCREENTYPE_QUAD = 0, fe._SCREENTYPE_TRIANGLE = 1, fe._compileDefine = new ee, fe._pool = [], fe
			._defaultOffsetScale = new i(0, 0, 1, 1);
		var me, pe = function(e) {
			function SetRenderTargetCMD() {
				var e;
				return _classCallCheck(this, SetRenderTargetCMD), (e = _possibleConstructorReturn(this,
					_getPrototypeOf(SetRenderTargetCMD).apply(this, arguments)))._renderTexture = null, e
			}
			return _inherits(SetRenderTargetCMD, e), _createClass(SetRenderTargetCMD, [{
				key: "run",
				value: function() {
					$.currentActive && $.currentActive._end(), t.LayaGL.instance.viewport(0, 0, this
							._renderTexture.width, this._renderTexture.height), this._renderTexture
						._start()
				}
			}, {
				key: "recover",
				value: function() {
					SetRenderTargetCMD._pool.push(this), this._renderTexture = null
				}
			}], [{
				key: "create",
				value: function(e) {
					var t;
					return (t = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool
					.pop() : new SetRenderTargetCMD)._renderTexture = e, t
				}
			}]), SetRenderTargetCMD
		}(de);
		pe._pool = [], (me = e.ShaderDataType || (e.ShaderDataType = {}))[me.Int = 0] = "Int", me[me.Bool = 1] = "Bool",
			me[me.Number = 2] = "Number", me[me.Vector2 = 3] = "Vector2", me[me.Vector3 = 4] = "Vector3", me[me.Vector =
				5] = "Vector", me[me.Quaternion = 6] = "Quaternion", me[me.Matrix4x4 = 7] = "Matrix4x4", me[me.Buffer =
				8] = "Buffer", me[me.Texture = 9] = "Texture";
		var Te = function(t) {
			function SetShaderDataCMD() {
				var e;
				return _classCallCheck(this, SetShaderDataCMD), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(SetShaderDataCMD).apply(this, arguments)))._shaderData = null, e._nameID =
					0, e._value = null, e._dataType = -1, e
			}
			return _inherits(SetShaderDataCMD, t), _createClass(SetShaderDataCMD, [{
				key: "run",
				value: function() {
					switch (this._dataType) {
						case e.ShaderDataType.Int:
							this._shaderData.setInt(this._nameID, this._value);
							break;
						case e.ShaderDataType.Number:
							this._shaderData.setNumber(this._nameID, this._value);
							break;
						case e.ShaderDataType.Bool:
							this._shaderData.setBool(this._nameID, this._value);
							break;
						case e.ShaderDataType.Matrix4x4:
							this._shaderData.setMatrix4x4(this._nameID, this._value);
							break;
						case e.ShaderDataType.Quaternion:
							this._shaderData.setQuaternion(this._nameID, this._value);
							break;
						case e.ShaderDataType.Texture:
							this._shaderData.setTexture(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector:
							this._shaderData.setVector(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector2:
							this._shaderData.setVector2(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector3:
							this._shaderData.setVector3(this._nameID, this._value);
							break;
						case e.ShaderDataType.Buffer:
							this._shaderData.setBuffer(this._nameID, this._value);
							break;
						default:
							throw "no type shaderValue on this CommendBuffer"
					}
				}
			}, {
				key: "recover",
				value: function() {
					SetShaderDataCMD._pool.push(this), this._shaderData = null, this._nameID = 0,
						this._value = null, this._dataType = -1
				}
			}], [{
				key: "create",
				value: function(e, t, r, n, i) {
					var a;
					return (a = SetShaderDataCMD._pool.length > 0 ? SetShaderDataCMD._pool.pop() :
							new SetShaderDataCMD)._shaderData = e, a._nameID = t, a._value = r, a
						._dataType = n, a._commandBuffer = i, a
				}
			}]), SetShaderDataCMD
		}(de);
		Te._pool = [];
		var Ee = function(e) {
			function Sprite3D() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
				return _classCallCheck(this, Sprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						Sprite3D).call(this)))._needProcessCollisions = !1, e._needProcessTriggers = !1, e._id = ++
					Sprite3D._uniqueIDCounter, e._transform = new f(_assertThisInitialized(e)), e._isStatic = r, e
					.layer = 0, e.name = t || "New Sprite3D", e
			}
			return _inherits(Sprite3D, e), _createClass(Sprite3D, [{
				key: "_setCreateURL",
				value: function(e) {
					this._url = t.URL.formatURL(e)
				}
			}, {
				key: "_changeAnimatorsToLinkSprite3D",
				value: function(e, t, r) {
					var n = this.getComponent(K);
					if (n && (n.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(n, t, r)), this
						._parent && this._parent instanceof Sprite3D) {
						r.unshift(this._parent.name);
						var i = this._parent;
						i._hierarchyAnimator && i._changeAnimatorsToLinkSprite3D(e, t, r)
					}
				}
			}, {
				key: "_setHierarchyAnimator",
				value: function(e, t) {
					this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
					for (var r = 0, n = this._children.length; r < n; r++) {
						var i = this._children[r];
						i._hierarchyAnimator == t && i._setHierarchyAnimator(e, t)
					}
				}
			}, {
				key: "_clearHierarchyAnimator",
				value: function(e, t) {
					this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar :
						null);
					for (var r = 0, n = this._children.length; r < n; r++) {
						var i = this._children[r];
						i._hierarchyAnimator == e && i._clearHierarchyAnimator(e, t)
					}
				}
			}, {
				key: "_changeHierarchyAnimatorAvatar",
				value: function(e, t) {
					this._changeAnimatorAvatar(t);
					for (var r = 0, n = this._children.length; r < n; r++) {
						var i = this._children[r];
						i._hierarchyAnimator == e && i._changeHierarchyAnimatorAvatar(e, t)
					}
				}
			}, {
				key: "_changeAnimatorToLinkSprite3DNoAvatar",
				value: function(e, t, r) {
					e._handleSpriteOwnersBySprite(t, r, this);
					for (var n = 0, i = this._children.length; n < i; n++) {
						var a = this._children[n],
							o = r.length;
						r.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(e, t, r), r.splice(
							o, 1)
					}
				}
			}, {
				key: "_changeHierarchyAnimator",
				value: function(e) {
					this._hierarchyAnimator = e
				}
			}, {
				key: "_changeAnimatorAvatar",
				value: function(e) {}
			}, {
				key: "_onAdded",
				value: function() {
					if (this._parent instanceof Sprite3D) {
						var e = this._parent;
						this.transform._setParent(e.transform), e._hierarchyAnimator && (!this
							._hierarchyAnimator && this._setHierarchyAnimator(e
								._hierarchyAnimator, null), e._changeAnimatorsToLinkSprite3D(
								this, !0, [this.name]))
					}
					_get(_getPrototypeOf(Sprite3D.prototype), "_onAdded", this).call(this)
				}
			}, {
				key: "_onRemoved",
				value: function() {
					if (_get(_getPrototypeOf(Sprite3D.prototype), "_onRemoved", this).call(this),
						this._parent instanceof Sprite3D) {
						var e = this._parent;
						this.transform._setParent(null), e._hierarchyAnimator && (this
							._hierarchyAnimator == e._hierarchyAnimator && this
							._clearHierarchyAnimator(e._hierarchyAnimator, null), e
							._changeAnimatorsToLinkSprite3D(this, !1, [this.name]))
					}
				}
			}, {
				key: "_parse",
				value: function(e, t) {
					if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e
						.active && (this.active = e.active), null != e.name && (this.name = e.name),
						void 0 !== e.position) {
						var r = this.transform.localPosition;
						r.fromArray(e.position), this.transform.localPosition = r
					}
					if (void 0 !== e.rotationEuler) {
						var n = this.transform.localRotationEuler;
						n.fromArray(e.rotationEuler), this.transform.localRotationEuler = n
					}
					if (void 0 !== e.rotation) {
						var i = this.transform.localRotation;
						i.fromArray(e.rotation), this.transform.localRotation = i
					}
					if (void 0 !== e.scale) {
						var a = this.transform.localScale;
						a.fromArray(e.scale), this.transform.localScale = a
					}
					null != e.layer && (this.layer = e.layer)
				}
			}, {
				key: "_cloneTo",
				value: function(e, t, r) {
					if (this.destroyed) throw new Error(
						"Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
					var n = e,
						i = this._transform,
						a = n._transform;
					n.name = this.name, n.destroyed = this.destroyed, n.active = this.active, a
						.localPosition = i.localPosition, a.localRotation = i.localRotation, a
						.localScale = i.localScale, n._isStatic = this._isStatic, n.layer = this
						.layer, _get(_getPrototypeOf(Sprite3D.prototype), "_cloneTo", this).call(
							this, n, t, r)
				}
			}, {
				key: "clone",
				value: function() {
					var e = Sprite3D._createSprite3DInstance(this);
					return Sprite3D._parseSprite3DInstance(this, e, this, e), e
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					this.destroyed || (_get(_getPrototypeOf(Sprite3D.prototype), "destroy", this)
						.call(this, e), this._transform = null, this._scripts = null, this
						._url && t.Loader.clearRes(this._url))
				}
			}, {
				key: "_create",
				value: function() {
					return new Sprite3D
				}
			}, {
				key: "id",
				get: function() {
					return this._id
				}
			}, {
				key: "layer",
				get: function() {
					return this._layer
				},
				set: function(e) {
					if (this._layer !== e) {
						if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
						this._layer = e
					}
				}
			}, {
				key: "url",
				get: function() {
					return this._url
				}
			}, {
				key: "isStatic",
				get: function() {
					return this._isStatic
				}
			}, {
				key: "transform",
				get: function() {
					return this._transform
				}
			}], [{
				key: "__init__",
				value: function() {}
			}, {
				key: "instantiate",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
						r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
						n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
						i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
						a = e.clone();
					t && t.addChild(a);
					var o = a.transform;
					if (r) {
						var s = o.worldMatrix;
						e.transform.worldMatrix.cloneTo(s), o.worldMatrix = s
					} else n && (o.position = n), i && (o.rotation = i);
					return a
				}
			}, {
				key: "load",
				value: function(e, r) {
					t.Laya.loader.create(e, r, null, Sprite3D.HIERARCHY)
				}
			}, {
				key: "_createSprite3DInstance",
				value: function(e) {
					for (var t = e._create(), r = e._children, n = 0, i = r.length; n < i; n++) {
						var a = Sprite3D._createSprite3DInstance(r[n]);
						t.addChild(a)
					}
					return t
				}
			}, {
				key: "_parseSprite3DInstance",
				value: function(e, t, r, n) {
					for (var i = r._children, a = n._children, o = 0, s = i.length; o < s; o++)
						Sprite3D._parseSprite3DInstance(e, t, i[o], a[o]);
					r._cloneTo(n, e, t)
				}
			}]), Sprite3D
		}(t.Node);
		Ee.HIERARCHY = "HIERARCHY", Ee.WORLDMATRIX = _e.propertyNameToID("u_WorldMat"), Ee.MVPMATRIX = _e
			.propertyNameToID("u_MvpMatrix"), Ee._uniqueIDCounter = 0;
		var ge = function(e) {
			function DrawMeshCMD() {
				var e;
				return _classCallCheck(this, DrawMeshCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						DrawMeshCMD).call(this)))._projectionViewWorldMatrix = new c, e._renderShaderValue = new ne,
					e._renderShaderValue = new ne(null), e
			}
			return _inherits(DrawMeshCMD, e), _createClass(DrawMeshCMD, [{
				key: "run",
				value: function() {
					var e = this._material._shader.getSubShaderAt(this._subShaderIndex);
					this.setContext(this._commandBuffer._context);
					var t = this._context,
						r = t.invertY,
						n = t.scene,
						i = t.cameraShaderValue,
						a = t.projectionViewMatrix;
					c.multiply(a, this._matrix, this._projectionViewWorldMatrix), this
						._renderShaderValue.setMatrix4x4(Ee.WORLDMATRIX, this._matrix), this
						._renderShaderValue.setMatrix4x4(Ee.MVPMATRIX, this
							._projectionViewWorldMatrix);
					for (var o = t.pipelineMode, s = e._passes, l = 0, u = s.length; l < u; l++) {
						var h = s[l];
						if (h._pipelineMode === o) {
							var _ = DrawMeshCMD._compileDefine;
							n._shaderValues._defineDatas.cloneTo(_), _.addDefineDatas(this
								._renderShaderValue._defineDatas), _.addDefineDatas(this
								._material._shaderValues._defineDatas);
							var d = t.shader = h.withCompile(_);
							d.bind();
							d.uploadUniforms(d._sceneUniformParamsMap, n._shaderValues, !0), d
								.uploadUniforms(d._spriteUniformParamsMap, this._renderShaderValue,
									!0), d.uploadUniforms(d._cameraUniformParamsMap, i, !0);
							var f = this._material._shaderValues;
							d.uploadUniforms(d._materialUniformParamsMap, f, !0), d
								.uploadRenderStateBlendDepth(f), d.uploadRenderStateFrontFace(f, r,
									this._matrix.getInvertFront())
						}
					}
					var m, p = this._mesh._subMeshes;
					if (-1 == this._subMeshIndex)
						for (var T = 0, E = p.length; T < E; T++)(m = p[T])._prepareRender(t) && m
							._render(t);
					else(m = (p = this._mesh._subMeshes)[this._subMeshIndex])._prepareRender(t) && m
						._render(t)
				}
			}, {
				key: "recover",
				value: function() {
					DrawMeshCMD._pool.push(this), this._renderShaderValue.clearDefine(), this
						._renderShaderValue._initData()
				}
			}], [{
				key: "create",
				value: function(e, t, r, n, i, a) {
					var o;
					return (o = DrawMeshCMD._pool.length > 0 ? DrawMeshCMD._pool.pop() :
							new DrawMeshCMD)._mesh = e, o._matrix = t, o._material = r, o
						._subMeshIndex = n, o._subShaderIndex = i, o._commandBuffer = a, o
				}
			}]), DrawMeshCMD
		}(de);
		ge._pool = [], ge._compileDefine = new ee;
		var ye = function(e) {
			function ClearRenderTextureCMD() {
				var e;
				return _classCallCheck(this, ClearRenderTextureCMD), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(ClearRenderTextureCMD).apply(this, arguments)))._clearColor = !1, e
					._clearDepth = !1, e._backgroundColor = new i, e._depth = 1, e
			}
			return _inherits(ClearRenderTextureCMD, e), _createClass(ClearRenderTextureCMD, [{
				key: "run",
				value: function() {
					var e, r = t.LayaGL.instance,
						n = this._backgroundColor;
					this._clearColor && (r.clearColor(n.x, n.y, n.z, n.w), e |= r.COLOR_BUFFER_BIT),
						this._clearDepth && (r.clearDepth(this._depth), e |= r.DEPTH_BUFFER_BIT), (
							this._clearColor || this._clearDepth) && r.clear(e)
				}
			}, {
				key: "recover",
				value: function() {}
			}], [{
				key: "create",
				value: function(e, t, r) {
					var n, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
						a = arguments.length > 4 ? arguments[4] : void 0;
					return (n = ClearRenderTextureCMD._pool.length > 0 ? ClearRenderTextureCMD._pool
							.pop() : new ClearRenderTextureCMD)._clearColor = e, n._clearDepth = t,
						r.cloneTo(n._backgroundColor), n._depth = i, n._commandBuffer = a, n
				}
			}]), ClearRenderTextureCMD
		}(de);
		ye._pool = [];
		var Se = function ClusterData() {
				_classCallCheck(this, ClusterData), this.updateMark = -1, this.pointLightCount = 0, this
					.spotLightCount = 0, this.indices = []
			},
			ve = function() {
				function Cluster(e, t, r, i) {
					_classCallCheck(this, Cluster), this._updateMark = 0, this._depthSliceParam = new n, this._xSlices =
						e, this._ySlices = t, this._zSlices = r;
					var a = e * t,
						o = r * (1 + Math.ceil(i / 4));
					this._clusterTexture = P._createFloatTextureBuffer(a, o), this._clusterTexture.lock = !0, this
						._clusterPixels = new Float32Array(a * o * 4);
					for (var s = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
						s[l] = new Array(this._ySlices);
						for (var u = 0; u < this._ySlices; u++) {
							s[l][u] = new Array(this._xSlices);
							for (var c = 0; c < this._xSlices; c++) s[l][u][c] = new Se
						}
					}
					this._clusterDatas = s
				}
				return _createClass(Cluster, [{
					key: "_insertSpotLightSphere",
					value: function(e, t, r, n, i) {
						var a = Cluster._tempVector35;
						a.x = i.x - e.x, a.y = i.y - e.y, a.z = i.z - e.z;
						var s = o.dot(a, a),
							l = i.w;
						if (!(s > l * l)) return !1;
						var u = o.dot(a, t);
						return !(Math.cos(n) * Math.sqrt(s - u * u) - u * Math.sin(n) > l || u > l +
							r || u < -l)
					}
				}, {
					key: "_placePointLightToClusters",
					value: function(e, t) {
						for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t
							.zMax; i < a; i++)
							for (var o = t.yMin, s = t.yMax; o < s; o++)
								for (var l = t.xMin, u = t.xMax; l < u; l++) {
									var c = r[i][o][l];
									c.updateMark != n && (c.pointLightCount = 0, c.spotLightCount = 0, c
										.updateMark = n);
									var h = c.indices,
										_ = c.pointLightCount++;
									_ < h.length ? h[_] = e : h.push(e)
								}
					}
				}, {
					key: "_placeSpotLightToClusters",
					value: function(e, t) {
						for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t
							.zMax; i < a; i++)
							for (var o = t.yMin, s = t.yMax; o < s; o++)
								for (var l = t.xMin, u = t.xMax; l < u; l++) {
									var c = r[i][o][l];
									c.updateMark != n && (c.pointLightCount = 0, c.spotLightCount = 0, c
										.updateMark = n);
									var h = c.indices,
										_ = c.pointLightCount + c.spotLightCount++;
									_ < h.length ? h[_] = e : h.push(e)
								}
					}
				}, {
					key: "_insertConePlane",
					value: function(e, t, r, n, i) {
						var a = Cluster._tempVector36,
							s = Cluster._tempVector37;
						o.cross(i, t, a), o.cross(a, t, s), o.normalize(s, s);
						var l = r * Math.tan(n),
							u = e.x + r * t.x + l * s.x,
							c = e.y + r * t.y + l * s.y,
							h = e.z + r * t.z + l * s.z;
						return u * i.x + c * i.y + h * i.z <= 0 || e.x * i.x + e.y * i.y + e.z * i.z <=
							0
					}
				}, {
					key: "_shrinkSphereLightZPerspective",
					value: function(e, t, r, n, i) {
						var a = r.z,
							o = a - n,
							s = a + n;
						if (o > t || s <= e) return !1;
						var l = this._depthSliceParam;
						return i.zMin = Math.floor(Math.log2(Math.max(o, e)) * l.x - l.y), i.zMax = Math
							.min(Math.ceil(Math.log2(s) * l.x - l.y), this._zSlices), !0
					}
				}, {
					key: "_shrinkSpotLightZPerspective",
					value: function(e, t, r, n, i, a, o) {
						var s = n.x,
							l = n.y,
							u = n.z,
							c = Math.tan(a) * i,
							h = r.x,
							_ = r.y,
							d = r.z,
							f = s - h,
							m = l - _,
							p = u - d,
							T = f * f + m * m + p * p,
							E = Math.sqrt(1 - p * p / T),
							g = Math.max(Math.min(d, u - E * c), r.z - i),
							y = Math.min(Math.max(d, u + E * c), r.z + i);
						if (g > t || y <= e) return !1;
						var S = this._depthSliceParam;
						return o.zMin = Math.floor(Math.log2(Math.max(g, e)) * S.x - S.y), o.zMax = Math
							.min(Math.ceil(Math.log2(y) * S.x - S.y), this._zSlices), !0
					}
				}, {
					key: "_shrinkSphereLightByBoundOrth",
					value: function(e, t, r, n, i, a, o) {
						var s = i.z,
							l = s - a,
							u = s + a;
						if (l > n || u <= r) return !1;
						var c = i.x,
							h = c - a,
							_ = c + a;
						if (h > e || _ <= -e) return !1;
						var d = i.y,
							f = d - a,
							m = d + a;
						if (f > t || m <= -t) return !1;
						var p = this._xSlices,
							T = this._ySlices,
							E = this._depthSliceParam,
							g = 2 * e / p,
							y = 2 * t / T;
						return o.xMin = Math.max(Math.floor((h + e) / g), 0), o.xMax = Math.min(Math
								.ceil((_ + e) / g), p), o.yMin = Math.max(Math.floor((t - m) / y), 0), o
							.yMax = Math.min(Math.ceil((t - f) / y), T), o.zMin = Math.floor(Math.log2(
								Math.max(l, r)) * E.x - E.y), o.zMax = Math.min(Math.ceil(Math.log2(u) *
								E.x - E.y), this._zSlices), !0
					}
				}, {
					key: "_shrinkSpotLightByBoundOrth",
					value: function(e, t, r, n, i, a, o, s, l) {
						var u = a.x,
							c = a.y,
							h = a.z,
							_ = Math.tan(s) * o,
							d = i.x,
							f = i.y,
							m = i.z,
							p = u - d,
							T = c - f,
							E = h - m,
							g = p * p + T * T + E * E,
							y = Math.sqrt(1 - E * E / g),
							S = Math.max(Math.min(m, h - y * _), i.z - o),
							v = Math.min(Math.max(m, h + y * _), i.z + o);
						if (S > n || v <= r) return !1;
						var R = Math.sqrt(1 - p * p / g),
							C = Math.max(Math.min(d, u - R * _), i.x - o),
							M = Math.min(Math.max(d, u + R * _), i.x + o);
						if (C > e || M <= -e) return !1;
						var D = Math.sqrt(1 - T * T / g),
							x = Math.max(Math.min(f, c - D * _), i.y - o),
							A = Math.min(Math.max(f, c + D * _), i.y + o);
						if (x > t || A <= -t) return !1;
						var I = this._xSlices,
							L = this._ySlices,
							P = this._depthSliceParam,
							O = 2 * e / I,
							N = 2 * t / L;
						return l.xMin = Math.max(Math.floor((C + e) / O), 0), l.xMax = Math.min(Math
								.ceil((M + e) / O), I), l.yMin = Math.max(Math.floor((t - A) / N), 0), l
							.yMax = Math.min(Math.ceil((t - x) / N), L), l.zMin = Math.floor(Math.log2(
								Math.max(S, r)) * P.x - P.y), l.zMax = Math.min(Math.ceil(Math.log2(v) *
								P.x - P.y), this._zSlices), !0
					}
				}, {
					key: "_shrinkXYByRadiusPerspective",
					value: function(e, t, r, n, i) {
						var a, o, s, l, u, c = e.x,
							h = e.y,
							_ = e.z,
							d = this._ySlices + 1;
						for (u = 0; u < d; u++) {
							if (h * (f = i[u]).y + _ * f.z < t) {
								o = Math.max(0, u - 1);
								break
							}
						}
						if (u == d) return !1;
						for (l = this._ySlices, u = o + 1; u < d; u++) {
							if (h * (f = i[u]).y + _ * f.z <= -t) {
								l = Math.max(0, u);
								break
							}
						}
						for (d = this._xSlices + 1, u = 0; u < d; u++) {
							if (c * (f = n[u]).x + _ * f.z < t) {
								a = Math.max(0, u - 1);
								break
							}
						}
						for (s = this._xSlices, u = a + 1; u < d; u++) {
							var f;
							if (c * (f = n[u]).x + _ * f.z <= -t) {
								s = Math.max(0, u);
								break
							}
						}
						return r.xMin = a, r.xMax = s, r.yMin = o, r.yMax = l, !0
					}
				}, {
					key: "_shrinkSpotXYByConePerspective",
					value: function(e, t, r, n, i, a, o) {
						for (var s, l, u, c, h = Cluster._tempVector32, _ = i.yMax + 1, d = i.yMin +
							1; d < _; d++)
							if (this._insertConePlane(e, t, r, n, o[d])) {
								l = Math.max(0, d - 1);
								break
							} c = i.yMax;
						for (d = l + 1; d < _; d++) {
							var f = o[d];
							if (h.setValue(0, -f.y, -f.z), !this._insertConePlane(e, t, r, n, h)) {
								c = Math.max(0, d);
								break
							}
						}
						_ = i.xMax + 1;
						for (d = i.xMin + 1; d < _; d++)
							if (this._insertConePlane(e, t, r, n, a[d])) {
								s = Math.max(0, d - 1);
								break
							} u = i.xMax;
						for (d = s + 1; d < _; d++) {
							f = a[d];
							if (h.setValue(-f.x, 0, -f.z), !this._insertConePlane(e, t, r, n, h)) {
								u = Math.max(0, d);
								break
							}
						}
						i.xMin = s, i.xMax = u, i.yMin = l, i.yMax = c
					}
				}, {
					key: "_updatePointLightPerspective",
					value: function(e, t, r, n, i, a, s) {
						var l = Cluster._tempLightBound,
							u = Cluster._tempVector30;
						o.transformV3ToV3(n._transform.position, r, u), u.z *= -1, this
							._shrinkSphereLightZPerspective(e, t, u, n.range, l) && this
							._shrinkXYByRadiusPerspective(u, n.range, l, a, s) && this
							._placePointLightToClusters(i, l)
					}
				}, {
					key: "_updateSpotLightPerspective",
					value: function(e, t, r, n, i, a, s) {
						var l = Cluster._tempLightBound,
							u = Cluster._tempVector30,
							c = Cluster._tempVector31,
							h = Cluster._tempVector34,
							_ = n._transform.position,
							d = n.range;
						n._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o
							.add(_, h, h), o.transformV3ToV3(_, r, u), o.transformV3ToV3(h, r, h), u
							.z *= -1, h.z *= -1;
						var f = n.spotAngle / 2 * Math.PI / 180;
						if (this._shrinkSpotLightZPerspective(e, t, u, h, d, f, l) && this
							._shrinkXYByRadiusPerspective(u, d, l, a, s)) {
							var m = Cluster._tempVector33;
							m.x = h.x - u.x, m.y = h.y - u.y, m.z = h.z - u.z, o.normalize(m, m), this
								._shrinkSpotXYByConePerspective(u, m, d, f, l, a, s), this
								._placeSpotLightToClusters(i, l)
						}
					}
				}, {
					key: "_updatePointLightOrth",
					value: function(e, t, r, n, i, a, s) {
						var l = Cluster._tempLightBound,
							u = Cluster._tempVector30;
						o.transformV3ToV3(a._transform.position, i, u), u.z *= -1, this
							._shrinkSphereLightByBoundOrth(e, t, r, n, u, a.range, l) && this
							._placePointLightToClusters(s, l)
					}
				}, {
					key: "_updateSpotLightOrth",
					value: function(e, t, r, n, i, a, s) {
						var l = Cluster._tempLightBound,
							u = Cluster._tempVector30,
							c = Cluster._tempVector31,
							h = Cluster._tempVector34,
							_ = a._transform.position,
							d = a.range;
						a._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o
							.add(_, h, h), o.transformV3ToV3(_, i, u), o.transformV3ToV3(h, i, h), u
							.z *= -1, h.z *= -1;
						var f = a.spotAngle / 2 * Math.PI / 180;
						this._shrinkSpotLightByBoundOrth(e, t, r, n, u, h, d, f, l) && this
							._placeSpotLightToClusters(s, l)
					}
				}, {
					key: "update",
					value: function(e, t) {
						this._updateMark++;
						var r = e.nearPlane;
						this._depthSliceParam.x = w._config.lightClusterCount.z / Math.log2(e.farPlane /
							r), this._depthSliceParam.y = Math.log2(r) * this._depthSliceParam.x;
						var n = e.nearPlane,
							i = e.farPlane,
							a = e.viewMatrix,
							o = t._directionLights._length,
							s = t._pointLights,
							l = s._length,
							u = s._elements,
							c = t._spotLights,
							h = c._length,
							_ = c._elements;
						if (e.orthographic) {
							for (var d = e.orthographicVerticalSize / 2, f = d * e.aspectRatio, m =
								0; m < l; m++, o++) this._updatePointLightOrth(f, d, n, i, a, u[m], o);
							for (m = 0; m < h; m++, o++) this._updateSpotLightOrth(f, d, n, i, a, _[m],
								o)
						} else {
							e._updateClusterPlaneXY();
							var p = e._clusterXPlanes,
								T = e._clusterYPlanes;
							for (m = 0; m < l; m++, o++) this._updatePointLightPerspective(n, i, a, u[
								m], o, p, T);
							for (m = 0; m < h; m++, o++) this._updateSpotLightPerspective(n, i, a, _[m],
								o, p, T)
						}
						if (l + h > 0) {
							for (var E = this._xSlices, g = this._ySlices, y = this._zSlices, S = E *
									g * 4, v = S * y, R = this._clusterPixels, C = R.length, M = this
									._clusterDatas, D = this._updateMark, x = !0, A = 0; A < y; A++)
								for (var I = 0; I < g; I++)
									for (var L = 0; L < E; L++) {
										var P = M[A][I][L],
											O = 4 * (L + I * E + A * E * g);
										if (P.updateMark !== D) R[O] = 0, R[O + 1] = 0;
										else if (x) {
											var N = P.indices,
												b = P.pointLightCount,
												k = P.spotLightCount,
												B = b + k;
											if (v + B < C) {
												R[O] = b, R[O + 1] = k, R[O + 2] = Math.floor(v / S), R[
													O + 3] = v % S;
												for (m = 0; m < B; m++) R[v++] = N[m]
											} else {
												B = C - (v + B), b = Math.min(b, B), R[O] = b, R[O +
													1] = Math.min(k, B - b), R[O + 2] = Math.floor(v /
														S), R[O + 3] = v % S;
												for (m = 0; m < B; m++) R[v++] = N[m];
												x = !1
											}
										}
									}
							var V = this._clusterTexture.width;
							this._clusterTexture.setSubPixels(0, 0, V, Math.ceil(v / (4 * V)), R)
						}
					}
				}]), Cluster
			}();
		ve._tempVector30 = new o, ve._tempVector31 = new o, ve._tempVector32 = new o, ve._tempVector33 = new o, ve
			._tempVector34 = new o, ve._tempVector35 = new o, ve._tempVector36 = new o, ve._tempVector37 = new o, ve
			._tempLightBound = new function LightBound() {
				_classCallCheck(this, LightBound)
			};
		var Re = function() {
			function Plane(e) {
				var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
				_classCallCheck(this, Plane), this.normal = e, this.distance = t
			}
			return _createClass(Plane, [{
				key: "normalize",
				value: function() {
					var e = this.normal.x,
						t = this.normal.y,
						r = this.normal.z,
						n = 1 / Math.sqrt(e * e + t * t + r * r);
					this.normal.x = e * n, this.normal.y = t * n, this.normal.z = r * n, this
						.distance *= n
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					this.normal.cloneTo(t.normal), t.distance = this.distance
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Plane(new o);
					return this.cloneTo(e), e
				}
			}], [{
				key: "createPlaneBy3P",
				value: function(e, t, r, n) {
					var i = t.x - e.x,
						a = t.y - e.y,
						o = t.z - e.z,
						s = r.x - e.x,
						l = r.y - e.y,
						u = r.z - e.z,
						c = a * u - o * l,
						h = o * s - i * u,
						_ = i * l - a * s,
						d = 1 / Math.sqrt(c * c + h * h + _ * _),
						f = c * d,
						m = h * d,
						p = _ * d,
						T = n.normal;
					T.x = f, T.y = m, T.z = p, n.distance = -(f * e.x + m * e.y + p * e.z)
				}
			}]), Plane
		}();
		Re.PlaneIntersectionType_Back = 0, Re.PlaneIntersectionType_Front = 1, Re.PlaneIntersectionType_Intersecting =
		2;
		var Ce = function Ray(e, t) {
				_classCallCheck(this, Ray), this.origin = e, this.direction = t
			},
			Me = function ContainmentType() {
				_classCallCheck(this, ContainmentType)
			};
		Me.Disjoint = 0, Me.Contains = 1, Me.Intersects = 2;
		var De, xe = function() {
			function CollisionUtils() {
				_classCallCheck(this, CollisionUtils)
			}
			return _createClass(CollisionUtils, null, [{
				key: "distancePlaneToPoint",
				value: function(e, t) {
					return o.dot(e.normal, t) - e.distance
				}
			}, {
				key: "distanceBoxToPoint",
				value: function(e, t) {
					var r = e.min,
						n = r.x,
						i = r.y,
						a = r.z,
						o = e.max,
						s = o.x,
						l = o.y,
						u = o.z,
						c = t.x,
						h = t.y,
						_ = t.z,
						d = 0;
					return c < n && (d += (n - c) * (n - c)), c > s && (d += (s - c) * (s - c)), h <
						i && (d += (i - h) * (i - h)), h > l && (d += (l - h) * (l - h)), _ < a && (
							d += (a - _) * (a - _)), _ > u && (d += (u - _) * (u - _)), Math.sqrt(d)
				}
			}, {
				key: "distanceBoxToBox",
				value: function(e, t) {
					var r, n = e.min,
						i = n.x,
						a = n.y,
						o = n.z,
						s = e.max,
						l = s.x,
						u = s.y,
						c = s.z,
						h = t.min,
						_ = h.x,
						d = h.y,
						f = h.z,
						m = t.max,
						p = m.x,
						T = m.y,
						E = m.z,
						g = 0;
					return i > p ? g += (r = i - p) * r : _ > l && (g += (r = _ - l) * r), a > T ?
						g += (r = a - T) * r : d > u && (g += (r = d - u) * r), o > E ? g += (r =
							o - E) * r : f > c && (g += (r = f - c) * r), Math.sqrt(g)
				}
			}, {
				key: "distanceSphereToPoint",
				value: function(e, t) {
					var r = Math.sqrt(o.distanceSquared(e.center, t));
					return r -= e.radius, Math.max(r, 0)
				}
			}, {
				key: "distanceSphereToSphere",
				value: function(e, t) {
					var r = Math.sqrt(o.distanceSquared(e.center, t.center));
					return r -= e.radius + t.radius, Math.max(r, 0)
				}
			}, {
				key: "intersectsRayAndTriangleRD",
				value: function(e, t, n, i, a) {
					var o = e.origin,
						s = o.x,
						l = o.y,
						u = o.z,
						c = e.direction,
						h = c.x,
						_ = c.y,
						d = c.z,
						f = t.x,
						m = t.y,
						p = t.z,
						T = n.x,
						E = n.y,
						g = n.z,
						y = i.x,
						S = i.y,
						v = i.z,
						R = CollisionUtils._tempV30.x,
						C = CollisionUtils._tempV30.y,
						M = CollisionUtils._tempV30.z;
					R = T - f, C = E - m, M = g - p;
					var D = CollisionUtils._tempV31.x,
						x = CollisionUtils._tempV31.y,
						A = CollisionUtils._tempV31.z;
					D = y - f, x = S - m, A = v - p;
					var I = CollisionUtils._tempV32.x,
						L = CollisionUtils._tempV32.y,
						P = CollisionUtils._tempV32.z,
						O = R * (I = _ * A - d * x) + C * (L = d * D - h * A) + M * (P = h * x - _ *
							D);
					if (r.isZero(O)) return !1;
					var N = 1 / O,
						b = CollisionUtils._tempV33.x,
						k = CollisionUtils._tempV33.y,
						w = CollisionUtils._tempV33.z,
						B = (b = s - f) * I + (k = l - m) * L + (w = u - p) * P;
					if ((B *= N) < 0 || B > 1) return !1;
					var V = CollisionUtils._tempV34.x,
						F = CollisionUtils._tempV34.y,
						U = CollisionUtils._tempV34.z,
						G = h * (V = k * M - w * C) + _ * (F = w * R - b * M) + d * (U = b * C - k *
							R);
					if ((G *= N) < 0 || B + G > 1) return !1;
					var H = D * V + x * F + A * U;
					return !((H *= N) < 0)
				}
			}, {
				key: "intersectsRayAndTriangleRP",
				value: function(e, t, r, n, i) {
					return CollisionUtils.intersectsRayAndTriangleRD(e, t, r, n, void 0) ? (o.scale(
						e.direction, void 0, CollisionUtils._tempV30), o.add(e.origin,
						CollisionUtils._tempV30, i), !0) : (i = o._ZERO, !1)
				}
			}, {
				key: "intersectsRayAndPoint",
				value: function(e, t) {
					o.subtract(e.origin, t, CollisionUtils._tempV30);
					var n = o.dot(CollisionUtils._tempV30, e.direction),
						i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r
						.zeroTolerance;
					return !(i > 0 && n > 0) && !(n * n - i < 0)
				}
			}, {
				key: "intersectsRayAndRay",
				value: function(e, t, n) {
					var i = e.origin,
						a = i.x,
						s = i.y,
						l = i.z,
						u = e.direction,
						c = u.x,
						h = u.y,
						_ = u.z,
						d = t.origin,
						f = d.x,
						m = d.y,
						p = d.z,
						T = t.direction,
						E = T.x,
						g = T.y,
						y = T.z;
					o.cross(u, T, CollisionUtils._tempV30);
					var S = CollisionUtils._tempV30,
						v = o.scalarLength(CollisionUtils._tempV30);
					if (r.isZero(v) && r.nearEqual(f, a) && r.nearEqual(m, s) && r.nearEqual(p, l))
						return !0;
					v *= v;
					var R = f - a,
						C = m - s,
						M = p - l,
						D = E,
						x = g,
						A = y,
						I = S.x,
						L = S.y,
						P = S.z,
						O = R * x * P + C * A * I + M * D * L - R * A * L - C * D * P - M * x * I;
					D = c, x = h, A = _;
					var N = O / v;
					o.scale(u, N, CollisionUtils._tempV30), o.scale(T, N, CollisionUtils._tempV31),
						o.add(i, CollisionUtils._tempV30, CollisionUtils._tempV32), o.add(d,
							CollisionUtils._tempV31, CollisionUtils._tempV33);
					var b = CollisionUtils._tempV32,
						k = CollisionUtils._tempV33;
					return !!(r.nearEqual(k.x, b.x) && r.nearEqual(k.y, b.y) && r.nearEqual(k.z, b
						.z))
				}
			}, {
				key: "intersectsPlaneAndTriangle",
				value: function(e, t, r, n) {
					var i = CollisionUtils.intersectsPlaneAndPoint(e, t),
						a = CollisionUtils.intersectsPlaneAndPoint(e, r),
						o = CollisionUtils.intersectsPlaneAndPoint(e, n);
					return i == Re.PlaneIntersectionType_Front && a == Re
						.PlaneIntersectionType_Front && o == Re.PlaneIntersectionType_Front ? Re
						.PlaneIntersectionType_Front : i == Re.PlaneIntersectionType_Back && a == Re
						.PlaneIntersectionType_Back && o == Re.PlaneIntersectionType_Back ? Re
						.PlaneIntersectionType_Back : Re.PlaneIntersectionType_Intersecting
				}
			}, {
				key: "intersectsRayAndPlaneRD",
				value: function(e, t) {
					var n = t.normal,
						i = o.dot(n, e.direction);
					if (Math.abs(i) < r.zeroTolerance) return -1;
					var a = o.dot(n, e.origin),
						s = (-t.distance - a) / i;
					if (s < 0) {
						if (s < -r.zeroTolerance) return -1;
						s = 0
					}
					return s
				}
			}, {
				key: "intersectsRayAndPlaneRP",
				value: function(e, t, r) {
					var n = CollisionUtils.intersectsRayAndPlaneRD(e, t);
					if (-1 == n) return r.setValue(0, 0, 0), !1;
					var i = CollisionUtils._tempV30;
					return o.scale(e.direction, n, i), o.add(e.origin, i, r), !0
				}
			}, {
				key: "intersectsRayAndBoxRD",
				value: function(e, t) {
					var n = e.origin,
						i = n.x,
						a = n.y,
						o = n.z,
						s = e.direction,
						l = s.x,
						u = s.y,
						c = s.z,
						h = t.min,
						_ = h.x,
						d = h.y,
						f = h.z,
						m = t.max,
						p = m.x,
						T = m.y,
						E = m.z,
						g = 0,
						y = r.MaxValue;
					if (r.isZero(l)) {
						if (i < _ || i > p) return -1
					} else {
						var S = 1 / l,
							v = (_ - i) * S,
							R = (p - i) * S;
						if (v > R) {
							var C = v;
							v = R, R = C
						}
						if ((g = Math.max(v, g)) > (y = Math.min(R, y))) return -1
					}
					if (r.isZero(u)) {
						if (a < d || a > T) return -1
					} else {
						var M = 1 / u,
							D = (d - a) * M,
							x = (T - a) * M;
						if (D > x) {
							var A = D;
							D = x, x = A
						}
						if ((g = Math.max(D, g)) > (y = Math.min(x, y))) return -1
					}
					if (r.isZero(c)) {
						if (o < f || o > E) return -1
					} else {
						var I = 1 / c,
							L = (f - o) * I,
							P = (E - o) * I;
						if (L > P) {
							var O = L;
							L = P, P = O
						}
						if ((g = Math.max(L, g)) > (y = Math.min(P, y))) return -1
					}
					return g
				}
			}, {
				key: "intersectsRayAndBoxRP",
				value: function(e, t, r) {
					var n = CollisionUtils.intersectsRayAndBoxRD(e, t);
					return -1 === n ? (o._ZERO.cloneTo(r), n) : (o.scale(e.direction, n,
						CollisionUtils._tempV30), o.add(e.origin, CollisionUtils._tempV30,
						CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(r), n)
				}
			}, {
				key: "intersectsRayAndSphereRD",
				value: function(e, t) {
					var r = t.radius;
					o.subtract(e.origin, t.center, CollisionUtils._tempV30);
					var n = o.dot(CollisionUtils._tempV30, e.direction),
						i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r * r;
					if (i > 0 && n > 0) return -1;
					var a = n * n - i;
					if (a < 0) return -1;
					var s = -n - Math.sqrt(a);
					return s < 0 && (s = 0), s
				}
			}, {
				key: "intersectsRayAndSphereRP",
				value: function(e, t, r) {
					var n = CollisionUtils.intersectsRayAndSphereRD(e, t);
					return -1 === n ? (o._ZERO.cloneTo(r), n) : (o.scale(e.direction, n,
						CollisionUtils._tempV30), o.add(e.origin, CollisionUtils._tempV30,
						CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(r), n)
				}
			}, {
				key: "intersectsSphereAndTriangle",
				value: function(e, t, r, n) {
					var i = e.center,
						a = e.radius;
					return CollisionUtils.closestPointPointTriangle(i, t, r, n, CollisionUtils
							._tempV30), o.subtract(CollisionUtils._tempV30, i, CollisionUtils
							._tempV31), o.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <=
						a * a
				}
			}, {
				key: "intersectsPlaneAndPoint",
				value: function(e, t) {
					var r = o.dot(e.normal, t) + e.distance;
					return r > 0 ? Re.PlaneIntersectionType_Front : r < 0 ? Re
						.PlaneIntersectionType_Back : Re.PlaneIntersectionType_Intersecting
				}
			}, {
				key: "intersectsPlaneAndPlane",
				value: function(e, t) {
					o.cross(e.normal, t.normal, CollisionUtils._tempV30);
					var n = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
					return !r.isZero(n)
				}
			}, {
				key: "intersectsPlaneAndPlaneRL",
				value: function(e, t, n) {
					var i = e.normal,
						a = t.normal;
					o.cross(i, a, CollisionUtils._tempV34);
					var s = o.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
					return !r.isZero(s) && (o.scale(a, e.distance, CollisionUtils._tempV30), o
						.scale(i, t.distance, CollisionUtils._tempV31), o.subtract(
							CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils
							._tempV32), o.cross(CollisionUtils._tempV32, CollisionUtils
							._tempV34, CollisionUtils._tempV33), o.normalize(CollisionUtils
							._tempV34, CollisionUtils._tempV34), !0)
				}
			}, {
				key: "intersectsPlaneAndBox",
				value: function(e, t) {
					var r = e.distance,
						n = e.normal,
						i = n.x,
						a = n.y,
						s = n.z,
						l = t.min,
						u = l.x,
						c = l.y,
						h = l.z,
						_ = t.max,
						d = _.x,
						f = _.y,
						m = _.z;
					CollisionUtils._tempV30.x = i > 0 ? u : d, CollisionUtils._tempV30.y = a > 0 ?
						c : f, CollisionUtils._tempV30.z = s > 0 ? h : m, CollisionUtils._tempV31
						.x = i > 0 ? d : u, CollisionUtils._tempV31.y = a > 0 ? f : c,
						CollisionUtils._tempV31.z = s > 0 ? m : h;
					var p = o.dot(n, CollisionUtils._tempV30);
					return p + r > 0 ? Re.PlaneIntersectionType_Front : (p = o.dot(n, CollisionUtils
							._tempV31)) + r < 0 ? Re.PlaneIntersectionType_Back : Re
						.PlaneIntersectionType_Intersecting
				}
			}, {
				key: "intersectsPlaneAndSphere",
				value: function(e, t) {
					var r = t.radius,
						n = o.dot(e.normal, t.center) + e.distance;
					return n > r ? Re.PlaneIntersectionType_Front : n < -r ? Re
						.PlaneIntersectionType_Back : Re.PlaneIntersectionType_Intersecting
				}
			}, {
				key: "intersectsBoxAndBox",
				value: function(e, t) {
					var r = e.min,
						n = e.max,
						i = t.min,
						a = t.max;
					return !(r.x > a.x || i.x > n.x) && (!(r.y > a.y || i.y > n.y) && !(r.z > a.z ||
						i.z > n.z))
				}
			}, {
				key: "intersectsBoxAndSphere",
				value: function(e, t) {
					var r = t.center,
						n = t.radius,
						i = CollisionUtils._tempV30;
					return o.Clamp(r, e.min, e.max, i), o.distanceSquared(r, i) <= n * n
				}
			}, {
				key: "intersectsSphereAndSphere",
				value: function(e, t) {
					var r = e.radius + t.radius;
					return o.distanceSquared(e.center, t.center) <= r * r
				}
			}, {
				key: "boxContainsPoint",
				value: function(e, t) {
					var r = e.min,
						n = e.max;
					return r.x <= t.x && n.x >= t.x && r.y <= t.y && n.y >= t.y && r.z <= t.z && n
						.z >= t.z ? Me.Contains : Me.Disjoint
				}
			}, {
				key: "boxContainsBox",
				value: function(e, t) {
					var r = e.min,
						n = r.x,
						i = r.y,
						a = r.z,
						o = e.max,
						s = o.x,
						l = o.y,
						u = o.z,
						c = t.min,
						h = c.x,
						_ = c.y,
						d = c.z,
						f = t.max,
						m = f.x,
						p = f.y,
						T = f.z;
					return s < h || n > m ? Me.Disjoint : l < _ || i > p ? Me.Disjoint : u < d ||
						a > T ? Me.Disjoint : n <= h && m <= s && i <= _ && p <= l && a <= d && T <=
						u ? Me.Contains : Me.Intersects
				}
			}, {
				key: "boxContainsSphere",
				value: function(e, t) {
					var r = e.min,
						n = r.x,
						i = r.y,
						a = r.z,
						s = e.max,
						l = s.x,
						u = s.y,
						c = s.z,
						h = t.center,
						_ = h.x,
						d = h.y,
						f = h.z,
						m = t.radius;
					return o.Clamp(h, r, s, CollisionUtils._tempV30), o.distanceSquared(h,
							CollisionUtils._tempV30) > m * m ? Me.Disjoint : n + m <= _ && _ <= l -
						m && l - n > m && i + m <= d && d <= u - m && u - i > m && a + m <= f &&
						f <= c - m && c - a > m ? Me.Contains : Me.Intersects
				}
			}, {
				key: "sphereContainsPoint",
				value: function(e, t) {
					return o.distanceSquared(t, e.center) <= e.radius * e.radius ? Me.Contains : Me
						.Disjoint
				}
			}, {
				key: "sphereContainsTriangle",
				value: function(e, t, r, n) {
					var i = CollisionUtils.sphereContainsPoint(e, t),
						a = CollisionUtils.sphereContainsPoint(e, r),
						o = CollisionUtils.sphereContainsPoint(e, n);
					return i == Me.Contains && a == Me.Contains && o == Me.Contains ? Me.Contains :
						CollisionUtils.intersectsSphereAndTriangle(e, t, r, n) ? Me.Intersects : Me
						.Disjoint
				}
			}, {
				key: "sphereContainsBox",
				value: function(e, t) {
					var r = e.center,
						n = r.x,
						i = r.y,
						a = r.z,
						s = e.radius,
						l = t.min,
						u = l.x,
						c = l.y,
						h = l.z,
						_ = t.max,
						d = _.x,
						f = _.y,
						m = _.z,
						p = CollisionUtils._tempV30;
					p.x, p.y, p.z;
					if (!CollisionUtils.intersectsBoxAndSphere(t, e)) return Me.Disjoint;
					var T = s * s;
					return n - u, i - f, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > T ?
						Me.Intersects : (n - d, i - f, a - m, o.scalarLengthSquared(CollisionUtils
							._tempV30) > T ? Me.Intersects : (n - d, i - c, a - m, o
							.scalarLengthSquared(CollisionUtils._tempV30) > T ? Me.Intersects :
							(n - u, i - c, a - m, o.scalarLengthSquared(CollisionUtils
								._tempV30) > T ? Me.Intersects : (n - u, i - f, a - h, o
									.scalarLengthSquared(CollisionUtils._tempV30) > T ? Me
									.Intersects : (n - d, i - f, a - h, o.scalarLengthSquared(
										CollisionUtils._tempV30) > T ? Me.Intersects : (n -
										d, i - c, a - h, o.scalarLengthSquared(
											CollisionUtils._tempV30) > T ? Me.Intersects : (
											n - u, i - c, a - h, o.scalarLengthSquared(
												CollisionUtils._tempV30) > T ? Me
											.Intersects : Me.Contains)))))))
				}
			}, {
				key: "sphereContainsSphere",
				value: function(e, t) {
					var r = e.radius,
						n = t.radius,
						i = o.distance(e.center, t.center);
					return r + n < i ? Me.Disjoint : r - n < i ? Me.Intersects : Me.Contains
				}
			}, {
				key: "closestPointPointTriangle",
				value: function(e, t, r, n, i) {
					o.subtract(r, t, CollisionUtils._tempV30), o.subtract(n, t, CollisionUtils
						._tempV31), o.subtract(e, t, CollisionUtils._tempV32), o.subtract(e, r,
						CollisionUtils._tempV33), o.subtract(e, n, CollisionUtils._tempV34);
					var a = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV32),
						s = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV32),
						l = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV33),
						u = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV33),
						c = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV34),
						h = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
					if (a <= 0 && s <= 0) t.cloneTo(i);
					else if (l >= 0 && u <= l) r.cloneTo(i);
					else {
						var _ = a * u - l * s;
						if (_ <= 0 && a >= 0 && l <= 0) {
							var d = a / (a - l);
							return o.scale(CollisionUtils._tempV30, d, i), void o.add(t, i, i)
						}
						if (h >= 0 && c <= h) n.cloneTo(i);
						else {
							var f = c * s - a * h;
							if (f <= 0 && s >= 0 && h <= 0) {
								var m = s / (s - h);
								return o.scale(CollisionUtils._tempV31, m, i), void o.add(t, i, i)
							}
							var p = l * h - c * u;
							if (p <= 0 && u - l >= 0 && c - h >= 0) {
								var T = (u - l) / (u - l + (c - h));
								return o.subtract(n, r, i), o.scale(i, T, i), void o.add(r, i, i)
							}
							var E = 1 / (p + f + _),
								g = f * E,
								y = _ * E;
							o.scale(CollisionUtils._tempV30, g, CollisionUtils._tempV35), o.scale(
								CollisionUtils._tempV31, y, CollisionUtils._tempV36), o.add(
								CollisionUtils._tempV35, CollisionUtils._tempV36, i), o.add(t,
								i, i)
						}
					}
				}
			}, {
				key: "closestPointPlanePoint",
				value: function(e, t, r) {
					var n = e.normal,
						i = o.dot(n, t) - e.distance;
					o.scale(n, i, CollisionUtils._tempV30), o.subtract(t, CollisionUtils._tempV30,
						r)
				}
			}, {
				key: "closestPointBoxPoint",
				value: function(e, t, r) {
					o.max(t, e.min, CollisionUtils._tempV30), o.min(CollisionUtils._tempV30, e.max,
						r)
				}
			}, {
				key: "closestPointSpherePoint",
				value: function(e, t, r) {
					var n = e.center;
					o.subtract(t, n, r), o.normalize(r, r), o.scale(r, e.radius, r), o.add(r, n, r)
				}
			}, {
				key: "closestPointSphereSphere",
				value: function(e, t, r) {
					var n = e.center;
					o.subtract(t.center, n, r), o.normalize(r, r), o.scale(r, e.radius, r), o.add(r,
						n, r)
				}
			}]), CollisionUtils
		}();
		xe._tempV30 = new o, xe._tempV31 = new o, xe._tempV32 = new o, xe._tempV33 = new o, xe._tempV34 = new o, xe
			._tempV35 = new o, xe._tempV36 = new o, (De = e.FrustumCorner || (e.FrustumCorner = {}))[De.FarBottomLeft =
				0] = "FarBottomLeft", De[De.FarTopLeft = 1] = "FarTopLeft", De[De.FarTopRight = 2] = "FarTopRight", De[
				De.FarBottomRight = 3] = "FarBottomRight", De[De.nearBottomLeft = 4] = "nearBottomLeft", De[De
				.nearTopLeft = 5] = "nearTopLeft", De[De.nearTopRight = 6] = "nearTopRight", De[De.nearBottomRight =
			7] = "nearBottomRight", De[De.unknown = 8] = "unknown";
		var Ae = function() {
			function BoundFrustum(e) {
				_classCallCheck(this, BoundFrustum), this._matrix = e, this._near = new Re(new o), this._far =
					new Re(new o), this._left = new Re(new o), this._right = new Re(new o), this._top = new Re(
						new o), this._bottom = new Re(new o), BoundFrustum.getPlanesFromMatrix(this._matrix, this
						._near, this._far, this._left, this._right, this._top, this._bottom)
			}
			return _createClass(BoundFrustum, [{
				key: "equalsBoundFrustum",
				value: function(e) {
					return this._matrix.equalsOtherMatrix(e.matrix)
				}
			}, {
				key: "equalsObj",
				value: function(e) {
					if (e instanceof BoundFrustum) {
						var t = e;
						return this.equalsBoundFrustum(t)
					}
					return !1
				}
			}, {
				key: "getPlane",
				value: function(e) {
					switch (e) {
						case 0:
							return this._near;
						case 1:
							return this._far;
						case 2:
							return this._left;
						case 3:
							return this._right;
						case 4:
							return this._top;
						case 5:
							return this._bottom;
						default:
							return null
					}
				}
			}, {
				key: "getCorners",
				value: function(t) {
					BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._right, t[e
							.FrustumCorner.nearBottomRight]), BoundFrustum.get3PlaneInterPoint(this
							._near, this._top, this._right, t[e.FrustumCorner.nearTopRight]),
						BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._left, t[e
							.FrustumCorner.nearTopLeft]), BoundFrustum.get3PlaneInterPoint(this
							._near, this._bottom, this._left, t[e.FrustumCorner.nearBottomLeft]),
						BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._right, t[e
							.FrustumCorner.FarBottomRight]), BoundFrustum.get3PlaneInterPoint(this
							._far, this._top, this._right, t[e.FrustumCorner.FarTopRight]),
						BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._left, t[e
							.FrustumCorner.FarTopLeft]), BoundFrustum.get3PlaneInterPoint(this._far,
							this._bottom, this._left, t[e.FrustumCorner.FarBottomLeft])
				}
			}, {
				key: "containsPoint",
				value: function(e) {
					for (var t = Re.PlaneIntersectionType_Front, r = Re.PlaneIntersectionType_Front,
							n = 0; n < 6; n++) {
						switch (n) {
							case 0:
								r = xe.intersectsPlaneAndPoint(this._near, e);
								break;
							case 1:
								r = xe.intersectsPlaneAndPoint(this._far, e);
								break;
							case 2:
								r = xe.intersectsPlaneAndPoint(this._left, e);
								break;
							case 3:
								r = xe.intersectsPlaneAndPoint(this._right, e);
								break;
							case 4:
								r = xe.intersectsPlaneAndPoint(this._top, e);
								break;
							case 5:
								r = xe.intersectsPlaneAndPoint(this._bottom, e)
						}
						switch (r) {
							case Re.PlaneIntersectionType_Back:
								return Me.Disjoint;
							case Re.PlaneIntersectionType_Intersecting:
								t = Re.PlaneIntersectionType_Intersecting
						}
					}
					switch (t) {
						case Re.PlaneIntersectionType_Intersecting:
							return Me.Intersects;
						default:
							return Me.Contains
					}
				}
			}, {
				key: "intersects",
				value: function(e) {
					var t = e.min,
						r = e.max,
						n = t.x,
						i = t.y,
						a = t.z,
						o = r.x,
						s = r.y,
						l = r.z,
						u = this._near.normal;
					if (this._near.distance + u.x * (u.x < 0 ? n : o) + u.y * (u.y < 0 ? i : s) + u
						.z * (u.z < 0 ? a : l) < 0) return !1;
					var c = this._left.normal;
					if (this._left.distance + c.x * (c.x < 0 ? n : o) + c.y * (c.y < 0 ? i : s) + c
						.z * (c.z < 0 ? a : l) < 0) return !1;
					var h = this._right.normal;
					if (this._right.distance + h.x * (h.x < 0 ? n : o) + h.y * (h.y < 0 ? i : s) + h
						.z * (h.z < 0 ? a : l) < 0) return !1;
					var _ = this._bottom.normal;
					if (this._bottom.distance + _.x * (_.x < 0 ? n : o) + _.y * (_.y < 0 ? i : s) +
						_.z * (_.z < 0 ? a : l) < 0) return !1;
					var d = this._top.normal;
					if (this._top.distance + d.x * (d.x < 0 ? n : o) + d.y * (d.y < 0 ? i : s) + d
						.z * (d.z < 0 ? a : l) < 0) return !1;
					var f = this._far.normal;
					return !(this._far.distance + f.x * (f.x < 0 ? n : o) + f.y * (f.y < 0 ? i :
						s) + f.z * (f.z < 0 ? a : l) < 0)
				}
			}, {
				key: "containsBoundBox",
				value: function(e) {
					for (var t = BoundFrustum._tempV30, r = BoundFrustum._tempV31, n = e.min, i = e
							.max, a = Me.Contains, o = 0; o < 6; o++) {
						var s = this.getPlane(o),
							l = s.normal;
						if (l.x >= 0 ? (t.x = i.x, r.x = n.x) : (t.x = n.x, r.x = i.x), l.y >= 0 ? (
								t.y = i.y, r.y = n.y) : (t.y = n.y, r.y = i.y), l.z >= 0 ? (t.z = i
								.z, r.z = n.z) : (t.z = n.z, r.z = i.z), xe.intersectsPlaneAndPoint(
								s, t) === Re.PlaneIntersectionType_Back) return Me.Disjoint;
						xe.intersectsPlaneAndPoint(s, r) === Re.PlaneIntersectionType_Back && (a =
							Me.Intersects)
					}
					return a
				}
			}, {
				key: "containsBoundSphere",
				value: function(e) {
					for (var t = Re.PlaneIntersectionType_Front, r = Re.PlaneIntersectionType_Front,
							n = 0; n < 6; n++) {
						switch (n) {
							case 0:
								r = xe.intersectsPlaneAndSphere(this._near, e);
								break;
							case 1:
								r = xe.intersectsPlaneAndSphere(this._far, e);
								break;
							case 2:
								r = xe.intersectsPlaneAndSphere(this._left, e);
								break;
							case 3:
								r = xe.intersectsPlaneAndSphere(this._right, e);
								break;
							case 4:
								r = xe.intersectsPlaneAndSphere(this._top, e);
								break;
							case 5:
								r = xe.intersectsPlaneAndSphere(this._bottom, e)
						}
						switch (r) {
							case Re.PlaneIntersectionType_Back:
								return Me.Disjoint;
							case Re.PlaneIntersectionType_Intersecting:
								t = Re.PlaneIntersectionType_Intersecting
						}
					}
					switch (t) {
						case Re.PlaneIntersectionType_Intersecting:
							return Me.Intersects;
						default:
							return Me.Contains
					}
				}
			}, {
				key: "matrix",
				get: function() {
					return this._matrix
				},
				set: function(e) {
					e.cloneTo(this._matrix), BoundFrustum.getPlanesFromMatrix(this._matrix, this
						._near, this._far, this._left, this._right, this._top, this._bottom)
				}
			}, {
				key: "near",
				get: function() {
					return this._near
				}
			}, {
				key: "far",
				get: function() {
					return this._far
				}
			}, {
				key: "left",
				get: function() {
					return this._left
				}
			}, {
				key: "right",
				get: function() {
					return this._right
				}
			}, {
				key: "top",
				get: function() {
					return this._top
				}
			}, {
				key: "bottom",
				get: function() {
					return this._bottom
				}
			}], [{
				key: "getPlanesFromMatrix",
				value: function(e, t, r, n, i, a, o) {
					var s = e.elements,
						l = s[0],
						u = s[1],
						c = s[2],
						h = s[3],
						_ = s[4],
						d = s[5],
						f = s[6],
						m = s[7],
						p = s[8],
						T = s[9],
						E = s[10],
						g = s[11],
						y = s[12],
						S = s[13],
						v = s[14],
						R = s[15],
						C = t.normal;
					C.x = c, C.y = f, C.z = E, t.distance = v, t.normalize();
					var M = r.normal;
					M.x = h - c, M.y = m - f, M.z = g - E, r.distance = R - v, r.normalize();
					var D = n.normal;
					D.x = h + l, D.y = m + _, D.z = g + p, n.distance = R + y, n.normalize();
					var x = i.normal;
					x.x = h - l, x.y = m - _, x.z = g - p, i.distance = R - y, i.normalize();
					var A = a.normal;
					A.x = h - u, A.y = m - d, A.z = g - T, a.distance = R - S, a.normalize();
					var I = o.normal;
					I.x = h + u, I.y = m + d, I.z = g + T, o.distance = R + S, o.normalize()
				}
			}, {
				key: "get3PlaneInterPoint",
				value: function(e, t, r, n) {
					var i = e.normal,
						a = t.normal,
						s = r.normal;
					o.cross(a, s, BoundFrustum._tempV30), o.cross(s, i, BoundFrustum._tempV31), o
						.cross(i, a, BoundFrustum._tempV32);
					var l = o.dot(i, BoundFrustum._tempV30),
						u = o.dot(a, BoundFrustum._tempV31),
						c = o.dot(s, BoundFrustum._tempV32);
					o.scale(BoundFrustum._tempV30, -e.distance / l, BoundFrustum._tempV33), o.scale(
							BoundFrustum._tempV31, -t.distance / u, BoundFrustum._tempV34), o.scale(
							BoundFrustum._tempV32, -r.distance / c, BoundFrustum._tempV35), o.add(
							BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36), o
						.add(BoundFrustum._tempV35, BoundFrustum._tempV36, n)
				}
			}]), BoundFrustum
		}();
		Ae._tempV30 = new o, Ae._tempV31 = new o, Ae._tempV32 = new o, Ae._tempV33 = new o, Ae._tempV34 = new o, Ae
			._tempV35 = new o, Ae._tempV36 = new o;
		var Ie = function() {
			function Viewport(e, t, r, n) {
				_classCallCheck(this, Viewport), this.minDepth = 0, this.maxDepth = 1, this.x = e, this.y = t, this
					.width = r, this.height = n
			}
			return _createClass(Viewport, [{
				key: "project",
				value: function(e, t, r) {
					o.transformV3ToV4(e, t, r);
					var n = r.x,
						i = r.y,
						a = r.z,
						s = r.w;
					1 !== s && (n /= s, i /= s, a /= s), r.x = .5 * (n + 1) * this.width + this.x, r
						.y = .5 * (1 - i) * this.height + this.y, r.z = a * (this.maxDepth - this
							.minDepth) + this.minDepth
				}
			}, {
				key: "unprojectFromMat",
				value: function(e, t, r) {
					var n = t.elements;
					r.x = (e.x - this.x) / this.width * 2 - 1, r.y = -((e.y - this.y) / this
						.height * 2 - 1), r.z = (e.z - this.minDepth) / (this.maxDepth - this
						.minDepth);
					var i = r.x * n[3] + r.y * n[7] + r.z * n[11] + n[15];
					o.transformV3ToV3(r, t, r), 1 !== i && (r.x = r.x / i, r.y = r.y / i, r.z = r
						.z / i)
				}
			}, {
				key: "unprojectFromWVP",
				value: function(e, t, r, n, i) {
					c.multiply(t, r, Viewport._tempMatrix4x4), n && c.multiply(Viewport
							._tempMatrix4x4, n, Viewport._tempMatrix4x4), Viewport._tempMatrix4x4
						.invert(Viewport._tempMatrix4x4), this.unprojectFromMat(e, Viewport
							._tempMatrix4x4, i)
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e
						.minDepth = this.minDepth, e.maxDepth = this.maxDepth
				}
			}]), Viewport
		}();
		Ie._tempMatrix4x4 = new c;
		var Le, Pe = function() {
			function Picker() {
				_classCallCheck(this, Picker)
			}
			return _createClass(Picker, null, [{
				key: "calculateCursorRay",
				value: function(e, t, r, n, i, a) {
					var s = e.x,
						l = e.y,
						u = Picker._tempVector30,
						c = u;
					c.x = s, c.y = l, c.z = t.minDepth;
					var h = Picker._tempVector31,
						_ = h;
					_.x = s, _.y = l, _.z = t.maxDepth;
					var d = a.origin,
						f = Picker._tempVector32;
					t.unprojectFromWVP(u, r, n, i, d), t.unprojectFromWVP(h, r, n, i, f);
					var m = a.direction;
					m.x = f.x - d.x, m.y = f.y - d.y, m.z = f.z - d.z, o.normalize(a.direction, a
						.direction)
				}
			}, {
				key: "rayIntersectsTriangle",
				value: function(e, t, r, n) {
					var i = Picker._tempVector30,
						a = Picker._tempVector31;
					o.subtract(r, t, i), o.subtract(n, t, a);
					var s, l = Picker._tempVector32;
					if (o.cross(e.direction, a, l), (s = o.dot(i, l)) > -Number.MIN_VALUE && s <
						Number.MIN_VALUE) return Number.NaN;
					var u, c = 1 / s,
						h = Picker._tempVector33;
					if (o.subtract(e.origin, t, h), u = o.dot(h, l), (u *= c) < 0 || u > 1)
					return Number.NaN;
					var _, d, f = Picker._tempVector34;
					return o.cross(h, i, f), _ = o.dot(e.direction, f), (_ *= c) < 0 || u + _ > 1 ?
						Number.NaN : (d = o.dot(a, f), (d *= c) < 0 ? Number.NaN : d)
				}
			}]), Picker
		}();
		Pe._tempVector30 = new o, Pe._tempVector31 = new o, Pe._tempVector32 = new o, Pe._tempVector33 = new o, Pe
			._tempVector34 = new o, (Le = e.IndexFormat || (e.IndexFormat = {}))[Le.UInt8 = 0] = "UInt8", Le[Le.UInt16 =
				1] = "UInt16", Le[Le.UInt32 = 2] = "UInt32";
		var Oe = function(r) {
				function IndexBuffer3D(r, n) {
					var i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 35044,
						o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
					switch (_classCallCheck(this, IndexBuffer3D), (i = _possibleConstructorReturn(this, _getPrototypeOf(
							IndexBuffer3D).call(this)))._indexType = r, i._indexCount = n, i._bufferUsage = a, i
						._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER, i._canRead = o, r) {
						case e.IndexFormat.UInt32:
							i._indexTypeByteCount = 4;
							break;
						case e.IndexFormat.UInt16:
							i._indexTypeByteCount = 2;
							break;
						case e.IndexFormat.UInt8:
							i._indexTypeByteCount = 1;
							break;
						default:
							throw new Error("unidentification index type.")
					}
					var s = i._indexTypeByteCount * n,
						l = t.BufferStateBase._curBindedBufferState;
					if (i._byteLength = s, l ? l._bindedIndexBuffer === _assertThisInitialized(i) ? t.LayaGL.instance
						.bufferData(i._bufferType, s, i._bufferUsage) : (l.unBind(), i.bind(), t.LayaGL.instance
							.bufferData(i._bufferType, s, i._bufferUsage), l.bind()) : (i.bind(), t.LayaGL.instance
							.bufferData(i._bufferType, s, i._bufferUsage)), o) switch (r) {
						case e.IndexFormat.UInt32:
							i._buffer = new Uint32Array(n);
							break;
						case e.IndexFormat.UInt16:
							i._buffer = new Uint16Array(n);
							break;
						case e.IndexFormat.UInt8:
							i._buffer = new Uint8Array(n)
					}
					return i
				}
				return _inherits(IndexBuffer3D, r), _createClass(IndexBuffer3D, [{
					key: "_bindForVAO",
					value: function() {
						if (!t.BufferStateBase._curBindedBufferState)
						throw "IndexBuffer3D: must bind current BufferState.";
						var e = t.LayaGL.instance;
						e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer)
					}
				}, {
					key: "bind",
					value: function() {
						if (t.BufferStateBase._curBindedBufferState)
						throw "IndexBuffer3D: must unbind current BufferState.";
						if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
							var e = t.LayaGL.instance;
							return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer
								._bindedIndexBuffer = this._glBuffer, !0
						}
						return !1
					}
				}, {
					key: "setData",
					value: function(r) {
						var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
							a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] :
							4294967295,
							o = this._indexTypeByteCount;
						if (0 !== i || 4294967295 !== a) switch (this._indexType) {
							case e.IndexFormat.UInt32:
								r = new Uint32Array(r.buffer, i * o, a);
								break;
							case e.IndexFormat.UInt16:
								r = new Uint16Array(r.buffer, i * o, a);
								break;
							case e.IndexFormat.UInt8:
								r = new Uint8Array(r.buffer, i * o, a)
						}
						var s = t.BufferStateBase._curBindedBufferState;
						if (s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this
								._bufferType, n * o, r) : (s.unBind(), this.bind(), t.LayaGL.instance
								.bufferSubData(this._bufferType, n * o, r), s.bind()) : (this.bind(), t
								.LayaGL.instance.bufferSubData(this._bufferType, n * o, r)), this
							._canRead)
							if (0 !== n || 0 !== i || 4294967295 !== a) {
								var l = this._buffer.length - n;
								a > l && (a = l);
								for (var u = 0; u < a; u++) this._buffer[n + u] = r[u]
							} else this._buffer = r
					}
				}, {
					key: "getData",
					value: function() {
						if (this._canRead) return this._buffer;
						throw new Error("Can't read data from VertexBuffer with only write flag!")
					}
				}, {
					key: "destroy",
					value: function() {
						_get(_getPrototypeOf(IndexBuffer3D.prototype), "destroy", this).call(this), this
							._buffer = null, this._byteLength = 0, this._indexCount = 0
					}
				}, {
					key: "indexType",
					get: function() {
						return this._indexType
					}
				}, {
					key: "indexTypeByteCount",
					get: function() {
						return this._indexTypeByteCount
					}
				}, {
					key: "indexCount",
					get: function() {
						return this._indexCount
					}
				}, {
					key: "canRead",
					get: function() {
						return this._canRead
					}
				}]), IndexBuffer3D
			}(t.Buffer),
			Ne = function() {
				function VertexMesh() {
					_classCallCheck(this, VertexMesh)
				}
				return _createClass(VertexMesh, null, [{
					key: "__init__",
					value: function() {
						VertexMesh.instanceWorldMatrixDeclaration = new ie(64, [new ae(0, re.Vector4,
								VertexMesh.MESH_WORLDMATRIX_ROW0), new ae(16, re.Vector4,
								VertexMesh.MESH_WORLDMATRIX_ROW1), new ae(32, re.Vector4,
								VertexMesh.MESH_WORLDMATRIX_ROW2), new ae(48, re.Vector4,
								VertexMesh.MESH_WORLDMATRIX_ROW3)]), VertexMesh
							.instanceMVPMatrixDeclaration = new ie(64, [new ae(0, re.Vector4, VertexMesh
								.MESH_MVPMATRIX_ROW0), new ae(16, re.Vector4, VertexMesh
								.MESH_MVPMATRIX_ROW1), new ae(32, re.Vector4, VertexMesh
								.MESH_MVPMATRIX_ROW2), new ae(48, re.Vector4, VertexMesh
								.MESH_MVPMATRIX_ROW3)]), VertexMesh.instanceSimpleAnimatorDeclaration =
							new ie(16, [new ae(0, re.Vector4, VertexMesh.MESH_SIMPLEANIMATOR)])
					}
				}, {
					key: "getVertexDeclaration",
					value: function(e) {
						var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
							r = VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")];
						if (!r) {
							for (var n = e.split(","), i = 0, a = [], o = 0, s = n.length; o < s; o++) {
								var l;
								switch (n[o]) {
									case "POSITION":
										l = new ae(i, re.Vector3, VertexMesh.MESH_POSITION0), i += 12;
										break;
									case "NORMAL":
										l = new ae(i, re.Vector3, VertexMesh.MESH_NORMAL0), i += 12;
										break;
									case "COLOR":
										l = new ae(i, re.Vector4, VertexMesh.MESH_COLOR0), i += 16;
										break;
									case "UV":
										l = new ae(i, re.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0),
											i += 8;
										break;
									case "UV1":
										l = new ae(i, re.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1),
											i += 8;
										break;
									case "BLENDWEIGHT":
										l = new ae(i, re.Vector4, VertexMesh.MESH_BLENDWEIGHT0), i +=
										16;
										break;
									case "BLENDINDICES":
										t ? (l = new ae(i, re.Vector4, VertexMesh.MESH_BLENDINDICES0),
											i += 16) : (l = new ae(i, re.Byte4, VertexMesh
											.MESH_BLENDINDICES0), i += 4);
										break;
									case "TANGENT":
										l = new ae(i, re.Vector4, VertexMesh.MESH_TANGENT0), i += 16;
										break;
									default:
										throw "VertexMesh: unknown vertex flag."
								}
								a.push(l)
							}
							r = new ie(i, a), VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")] =
								r
						}
						return r
					}
				}]), VertexMesh
			}();
		Ne.MESH_POSITION0 = 0, Ne.MESH_COLOR0 = 1, Ne.MESH_TEXTURECOORDINATE0 = 2, Ne.MESH_NORMAL0 = 3, Ne
			.MESH_TANGENT0 = 4, Ne.MESH_BLENDINDICES0 = 5, Ne.MESH_BLENDWEIGHT0 = 6, Ne.MESH_TEXTURECOORDINATE1 = 7, Ne
			.MESH_WORLDMATRIX_ROW0 = 8, Ne.MESH_WORLDMATRIX_ROW1 = 9, Ne.MESH_WORLDMATRIX_ROW2 = 10, Ne
			.MESH_WORLDMATRIX_ROW3 = 11, Ne.MESH_MVPMATRIX_ROW0 = 12, Ne.MESH_MVPMATRIX_ROW1 = 13, Ne
			.MESH_MVPMATRIX_ROW2 = 14, Ne.MESH_MVPMATRIX_ROW3 = 15, Ne.MESH_SIMPLEANIMATOR = 7, Ne
			._vertexDeclarationMap = {};
		var be = function() {
				function SkyMesh() {
					_classCallCheck(this, SkyMesh)
				}
				return _createClass(SkyMesh, [{
					key: "_render",
					value: function(e) {}
				}]), SkyMesh
			}(),
			ke = function(r) {
				function SkyBox() {
					var r;
					_classCallCheck(this, SkyBox), r = _possibleConstructorReturn(this, _getPrototypeOf(SkyBox).call(
						this));
					var n = t.LayaGL.instance,
						i = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -
							1, -1, 1
						]),
						a = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3,
							2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0
						]),
						o = Ne.getVertexDeclaration("POSITION");
					r._vertexBuffer = new te(8 * o.vertexStride, n.STATIC_DRAW, !1), r._vertexBuffer.vertexDeclaration =
						o, r._indexBuffer = new Oe(e.IndexFormat.UInt8, 36, n.STATIC_DRAW, !1), r._vertexBuffer.setData(
							i.buffer), r._indexBuffer.setData(a);
					var s = new oe;
					return s.bind(), s.applyVertexBuffer(r._vertexBuffer), s.applyIndexBuffer(r._indexBuffer), s
					.unBind(), r._bufferState = s, r
				}
				return _inherits(SkyBox, r), _createClass(SkyBox, [{
					key: "_render",
					value: function(e) {
						var r = t.LayaGL.instance;
						r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces +=
							12, t.Stat.renderBatches++
					}
				}], [{
					key: "__init__",
					value: function() {
						SkyBox.instance = new SkyBox
					}
				}]), SkyBox
			}(be),
			we = function() {
				function SkyRenderer() {
					_classCallCheck(this, SkyRenderer), this._mesh = ke.instance
				}
				return _createClass(SkyRenderer, [{
					key: "_isAvailable",
					value: function() {
						return !(!this._material || !this._mesh)
					}
				}, {
					key: "_render",
					value: function(e) {
						if (this._material && this._mesh) {
							var r = t.LayaGL.instance,
								n = e.scene,
								i = e.cameraShaderValue,
								a = e.camera,
								s = ne._SET_RUNTIME_VALUE_MODE_REFERENCE_;
							t.ILaya.Render.supportWebGLPlusRendering && ne.setRuntimeValueMode(!1), t
								.WebGLContext.setCullFace(r, !1), t.WebGLContext.setDepthFunc(r, r
									.LEQUAL), t.WebGLContext.setDepthMask(r, !1);
							var l = SkyRenderer._compileDefine;
							this._material._shaderValues._defineDatas.cloneTo(l);
							var u = e.shader = this._material._shader.getSubShaderAt(0)._passes[0]
								.withCompile(l),
								h = u.bind(),
								_ = t.Stat.loopCount !== u._uploadMark,
								d = u._uploadScene !== n || _;
							(d || h) && (u.uploadUniforms(u._sceneUniformParamsMap, n._shaderValues, d),
								u._uploadScene = n);
							a._getRenderTexture();
							var f = u._uploadCameraShaderValue !== i || _;
							if (f || h) {
								var m = SkyRenderer._tempMatrix0,
									p = SkyRenderer._tempMatrix1;
								a.viewMatrix.cloneTo(m), a.projectionMatrix.cloneTo(p), m
									.setTranslationVector(o._ZERO), a.orthographic && c
									.createPerspective(a.fieldOfView, a.aspectRatio, a.nearPlane, a
										.farPlane, p);
								var T = 1 / Math.tan(3.1416 * a.fieldOfView / 180 * .5);
								p.elements[0] = T / a.aspectRatio, p.elements[5] = T, p.elements[10] =
									1e-6 - 1, p.elements[11] = -1, p.elements[14] = -0, a
									._applyViewProject(e, m, p), u.uploadUniforms(u
										._cameraUniformParamsMap, i, f), u._uploadCameraShaderValue = i
							}
							var E = u._uploadMaterial !== this._material || _;
							(E || h) && (u.uploadUniforms(u._materialUniformParamsMap, this._material
								._shaderValues, E), u._uploadMaterial = this._material), this._mesh
								._bufferState.bind(), this._mesh._render(e), t.ILaya.Render
								.supportWebGLPlusRendering && ne.setRuntimeValueMode(s), t.WebGLContext
								.setDepthFunc(r, r.LESS), t.WebGLContext.setDepthMask(r, !0), a
								._applyViewProject(e, a.viewMatrix, a.projectionMatrix)
						}
					}
				}, {
					key: "destroy",
					value: function() {
						this._material && (this._material._removeReference(), this._material = null)
					}
				}, {
					key: "material",
					get: function() {
						return this._material
					},
					set: function(e) {
						this._material !== e && (this._material && this._material._removeReference(),
							e && e._addReference(), this._material = e)
					}
				}, {
					key: "mesh",
					get: function() {
						return this._mesh
					},
					set: function(e) {
						this._mesh !== e && (this._mesh = e)
					}
				}]), SkyRenderer
			}();
		we._tempMatrix0 = new c, we._tempMatrix1 = new c, we._compileDefine = new ee;
		var Be, Ve = function(e) {
			function BaseCamera() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .3,
					r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
				return _classCallCheck(this, BaseCamera), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						BaseCamera).call(this)))._skyRenderer = new we, e._forward = new o, e._up = new o, e
					.clearColor = new i(100 / 255, 149 / 255, 237 / 255, 1), e._shaderValues = new ne(null), e
					._fieldOfView = 60, e._useUserProjectionMatrix = !1, e._orthographic = !1, e
					._orthographicVerticalSize = 10, e.renderingOrder = 0, e._nearPlane = t, e._farPlane = r, e
					.cullingMask = 2147483647, e.useOcclusionCulling = !0, e
			}
			return _inherits(BaseCamera, e), _createClass(BaseCamera, [{
				key: "_sortCamerasByRenderingOrder",
				value: function() {
					if (this.displayedInStage)
						for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++)
							if (e[r].renderingOrder > e[t].renderingOrder) {
								var n = e[r];
								e[r] = e[t], e[t] = n
							}
				}
			}, {
				key: "_calculateProjectionMatrix",
				value: function() {}
			}, {
				key: "_onScreenSizeChanged",
				value: function() {
					this._calculateProjectionMatrix()
				}
			}, {
				key: "_prepareCameraToRender",
				value: function() {
					var e = this._shaderValues;
					this.transform.getForward(this._forward), this.transform.getUp(this._up), e
						.setVector3(BaseCamera.CAMERAPOS, this.transform.position), e.setVector3(
							BaseCamera.CAMERADIRECTION, this._forward), e.setVector3(BaseCamera
							.CAMERAUP, this._up)
				}
			}, {
				key: "render",
				value: function() {
					arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments
						.length > 1 && void 0 !== arguments[1] && arguments[1]
				}
			}, {
				key: "addLayer",
				value: function(e) {
					this.cullingMask |= Math.pow(2, e)
				}
			}, {
				key: "removeLayer",
				value: function(e) {
					this.cullingMask &= ~Math.pow(2, e)
				}
			}, {
				key: "addAllLayers",
				value: function() {
					this.cullingMask = 2147483647
				}
			}, {
				key: "removeAllLayers",
				value: function() {
					this.cullingMask = 0
				}
			}, {
				key: "resetProjectionMatrix",
				value: function() {
					this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix()
				}
			}, {
				key: "_onActive",
				value: function() {
					this._scene._addCamera(this), _get(_getPrototypeOf(BaseCamera.prototype),
						"_onActive", this).call(this)
				}
			}, {
				key: "_onInActive",
				value: function() {
					this._scene._removeCamera(this), _get(_getPrototypeOf(BaseCamera.prototype),
						"_onInActive", this).call(this)
				}
			}, {
				key: "_parse",
				value: function(e, r) {
					_get(_getPrototypeOf(BaseCamera.prototype), "_parse", this).call(this, e, r),
						this.orthographic = e.orthographic, void 0 !== e.orthographicVerticalSize &&
						(this.orthographicVerticalSize = e.orthographicVerticalSize), void 0 !== e
						.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e
						.nearPlane, this.farPlane = e.farPlane;
					var n = e.clearColor;
					this.clearColor = new i(n[0], n[1], n[2], n[3]);
					var a = e.skyboxMaterial;
					a && (this._skyRenderer.material = t.Loader.getRes(a.path))
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event
						.RESIZE, this, this._onScreenSizeChanged), _get(_getPrototypeOf(
						BaseCamera.prototype), "destroy", this).call(this, e)
				}
			}, {
				key: "_create",
				value: function() {
					return new BaseCamera
				}
			}, {
				key: "skyRenderer",
				get: function() {
					return this._skyRenderer
				}
			}, {
				key: "fieldOfView",
				get: function() {
					return this._fieldOfView
				},
				set: function(e) {
					this._fieldOfView = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "nearPlane",
				get: function() {
					return this._nearPlane
				},
				set: function(e) {
					this._nearPlane = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "farPlane",
				get: function() {
					return this._farPlane
				},
				set: function(e) {
					this._farPlane = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "orthographic",
				get: function() {
					return this._orthographic
				},
				set: function(e) {
					this._orthographic = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "orthographicVerticalSize",
				get: function() {
					return this._orthographicVerticalSize
				},
				set: function(e) {
					this._orthographicVerticalSize = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "renderingOrder",
				get: function() {
					return this._renderingOrder
				},
				set: function(e) {
					this._renderingOrder = e, this._sortCamerasByRenderingOrder()
				}
			}]), BaseCamera
		}(Ee);
		Ve._tempMatrix4x40 = new c, Ve.CAMERAPOS = _e.propertyNameToID("u_CameraPos"), Ve.VIEWMATRIX = _e
			.propertyNameToID("u_View"), Ve.PROJECTMATRIX = _e.propertyNameToID("u_Projection"), Ve.VIEWPROJECTMATRIX =
			_e.propertyNameToID("u_ViewProjection"), Ve.CAMERADIRECTION = _e.propertyNameToID("u_CameraDirection"), Ve
			.CAMERAUP = _e.propertyNameToID("u_CameraUp"), Ve.VIEWPORT = _e.propertyNameToID("u_Viewport"), Ve
			.PROJECTION_PARAMS = _e.propertyNameToID("u_ProjectionParams"), Ve.RENDERINGTYPE_DEFERREDLIGHTING =
			"DEFERREDLIGHTING", Ve.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", Ve._invertYScaleMatrix = new c(
				1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), Ve._invertYProjectionMatrix = new c, Ve
			._invertYProjectionViewMatrix = new c, Ve.CLEARFLAG_SOLIDCOLOR = 0, Ve.CLEARFLAG_SKY = 1, Ve
			.CLEARFLAG_DEPTHONLY = 2, Ve.CLEARFLAG_NONE = 3, (Be = e.ShadowMode || (e.ShadowMode = {}))[Be.None = 0] =
			"None", Be[Be.Hard = 1] = "Hard", Be[Be.SoftLow = 2] = "SoftLow", Be[Be.SoftHigh = 3] = "SoftHigh";
		var Fe, Ue = function Scene3DShaderDeclaration() {
			_classCallCheck(this, Scene3DShaderDeclaration)
		};
		(Fe = e.LightType || (e.LightType = {}))[Fe.Directional = 0] = "Directional", Fe[Fe.Spot = 1] = "Spot", Fe[Fe
			.Point = 2] = "Point";
		var Ge, He, ze = function(t) {
			function LightSprite() {
				var t;
				return _classCallCheck(this, LightSprite), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						LightSprite).call(this)))._shadowMode = e.ShadowMode.None, t._isAlternate = !1, t
					._shadowResolution = 2048, t._shadowDistance = 50, t._shadowDepthBias = 1, t._shadowNormalBias =
					1, t._shadowNearPlane = .1, t._shadowStrength = 1, t._lightWoldMatrix = new c, t._intensity = 1,
					t._intensityColor = new o, t.color = new o(1, 1, 1), t._lightmapBakedType = LightSprite
					.LIGHTMAPBAKEDTYPE_REALTIME, t
			}
			return _inherits(LightSprite, t), _createClass(LightSprite, [{
				key: "_parse",
				value: function(e, t) {
					_get(_getPrototypeOf(LightSprite.prototype), "_parse", this).call(this, e, t);
					var r = e.color;
					this.color.fromArray(r), this.intensity = e.intensity, this.lightmapBakedType =
						e.lightmapBakedType
				}
			}, {
				key: "_cloneTo",
				value: function(e, t, r) {
					_get(_getPrototypeOf(LightSprite.prototype), "_cloneTo", this).call(this, e, t,
						r);
					var n = e;
					n.color = this.color.clone(), n.intensity = this.intensity, n
						.lightmapBakedType = this.lightmapBakedType
				}
			}, {
				key: "_addToScene",
				value: function() {
					var e = this._scene,
						t = w._config.maxLightCount;
					e._lightCount < t ? (e._lightCount++, this._addToLightQueue(), this
						._isAlternate = !1) : (e._alternateLights.add(this), this
						._isAlternate = !0, console.warn(
							"LightSprite:light count has large than maxLightCount,the latest added light will be ignore."
							))
				}
			}, {
				key: "_removeFromScene",
				value: function() {
					var e = this._scene;
					if (this._isAlternate) e._alternateLights.remove(this);
					else if (e._lightCount--, this._removeFromLightQueue(), e._alternateLights
						._length > 0) {
						var t = e._alternateLights.shift();
						t._addToLightQueue(), t._isAlternate = !1, e._lightCount++
					}
				}
			}, {
				key: "_addToLightQueue",
				value: function() {}
			}, {
				key: "_removeFromLightQueue",
				value: function() {}
			}, {
				key: "_onActive",
				value: function() {
					_get(_getPrototypeOf(LightSprite.prototype), "_onActive", this).call(this), this
						.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this
						._addToScene()
				}
			}, {
				key: "_onInActive",
				value: function() {
					_get(_getPrototypeOf(LightSprite.prototype), "_onInActive", this).call(this),
						this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this
						._removeFromScene()
				}
			}, {
				key: "_create",
				value: function() {
					return new LightSprite
				}
			}, {
				key: "intensity",
				get: function() {
					return this._intensity
				},
				set: function(e) {
					this._intensity = e
				}
			}, {
				key: "shadowMode",
				get: function() {
					return this._shadowMode
				},
				set: function(e) {
					this._shadowMode = e
				}
			}, {
				key: "shadowDistance",
				get: function() {
					return this._shadowDistance
				},
				set: function(e) {
					this._shadowDistance = e
				}
			}, {
				key: "shadowResolution",
				get: function() {
					return this._shadowResolution
				},
				set: function(e) {
					this._shadowResolution = e
				}
			}, {
				key: "shadowDepthBias",
				get: function() {
					return this._shadowDepthBias
				},
				set: function(e) {
					this._shadowDepthBias = e
				}
			}, {
				key: "shadowNormalBias",
				get: function() {
					return this._shadowNormalBias
				},
				set: function(e) {
					this._shadowNormalBias = e
				}
			}, {
				key: "shadowStrength",
				get: function() {
					return this._shadowStrength
				},
				set: function(e) {
					this._shadowStrength = e
				}
			}, {
				key: "shadowNearPlane",
				get: function() {
					return this._shadowNearPlane
				},
				set: function(e) {
					this._shadowNearPlane = e
				}
			}, {
				key: "lightmapBakedType",
				get: function() {
					return this._lightmapBakedType
				},
				set: function(e) {
					this._lightmapBakedType !== e && (this._lightmapBakedType = e, this
						.activeInHierarchy && (e !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this
							._addToScene() : this._removeFromScene()))
				}
			}, {
				key: "lightWorldMatrix",
				get: function() {
					var e = this.transform.position,
						t = this.transform.rotation;
					return c.createAffineTransformation(e, t, o._ONE, this._lightWoldMatrix), this
						._lightWoldMatrix
				}
			}, {
				key: "diffuseColor",
				get: function() {
					return console.log(
							"LightSprite: discard property,please use color property instead."),
						this.color
				},
				set: function(e) {
					console.log("LightSprite: discard property,please use color property instead."),
						this.color = e
				}
			}]), LightSprite
		}(Ee);
		ze.LIGHTMAPBAKEDTYPE_REALTIME = 0, ze.LIGHTMAPBAKEDTYPE_MIXED = 1, ze.LIGHTMAPBAKEDTYPE_BAKED = 2, (Ge = e
				.ShadowCascadesMode || (e.ShadowCascadesMode = {}))[Ge.NoCascades = 0] = "NoCascades", Ge[Ge
				.TwoCascades = 1] = "TwoCascades", Ge[Ge.FourCascades = 2] = "FourCascades",
			function(e) {
				e[e.Near = 0] = "Near", e[e.Far = 1] = "Far", e[e.Left = 2] = "Left", e[e.Right = 3] = "Right", e[e
					.Bottom = 4] = "Bottom", e[e.Top = 5] = "Top"
			}(He || (He = {}));
		var We, Xe, Ye = function() {
			function ShadowUtils() {
				_classCallCheck(this, ShadowUtils)
			}
			return _createClass(ShadowUtils, null, [{
				key: "supportShadow",
				value: function() {
					return t.LayaGL.layaGPUInstance._isWebGL2 || t.SystemUtils
						.supportRenderTextureFormat(t.RenderTextureFormat.Depth)
				}
			}, {
				key: "init",
				value: function() {
					t.LayaGL.layaGPUInstance._isWebGL2 ? ShadowUtils._shadowTextureFormat = t
						.RenderTextureFormat.ShadowMap : ShadowUtils._shadowTextureFormat = t
						.RenderTextureFormat.Depth
				}
			}, {
				key: "getTemporaryShadowTexture",
				value: function(e, r, n) {
					var i = $.createFromPool(e, r, ShadowUtils._shadowTextureFormat, n);
					return i.filterMode = t.FilterMode.Bilinear, i.wrapModeU = t.WarpMode.Clamp, i
						.wrapModeV = t.WarpMode.Clamp, i
				}
			}, {
				key: "getShadowBias",
				value: function(t, n, i, a) {
					var o;
					t._lightType == e.LightType.Directional ? o = 2 / n.elements[0] : t
						._lightType == e.LightType.Spot ? o = Math.tan(.5 * t.spotAngle * r
						.Deg2Rad) * t.range : (console.warn(
							"ShadowUtils:Only spot and directional shadow casters are supported now."
							), o = 0);
					var s = o / i,
						l = -t._shadowDepthBias * s,
						u = -t._shadowNormalBias * s;
					if (t.shadowMode == e.ShadowMode.SoftHigh) {
						l *= 2.5, u *= 2.5
					}
					a.setValue(l, u, 0, 0)
				}
			}, {
				key: "getCameraFrustumPlanes",
				value: function(e, t) {
					Ae.getPlanesFromMatrix(e, t[He.Near], t[He.Far], t[He.Left], t[He.Right], t[He
						.Top], t[He.Bottom])
				}
			}, {
				key: "getFarWithRadius",
				value: function(e, t) {
					return Math.sqrt(e * e / t)
				}
			}, {
				key: "getCascadesSplitDistance",
				value: function(t, r, n, i, a, o, s, l) {
					l[0] = n;
					var u = i - n,
						c = Math.tan(.5 * a),
						h = 1 + c * c * (o * o + 1);
					switch (s) {
						case e.ShadowCascadesMode.NoCascades:
							l[1] = ShadowUtils.getFarWithRadius(i, h);
							break;
						case e.ShadowCascadesMode.TwoCascades:
							l[1] = ShadowUtils.getFarWithRadius(n + u * t, h), l[2] = ShadowUtils
								.getFarWithRadius(i, h);
							break;
						case e.ShadowCascadesMode.FourCascades:
							l[1] = ShadowUtils.getFarWithRadius(n + u * r.x, h), l[2] = ShadowUtils
								.getFarWithRadius(n + u * r.y, h), l[3] = ShadowUtils
								.getFarWithRadius(n + u * r.z, h), l[4] = ShadowUtils
								.getFarWithRadius(i, h)
					}
				}
			}, {
				key: "applySliceTransform",
				value: function(e, t, r, n, i) {
					var a = ShadowUtils._tempMatrix0.elements,
						o = 1 / t,
						s = 1 / r;
					a[0] = e.resolution * o, a[5] = e.resolution * s, a[12] = e.offsetX * o, a[13] =
						e.offsetY * s, a[1] = a[2] = a[2] = a[4] = a[6] = a[7] = a[8] = a[9] = a[
						11] = a[14] = 0, a[10] = a[15] = 1;
					var l = 16 * n;
					P._mulMatrixArray(a, i, l, i, l)
				}
			}, {
				key: "getDirectionLightShadowCullPlanes",
				value: function(t, r, n, i, a, s) {
					var l = ShadowUtils._frustumCorners,
						u = ShadowUtils._backPlaneFaces,
						c = ShadowUtils._frustumPlaneNeighbors,
						h = ShadowUtils._frustumTwoPlaneCorners,
						_ = ShadowUtils._edgePlanePoint2,
						d = s.cullPlanes,
						f = t[He.Near],
						m = t[He.Far],
						p = t[He.Left],
						T = t[He.Right],
						E = t[He.Bottom],
						g = t[He.Top],
						y = n[r] - i,
						S = ShadowUtils._adjustNearPlane,
						v = ShadowUtils._adjustFarPlane;
					f.normal.cloneTo(S.normal), m.normal.cloneTo(v.normal), S.distance = f
						.distance - y, v.distance = Math.min(-f.distance + s.sphereCenterZ + s
							.splitBoundSphere.radius, m.distance), Ae.get3PlaneInterPoint(S, E, T,
							l[e.FrustumCorner.nearBottomRight]), Ae.get3PlaneInterPoint(S, g, T, l[e
							.FrustumCorner.nearTopRight]), Ae.get3PlaneInterPoint(S, g, p, l[e
							.FrustumCorner.nearTopLeft]), Ae.get3PlaneInterPoint(S, E, p, l[e
							.FrustumCorner.nearBottomLeft]), Ae.get3PlaneInterPoint(v, E, T, l[e
							.FrustumCorner.FarBottomRight]), Ae.get3PlaneInterPoint(v, g, T, l[e
							.FrustumCorner.FarTopRight]), Ae.get3PlaneInterPoint(v, g, p, l[e
							.FrustumCorner.FarTopLeft]), Ae.get3PlaneInterPoint(v, E, p, l[e
							.FrustumCorner.FarBottomLeft]);
					for (var R = 0, C = 0; C < 6; C++) {
						var M;
						switch (C) {
							case He.Near:
								M = S;
								break;
							case He.Far:
								M = v;
								break;
							default:
								M = t[C]
						}
						o.dot(M.normal, a) < 0 && (M.cloneTo(d[R]), u[R] = C, R++)
					}
					var D = R;
					for (C = 0; C < R; C++)
						for (var x = u[C], A = c[x], I = 0; I < 4; I++) {
							for (var L = A[I], P = !0, O = 0; O < R; O++)
								if (L == u[O]) {
									P = !1;
									break
								} if (P) {
								var N = h[x][L],
									b = l[N[0]],
									k = l[N[1]];
								o.add(b, a, _), Re.createPlaneBy3P(b, k, _, d[D++])
							}
						}
					s.cullPlaneCount = D
				}
			}, {
				key: "getBoundSphereByFrustum",
				value: function(e, t, r, n, i, a, s) {
					var l, u, c = Math.sqrt(1 + n * n) * Math.tan(r / 2),
						h = c * c,
						_ = t - e,
						d = t + e;
					h > _ / d ? (l = t, u = t * c) : (l = .5 * d * (1 + h), u = .5 * Math.sqrt(_ *
						_ + 2 * (t * t + e * e) * h + d * d * h * h));
					var f = s.center;
					return s.radius = u, o.scale(a, l, f), o.add(i, f, f), l
				}
			}, {
				key: "getMaxTileResolutionInAtlas",
				value: function(e, t, r) {
					for (var n = Math.min(e, t), i = Math.floor(e / n) * Math.floor(t / n); i < r;)
						n = Math.floor(n >> 1), i = Math.floor(e / n) * Math.floor(t / n);
					return n
				}
			}, {
				key: "getDirectionalLightMatrices",
				value: function(e, t, r, n, i, a, s, l) {
					var u = s.splitBoundSphere,
						h = u.center,
						_ = u.radius,
						d = a / 2,
						f = _ * d / (d - ShadowUtils.atlasBorderSize),
						m = 2 * f,
						p = a / m,
						T = m / a,
						E = Math.ceil(o.dot(h, e) * p) * T,
						g = Math.ceil(o.dot(h, t) * p) * T,
						y = o.dot(h, r);
					h.x = e.x * E + t.x * g + r.x * y, h.y = e.y * E + t.y * g + r.y * y, h.z = e
						.z * E + t.z * g + r.z * y;
					var S = s.position,
						v = s.viewMatrix,
						R = s.projectionMatrix,
						C = s.viewProjectMatrix;
					s.resolution = a, s.offsetX = n % 2 * a, s.offsetY = Math.floor(n / 2) * a, o
						.scale(r, _ + i, S), o.subtract(h, S, S), c.createLookAt(S, h, e, v), c
						.createOrthoOffCenter(-f, f, -f, f, 0, 2 * _ + i, R), c.multiply(R, v, C), P
						._mulMatrixArray(ShadowUtils._shadowMapScaleOffsetMatrix.elements, C
							.elements, 0, l, 16 * n)
				}
			}, {
				key: "getSpotLightShadowData",
				value: function(e, t, r, n, i, a) {
					var o = e.position = t.transform.position;
					e.resolution = r, a.setValue(1 / r, 1 / r, r, r), e.offsetX = 0, e.offsetY = 0;
					var s = t.lightWorldMatrix,
						l = e.viewMatrix,
						u = e.projectionMatrix,
						h = e.viewProjectMatrix,
						_ = e.cameraCullInfo.boundFrustum;
					s.invert(l), c.createPerspective(3.1416 * t.spotAngle / 180, 1, .1, t.range, u),
						n.y = t.shadowStrength, c.multiply(u, l, h), _.matrix = h, h.cloneTo(i), e
						.cameraCullInfo.position = o
				}
			}, {
				key: "prepareShadowReceiverShaderValues",
				value: function(e, t, r, n, i, a, o, s, l) {
					if (a.setValue(1 / t, 1 / r, t, r), o.setValue(e._shadowStrength, 0, 0, 0), i >
						1) {
						for (var u = 16 * i, c = 64; u < c; u++) s[u] = 0;
						for (u = 0; u < i; u++) {
							var h = n[u].splitBoundSphere,
								_ = h.center,
								d = h.radius,
								f = 4 * u;
							l[f] = _.x, l[f + 1] = _.y, l[f + 2] = _.z, l[f + 3] = d * d
						}
						for (u = 4 * i, c = 16; u < c; u++) l[u] = 0
					}
				}
			}]), ShadowUtils
		}();
		Ye._tempMatrix0 = new c, Ye._shadowMapScaleOffsetMatrix = new c(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, 1, 0, .5, .5, 0,
				1), Ye._frustumCorners = [new o, new o, new o, new o, new o, new o, new o, new o], Ye._adjustNearPlane =
			new Re(new o), Ye._adjustFarPlane = new Re(new o), Ye._backPlaneFaces = new Array(5), Ye._edgePlanePoint2 =
			new o, Ye._frustumPlaneNeighbors = [
				[He.Left, He.Right, He.Top, He.Bottom],
				[He.Left, He.Right, He.Top, He.Bottom],
				[He.Near, He.Far, He.Top, He.Bottom],
				[He.Near, He.Far, He.Top, He.Bottom],
				[He.Near, He.Far, He.Left, He.Right],
				[He.Near, He.Far, He.Left, He.Right]
			], Ye._frustumTwoPlaneCorners = [
				[
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearTopLeft],
					[e.FrustumCorner.nearTopRight, e.FrustumCorner.nearBottomRight],
					[e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearBottomLeft],
					[e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearTopRight]
				],
				[
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarBottomLeft],
					[e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarTopRight],
					[e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarBottomRight],
					[e.FrustumCorner.FarTopRight, e.FrustumCorner.FarTopLeft]
				],
				[
					[e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearBottomLeft],
					[e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarTopLeft],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.nearBottomLeft, e.FrustumCorner.FarBottomLeft],
					[e.FrustumCorner.FarTopLeft, e.FrustumCorner.nearTopLeft]
				],
				[
					[e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearTopRight],
					[e.FrustumCorner.FarTopRight, e.FrustumCorner.FarBottomRight],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.FarBottomRight, e.FrustumCorner.nearBottomRight],
					[e.FrustumCorner.nearTopRight, e.FrustumCorner.FarTopRight]
				],
				[
					[e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearBottomRight],
					[e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarBottomLeft],
					[e.FrustumCorner.FarBottomLeft, e.FrustumCorner.nearBottomLeft],
					[e.FrustumCorner.nearBottomRight, e.FrustumCorner.FarBottomRight],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown]
				],
				[
					[e.FrustumCorner.nearTopRight, e.FrustumCorner.nearTopLeft],
					[e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarTopRight],
					[e.FrustumCorner.nearTopLeft, e.FrustumCorner.FarTopLeft],
					[e.FrustumCorner.FarTopRight, e.FrustumCorner.nearTopRight],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown],
					[e.FrustumCorner.unknown, e.FrustumCorner.unknown]
				]
			], Ye.atlasBorderSize = 4, (We = e.CameraClearFlags || (e.CameraClearFlags = {}))[We.SolidColor = 0] =
			"SolidColor", We[We.Sky = 1] = "Sky", We[We.DepthOnly = 2] = "DepthOnly", We[We.Nothing = 3] = "Nothing", (
				Xe = e.CameraEventFlags || (e.CameraEventFlags = {}))[Xe.BeforeForwardOpaque = 0] =
			"BeforeForwardOpaque", Xe[Xe.BeforeSkyBox = 2] = "BeforeSkyBox", Xe[Xe.BeforeTransparent = 4] =
			"BeforeTransparent", Xe[Xe.BeforeImageEffect = 6] = "BeforeImageEffect", Xe[Xe.AfterEveryThing = 8] =
			"AfterEveryThing";
		var je = function(r) {
			function Camera() {
				var r, a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3,
					s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
				return _classCallCheck(this, Camera), (r = _possibleConstructorReturn(this, _getPrototypeOf(Camera)
						.call(this, o, s)))._updateViewMatrix = !0, r._postProcess = null, r._enableHDR = !1, r
					._viewportParams = new i, r._projectionParams = new i, r._needBuiltInRenderTexture = !1, r
					._offScreenRenderTexture = null, r._internalRenderTexture = null, r
					._cameraEventCommandBuffer = {}, r._clusterPlaneCacheFlag = new n(-1, -1), r
					._screenOffsetScale = new i, r.enableRender = !0, r.clearFlag = e.CameraClearFlags.SolidColor, r
					._viewMatrix = new c, r._projectionMatrix = new c, r._projectionViewMatrix = new c, r
					._viewport = new Ie(0, 0, 0, 0), r._normalizedViewport = new Ie(0, 0, 1, 1), r._aspectRatio = a,
					r._boundFrustum = new Ae(new c), r._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE,
						_assertThisInitialized(r), r._onScreenSizeChanged), r.transform.on(t.Event
						.TRANSFORM_CHANGED, _assertThisInitialized(r), r._onTransformChanged), r
			}
			return _inherits(Camera, r), _createClass(Camera, [{
				key: "_calculationViewport",
				value: function(e, t, r) {
					var n = e.x * t,
						i = e.y * r,
						a = n + Math.max(e.width * t, 0),
						o = i + Math.max(e.height * r, 0),
						s = Math.ceil(n),
						l = Math.ceil(i),
						u = Math.floor(a),
						c = Math.floor(o),
						h = s - n >= .5 ? Math.floor(n) : s,
						_ = l - i >= .5 ? Math.floor(i) : l,
						d = a - u >= .5 ? Math.ceil(a) : u,
						f = o - c >= .5 ? Math.ceil(o) : c;
					this._viewport.x = h, this._viewport.y = _, this._viewport.width = d - h, this
						._viewport.height = f - _
				}
			}, {
				key: "_calculateProjectionMatrix",
				value: function() {
					if (!this._useUserProjectionMatrix)
						if (this._orthographic) {
							var e = .5 * this.orthographicVerticalSize,
								t = e * this.aspectRatio;
							c.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this
								._projectionMatrix)
						} else c.createPerspective(3.1416 * this.fieldOfView / 180, this
							.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix)
				}
			}, {
				key: "_isLayerVisible",
				value: function(e) {
					return 0 != (Math.pow(2, e) & this.cullingMask)
				}
			}, {
				key: "_onTransformChanged",
				value: function(e) {
					(e &= f.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0)
				}
			}, {
				key: "_parse",
				value: function(e, t) {
					_get(_getPrototypeOf(Camera.prototype), "_parse", this).call(this, e, t);
					var r = e.clearFlag;
					void 0 !== r && (this.clearFlag = r);
					var n = e.viewport;
					this.normalizedViewport = new Ie(n[0], n[1], n[2], n[3]);
					var i = e.enableHDR;
					void 0 !== i && (this.enableHDR = i)
				}
			}, {
				key: "_getCanvasWidth",
				value: function() {
					return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : J
						.clientWidth
				}
			}, {
				key: "_getCanvasHeight",
				value: function() {
					return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : J
						.clientHeight
				}
			}, {
				key: "_getRenderTexture",
				value: function() {
					return this._internalRenderTexture || this._offScreenRenderTexture
				}
			}, {
				key: "_needInternalRenderTexture",
				value: function() {
					return !!(this._postProcess || this._enableHDR || this
						._needBuiltInRenderTexture)
				}
			}, {
				key: "_getRenderTextureFormat",
				value: function() {
					return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t
						.RenderTextureFormat.R8G8B8
				}
			}, {
				key: "_prepareCameraToRender",
				value: function() {
					_get(_getPrototypeOf(Camera.prototype), "_prepareCameraToRender", this).call(
						this);
					var e = this.viewport;
					this._viewportParams.setValue(e.x, e.y, e.width, e.height), this
						._projectionParams.setValue(this._nearPlane, this._farPlane, J._instance
							.invertY ? -1 : 1, 0), this._shaderValues.setVector(Ve.VIEWPORT, this
							._viewportParams), this._shaderValues.setVector(Ve.PROJECTION_PARAMS,
							this._projectionParams)
				}
			}, {
				key: "_applyViewProject",
				value: function(e, t, r) {
					var n, i = this._shaderValues;
					e.invertY ? (c.multiply(Ve._invertYScaleMatrix, r, Ve._invertYProjectionMatrix),
							c.multiply(Ve._invertYProjectionMatrix, t, Ve
								._invertYProjectionViewMatrix), r = Ve._invertYProjectionMatrix, n =
							Ve._invertYProjectionViewMatrix) : (c.multiply(r, t, this
							._projectionViewMatrix), n = this._projectionViewMatrix), e.viewMatrix =
						t, e.projectionMatrix = r, e.projectionViewMatrix = n, i.setMatrix4x4(Ve
							.VIEWMATRIX, t), i.setMatrix4x4(Ve.PROJECTMATRIX, r), i.setMatrix4x4(Ve
							.VIEWPROJECTMATRIX, n)
				}
			}, {
				key: "_updateClusterPlaneXY",
				value: function() {
					var e = this.fieldOfView,
						t = this.aspectRatio;
					if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !==
						t) {
						var r = w._config.lightClusterCount,
							n = r.x,
							i = r.y,
							a = n + 1,
							s = i + 1,
							l = this._clusterXPlanes,
							u = this._clusterYPlanes;
						if (!l) {
							l = this._clusterXPlanes = new Array(a), u = this._clusterYPlanes =
								new Array(s);
							for (var c = 0; c < a; c++) l[c] = new o;
							for (c = 0; c < s; c++) u[c] = new o
						}
						var h = Math.tan(this.fieldOfView / 2 * Math.PI / 180),
							_ = this.aspectRatio * h,
							d = 2 * h / n,
							f = 2 * _ / i;
						for (c = 0; c < a; c++) {
							var m = f * c - _,
								p = 1 / Math.sqrt(1 + m * m);
							l[c].setValue(p, 0, -m * p)
						}
						for (c = 0; c < s; c++) {
							m = h - d * c;
							var T = -1 / Math.sqrt(1 + m * m);
							u[c].setValue(0, T, -m * T)
						}
						this._clusterPlaneCacheFlag.x = e, this._clusterPlaneCacheFlag.y = t
					}
				}
			}, {
				key: "_applyCommandBuffer",
				value: function(e, r) {
					var n = t.LayaGL.instance,
						i = this._cameraEventCommandBuffer[e];
					i && 0 != i.length && (this._internalRenderTexture && this
						._internalRenderTexture._end(), i.forEach((function(e) {
							e._context = r, e._apply()
						})), $.currentActive && $.currentActive._end(), this
						._internalRenderTexture ? this._internalRenderTexture._start() : n
						.bindFramebuffer(n.FRAMEBUFFER, null), n.viewport(0, 0, r.viewport
							.width, r.viewport.height))
				}
			}, {
				key: "render",
				value: function() {
					var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					if (this.activeInHierarchy) {
						var i, a = this.viewport,
							o = this._needInternalRenderTexture(),
							s = t.LayaGL.instance,
							u = J._instance,
							c = u.scene = this._scene;
						u.pipelineMode = "Forward", o ? (this._internalRenderTexture = $
								.createFromPool(a.width, a.height, this._getRenderTextureFormat(), t
									.RenderTextureDepthFormat.DEPTH_16), this._internalRenderTexture
								.filterMode = t.FilterMode.Bilinear) : this._internalRenderTexture =
							null;
						var h = c._mainDirectionLight,
							_ = h && h.shadowMode !== e.ShadowMode.None && Ye.supportShadow();
						_ ? (c._shaderValues.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT), c
							._shaderValues.addDefine(Ue.SHADERDEFINE_SHADOW), (i = l.Scene3D
								._shadowCasterPass).update(this, h, l.ShadowLightType
								.DirectionLight), i.render(u, c, l.ShadowLightType
								.DirectionLight)) : c._shaderValues.removeDefine(Ue
							.SHADERDEFINE_SHADOW);
						var d = c._mainSpotLight,
							f = d && d.shadowMode !== e.ShadowMode.None && Ye.supportShadow();
						if (f ? (c._shaderValues.removeDefine(Ue.SHADERDEFINE_SHADOW), c
								._shaderValues.addDefine(Ue.SHADERDEFINE_SHADOW_SPOT), (i = l
									.Scene3D._shadowCasterPass).update(this, d, l.ShadowLightType
									.SpotLight), i.render(u, c, l.ShadowLightType.SpotLight)) : c
							._shaderValues.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT), _ && c
							._shaderValues.addDefine(Ue.SHADERDEFINE_SHADOW), f && c._shaderValues
							.addDefine(Ue.SHADERDEFINE_SHADOW_SPOT), u.camera = this, u
							.cameraShaderValue = this._shaderValues, Camera._updateMark++, c
							._preRenderScript(), o && !this._offScreenRenderTexture && (this
								.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e
								.CameraClearFlags.Nothing))
							if (this._enableHDR) {
								var m = $.createFromPool(a.width, a.height, t.RenderTextureFormat
									.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16);
								m.filterMode = t.FilterMode.Bilinear, t.WebGLContext.bindTexture(s,
										s.TEXTURE_2D, m._getSource()), s.copyTexSubImage2D(s
										.TEXTURE_2D, 0, 0, 0, a.x, J.clientHeight - (a.y + a
										.height), a.width, a.height), (E = fe.create(m, this
										._internalRenderTexture)).run(), E.recover(), $
									.recoverToPool(m)
							} else t.WebGLContext.bindTexture(s, s.TEXTURE_2D, this
								._internalRenderTexture._getSource()), s.copyTexSubImage2D(s
								.TEXTURE_2D, 0, 0, 0, a.x, J.clientHeight - (a.y + a.height), a
								.width, a.height);
						var p = this._getRenderTexture();
						p && p._start(), u.viewport = a, this._prepareCameraToRender();
						var T = w._config._multiLighting;
						if (T && ve.instance.update(this, this._scene), this._applyViewProject(u,
								this.viewMatrix, this._projectionMatrix), c._preCulling(u, this, r,
								n), c._clear(s, u), this._applyCommandBuffer(e.CameraEventFlags
								.BeforeForwardOpaque, u), c._renderScene(u, l.Scene3D
								.SCENERENDERFLAG_RENDERQPAQUE), this._applyCommandBuffer(e
								.CameraEventFlags.BeforeSkyBox, u), c._renderScene(u, l.Scene3D
								.SCENERENDERFLAG_SKYBOX), this._applyCommandBuffer(e
								.CameraEventFlags.BeforeTransparent, u), c._renderScene(u, l.Scene3D
								.SCENERENDERFLAG_RENDERTRANSPARENT), c._postRenderScript(), this
							._applyCommandBuffer(e.CameraEventFlags.BeforeImageEffect, u), p && p
							._end(), o) {
							if (this._postProcess) this._postProcess._render(), this._postProcess
								._applyPostProcessCommandBuffers();
							else if (this._enableHDR || this._needBuiltInRenderTexture) {
								var E, g = this._getCanvasWidth(),
									y = this._getCanvasHeight();
								this._screenOffsetScale.setValue(a.x / g, a.y / y, a.width / g, a
									.height / y), (E = fe.create(this._internalRenderTexture,
									this._offScreenRenderTexture ? this
									._offScreenRenderTexture : null, this
									._screenOffsetScale, null, null, 0, fe._SCREENTYPE_QUAD,
									null, !0)).run(), E.recover()
							}
							$.recoverToPool(this._internalRenderTexture)
						}
						this._applyCommandBuffer(e.CameraEventFlags.AfterEveryThing, u), (_ || f) &&
							i.cleanUp()
					}
				}
			}, {
				key: "viewportPointToRay",
				value: function(e, t) {
					Pe.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix,
						null, t)
				}
			}, {
				key: "normalizedViewportPointToRay",
				value: function(e, t) {
					var r = Camera._tempVector20,
						n = this.viewport;
					r.x = e.x * n.width, r.y = e.y * n.height, Pe.calculateCursorRay(r, this
						.viewport, this._projectionMatrix, this.viewMatrix, null, t)
				}
			}, {
				key: "worldToViewportPoint",
				value: function(e, r) {
					c.multiply(this._projectionMatrix, this._viewMatrix, this
						._projectionViewMatrix), this.viewport.project(e, this
							._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX, r.y =
						r.y / t.Laya.stage.clientScaleY
				}
			}, {
				key: "worldToNormalizedViewportPoint",
				value: function(e, r) {
					c.multiply(this._projectionMatrix, this._viewMatrix, this
						._projectionViewMatrix), this.normalizedViewport.project(e, this
							._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX, r.y =
						r.y / t.Laya.stage.clientScaleY
				}
			}, {
				key: "convertScreenCoordToOrthographicCoord",
				value: function(e, r) {
					if (this._orthographic) {
						var n = J.clientWidth,
							i = J.clientHeight,
							a = this.orthographicVerticalSize * this.aspectRatio / n,
							s = this.orthographicVerticalSize / i;
						return r.x = (-n / 2 + e.x * t.Laya.stage.clientScaleX) * a, r.y = (i / 2 -
							e.y * t.Laya.stage.clientScaleY) * s, r.z = (this.nearPlane - this
							.farPlane) * (e.z + 1) / 2 - this.nearPlane, o.transformCoordinate(
							r, this.transform.worldMatrix, r), !0
					}
					return !1
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					this._offScreenRenderTexture = null, this.transform.off(t.Event
						.TRANSFORM_CHANGED, this, this._onTransformChanged), _get(
						_getPrototypeOf(Camera.prototype), "destroy", this).call(this, e)
				}
			}, {
				key: "addCommandBuffer",
				value: function(e, t) {
					var r = this._cameraEventCommandBuffer[e];
					r || (r = this._cameraEventCommandBuffer[e] = []), r.indexOf(t) < 0 && r.push(
						t), t._camera = this
				}
			}, {
				key: "removeCommandBuffer",
				value: function(e, t) {
					var r = this._cameraEventCommandBuffer[e];
					if (!r) throw "Camera:unknown event.";
					var n = r.indexOf(t); - 1 != n && r.splice(n, 1)
				}
			}, {
				key: "removeCommandBuffers",
				value: function(e) {
					this._cameraEventCommandBuffer[e] && (this._cameraEventCommandBuffer[e].length =
						0)
				}
			}, {
				key: "_create",
				value: function() {
					return new Camera
				}
			}, {
				key: "aspectRatio",
				get: function() {
					if (0 === this._aspectRatio) {
						var e = this.viewport;
						return e.width / e.height
					}
					return this._aspectRatio
				},
				set: function(e) {
					if (e < 0) throw new Error(
						"Camera: the aspect ratio has to be a positive real number.");
					this._aspectRatio = e, this._calculateProjectionMatrix()
				}
			}, {
				key: "viewport",
				get: function() {
					return this._offScreenRenderTexture ? this._calculationViewport(this
						._normalizedViewport, this._offScreenRenderTexture.width, this
						._offScreenRenderTexture.height) : this._calculationViewport(this
						._normalizedViewport, J.clientWidth, J.clientHeight), this._viewport
				},
				set: function(e) {
					var t, r;
					this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this
							._offScreenRenderTexture.height) : (t = J.clientWidth, r = J
							.clientHeight), this._normalizedViewport.x = e.x / t, this
						._normalizedViewport.y = e.y / r, this._normalizedViewport.width = e.width /
						t, this._normalizedViewport.height = e.height / r, this
						._calculationViewport(this._normalizedViewport, t, r), this
						._calculateProjectionMatrix()
				}
			}, {
				key: "normalizedViewport",
				get: function() {
					return this._normalizedViewport
				},
				set: function(e) {
					var t, r;
					this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this
							._offScreenRenderTexture.height) : (t = J.clientWidth, r = J
							.clientHeight), this._normalizedViewport !== e && e.cloneTo(this
							._normalizedViewport), this._calculationViewport(e, t, r), this
						._calculateProjectionMatrix()
				}
			}, {
				key: "viewMatrix",
				get: function() {
					if (this._updateViewMatrix) {
						var e = this.transform.getWorldLossyScale(),
							t = e.x,
							r = e.y,
							n = e.z,
							i = this._viewMatrix.elements;
						this.transform.worldMatrix.cloneTo(this._viewMatrix), i[0] /= t, i[1] /= t,
							i[2] /= t, i[4] /= r, i[5] /= r, i[6] /= r, i[8] /= n, i[9] /= n, i[
							10] /= n, this._viewMatrix.invert(this._viewMatrix), this
							._updateViewMatrix = !1
					}
					return this._viewMatrix
				}
			}, {
				key: "projectionMatrix",
				get: function() {
					return this._projectionMatrix
				},
				set: function(e) {
					this._projectionMatrix = e, this._useUserProjectionMatrix = !0
				}
			}, {
				key: "projectionViewMatrix",
				get: function() {
					return c.multiply(this.projectionMatrix, this.viewMatrix, this
						._projectionViewMatrix), this._projectionViewMatrix
				}
			}, {
				key: "boundFrustum",
				get: function() {
					return this._boundFrustum.matrix = this.projectionViewMatrix, this._boundFrustum
				}
			}, {
				key: "renderTarget",
				get: function() {
					return this._offScreenRenderTexture
				},
				set: function(e) {
					var t = this._offScreenRenderTexture;
					t !== e && (t && (t._isCameraTarget = !1), e && (e._isCameraTarget = !0), this
						._offScreenRenderTexture = e, this._calculateProjectionMatrix())
				}
			}, {
				key: "postProcess",
				get: function() {
					return this._postProcess
				},
				set: function(e) {
					this._postProcess = e, e && e && e._init(this)
				}
			}, {
				key: "enableHDR",
				get: function() {
					return this._enableHDR
				},
				set: function(e) {
					!e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat
						.R16G16B16A16) ? this._enableHDR = e : console.warn(
						"Camera:can't enable HDR in this device.")
				}
			}, {
				key: "enableBuiltInRenderTexture",
				get: function() {
					return this._needBuiltInRenderTexture
				},
				set: function(e) {
					this._needBuiltInRenderTexture = e
				}
			}]), Camera
		}(Ve);
		je._tempVector20 = new n, je._updateMark = 0;
		var Ze = function() {
			function RenderElement() {
				_classCallCheck(this, RenderElement), this.renderSubShader = null, this.renderType = RenderElement
					.RENDERTYPE_NORMAL
			}
			return _createClass(RenderElement, [{
				key: "getInvertFront",
				value: function() {
					return this._transform._isFrontFaceInvert
				}
			}, {
				key: "setTransform",
				value: function(e) {
					this._transform = e
				}
			}, {
				key: "setGeometry",
				value: function(e) {
					this._geometry = e
				}
			}, {
				key: "addToOpaqueRenderQueue",
				value: function(e, t) {
					t.elements.add(this)
				}
			}, {
				key: "addToTransparentRenderQueue",
				value: function(e, t) {
					t.elements.add(this), t.lastTransparentBatched = !1, t
						.lastTransparentRenderElement = this
				}
			}, {
				key: "_update",
				value: function(e, t, r, n) {
					var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
					if (this.material) {
						var a = this.material._shader.getSubShaderAt(0);
						if (this.renderSubShader = null, r)
							if (n) {
								var o = a.getFlag(n);
								if (!o) return;
								for (var s = r._subShaders, l = 0, u = s.length; l < u; l++) {
									var c = s[l];
									if (o === c.getFlag(n)) {
										this.renderSubShader = c;
										break
									}
								}
								if (!this.renderSubShader) return
							} else this.renderSubShader = r.getSubShaderAt(i);
						else this.renderSubShader = a;
						var h = e._getRenderQueue(this.material.renderQueue);
						h.isTransparent ? this.addToTransparentRenderQueue(t, h) : this
							.addToOpaqueRenderQueue(t, h)
					}
				}
			}, {
				key: "_render",
				value: function(e) {
					var t, r, n, i = e.invertY,
						a = je._updateMark,
						o = e.scene,
						s = e.cameraShaderValue,
						l = this._transform,
						u = this._geometry;
					e.renderElement = this, a !== this.render._updateMark || this.renderType !==
						this.render._updateRenderType ? (this.render._renderUpdate(e, l), this
							.render._renderUpdateWithCamera(e, l), this.render._updateMark = a, this
							.render._updateRenderType = this.renderType) : this.renderType ==
						RenderElement.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l),
							this.render._renderUpdateWithCamera(e, l));
					var c = e.pipelineMode;
					if (u._prepareRender(e))
						for (var h = this.renderSubShader._passes, _ = 0, d = h.length; _ <
							d; _++) {
							var f = h[_];
							if (f._pipelineMode === c) {
								var m = RenderElement._compileDefine;
								o._shaderValues._defineDatas.cloneTo(m), m.addDefineDatas(this
									.render._shaderValues._defineDatas), m.addDefineDatas(this
									.material._shaderValues._defineDatas);
								var p = e.shader = f.withCompile(m),
									T = p.bind(),
									E = a !== p._uploadMark,
									g = p._uploadScene !== o || E;
								(g || T) && (p.uploadUniforms(p._sceneUniformParamsMap, o
									._shaderValues, g), p._uploadScene = o);
								var y = p._uploadRender !== this.render || p._uploadRenderType !==
									this.renderType || E;
								(y || T) && (p.uploadUniforms(p._spriteUniformParamsMap, this.render
										._shaderValues, y), p._uploadRender = this.render, p
									._uploadRenderType = this.renderType);
								var S = p._uploadCameraShaderValue !== s || E;
								(S || T) && (p.uploadUniforms(p._cameraUniformParamsMap, s, S), p
									._uploadCameraShaderValue = s);
								var v = p._uploadMaterial !== this.material || E;
								(v || T) && (p.uploadUniforms(p._materialUniformParamsMap, this
										.material._shaderValues, v), p._uploadMaterial = this
									.material);
								var R = this.material._shaderValues;
								t !== this.material || r !== p ? (p.uploadRenderStateBlendDepth(R),
										p.uploadRenderStateFrontFace(R, i, this.getInvertFront()),
										t = this.material, r = p, n = this.render) : n !== this
									.render && (p.uploadRenderStateFrontFace(R, i, this
										.getInvertFront()), n = this.render), u._render(e), p
									._uploadMark = a
							}
						}
					this.renderType !== RenderElement.RENDERTYPE_NORMAL && this.render
						._revertBatchRenderUpdate(e)
				}
			}, {
				key: "destroy",
				value: function() {
					this._transform = null, this._geometry = null, this.material = null, this
						.render = null
				}
			}]), RenderElement
		}();
		Ze.RENDERTYPE_NORMAL = 0, Ze.RENDERTYPE_STATICBATCH = 1, Ze.RENDERTYPE_INSTANCEBATCH = 2, Ze
			.RENDERTYPE_VERTEXBATCH = 3, Ze._compileDefine = new ee;
		var Qe = function(e) {
			function DrawRenderCMD() {
				return _classCallCheck(this, DrawRenderCMD), _possibleConstructorReturn(this, _getPrototypeOf(
					DrawRenderCMD).apply(this, arguments))
			}
			return _inherits(DrawRenderCMD, e), _createClass(DrawRenderCMD, [{
				key: "_elementRender",
				value: function(e, t) {
					var r, n, i, a = t.invertY,
						o = je._updateMark,
						s = t.scene,
						l = t.cameraShaderValue,
						u = e._transform,
						c = e._geometry;
					t.renderElement = e, o !== e.render._updateMark || e.renderType !== e.render
						._updateRenderType ? (e.render._renderUpdate(t, u), e.render
							._renderUpdateWithCamera(t, u), e.render._updateMark = o, e.render
							._updateRenderType = e.renderType) : e.renderType == Ze
						.RENDERTYPE_INSTANCEBATCH && (e.render._renderUpdate(t, u), e.render
							._renderUpdateWithCamera(t, u));
					var h = t.pipelineMode;
					if (c._prepareRender(t))
						for (var _ = e.renderSubShader._passes, d = 0, f = _.length; d < f; d++) {
							var m = _[d];
							if (m._pipelineMode === h) {
								var p = DrawRenderCMD._compileDefine;
								s._shaderValues._defineDatas.cloneTo(p), p.addDefineDatas(e.render
									._shaderValues._defineDatas), p.addDefineDatas(this
									._material._shaderValues._defineDatas);
								var T = t.shader = m.withCompile(p),
									E = T.bind(),
									g = o !== T._uploadMark,
									y = T._uploadScene !== s || g;
								(y || E) && (T.uploadUniforms(T._sceneUniformParamsMap, s
									._shaderValues, y), T._uploadScene = s);
								var S = T._uploadRender !== e.render || T._uploadRenderType !== e
									.renderType || g;
								(S || E) && (T.uploadUniforms(T._spriteUniformParamsMap, e.render
										._shaderValues, S), T._uploadRender = e.render, T
									._uploadRenderType = e.renderType);
								var v = T._uploadCameraShaderValue !== l || g;
								(v || E) && (T.uploadUniforms(T._cameraUniformParamsMap, l, v), T
									._uploadCameraShaderValue = l);
								var R = T._uploadMaterial !== this._material || g;
								(R || E) && (T.uploadUniforms(T._materialUniformParamsMap, this
										._material._shaderValues, R), T._uploadMaterial = this
									._material);
								var C = this._material._shaderValues;
								r !== this._material || n !== T ? (T.uploadRenderStateBlendDepth(C),
									T.uploadRenderStateFrontFace(C, a, e.getInvertFront()), r =
									this._material, n = T, i = e.render) : i !== e.render && (T
									.uploadRenderStateFrontFace(C, a, e.getInvertFront()), i = e
									.render), c._render(t), T._uploadMark = o
							}
						}
					e.renderType !== Ze.RENDERTYPE_NORMAL && e.render._revertBatchRenderUpdate(t)
				}
			}, {
				key: "run",
				value: function() {
					if (!this._material) throw "This render command material cannot be empty";
					this.setContext(this._commandBuffer._context);
					for (var e = this._context, t = e.scene, r = this._render._renderElements, n =
							0, i = r.length; n < i; n++) {
						var a = r[n];
						a._update(t, e, this._material._shader, null, this._subShaderIndex), this
							._elementRender(a, e)
					}
				}
			}, {
				key: "recover",
				value: function() {
					DrawRenderCMD._pool.push(this)
				}
			}], [{
				key: "create",
				value: function(e, t, r, n) {
					var i;
					return (i = DrawRenderCMD._pool.length > 0 ? DrawRenderCMD._pool.pop() :
							new DrawRenderCMD)._render = e, i._material = t, i._subShaderIndex = r,
						i._commandBuffer = n, i
				}
			}]), DrawRenderCMD
		}(de);
		Qe._pool = [], Qe._compileDefine = new ee;
		var qe = function(t) {
			function SetGlobalShaderDataCMD() {
				var e;
				return _classCallCheck(this, SetGlobalShaderDataCMD), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(SetGlobalShaderDataCMD).apply(this, arguments)))._nameID = 0, e._value =
					null, e._dataType = -1, e
			}
			return _inherits(SetGlobalShaderDataCMD, t), _createClass(SetGlobalShaderDataCMD, [{
				key: "run",
				value: function() {
					var t = this._commandBuffer._camera.scene._shaderValues;
					switch (this._dataType) {
						case e.ShaderDataType.Int:
							t.setInt(this._nameID, this._value);
							break;
						case e.ShaderDataType.Number:
							t.setNumber(this._nameID, this._value);
							break;
						case e.ShaderDataType.Bool:
							t.setBool(this._nameID, this._value);
							break;
						case e.ShaderDataType.Matrix4x4:
							t.setMatrix4x4(this._nameID, this._value);
							break;
						case e.ShaderDataType.Quaternion:
							t.setQuaternion(this._nameID, this._value);
							break;
						case e.ShaderDataType.Texture:
							t.setTexture(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector:
							t.setVector(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector2:
							t.setVector2(this._nameID, this._value);
							break;
						case e.ShaderDataType.Vector3:
							t.setVector3(this._nameID, this._value);
							break;
						case e.ShaderDataType.Buffer:
							t.setBuffer(this._nameID, this._value);
							break;
						default:
							throw "no type shaderValue on this CommendBuffer"
					}
				}
			}, {
				key: "recover",
				value: function() {
					SetGlobalShaderDataCMD._pool.push(this), this._nameID = 0, this._value = null,
						this._dataType = -1
				}
			}], [{
				key: "create",
				value: function(e, t, r, n) {
					var i;
					return (i = SetGlobalShaderDataCMD._pool.length > 0 ? SetGlobalShaderDataCMD
							._pool.pop() : new SetGlobalShaderDataCMD)._nameID = e, i._value = t, i
						._dataType = r, i._commandBuffer = n, i
				}
			}]), SetGlobalShaderDataCMD
		}(de);
		qe._pool = [];
		var Ke = function() {
				function CommandBuffer() {
					_classCallCheck(this, CommandBuffer), this._camera = null, this._commands = []
				}
				return _createClass(CommandBuffer, [{
					key: "_apply",
					value: function() {
						for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run()
					}
				}, {
					key: "setShaderDataTexture",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Texture, this))
					}
				}, {
					key: "setGlobalTexture",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Texture, this))
					}
				}, {
					key: "setShaderDataVector",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Vector, this))
					}
				}, {
					key: "setGlobalVector",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Vector, this))
					}
				}, {
					key: "setShaderDataVector3",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Vector3, this))
					}
				}, {
					key: "setGlobalVector3",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Vector3, this))
					}
				}, {
					key: "setShaderDataVector2",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Vector2, this))
					}
				}, {
					key: "setGlobalVector2",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Vector2, this))
					}
				}, {
					key: "setShaderDataNumber",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Number, this))
					}
				}, {
					key: "setGlobalNumber",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Number, this))
					}
				}, {
					key: "setShaderDataInt",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Int, this))
					}
				}, {
					key: "setGlobalInt",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Int, this))
					}
				}, {
					key: "setShaderDataMatrix",
					value: function(t, r, n) {
						this._commands.push(Te.create(t, r, n, e.ShaderDataType.Matrix4x4, this))
					}
				}, {
					key: "setGlobalMatrix",
					value: function(t, r) {
						this._commands.push(qe.create(t, r, e.ShaderDataType.Matrix4x4, this))
					}
				}, {
					key: "blitScreenQuad",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
							a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
						this._commands.push(fe.create(e, t, r, n, i, a, fe._SCREENTYPE_QUAD, this))
					}
				}, {
					key: "blitScreenQuadByMaterial",
					value: function(e, t) {
						var r, n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
							null,
							a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
							o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
						a && (r = a._shader, n = a.shaderData), this._commands.push(fe.create(e, t, i,
							r, n, o, fe._SCREENTYPE_QUAD, this))
					}
				}, {
					key: "blitScreenTriangle",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
							i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
							a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
							o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
						this._commands.push(fe.create(e, t, r, n, i, a, fe._SCREENTYPE_TRIANGLE, this,
							o))
					}
				}, {
					key: "setRenderTarget",
					value: function(e) {
						this._commands.push(pe.create(e))
					}
				}, {
					key: "clearRenderTarget",
					value: function(e, t, r) {
						var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
						this._commands.push(ye.create(e, t, r, n, this))
					}
				}, {
					key: "drawMesh",
					value: function(e, t, r, n, i) {
						this._commands.push(ge.create(e, t, r, n, i, this))
					}
				}, {
					key: "drawRender",
					value: function(e, t, r) {
						this._commands.push(Qe.create(e, t, r, this))
					}
				}, {
					key: "clear",
					value: function() {
						for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e]
							.recover();
						this._commands.length = 0
					}
				}]), CommandBuffer
			}(),
			Je = function PostProcessRenderContext() {
				_classCallCheck(this, PostProcessRenderContext), this.source = null, this.destination = null, this
					.camera = null, this.compositeShaderData = null, this.command = null, this
					.deferredReleaseTextures = []
			},
			$e = function() {
				function PostProcess() {
					_classCallCheck(this, PostProcess), this._compositeShader = _e.find("PostProcessComposite"), this
						._compositeShaderData = new ne, this._effects = [], this._context = null, this._context =
						new Je, this._context.compositeShaderData = this._compositeShaderData, this._context.command =
						new Ke
				}
				return _createClass(PostProcess, [{
					key: "_init",
					value: function(e) {
						this._context.camera = e, this._context.command._camera = e
					}
				}, {
					key: "_render",
					value: function() {
						var e = ne._SET_RUNTIME_VALUE_MODE_REFERENCE_;
						t.ILaya.Render.supportWebGLPlusRendering && ne.setRuntimeValueMode(!1);
						var r = this._context.camera,
							n = r.viewport,
							i = r._internalRenderTexture,
							a = i;
						this._context.command.clear(), this._context.source = a, this._context
							.destination = i, this._context.compositeShaderData.clearDefine(), this
							._context.compositeShaderData.setTexture(PostProcess
								.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
						for (var o = 0, s = this._effects.length; o < s; o++) this._effects[o].render(
							this._context);
						this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
						var l = r._offScreenRenderTexture,
							u = l || null;
						this._context.destination = u;
						var c = r._getCanvasWidth(),
							h = r._getCanvasHeight();
						r._screenOffsetScale.setValue(n.x / c, n.y / h, n.width / c, n.height / h), this
							._context.command.blitScreenTriangle(this._context.source, u, r
								._screenOffsetScale, this._compositeShader, this._compositeShaderData,
								0, !0), $.recoverToPool(a);
						var _ = this._context.deferredReleaseTextures;
						for (o = 0, s = _.length; o < s; o++) $.recoverToPool(_[o]);
						_.length = 0, t.ILaya.Render.supportWebGLPlusRendering && ne
							.setRuntimeValueMode(e)
					}
				}, {
					key: "addEffect",
					value: function(e) {
						this._effects.push(e)
					}
				}, {
					key: "removeEffect",
					value: function(e) {
						var t = this._effects.indexOf(e); - 1 !== t && this._effects.splice(t, 1)
					}
				}, {
					key: "_applyPostProcessCommandBuffers",
					value: function() {
						this._context.command._apply()
					}
				}], [{
					key: "__init__",
					value: function() {
						PostProcess.SHADERDEFINE_BLOOM_LOW = _e.getDefineByName("BLOOM_LOW"),
							PostProcess.SHADERDEFINE_BLOOM = _e.getDefineByName("BLOOM"), PostProcess
							.SHADERDEFINE_FINALPASS = _e.getDefineByName("FINALPASS")
					}
				}]), PostProcess
			}();
		$e.SHADERVALUE_MAINTEX = _e.propertyNameToID("u_MainTex"), $e.SHADERVALUE_BLOOMTEX = _e.propertyNameToID(
				"u_BloomTex"), $e.SHADERVALUE_AUTOEXPOSURETEX = _e.propertyNameToID("u_AutoExposureTex"), $e
			.SHADERVALUE_BLOOM_DIRTTEX = _e.propertyNameToID("u_Bloom_DirtTex"), $e.SHADERVALUE_BLOOMTEX_TEXELSIZE = _e
			.propertyNameToID("u_BloomTex_TexelSize"), $e.SHADERVALUE_BLOOM_DIRTTILEOFFSET = _e.propertyNameToID(
				"u_Bloom_DirtTileOffset"), $e.SHADERVALUE_BLOOM_SETTINGS = _e.propertyNameToID("u_Bloom_Settings"), $e
			.SHADERVALUE_BLOOM_COLOR = _e.propertyNameToID("u_Bloom_Color");
		var et = function(e) {
			function AnimationTransform3D(e) {
				var t;
				arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !==
					arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
					arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
				return _classCallCheck(this, AnimationTransform3D), (t = _possibleConstructorReturn(this,
						_getPrototypeOf(AnimationTransform3D).call(this)))._owner = e, t._children = [], t
					._localMatrix = new Float32Array(16), t._localPosition = new o, t._localRotation = new u, t
					._localScale = new o, t._worldMatrix = new Float32Array(16), t._localQuaternionUpdate = !1, t
					._locaEulerlUpdate = !1, t._localUpdate = !1, t._worldUpdate = !0, t
			}
			return _inherits(AnimationTransform3D, e), _createClass(AnimationTransform3D, [{
				key: "_getlocalMatrix",
				value: function() {
					return this._localUpdate && (P._createAffineTransformationArray(this
						._localPosition, this._localRotation, this._localScale, this
						._localMatrix), this._localUpdate = !1), this._localMatrix
				}
			}, {
				key: "_onWorldTransform",
				value: function() {
					if (!this._worldUpdate) {
						this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
						for (var e = 0, r = this._children.length; e < r; e++) this._children[e]
							._onWorldTransform()
					}
				}
			}, {
				key: "getWorldMatrix",
				value: function() {
					if (this._worldUpdate) {
						if (null != this._parent) P.matrix4x4MultiplyFFF(this._parent
							.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
						else {
							var e = this._worldMatrix;
							e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] =
								e[13] = e[14] = 0, e[0] = e[5] = e[10] = e[15] = 1
						}
						this._worldUpdate = !1
					}
					return this._worldMatrix
				}
			}, {
				key: "setParent",
				value: function(e) {
					if (this._parent !== e) {
						if (this._parent) {
							var t = this._parent._children,
								r = t.indexOf(this);
							t.splice(r, 1)
						}
						e && (e._children.push(this), e && this._onWorldTransform()), this._parent =
							e
					}
				}
			}, {
				key: "localPosition",
				get: function() {
					return this._localPosition
				},
				set: function(e) {
					this._localPosition = e, this._localUpdate = !0, this._onWorldTransform()
				}
			}, {
				key: "localRotation",
				get: function() {
					if (this._localQuaternionUpdate) {
						var e = this._localRotationEuler;
						u.createFromYawPitchRoll(e.y / AnimationTransform3D._angleToRandin, e.x /
								AnimationTransform3D._angleToRandin, e.z / AnimationTransform3D
								._angleToRandin, this._localRotation), this
							._localQuaternionUpdate = !1
					}
					return this._localRotation
				},
				set: function(e) {
					this._localRotation = e, this._locaEulerlUpdate = !0, this
						._localQuaternionUpdate = !1, this._localUpdate = !0, this
						._onWorldTransform()
				}
			}, {
				key: "localScale",
				get: function() {
					return this._localScale
				},
				set: function(e) {
					this._localScale = e, this._localUpdate = !0, this._onWorldTransform()
				}
			}, {
				key: "localRotationEuler",
				get: function() {
					if (this._locaEulerlUpdate) {
						this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
						var e = AnimationTransform3D._tempVector3,
							t = this._localRotationEuler;
						t.x = e.y * AnimationTransform3D._angleToRandin, t.y = e.x *
							AnimationTransform3D._angleToRandin, t.z = e.z * AnimationTransform3D
							._angleToRandin, this._locaEulerlUpdate = !1
					}
					return this._localRotationEuler
				},
				set: function(e) {
					this._localRotationEuler = e, this._locaEulerlUpdate = !1, this
						._localQuaternionUpdate = !0, this._localUpdate = !0, this
						._onWorldTransform()
				}
			}]), AnimationTransform3D
		}(t.EventDispatcher);
		et._tempVector3 = new o, et._angleToRandin = 180 / Math.PI;
		var tt = function() {
				function AnimationNode() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
						n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
					_classCallCheck(this, AnimationNode), this._children = [], this.transform = new et(this, e, t, r, n)
				}
				return _createClass(AnimationNode, [{
					key: "addChild",
					value: function(e) {
						e._parent = this, e.transform.setParent(this.transform), this._children.push(e)
					}
				}, {
					key: "removeChild",
					value: function(e) {
						var t = this._children.indexOf(e); - 1 !== t && this._children.splice(t, 1)
					}
				}, {
					key: "getChildByName",
					value: function(e) {
						for (var t = 0, r = this._children.length; t < r; t++) {
							var n = this._children[t];
							if (n.name === e) return n
						}
						return null
					}
				}, {
					key: "getChildByIndex",
					value: function(e) {
						return this._children[e]
					}
				}, {
					key: "getChildCount",
					value: function() {
						return this._children.length
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.name = this.name;
						for (var r = 0, n = this._children.length; r < n; r++) {
							var i = this._children[r],
								a = i.clone();
							t.addChild(a);
							var o = i.transform,
								s = a.transform,
								l = s.localPosition,
								u = s.localRotation,
								c = s.localScale;
							o.localPosition.cloneTo(l), o.localRotation.cloneTo(u), o.localScale
								.cloneTo(c), s.localPosition = l, s.localRotation = u, s.localScale = c
						}
					}
				}, {
					key: "clone",
					value: function() {
						var e = new AnimationNode;
						return this.cloneTo(e), e
					}
				}, {
					key: "_cloneNative",
					value: function(e, t, r, n, i, a, o) {
						var s = o._nativeCurCloneCount;
						i[s] = a;
						var l = new AnimationNode(new Float32Array(e.buffer, 3 * s * 4, 3),
							new Float32Array(t.buffer, 4 * s * 4, 4), new Float32Array(r.buffer, 3 *
								s * 4, 3), new Float32Array(n.buffer, 16 * s * 4, 16));
						return l._worldMatrixIndex = s, this._cloneToNative(l, e, t, r, n, i, s, o), l
					}
				}, {
					key: "_cloneToNative",
					value: function(e, t, r, n, i, a, o, s) {
						var l = e;
						l.name = this.name;
						for (var u = 0, c = this._children.length; u < c; u++) {
							var h = this._children[u];
							s._nativeCurCloneCount++;
							var _ = h._cloneNative(t, r, n, i, a, o, s);
							l.addChild(_);
							var d = h.transform,
								f = _.transform,
								m = f.localPosition,
								p = f.localRotation,
								T = f.localScale;
							d.localPosition.cloneTo(m), d.localRotation.cloneTo(p), d.localScale
								.cloneTo(T), f.localPosition = m, f.localRotation = p, f.localScale = T
						}
					}
				}]), AnimationNode
			}(),
			rt = function(e) {
				function Avatar() {
					var e;
					return _classCallCheck(this, Avatar), (e = _possibleConstructorReturn(this, _getPrototypeOf(Avatar)
						.call(this)))._nativeNodeCount = 0, e._nativeCurCloneCount = 0, e
				}
				return _inherits(Avatar, e), _createClass(Avatar, [{
					key: "_initCloneToAnimator",
					value: function(e, t) {
						t._avatarNodeMap[e.name] = e;
						for (var r = 0, n = e.getChildCount(); r < n; r++) this._initCloneToAnimator(e
							.getChildByIndex(r), t)
					}
				}, {
					key: "_parseNode",
					value: function(e, t) {
						var r = e.props.name;
						t.name = r;
						var n = e.props,
							i = t.transform,
							a = i.localPosition,
							o = i.localRotation,
							s = i.localScale;
						a.fromArray(n.translate), o.fromArray(n.rotation), s.fromArray(n.scale), i
							.localPosition = a, i.localRotation = o, i.localScale = s;
						for (var l = e.child, u = 0, c = l.length; u < c; u++) {
							var h = l[u],
								_ = new tt(new Float32Array(3), new Float32Array(4), new Float32Array(
									3), new Float32Array(16));
							t.addChild(_), this._parseNode(h, _)
						}
					}
				}, {
					key: "_cloneDatasToAnimator",
					value: function(e) {
						var t;
						t = this._rootNode.clone();
						var r = this._rootNode.transform,
							n = t.transform,
							i = n.localPosition,
							a = n.localRotation,
							o = n.localScale;
						r.localPosition.cloneTo(i), r.localRotation.cloneTo(a), r.localScale.cloneTo(o),
							n.localPosition = i, n.localRotation = a, n.localScale = o, e
							._avatarNodeMap = {}, this._initCloneToAnimator(t, e)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e,
							r = this._rootNode.clone();
						t._rootNode = r
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Avatar;
						return this.cloneTo(e), e
					}
				}, {
					key: "_cloneDatasToAnimatorNative",
					value: function(e) {
						var t = new Float32Array(3 * this._nativeNodeCount),
							r = new Float32Array(4 * this._nativeNodeCount),
							n = new Float32Array(3 * this._nativeNodeCount),
							i = new Float32Array(16 * this._nativeNodeCount),
							a = new Int16Array(this._nativeNodeCount);
						e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = r, e
							._animationNodeLocalScales = n, e._animationNodeWorldMatrixs = i, e
							._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
						var o = this._rootNode._cloneNative(t, r, n, i, a, -1, this),
							s = this._rootNode.transform,
							l = o.transform,
							u = l.localPosition,
							c = l.localRotation,
							h = l.localScale;
						s.localPosition.cloneTo(u), s.localRotation.cloneTo(c), s.localScale.cloneTo(h),
							l.localPosition = u, l.localRotation = c, l.localScale = h, e
							._avatarNodeMap = {}, this._initCloneToAnimator(o, e)
					}
				}], [{
					key: "_parse",
					value: function(e) {
						arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
							.length > 2 && void 0 !== arguments[2] && arguments[2];
						var t = new Avatar;
						if (t._rootNode = new tt(new Float32Array(3), new Float32Array(4),
								new Float32Array(3), new Float32Array(16)), e.version) {
							var r = e.rootNode;
							r && t._parseNode(r, t._rootNode)
						}
						return t
					}
				}, {
					key: "load",
					value: function(e, r) {
						t.ILaya.loader.create(e, r, null, Avatar.AVATAR)
					}
				}]), Avatar
			}(t.Resource);
		rt.AVATAR = "AVATAR";
		var nt = function(e) {
			function Material() {
				var e;
				return _classCallCheck(this, Material), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						Material).call(this)))._shaderValues = null, e._shaderValues = new ne(
						_assertThisInitialized(e)), e.renderQueue = Material.RENDERQUEUE_OPAQUE, e._alphaTest = !1,
					e
			}
			return _inherits(Material, e), _createClass(Material, [{
				key: "_removeTetxureReference",
				value: function() {
					var e = this._shaderValues.getData();
					for (var r in e) {
						var n = e[r];
						n && n instanceof t.BaseTexture && n._removeReference()
					}
				}
			}, {
				key: "_disposeResource",
				value: function() {
					this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues =
						null
				}
			}, {
				key: "_addReference",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
					_get(_getPrototypeOf(Material.prototype), "_addReference", this).call(this, e);
					var r = this._shaderValues.getData();
					for (var n in r) {
						var i = r[n];
						i && i instanceof t.BaseTexture && i._addReference()
					}
				}
			}, {
				key: "_removeReference",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
					_get(_getPrototypeOf(Material.prototype), "_removeReference", this).call(this,
						e), this._removeTetxureReference()
				}
			}, {
				key: "setShaderName",
				value: function(e) {
					if (this._shader = _e.find(e), !this._shader) throw new Error(
						"BaseMaterial: unknown shader name.")
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t.name = this.name, t.renderQueue = this.renderQueue, this._shaderValues
						.cloneTo(t._shaderValues)
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Material;
					return this.cloneTo(e), e
				}
			}, {
				key: "shaderData",
				get: function() {
					return this._shaderValues
				}
			}, {
				key: "alphaTestValue",
				get: function() {
					return this._shaderValues.getNumber(Material.ALPHATESTVALUE)
				},
				set: function(e) {
					this._shaderValues.setNumber(Material.ALPHATESTVALUE, e)
				}
			}, {
				key: "alphaTest",
				get: function() {
					return this._alphaTest
				},
				set: function(e) {
					this._alphaTest = e, e ? this._shaderValues.addDefine(Material
						.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Material
						.SHADERDEFINE_ALPHATEST)
				}
			}, {
				key: "_defineDatas",
				get: function() {
					return this._shaderValues._defineDatas
				}
			}], [{
				key: "load",
				value: function(e, r) {
					t.Laya.loader.create(e, r, null, Material.MATERIAL)
				}
			}, {
				key: "__initDefine__",
				value: function() {
					Material.SHADERDEFINE_ALPHATEST = _e.getDefineByName("ALPHATEST")
				}
			}, {
				key: "_parse",
				value: function(e) {
					arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
						.length > 2 && void 0 !== arguments[2] && arguments[2];
					var r, a = e,
						s = a.props,
						l = s.type,
						u = t.ClassUtils.getRegClass(l);
					if (!u) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
					switch (r = new u, a.version) {
						case "LAYAMATERIAL:01":
						case "LAYAMATERIAL:02":
							var c, h;
							for (var _ in s) switch (_) {
								case "type":
									break;
								case "vectors":
									var d = s[_];
									for (c = 0, h = d.length; c < h; c++) {
										var f = d[c],
											m = f.value;
										switch (m.length) {
											case 2:
												r[f.name] = new n(m[0], m[1]);
												break;
											case 3:
												r[f.name] = new o(m[0], m[1], m[2]);
												break;
											case 4:
												r[f.name] = new i(m[0], m[1], m[2], m[3]);
												break;
											default:
												throw new Error(
													"BaseMaterial:unkonwn color length.")
										}
									}
									break;
								case "textures":
									var p = s[_];
									for (c = 0, h = p.length; c < h; c++) {
										var T = p[c],
											E = T.path;
										E && (r[T.name] = t.Loader.getRes(E))
									}
									break;
								case "defines":
									var g = s[_];
									for (c = 0, h = g.length; c < h; c++) {
										var y = _e.getDefineByName(g[c]);
										r._shaderValues.addDefine(y)
									}
									break;
								case "renderStates":
									var S = s[_],
										v = S[0],
										R = r;
									R.blend = v.blend, R.cull = v.cull, R.depthTest = v
										.depthTest, R.depthWrite = v.depthWrite, R.blendSrc = v
										.srcBlend, R.blendDst = v.dstBlend;
									break;
								case "cull":
									r.cull = s[_];
									break;
								case "blend":
									r.blend = s[_];
									break;
								case "depthWrite":
									r.depthWrite = s[_];
									break;
								case "srcBlend":
									r.blendSrc = s[_];
									break;
								case "dstBlend":
									r.blendDst = s[_];
									break;
								default:
									r[_] = s[_]
							}
							break;
						default:
							throw new Error("BaseMaterial:unkonwn version.")
					}
					return r
				}
			}]), Material
		}(t.Resource);
		nt.MATERIAL = "MATERIAL", nt.RENDERQUEUE_OPAQUE = 2e3, nt.RENDERQUEUE_ALPHATEST = 2450, nt
			.RENDERQUEUE_TRANSPARENT = 3e3, nt.ALPHATESTVALUE = _e.propertyNameToID("u_AlphaTestValue"), nt
			.SHADERDEFINE_ALPHATEST = null;
		var it = function() {
			function BaseMaterial() {
				_classCallCheck(this, BaseMaterial)
			}
			return _createClass(BaseMaterial, null, [{
				key: "load",
				value: function(e, r) {
					t.Laya.loader.create(e, r, null, nt.MATERIAL)
				}
			}, {
				key: "__initDefine__",
				value: function() {
					BaseMaterial.SHADERDEFINE_ALPHATEST = nt.SHADERDEFINE_ALPHATEST
				}
			}]), BaseMaterial
		}();
		it.MATERIAL = "MATERIAL", it.RENDERQUEUE_OPAQUE = 2e3, it.RENDERQUEUE_ALPHATEST = 2450, it
			.RENDERQUEUE_TRANSPARENT = 3e3, it.ALPHATESTVALUE = _e.propertyNameToID("u_AlphaTestValue"), it
			.SHADERDEFINE_ALPHATEST = null;
		var at = function() {
			function RenderState() {
				_classCallCheck(this, RenderState), this.cull = RenderState.CULL_BACK, this.blend = RenderState
					.BLEND_DISABLE, this.srcBlend = RenderState.BLENDPARAM_ONE, this.dstBlend = RenderState
					.BLENDPARAM_ZERO, this.srcBlendRGB = RenderState.BLENDPARAM_ONE, this.dstBlendRGB = RenderState
					.BLENDPARAM_ZERO, this.srcBlendAlpha = RenderState.BLENDPARAM_ONE, this.dstBlendAlpha =
					RenderState.BLENDPARAM_ZERO, this.blendConstColor = new i(1, 1, 1, 1), this.blendEquation =
					RenderState.BLENDEQUATION_ADD, this.blendEquationRGB = RenderState.BLENDEQUATION_ADD, this
					.blendEquationAlpha = RenderState.BLENDEQUATION_ADD, this.depthTest = RenderState
					.DEPTHTEST_LEQUAL, this.depthWrite = !0
			}
			return _createClass(RenderState, [{
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t
						.dstBlend = this.dstBlend, t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB =
						this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha, t.dstBlendAlpha =
						this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor), t
						.blendEquation = this.blendEquation, t.blendEquationRGB = this
						.blendEquationRGB, t.blendEquationAlpha = this.blendEquationAlpha, t
						.depthTest = this.depthTest, t.depthWrite = this.depthWrite
				}
			}, {
				key: "clone",
				value: function() {
					var e = new RenderState;
					return this.cloneTo(e), e
				}
			}]), RenderState
		}();
		at.CULL_NONE = 0, at.CULL_FRONT = 1, at.CULL_BACK = 2, at.BLEND_DISABLE = 0, at.BLEND_ENABLE_ALL = 1, at
			.BLEND_ENABLE_SEPERATE = 2, at.BLENDPARAM_ZERO = 0, at.BLENDPARAM_ONE = 1, at.BLENDPARAM_SRC_COLOR = 768, at
			.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, at.BLENDPARAM_DST_COLOR = 774, at.BLENDPARAM_ONE_MINUS_DST_COLOR =
			775, at.BLENDPARAM_SRC_ALPHA = 770, at.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, at.BLENDPARAM_DST_ALPHA = 772,
			at.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, at.BLENDPARAM_SRC_ALPHA_SATURATE = 776, at.BLENDEQUATION_ADD =
			32774, at.BLENDEQUATION_SUBTRACT = 32778, at.BLENDEQUATION_REVERSE_SUBTRACT = 32779, at.DEPTHTEST_OFF = 0,
			at.DEPTHTEST_NEVER = 512, at.DEPTHTEST_LESS = 513, at.DEPTHTEST_EQUAL = 514, at.DEPTHTEST_LEQUAL = 515, at
			.DEPTHTEST_GREATER = 516, at.DEPTHTEST_NOTEQUAL = 517, at.DEPTHTEST_GEQUAL = 518, at.DEPTHTEST_ALWAYS = 519;
		var ot = function(e) {
			function BlinnPhongMaterial() {
				var e;
				_classCallCheck(this, BlinnPhongMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						BlinnPhongMaterial).call(this)))._enableVertexColor = !1, e.setShaderName("BLINNPHONG"), e
					._albedoIntensity = 1, e._albedoColor = new i(1, 1, 1, 1);
				var t = e._shaderValues;
				return t.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), t.setVector(
						BlinnPhongMaterial.MATERIALSPECULAR, new i(1, 1, 1, 1)), t.setNumber(BlinnPhongMaterial
						.SHININESS, .078125), t.setNumber(nt.ALPHATESTVALUE, .5), t.setVector(BlinnPhongMaterial
						.TILINGOFFSET, new i(1, 1, 0, 0)), e._enableLighting = !0, e.renderMode = BlinnPhongMaterial
					.RENDERMODE_OPAQUE, e
			}
			return _inherits(BlinnPhongMaterial, e), _createClass(BlinnPhongMaterial, [{
				key: "clone",
				value: function() {
					var e = new BlinnPhongMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					_get(_getPrototypeOf(BlinnPhongMaterial.prototype), "cloneTo", this).call(this,
						e);
					var t = e;
					t._enableLighting = this._enableLighting, t._albedoIntensity = this
						._albedoIntensity, t._enableVertexColor = this._enableVertexColor, this
						._albedoColor.cloneTo(t._albedoColor)
				}
			}, {
				key: "_ColorR",
				get: function() {
					return this._albedoColor.x
				},
				set: function(e) {
					this._albedoColor.x = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorG",
				get: function() {
					return this._albedoColor.y
				},
				set: function(e) {
					this._albedoColor.y = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorB",
				get: function() {
					return this._albedoColor.z
				},
				set: function(e) {
					this._albedoColor.z = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorA",
				get: function() {
					return this._albedoColor.w
				},
				set: function(e) {
					this._albedoColor.w = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_Color",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR)
				},
				set: function(e) {
					this.albedoColor = e
				}
			}, {
				key: "_SpecColorR",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x
				},
				set: function(e) {
					this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = e
				}
			}, {
				key: "_SpecColorG",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y
				},
				set: function(e) {
					this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = e
				}
			}, {
				key: "_SpecColorB",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z
				},
				set: function(e) {
					this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = e
				}
			}, {
				key: "_SpecColorA",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w
				},
				set: function(e) {
					this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = e
				}
			}, {
				key: "_SpecColor",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR)
				},
				set: function(e) {
					this.specularColor = e
				}
			}, {
				key: "_AlbedoIntensity",
				get: function() {
					return this._albedoIntensity
				},
				set: function(e) {
					if (this._albedoIntensity !== e) {
						var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
						i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this
							._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t)
					}
				}
			}, {
				key: "_Shininess",
				get: function() {
					return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS)
				},
				set: function(e) {
					e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(BlinnPhongMaterial
						.SHININESS, e)
				}
			}, {
				key: "_MainTex_STX",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x
				},
				set: function(e) {
					var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
					t.x = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STY",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y
				},
				set: function(e) {
					var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
					t.y = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STZ",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z
				},
				set: function(e) {
					var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
					t.z = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STW",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w
				},
				set: function(e) {
					var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
					t.w = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_ST",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET)
				},
				set: function(e) {
					this.tilingOffset = e
				}
			}, {
				key: "_Cutoff",
				get: function() {
					return this.alphaTestValue
				},
				set: function(e) {
					this.alphaTestValue = e
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case BlinnPhongMaterial.RENDERMODE_OPAQUE:
							this.alphaTest = !1, this.renderQueue = nt.RENDERQUEUE_OPAQUE, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS;
							break;
						case BlinnPhongMaterial.RENDERMODE_CUTOUT:
							this.renderQueue = nt.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS;
							break;
						case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS;
							break;
						default:
							throw new Error("Material:renderMode value error.")
					}
				}
			}, {
				key: "enableVertexColor",
				get: function() {
					return this._enableVertexColor
				},
				set: function(e) {
					this._enableVertexColor = e, e ? this._shaderValues.addDefine(BlinnPhongMaterial
						.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(
						BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR)
				}
			}, {
				key: "tilingOffsetX",
				get: function() {
					return this._MainTex_STX
				},
				set: function(e) {
					this._MainTex_STX = e
				}
			}, {
				key: "tilingOffsetY",
				get: function() {
					return this._MainTex_STY
				},
				set: function(e) {
					this._MainTex_STY = e
				}
			}, {
				key: "tilingOffsetZ",
				get: function() {
					return this._MainTex_STZ
				},
				set: function(e) {
					this._MainTex_STZ = e
				}
			}, {
				key: "tilingOffsetW",
				get: function() {
					return this._MainTex_STW
				},
				set: function(e) {
					this._MainTex_STW = e
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this
						._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET),
						this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "albedoColorR",
				get: function() {
					return this._ColorR
				},
				set: function(e) {
					this._ColorR = e
				}
			}, {
				key: "albedoColorG",
				get: function() {
					return this._ColorG
				},
				set: function(e) {
					this._ColorG = e
				}
			}, {
				key: "albedoColorB",
				get: function() {
					return this._ColorB
				},
				set: function(e) {
					this._ColorB = e
				}
			}, {
				key: "albedoColorA",
				get: function() {
					return this._ColorA
				},
				set: function(e) {
					this._ColorA = e
				}
			}, {
				key: "albedoColor",
				get: function() {
					return this._albedoColor
				},
				set: function(e) {
					var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
					i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues
						.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t)
				}
			}, {
				key: "albedoIntensity",
				get: function() {
					return this._albedoIntensity
				},
				set: function(e) {
					this._AlbedoIntensity = e
				}
			}, {
				key: "specularColorR",
				get: function() {
					return this._SpecColorR
				},
				set: function(e) {
					this._SpecColorR = e
				}
			}, {
				key: "specularColorG",
				get: function() {
					return this._SpecColorG
				},
				set: function(e) {
					this._SpecColorG = e
				}
			}, {
				key: "specularColorB",
				get: function() {
					return this._SpecColorB
				},
				set: function(e) {
					this._SpecColorB = e
				}
			}, {
				key: "specularColorA",
				get: function() {
					return this._SpecColorA
				},
				set: function(e) {
					this._SpecColorA = e
				}
			}, {
				key: "specularColor",
				get: function() {
					return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR)
				},
				set: function(e) {
					this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, e)
				}
			}, {
				key: "shininess",
				get: function() {
					return this._Shininess
				},
				set: function(e) {
					this._Shininess = e
				}
			}, {
				key: "albedoTexture",
				get: function() {
					return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) :
						this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP),
						this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, e)
				}
			}, {
				key: "normalTexture",
				get: function() {
					return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) :
						this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP),
						this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, e)
				}
			}, {
				key: "specularTexture",
				get: function() {
					return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) :
						this._shaderValues.removeDefine(BlinnPhongMaterial
						.SHADERDEFINE_SPECULARMAP), this._shaderValues.setTexture(BlinnPhongMaterial
							.SPECULARTEXTURE, e)
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(BlinnPhongMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(BlinnPhongMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(BlinnPhongMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(BlinnPhongMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = _e.getDefineByName("DIFFUSEMAP"),
						BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = _e.getDefineByName("NORMALMAP"),
						BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = _e.getDefineByName(
							"SPECULARMAP"), BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = _e
						.getDefineByName("TILINGOFFSET"), BlinnPhongMaterial
						.SHADERDEFINE_ENABLEVERTEXCOLOR = _e.getDefineByName("ENABLEVERTEXCOLOR")
				}
			}]), BlinnPhongMaterial
		}(nt);
		ot.RENDERMODE_OPAQUE = 0, ot.RENDERMODE_CUTOUT = 1, ot.RENDERMODE_TRANSPARENT = 2, ot.ALBEDOTEXTURE = _e
			.propertyNameToID("u_DiffuseTexture"), ot.NORMALTEXTURE = _e.propertyNameToID("u_NormalTexture"), ot
			.SPECULARTEXTURE = _e.propertyNameToID("u_SpecularTexture"), ot.ALBEDOCOLOR = _e.propertyNameToID(
				"u_DiffuseColor"), ot.MATERIALSPECULAR = _e.propertyNameToID("u_MaterialSpecular"), ot.SHININESS = _e
			.propertyNameToID("u_Shininess"), ot.TILINGOFFSET = _e.propertyNameToID("u_TilingOffset"), ot.CULL = _e
			.propertyNameToID("s_Cull"), ot.BLEND = _e.propertyNameToID("s_Blend"), ot.BLEND_SRC = _e.propertyNameToID(
				"s_BlendSrc"), ot.BLEND_DST = _e.propertyNameToID("s_BlendDst"), ot.DEPTH_TEST = _e.propertyNameToID(
				"s_DepthTest"), ot.DEPTH_WRITE = _e.propertyNameToID("s_DepthWrite");
		var st = function(e) {
			function EffectMaterial() {
				var e;
				return _classCallCheck(this, EffectMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						EffectMaterial).call(this))).setShaderName("Effect"), e._color = new i(1, 1, 1, 1), e
					._shaderValues.setVector(EffectMaterial.TINTCOLOR, new i(1, 1, 1, 1)), e.renderMode =
					EffectMaterial.RENDERMODE_ADDTIVE, e
			}
			return _inherits(EffectMaterial, e), _createClass(EffectMaterial, [{
				key: "clone",
				value: function() {
					var e = new EffectMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "_TintColorR",
				get: function() {
					return this._color.x
				},
				set: function(e) {
					this._color.x = e, this.color = this._color
				}
			}, {
				key: "_TintColorG",
				get: function() {
					return this._color.y
				},
				set: function(e) {
					this._color.y = e, this.color = this._color
				}
			}, {
				key: "_TintColorB",
				get: function() {
					return this._color.z
				},
				set: function(e) {
					this._color.z = e, this.color = this._color
				}
			}, {
				key: "_TintColorA",
				get: function() {
					return this._color.w
				},
				set: function(e) {
					this._color.w = e, this.color = this._color
				}
			}, {
				key: "_TintColor",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TINTCOLOR)
				},
				set: function(e) {
					this.color = e
				}
			}, {
				key: "_MainTex_STX",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x
				},
				set: function(e) {
					var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
					t.x = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STY",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y
				},
				set: function(e) {
					var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
					t.y = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STZ",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z
				},
				set: function(e) {
					var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
					t.z = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STW",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w
				},
				set: function(e) {
					var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
					t.w = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_ST",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET)
				},
				set: function(e) {
					this.tilingOffset = e
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case EffectMaterial.RENDERMODE_ADDTIVE:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_NONE, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE, this.depthTest = at.DEPTHTEST_LESS,
								this._shaderValues.addDefine(EffectMaterial
								.SHADERDEFINE_ADDTIVEFOG);
							break;
						case EffectMaterial.RENDERMODE_ALPHABLENDED:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_NONE, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS, this._shaderValues.removeDefine(EffectMaterial
									.SHADERDEFINE_ADDTIVEFOG);
							break;
						default:
							throw new Error("MeshEffectMaterial : renderMode value error.")
					}
				}
			}, {
				key: "colorR",
				get: function() {
					return this._TintColorR
				},
				set: function(e) {
					this._TintColorR = e
				}
			}, {
				key: "colorG",
				get: function() {
					return this._TintColorG
				},
				set: function(e) {
					this._TintColorG = e
				}
			}, {
				key: "colorB",
				get: function() {
					return this._TintColorB
				},
				set: function(e) {
					this._TintColorB = e
				}
			}, {
				key: "colorA",
				get: function() {
					return this._TintColorA
				},
				set: function(e) {
					this._TintColorA = e
				}
			}, {
				key: "color",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TINTCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(EffectMaterial.TINTCOLOR, e)
				}
			}, {
				key: "texture",
				get: function() {
					return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this
						._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE), this
						._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, e)
				}
			}, {
				key: "tilingOffsetX",
				get: function() {
					return this._MainTex_STX
				},
				set: function(e) {
					this._MainTex_STX = e
				}
			}, {
				key: "tilingOffsetY",
				get: function() {
					return this._MainTex_STY
				},
				set: function(e) {
					this._MainTex_STY = e
				}
			}, {
				key: "tilingOffsetZ",
				get: function() {
					return this._MainTex_STZ
				},
				set: function(e) {
					this._MainTex_STZ = e
				}
			}, {
				key: "tilingOffsetW",
				get: function() {
					return this._MainTex_STW
				},
				set: function(e) {
					this._MainTex_STW = e
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues
						.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues
						.setVector(EffectMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(EffectMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(EffectMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(EffectMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(EffectMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(EffectMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(EffectMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(EffectMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(EffectMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					EffectMaterial.SHADERDEFINE_MAINTEXTURE = _e.getDefineByName("MAINTEXTURE"),
						EffectMaterial.SHADERDEFINE_TILINGOFFSET = _e.getDefineByName(
							"TILINGOFFSET"), EffectMaterial.SHADERDEFINE_ADDTIVEFOG = _e
						.getDefineByName("ADDTIVEFOG")
				}
			}]), EffectMaterial
		}(nt);
		st.RENDERMODE_ADDTIVE = 0, st.RENDERMODE_ALPHABLENDED = 1, st.MAINTEXTURE = _e.propertyNameToID(
				"u_AlbedoTexture"), st.TINTCOLOR = _e.propertyNameToID("u_AlbedoColor"), st.TILINGOFFSET = _e
			.propertyNameToID("u_TilingOffset"), st.CULL = _e.propertyNameToID("s_Cull"), st.BLEND = _e
			.propertyNameToID("s_Blend"), st.BLEND_SRC = _e.propertyNameToID("s_BlendSrc"), st.BLEND_DST = _e
			.propertyNameToID("s_BlendDst"), st.DEPTH_TEST = _e.propertyNameToID("s_DepthTest"), st.DEPTH_WRITE = _e
			.propertyNameToID("s_DepthWrite");
		var lt, ut = function(e) {
			function ExtendTerrainMaterial() {
				var e;
				return _classCallCheck(this, ExtendTerrainMaterial), (e = _possibleConstructorReturn(this,
					_getPrototypeOf(ExtendTerrainMaterial).call(this)))._enableLighting = !0, e.setShaderName(
					"ExtendTerrain"), e.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE, e
			}
			return _inherits(ExtendTerrainMaterial, e), _createClass(ExtendTerrainMaterial, [{
				key: "_setDetailNum",
				value: function(e) {
					switch (e) {
						case 1:
							this._shaderValues.addDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM5);
							break;
						case 2:
							this._shaderValues.addDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM5);
							break;
						case 3:
							this._shaderValues.addDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM5);
							break;
						case 4:
							this._shaderValues.addDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM5);
							break;
						case 5:
							this._shaderValues.addDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(
									ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this
								._shaderValues.removeDefine(ExtendTerrainMaterial
									.SHADERDEFINE_DETAIL_NUM4)
					}
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ExtendTerrainMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "splatAlphaTexture",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, e)
				}
			}, {
				key: "diffuseTexture1",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, e), this
						._setDetailNum(1)
				}
			}, {
				key: "diffuseTexture2",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, e), this
						._setDetailNum(2)
				}
			}, {
				key: "diffuseTexture3",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, e), this
						._setDetailNum(3)
				}
			}, {
				key: "diffuseTexture4",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, e), this
						._setDetailNum(4)
				}
			}, {
				key: "diffuseTexture5",
				get: function() {
					return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5)
				},
				set: function(e) {
					this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, e), this
						._setDetailNum(5)
				}
			}, {
				key: "diffuseScaleOffset1",
				set: function(e) {
					this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, e)
				}
			}, {
				key: "diffuseScaleOffset2",
				set: function(e) {
					this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, e)
				}
			}, {
				key: "diffuseScaleOffset3",
				set: function(e) {
					this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, e)
				}
			}, {
				key: "diffuseScaleOffset4",
				set: function(e) {
					this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, e)
				}
			}, {
				key: "diffuseScaleOffset5",
				set: function(e) {
					this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, e)
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
							this.renderQueue = nt.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this
								.cull = at.CULL_BACK, this.blend = at.BLEND_DISABLE, this
								.depthTest = at.DEPTHTEST_LESS;
							break;
						case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
							this.renderQueue = nt.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this
								.cull = at.CULL_BACK, this.blend = at.BLEND_ENABLE_ALL, this
								.blendSrc = at.BLENDPARAM_SRC_ALPHA, this.blendDst = at
								.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LEQUAL;
							break;
						default:
							throw new Error("ExtendTerrainMaterial:renderMode value error.")
					}
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(ExtendTerrainMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(ExtendTerrainMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = _e.getDefineByName(
							"ExtendTerrain_DETAIL_NUM1"), ExtendTerrainMaterial
						.SHADERDEFINE_DETAIL_NUM2 = _e.getDefineByName("ExtendTerrain_DETAIL_NUM2"),
						ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = _e.getDefineByName(
							"ExtendTerrain_DETAIL_NUM3"), ExtendTerrainMaterial
						.SHADERDEFINE_DETAIL_NUM4 = _e.getDefineByName("ExtendTerrain_DETAIL_NUM4"),
						ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = _e.getDefineByName(
							"ExtendTerrain_DETAIL_NUM5")
				}
			}]), ExtendTerrainMaterial
		}(nt);
		ut.RENDERMODE_OPAQUE = 1, ut.RENDERMODE_TRANSPARENT = 2, ut.SPLATALPHATEXTURE = _e.propertyNameToID(
				"u_SplatAlphaTexture"), ut.DIFFUSETEXTURE1 = _e.propertyNameToID("u_DiffuseTexture1"), ut
			.DIFFUSETEXTURE2 = _e.propertyNameToID("u_DiffuseTexture2"), ut.DIFFUSETEXTURE3 = _e.propertyNameToID(
				"u_DiffuseTexture3"), ut.DIFFUSETEXTURE4 = _e.propertyNameToID("u_DiffuseTexture4"), ut
			.DIFFUSETEXTURE5 = _e.propertyNameToID("u_DiffuseTexture5"), ut.DIFFUSESCALEOFFSET1 = _e.propertyNameToID(
				"u_DiffuseScaleOffset1"), ut.DIFFUSESCALEOFFSET2 = _e.propertyNameToID("u_DiffuseScaleOffset2"), ut
			.DIFFUSESCALEOFFSET3 = _e.propertyNameToID("u_DiffuseScaleOffset3"), ut.DIFFUSESCALEOFFSET4 = _e
			.propertyNameToID("u_DiffuseScaleOffset4"), ut.DIFFUSESCALEOFFSET5 = _e.propertyNameToID(
				"u_DiffuseScaleOffset5"), ut.CULL = _e.propertyNameToID("s_Cull"), ut.BLEND = _e.propertyNameToID(
				"s_Blend"), ut.BLEND_SRC = _e.propertyNameToID("s_BlendSrc"), ut.BLEND_DST = _e.propertyNameToID(
				"s_BlendDst"), ut.DEPTH_TEST = _e.propertyNameToID("s_DepthTest"), ut.DEPTH_WRITE = _e.propertyNameToID(
				"s_DepthWrite"), (lt = e.PBRRenderMode || (e.PBRRenderMode = {}))[lt.Opaque = 0] = "Opaque", lt[lt
				.Cutout = 1] = "Cutout", lt[lt.Fade = 2] = "Fade", lt[lt.Transparent = 3] = "Transparent";
		var ct = function(t) {
			function PBRMaterial() {
				var t;
				return _classCallCheck(this, PBRMaterial), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						PBRMaterial).call(this)))._enableEmission = !1, t._shaderValues.setVector(PBRMaterial
						.ALBEDOCOLOR, new i(1, 1, 1, 1)), t._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR,
						new i(1, 1, 1, 1)), t._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, .5), t._shaderValues
					.setNumber(PBRMaterial.SMOOTHNESSSCALE, 1), t._shaderValues.setNumber(PBRMaterial
						.OCCLUSIONSTRENGTH, 1), t._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1), t
					._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, .001), t._shaderValues.setNumber(nt
						.ALPHATESTVALUE, .5), t.renderMode = e.PBRRenderMode.Opaque, t
			}
			return _inherits(PBRMaterial, t), _createClass(PBRMaterial, [{
				key: "albedoColor",
				get: function() {
					return this._shaderValues.getVector(PBRMaterial.ALBEDOCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, e)
				}
			}, {
				key: "albedoTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this
						._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE), this
						._shaderValues.setTexture(PBRMaterial.ALBEDOTEXTURE, e)
				}
			}, {
				key: "normalTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE) : this
						._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE), this
						._shaderValues.setTexture(PBRMaterial.NORMALTEXTURE, e)
				}
			}, {
				key: "normalTextureScale",
				get: function() {
					return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, e)
				}
			}, {
				key: "parallaxTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE) :
						this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE),
						this._shaderValues.setTexture(PBRMaterial.PARALLAXTEXTURE, e)
				}
			}, {
				key: "parallaxTextureScale",
				get: function() {
					return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(.005, Math.min(
						.08, e)))
				}
			}, {
				key: "occlusionTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) :
						this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE),
						this._shaderValues.setTexture(PBRMaterial.OCCLUSIONTEXTURE, e)
				}
			}, {
				key: "occlusionTextureStrength",
				get: function() {
					return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0, Math
						.min(1, e)))
				}
			}, {
				key: "smoothness",
				get: function() {
					return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0, Math.min(1,
						e)))
				}
			}, {
				key: "smoothnessTextureScale",
				get: function() {
					return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESSSCALE)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, Math.max(0, Math.min(
						1, e)))
				}
			}, {
				key: "enableEmission",
				get: function() {
					return this._enableEmission
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSION) : this
						._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSION), this
						._enableEmission = e
				}
			}, {
				key: "emissionColor",
				get: function() {
					return this._shaderValues.getVector(PBRMaterial.EMISSIONCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, e)
				}
			}, {
				key: "emissionTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE) :
						this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE),
						this._shaderValues.setTexture(PBRMaterial.EMISSIONTEXTURE, e)
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues
						.removeDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues
						.setVector(PBRMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(PBRMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(PBRMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(PBRMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(PBRMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(PBRMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(PBRMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(PBRMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(PBRMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(PBRMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(PBRMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(PBRMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(PBRMaterial.DEPTH_TEST, e)
				}
			}, {
				key: "renderMode",
				set: function(t) {
					switch (t) {
						case e.PBRRenderMode.Opaque:
							this.alphaTest = !1, this.renderQueue = nt.RENDERQUEUE_OPAQUE, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS, this
								._shaderValues.removeDefine(PBRMaterial
									.SHADERDEFINE_TRANSPARENTBLEND);
							break;
						case e.PBRRenderMode.Cutout:
							this.renderQueue = nt.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS, this
								._shaderValues.removeDefine(PBRMaterial
									.SHADERDEFINE_TRANSPARENTBLEND);
							break;
						case e.PBRRenderMode.Fade:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS, this._shaderValues.removeDefine(PBRMaterial
									.SHADERDEFINE_TRANSPARENTBLEND);
							break;
						case e.PBRRenderMode.Transparent:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_ONE, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS, this._shaderValues.addDefine(PBRMaterial
									.SHADERDEFINE_TRANSPARENTBLEND);
							break;
						default:
							throw new Error("PBRMaterial:unknown renderMode value.")
					}
				}
			}, {
				key: "enableReflection",
				get: function() {
					return !0
				},
				set: function(e) {}
			}], [{
				key: "__init__",
				value: function() {
					PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = _e.getDefineByName("ALBEDOTEXTURE"),
						PBRMaterial.SHADERDEFINE_NORMALTEXTURE = _e.getDefineByName(
						"NORMALTEXTURE"), PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = _e
						.getDefineByName("PARALLAXTEXTURE"), PBRMaterial
						.SHADERDEFINE_OCCLUSIONTEXTURE = _e.getDefineByName("OCCLUSIONTEXTURE"),
						PBRMaterial.SHADERDEFINE_EMISSION = _e.getDefineByName("EMISSION"),
						PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = _e.getDefineByName(
							"EMISSIONTEXTURE"), PBRMaterial.SHADERDEFINE_TILINGOFFSET = _e
						.getDefineByName("TILINGOFFSET"), PBRMaterial
						.SHADERDEFINE_TRANSPARENTBLEND = _e.getDefineByName("TRANSPARENTBLEND"),
						PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = _e.getDefineByName(
							"LAYA_PBR_BRDF_HIGH"), PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = _e
						.getDefineByName("LAYA_PBR_BRDF_LOW")
				}
			}]), PBRMaterial
		}(nt);
		ct.ALBEDOTEXTURE = _e.propertyNameToID("u_AlbedoTexture"), ct.ALBEDOCOLOR = _e.propertyNameToID(
			"u_AlbedoColor"), ct.TILINGOFFSET = _e.propertyNameToID("u_TilingOffset"), ct.NORMALTEXTURE = _e
			.propertyNameToID("u_NormalTexture"), ct.NORMALSCALE = _e.propertyNameToID("u_NormalScale"), ct.SMOOTHNESS =
			_e.propertyNameToID("u_Smoothness"), ct.SMOOTHNESSSCALE = _e.propertyNameToID("u_SmoothnessScale"), ct
			.OCCLUSIONTEXTURE = _e.propertyNameToID("u_OcclusionTexture"), ct.OCCLUSIONSTRENGTH = _e.propertyNameToID(
				"u_occlusionStrength"), ct.PARALLAXTEXTURE = _e.propertyNameToID("u_ParallaxTexture"), ct
			.PARALLAXSCALE = _e.propertyNameToID("u_ParallaxScale"), ct.EMISSIONTEXTURE = _e.propertyNameToID(
				"u_EmissionTexture"), ct.EMISSIONCOLOR = _e.propertyNameToID("u_EmissionColor"), ct.CULL = _e
			.propertyNameToID("s_Cull"), ct.BLEND = _e.propertyNameToID("s_Blend"), ct.BLEND_SRC = _e.propertyNameToID(
				"s_BlendSrc"), ct.BLEND_DST = _e.propertyNameToID("s_BlendDst"), ct.DEPTH_TEST = _e.propertyNameToID(
				"s_DepthTest"), ct.DEPTH_WRITE = _e.propertyNameToID("s_DepthWrite"), ct.renderQuality = e
			.PBRRenderQuality.High;
		var ht = function ShaderVariable() {
				_classCallCheck(this, ShaderVariable), this.textureID = -1
			},
			_t = function(e) {
				function ShaderInstance(e, t, r, n, i) {
					var a;
					return _classCallCheck(this, ShaderInstance), (a = _possibleConstructorReturn(this, _getPrototypeOf(
							ShaderInstance).call(this)))._stateParamsMap = [], a._uploadMark = -1, a
						._uploadRenderType = -1, a._vs = e, a._ps = t, a._attributeMap = r, a._uniformMap = n, a
						._shaderPass = i, a._globaluniformMap = [], a._create(), a.lock = !0, a
				}
				return _inherits(ShaderInstance, e), _createClass(ShaderInstance, [{
					key: "_create",
					value: function() {
						var e = t.LayaGL.instance;
						for (var r in this._program = e.createProgram(), this._vshader = this
								._createShader(e, this._vs, e.VERTEX_SHADER), this._pshader = this
								._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this
									._program, this._vshader), e.attachShader(this._program, this
									._pshader), this._attributeMap) e.bindAttribLocation(this._program,
							this._attributeMap[r], r);
						if (e.linkProgram(this._program), !t.Render.isConchApp && _e.debugMode && !e
							.getProgramParameter(this._program, e.LINK_STATUS)) throw e
							.getProgramInfoLog(this._program);
						var n = [],
							i = [],
							a = [],
							o = [],
							s = [];
						this._customUniformParamsMap = [];
						var l, u, c, h = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
						for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, u =
							0; u < h; u++) {
							var _ = e.getActiveUniform(this._program, u),
								d = _.name;
							(l = new ht).location = e.getUniformLocation(this._program, d), d.indexOf(
									"[0]") > 0 ? (l.name = d = d.substr(0, d.length - 3), l.isArray = !
									0) : (l.name = d, l.isArray = !1), l.type = _.type, this
								._addShaderUnifiormFun(l);
							var f = this._uniformMap[d];
							if (null != f) switch (l.dataOffset = _e.propertyNameToID(d), f) {
								case _e.PERIOD_CUSTOM:
									s.push(l);
									break;
								case _e.PERIOD_MATERIAL:
									o.push(l);
									break;
								case _e.PERIOD_SPRITE:
									a.push(l);
									break;
								case _e.PERIOD_CAMERA:
									i.push(l);
									break;
								case _e.PERIOD_SCENE:
									n.push(l);
									break;
								default:
									throw new Error("Shader3D: period is unkonw.")
							} else l.dataOffset = _e.propertyNameToID(d), this._globaluniformMap[
								d] = _e.PERIOD_SCENE, n.push(l)
						}
						for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n
								.length * 5 + 4, 64, !0), u = 0, c = n.length; u < c; u++) this
							._sceneUniformParamsMap.addShaderUniform(n[u]);
						for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i
								.length * 5 + 4, 64, !0), u = 0, c = i.length; u < c; u++) this
							._cameraUniformParamsMap.addShaderUniform(i[u]);
						for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a
								.length * 5 + 4, 64, !0), u = 0, c = a.length; u < c; u++) this
							._spriteUniformParamsMap.addShaderUniform(a[u]);
						for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 *
								o.length * 5 + 4, 64, !0), u = 0, c = o.length; u < c; u++) this
							._materialUniformParamsMap.addShaderUniform(o[u]);
						for (this._customUniformParamsMap.length = s.length, u = 0, c = s.length; u <
							c; u++) {
							var m = s[u];
							this._customUniformParamsMap[m.dataOffset] = m
						}
						var p = this._shaderPass._stateMap;
						for (var T in p) this._stateParamsMap[p[T]] = _e.propertyNameToID(T)
					}
				}, {
					key: "_getRenderState",
					value: function(e, t) {
						var r = this._stateParamsMap[t];
						return null == r ? null : e[r]
					}
				}, {
					key: "_disposeResource",
					value: function() {
						t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(
								this._pshader), t.LayaGL.instance.deleteProgram(this._program), this
							._vshader = this._pshader = this._program = null, this._setGPUMemory(0),
							this._curActTexIndex = 0
					}
				}, {
					key: "_addShaderUnifiormFun",
					value: function(e) {
						var r = t.LayaGL.instance;
						e.caller = this;
						var n = e.isArray;
						switch (e.type) {
							case r.BOOL:
								e.fun = this._uniform1i, e.uploadedValue = new Array(1);
								break;
							case r.INT:
								e.fun = n ? this._uniform1iv : this._uniform1i, e.uploadedValue =
									new Array(1);
								break;
							case r.FLOAT:
								e.fun = n ? this._uniform1fv : this._uniform1f, e.uploadedValue =
									new Array(1);
								break;
							case r.FLOAT_VEC2:
								e.fun = n ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue =
									new Array(2);
								break;
							case r.FLOAT_VEC3:
								e.fun = n ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue =
									new Array(3);
								break;
							case r.FLOAT_VEC4:
								e.fun = n ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue =
									new Array(4);
								break;
							case r.FLOAT_MAT2:
								e.fun = this._uniformMatrix2fv;
								break;
							case r.FLOAT_MAT3:
								e.fun = this._uniformMatrix3fv;
								break;
							case r.FLOAT_MAT4:
								e.fun = n ? this._uniformMatrix4fv : this._uniformMatrix4f;
								break;
							case r.SAMPLER_2D:
							case r.SAMPLER_2D_SHADOW:
								r.uniform1i(e.location, this._curActTexIndex), e.textureID = t
									.WebGLContext._glTextureIDs[this._curActTexIndex++], e.fun = this
									._uniform_sampler2D;
								break;
							case 35679:
								r.uniform1i(e.location, this._curActTexIndex), e.textureID = t
									.WebGLContext._glTextureIDs[this._curActTexIndex++], e.fun = this
									._uniform_sampler3D;
								break;
							case r.SAMPLER_CUBE:
								r.uniform1i(e.location, this._curActTexIndex), e.textureID = t
									.WebGLContext._glTextureIDs[this._curActTexIndex++], e.fun = this
									._uniform_samplerCube;
								break;
							default:
								throw new Error("compile shader err!")
						}
					}
				}, {
					key: "_createShader",
					value: function(e, t, r) {
						var n = e.createShader(r);
						if (e.shaderSource(n, t), e.compileShader(n), _e.debugMode && !e
							.getShaderParameter(n, e.COMPILE_STATUS)) throw e.getShaderInfoLog(n);
						return n
					}
				}, {
					key: "_uniform1f",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, n[0] = r), 1) : 0
					}
				}, {
					key: "_uniform1fv",
					value: function(e, r) {
						if (r.length < 4) {
							var n = e.uploadedValue;
							return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t
								.LayaGL.instance.uniform1fv(e.location, r), n[0] = r[0], n[1] = r[
								1], n[2] = r[2], n[3] = r[3], 1) : 0
						}
						return t.LayaGL.instance.uniform1fv(e.location, r), 1
					}
				}, {
					key: "_uniform_vec2",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r.x || n[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location,
							n[0] = r.x, n[1] = r.y), 1) : 0
					}
				}, {
					key: "_uniform_vec2v",
					value: function(e, r) {
						if (r.length < 2) {
							var n = e.uploadedValue;
							return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t
								.LayaGL.instance.uniform2fv(e.location, r), n[0] = r[0], n[1] = r[
								1], n[2] = r[2], n[3] = r[3], 1) : 0
						}
						return t.LayaGL.instance.uniform2fv(e.location, r), 1
					}
				}, {
					key: "_uniform_vec3",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z ? (t.LayaGL.instance
							.uniform3f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z), 1) : 0
					}
				}, {
					key: "_uniform_vec3v",
					value: function(e, r) {
						return t.LayaGL.instance.uniform3fv(e.location, r), 1
					}
				}, {
					key: "_uniform_vec4",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z || n[3] !== r.w ? (t.LayaGL
							.instance.uniform4f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z, n[
								3] = r.w), 1) : 0
					}
				}, {
					key: "_uniform_vec4v",
					value: function(e, r) {
						return t.LayaGL.instance.uniform4fv(e.location, r), 1
					}
				}, {
					key: "_uniformMatrix2fv",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r), 1
					}
				}, {
					key: "_uniformMatrix3fv",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r), 1
					}
				}, {
					key: "_uniformMatrix4f",
					value: function(e, r) {
						var n = r.elements;
						return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, n), 1
					}
				}, {
					key: "_uniformMatrix4fv",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1
					}
				}, {
					key: "_uniform1i",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, n[0] = r), 1) : 0
					}
				}, {
					key: "_uniform1iv",
					value: function(e, r) {
						return t.LayaGL.instance.uniform1iv(e.location, r), 1
					}
				}, {
					key: "_uniform_ivec2",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r[0] || n[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location,
							n[0] = r[0], n[1] = r[1]), 1) : 0
					}
				}, {
					key: "_uniform_ivec2v",
					value: function(e, r) {
						return t.LayaGL.instance.uniform2iv(e.location, r), 1
					}
				}, {
					key: "_uniform_vec3i",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] ? (t.LayaGL.instance
							.uniform3i(e.location, n[0] = r[0], n[1] = r[1], n[2] = r[2]), 1) : 0
					}
				}, {
					key: "_uniform_vec3vi",
					value: function(e, r) {
						return t.LayaGL.instance.uniform3iv(e.location, r), 1
					}
				}, {
					key: "_uniform_vec4i",
					value: function(e, r) {
						var n = e.uploadedValue;
						return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t
							.LayaGL.instance.uniform4i(e.location, n[0] = r[0], n[1] = r[1], n[2] =
								r[2], n[3] = r[3]), 1) : 0
					}
				}, {
					key: "_uniform_vec4vi",
					value: function(e, r) {
						return t.LayaGL.instance.uniform4iv(e.location, r), 1
					}
				}, {
					key: "_uniform_sampler2D",
					value: function(e, r) {
						var n = r._getSource() || r.defaulteTexture._getSource(),
							i = t.LayaGL.instance;
						return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(
							i, i.TEXTURE_2D, n), 0
					}
				}, {
					key: "_uniform_sampler3D",
					value: function(e, r) {
						var n = r._getSource() || r.defaulteTexture._getSource(),
							i = t.LayaGL.instance;
						return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(
							i, WebGL2RenderingContext.TEXTURE_3D, n), 0
					}
				}, {
					key: "_uniform_samplerCube",
					value: function(e, r) {
						var n = r._getSource() || r.defaulteTexture._getSource(),
							i = t.LayaGL.instance;
						return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(
							i, i.TEXTURE_CUBE_MAP, n), 0
					}
				}, {
					key: "bind",
					value: function() {
						return t.WebGLContext.useProgram(t.LayaGL.instance, this._program)
					}
				}, {
					key: "uploadUniforms",
					value: function(e, r, n) {
						t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e,
							r, n)
					}
				}, {
					key: "uploadRenderStateBlendDepth",
					value: function(e) {
						var r = t.LayaGL.instance,
							n = this._shaderPass.renderState,
							i = e.getData(),
							a = this._getRenderState(i, _e.RENDER_STATE_DEPTH_WRITE),
							o = this._getRenderState(i, _e.RENDER_STATE_DEPTH_TEST),
							s = this._getRenderState(i, _e.RENDER_STATE_BLEND);
						switch (null == a && (a = n.depthWrite), null == o && (o = n.depthTest), null ==
							s && (s = n.blend), t.WebGLContext.setDepthMask(r, a), o === at
							.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext
								.setDepthTest(r, !0), t.WebGLContext.setDepthFunc(r, o)), s) {
							case at.BLEND_DISABLE:
								t.WebGLContext.setBlend(r, !1);
								break;
							case at.BLEND_ENABLE_ALL:
								var l = this._getRenderState(i, _e.RENDER_STATE_BLEND_EQUATION),
									u = this._getRenderState(i, _e.RENDER_STATE_BLEND_SRC),
									c = this._getRenderState(i, _e.RENDER_STATE_BLEND_DST);
								null == l && (l = n.blendEquation), null == u && (u = n.srcBlend),
									null == c && (c = n.dstBlend), t.WebGLContext.setBlend(r, !0), t
									.WebGLContext.setBlendEquation(r, l), t.WebGLContext.setBlendFunc(r,
										u, c);
								break;
							case at.BLEND_ENABLE_SEPERATE:
								var h = this._getRenderState(i, _e.RENDER_STATE_BLEND_EQUATION_RGB),
									_ = this._getRenderState(i, _e.RENDER_STATE_BLEND_EQUATION_ALPHA),
									d = this._getRenderState(i, _e.RENDER_STATE_BLEND_SRC_RGB),
									f = this._getRenderState(i, _e.RENDER_STATE_BLEND_DST_RGB),
									m = this._getRenderState(i, _e.RENDER_STATE_BLEND_SRC_ALPHA),
									p = this._getRenderState(i, _e.RENDER_STATE_BLEND_DST_ALPHA);
								null == h && (h = n.blendEquationRGB), null == _ && (_ = n
										.blendEquationAlpha), null == d && (d = n.srcBlendRGB), null ==
									f && (f = n.dstBlendRGB), null == m && (m = n.srcBlendAlpha),
									null == p && (p = n.dstBlendAlpha), t.WebGLContext.setBlend(r, !0),
									t.WebGLContext.setBlendEquationSeparate(r, h, _), t.WebGLContext
									.setBlendFuncSeperate(r, d, f, m, p)
						}
					}
				}, {
					key: "uploadRenderStateFrontFace",
					value: function(e, r, n) {
						var i, a = t.LayaGL.instance,
							o = this._shaderPass.renderState,
							s = e.getData(),
							l = this._getRenderState(s, _e.RENDER_STATE_CULL);
						switch (null == l && (l = o.cull), l) {
							case at.CULL_NONE:
								t.WebGLContext.setCullFace(a, !1);
								break;
							case at.CULL_FRONT:
								t.WebGLContext.setCullFace(a, !0), i = r ? n ? a.CCW : a.CW : n ? a.CW :
									a.CCW, t.WebGLContext.setFrontFace(a, i);
								break;
							case at.CULL_BACK:
								t.WebGLContext.setCullFace(a, !0), i = r ? n ? a.CW : a.CCW : n ? a
									.CCW : a.CW, t.WebGLContext.setFrontFace(a, i)
						}
					}
				}, {
					key: "uploadCustomUniform",
					value: function(e, r) {
						t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this
							._customUniformParamsMap, e, r)
					}
				}, {
					key: "_uniformMatrix2fvForNative",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r), 1
					}
				}, {
					key: "_uniformMatrix3fvForNative",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r), 1
					}
				}, {
					key: "_uniformMatrix4fvForNative",
					value: function(e, r) {
						return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r), 1
					}
				}]), ShaderInstance
			}(t.Resource),
			dt = function(e) {
				function SimpleSingletonList() {
					return _classCallCheck(this, SimpleSingletonList), _possibleConstructorReturn(this, _getPrototypeOf(
						SimpleSingletonList).call(this))
				}
				return _inherits(SimpleSingletonList, e), _createClass(SimpleSingletonList, [{
					key: "add",
					value: function(e) {
						if (-1 !== e._getIndexInList()) throw "SimpleSingletonList:" + e +
							" has  in  SingletonList.";
						this._add(e), e._setIndexInList(this.length++)
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._getIndexInList();
						if (this.length--, t !== this.length) {
							var r = this.elements[this.length];
							this.elements[t] = r, r._setIndexInList(t)
						}
						e._setIndexInList(-1)
					}
				}, {
					key: "clear",
					value: function() {
						for (var e = this.elements, t = 0, r = this.length; t < r; t++) e[t]
							._setIndexInList(-1);
						this.length = 0
					}
				}]), SimpleSingletonList
			}(R),
			ft = function() {
				function Color() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
						t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
						r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
						n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
					_classCallCheck(this, Color), this.r = e, this.g = t, this.b = r, this.a = n
				}
				return _createClass(Color, [{
					key: "toLinear",
					value: function(e) {
						e.r = Color.gammaToLinearSpace(this.r), e.g = Color.gammaToLinearSpace(this.g),
							e.b = Color.gammaToLinearSpace(this.b)
					}
				}, {
					key: "toGamma",
					value: function(e) {
						e.r = Color.linearToGammaSpace(this.r), e.g = Color.linearToGammaSpace(this.g),
							e.b = Color.linearToGammaSpace(this.b)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Color;
						return this.cloneTo(e), e
					}
				}, {
					key: "forNativeElement",
					value: function() {}
				}], [{
					key: "gammaToLinearSpace",
					value: function(e) {
						return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) :
							Math.pow(e, 2.4)
					}
				}, {
					key: "linearToGammaSpace",
					value: function(e) {
						return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e,
							.41666) - .055 : Math.pow(e, .41666)
					}
				}]), Color
			}();
		ft.RED = new ft(1, 0, 0, 1), ft.GREEN = new ft(0, 1, 0, 1), ft.BLUE = new ft(0, 0, 1, 1), ft.CYAN = new ft(0, 1,
			1, 1), ft.YELLOW = new ft(1, .92, .016, 1), ft.MAGENTA = new ft(1, 0, 1, 1), ft.GRAY = new ft(.5, .5,
			.5, 1), ft.WHITE = new ft(1, 1, 1, 1), ft.BLACK = new ft(0, 0, 0, 1);
		var mt = function CameraCullInfo() {
				_classCallCheck(this, CameraCullInfo)
			},
			pt = function ShadowCullInfo() {
				_classCallCheck(this, ShadowCullInfo)
			},
			Tt = function() {
				function FrustumCulling() {
					_classCallCheck(this, FrustumCulling)
				}
				return _createClass(FrustumCulling, null, [{
					key: "__init__",
					value: function() {}
				}, {
					key: "_drawTraversalCullingBound",
					value: function(e, t) {
						for (var r = e.elements, n = 0, i = e.length; n < i; n++) {
							var a = FrustumCulling._tempColor0;
							a.r = 0, a.g = 1, a.b = 0, a.a = 1, P._drawBound(t, r[n].bounds
								._getBoundBox(), a)
						}
					}
				}, {
					key: "_traversalCulling",
					value: function(e, r, n, i, a, s, l) {
						for (var u = i.elements, c = e.boundFrustum, h = e.position, _ = e.cullingMask,
								d = t.Stat.loopCount, f = 0, m = i.length; f < m; f++) {
							var p = u[f];
							if ((l ? p._castShadow && p._enable : 0 != (Math.pow(2, p._owner._layer) &
									_) && p._enable) && (t.Stat.frustumCulling++, !e
									.useOcclusionCulling || p._needRender(c, n))) {
								p._renderMark = d, p._distanceForSort = o.distance(p.bounds.getCenter(),
									h);
								for (var T = p._renderElements, E = 0, g = T.length; E < g; E++) T[E]
									._update(r, n, a, s)
							}
						}
					}
				}, {
					key: "renderObjectCulling",
					value: function(e, t, r, n, i, a) {
						var o = t._opaqueQueue,
							s = t._transparentQueue,
							l = t._renders;
						t._clearRenderQueue();
						var u = t._octree;
						if (u && (u.updateMotionObjects(), u.shrinkRootIfPossible(), u
								.getCollidingWithFrustum(e, r, n, i, a)), FrustumCulling
							._traversalCulling(e, t, r, l, n, i, a), FrustumCulling.debugFrustumCulling
							) {
							var c = t._debugTool;
							c.clear(), u && (u.drawAllBounds(c), u.drawAllObjects(c)), FrustumCulling
								._drawTraversalCullingBound(l, c)
						}
						var h = o.elements.length;
						h > 0 && o._quickSort(0, h - 1), (h = s.elements.length) > 0 && s._quickSort(0,
							h - 1)
					}
				}, {
					key: "cullingShadow",
					value: function(e, r, n) {
						var i = r._renders;
						r._clearRenderQueue();
						for (var a = r._opaqueQueue, s = e.position, l = e.cullPlaneCount, u = e
								.cullPlanes, c = (e.cullSphere, e.direction, i.elements), h = t.Stat
								.loopCount, _ = 0, d = i.length; _ < d; _++) {
							var f = c[_];
							if (f._castShadow && f._enable) {
								t.Stat.frustumCulling++;
								for (var m = f.bounds, p = m.getMin(), T = m.getMax(), E = p.x, g = p.y,
										y = p.z, S = T.x, v = T.y, R = T.z, C = !0, M = 0; M < l; M++) {
									var D = u[M],
										x = D.normal;
									if (D.distance + x.x * (x.x < 0 ? E : S) + x.y * (x.y < 0 ? g : v) +
										x.z * (x.z < 0 ? y : R) < 0) {
										C = !1;
										break
									}
								}
								if (C) {
									f._renderMark = h, f._distanceForSort = o.distance(m.getCenter(),
									s);
									for (var A = f._renderElements, I = (M = 0, A.length); M < I; M++)
										A[M]._update(r, n, null, null)
								}
							}
						}
						return a.elements.length > 0
					}
				}, {
					key: "cullingSpotShadow",
					value: function(e, r, n) {
						var i = r._renders;
						r._clearRenderQueue();
						for (var a = r._opaqueQueue, s = i.elements, l = t.Stat.loopCount, u = 0, c = i
								.length; u < c; u++) {
							var h = s[u];
							if (h._castShadow && h._enable && h._needRender(e.boundFrustum, n)) {
								var _ = h.bounds;
								h._renderMark = l, h._distanceForSort = o.distance(_.getCenter(), e
									.position);
								for (var d = h._renderElements, f = 0, m = d.length; f < m; f++) d[f]
									._update(r, n, null, null)
							}
						}
						return a.elements.length > 0
					}
				}, {
					key: "renderObjectCullingNative",
					value: function(e, r, n, i, a, s) {
						var l, u, c, h = r._opaqueQueue,
							_ = r._transparentQueue;
						r._clearRenderQueue();
						var d = i.length,
							f = i.elements;
						for (l = 0; l < d; l++) f[l].bounds, f[l]._updateForNative && f[l]
							._updateForNative(n);
						e.boundFrustum;
						FrustumCulling.cullingNative(e._boundFrustumBuffer, FrustumCulling
							._cullingBuffer, r._cullingBufferIndices, d, r._cullingBufferResult);
						var m = t.Stat.loopCount,
							p = n.camera._transform.position;
						for (l = 0; l < d; l++) {
							var T = f[l];
							if (!e.useOcclusionCulling || e._isLayerVisible(T._owner._layer) && T
								._enable && r._cullingBufferResult[l]) {
								T._renderMark = m, T._distanceForSort = o.distance(T.bounds.getCenter(),
									p);
								var E = T._renderElements;
								for (u = 0, c = E.length; u < c; u++) {
									E[u]._update(r, n, a, s)
								}
							}
						}
						var g = h.elements.length;
						g > 0 && h._quickSort(0, g - 1), (g = _.elements.length) > 0 && _._quickSort(0,
							g - 1)
					}
				}, {
					key: "cullingNative",
					value: function(e, r, n, i, a) {
						return t.LayaGL.instance.culling(e, r, n, i, a)
					}
				}]), FrustumCulling
			}();
		Tt._tempColor0 = new ft, Tt._tempVector0 = new o, Tt._cameraCullInfo = new mt, Tt._shadowCullInfo = new pt, Tt
			.debugFrustumCulling = !1;
		var Et = function() {
			function SphericalHarmonicsL2() {
				_classCallCheck(this, SphericalHarmonicsL2), this._coefficients = new Float32Array(27)
			}
			return _createClass(SphericalHarmonicsL2, [{
				key: "getCoefficient",
				value: function(e, t) {
					return this._coefficients[9 * e + t]
				}
			}, {
				key: "setCoefficient",
				value: function(e, t, r) {
					this._coefficients[9 * e + t] = r
				}
			}, {
				key: "setCoefficients",
				value: function(e, t, r, n, i, a, o, s, l, u) {
					var c = 9 * e;
					this._coefficients[c] = t, this._coefficients[++c] = r, this._coefficients[++
						c] = n, this._coefficients[++c] = i, this._coefficients[++c] = a, this
						._coefficients[++c] = o, this._coefficients[++c] = s, this._coefficients[++
							c] = l, this._coefficients[++c] = u
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					if (this !== e)
						for (var t = this._coefficients, r = e._coefficients, n = 0; n < 27; n++) r[
							n] = t[n]
				}
			}]), SphericalHarmonicsL2
		}();
		Et._default = new Et;
		var gt = function MouseTouch() {
				_classCallCheck(this, MouseTouch), this._pressedSprite = null, this._pressedLoopCount = -1, this
					.sprite = null, this.mousePositionX = 0, this.mousePositionY = 0
			},
			yt = function() {
				function Touch() {
					_classCallCheck(this, Touch), this._indexInList = -1, this._identifier = -1, this._position = new n
				}
				return _createClass(Touch, [{
					key: "_getIndexInList",
					value: function() {
						return this._indexInList
					}
				}, {
					key: "_setIndexInList",
					value: function(e) {
						this._indexInList = e
					}
				}, {
					key: "identifier",
					get: function() {
						return this._identifier
					}
				}, {
					key: "position",
					get: function() {
						return this._position
					}
				}]), Touch
			}(),
			St = function() {
				function Input3D() {
					var e = this;
					_classCallCheck(this, Input3D), this._eventList = [], this._mouseTouch = new gt, this
						._touchPool = [], this._touches = new dt, this._multiTouchEnabled = !0, this._pushEventList =
						function(t) {
							t.cancelable && t.preventDefault(), e._eventList.push(t)
						}.bind(this)
				}
				return _createClass(Input3D, [{
					key: "__init__",
					value: function(e, t) {
						this._scene = t, e.oncontextmenu = function(e) {
							return !1
						}
					}
				}, {
					key: "_onCanvasEvent",
					value: function(e) {
						e.addEventListener("mousedown", this._pushEventList), e.addEventListener(
								"mouseup", this._pushEventList, !0), e.addEventListener("mousemove",
								this._pushEventList, !0), e.addEventListener("touchstart", this
								._pushEventList), e.addEventListener("touchend", this._pushEventList, !
								0), e.addEventListener("touchmove", this._pushEventList, !0), e
							.addEventListener("touchcancel", this._pushEventList, !0)
					}
				}, {
					key: "_offCanvasEvent",
					value: function(e) {
						e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener(
								"mouseup", this._pushEventList, !0), e.removeEventListener("mousemove",
								this._pushEventList, !0), e.removeEventListener("touchstart", this
								._pushEventList), e.removeEventListener("touchend", this._pushEventList,
								!0), e.removeEventListener("touchmove", this._pushEventList, !0), e
							.removeEventListener("touchcancel", this._pushEventList, !0), this
							._eventList.length = 0, this._touches.clear()
					}
				}, {
					key: "touchCount",
					value: function() {
						return this._touches.length
					}
				}, {
					key: "_getTouch",
					value: function(e, t) {
						var r = this._touchPool[e];
						return 0 == t && r && -1 != r._getIndexInList() ? null : 1 == t && r && -1 == r
							._getIndexInList() ? null : (r || (r = new yt, this._touchPool[e] = r, r
								._identifier = e), r)
					}
				}, {
					key: "_mouseTouchDown",
					value: function() {
						var e = this._mouseTouch,
							r = e.sprite;
						if (e._pressedSprite = r, e._pressedLoopCount = t.Stat.loopCount, r) {
							var n = r._scripts;
							if (n)
								for (var i = 0, a = n.length; i < a; i++) n[i].onMouseDown()
						}
					}
				}, {
					key: "_mouseTouchUp",
					value: function() {
						var e, t, r = this._mouseTouch,
							n = r._pressedSprite;
						r._pressedSprite = null, r._pressedLoopCount = -1;
						var i = r.sprite;
						if (i && i === n) {
							var a = i._scripts;
							if (a)
								for (e = 0, t = a.length; e < t; e++) a[e].onMouseClick()
						}
						if (n) {
							var o = n._scripts;
							if (o)
								for (e = 0, t = o.length; e < t; e++) o[e].onMouseUp()
						}
					}
				}, {
					key: "_mouseTouchRayCast",
					value: function(t) {
						var r = Input3D._tempHitResult0,
							n = Input3D._tempVector20,
							i = Input3D._tempRay0;
						r.succeeded = !1;
						var a = this._mouseTouch.mousePositionX,
							o = this._mouseTouch.mousePositionY;
						n.x = a, n.y = o;
						for (var s = t.length - 1; s >= 0; s--) {
							var l = t[s],
								u = l.viewport;
							if (n.x >= u.x && n.y >= u.y && n.x <= u.width && n.y <= u.height)
								if (l.viewportPointToRay(n, i), this._scene._physicsSimulation.rayCast(
										i, r) || l.clearFlag === e.CameraClearFlags.SolidColor || l
									.clearFlag === e.CameraClearFlags.Sky) break
						}
						var c = this._mouseTouch,
							h = c.sprite;
						if (r.succeeded) {
							var _ = r.collider.owner;
							c.sprite = _;
							var d = _._scripts;
							if (h !== _ && d)
								for (var f = 0, m = d.length; f < m; f++) d[f].onMouseEnter()
						} else c.sprite = null;
						if (h && h !== _) {
							var p = h._scripts;
							if (p)
								for (f = 0, m = p.length; f < m; f++) p[f].onMouseOut()
						}
					}
				}, {
					key: "_changeTouches",
					value: function(e, r) {
						for (var n = 0, i = 0, a = this._touches.length, o = 0, s = e.length; o <
							s; o++) {
							var l = e[o],
								u = l.identifier;
							if (this._multiTouchEnabled || 0 === u) {
								var c = this._getTouch(u, r),
									h = this._touchPool[u]._position,
									_ = Input3D._tempPoint;
								_.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform
									.invertTransformPoint(_);
								var d = _.x,
									f = _.y;
								switch (r) {
									case 0:
										c && this._touches.add(c), n += d, i += f;
										break;
									case 1:
										c && this._touches.remove(c), n -= d, i -= f;
										break;
									case 2:
										n = d - h.x, i = f - h.y
								}
								h.x = d, h.y = f
							}
						}
						var m = this._touches.length;
						0 === m ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch
							.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this
								._mouseTouch.mousePositionX * a + n) / m, this._mouseTouch
							.mousePositionY = (this._mouseTouch.mousePositionY * a + i) / m)
					}
				}, {
					key: "_update",
					value: function() {
						var e, r, n, i, a = k._enablePhysics && !I.disableSimulation;
						r = this._eventList.length;
						var o = this._scene._cameraPool;
						if (r > 0) {
							var s = !1;
							for (e = 0; e < r; e++) {
								var l = this._eventList[e];
								switch (l.type) {
									case "mousedown":
										a && this._mouseTouchDown();
										break;
									case "mouseup":
										a && this._mouseTouchUp();
										break;
									case "mousemove":
										var u = Input3D._tempPoint;
										u.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform
											.invertTransformPoint(u), this._mouseTouch.mousePositionX =
											u.x, this._mouseTouch.mousePositionY = u.y, a && (s = !0);
										break;
									case "touchstart":
										var c = this._touches.length;
										this._changeTouches(l.changedTouches, 0), a && (!w._config
											.isUseCannonPhysicsEngine && this._mouseTouchRayCast(o),
											0 === c && this._mouseTouchDown());
										break;
									case "touchend":
									case "touchcancel":
										this._changeTouches(l.changedTouches, 1), a && 0 === this
											._touches.length && this._mouseTouchUp();
										break;
									case "touchmove":
										this._changeTouches(l.changedTouches, 2), a && (s = !0);
										break;
									default:
										throw "Input3D:unkonwn event type."
								}
							}
							s && !w._config.isUseCannonPhysicsEngine && this._mouseTouchRayCast(o), this
								._eventList.length = 0
						}
						if (a) {
							var h = this._mouseTouch,
								_ = h._pressedSprite;
							if (_ && t.Stat.loopCount > h._pressedLoopCount) {
								var d = _._scripts;
								if (d)
									for (n = 0, i = d.length; n < i; n++) d[n].onMouseDrag()
							}
							var f = h.sprite;
							if (f) {
								var m = f._scripts;
								if (m)
									for (n = 0, i = m.length; n < i; n++) m[n].onMouseOver()
							}
						}
					}
				}, {
					key: "getTouch",
					value: function(e) {
						return e < this._touches.length ? this._touches.elements[e] : null
					}
				}, {
					key: "multiTouchEnabled",
					get: function() {
						return this._multiTouchEnabled
					},
					set: function(e) {
						this._multiTouchEnabled = e
					}
				}]), Input3D
			}();
		St._tempPoint = new t.Point, St._tempVector20 = new n, St._tempRay0 = new Ce(new o, new o), St._tempHitResult0 =
			new D;
		var vt, Rt = function PhysicsSettings() {
				_classCallCheck(this, PhysicsSettings), this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 /
					60
			},
			Ct = function() {
				function VertexPositionTexture0(e, t) {
					_classCallCheck(this, VertexPositionTexture0), this._position = e, this._textureCoordinate0 = t
				}
				return _createClass(VertexPositionTexture0, [{
					key: "position",
					get: function() {
						return this._position
					}
				}, {
					key: "textureCoordinate0",
					get: function() {
						return this._textureCoordinate0
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexPositionTexture0._vertexDeclaration
					}
				}], [{
					key: "__init__",
					value: function() {
						VertexPositionTexture0._vertexDeclaration = new ie(20, [new ae(0, re.Vector3, Ne
							.MESH_POSITION0), new ae(12, re.Vector2, Ne
							.MESH_TEXTURECOORDINATE0)])
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexPositionTexture0._vertexDeclaration
					}
				}]), VertexPositionTexture0
			}(),
			Mt = function(r) {
				function SkyDome() {
					var r, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 48,
						i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48;
					_classCallCheck(this, SkyDome), r = _possibleConstructorReturn(this, _getPrototypeOf(SkyDome).call(
						this));
					var a = t.LayaGL.instance;
					r._stacks = n, r._slices = i;
					for (var o = Ct.vertexDeclaration, s = o.vertexStride / 4, l = (r._stacks + 1) * (r._slices + 1),
							u = 3 * r._stacks * (r._slices + 1) * 2, c = new Float32Array(l * s), h = new Uint16Array(
							u), _ = Math.PI / r._stacks, d = 2 * Math.PI / r._slices, f = 0, m = 0, p = 0, T = 0; T < r
						._stacks + 1; T++)
						for (var E = Math.sin(T * _), g = Math.cos(T * _), y = 0; y < r._slices + 1; y++) {
							var S = E * Math.sin(y * d),
								v = E * Math.cos(y * d);
							c[m + 0] = S * SkyDome._radius, c[m + 1] = g * SkyDome._radius, c[m + 2] = v * SkyDome
								._radius, c[m + 3] = -y / r._slices + .75, c[m + 4] = T / r._stacks, m += s, T != r
								._stacks - 1 && (h[p++] = f + 1, h[p++] = f, h[p++] = f + (r._slices + 1), h[p++] = f +
									(r._slices + 1), h[p++] = f, h[p++] = f + r._slices, f++)
						}
					r._vertexBuffer = new te(4 * c.length, a.STATIC_DRAW, !1), r._vertexBuffer.vertexDeclaration = o, r
						._indexBuffer = new Oe(e.IndexFormat.UInt16, h.length, a.STATIC_DRAW, !1), r._vertexBuffer
						.setData(c.buffer), r._indexBuffer.setData(h);
					var R = new oe;
					return R.bind(), R.applyVertexBuffer(r._vertexBuffer), R.applyIndexBuffer(r._indexBuffer), R
					.unBind(), r._bufferState = R, r
				}
				return _inherits(SkyDome, r), _createClass(SkyDome, [{
					key: "_render",
					value: function(e) {
						var r = t.LayaGL.instance,
							n = this._indexBuffer.indexCount;
						r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces +=
							n / 3, t.Stat.renderBatches++
					}
				}, {
					key: "stacks",
					get: function() {
						return this._stacks
					}
				}, {
					key: "slices",
					get: function() {
						return this._slices
					}
				}], [{
					key: "__init__",
					value: function() {
						SkyDome.instance = new SkyDome
					}
				}]), SkyDome
			}(be);
		Mt._radius = 1, (vt = e.TextureCubeFace || (e.TextureCubeFace = {}))[vt.PositiveX = 0] = "PositiveX", vt[vt
				.NegativeX = 1] = "NegativeX", vt[vt.PositiveY = 2] = "PositiveY", vt[vt.NegativeY = 3] = "NegativeY",
			vt[vt.PositiveZ = 4] = "PositiveZ", vt[vt.NegativeZ = 5] = "NegativeZ";
		var Dt = function(r) {
			function TextureCube(e) {
				var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.TextureFormat.R8G8B8,
					i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
				_classCallCheck(this, TextureCube), (r = _possibleConstructorReturn(this, _getPrototypeOf(
						TextureCube).call(this, n, i)))._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP, r
					._width = e, r._height = e;
				var a = t.LayaGL.instance;
				if (r._setWarpMode(a.TEXTURE_WRAP_S, r._wrapModeU), r._setWarpMode(a.TEXTURE_WRAP_T, r._wrapModeV),
					r._setFilterMode(r._filterMode), r._setAnisotropy(r._anisoLevel), r._mipmap) {
					r._mipmapCount = Math.ceil(Math.log2(e)) + 1;
					for (var o = 0; o < r._mipmapCount; o++) r._setPixels([], o, Math.max(e >> o, 1), Math.max(e >>
						o, 1));
					r._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6)
				} else r._mipmapCount = 1, r._setGPUMemory(e * e * 4 * 6);
				return r
			}
			return _inherits(TextureCube, r), _createClass(TextureCube, [{
				key: "_setPixels",
				value: function(e, r, n, i) {
					var a = t.LayaGL.instance,
						o = this._getGLFormat();
					t.WebGLContext.bindTexture(a, this._glTextureType, this._glTexture), this
						.format === t.TextureFormat.R8G8B8 ? (a.pixelStorei(a.UNPACK_ALIGNMENT, 1),
							a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a
								.UNSIGNED_BYTE, e[0]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z,
								r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]), a.texImage2D(a
								.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[
									2]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0,
								o, a.UNSIGNED_BYTE, e[3]), a.texImage2D(a
								.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[
									4]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0,
								o, a.UNSIGNED_BYTE, e[5]), a.pixelStorei(a.UNPACK_ALIGNMENT, 4)) : (
							a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a
								.UNSIGNED_BYTE, e[0]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z,
								r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]), a.texImage2D(a
								.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[
									2]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0,
								o, a.UNSIGNED_BYTE, e[3]), a.texImage2D(a
								.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[
									4]), a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0,
								o, a.UNSIGNED_BYTE, e[5]))
				}
			}, {
				key: "setSixSideImageSources",
				value: function(e) {
					for (var r, n, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[
							1], a = 0; a < 6; a++) {
						var o = e[a];
						if (!o) return void console.log("TextureCube: image Source can't be null.");
						var s = o.width,
							l = o.height;
						if (a > 0 && r !== s) return void console.log(
							"TextureCube: each side image's width and height must same.");
						if ((r = s) !== (n = l)) return void console.log(
							"TextureCube: each side image's width and height must same.")
					}
					this._width = r, this._height = n;
					var u = t.LayaGL.instance;
					t.WebGLContext.bindTexture(u, this._glTextureType, this._glTexture);
					var c = this._getGLFormat();
					if (t.Render.isConchApp) {
						if (1 == i)
							for (var h = 0; h < 6; h++) e[h].setPremultiplyAlpha(i);
						u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, u.RGBA, u.RGBA, u
							.UNSIGNED_BYTE, e[0]), u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z,
							0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[1]), u.texImage2D(u
							.TEXTURE_CUBE_MAP_POSITIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[
								2]), u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, u.RGBA, u
							.RGBA, u.UNSIGNED_BYTE, e[3]), u.texImage2D(u
							.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[
								4]), u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, u.RGBA, u
							.RGBA, u.UNSIGNED_BYTE, e[5])
					} else i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), u.texImage2D(u
							.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[0]), u
						.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[1]),
						u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[2]),
						u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[3]),
						u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[4]),
						u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[5]),
						i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
					this._mipmap && this._isPot(r) && this._isPot(n) ? (u.generateMipmap(this
							._glTextureType), this._setGPUMemory(r * n * 4 * (1 + 1 / 3) * 6)) :
						this._setGPUMemory(r * n * 4 * 6), this._setWarpMode(u.TEXTURE_WRAP_S, this
							._wrapModeU), this._setWarpMode(u.TEXTURE_WRAP_T, this._wrapModeV), this
						._setFilterMode(this._filterMode), this._readyed = !0, this
						._activeResource()
				}
			}, {
				key: "setSixSidePixels",
				value: function(e) {
					var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					if (!e) throw new Error("TextureCube:pixels can't be null.");
					var n = Math.max(this._width >> r, 1),
						i = Math.max(this._height >> r, 1),
						a = n * i * this._getFormatByteCount();
					if (e[0].length < a) throw "TextureCube:pixels length should at least " + a +
						".";
					if (this._setPixels(e, r, n, i), 0 === r) {
						var o = t.LayaGL.instance;
						this._setWarpMode(o.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(o
							.TEXTURE_WRAP_T, this._wrapModeV)
					}
					this._readyed = !0, this._activeResource()
				}
			}, {
				key: "setImageSource",
				value: function(r, n) {
					var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
						a = this._width,
						o = this._height;
					if (!n || a === n.width && o === n.height) {
						var s = t.LayaGL.instance;
						t.WebGLContext.bindTexture(s, this._glTextureType, this._glTexture);
						var l = this._getGLFormat();
						switch (r) {
							case e.TextureCubeFace.NegativeX:
								s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_X, i, l, l, s
									.UNSIGNED_BYTE, n);
								break;
							case e.TextureCubeFace.PositiveX:
								s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X, i, l, l, s
									.UNSIGNED_BYTE, n);
								break;
							case e.TextureCubeFace.NegativeY:
								s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Y, i, l, l, s
									.UNSIGNED_BYTE, n);
								break;
							case e.TextureCubeFace.PositiveY:
								s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Y, i, l, l, s
									.UNSIGNED_BYTE, n);
								break;
							case e.TextureCubeFace.NegativeZ:
								s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Z, i, l, l, s
									.UNSIGNED_BYTE, n);
								break;
							case e.TextureCubeFace.PositiveZ:
								s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Z, i, l, l, s
									.UNSIGNED_BYTE, n)
						}
						this._mipmap && this._isPot(a) && this._isPot(o) ? (s.generateMipmap(this
							._glTextureType), this._setGPUMemory(a * o * 4 * (1 + 1 / 3) *
							6)) : this._setGPUMemory(a * o * 4 * 6), this._setWarpMode(s
							.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s
							.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this
							._filterMode), this._readyed = !0
					} else console.log("TextureCube: imageSource's width and height must same.")
				}
			}, {
				key: "defaulteTexture",
				get: function() {
					return TextureCube.grayTexture
				}
			}], [{
				key: "__init__",
				value: function() {
					var e = new TextureCube(1, t.TextureFormat.R8G8B8, !1),
						r = new TextureCube(1, t.TextureFormat.R8G8B8, !1),
						n = new Uint8Array(3);
					n[0] = 0, n[1] = 0, n[2] = 0, e.setSixSidePixels([n, n, n, n, n, n]), e.lock = !
						0, n[0] = 128, n[1] = 128, n[2] = 128, r.setSixSidePixels([n, n, n, n, n,
							n]), r.lock = !0, TextureCube._grayTexture = r, TextureCube
						._blackTexture = e
				}
			}, {
				key: "_parse",
				value: function(e) {
					arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
						r = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
					return r.setSixSideImageSources(e), r
				}
			}, {
				key: "_parseBin",
				value: function(e) {
					arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
					var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
						r = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
					return r.setSixSideImageSources(e), r
				}
			}, {
				key: "load",
				value: function(e, r) {
					var n = t.LoaderManager.createMap[t.Utils.getFilecompatibleExtension(e)] ? t
						.Utils.getFilecompatibleExtension(e) : t.Utils.getFileExtension(e),
						i = t.LoaderManager.createMap[n] ? t.LoaderManager.createMap[n][0] : null;
					t.ILaya.loader.create(e, r, null, i)
				}
			}, {
				key: "blackTexture",
				get: function() {
					return TextureCube._blackTexture
				}
			}, {
				key: "grayTexture",
				get: function() {
					return TextureCube._grayTexture
				}
			}]), TextureCube
		}(t.BaseTexture);
		Dt.TEXTURECUBE = "TEXTURECUBE", Dt.TEXTURECUBEBIN = "TEXTURECUBEBIN";
		var xt = function() {
				function LightQueue() {
					_classCallCheck(this, LightQueue), this._length = 0, this._elements = []
				}
				return _createClass(LightQueue, [{
					key: "add",
					value: function(e) {
						this._length === this._elements.length ? this._elements.push(e) : this
							._elements[this._length] = e, this._length++
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = this._elements.indexOf(e);
						if (this._length--, t !== this._length) {
							var r = this._elements[this._length];
							this._elements[t] = r
						}
					}
				}, {
					key: "shift",
					value: function() {
						return this._length--, this._elements.shift()
					}
				}, {
					key: "getBrightestLight",
					value: function() {
						for (var e, t = -1, r = this._elements, n = 0; n < this._length; n++) {
							var i = r[n]._intensity;
							t < i && (t = i, e = n)
						}
						return e
					}
				}, {
					key: "normalLightOrdering",
					value: function(e) {
						this._elements;
						var t = this._elements[0];
						this._elements[0] = this._elements[e], this._elements[e] = t
					}
				}]), LightQueue
			}(),
			At = function(e) {
				function AlternateLightQueue() {
					return _classCallCheck(this, AlternateLightQueue), _possibleConstructorReturn(this, _getPrototypeOf(
						AlternateLightQueue).apply(this, arguments))
				}
				return _inherits(AlternateLightQueue, e), _createClass(AlternateLightQueue, [{
					key: "remove",
					value: function(e) {
						var t = this._elements.indexOf(e);
						this._elements.splice(t, 1), this._length--
					}
				}]), AlternateLightQueue
			}(xt),
			It = function(e) {
				function PixelLineMaterial() {
					var e;
					return _classCallCheck(this, PixelLineMaterial), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(PixelLineMaterial).call(this))).setShaderName("LineShader"), e._shaderValues
						.setVector(PixelLineMaterial.COLOR, new i(1, 1, 1, 1)), e
				}
				return _inherits(PixelLineMaterial, e), _createClass(PixelLineMaterial, [{
					key: "clone",
					value: function() {
						var e = new PixelLineMaterial;
						return this.cloneTo(e), e
					}
				}, {
					key: "color",
					get: function() {
						return this._shaderValues.getVector(PixelLineMaterial.COLOR)
					},
					set: function(e) {
						this._shaderValues.setVector(PixelLineMaterial.COLOR, e)
					}
				}, {
					key: "depthWrite",
					set: function(e) {
						this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, e)
					},
					get: function() {
						return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE)
					}
				}, {
					key: "cull",
					set: function(e) {
						this._shaderValues.setInt(PixelLineMaterial.CULL, e)
					},
					get: function() {
						return this._shaderValues.getInt(PixelLineMaterial.CULL)
					}
				}, {
					key: "blend",
					set: function(e) {
						this._shaderValues.setInt(PixelLineMaterial.BLEND, e)
					},
					get: function() {
						return this._shaderValues.getInt(PixelLineMaterial.BLEND)
					}
				}, {
					key: "blendSrc",
					set: function(e) {
						this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, e)
					},
					get: function() {
						return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC)
					}
				}, {
					key: "blendDst",
					set: function(e) {
						this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, e)
					},
					get: function() {
						return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST)
					}
				}, {
					key: "depthTest",
					set: function(e) {
						this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, e)
					},
					get: function() {
						return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST)
					}
				}], [{
					key: "__initDefine__",
					value: function() {}
				}]), PixelLineMaterial
			}(nt);
		It.COLOR = _e.propertyNameToID("u_Color"), It.CULL = _e.propertyNameToID("s_Cull"), It.BLEND = _e
			.propertyNameToID("s_Blend"), It.BLEND_SRC = _e.propertyNameToID("s_BlendSrc"), It.BLEND_DST = _e
			.propertyNameToID("s_BlendDst"), It.DEPTH_TEST = _e.propertyNameToID("s_DepthTest"), It.DEPTH_WRITE = _e
			.propertyNameToID("s_DepthWrite");
		var Lt = function() {
			function BoundBox(e, t) {
				_classCallCheck(this, BoundBox), this.min = e, this.max = t
			}
			return _createClass(BoundBox, [{
				key: "_rotateExtents",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.elements;
					r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a), r.y = Math
						.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a), r.z = Math.abs(o[
							2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a)
				}
			}, {
				key: "getCorners",
				value: function(e) {
					e.length = 8;
					var t = this.min.x,
						r = this.min.y,
						n = this.min.z,
						i = this.max.x,
						a = this.max.y,
						s = this.max.z;
					e[0] = new o(t, a, s), e[1] = new o(i, a, s), e[2] = new o(i, r, s), e[3] =
						new o(t, r, s), e[4] = new o(t, a, n), e[5] = new o(i, a, n), e[6] = new o(
							i, r, n), e[7] = new o(t, r, n)
				}
			}, {
				key: "getCenter",
				value: function(e) {
					o.add(this.min, this.max, e), o.scale(e, .5, e)
				}
			}, {
				key: "getExtent",
				value: function(e) {
					o.subtract(this.max, this.min, e), o.scale(e, .5, e)
				}
			}, {
				key: "setCenterAndExtent",
				value: function(e, t) {
					o.subtract(e, t, this.min), o.add(e, t, this.max)
				}
			}, {
				key: "tranform",
				value: function(e, t) {
					var r = BoundBox._tempVector30,
						n = BoundBox._tempVector31;
					this.getCenter(r), this.getExtent(n), o.transformCoordinate(r, e, r), this
						._rotateExtents(n, e, n), t.setCenterAndExtent(r, n)
				}
			}, {
				key: "toDefault",
				value: function() {
					this.min.toDefault(), this.max.toDefault()
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					this.min.cloneTo(t.min), this.max.cloneTo(t.max)
				}
			}, {
				key: "clone",
				value: function() {
					var e = new BoundBox(new o, new o);
					return this.cloneTo(e), e
				}
			}], [{
				key: "createfromPoints",
				value: function(e, t) {
					if (null == e) throw new Error("points");
					var r = t.min,
						n = t.max;
					r.x = Number.MAX_VALUE, r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, n.x = -
						Number.MAX_VALUE, n.y = -Number.MAX_VALUE, n.z = -Number.MAX_VALUE;
					for (var i = 0, a = e.length; i < a; ++i) o.min(r, e[i], r), o.max(n, e[i], n)
				}
			}, {
				key: "merge",
				value: function(e, t, r) {
					o.min(e.min, t.min, r.min), o.max(e.max, t.max, r.max)
				}
			}]), BoundBox
		}();
		Lt._tempVector30 = new o, Lt._tempVector31 = new o;
		var Pt = function() {
			function Bounds(e, t) {
				_classCallCheck(this, Bounds), this._updateFlag = 0, this._center = new o, this._extent = new o,
					this._boundBox = new Lt(new o, new o), e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox
						.max), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0)
			}
			return _createClass(Bounds, [{
				key: "setMin",
				value: function(e) {
					var t = this._boundBox.min;
					e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds
						._UPDATE_EXTENT, !0), this._setUpdateFlag(Bounds._UPDATE_MIN, !1)
				}
			}, {
				key: "getMin",
				value: function() {
					var e = this._boundBox.min;
					return this._getUpdateFlag(Bounds._UPDATE_MIN) && (this._getMin(this
					.getCenter(), this.getExtent(), e), this._setUpdateFlag(Bounds
						._UPDATE_MIN, !1)), e
				}
			}, {
				key: "setMax",
				value: function(e) {
					var t = this._boundBox.max;
					e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds
						._UPDATE_EXTENT, !0), this._setUpdateFlag(Bounds._UPDATE_MAX, !1)
				}
			}, {
				key: "getMax",
				value: function() {
					var e = this._boundBox.max;
					return this._getUpdateFlag(Bounds._UPDATE_MAX) && (this._getMax(this
					.getCenter(), this.getExtent(), e), this._setUpdateFlag(Bounds
						._UPDATE_MAX, !1)), e
				}
			}, {
				key: "setCenter",
				value: function(e) {
					e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(Bounds
						._UPDATE_MIN | Bounds._UPDATE_MAX, !0), this._setUpdateFlag(Bounds
						._UPDATE_CENTER, !1)
				}
			}, {
				key: "getCenter",
				value: function() {
					return this._getUpdateFlag(Bounds._UPDATE_CENTER) && (this._getCenter(this
						.getMin(), this.getMax(), this._center), this._setUpdateFlag(Bounds
						._UPDATE_CENTER, !1)), this._center
				}
			}, {
				key: "setExtent",
				value: function(e) {
					e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(Bounds
						._UPDATE_MIN | Bounds._UPDATE_MAX, !0), this._setUpdateFlag(Bounds
						._UPDATE_EXTENT, !1)
				}
			}, {
				key: "getExtent",
				value: function() {
					return this._getUpdateFlag(Bounds._UPDATE_EXTENT) && (this._getExtent(this
						.getMin(), this.getMax(), this._extent), this._setUpdateFlag(Bounds
						._UPDATE_EXTENT, !1)), this._extent
				}
			}, {
				key: "_getUpdateFlag",
				value: function(e) {
					return 0 != (this._updateFlag & e)
				}
			}, {
				key: "_setUpdateFlag",
				value: function(e, t) {
					t ? this._updateFlag |= e : this._updateFlag &= ~e
				}
			}, {
				key: "_getCenter",
				value: function(e, t, r) {
					o.add(e, t, r), o.scale(r, .5, r)
				}
			}, {
				key: "_getExtent",
				value: function(e, t, r) {
					o.subtract(t, e, r), o.scale(r, .5, r)
				}
			}, {
				key: "_getMin",
				value: function(e, t, r) {
					o.subtract(e, t, r)
				}
			}, {
				key: "_getMax",
				value: function(e, t, r) {
					o.add(e, t, r)
				}
			}, {
				key: "_rotateExtents",
				value: function(e, t, r) {
					var n = e.x,
						i = e.y,
						a = e.z,
						o = t.elements;
					r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a), r.y = Math
						.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a), r.z = Math.abs(o[
							2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a)
				}
			}, {
				key: "_tranform",
				value: function(e, t) {
					var r = t._center,
						n = t._extent;
					o.transformCoordinate(this.getCenter(), e, r), this._rotateExtents(this
							.getExtent(), e, n), t._boundBox.setCenterAndExtent(r, n), t
						._updateFlag = 0
				}
			}, {
				key: "_getBoundBox",
				value: function() {
					if (this._updateFlag & Bounds._UPDATE_MIN) {
						var e = this._boundBox.min;
						this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(
							Bounds._UPDATE_MIN, !1)
					}
					if (this._updateFlag & Bounds._UPDATE_MAX) {
						var t = this._boundBox.max;
						this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(
							Bounds._UPDATE_MAX, !1)
					}
					return this._boundBox
				}
			}, {
				key: "calculateBoundsintersection",
				value: function(e) {
					var t = this.getMax(),
						r = this.getMin(),
						n = e.getMax(),
						i = e.getMin(),
						a = Bounds.TEMP_VECTOR3_MAX0,
						o = Bounds.TEMP_VECTOR3_MAX1,
						s = this.getExtent(),
						l = e.getExtent();
					return a.setValue(Math.max(t.x, n.x) - Math.min(r.x, i.x), Math.max(t.y, n.y) -
							Math.min(r.y, i.y), Math.max(t.z, n.z) - Math.min(r.z, i.z)), o
						.setValue(2 * (s.x + l.x), 2 * (s.y + l.y), 2 * (s.z + l.z)), a.x > o.x ? -
						1 : a.y > o.y ? -1 : a.z > o.z ? -1 : (o.x - a.x) * (o.y - a.y) * (o.z - a
							.z)
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max),
						this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t
						._updateFlag = 0
				}
			}, {
				key: "clone",
				value: function() {
					var e = new Bounds(new o, new o);
					return this.cloneTo(e), e
				}
			}]), Bounds
		}();
		Pt._UPDATE_MIN = 1, Pt._UPDATE_MAX = 2, Pt._UPDATE_CENTER = 4, Pt._UPDATE_EXTENT = 8, Pt.TEMP_VECTOR3_MAX0 =
			new o, Pt.TEMP_VECTOR3_MAX1 = new o;
		var Ot = function() {
			function GeometryElement() {
				_classCallCheck(this, GeometryElement), this._destroyed = !1
			}
			return _createClass(GeometryElement, [{
				key: "_getType",
				value: function() {
					throw "GeometryElement:must override it."
				}
			}, {
				key: "_prepareRender",
				value: function(e) {
					return !0
				}
			}, {
				key: "_render",
				value: function(e) {
					throw "GeometryElement:must override it."
				}
			}, {
				key: "destroy",
				value: function() {
					this._destroyed || (this._destroyed = !0)
				}
			}, {
				key: "destroyed",
				get: function() {
					return this._destroyed
				}
			}]), GeometryElement
		}();
		Ot._typeCounter = 0;
		var Nt = function() {
				function PixelLineVertex() {
					_classCallCheck(this, PixelLineVertex)
				}
				return _createClass(PixelLineVertex, [{
					key: "vertexDeclaration",
					get: function() {
						return PixelLineVertex._vertexDeclaration
					}
				}], [{
					key: "__init__",
					value: function() {
						PixelLineVertex._vertexDeclaration = new ie(28, [new ae(0, re.Vector3, Ne
							.MESH_POSITION0), new ae(12, re.Vector4, Ne.MESH_COLOR0)])
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return PixelLineVertex._vertexDeclaration
					}
				}]), PixelLineVertex
			}(),
			bt = function(e) {
				function PixelLineFilter(e, r) {
					var n;
					_classCallCheck(this, PixelLineFilter), (n = _possibleConstructorReturn(this, _getPrototypeOf(
							PixelLineFilter).call(this)))._floatCountPerVertices = 7, n._minUpdate = Number.MAX_VALUE, n
						._maxUpdate = Number.MIN_VALUE, n._bufferState = new oe, n._floatBound = new Float32Array(6), n
						._calculateBound = !1, n._maxLineCount = 0, n._lineCount = 0;
					var i = 2 * r;
					n._owner = e, n._maxLineCount = r, n._vertices = new Float32Array(i * n._floatCountPerVertices), n
						._vertexBuffer = new te(Nt.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !
							1), n._vertexBuffer.vertexDeclaration = Nt.vertexDeclaration, n._bufferState.bind(), n
						._bufferState.applyVertexBuffer(n._vertexBuffer), n._bufferState.unBind();
					var a = PixelLineFilter._tempVector0,
						o = PixelLineFilter._tempVector1;
					return a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.setValue(-Number
						.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), n._bounds = new Pt(a, o), n
				}
				return _inherits(PixelLineFilter, e), _createClass(PixelLineFilter, [{
					key: "_getType",
					value: function() {
						return PixelLineFilter._type
					}
				}, {
					key: "_resizeLineData",
					value: function(e) {
						var r = 2 * e,
							n = this._vertices;
						this._vertexBuffer.destroy(), this._maxLineCount = e;
						var i = r * this._floatCountPerVertices;
						this._vertices = new Float32Array(i), this._vertexBuffer = new te(Nt
								.vertexDeclaration.vertexStride * r, t.LayaGL.instance.STATIC_DRAW, !1),
							this._vertexBuffer.vertexDeclaration = Nt.vertexDeclaration, i < n.length ?
							(this._vertices.set(new Float32Array(n.buffer, 0, i)), this._vertexBuffer
								.setData(this._vertices.buffer, 0, 0, 4 * i)) : (this._vertices.set(n),
								this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * n.length)),
							this._bufferState.bind(), this._bufferState.applyVertexBuffer(this
								._vertexBuffer), this._bufferState.unBind()
					}
				}, {
					key: "_updateLineVertices",
					value: function(e, t, r, n, i) {
						t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[
								e + 2] = t.z), n && (this._vertices[e + 3] = n.r, this._vertices[e +
								4] = n.g, this._vertices[e + 5] = n.b, this._vertices[e + 6] = n.a),
							r && (this._vertices[e + 7] = r.x, this._vertices[e + 8] = r.y, this
								._vertices[e + 9] = r.z), i && (this._vertices[e + 10] = i.r, this
								._vertices[e + 11] = i.g, this._vertices[e + 12] = i.b, this._vertices[
									e + 13] = i.a), this._minUpdate = Math.min(this._minUpdate, e), this
							._maxUpdate = Math.max(this._maxUpdate, e + 2 * this
							._floatCountPerVertices);
						var a = this._bounds,
							s = this._floatBound,
							l = a.getMin(),
							u = a.getMax();
						o.min(l, t, l), o.min(l, r, l), o.max(u, t, u), o.max(u, r, u), a.setMin(l), a
							.setMax(u), s[0] = l.x, s[1] = l.y, s[2] = l.z, s[3] = u.x, s[4] = u.y, s[
							5] = u.z
					}
				}, {
					key: "_reCalculateBound",
					value: function() {
						if (this._calculateBound) {
							var e = this._vertices,
								t = PixelLineFilter._tempVector0,
								r = PixelLineFilter._tempVector1;
							t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r
								.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
							for (var n = 0; n < 2 * this._lineCount; ++n) {
								var i = this._floatCountPerVertices * n,
									a = e[i + 0],
									o = e[i + 1],
									s = e[i + 2];
								t.x = Math.min(a, t.x), t.y = Math.min(o, t.y), t.z = Math.min(s, t.z),
									r.x = Math.max(a, r.x), r.y = Math.max(o, r.y), r.z = Math.max(s, r
										.z)
							}
							this._bounds.setMin(t), this._bounds.setMax(r);
							var l = this._floatBound;
							l[0] = t.x, l[1] = t.y, l[2] = t.z, l[3] = r.x, l[4] = r.y, l[5] = r.z, this
								._calculateBound = !1
						}
					}
				}, {
					key: "_removeLineData",
					value: function(e) {
						var t = 2 * this._floatCountPerVertices,
							r = e + 1,
							n = e * t,
							i = this._vertices,
							a = new Float32Array(i.buffer, r * t * 4, (this._lineCount - r) * t);
						i.set(a, n), this._minUpdate = Math.min(this._minUpdate, n), this._maxUpdate =
							Math.max(this._maxUpdate, n + a.length), this._lineCount--;
						var o = this._floatBound,
							s = i[n],
							l = i[n + 1],
							u = i[n + 2],
							c = i[n + 7],
							h = i[n + 8],
							_ = i[n + 9],
							d = o[0],
							f = o[1],
							m = o[2],
							p = o[3],
							T = o[4],
							E = o[5];
						s !== d && s !== p && l !== f && l !== T && u !== m && u !== E && c !== d &&
							c !== p && h !== f && h !== T && _ !== m && _ !== E || (this
								._calculateBound = !0)
					}
				}, {
					key: "_updateLineData",
					value: function(e, t, r, n, i) {
						var a = 2 * this._floatCountPerVertices;
						this._updateLineVertices(e * a, t, r, n, i)
					}
				}, {
					key: "_updateLineDatas",
					value: function(e, t) {
						for (var r = 2 * this._floatCountPerVertices, n = t.length, i = 0; i < n; i++) {
							var a = t[i];
							this._updateLineVertices((e + i) * r, a.startPosition, a.endPosition, a
								.startColor, a.endColor)
						}
					}
				}, {
					key: "_getLineData",
					value: function(e, t) {
						var r = t.startPosition,
							n = t.startColor,
							i = t.endPosition,
							a = t.endColor,
							o = this._vertices,
							s = e * this._floatCountPerVertices * 2;
						r.x = o[s + 0], r.y = o[s + 1], r.z = o[s + 2], n.r = o[s + 3], n.g = o[s + 4],
							n.b = o[s + 5], n.a = o[s + 6], i.x = o[s + 7], i.y = o[s + 8], i.z = o[s +
								9], a.r = o[s + 10], a.g = o[s + 11], a.b = o[s + 12], a.a = o[s + 13]
					}
				}, {
					key: "_prepareRender",
					value: function(e) {
						return !0
					}
				}, {
					key: "_render",
					value: function(e) {
						if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number
							.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this
									._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this
										._minUpdate)), this._minUpdate = Number.MAX_VALUE, this
								._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
							this._bufferState.bind();
							var r = t.LayaGL.instance;
							r.drawArrays(r.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++
						}
					}
				}, {
					key: "destroy",
					value: function() {
						this._destroyed || (_get(_getPrototypeOf(PixelLineFilter.prototype), "destroy",
								this).call(this), this._bufferState.destroy(), this._vertexBuffer
							.destroy(), this._bufferState = null, this._vertexBuffer = null, this
							._vertices = null)
					}
				}]), PixelLineFilter
			}(Ot);
		bt._tempVector0 = new o, bt._tempVector1 = new o, bt._type = Ot._typeCounter++;
		var kt = function(e) {
			function RenderableSprite3D(e) {
				return _classCallCheck(this, RenderableSprite3D), _possibleConstructorReturn(this, _getPrototypeOf(
					RenderableSprite3D).call(this, e))
			}
			return _inherits(RenderableSprite3D, e), _createClass(RenderableSprite3D, [{
				key: "_onInActive",
				value: function() {
					_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onInActive", this).call(
						this), this._scene._removeRenderObject(this._render)
				}
			}, {
				key: "_onActive",
				value: function() {
					_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActive", this).call(
						this), this._scene._addRenderObject(this._render)
				}
			}, {
				key: "_onActiveInScene",
				value: function() {
					if (_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActiveInScene",
							this).call(this), l.Laya3D._editerEnvironment) {
						var e = this._scene,
							t = new i;
						e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this
							._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, t)
					}
				}
			}, {
				key: "_addToInitStaticBatchManager",
				value: function() {}
			}, {
				key: "_setBelongScene",
				value: function(e) {
					_get(_getPrototypeOf(RenderableSprite3D.prototype), "_setBelongScene", this)
						.call(this, e), this._render._setBelongScene(e)
				}
			}, {
				key: "_setUnBelongScene",
				value: function() {
					this._render._shaderValues.removeDefine(RenderableSprite3D
						.SAHDERDEFINE_LIGHTMAP), _get(_getPrototypeOf(RenderableSprite3D
						.prototype), "_setUnBelongScene", this).call(this)
				}
			}, {
				key: "_changeHierarchyAnimator",
				value: function(e) {
					if (this._hierarchyAnimator) {
						var t = this._hierarchyAnimator._renderableSprites;
						t.splice(t.indexOf(this), 1)
					}
					e && e._renderableSprites.push(this), _get(_getPrototypeOf(RenderableSprite3D
						.prototype), "_changeHierarchyAnimator", this).call(this, e)
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					_get(_getPrototypeOf(RenderableSprite3D.prototype), "destroy", this).call(this,
						e), this._render._destroy(), this._render = null
				}
			}, {
				key: "_create",
				value: function() {
					return new RenderableSprite3D(this.name)
				}
			}], [{
				key: "__init__",
				value: function() {
					RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = _e.getDefineByName(
							"RECEIVESHADOW"), RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = _e
						.getDefineByName("LIGHTMAP"), RenderableSprite3D
						.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = _e.getDefineByName(
							"LIGHTMAP_DIRECTIONAL")
				}
			}]), RenderableSprite3D
		}(Ee);
		kt.LIGHTMAPSCALEOFFSET = _e.propertyNameToID("u_LightmapScaleOffset"), kt.LIGHTMAP = _e.propertyNameToID(
				"u_LightMap"), kt.LIGHTMAP_DIRECTION = _e.propertyNameToID("u_LightMapDirection"), kt.PICKCOLOR = _e
			.propertyNameToID("u_PickColor"), kt.REFLECTIONTEXTURE = _e.propertyNameToID("u_ReflectTexture"), kt
			.REFLECTIONCUBE_HDR_PARAMS = _e.propertyNameToID("u_ReflectCubeHDRParams"), kt
			.REFLECTIONCUBE_PROBEPOSITION = _e.propertyNameToID("u_SpecCubeProbePosition"), kt
			.REFLECTIONCUBE_PROBEBOXMAX = _e.propertyNameToID("u_SpecCubeBoxMax"), kt.REFLECTIONCUBE_PROBEBOXMIN = _e
			.propertyNameToID("u_SpecCubeBoxMin");
		var wt = function BatchMark() {
				_classCallCheck(this, BatchMark), this.updateMark = -1, this.indexInList = -1, this.batched = !1
			},
			Bt = function(e) {
				function SubMeshInstanceBatch() {
					var e;
					_classCallCheck(this, SubMeshInstanceBatch), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							SubMeshInstanceBatch).call(this))).maxInstanceCount = 1024, e.instanceWorldMatrixData =
						new Float32Array(16 * e.maxInstanceCount), e.instanceMVPMatrixData = new Float32Array(16 * e
							.maxInstanceCount), e.instanceSimpleAnimatorData = new Float32Array(4 * e.maxInstanceCount);
					var r = t.LayaGL.instance;
					return e.instanceWorldMatrixBuffer = new te(4 * e.instanceWorldMatrixData.length, r.DYNAMIC_DRAW), e
						.instanceMVPMatrixBuffer = new te(4 * e.instanceMVPMatrixData.length, r.DYNAMIC_DRAW), e
						.instanceWorldMatrixBuffer.vertexDeclaration = Ne.instanceWorldMatrixDeclaration, e
						.instanceMVPMatrixBuffer.vertexDeclaration = Ne.instanceMVPMatrixDeclaration, e
						.instanceSimpleAnimatorBuffer = new te(4 * e.instanceSimpleAnimatorData.length, r.DYNAMIC_DRAW),
						e.instanceSimpleAnimatorBuffer.vertexDeclaration = Ne.instanceSimpleAnimatorDeclaration, e
				}
				return _inherits(SubMeshInstanceBatch, e), _createClass(SubMeshInstanceBatch, [{
					key: "_render",
					value: function(e) {
						var r = t.LayaGL.instance,
							n = e.renderElement,
							i = n.instanceSubMesh,
							a = n.instanceBatchElementList.length,
							o = i._indexCount;
						i._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance
							.drawElementsInstanced(r.TRIANGLES, o, r.UNSIGNED_SHORT, 2 * i._indexStart,
								a), t.Stat.renderBatches++, t.Stat.savedRenderBatches += a - 1, t.Stat
							.trianglesFaces += o * a / 3
					}
				}], [{
					key: "__init__",
					value: function() {
						SubMeshInstanceBatch.instance = new SubMeshInstanceBatch
					}
				}]), SubMeshInstanceBatch
			}(Ot),
			Vt = function(e) {
				function SubMeshRenderElement() {
					var e;
					return _classCallCheck(this, SubMeshRenderElement), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(SubMeshRenderElement).call(this)))._dynamicWorldPositionNormalNeedUpdate = !
						0, e
				}
				return _inherits(SubMeshRenderElement, e), _createClass(SubMeshRenderElement, [{
					key: "_onWorldMatrixChanged",
					value: function() {
						this._dynamicWorldPositionNormalNeedUpdate = !0
					}
				}, {
					key: "_computeWorldPositionsAndNormals",
					value: function(e, t, r, n) {
						if (this._dynamicWorldPositionNormalNeedUpdate) {
							for (var i = this._geometry, a = i._vertexBuffer, o = a.vertexDeclaration
									.vertexStride / 4, s = a.getFloat32Data(), l = this._transform
									.worldMatrix, u = this._transform.rotation, c = i._indices, h =
									0; h < n; h++) {
								var _ = (r ? c[h] : h) * o,
									d = 3 * h;
								P.transformVector3ArrayToVector3ArrayCoordinate(s, _ + e, l, this
										._dynamicWorldPositions, d), -1 !== t && P
									.transformVector3ArrayByQuat(s, _ + t, u, this._dynamicWorldNormals,
										d)
							}
							this._dynamicWorldPositionNormalNeedUpdate = !1
						}
					}
				}, {
					key: "setTransform",
					value: function(e) {
						this._transform !== e && (this._transform && this._transform.off(t.Event
								.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), e && e.on(t
								.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this
							._dynamicWorldPositionNormalNeedUpdate = !0, this._transform = e)
					}
				}, {
					key: "setGeometry",
					value: function(e) {
						if (this._geometry !== e) {
							var t = e,
								r = t._mesh;
							if (r) {
								var n = r._subMeshes.length > 1,
									i = n ? t._indexCount : r._vertexCount;
								if (i <= l.SubMeshDynamicBatch.maxAllowVertexCount) {
									var a = 3 * i;
									this._dynamicVertexBatch = !0, this._dynamicWorldPositions =
										new Float32Array(a), this._dynamicWorldNormals =
										new Float32Array(a), this._dynamicVertexCount = i, this
										._dynamicMultiSubMesh = n
								} else this._dynamicVertexBatch = !1
							}
							this._geometry = e
						}
					}
				}, {
					key: "addToOpaqueRenderQueue",
					value: function(e, r) {
						var n = this.staticBatch,
							i = r.elements,
							a = i.elements;
						if (!n || this.render._probReflection && !this.render._probReflection._isScene)
							if (this.renderSubShader._owner._enableInstancing && t.LayaGL
								.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0 && (
									!this.render._probReflection || this.render._probReflection._isScene
									)) {
								var o = this._geometry,
									s = l.MeshRenderDynamicBatchManager.instance,
									u = s.getInstanceBatchOpaquaMark(this.render.receiveShadow, this
										.material.id, o._id, this._transform._isFrontFaceInvert);
								if (s._updateCountMark === u.updateMark) {
									var c = u.indexInList;
									if (u.batched) {
										var h = a[c].instanceBatchElementList;
										h.length === Bt.instance.maxInstanceCount ? (u.updateMark = s
											._updateCountMark, u.indexInList = i.length, u
											.batched = !1, i.add(this)) : h.add(this)
									} else {
										var _ = a[c],
											d = _.render,
											f = s._getBatchRenderElementFromPool();
										f.renderType = Ze.RENDERTYPE_INSTANCEBATCH, f.setGeometry(Bt
												.instance), f.material = _.material, f.setTransform(
												null), f.render = d, f.instanceSubMesh = o, f
											.renderSubShader = _.renderSubShader;
										var m = f.instanceBatchElementList;
										m.length = 0, m.add(_), m.add(this), a[c] = f, u.batched = !0
									}
								} else u.updateMark = s._updateCountMark, u.indexInList = i.length, u
									.batched = !1, i.add(this)
							} else if (this._dynamicVertexBatch) {
							var p = this._geometry._vertexBuffer.vertexDeclaration,
								T = l.MeshRenderDynamicBatchManager.instance,
								E = T.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this
									.render.receiveShadow, this.material.id, p.id);
							if (T._updateCountMark === E.updateMark) {
								var g = E.indexInList;
								if (E.batched) a[g].vertexBatchElementList.add(this);
								else {
									var y = a[g],
										S = y.render,
										v = T._getBatchRenderElementFromPool();
									v.renderType = Ze.RENDERTYPE_VERTEXBATCH, v.setGeometry(l
											.SubMeshDynamicBatch.instance), v.material = y.material, v
										.setTransform(null), v.render = S, v
										.vertexBatchVertexDeclaration = p, v.renderSubShader = y
										.renderSubShader;
									var R = v.vertexBatchElementList;
									R.length = 0, R.add(y), R.add(this), a[g] = v, E.batched = !0
								}
							} else E.updateMark = T._updateCountMark, E.indexInList = i.length, E
								.batched = !1, i.add(this)
						} else i.add(this);
						else {
							var C = l.MeshRenderStaticBatchManager.instance,
								M = C.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render
									.receiveShadow, this.material.id, n._batchID);
							if (C._updateCountMark === M.updateMark) {
								var D = M.indexInList;
								if (M.batched) a[D].staticBatchElementList.add(this);
								else {
									var x = a[D],
										A = x.render,
										I = C._getBatchRenderElementFromPool();
									I.renderType = Ze.RENDERTYPE_STATICBATCH, I.setGeometry(n), I
										.material = x.material;
									var L = n.batchOwner,
										P = L ? L._transform : null;
									I.setTransform(P), I.render = A, I.renderSubShader = x
										.renderSubShader;
									var O = I.staticBatchElementList;
									O.length = 0, O.add(x), O.add(this), a[D] = I, M.batched = !0
								}
							} else M.updateMark = C._updateCountMark, M.indexInList = i.length, M
								.batched = !1, i.add(this)
						}
					}
				}, {
					key: "addToTransparentRenderQueue",
					value: function(e, r) {
						var n = this.staticBatch,
							i = r.elements,
							a = i.elements;
						if (n) {
							var o = l.MeshRenderStaticBatchManager.instance,
								s = r.lastTransparentRenderElement;
							if (s) {
								var u = s.render;
								if (s._geometry._getType() !== this._geometry._getType() || s
									.staticBatch !== n || s.material !== this.material || u
									.receiveShadow !== this.render.receiveShadow || u.lightmapIndex !==
									this.render.lightmapIndex) i.add(this), r.lastTransparentBatched = !
									1;
								else {
									if (r.lastTransparentBatched) a[i.length - 1].staticBatchElementList
										.add(this);
									else {
										var c = o._getBatchRenderElementFromPool();
										c.renderType = Ze.RENDERTYPE_STATICBATCH, c.setGeometry(n), c
											.material = s.material;
										var h = n.batchOwner,
											_ = h ? h._transform : null;
										c.setTransform(_), c.render = this.render, c.renderSubShader = s
											.renderSubShader;
										var d = c.staticBatchElementList;
										d.length = 0, d.add(s), d.add(this), a[i.length - 1] = c
									}
									r.lastTransparentBatched = !0
								}
							} else i.add(this), r.lastTransparentBatched = !1
						} else if (this.renderSubShader._owner._enableInstancing && t.LayaGL
							.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0 && (!
								this.render._probReflection || this.render._probReflection._isScene)) {
							var f = this._geometry,
								m = l.MeshRenderDynamicBatchManager.instance,
								p = r.lastTransparentRenderElement;
							if (p) {
								var T = p.render;
								if (p._geometry._getType() !== this._geometry._getType() || p
									._geometry !== f || p.material !== this.material || T
									.receiveShadow !== this.render.receiveShadow) i.add(this), r
									.lastTransparentBatched = !1;
								else if (r.lastTransparentBatched) {
									var E = a[i.length - 1].instanceBatchElementList;
									E.length === Bt.instance.maxInstanceCount ? (i.add(this), r
										.lastTransparentBatched = !1) : (E.add(this), r
										.lastTransparentBatched = !0)
								} else {
									var g = m._getBatchRenderElementFromPool();
									g.renderType = Ze.RENDERTYPE_INSTANCEBATCH, g.setGeometry(Bt
											.instance), g.material = p.material, g.setTransform(null), g
										.render = this.render, g.instanceSubMesh = f, g
										.renderSubShader = p.renderSubShader;
									var y = g.instanceBatchElementList;
									y.length = 0, y.add(p), y.add(this), a[i.length - 1] = g, r
										.lastTransparentBatched = !0
								}
							} else i.add(this), r.lastTransparentBatched = !1
						} else if (this._dynamicVertexBatch) {
							var S = this._geometry._vertexBuffer.vertexDeclaration,
								v = l.MeshRenderDynamicBatchManager.instance,
								R = r.lastTransparentRenderElement;
							if (R) {
								var C = R.render;
								if (R._dynamicVertexBatch && R._geometry._getType() === this._geometry
									._getType() && R._geometry._vertexBuffer._vertexDeclaration === S &&
									R.material === this.material && C.receiveShadow === this.render
									.receiveShadow && C.lightmapIndex === this.render.lightmapIndex) {
									if (r.lastTransparentBatched) a[i.length - 1].vertexBatchElementList
										.add(this);
									else {
										var M = v._getBatchRenderElementFromPool();
										M.renderType = Ze.RENDERTYPE_VERTEXBATCH, M.setGeometry(l
												.SubMeshDynamicBatch.instance), M.material = R.material,
											M.setTransform(null), M.render = this.render, M
											.vertexBatchVertexDeclaration = S, M.renderSubShader = R
											.renderSubShader;
										var D = M.vertexBatchElementList;
										D.length = 0, D.add(R), D.add(this), a[i.length - 1] = M
									}
									r.lastTransparentBatched = !0
								} else i.add(this), r.lastTransparentBatched = !1
							} else i.add(this), r.lastTransparentBatched = !1
						} else i.add(this);
						r.lastTransparentRenderElement = this
					}
				}, {
					key: "getInvertFront",
					value: function() {
						switch (this.renderType) {
							case Ze.RENDERTYPE_NORMAL:
								return this._transform._isFrontFaceInvert;
							case Ze.RENDERTYPE_STATICBATCH:
							case Ze.RENDERTYPE_VERTEXBATCH:
								return !1;
							case Ze.RENDERTYPE_INSTANCEBATCH:
								return this.instanceBatchElementList.elements[0]._transform
									._isFrontFaceInvert;
							default:
								throw "SubMeshRenderElement: unknown renderType"
						}
					}
				}, {
					key: "destroy",
					value: function() {
						_get(_getPrototypeOf(SubMeshRenderElement.prototype), "destroy", this).call(
								this), this._dynamicWorldPositions = null, this._dynamicWorldNormals =
							null, this.staticBatch = null, this.staticBatchElementList = null, this
							.vertexBatchElementList = null, this.vertexBatchVertexDeclaration = null
					}
				}]), SubMeshRenderElement
			}(Ze),
			Ft = function() {
				function StaticBatchManager() {
					_classCallCheck(this, StaticBatchManager), this._initBatchSprites = [], this._staticBatches = {},
						this._batchRenderElementPoolIndex = 0, this._batchRenderElementPool = []
				}
				return _createClass(StaticBatchManager, [{
					key: "_partition",
					value: function(e, t, r) {
						for (var n = e[Math.floor((r + t) / 2)]; t <= r;) {
							for (; this._compare(e[t], n) < 0;) t++;
							for (; this._compare(e[r], n) > 0;) r--;
							if (t < r) {
								var i = e[t];
								e[t] = e[r], e[r] = i, t++, r--
							} else if (t === r) {
								t++;
								break
							}
						}
						return t
					}
				}, {
					key: "_quickSort",
					value: function(e, t, r) {
						if (e.length > 1) {
							var n = this._partition(e, t, r),
								i = n - 1;
							t < i && this._quickSort(e, t, i), n < r && this._quickSort(e, n, r)
						}
					}
				}, {
					key: "_compare",
					value: function(e, t) {
						throw "StaticBatch:must override this function."
					}
				}, {
					key: "_initStaticBatchs",
					value: function(e) {
						throw "StaticBatch:must override this function."
					}
				}, {
					key: "_getBatchRenderElementFromPool",
					value: function() {
						throw "StaticBatch:must override this function."
					}
				}, {
					key: "_addBatchSprite",
					value: function(e) {
						this._initBatchSprites.push(e)
					}
				}, {
					key: "_clear",
					value: function() {
						this._batchRenderElementPoolIndex = 0
					}
				}, {
					key: "_garbageCollection",
					value: function() {
						throw "StaticBatchManager: must override it."
					}
				}, {
					key: "dispose",
					value: function() {
						this._staticBatches = null
					}
				}], [{
					key: "_addToStaticBatchQueue",
					value: function(e, t) {
						e instanceof kt && t.push(e);
						for (var r = 0, n = e.numChildren; r < n; r++) StaticBatchManager
							._addToStaticBatchQueue(e._children[r], t)
					}
				}, {
					key: "_registerManager",
					value: function(e) {
						StaticBatchManager._managers.push(e)
					}
				}, {
					key: "combine",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						t || (t = [], e && StaticBatchManager._addToStaticBatchQueue(e, t));
						var r = t.length;
						if (r > 0) {
							for (var n = 0; n < r; n++) {
								var i = t[n];
								i.destroyed || (i._render._isPartOfStaticBatch ? console.warn(
										"StaticBatchManager: Sprite " + i.name +
										" has a part of Static Batch,it will be ignore.") : i
									._addToInitStaticBatchManager())
							}
							for (var a = 0, o = StaticBatchManager._managers.length; a < o; a++) {
								var s = StaticBatchManager._managers[a];
								s._initStaticBatchs(e)
							}
						}
					}
				}]), StaticBatchManager
			}();
		Ft._managers = [];
		var Ut = function(r) {
			function SubMeshStaticBatch(e, t) {
				var r;
				return _classCallCheck(this, SubMeshStaticBatch), (r = _possibleConstructorReturn(this,
						_getPrototypeOf(SubMeshStaticBatch).call(this)))._bufferState = new oe, r._batchID =
					SubMeshStaticBatch._batchIDCounter++, r._batchElements = [], r._currentBatchVertexCount = 0, r
					._currentBatchIndexCount = 0, r._vertexDeclaration = t, r.batchOwner = e, r
			}
			return _inherits(SubMeshStaticBatch, r), _createClass(SubMeshStaticBatch, [{
				key: "_getStaticBatchBakedVertexs",
				value: function(e, t, r, n, i, a) {
					var o, s = a._vertexBuffer,
						l = s.vertexDeclaration,
						u = l.getVertexElementByUsage(Ne.MESH_POSITION0)._offset / 4,
						h = l.getVertexElementByUsage(Ne.MESH_NORMAL0),
						_ = h ? h._offset / 4 : -1,
						d = l.getVertexElementByUsage(Ne.MESH_COLOR0),
						f = d ? d._offset / 4 : -1,
						m = l.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0),
						p = m ? m._offset / 4 : -1,
						T = l.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE1),
						E = T ? T._offset / 4 : -1,
						g = l.getVertexElementByUsage(Ne.MESH_TANGENT0),
						y = g ? g._offset / 4 : -1,
						S = l.vertexStride / 4,
						v = s.getFloat32Data();
					r ? (r.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40), o =
						SubMeshStaticBatch._tempMatrix4x41, c.multiply(SubMeshStaticBatch
							._tempMatrix4x40, n.worldMatrix, o)) : o = n.worldMatrix;
					var R = SubMeshStaticBatch._tempMatrix4x42;
					o.invert(R), R.transpose();
					var C = SubMeshStaticBatch._tempQuaternion0;
					o.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, C, SubMeshStaticBatch
						._tempVector31);
					for (var M = i.lightmapScaleOffset, D = a.vertexCount, x = 0; x < D; x++) {
						var A, I, L = x * S,
							O = 18 * (x + t);
						P.transformVector3ArrayToVector3ArrayCoordinate(v, L + u, o, e, O + 0), -
							1 !== _ && P.transformVector3ArrayToVector3ArrayNormal(v, L + _, R, e,
								O + 3);
						var N = O + 6;
						if (-1 !== f) {
							var b = L + f;
							for (A = 0, I = 4; A < I; A++) e[N + A] = v[b + A]
						} else
							for (A = 0, I = 4; A < I; A++) e[N + A] = 1;
						if (-1 !== p) {
							var k = L + p;
							e[O + 10] = v[k], e[O + 11] = v[k + 1]
						}
						if (M && (-1 !== E ? P.transformLightingMapTexcoordArray(v, L + E, M, e, O +
								12) : P.transformLightingMapTexcoordArray(v, L + p, M, e, O +
								12)), -1 !== y) {
							var w = L + y;
							P.transformVector3ArrayToVector3ArrayNormal(v, w, R, e, O + 14), e[O +
								17] = v[w + 3]
						}
					}
					return D
				}
			}, {
				key: "addTest",
				value: function(e) {
					var t = e.meshFilter.sharedMesh.vertexCount;
					return !(this._currentBatchVertexCount + t > SubMeshStaticBatch
						.maxBatchVertexCount)
				}
			}, {
				key: "add",
				value: function(e) {
					var t = e.meshFilter.sharedMesh,
						r = t.vertexCount;
					this._batchElements.push(e);
					var n = e._render;
					n._isPartOfStaticBatch = !0, n._staticBatch = this;
					for (var i = n._renderElements, a = 0, o = i.length; a < o; a++) i[a]
						.staticBatch = this;
					this._currentBatchIndexCount += t._indexBuffer.indexCount, this
						._currentBatchVertexCount += r
				}
			}, {
				key: "remove",
				value: function(e) {
					var t = e.meshFilter.sharedMesh,
						r = this._batchElements.indexOf(e);
					if (-1 !== r) {
						this._batchElements.splice(r, 1);
						for (var n = e._render._renderElements, i = 0, a = n.length; i < a; i++) n[
							i].staticBatch = null;
						this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer
							.indexCount, this._currentBatchVertexCount = this
							._currentBatchVertexCount - t.vertexCount, e._render
							._isPartOfStaticBatch = !1
					}
				}
			}, {
				key: "finishInit",
				value: function() {
					this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer
					.destroy(), t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this
							._indexBuffer._byteLength)));
					var r = t.LayaGL.instance,
						n = 0,
						i = 0,
						a = this.batchOwner,
						o = this._vertexDeclaration.vertexStride / 4,
						s = new Float32Array(o * this._currentBatchVertexCount),
						l = new Uint16Array(this._currentBatchIndexCount);
					this._vertexBuffer = new te(this._vertexDeclaration.vertexStride * this
							._currentBatchVertexCount, r.STATIC_DRAW), this._vertexBuffer
						.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new Oe(e
							.IndexFormat.UInt16, this._currentBatchIndexCount, r.STATIC_DRAW);
					for (var u = 0, c = this._batchElements.length; u < c; u++) {
						for (var h, _ = this._batchElements[u], d = _.meshFilter.sharedMesh, f =
								this._getStaticBatchBakedVertexs(s, n, a ? a._transform : null, _
									._transform, _._render, d), m = d._indexBuffer.getData(), p = n,
								T = i + m.length, E = _._render._renderElements, g = 0, y = d
								.subMeshCount; g < y; g++) {
							var S = d._subMeshes[g],
								v = i + S._indexStart,
								R = E[g];
							R.staticBatchIndexStart = v, R.staticBatchIndexEnd = v + S._indexCount
						}
						if (l.set(m, i), a ? _._transform._isFrontFaceInvert !== a.transform
							._isFrontFaceInvert : _._transform._isFrontFaceInvert)
							for (h = i; h < T; h += 3) {
								l[h] = p + l[h];
								var C = l[h + 1],
									M = l[h + 2];
								l[h + 1] = p + M, l[h + 2] = p + C
							} else
								for (h = i; h < T; h += 3) l[h] = p + l[h], l[h + 1] = p + l[h + 1],
									l[h + 2] = p + l[h + 2];
						i += m.length, n += f
					}
					this._vertexBuffer.setData(s.buffer), this._indexBuffer.setData(l);
					var D = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
					t.Resource._addGPUMemory(D), this._bufferState.bind(), this._bufferState
						.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(
							this._indexBuffer), this._bufferState.unBind()
				}
			}, {
				key: "_render",
				value: function(e) {
					this._bufferState.bind();
					for (var r = t.LayaGL.instance, n = e.renderElement.staticBatchElementList, i =
							n.elements, a = 0, o = 0, s = n.length, l = 1; l < s; l++) {
						if (i[l - 1].staticBatchIndexEnd !== i[l].staticBatchIndexStart) {
							var u = i[a].staticBatchIndexStart,
								c = i[o].staticBatchIndexEnd - u;
							r.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u), a = ++o, t.Stat
								.trianglesFaces += c / 3
						} else o++
					}
					u = i[a].staticBatchIndexStart, c = i[o].staticBatchIndexEnd - u, r
						.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u), t.Stat
						.renderBatches++, t.Stat.savedRenderBatches += s - 1, t.Stat
						.trianglesFaces += c / 3
				}
			}, {
				key: "dispose",
				value: function() {
					var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
					t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner =
						null, this._vertexDeclaration = null, this._bufferState.destroy(), this
						._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._vertexBuffer =
						null, this._indexBuffer = null, this._bufferState = null
				}
			}]), SubMeshStaticBatch
		}(Ot);
		Ut._tempVector30 = new o, Ut._tempVector31 = new o, Ut._tempQuaternion0 = new u, Ut._tempMatrix4x40 = new c, Ut
			._tempMatrix4x41 = new c, Ut._tempMatrix4x42 = new c, Ut.maxBatchVertexCount = 65535, Ut._batchIDCounter =
			0;
		var Gt, Ht = function(e) {
			function MeshRenderStaticBatchManager() {
				var e;
				return _classCallCheck(this, MeshRenderStaticBatchManager), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(MeshRenderStaticBatchManager).call(this)))._opaqueBatchMarks = [], e
					._updateCountMark = 0, e
			}
			return _inherits(MeshRenderStaticBatchManager, e), _createClass(MeshRenderStaticBatchManager, [{
				key: "_compare",
				value: function(e, t) {
					var r = e._render,
						n = t._render,
						i = e.meshFilter.sharedMesh,
						a = t.meshFilter.sharedMesh,
						o = r.lightmapIndex - n.lightmapIndex;
					if (0 === o) {
						var s = (r.receiveShadow ? 1 : 0) - (n.receiveShadow ? 1 : 0);
						if (0 === s) {
							var l = r.sharedMaterial && n.sharedMaterial ? r.sharedMaterial.id - n
								.sharedMaterial.id : 0;
							if (0 === l) {
								var u = i._vertexBuffer.vertexDeclaration.id - a._vertexBuffer
									.vertexDeclaration.id;
								return 0 === u ? a._indexBuffer.indexCount - i._indexBuffer
									.indexCount : u
							}
							return l
						}
						return s
					}
					return o
				}
			}, {
				key: "_getBatchRenderElementFromPool",
				value: function() {
					var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
					return e || (e = new Vt, this._batchRenderElementPool[this
							._batchRenderElementPoolIndex - 1] = e, e.staticBatchElementList =
						new R), e
				}
			}, {
				key: "_getStaticBatch",
				value: function(e, t, r) {
					var n = e[r];
					return n || (n = e[r] = new Ut(t, MeshRenderStaticBatchManager._verDec), this
						._staticBatches[n._batchID] = n), n
				}
			}, {
				key: "_initStaticBatchs",
				value: function(e) {
					var t = this._initBatchSprites;
					this._quickSort(t, 0, t.length - 1);
					for (var r, n = [], i = !1, a = 0, o = 0, s = t.length; o < s; o++) {
						var l = t[o];
						if (i) r.addTest(l) ? r.add(l) : (i = !1, a++);
						else o !== s - 1 && ((r = this._getStaticBatch(n, e, a)).add(l), i = !0)
					}
					for (o = 0, s = n.length; o < s; o++) {
						var u = n[o];
						u && u.finishInit()
					}
					this._initBatchSprites.length = 0
				}
			}, {
				key: "_removeRenderSprite",
				value: function(e) {
					var t = e._render,
						r = t._staticBatch,
						n = r._batchElements,
						i = n.indexOf(e);
					if (-1 !== i) {
						n.splice(i, 1), t._staticBatch = null;
						for (var a = t._renderElements, o = 0, s = a.length; o < s; o++) a[o]
							.staticBatch = null
					}
					0 === n.length && (delete this._staticBatches[r._batchID], r.dispose())
				}
			}, {
				key: "_clear",
				value: function() {
					_get(_getPrototypeOf(MeshRenderStaticBatchManager.prototype), "_clear", this)
						.call(this), this._updateCountMark++
				}
			}, {
				key: "_garbageCollection",
				value: function() {
					for (var e in this._staticBatches) {
						var t = this._staticBatches[e];
						0 === t._batchElements.length && (t.dispose(), delete this._staticBatches[
							e])
					}
				}
			}, {
				key: "getBatchOpaquaMark",
				value: function(e, t, r, n) {
					var i = t ? 1 : 0,
						a = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []),
						o = a[i] || (a[i] = []),
						s = o[r] || (o[r] = []);
					return s[n] || (s[n] = new wt)
				}
			}], [{
				key: "__init__",
				value: function() {
					MeshRenderStaticBatchManager._verDec = Ne.getVertexDeclaration(
						"POSITION,NORMAL,COLOR,UV,UV1,TANGENT")
				}
			}]), MeshRenderStaticBatchManager
		}(Ft);
		Ht.instance = new Ht, (Gt = e.ReflectionProbeMode || (e.ReflectionProbeMode = {}))[Gt.off = 0] = "off", Gt[Gt
			.simple = 1] = "simple";
		var zt = function(e) {
			function ReflectionProbe() {
				var e;
				return _classCallCheck(this, ReflectionProbe), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(ReflectionProbe).call(this)))._boxProjection = !1, e._size = new o, e
					._offset = new o, e._reflectionHDRParams = new i, e._reflectionDecodeFormat = t
					.TextureDecodeFormat.Normal, e._isScene = !1, e
			}
			return _inherits(ReflectionProbe, e), _createClass(ReflectionProbe, [{
				key: "_parse",
				value: function(e, r) {
					_get(_getPrototypeOf(ReflectionProbe.prototype), "_parse", this).call(this, e,
							r), this._boxProjection = e.boxProjection, this._importance = e
						.importance, this._reflectionTexture = t.Loader.getRes(e.reflection);
					var n = this.transform.position;
					this._size.fromArray(e.boxSize), o.scale(this._size, .5, ReflectionProbe
						.TEMPVECTOR3), this._offset.fromArray(e.boxOffset);
					var i = new o,
						a = new o;
					o.add(n, ReflectionProbe.TEMPVECTOR3, a), o.add(a, this._offset, a), o.subtract(
							n, ReflectionProbe.TEMPVECTOR3, i), o.add(i, this._offset, i), this
						._reflectionDecodeFormat = e.reflectionDecodingFormat, this.intensity = e
						.intensity, this._bounds ? (this._bounds.setMin(i), this._bounds.setMax(
						a)) : this.bounds = new Pt(i, a)
				}
			}, {
				key: "_setIndexInReflectionList",
				value: function(e) {
					this._indexInReflectProbList = e
				}
			}, {
				key: "_getIndexInReflectionList",
				value: function() {
					return this._indexInReflectProbList
				}
			}, {
				key: "_onActive",
				value: function() {
					_get(_getPrototypeOf(ReflectionProbe.prototype), "_onActive", this).call(this),
						this._reflectionTexture && this.scene._reflectionProbeManager.add(this)
				}
			}, {
				key: "_onInActive",
				value: function() {
					_get(_getPrototypeOf(ReflectionProbe.prototype), "_onInActive", this).call(
						this), this.reflectionTexture && this.scene._reflectionProbeManager.remove(
							this)
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					this.destroyed || (_get(_getPrototypeOf(ReflectionProbe.prototype), "destroy",
							this).call(this, e), this._reflectionTexture && this
						._reflectionTexture._removeReference(), this._reflectionTexture = null,
						this._bounds = null)
				}
			}, {
				key: "_cloneTo",
				value: function(e, t, r) {
					var n = e;
					n.bounds = this.bounds, n.boxProjection = this.boxProjection, n.importance =
						this.importance, n._size = this._size, n._offset = this._offset, n
						.intensity = this.intensity, n.reflectionHDRParams = this
						.reflectionHDRParams, _get(_getPrototypeOf(ReflectionProbe.prototype),
							"_cloneTo", this).call(this, e, t, r)
				}
			}, {
				key: "boxProjection",
				get: function() {
					return this._boxProjection
				},
				set: function(e) {
					this._boxProjection = e
				}
			}, {
				key: "importance",
				get: function() {
					return this._importance
				},
				set: function(e) {
					this._importance = e
				}
			}, {
				key: "intensity",
				get: function() {
					return this._intensity
				},
				set: function(e) {
					e = Math.max(Math.min(e, 1), 0), this._reflectionHDRParams.x = e, this
						._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this
							._reflectionHDRParams.x *= 5), this._intensity = e
				}
			}, {
				key: "reflectionTexture",
				get: function() {
					return this._reflectionTexture
				},
				set: function(e) {
					this._reflectionTexture = e, this._reflectionTexture._addReference()
				}
			}, {
				key: "bounds",
				get: function() {
					return this._bounds
				},
				set: function(e) {
					this._bounds = e
				}
			}, {
				key: "boundsMax",
				get: function() {
					return this._bounds.getMax()
				}
			}, {
				key: "boundsMin",
				get: function() {
					return this._bounds.getMin()
				}
			}, {
				key: "probePosition",
				get: function() {
					return this.transform.position
				}
			}, {
				key: "reflectionHDRParams",
				get: function() {
					return this._reflectionHDRParams
				},
				set: function(e) {
					this._reflectionHDRParams = e
				}
			}]), ReflectionProbe
		}(Ee);
		zt.TEMPVECTOR3 = new o, zt.defaultTextureHDRDecodeValues = new i(1, 1, 0, 0);
		var Wt = function(r) {
			function BaseRender(r) {
				var n;
				return _classCallCheck(this, BaseRender), (n = _possibleConstructorReturn(this, _getPrototypeOf(
						BaseRender).call(this)))._lightmapScaleOffset = new i(1, 1, 0, 0), n._indexInList = -1, n
					._indexInCastShadowList = -1, n._boundsChange = !0, n._castShadow = !1, n._supportOctree = !0, n
					._sharedMaterials = [], n._renderMark = -1, n._indexInOctreeMotionList = -1, n._reflectionMode =
					e.ReflectionProbeMode.simple, n._updateMark = -1, n._updateRenderType = -1, n
					._isPartOfStaticBatch = !1, n._staticBatch = null, n._id = ++BaseRender._uniqueIDCounter, n
					._indexInCastShadowList = -1, n._bounds = new Pt(o._ZERO, o._ZERO), n._renderElements = [], n
					._owner = r, n._enable = !0, n._materialsInstance = [], n._shaderValues = new ne(null), n
					.lightmapIndex = -1, n.receiveShadow = !1, n.sortingFudge = 0, r && n._owner.transform.on(t
						.Event.TRANSFORM_CHANGED, _assertThisInitialized(n), n._onWorldMatNeedChange), n
			}
			return _inherits(BaseRender, r), _createClass(BaseRender, [{
				key: "_getOctreeNode",
				value: function() {
					return this._octreeNode
				}
			}, {
				key: "_setOctreeNode",
				value: function(e) {
					e || -1 !== this._indexInOctreeMotionList && this._octreeNode._octree
						.removeMotionObject(this), this._octreeNode = e
				}
			}, {
				key: "_getIndexInMotionList",
				value: function() {
					return this._indexInOctreeMotionList
				}
			}, {
				key: "_setIndexInMotionList",
				value: function(e) {
					this._indexInOctreeMotionList = e
				}
			}, {
				key: "_changeMaterialReference",
				value: function(e, t) {
					e && e._removeReference(), t._addReference()
				}
			}, {
				key: "_getInstanceMaterial",
				value: function(e, t) {
					var r = e.clone();
					return r.name = r.name + "(Instance)", this._materialsInstance[t] = !0, this
						._changeMaterialReference(this._sharedMaterials[t], r), this
						._sharedMaterials[t] = r, r
				}
			}, {
				key: "_isSupportReflection",
				value: function() {
					this._surportReflectionProbe = !1;
					for (var e = this._sharedMaterials, t = 0, r = e.length; t < r; t++) {
						var n = e[t];
						this._surportReflectionProbe = this._surportReflectionProbe || n && n
							._shader._supportReflectionProbe
					}
				}
			}, {
				key: "_addReflectionProbeUpdate",
				value: function() {
					this._surportReflectionProbe && 1 == this._reflectionMode && this._scene
						._reflectionProbeManager.addMotionObject(this)
				}
			}, {
				key: "_applyLightMapParams",
				value: function() {
					var e = this._scene.lightmaps,
						t = this._shaderValues,
						r = this._lightmapIndex;
					if (r >= 0 && r < e.length) {
						var n = e[r];
						t.setTexture(kt.LIGHTMAP, n.lightmapColor), t.addDefine(kt
							.SAHDERDEFINE_LIGHTMAP), n.lightmapDirection ? (t.setTexture(kt
							.LIGHTMAP_DIRECTION, n.lightmapDirection), t.addDefine(kt
							.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)) : t.removeDefine(kt
							.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)
					} else t.removeDefine(kt.SAHDERDEFINE_LIGHTMAP), t.removeDefine(kt
						.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)
				}
			}, {
				key: "_onWorldMatNeedChange",
				value: function(e) {
					this._boundsChange = !0, this._octreeNode && (e &= f.TRANSFORM_WORLDPOSITION | f
							.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE) && -1 === this
						._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this),
						this._addReflectionProbeUpdate()
				}
			}, {
				key: "_calculateBoundingBox",
				value: function() {
					throw "BaseRender: must override it."
				}
			}, {
				key: "_getIndexInList",
				value: function() {
					return this._indexInList
				}
			}, {
				key: "_setIndexInList",
				value: function(e) {
					this._indexInList = e
				}
			}, {
				key: "_setBelongScene",
				value: function(e) {
					this._scene = e
				}
			}, {
				key: "_needRender",
				value: function(e, t) {
					return !0
				}
			}, {
				key: "_renderUpdate",
				value: function(e, t) {}
			}, {
				key: "_renderUpdateWithCamera",
				value: function(e, t) {}
			}, {
				key: "_revertBatchRenderUpdate",
				value: function(e) {}
			}, {
				key: "_destroy",
				value: function() {
					-1 !== this._indexInOctreeMotionList && this._octreeNode._octree
						.removeMotionObject(this), this.offAll();
					var e = 0,
						t = 0;
					for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e]
						.destroy();
					for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[
						e].destroyed || this._sharedMaterials[e]._removeReference();
					this._renderElements = null, this._owner = null, this._sharedMaterials = null,
						this._bounds = null, this._lightmapScaleOffset = null
				}
			}, {
				key: "markAsUnStatic",
				value: function() {
					this._isPartOfStaticBatch && (Ht.instance._removeRenderSprite(this._owner), this
						._isPartOfStaticBatch = !1)
				}
			}, {
				key: "id",
				get: function() {
					return this._id
				}
			}, {
				key: "lightmapIndex",
				get: function() {
					return this._lightmapIndex
				},
				set: function(e) {
					this._lightmapIndex = e
				}
			}, {
				key: "lightmapScaleOffset",
				get: function() {
					return this._lightmapScaleOffset
				},
				set: function(e) {
					if (!e) throw "BaseRender: lightmapScaleOffset can't be null.";
					this._lightmapScaleOffset = e, this._shaderValues.setVector(kt
						.LIGHTMAPSCALEOFFSET, e)
				}
			}, {
				key: "enable",
				get: function() {
					return this._enable
				},
				set: function(e) {
					this._enable = !!e
				}
			}, {
				key: "material",
				get: function() {
					var e = this._sharedMaterials[0];
					if (e && !this._materialsInstance[0]) {
						var t = this._getInstanceMaterial(e, 0),
							r = this._renderElements[0];
						r && (r.material = t)
					}
					return this._sharedMaterials[0]
				},
				set: function(e) {
					this.sharedMaterial = e, this._isSupportReflection()
				}
			}, {
				key: "materials",
				get: function() {
					for (var e = 0, t = this._sharedMaterials.length; e < t; e++)
						if (!this._materialsInstance[e]) {
							var r = this._getInstanceMaterial(this._sharedMaterials[e], e),
								n = this._renderElements[e];
							n && (n.material = r)
						} return this._sharedMaterials.slice()
				},
				set: function(e) {
					this.sharedMaterials = e, this._isSupportReflection()
				}
			}, {
				key: "sharedMaterial",
				get: function() {
					return this._sharedMaterials[0]
				},
				set: function(e) {
					var t = this._sharedMaterials[0];
					if (t !== e) {
						this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this
							._changeMaterialReference(t, e);
						var r = this._renderElements[0];
						r && (r.material = e)
					}
					this._isSupportReflection()
				}
			}, {
				key: "sharedMaterials",
				get: function() {
					return this._sharedMaterials.slice()
				},
				set: function(e) {
					for (var t = this._materialsInstance, r = this._sharedMaterials, n = 0, i = r
							.length; n < i; n++) {
						var a = r[n];
						a && a._removeReference()
					}
					if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
					var o = e.length;
					for (t.length = o, r.length = o, n = 0; n < o; n++) {
						a = r[n];
						var s = e[n];
						if (a !== s) {
							t[n] = !1;
							var l = this._renderElements[n];
							l && (l.material = s)
						}
						s && s._addReference(), r[n] = s
					}
					this._isSupportReflection()
				}
			}, {
				key: "bounds",
				get: function() {
					return this._boundsChange && (this._calculateBoundingBox(), this
						._boundsChange = !1), this._bounds
				}
			}, {
				key: "receiveShadow",
				set: function(e) {
					this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues
						.addDefine(kt.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues
						.removeDefine(kt.SHADERDEFINE_RECEIVE_SHADOW))
				},
				get: function() {
					return this._receiveShadow
				}
			}, {
				key: "castShadow",
				get: function() {
					return this._castShadow
				},
				set: function(e) {
					this._castShadow = e
				}
			}, {
				key: "isPartOfStaticBatch",
				get: function() {
					return this._isPartOfStaticBatch
				}
			}, {
				key: "isRender",
				get: function() {
					return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1
				}
			}, {
				key: "reflectionMode",
				set: function(e) {
					this._reflectionMode = e
				},
				get: function() {
					return this._reflectionMode
				}
			}]), BaseRender
		}(t.EventDispatcher);
		Wt._tempBoundBoxCorners = [new o, new o, new o, new o, new o, new o, new o, new o], Wt._uniqueIDCounter = 0, Wt
			._defaultLightmapScaleOffset = new i(1, 1, 0, 0);
		var Xt = function(e) {
				function PixelLineRenderer(e) {
					var t;
					return _classCallCheck(this, PixelLineRenderer), (t = _possibleConstructorReturn(this,
						_getPrototypeOf(PixelLineRenderer).call(this, e)))._projectionViewWorldMatrix = new c, t
				}
				return _inherits(PixelLineRenderer, e), _createClass(PixelLineRenderer, [{
					key: "_calculateBoundingBox",
					value: function() {
						var e = this._owner.transform.worldMatrix,
							t = this._owner._geometryFilter;
						t._reCalculateBound(), t._bounds._tranform(e, this._bounds)
					}
				}, {
					key: "_renderUpdateWithCamera",
					value: function(e, t) {
						var r = e.projectionViewMatrix,
							n = this._shaderValues;
						if (t) {
							var i = t.worldMatrix;
							n.setMatrix4x4(Ee.WORLDMATRIX, i), c.multiply(r, i, this
								._projectionViewWorldMatrix), n.setMatrix4x4(Ee.MVPMATRIX, this
								._projectionViewWorldMatrix)
						} else n.setMatrix4x4(Ee.WORLDMATRIX, c.DEFAULT), n.setMatrix4x4(Ee.MVPMATRIX,
							r)
					}
				}]), PixelLineRenderer
			}(Wt),
			Yt = function(e) {
				function PixelLineSprite3D() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					return _classCallCheck(this, PixelLineSprite3D), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(PixelLineSprite3D).call(this, r)))._isRenderActive = !1, e._isInRenders = !
						1, e._geometryFilter = new bt(_assertThisInitialized(e), t), e._render = new Xt(
							_assertThisInitialized(e)), e._changeRenderObjects(e._render, 0, It.defaultMaterial), e
				}
				return _inherits(PixelLineSprite3D, e), _createClass(PixelLineSprite3D, [{
					key: "_onInActive",
					value: function() {
						t.Stat.spriteCount--, 0 != this._geometryFilter._lineCount && this
							._isRenderActive && (this._scene._removeRenderObject(this._render), this
								._isInRenders = !1), this._isRenderActive = !1
					}
				}, {
					key: "_onActive",
					value: function() {
						t.Stat.spriteCount++, this._isRenderActive = !0, 0 != this._geometryFilter
							._lineCount && (this._scene._addRenderObject(this._render), this
								._isInRenders = !0)
					}
				}, {
					key: "_changeRenderObjects",
					value: function(e, t, r) {
						var n = this._render._renderElements;
						r || (r = It.defaultMaterial);
						var i = n[t];
						i || (i = n[t] = new Ze), i.setTransform(this._transform), i.setGeometry(this
							._geometryFilter), i.render = this._render, i.material = r
					}
				}, {
					key: "addLine",
					value: function(e, t, r, n) {
						if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount)
							throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
						this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r,
								n), this._isRenderActive && !this._isInRenders && this._geometryFilter
							._lineCount > 0 && (this._scene._addRenderObject(this._render), this
								._isInRenders = !0)
					}
				}, {
					key: "addLines",
					value: function(e) {
						var t = this._geometryFilter._lineCount,
							r = e.length;
						if (t + r > this._geometryFilter._maxLineCount)
						throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
						this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount +=
							r, this._isRenderActive && !this._isInRenders && this._geometryFilter
							._lineCount > 0 && (this._scene._addRenderObject(this._render), this
								._isInRenders = !0)
					}
				}, {
					key: "removeLine",
					value: function(e) {
						if (!(e < this._geometryFilter._lineCount))
						throw "PixelLineSprite3D: index must less than lineCount.";
						this._geometryFilter._removeLineData(e), this._isRenderActive && this
							._isInRenders && 0 == this._geometryFilter._lineCount && (this._scene
								._removeRenderObject(this._render), this._isInRenders = !1)
					}
				}, {
					key: "setLine",
					value: function(e, t, r, n, i) {
						if (!(e < this._geometryFilter._lineCount))
						throw "PixelLineSprite3D: index must less than lineCount.";
						this._geometryFilter._updateLineData(e, t, r, n, i)
					}
				}, {
					key: "getLine",
					value: function(e, t) {
						if (!(e < this.lineCount))
						throw "PixelLineSprite3D: index must less than lineCount.";
						this._geometryFilter._getLineData(e, t)
					}
				}, {
					key: "clear",
					value: function() {
						this._geometryFilter._lineCount = 0, this._isRenderActive && this
							._isInRenders && (this._scene._removeRenderObject(this._render), this
								._isInRenders = !1)
					}
				}, {
					key: "_create",
					value: function() {
						return new PixelLineSprite3D
					}
				}, {
					key: "maxLineCount",
					get: function() {
						return this._geometryFilter._maxLineCount
					},
					set: function(e) {
						this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math
							.min(this._geometryFilter._lineCount, e)
					}
				}, {
					key: "lineCount",
					get: function() {
						return this._geometryFilter._lineCount
					},
					set: function(e) {
						if (e > this.maxLineCount)
						throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
						this._geometryFilter._lineCount = e
					}
				}, {
					key: "pixelLineRenderer",
					get: function() {
						return this._render
					}
				}]), PixelLineSprite3D
			}(kt),
			jt = function() {
				function RenderQueue() {
					var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
					_classCallCheck(this, RenderQueue), this.isTransparent = !1, this.elements = new R, this
						.lastTransparentRenderElement = null, this.lastTransparentBatched = !1, this.isTransparent = e
				}
				return _createClass(RenderQueue, [{
					key: "_compare",
					value: function(e, t) {
						var r = e.material.renderQueue - t.material.renderQueue;
						return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render
							._distanceForSort : e.render._distanceForSort - t.render
							._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r
					}
				}, {
					key: "_partitionRenderObject",
					value: function(e, t) {
						for (var r = this.elements.elements, n = r[Math.floor((t + e) / 2)]; e <= t;) {
							for (; this._compare(r[e], n) < 0;) e++;
							for (; this._compare(r[t], n) > 0;) t--;
							if (e < t) {
								var i = r[e];
								r[e] = r[t], r[t] = i, e++, t--
							} else if (e === t) {
								e++;
								break
							}
						}
						return e
					}
				}, {
					key: "_quickSort",
					value: function(e, t) {
						if (this.elements.length > 1) {
							var r = this._partitionRenderObject(e, t),
								n = r - 1;
							e < n && this._quickSort(e, n), r < t && this._quickSort(r, t)
						}
					}
				}, {
					key: "_render",
					value: function(e) {
						for (var t = this.elements.elements, r = 0, n = this.elements.length; r <
							n; r++) t[r]._render(e)
					}
				}, {
					key: "clear",
					value: function() {
						this.elements.length = 0, this.lastTransparentRenderElement = null, this
							.lastTransparentBatched = !1
					}
				}]), RenderQueue
			}(),
			Zt = function() {
				function BoundsOctreeNode(e, t, r, n) {
					_classCallCheck(this, BoundsOctreeNode), this._bounds = new Lt(new o, new o), this._objects = [],
						this._isContaion = !1, this.center = new o, this.baseLength = 0, this._setValues(e, t, r, n)
				}
				return _createClass(BoundsOctreeNode, [{
					key: "_setValues",
					value: function(e, t, r, n) {
						this._octree = e, this._parent = t, this.baseLength = r, n.cloneTo(this.center);
						var i = this._bounds.min,
							a = this._bounds.max,
							o = e._looseness * r / 2;
						i.setValue(n.x - o, n.y - o, n.z - o), a.setValue(n.x + o, n.y + o, n.z + o)
					}
				}, {
					key: "_getChildBound",
					value: function(e) {
						if (null != this._children && this._children[e]) return this._children[e]
							._bounds;
						var t = this.baseLength / 4,
							r = this.baseLength / 2 * this._octree._looseness / 2,
							n = BoundsOctreeNode._tempBoundBox,
							i = n.min,
							a = n.max;
						switch (e) {
							case 0:
								i.x = this.center.x - t - r, i.y = this.center.y + t - r, i.z = this
									.center.z - t - r, a.x = this.center.x - t + r, a.y = this.center
									.y + t + r, a.z = this.center.z - t + r;
								break;
							case 1:
								i.x = this.center.x + t - r, i.y = this.center.y + t - r, i.z = this
									.center.z - t - r, a.x = this.center.x + t + r, a.y = this.center
									.y + t + r, a.z = this.center.z - t + r;
								break;
							case 2:
								i.x = this.center.x - t - r, i.y = this.center.y + t - r, i.z = this
									.center.z + t - r, a.x = this.center.x - t + r, a.y = this.center
									.y + t + r, a.z = this.center.z + t + r;
								break;
							case 3:
								i.x = this.center.x + t - r, i.y = this.center.y + t - r, i.z = this
									.center.z + t - r, a.x = this.center.x + t + r, a.y = this.center
									.y + t + r, a.z = this.center.z + t + r;
								break;
							case 4:
								i.x = this.center.x - t - r, i.y = this.center.y - t - r, i.z = this
									.center.z - t - r, a.x = this.center.x - t + r, a.y = this.center
									.y - t + r, a.z = this.center.z - t + r;
								break;
							case 5:
								i.x = this.center.x + t - r, i.y = this.center.y - t - r, i.z = this
									.center.z - t - r, a.x = this.center.x + t + r, a.y = this.center
									.y - t + r, a.z = this.center.z - t + r;
								break;
							case 6:
								i.x = this.center.x - t - r, i.y = this.center.y - t - r, i.z = this
									.center.z + t - r, a.x = this.center.x - t + r, a.y = this.center
									.y - t + r, a.z = this.center.z + t + r;
								break;
							case 7:
								i.x = this.center.x + t - r, i.y = this.center.y - t - r, i.z = this
									.center.z + t - r, a.x = this.center.x + t + r, a.y = this.center
									.y - t + r, a.z = this.center.z + t + r
						}
						return n
					}
				}, {
					key: "_getChildCenter",
					value: function(e) {
						if (null != this._children) return this._children[e].center;
						var t = this.baseLength / 4,
							r = BoundsOctreeNode._tempVector30;
						switch (e) {
							case 0:
								r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z -
									t;
								break;
							case 1:
								r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z -
									t;
								break;
							case 2:
								r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z +
									t;
								break;
							case 3:
								r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z +
									t;
								break;
							case 4:
								r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z -
									t;
								break;
							case 5:
								r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z -
									t;
								break;
							case 6:
								r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z +
									t;
								break;
							case 7:
								r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z +
									t
						}
						return r
					}
				}, {
					key: "_getChild",
					value: function(e) {
						var t = this.baseLength / 4;
						switch (this._children || (this._children = []), e) {
							case 0:
								return this._children[0] || (this._children[0] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x + -t, this.center.y + t, this.center.z - t)));
							case 1:
								return this._children[1] || (this._children[1] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x + t, this.center.y + t, this.center.z - t)));
							case 2:
								return this._children[2] || (this._children[2] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x - t, this.center.y + t, this.center.z + t)));
							case 3:
								return this._children[3] || (this._children[3] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x + t, this.center.y + t, this.center.z + t)));
							case 4:
								return this._children[4] || (this._children[4] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x - t, this.center.y - t, this.center.z - t)));
							case 5:
								return this._children[5] || (this._children[5] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x + t, this.center.y - t, this.center.z - t)));
							case 6:
								return this._children[6] || (this._children[6] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x - t, this.center.y - t, this.center.z + t)));
							case 7:
								return this._children[7] || (this._children[7] = new BoundsOctreeNode(
									this._octree, this, this.baseLength / 2, new o(this.center
										.x + t, this.center.y - t, this.center.z + t)));
							default:
								throw "BoundsOctreeNode: unknown index."
						}
					}
				}, {
					key: "_shouldMerge",
					value: function() {
						for (var e = this._objects.length, t = 0; t < 8; t++) {
							var r = this._children[t];
							if (r) {
								if (null != r._children) return !1;
								e += r._objects.length
							}
						}
						return e <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED
					}
				}, {
					key: "_mergeChildren",
					value: function() {
						for (var e = 0; e < 8; e++) {
							var t = this._children[e];
							if (t) {
								t._parent = null;
								for (var r = t._objects, n = r.length - 1; n >= 0; n--) {
									var i = r[n];
									this._objects.push(i), i._setOctreeNode(this)
								}
							}
						}
						this._children = null
					}
				}, {
					key: "_merge",
					value: function() {
						if (null === this._children) {
							var e = this._parent;
							e && e._shouldMerge() && (e._mergeChildren(), e._merge())
						}
					}
				}, {
					key: "_checkAddNode",
					value: function(e) {
						if (null == this._children) {
							if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || this
								.baseLength / 2 < this._octree._minSize) return this;
							for (var t = this._objects.length - 1; t >= 0; t--) {
								var r = this._objects[t],
									n = this._bestFitChild(r.bounds.getCenter());
								BoundsOctreeNode._encapsulates(this._getChildBound(n), r.bounds
									._getBoundBox()) && (this._objects.splice(this._objects.indexOf(
									r), 1), this._getChild(n)._add(r))
							}
						}
						var i = this._bestFitChild(e.bounds.getCenter());
						return BoundsOctreeNode._encapsulates(this._getChildBound(i), e.bounds
							._getBoundBox()) ? this._getChild(i)._checkAddNode(e) : this
					}
				}, {
					key: "_add",
					value: function(e) {
						var t = this._checkAddNode(e);
						t._objects.push(e), e._setOctreeNode(t)
					}
				}, {
					key: "_remove",
					value: function(e) {
						var t = this._objects.indexOf(e);
						this._objects.splice(t, 1), e._setOctreeNode(null), this._merge()
					}
				}, {
					key: "_addUp",
					value: function(e) {
						return xe.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Me
							.Contains ? (this._add(e), !0) : !!this._parent && this._parent._addUp(e)
					}
				}, {
					key: "_getCollidingWithFrustum",
					value: function(e, r, n, i, a, s) {
						var l = e.boundFrustum,
							u = e.position,
							c = e.cullingMask;
						if (n) {
							var h = l.containsBoundBox(this._bounds);
							if (t.Stat.octreeNodeCulling++, h === Me.Disjoint) return;
							n = h === Me.Intersects
						}
						this._isContaion = !n;
						for (var _ = r.scene, d = t.Stat.loopCount, f = 0, m = this._objects.length; f <
							m; f++) {
							var p = this._objects[f];
							if (s ? p._castShadow && p._enable : 0 != (Math.pow(2, p._owner._layer) &
								c) && p._enable) {
								if (n && (t.Stat.frustumCulling++, !p._needRender(l, r))) continue;
								p._renderMark = d, p._distanceForSort = o.distance(p.bounds.getCenter(),
									u);
								for (var T = p._renderElements, E = 0, g = T.length; E < g; E++) {
									T[E]._update(_, r, i, a)
								}
							}
						}
						if (null != this._children)
							for (f = 0; f < 8; f++) {
								var y = this._children[f];
								y && y._getCollidingWithFrustum(e, r, n, i, a, s)
							}
					}
				}, {
					key: "_getCollidingWithBoundBox",
					value: function(e, t, r) {
						if (t) {
							var n = xe.boxContainsBox(this._bounds, e);
							if (n === Me.Disjoint) return;
							t = n === Me.Intersects
						}
						if (t)
							for (var i = 0, a = this._objects.length; i < a; i++) {
								var o = this._objects[i];
								xe.intersectsBoxAndBox(o.bounds._getBoundBox(), e) && r.push(o)
							}
						if (null != this._children)
							for (i = 0; i < 8; i++) {
								this._children[i]._getCollidingWithBoundBox(e, t, r)
							}
					}
				}, {
					key: "_bestFitChild",
					value: function(e) {
						return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <=
							this.center.z ? 0 : 2)
					}
				}, {
					key: "_update",
					value: function(e) {
						if (xe.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === Me.Contains) {
							var t = this._checkAddNode(e);
							if (t !== e._getOctreeNode()) {
								t._objects.push(e), e._setOctreeNode(t);
								var r = this._objects.indexOf(e);
								this._objects.splice(r, 1), this._merge()
							}
							return !0
						}
						if (this._parent) {
							var n = this._parent._addUp(e);
							return n && (r = this._objects.indexOf(e), this._objects.splice(r, 1), this
								._merge()), n
						}
						return !1
					}
				}, {
					key: "add",
					value: function(e) {
						return !!BoundsOctreeNode._encapsulates(this._bounds, e.bounds
						._getBoundBox()) && (this._add(e), !0)
					}
				}, {
					key: "remove",
					value: function(e) {
						return e._getOctreeNode() === this && (this._remove(e), !0)
					}
				}, {
					key: "update",
					value: function(e) {
						return e._getOctreeNode() === this && this._update(e)
					}
				}, {
					key: "shrinkIfPossible",
					value: function(e) {
						if (this.baseLength < 2 * e) return this;
						for (var t = -1, r = 0, n = this._objects.length; r < n; r++) {
							var i = this._objects[r],
								a = this._bestFitChild(i.bounds.getCenter());
							if (0 != r && a != t) return this;
							var o = this._getChildBound(a);
							if (!BoundsOctreeNode._encapsulates(o, i.bounds._getBoundBox()))
						return this;
							0 == r && (t = a)
						}
						if (null == this._children) {
							if (-1 != t) {
								var s = this._getChildCenter(t);
								this._setValues(this._octree, null, this.baseLength / 2, s)
							}
							return this
						}
						var l = !1;
						for (r = 0, n = this._children.length; r < n; r++) {
							var u = this._children[r];
							if (u && u.hasAnyObjects()) {
								if (l) return this;
								if (t >= 0 && t != r) return this;
								l = !0, t = r
							}
						}
						if (-1 != t) {
							var c = this._children[t];
							return c._parent = null, c
						}
						return this
					}
				}, {
					key: "hasAnyObjects",
					value: function() {
						if (this._objects.length > 0) return !0;
						if (null != this._children)
							for (var e = 0; e < 8; e++) {
								var t = this._children[e];
								if (t && t.hasAnyObjects()) return !0
							}
						return !1
					}
				}, {
					key: "getCollidingWithBoundBox",
					value: function(e, t) {
						this._getCollidingWithBoundBox(e, !0, t)
					}
				}, {
					key: "getCollidingWithRay",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number
							.MAX_VALUE,
							n = xe.intersectsRayAndBoxRD(e, this._bounds);
						if (!(-1 == n || n > r)) {
							for (var i = 0, a = this._objects.length; i < a; i++) {
								var o = this._objects[i]; - 1 !== (n = xe.intersectsRayAndBoxRD(e, o
									.bounds._getBoundBox())) && n <= r && t.push(o)
							}
							if (null != this._children)
								for (i = 0; i < 8; i++) {
									var s = this._children[i];
									s.getCollidingWithRay(e, t, r)
								}
						}
					}
				}, {
					key: "getCollidingWithFrustum",
					value: function(e, t, r, n, i) {
						this._getCollidingWithFrustum(e, t, !0, r, n, i)
					}
				}, {
					key: "isCollidingWithBoundBox",
					value: function(e) {
						if (!xe.intersectsBoxAndBox(this._bounds, e)) return !1;
						for (var t = 0, r = this._objects.length; t < r; t++) {
							var n = this._objects[t];
							if (xe.intersectsBoxAndBox(n.bounds._getBoundBox(), e)) return !0
						}
						if (null != this._children)
							for (t = 0; t < 8; t++) {
								if (this._children[t].isCollidingWithBoundBox(e)) return !0
							}
						return !1
					}
				}, {
					key: "isCollidingWithRay",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number
							.MAX_VALUE,
							r = xe.intersectsRayAndBoxRD(e, this._bounds);
						if (-1 == r || r > t) return !1;
						for (var n = 0, i = this._objects.length; n < i; n++) {
							var a = this._objects[n];
							if (-1 !== (r = xe.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) &&
								r <= t) return !0
						}
						if (null != this._children)
							for (n = 0; n < 8; n++) {
								var o = this._children[n];
								if (o.isCollidingWithRay(e, t)) return !0
							}
						return !1
					}
				}, {
					key: "getBound",
					value: function() {
						return this._bounds
					}
				}, {
					key: "drawAllBounds",
					value: function(e, t, r) {
						if (null !== this._children || 0 != this._objects.length) {
							t++;
							var n = BoundsOctreeNode._tempColor0;
							if (this._isContaion) n.r = 0, n.g = 0, n.b = 1;
							else {
								var i = r ? t / r : 0;
								n.r = 1 - i, n.g = i, n.b = 0
							}
							if (n.a = .3, P._drawBound(e, this._bounds, n), null != this._children)
								for (var a = 0; a < 8; a++) {
									var o = this._children[a];
									o && o.drawAllBounds(e, t, r)
								}
						}
					}
				}, {
					key: "drawAllObjects",
					value: function(e, t, r) {
						t++;
						var n = BoundsOctreeNode._tempColor0;
						if (this._isContaion) n.r = 0, n.g = 0, n.b = 1;
						else {
							var i = r ? t / r : 0;
							n.r = 1 - i, n.g = i, n.b = 0
						}
						n.a = 1;
						for (var a = 0, o = this._objects.length; a < o; a++) P._drawBound(e, this
							._objects[a].bounds._getBoundBox(), n);
						if (null != this._children)
							for (a = 0; a < 8; a++) {
								var s = this._children[a];
								s && s.drawAllObjects(e, t, r)
							}
					}
				}], [{
					key: "_encapsulates",
					value: function(e, t) {
						return xe.boxContainsBox(e, t) == Me.Contains
					}
				}]), BoundsOctreeNode
			}();
		Zt._tempVector3 = new o, Zt._tempVector30 = new o, Zt._tempVector31 = new o, Zt._tempColor0 = new ft, Zt
			._tempBoundBox = new Lt(new o, new o), Zt._NUM_OBJECTS_ALLOWED = 8;
		var Qt = function(e) {
				function OctreeMotionList() {
					return _classCallCheck(this, OctreeMotionList), _possibleConstructorReturn(this, _getPrototypeOf(
						OctreeMotionList).call(this))
				}
				return _inherits(OctreeMotionList, e), _createClass(OctreeMotionList, [{
					key: "add",
					value: function(e) {
						if (-1 !== e._getIndexInMotionList())
						throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
						this._add(e), e._setIndexInMotionList(this.length++)
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._getIndexInMotionList();
						if (this.length--, t !== this.length) {
							var r = this.elements[this.length];
							this.elements[t] = r, r._setIndexInMotionList(t)
						}
						e._setIndexInMotionList(-1)
					}
				}]), OctreeMotionList
			}(R),
			qt = function() {
				function BoundsOctree(e, t, r, n) {
					_classCallCheck(this, BoundsOctree), this._motionObjects = new Qt, this.count = 0, r > e && (console
							.warn("Minimum node size must be at least as big as the initial world size. Was: " + r +
								" Adjusted to: " + e), r = e), this._initialSize = e, this._minSize = r, this
						._looseness = Math.min(Math.max(n, 1), 2), this._rootNode = new Zt(this, null, e, t)
				}
				return _createClass(BoundsOctree, [{
					key: "_getMaxDepth",
					value: function(e, t) {
						t++;
						var r = e._children;
						if (null != r)
							for (var n = t, i = 0, a = r.length; i < a; i++) {
								var o = r[i];
								o && (t = Math.max(this._getMaxDepth(o, n), t))
							}
						return t
					}
				}, {
					key: "_grow",
					value: function(e) {
						var t = e.x >= 0 ? 1 : -1,
							r = e.y >= 0 ? 1 : -1,
							n = e.z >= 0 ? 1 : -1,
							i = this._rootNode,
							a = this._rootNode.baseLength / 2,
							s = 2 * this._rootNode.baseLength,
							l = this._rootNode.center,
							u = new o(l.x + t * a, l.y + r * a, l.z + n * a);
						if (this._rootNode = new Zt(this, null, s, u), i.hasAnyObjects()) {
							for (var c = this._rootNode._bestFitChild(i.center), h = [], _ = 0; _ <
								8; _++) _ == c && (i._parent = this._rootNode, h[_] = i);
							this._rootNode._children = h
						}
					}
				}, {
					key: "add",
					value: function(e) {
						for (var t = 0; !this._rootNode.add(e);) {
							var r = BoundsOctree._tempVector30;
							if (o.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(
									r), ++t > 20)
							throw "Aborted Add operation as it seemed to be going on forever (" + (
									t - 1) + ") attempts at growing the octree."
						}
						this.count++
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._getOctreeNode().remove(e);
						return t && this.count--, t
					}
				}, {
					key: "update",
					value: function(e) {
						var t = 0,
							r = e._getOctreeNode();
						if (r) {
							for (; !r._update(e);) {
								var n = BoundsOctree._tempVector30;
								if (o.subtract(e.bounds.getCenter(), this._rootNode.center, n), this
									._grow(n), ++t > 20)
								throw "Aborted Add operation as it seemed to be going on forever (" +
									(t - 1) + ") attempts at growing the octree."
							}
							return !0
						}
						return !1
					}
				}, {
					key: "shrinkRootIfPossible",
					value: function() {
						this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize)
					}
				}, {
					key: "addMotionObject",
					value: function(e) {
						this._motionObjects.add(e)
					}
				}, {
					key: "removeMotionObject",
					value: function(e) {
						this._motionObjects.remove(e)
					}
				}, {
					key: "updateMotionObjects",
					value: function() {
						for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects
							.length; t < r; t++) {
							var n = e[t];
							this.update(n), n._setIndexInMotionList(-1)
						}
						this._motionObjects.length = 0
					}
				}, {
					key: "isCollidingWithBoundBox",
					value: function(e) {
						return this._rootNode.isCollidingWithBoundBox(e)
					}
				}, {
					key: "isCollidingWithRay",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number
							.MAX_VALUE;
						return this._rootNode.isCollidingWithRay(e, t)
					}
				}, {
					key: "getCollidingWithBoundBox",
					value: function(e, t) {
						this._rootNode.getCollidingWithBoundBox(e, t)
					}
				}, {
					key: "getCollidingWithRay",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number
							.MAX_VALUE;
						this._rootNode.getCollidingWithRay(e, t, r)
					}
				}, {
					key: "getCollidingWithFrustum",
					value: function(e, t, r, n, i) {
						this._rootNode.getCollidingWithFrustum(e, t, r, n, i)
					}
				}, {
					key: "getMaxBounds",
					value: function() {
						return this._rootNode.getBound()
					}
				}, {
					key: "drawAllBounds",
					value: function(e) {
						var t = this._getMaxDepth(this._rootNode, -1);
						this._rootNode.drawAllBounds(e, -1, t)
					}
				}, {
					key: "drawAllObjects",
					value: function(e) {
						var t = this._getMaxDepth(this._rootNode, -1);
						this._rootNode.drawAllObjects(e, -1, t)
					}
				}]), BoundsOctree
			}();
		qt._tempVector30 = new o;
		var Kt = function Lightmap() {
				_classCallCheck(this, Lightmap)
			},
			Jt = function() {
				function BoundSphere(e, t) {
					_classCallCheck(this, BoundSphere), this.center = e, this.radius = t
				}
				return _createClass(BoundSphere, [{
					key: "toDefault",
					value: function() {
						this.center.toDefault(), this.radius = 0
					}
				}, {
					key: "intersectsRayDistance",
					value: function(e) {
						return xe.intersectsRayAndSphereRD(e, this)
					}
				}, {
					key: "intersectsRayPoint",
					value: function(e, t) {
						return xe.intersectsRayAndSphereRP(e, this, t)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this.center.cloneTo(t.center), t.radius = this.radius
					}
				}, {
					key: "clone",
					value: function() {
						var e = new BoundSphere(new o, 0);
						return this.cloneTo(e), e
					}
				}], [{
					key: "createFromSubPoints",
					value: function(e, t, r, n) {
						if (null == e) throw new Error("points");
						if (t < 0 || t >= e.length) throw new Error("start" + t +
							"Must be in the range [0, " + (e.length - 1) + "]");
						if (r < 0 || t + r > e.length) throw new Error("count" + r +
							"Must be in the range <= " + e.length + "}");
						var i = t + r,
							a = BoundSphere._tempVector3;
						a.x = 0, a.y = 0, a.z = 0;
						for (var s = t; s < i; ++s) o.add(e[s], a, a);
						var l = n.center;
						o.scale(a, 1 / r, l);
						var u = 0;
						for (s = t; s < i; ++s) {
							var c = o.distanceSquared(l, e[s]);
							c > u && (u = c)
						}
						n.radius = Math.sqrt(u)
					}
				}, {
					key: "createfromPoints",
					value: function(e, t) {
						if (null == e) throw new Error("points");
						BoundSphere.createFromSubPoints(e, 0, e.length, t)
					}
				}]), BoundSphere
			}();
		Jt._tempVector3 = new o;
		var $t, er = function ShadowSliceData() {
				_classCallCheck(this, ShadowSliceData), this.cameraShaderValue = new ne, this.position = new o, this
					.viewMatrix = new c, this.projectionMatrix = new c, this.viewProjectMatrix = new c, this
					.cullPlanes = [new Re(new o), new Re(new o), new Re(new o), new Re(new o), new Re(new o), new Re(
						new o), new Re(new o), new Re(new o), new Re(new o), new Re(new o)], this.splitBoundSphere =
					new Jt(new o, 0)
			},
			tr = function ShadowSpotData() {
				_classCallCheck(this, ShadowSpotData), this.cameraShaderValue = new ne, this.position = new o, this
					.viewMatrix = new c, this.projectionMatrix = new c, this.viewProjectMatrix = new c, this
					.cameraCullInfo = new mt
			};
		($t = e.ShadowLightType || (e.ShadowLightType = {}))[$t.DirectionLight = 0] = "DirectionLight", $t[$t
			.SpotLight = 1] = "SpotLight", $t[$t.PointLight = 2] = "PointLight";
		var rr = function() {
			function ShadowCasterPass() {
				_classCallCheck(this, ShadowCasterPass), this._shadowBias = new i, this._shadowParams = new i, this
					._shadowMapSize = new i, this._shadowMatrices = new Float32Array(16 * ShadowCasterPass
						._maxCascades), this._shadowSpotMatrices = new c, this._splitBoundSpheres =
					new Float32Array(4 * ShadowCasterPass._maxCascades), this._cascadeCount = 0, this
					._shadowMapWidth = 0, this._shadowMapHeight = 0, this._shadowSliceDatas = [new er, new er,
						new er, new er
					], this._shadowSpotData = new tr, this._lightUp = new o, this._lightSide = new o, this
					._lightForward = new o, this._shadowSpotData.cameraCullInfo.boundFrustum = new Ae(new c)
			}
			return _createClass(ShadowCasterPass, [{
				key: "_setupShadowCasterShaderValues",
				value: function(t, r, n, i, a, o, s) {
					switch (r.setVector(ShadowCasterPass.SHADOW_BIAS, o), s) {
						case e.LightType.Directional:
							r.setVector3(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, i);
							break;
						case e.LightType.Spot:
							r.setVector(ShadowCasterPass.SHADOW_PARAMS, a);
							break;
						case e.LightType.Point:
					}
					var l = n.cameraShaderValue;
					l.setMatrix4x4(Ve.VIEWMATRIX, n.viewMatrix), l.setMatrix4x4(Ve.PROJECTMATRIX, n
							.projectionMatrix), l.setMatrix4x4(Ve.VIEWPROJECTMATRIX, n
							.viewProjectMatrix), t.viewMatrix = n.viewMatrix, t.projectionMatrix = n
						.projectionMatrix, t.projectionViewMatrix = n.viewProjectMatrix
				}
			}, {
				key: "_setupShadowReceiverShaderValues",
				value: function(t) {
					var r = this._light;
					switch (r.shadowCascadesMode !== e.ShadowCascadesMode.NoCascades ? t.addDefine(
						Ue.SHADERDEFINE_SHADOW_CASCADE) : t.removeDefine(Ue
						.SHADERDEFINE_SHADOW_CASCADE), r.shadowMode) {
						case e.ShadowMode.Hard:
							t.removeDefine(Ue.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(
								Ue.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
							break;
						case e.ShadowMode.SoftLow:
							t.addDefine(Ue.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(Ue
								.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
							break;
						case e.ShadowMode.SoftHigh:
							t.addDefine(Ue.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH), t.removeDefine(Ue
								.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW)
					}
					t.setTexture(ShadowCasterPass.SHADOW_MAP, this._shadowDirectLightMap), t
						.setBuffer(ShadowCasterPass.SHADOW_MATRICES, this._shadowMatrices), t
						.setVector(ShadowCasterPass.SHADOW_MAP_SIZE, this._shadowMapSize), t
						.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams), t.setBuffer(
							ShadowCasterPass.SHADOW_SPLIT_SPHERES, this._splitBoundSpheres)
				}
			}, {
				key: "_setupSpotShadowReceiverShaderValues",
				value: function(t) {
					switch (this._light.shadowMode) {
						case e.ShadowMode.Hard:
							t.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH), t
								.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW);
							break;
						case e.ShadowMode.SoftLow:
							t.addDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW), t
								.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH);
							break;
						case e.ShadowMode.SoftHigh:
							t.addDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH), t
								.removeDefine(Ue.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW)
					}
					t.setTexture(ShadowCasterPass.SHADOW_SPOTMAP, this._shadowSpotLightMap), t
						.setMatrix4x4(ShadowCasterPass.SHADOW_SPOTMATRICES, this
							._shadowSpotMatrices), t.setVector(ShadowCasterPass.SHADOW_MAP_SIZE,
							this._shadowMapSize), t.setVector(ShadowCasterPass.SHADOW_PARAMS, this
							._shadowParams)
				}
			}, {
				key: "update",
				value: function(t, n, i) {
					switch (i) {
						case e.ShadowLightType.DirectionLight:
							this._light = n;
							var a = (D = ShadowCasterPass._tempMatrix0).elements,
								s = this._lightUp,
								l = this._lightSide,
								u = this._lightForward;
							c.createFromQuaternion(n._transform.rotation, D), l.setValue(a[0], a[1],
								a[2]), s.setValue(a[4], a[5], a[6]), u.setValue(-a[8], -a[9], -
								a[10]);
							var h, _, d, f, m = n._shadowResolution,
								p = n._shadowCascadesMode;
							p == e.ShadowCascadesMode.NoCascades ? (h = 1, _ = m, d = m, f = m) : (
									h = p == e.ShadowCascadesMode.TwoCascades ? 2 : 4, d = 2 * (_ =
										Ye.getMaxTileResolutionInAtlas(m, m, h)), f = p == e
									.ShadowCascadesMode.TwoCascades ? _ : 2 * _), this
								._cascadeCount = h, this._shadowMapWidth = d, this
								._shadowMapHeight = f;
							var T = ShadowCasterPass._cascadesSplitDistance,
								E = ShadowCasterPass._frustumPlanes,
								g = t.nearPlane,
								y = Math.min(t.farPlane, n._shadowDistance),
								S = this._shadowMatrices,
								v = this._splitBoundSpheres;
							Ye.getCascadesSplitDistance(n._shadowTwoCascadeSplits, n
								._shadowFourCascadeSplits, g, y, t.fieldOfView * r.Deg2Rad, t
								.aspectRatio, p, T), Ye.getCameraFrustumPlanes(t
								.projectionViewMatrix, E);
							var R = ShadowCasterPass._tempVector30;
							t._transform.getForward(R), o.normalize(R, R);
							for (var C = 0; C < h; C++) {
								var M = this._shadowSliceDatas[C];
								M.sphereCenterZ = Ye.getBoundSphereByFrustum(T[C], T[C + 1], t
										.fieldOfView * r.Deg2Rad, t.aspectRatio, t._transform
										.position, R, M.splitBoundSphere), Ye
									.getDirectionLightShadowCullPlanes(E, C, T, g, u, M), Ye
									.getDirectionalLightMatrices(s, l, u, C, n._shadowNearPlane, _,
										M, S), h > 1 && Ye.applySliceTransform(M, d, f, C, S)
							}
							Ye.prepareShadowReceiverShaderValues(n, d, f, this._shadowSliceDatas, h,
								this._shadowMapSize, this._shadowParams, S, v);
							break;
						case e.ShadowLightType.SpotLight:
							this._light = n;
							var D = ShadowCasterPass._tempMatrix0,
								x = (u = this._lightForward, this._light._shadowResolution);
							this._shadowMapWidth = x, this._shadowMapHeight = x;
							var A = this._shadowSpotData;
							Ye.getSpotLightShadowData(A, this._light, x, this._shadowParams, this
								._shadowSpotMatrices, this._shadowMapSize);
							break;
						case e.ShadowLightType.PointLight:
							break;
						default:
							throw "There is no shadow of this type"
					}
				}
			}, {
				key: "render",
				value: function(r, n, i) {
					switch (i) {
						case e.ShadowLightType.DirectionLight:
							var a = n._shaderValues;
							r.pipelineMode = "ShadowCaster", ne.setRuntimeValueMode(!1), (p = this
								._shadowDirectLightMap = Ye.getTemporaryShadowTexture(this
									._shadowMapWidth, this._shadowMapHeight, t
									.RenderTextureDepthFormat.DEPTH_16))._start();
							for (var o = this._light, s = 0, l = this._cascadeCount; s < l; s++) {
								var u = this._shadowSliceDatas[s];
								Ye.getShadowBias(o, u.projectionMatrix, u.resolution, this
									._shadowBias), this._setupShadowCasterShaderValues(r, a, u,
									this._lightForward, this._shadowParams, this._shadowBias, e
									.LightType.Directional);
								var c = Tt._shadowCullInfo;
								c.position = u.position, c.cullPlanes = u.cullPlanes, c
									.cullPlaneCount = u.cullPlaneCount, c.cullSphere = u
									.splitBoundSphere, c.direction = this._lightForward;
								var h = Tt.cullingShadow(c, n, r);
								r.cameraShaderValue = u.cameraShaderValue, je._updateMark++;
								var _ = t.LayaGL.instance,
									d = u.resolution,
									f = u.offsetX,
									m = u.offsetY;
								_.enable(_.SCISSOR_TEST), _.viewport(f, m, d, d), _.scissor(f, m, d,
									d), _.clear(_.DEPTH_BUFFER_BIT), h && (_.scissor(f + 1, m +
									1, d - 2, d - 2), n._opaqueQueue._render(r))
							}
							p._end(), this._setupShadowReceiverShaderValues(a), ne
								.setRuntimeValueMode(!0), r.pipelineMode = "Forward";
							break;
						case e.ShadowLightType.SpotLight:
							a = n._shaderValues;
							r.pipelineMode = "ShadowCaster", ne.setRuntimeValueMode(!1);
							var p, T = this._light;
							(p = this._shadowSpotLightMap = Ye.getTemporaryShadowTexture(this
								._shadowMapWidth, this._shadowMapHeight, t
								.RenderTextureDepthFormat.DEPTH_16))._start();
							var E = this._shadowSpotData;
							Ye.getShadowBias(T, E.projectionMatrix, E.resolution, this._shadowBias),
								this._setupShadowCasterShaderValues(r, a, E, this._light.transform
									.position, this._shadowParams, this._shadowBias, e.LightType
									.Spot);
							h = Tt.cullingSpotShadow(E.cameraCullInfo, n, r);
							r.cameraShaderValue = E.cameraShaderValue, je._updateMark++, (_ = t
									.LayaGL.instance).enable(_.SCISSOR_TEST), _.viewport(E.offsetX,
									E.offsetY, E.resolution, E.resolution), _.scissor(E.offsetX, E
									.offsetY, E.resolution, E.resolution), _.clear(_
									.DEPTH_BUFFER_BIT), h && (_.scissor(E.offsetX, E.offsetY, E
									.resolution, E.resolution), n._opaqueQueue._render(r)), p
							._end(), this._setupSpotShadowReceiverShaderValues(a), ne
								.setRuntimeValueMode(!0), r.pipelineMode = "Forward";
							break;
						case e.ShadowLightType.PointLight:
							break;
						default:
							throw "There is no shadow of this type"
					}
				}
			}, {
				key: "cleanUp",
				value: function() {
					this._shadowDirectLightMap && $.recoverToPool(this._shadowDirectLightMap), this
						._shadowSpotLightMap && $.recoverToPool(this._shadowSpotLightMap), this
						._shadowDirectLightMap = null, this._shadowSpotLightMap = null, this
						._light = null
				}
			}]), ShadowCasterPass
		}();
		rr._tempVector30 = new o, rr._tempMatrix0 = new c, rr.SHADOW_BIAS = _e.propertyNameToID("u_ShadowBias"), rr
			.SHADOW_LIGHT_DIRECTION = _e.propertyNameToID("u_ShadowLightDirection"), rr.SHADOW_SPLIT_SPHERES = _e
			.propertyNameToID("u_ShadowSplitSpheres"), rr.SHADOW_MATRICES = _e.propertyNameToID("u_ShadowMatrices"), rr
			.SHADOW_MAP_SIZE = _e.propertyNameToID("u_ShadowMapSize"), rr.SHADOW_MAP = _e.propertyNameToID(
				"u_ShadowMap"), rr.SHADOW_PARAMS = _e.propertyNameToID("u_ShadowParams"), rr.SHADOW_SPOTMAP = _e
			.propertyNameToID("u_SpotShadowMap"), rr.SHADOW_SPOTMATRICES = _e.propertyNameToID(
				"u_SpotViewProjectMatrix"), rr._maxCascades = 4, rr._cascadesSplitDistance = new Array(rr._maxCascades +
				1), rr._frustumPlanes = new Array(new Re(new o), new Re(new o), new Re(new o), new Re(new o), new Re(
				new o), new Re(new o));
		var nr = function() {
			function DynamicBatchManager() {
				_classCallCheck(this, DynamicBatchManager), this._batchRenderElementPool = []
			}
			return _createClass(DynamicBatchManager, [{
				key: "_clear",
				value: function() {
					this._batchRenderElementPoolIndex = 0
				}
			}, {
				key: "_getBatchRenderElementFromPool",
				value: function() {
					throw "StaticBatch:must override this function."
				}
			}, {
				key: "dispose",
				value: function() {}
			}], [{
				key: "_registerManager",
				value: function(e) {
					DynamicBatchManager._managers.push(e)
				}
			}]), DynamicBatchManager
		}();
		nr._managers = [];
		var ir, ar = function(e) {
				function ReflectionProbeList() {
					return _classCallCheck(this, ReflectionProbeList), _possibleConstructorReturn(this, _getPrototypeOf(
						ReflectionProbeList).call(this))
				}
				return _inherits(ReflectionProbeList, e), _createClass(ReflectionProbeList, [{
					key: "add",
					value: function(e) {
						this._add(e), e._setIndexInReflectionList(this.length++)
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._getIndexInReflectionList();
						if (this.length--, t !== this.length) {
							var r = this.elements[this.length];
							this.elements[t] = r, r._setIndexInReflectionList(t)
						}
						e._setIndexInReflectionList(-1)
					}
				}]), ReflectionProbeList
			}(R),
			or = function() {
				function ReflectionProbeManager() {
					_classCallCheck(this, ReflectionProbeManager), this._reflectionProbes = new ar, this
						._motionObjects = new R, this._needUpdateAllRender = !1, this._sceneReflectionProbe = new zt,
						this._sceneReflectionProbe.bounds = new Pt(new o(0, 0, 0), new o(0, 0, 0)), this
						._sceneReflectionProbe.boxProjection = !1, this._sceneReflectionProbe._isScene = !0
				}
				return _createClass(ReflectionProbeManager, [{
					key: "_updateMotionObjects",
					value: function(e) {
						if (0 != this._reflectionProbes.length) {
							for (var t, r, n = this._reflectionProbes.elements, i = 0, a = e.bounds, o =
									0, s = this._reflectionProbes.length; o < s; o++) {
								var l = n[o];
								if (t) {
									if (t.importance > l.importance) continue;
									if ((r = a.calculateBoundsintersection(l.bounds)) < i && t
										.importance == l.importance) continue
								} else if ((r = a.calculateBoundsintersection(l.bounds)) < i) continue;
								t = l, i = r
							}!t && this._sceneReflectionProbe && (t = this._sceneReflectionProbe), e
								._probReflection = t
						} else e._probReflection = this._sceneReflectionProbe
					}
				}, {
					key: "add",
					value: function(e) {
						this._reflectionProbes.add(e), this._needUpdateAllRender = !0
					}
				}, {
					key: "remove",
					value: function(e) {
						this._reflectionProbes.remove(e), this._needUpdateAllRender = !0
					}
				}, {
					key: "addMotionObject",
					value: function(e) {
						this._motionObjects.add(e)
					}
				}, {
					key: "update",
					value: function() {
						for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects
							.length; t < r; t++) this._updateMotionObjects(e[t]);
						this.clearMotionObjects()
					}
				}, {
					key: "updateAllRenderObjects",
					value: function(e) {
						for (var t = e.elements, r = 0, n = e.length; r < n; r++) this
							._updateMotionObjects(t[r]);
						this._needUpdateAllRender = !1
					}
				}, {
					key: "clearMotionObjects",
					value: function() {
						this._motionObjects.length = 0
					}
				}, {
					key: "destroy",
					value: function() {}
				}, {
					key: "sceneReflectionProbe",
					set: function(e) {
						this._sceneReflectionProbe.reflectionTexture = e
					}
				}, {
					key: "sceneReflectionCubeHDRParam",
					set: function(e) {
						this._sceneReflectionProbe.reflectionHDRParams = e
					}
				}]), ReflectionProbeManager
			}();
		(ir = e.AmbientMode || (e.AmbientMode = {}))[ir.SolidColor = 0] = "SolidColor", ir[ir.SphericalHarmonics = 1] =
			"SphericalHarmonics";
		var sr = function(r) {
			function Scene3D() {
				var r;
				_classCallCheck(this, Scene3D), (r = _possibleConstructorReturn(this, _getPrototypeOf(Scene3D).call(
						this)))._lightCount = 0, r._pointLights = new xt, r._spotLights = new xt, r
					._directionLights = new xt, r._alternateLights = new At, r._lightmaps = [], r._skyRenderer =
					new we, r._input = new St, r._timer = t.ILaya.timer, r._time = 0, r._shCoefficients = new Array(
						7), r._ambientMode = e.AmbientMode.SolidColor, r._ambientSphericalHarmonics = new Et, r
					._ambientSphericalHarmonicsIntensity = 1, r._reflectionDecodeFormat = t.TextureDecodeFormat
					.Normal, r._reflectionIntensity = 1, r._collsionTestList = [], r._renders = new dt, r
					._opaqueQueue = new jt(!1), r._transparentQueue = new jt(!0), r._cameraPool = [], r
					._animatorPool = new dt, r._scriptPool = new Array, r._tempScriptPool = new Array, r
					._needClearScriptPool = !1, r._reflectionCubeHDRParams = new i, r._reflectionProbeManager =
					new or, r.currentCreationLayer = Math.pow(2, 0), r.enableLight = !0, r._key = new t.SubmitKey, r
					._pickIdToSprite = new Object, r._reflectionMode = 0, !w._config.isUseCannonPhysicsEngine && k
					._bullet ? r._physicsSimulation = new I(Scene3D.physicsSettings) : k._cannon && (r
						._cannonPhysicsSimulation = new t.CannonPhysicsSimulation(Scene3D.cannonPhysicsSettings)), r
					._shaderValues = new ne(null), r.enableFog = !1, r.fogStart = 300, r.fogRange = 1e3, r
					.fogColor = new o(.7, .7, .7), r.ambientColor = new o(.212, .227, .259), r.reflectionIntensity =
					1, r.reflection = Dt.blackTexture;
				for (var n = 0; n < 7; n++) r._shCoefficients[n] = new i;
				if (r._reflectionProbeManager.sceneReflectionCubeHDRParam = r._reflectionCubeHDRParams, r._scene =
					_assertThisInitialized(r), r._input.__init__(t.Render.canvas, _assertThisInitialized(r)),
					Scene3D.octreeCulling && (r._octree = new qt(Scene3D.octreeInitialSize, Scene3D
						.octreeInitialCenter, Scene3D.octreeMinNodeSize, Scene3D.octreeLooseness)), Tt
					.debugFrustumCulling) {
					r._debugTool = new Yt;
					var a = new It;
					a.renderQueue = nt.RENDERQUEUE_TRANSPARENT, a.alphaTest = !1, a.depthWrite = !1, a.cull = at
						.CULL_BACK, a.blend = at.BLEND_ENABLE_ALL, a.blendSrc = at.BLENDPARAM_SRC_ALPHA, a
						.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, a.depthTest = at.DEPTHTEST_LESS, r._debugTool
						.pixelLineRenderer.sharedMaterial = a
				}
				return r
			}
			return _inherits(Scene3D, r), _createClass(Scene3D, [{
				key: "_applySHCoefficients",
				value: function(e, t) {
					for (var r = this._shCoefficients, n = 0; n < 3; n++) {
						var i = r[n],
							a = r[n + 3];
						i.setValue(e.getCoefficient(n, 3) * t, e.getCoefficient(n, 1) * t, e
							.getCoefficient(n, 2) * t, (e.getCoefficient(n, 0) - e
								.getCoefficient(n, 6)) * t), a.setValue(e.getCoefficient(n, 4) *
							t, e.getCoefficient(n, 5) * t, 3 * e.getCoefficient(n, 6) * t, e
							.getCoefficient(n, 7) * t)
					}
					r[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e
						.getCoefficient(2, 8) * t, 1);
					var o = this._shaderValues;
					o.setVector(Scene3D.AMBIENTSHAR, r[0]), o.setVector(Scene3D.AMBIENTSHAG, r[1]),
						o.setVector(Scene3D.AMBIENTSHAB, r[2]), o.setVector(Scene3D.AMBIENTSHBR, r[
							3]), o.setVector(Scene3D.AMBIENTSHBG, r[4]), o.setVector(Scene3D
							.AMBIENTSHBB, r[5]), o.setVector(Scene3D.AMBIENTSHC, r[6])
				}
			}, {
				key: "_update",
				value: function() {
					var e = this.timer._delta / 1e3;
					this._time += e, this._shaderValues.setNumber(Scene3D.TIME, this._time);
					var r = this._physicsSimulation;
					if (!k._enablePhysics || I.disableSimulation || w._config
						.isUseCannonPhysicsEngine || (r._updatePhysicsTransformFromRender(), v
							._addUpdateList = !1, r._simulate(e), r._updateCharacters(), v
							._addUpdateList = !0, r._updateCollisions(), r._eventScripts()), k
						._cannon && w._config.isUseCannonPhysicsEngine) {
						var n = this._cannonPhysicsSimulation;
						n._updatePhysicsTransformFromRender(), t.CannonPhysicsComponent
							._addUpdateList = !1, n._simulate(e), t.CannonPhysicsComponent
							._addUpdateList = !0, n._updateCollisions(), n._eventScripts()
					}
					this._input._update(), this._clearScript(), this._updateScript(), K._update(
							this), t.VideoTexture._update(), this._reflectionProbeManager
						._needUpdateAllRender ? this._reflectionProbeManager.updateAllRenderObjects(
							this._renders) : this._reflectionProbeManager.update(), this
						._lateUpdateScript()
				}
			}, {
				key: "_binarySearchIndexInCameraPool",
				value: function(e) {
					for (var t, r = 0, n = this._cameraPool.length - 1; r <= n;) {
						t = Math.floor((r + n) / 2);
						var i = this._cameraPool[t]._renderingOrder;
						if (i == e._renderingOrder) return t;
						i > e._renderingOrder ? n = t - 1 : r = t + 1
					}
					return r
				}
			}, {
				key: "_allotPickColorByID",
				value: function(e, t) {
					var r = Math.floor(e / 65025);
					e -= 255 * r * 255;
					var n = Math.floor(e / 255),
						i = e -= 255 * n;
					t.x = r / 255, t.y = n / 255, t.z = i / 255, t.w = 1
				}
			}, {
				key: "_searchIDByPickColor",
				value: function(e) {
					return 255 * e.x * 255 + 255 * e.y + e.z
				}
			}, {
				key: "onEnable",
				value: function() {
					this._input._onCanvasEvent(t.Render.canvas)
				}
			}, {
				key: "onDisable",
				value: function() {
					this._input._offCanvasEvent(t.Render.canvas)
				}
			}, {
				key: "_setCreateURL",
				value: function(e) {
					this._url = t.URL.formatURL(e)
				}
			}, {
				key: "_getGroup",
				value: function() {
					return this._group
				}
			}, {
				key: "_setGroup",
				value: function(e) {
					this._group = e
				}
			}, {
				key: "_clearScript",
				value: function() {
					if (this._needClearScriptPool) {
						for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
							var n = e[t];
							n && (n._indexInPool = this._tempScriptPool.length, this._tempScriptPool
								.push(n))
						}
						this._scriptPool = this._tempScriptPool, e.length = 0, this
							._tempScriptPool = e, this._needClearScriptPool = !1
					}
				}
			}, {
				key: "_updateScript",
				value: function() {
					for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
						var n = e[t];
						n && n.enabled && n.onUpdate()
					}
				}
			}, {
				key: "_lateUpdateScript",
				value: function() {
					for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
						var n = e[t];
						n && n.enabled && n.onLateUpdate()
					}
				}
			}, {
				key: "_onActive",
				value: function() {
					_get(_getPrototypeOf(Scene3D.prototype), "_onActive", this).call(this), t.ILaya
						.stage._scene3Ds.push(this)
				}
			}, {
				key: "_onInActive",
				value: function() {
					_get(_getPrototypeOf(Scene3D.prototype), "_onInActive", this).call(this);
					var e = t.ILaya.stage._scene3Ds;
					e.splice(e.indexOf(this), 1)
				}
			}, {
				key: "_prepareSceneToRender",
				value: function() {
					var e = this._shaderValues;
					if (w._config._multiLighting) {
						var t = Scene3D._lightTexture,
							r = Scene3D._lightPixles,
							n = t.width,
							i = 4 * n,
							a = 0,
							s = this._directionLights._length,
							l = this._directionLights._elements;
						if (s > 0) {
							var u = this._directionLights.getBrightestLight();
							this._mainDirectionLight = l[u], this._directionLights
								.normalLightOrdering(u);
							for (var c = 0; c < s; c++, a++) {
								var h = (v = l[c])._direction,
									_ = v._intensityColor,
									d = i * a;
								o.scale(v.color, v._intensity, _), v.transform.worldMatrix
									.getForward(h), o.normalize(h, h), r[d] = _.x, r[d + 1] = _.y,
									r[d + 2] = _.z, r[d + 4] = h.x, r[d + 5] = h.y, r[d + 6] = h.z,
									0 == c && (e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, _), e
										.setVector3(Scene3D.SUNLIGHTDIRECTION, h))
							}
							e.addDefine(Ue.SHADERDEFINE_DIRECTIONLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_DIRECTIONLIGHT);
						var f = this._pointLights._length;
						if (f > 0) {
							var m = this._pointLights._elements,
								p = this._pointLights.getBrightestLight();
							this._mainPointLight = m[p], this._pointLights.normalLightOrdering(p);
							for (c = 0; c < f; c++, a++) {
								var T = (R = m[c]).transform.position;
								_ = R._intensityColor, d = i * a;
								o.scale(R.color, R._intensity, _), r[d] = _.x, r[d + 1] = _.y, r[d +
										2] = _.z, r[d + 3] = R.range, r[d + 4] = T.x, r[d + 5] = T
									.y, r[d + 6] = T.z
							}
							e.addDefine(Ue.SHADERDEFINE_POINTLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_POINTLIGHT);
						var E = this._spotLights._length;
						if (E > 0) {
							var g = this._spotLights._elements,
								y = this._spotLights.getBrightestLight();
							this._mainSpotLight = g[y], this._spotLights.normalLightOrdering(y);
							for (c = 0; c < E; c++, a++) {
								var S = g[c];
								h = S._direction, T = S.transform.position, _ = S._intensityColor,
									d = i * a;
								o.scale(S.color, S._intensity, _), S.transform.worldMatrix
									.getForward(h), o.normalize(h, h), r[d] = _.x, r[d + 1] = _.y,
									r[d + 2] = _.z, r[d + 3] = S.range, r[d + 4] = T.x, r[d + 5] = T
									.y, r[d + 6] = T.z, r[d + 7] = S.spotAngle * Math.PI / 180, r[
										d + 8] = h.x, r[d + 9] = h.y, r[d + 10] = h.z
							}
							e.addDefine(Ue.SHADERDEFINE_SPOTLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_SPOTLIGHT);
						a > 0 && t.setSubPixels(0, 0, n, a, r, 0), e.setTexture(Scene3D.LIGHTBUFFER,
							t), e.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights
							._length), e.setTexture(Scene3D.CLUSTERBUFFER, ve.instance
							._clusterTexture)
					} else {
						if (this._directionLights._length > 0) {
							var v = this._directionLights._elements[0];
							this._mainDirectionLight = v, o.scale(v.color, v._intensity, v
									._intensityColor), v.transform.worldMatrix.getForward(v
									._direction), o.normalize(v._direction, v._direction), e
								.setVector3(Scene3D.LIGHTDIRCOLOR, v._intensityColor), e.setVector3(
									Scene3D.LIGHTDIRECTION, v._direction), e.setVector3(Scene3D
									.SUNLIGHTDIRCOLOR, v._intensityColor), e.setVector3(Scene3D
									.SUNLIGHTDIRECTION, v._direction), e.addDefine(Ue
									.SHADERDEFINE_DIRECTIONLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_DIRECTIONLIGHT);
						if (this._pointLights._length > 0) {
							var R = this._pointLights._elements[0];
							this._mainPointLight = R, o.scale(R.color, R._intensity, R
								._intensityColor), e.setVector3(Scene3D.POINTLIGHTCOLOR, R
								._intensityColor), e.setVector3(Scene3D.POINTLIGHTPOS, R
								.transform.position), e.setNumber(Scene3D.POINTLIGHTRANGE, R
								.range), e.addDefine(Ue.SHADERDEFINE_POINTLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_POINTLIGHT);
						if (this._spotLights._length > 0) {
							var C = this._spotLights._elements[0];
							this._mainSpotLight = C, o.scale(C.color, C._intensity, C
									._intensityColor), e.setVector3(Scene3D.SPOTLIGHTCOLOR, C
									._intensityColor), e.setVector3(Scene3D.SPOTLIGHTPOS, C
									.transform.position), C.transform.worldMatrix.getForward(C
									._direction), o.normalize(C._direction, C._direction), e
								.setVector3(Scene3D.SPOTLIGHTDIRECTION, C._direction), e.setNumber(
									Scene3D.SPOTLIGHTRANGE, C.range), e.setNumber(Scene3D
									.SPOTLIGHTSPOTANGLE, C.spotAngle * Math.PI / 180), e.addDefine(
									Ue.SHADERDEFINE_SPOTLIGHT)
						} else e.removeDefine(Ue.SHADERDEFINE_SPOTLIGHT)
					}
				}
			}, {
				key: "_addScript",
				value: function(e) {
					var t = this._scriptPool;
					e._indexInPool = t.length, t.push(e)
				}
			}, {
				key: "_removeScript",
				value: function(e) {
					this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this
						._needClearScriptPool = !0
				}
			}, {
				key: "_preRenderScript",
				value: function() {
					for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
						var n = e[t];
						n && n.enabled && n.onPreRender()
					}
				}
			}, {
				key: "_postRenderScript",
				value: function() {
					for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
						var n = e[t];
						n && n.enabled && n.onPostRender()
					}
				}
			}, {
				key: "_addCamera",
				value: function(e) {
					for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, n =
							this._cameraPool.length; t < n && this._cameraPool[t]._renderingOrder <=
						r;) t++;
					this._cameraPool.splice(t, 0, e)
				}
			}, {
				key: "_removeCamera",
				value: function(e) {
					this._cameraPool.splice(this._cameraPool.indexOf(e), 1)
				}
			}, {
				key: "_preCulling",
				value: function(e, t, r, n) {
					var i = Tt._cameraCullInfo;
					i.position = t._transform.position, i.cullingMask = t.cullingMask, i
						.boundFrustum = t.boundFrustum, i.useOcclusionCulling = t
						.useOcclusionCulling, Tt.renderObjectCulling(i, this, e, r, n, !1)
				}
			}, {
				key: "_clear",
				value: function(r, n) {
					var i, a, o, s = n.viewport,
						l = n.camera,
						u = l._getRenderTexture(),
						c = s.width,
						h = s.height;
					l._needInternalRenderTexture() ? (i = 0, a = 0) : (i = s.x, a = l
						._getCanvasHeight() - s.y - h), r.viewport(i, a, c, h);
					var _ = l.clearFlag;
					switch (_ !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this
						._skyRenderer._isAvailable() || (_ = e.CameraClearFlags.SolidColor), _) {
						case e.CameraClearFlags.SolidColor:
							var d = l.clearColor;
							if (r.enable(r.SCISSOR_TEST), r.scissor(i, a, c, h), d ? r.clearColor(d
									.x, d.y, d.z, d.w) : r.clearColor(0, 0, 0, 0), u) switch (o = r
								.COLOR_BUFFER_BIT, u.depthStencilFormat) {
								case t.RenderTextureDepthFormat.DEPTH_16:
									o |= r.DEPTH_BUFFER_BIT;
									break;
								case t.RenderTextureDepthFormat.STENCIL_8:
									o |= r.STENCIL_BUFFER_BIT;
									break;
								case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
									o |= r.DEPTH_BUFFER_BIT, o |= r.STENCIL_BUFFER_BIT
							} else o = r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT;
							t.WebGLContext.setDepthMask(r, !0), r.clear(o), r.disable(r
								.SCISSOR_TEST);
							break;
						case e.CameraClearFlags.Sky:
						case e.CameraClearFlags.DepthOnly:
							if (r.enable(r.SCISSOR_TEST), r.scissor(i, a, c, h), u) switch (u
								.depthStencilFormat) {
								case t.RenderTextureDepthFormat.DEPTH_16:
									o = r.DEPTH_BUFFER_BIT;
									break;
								case t.RenderTextureDepthFormat.STENCIL_8:
									o = r.STENCIL_BUFFER_BIT;
									break;
								case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
									o = r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT
							} else o = r.DEPTH_BUFFER_BIT;
							t.WebGLContext.setDepthMask(r, !0), r.clear(o), r.disable(r
								.SCISSOR_TEST);
							break;
						case e.CameraClearFlags.Nothing:
							break;
						default:
							throw new Error("Scene3D:camera clearFlag invalid.")
					}
				}
			}, {
				key: "_renderScene",
				value: function(t, r) {
					var n = t.camera;
					switch (r) {
						case Scene3D.SCENERENDERFLAG_RENDERQPAQUE:
							this._opaqueQueue._render(t);
							break;
						case Scene3D.SCENERENDERFLAG_SKYBOX:
							n.clearFlag === e.CameraClearFlags.Sky && (n.skyRenderer
							._isAvailable() ? n.skyRenderer._render(t) : this._skyRenderer
								._isAvailable() && this._skyRenderer._render(t));
							break;
						case Scene3D.SCENERENDERFLAG_RENDERTRANSPARENT:
							if (this._transparentQueue._render(t), Tt.debugFrustumCulling)
								for (var i = this._debugTool._render._renderElements, a = 0, o = i
										.length; a < o; a++) i[a]._update(this, t, null, null), i[a]
									._render(t)
					}
				}
			}, {
				key: "_parse",
				value: function(e, r) {
					var n = e.lightmaps;
					if (n) {
						for (var i = n.length, a = new Array(i), o = 0; o < i; o++) {
							var s = new Kt,
								l = n[o];
							l.path ? s.lightmapColor = t.Loader.getRes(l.path) : (s.lightmapColor =
								t.Loader.getRes(l.color.path), l.direction && (s
									.lightmapDirection = t.Loader.getRes(l.direction.path))), a[
								o] = s
						}
						this.lightmaps = a
					}
					var u = e.ambientColor;
					if (u) {
						var c = this.ambientColor;
						c.fromArray(u), this.ambientColor = c
					}
					var h = e.sky;
					if (h) switch (this._skyRenderer.material = t.Loader.getRes(h.material.path), h
						.mesh) {
						case "SkyBox":
							this._skyRenderer.mesh = ke.instance;
							break;
						case "SkyDome":
							this._skyRenderer.mesh = Mt.instance;
							break;
						default:
							this.skyRenderer.mesh = ke.instance
					}
					this.enableFog = e.enableFog, this.fogStart = e.fogStart, this.fogRange = e
						.fogRange;
					var _ = e.fogColor;
					if (_) {
						var d = this.fogColor;
						d.fromArray(_), this.fogColor = d
					}
					var f = e.ambientSphericalHarmonics;
					if (f) {
						var m = this.ambientSphericalHarmonics;
						for (o = 0; o < 3; o++) {
							var p = 9 * o;
							m.setCoefficients(o, f[p], f[p + 1], f[p + 2], f[p + 3], f[p + 4], f[p +
								5], f[p + 6], f[p + 7], f[p + 8])
						}
						this.ambientSphericalHarmonics = m
					}
					var T = e.reflection;
					null != T && (this.reflection = t.Loader.getRes(T));
					var E = e.reflectionDecodingFormat;
					null != E && (this.reflectionDecodingFormat = E);
					var g = e.ambientMode;
					null != g && (this.ambientMode = g);
					var y = e.ambientSphericalHarmonicsIntensity;
					null != y && (this.ambientSphericalHarmonicsIntensity = y);
					var S = e.reflectionIntensity;
					null != S && (this.reflectionIntensity = S)
				}
			}, {
				key: "_addRenderObject",
				value: function(e) {
					this._octree && e._supportOctree ? this._octree.add(e) : this._renders.add(e), e
						._addReflectionProbeUpdate()
				}
			}, {
				key: "_removeRenderObject",
				value: function(e) {
					this._octree && e._supportOctree ? this._octree.remove(e) : this._renders
						.remove(e)
				}
			}, {
				key: "_getRenderQueue",
				value: function(e) {
					return e <= 2500 ? this._opaqueQueue : this._transparentQueue
				}
			}, {
				key: "_clearRenderQueue",
				value: function() {
					this._opaqueQueue.clear(), this._transparentQueue.clear();
					for (var e = Ft._managers, t = 0, r = e.length; t < r; t++) e[t]._clear();
					var n = nr._managers;
					for (t = 0, r = n.length; t < r; t++) n[t]._clear()
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					if (!this.destroyed) {
						_get(_getPrototypeOf(Scene3D.prototype), "destroy", this).call(this, e),
							this._skyRenderer.destroy(), this._skyRenderer = null, this
							._directionLights = null, this._pointLights = null, this._spotLights =
							null, this._alternateLights = null, this._shaderValues = null, this
							._renders = null, this._cameraPool = null, this._octree = null, this
							._physicsSimulation && this._physicsSimulation._destroy(), this
							._reflection._removeReference(), this._reflection = null;
						var r = this._lightmaps;
						if (r)
							for (var n = 0, i = r.length; n < i; n++) {
								var a = r[n];
								a.lightmapColor && a.lightmapColor._removeReference(), a
									.lightmapDirection && a.lightmapDirection._removeReference()
							}
						this._lightmaps = null, this._reflectionProbeManager.destroy(), t.Loader
							.clearRes(this.url)
					}
				}
			}, {
				key: "render",
				value: function(e, r, n) {
					e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e
						.addRenderObject(this)
				}
			}, {
				key: "renderSubmit",
				value: function() {
					var e, r, n;
					t.LayaGL.instance;
					for (this._prepareSceneToRender(), e = 0, n = (r = this._cameraPool.length) -
						1; e < r; e++) {
						t.Render.supportWebGLPlusRendering && ne.setRuntimeValueMode(e == n);
						var i = this._cameraPool[e];
						i.enableRender && i.render()
					}
					return t.Context.set2DRenderConfig(), 1
				}
			}, {
				key: "getRenderType",
				value: function() {
					return 0
				}
			}, {
				key: "releaseRender",
				value: function() {}
			}, {
				key: "reUse",
				value: function(e, t) {
					return 0
				}
			}, {
				key: "setGlobalShaderValue",
				value: function(t, r, n) {
					var i = _e.propertyNameToID(t);
					switch (r) {
						case e.ShaderDataType.Int:
							this._shaderValues.setInt(i, n);
							break;
						case e.ShaderDataType.Number:
							this._shaderValues.setNumber(i, n);
							break;
						case e.ShaderDataType.Bool:
							this._shaderValues.setBool(i, n);
							break;
						case e.ShaderDataType.Matrix4x4:
							this._shaderValues.setMatrix4x4(i, n);
							break;
						case e.ShaderDataType.Quaternion:
							this._shaderValues.setQuaternion(i, n);
							break;
						case e.ShaderDataType.Texture:
							this._shaderValues.setTexture(i, n);
							break;
						case e.ShaderDataType.Vector:
							this._shaderValues.setVector(i, n);
							break;
						case e.ShaderDataType.Vector2:
							this._shaderValues.setVector2(i, n);
							break;
						case e.ShaderDataType.Vector3:
							this._shaderValues.setVector3(i, n);
							break;
						case e.ShaderDataType.Buffer:
							this._shaderValues.setBuffer(i, n)
					}
				}
			}, {
				key: "setlightmaps",
				value: function(e) {
					for (var t = this._lightmaps, r = 0, n = t.length; r < n; r++) t[r]
						.lightmapColor._removeReference();
					if (!e) throw new Error("Scene3D: value value can't be null.");
					var i = e.length;
					for (t.length = i, r = 0; r < i; r++) {
						var a = e[r];
						a._addReference(), t[r] || (t[r] = new Kt), t[r].lightmapColor = a
					}
				}
			}, {
				key: "getlightmaps",
				value: function() {
					for (var e = new Array(this._lightmaps.length), t = 0; t < this._lightmaps
						.length; t++) e[t] = this._lightmaps[t].lightmapColor;
					return e
				}
			}, {
				key: "url",
				get: function() {
					return this._url
				}
			}, {
				key: "enableFog",
				get: function() {
					return this._enableFog
				},
				set: function(e) {
					this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(
						Ue.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(Ue
						.SHADERDEFINE_FOG))
				}
			}, {
				key: "fogColor",
				get: function() {
					return this._shaderValues.getVector3(Scene3D.FOGCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector3(Scene3D.FOGCOLOR, e)
				}
			}, {
				key: "fogStart",
				get: function() {
					return this._shaderValues.getNumber(Scene3D.FOGSTART)
				},
				set: function(e) {
					this._shaderValues.setNumber(Scene3D.FOGSTART, e)
				}
			}, {
				key: "fogRange",
				get: function() {
					return this._shaderValues.getNumber(Scene3D.FOGRANGE)
				},
				set: function(e) {
					this._shaderValues.setNumber(Scene3D.FOGRANGE, e)
				}
			}, {
				key: "ambientMode",
				get: function() {
					return this._ambientMode
				},
				set: function(t) {
					if (this._ambientMode !== t) {
						switch (t) {
							case e.AmbientMode.SolidColor:
								this._shaderValues.removeDefine(Ue.SHADERDEFINE_GI_AMBIENT_SH);
								break;
							case e.AmbientMode.SphericalHarmonics:
								this._shaderValues.addDefine(Ue.SHADERDEFINE_GI_AMBIENT_SH);
								break;
							default:
								throw "Scene3D: unknown ambientMode."
						}
						this._ambientMode = t
					}
				}
			}, {
				key: "ambientColor",
				get: function() {
					return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, e)
				}
			}, {
				key: "ambientSphericalHarmonics",
				get: function() {
					return this._ambientSphericalHarmonics
				},
				set: function(e) {
					var t = e || Et._default;
					this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity,
						2.2)), this._ambientSphericalHarmonics != e && e.cloneTo(this
						._ambientSphericalHarmonics)
				}
			}, {
				key: "ambientSphericalHarmonicsIntensity",
				get: function() {
					return this._ambientSphericalHarmonicsIntensity
				},
				set: function(e) {
					if (e = Math.max(Math.min(e, 8), 0), this
						._ambientSphericalHarmonicsIntensity !== e) {
						var t = this._ambientSphericalHarmonics || Et._default;
						this._applySHCoefficients(t, Math.pow(e, 2.2)), this
							._ambientSphericalHarmonicsIntensity = e
					}
				}
			}, {
				key: "reflection",
				get: function() {
					return this._reflection
				},
				set: function(e) {
					this._reflection != e && (e._addReference(), this._reflectionProbeManager
						.sceneReflectionProbe = e, this._reflection = e || Dt.blackTexture, this
						._reflectionProbeManager._needUpdateAllRender = !0)
				}
			}, {
				key: "reflectionDecodingFormat",
				get: function() {
					return this._reflectionDecodeFormat
				},
				set: function(e) {
					this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this
						._reflectionIntensity, this._reflectionDecodeFormat == t
						.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
						this._reflectionDecodeFormat = e, this._reflectionProbeManager
						.sceneReflectionCubeHDRParam = this._reflectionCubeHDRParams)
				}
			}, {
				key: "reflectionIntensity",
				get: function() {
					return this._reflectionIntensity
				},
				set: function(e) {
					e = Math.max(Math.min(e, 1), 0), this._reflectionCubeHDRParams.x = e, this
						._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this
							._reflectionCubeHDRParams.x *= 5), this._reflectionIntensity = e, this
						._reflectionProbeManager.sceneReflectionCubeHDRParam = this
						._reflectionCubeHDRParams
				}
			}, {
				key: "skyRenderer",
				get: function() {
					return this._skyRenderer
				}
			}, {
				key: "physicsSimulation",
				get: function() {
					return this._physicsSimulation
				}
			}, {
				key: "cannonPhysicsSimulation",
				get: function() {
					return this._cannonPhysicsSimulation
				}
			}, {
				key: "timer",
				get: function() {
					return this._timer
				},
				set: function(e) {
					this._timer = e
				}
			}, {
				key: "input",
				get: function() {
					return this._input
				}
			}, {
				key: "lightmaps",
				get: function() {
					return this._lightmaps.slice()
				},
				set: function(e) {
					var t = this._lightmaps;
					if (t)
						for (var r = 0, n = t.length; r < n; r++) {
							(a = t[r]).lightmapColor._removeReference(), a.lightmapDirection
								._removeReference()
						}
					if (e) {
						var i = e.length;
						for (t.length = i, r = 0; r < i; r++) {
							var a;
							(a = e[r]).lightmapColor && a.lightmapColor._addReference(), a
								.lightmapDirection && a.lightmapDirection._addReference(), t[r] = a
						}
					} else t.length = 0
				}
			}, {
				key: "customReflection",
				get: function() {
					return this._reflection
				},
				set: function(e) {
					this._reflection != e && (e._addReference(), this._reflectionProbeManager
						.sceneReflectionProbe = e, this._reflection = e)
				}
			}, {
				key: "reflectionMode",
				get: function() {
					return this._reflectionMode
				},
				set: function(e) {
					this._reflectionMode = e
				}
			}], [{
				key: "__init__",
				value: function() {
					var r = w._config;
					if (r._multiLighting) {
						var n = r.maxLightCount,
							i = r.lightClusterCount;
						ve.instance = new ve(i.x, i.y, i.z, Math.min(r.maxLightCount, r
								._maxAreaLightCountPerClusterAverage)), Scene3D._lightTexture = P
							._createFloatTextureBuffer(4, n), Scene3D._lightTexture.lock = !0,
							Scene3D._lightPixles = new Float32Array(4 * n * 4)
					}
					Ue.SHADERDEFINE_FOG = _e.getDefineByName("FOG"), Ue
						.SHADERDEFINE_DIRECTIONLIGHT = _e.getDefineByName("DIRECTIONLIGHT"), Ue
						.SHADERDEFINE_POINTLIGHT = _e.getDefineByName("POINTLIGHT"), Ue
						.SHADERDEFINE_SPOTLIGHT = _e.getDefineByName("SPOTLIGHT"), Ue
						.SHADERDEFINE_SHADOW = _e.getDefineByName("SHADOW"), Ue
						.SHADERDEFINE_SHADOW_CASCADE = _e.getDefineByName("SHADOW_CASCADE"), Ue
						.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = _e.getDefineByName(
							"SHADOW_SOFT_SHADOW_LOW"), Ue.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = _e
						.getDefineByName("SHADOW_SOFT_SHADOW_HIGH"), Ue.SHADERDEFINE_GI_AMBIENT_SH =
						_e.getDefineByName("GI_AMBIENT_SH"), Ue.SHADERDEFINE_SHADOW_SPOT = _e
						.getDefineByName("SHADOW_SPOT"), Ue
						.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW = _e.getDefineByName(
							"SHADOW_SPOT_SOFT_SHADOW_LOW"), Ue
						.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH = _e.getDefineByName(
							"SHADOW_SPOT_SOFT_SHADOW_HIGH");
					var a = w._config,
						o = Scene3D._configDefineValues;
					switch (a._multiLighting || o.add(_e.SHADERDEFINE_LEGACYSINGALLIGHTING), t
						.LayaGL.layaGPUInstance._isWebGL2 ? o.add(_e
							.SHADERDEFINE_GRAPHICS_API_GLES3) : o.add(_e
							.SHADERDEFINE_GRAPHICS_API_GLES2), a.pbrRenderQuality) {
						case e.PBRRenderQuality.High:
							o.add(ct.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
							break;
						case e.PBRRenderQuality.Low:
							o.add(ct.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
							break;
						default:
							throw "Scene3D:unknown shader quality."
					}
					a.isUseCannonPhysicsEngine ? Scene3D.cannonPhysicsSettings = new t
						.CannonPhysicsSettings : Scene3D.physicsSettings = new Rt
				}
			}, {
				key: "load",
				value: function(e, r) {
					t.ILaya.loader.create(e, r, null, Scene3D.HIERARCHY)
				}
			}]), Scene3D
		}(t.Sprite);
		sr._shadowCasterPass = new rr, sr.HIERARCHY = "HIERARCHY", sr.octreeCulling = !1, sr.octreeInitialSize = 64, sr
			.octreeInitialCenter = new o(0, 0, 0), sr.octreeMinNodeSize = 2, sr.octreeLooseness = 1.25, sr
			.REFLECTIONMODE_SKYBOX = 0, sr.REFLECTIONMODE_CUSTOM = 1, sr.SCENERENDERFLAG_RENDERQPAQUE = 0, sr
			.SCENERENDERFLAG_SKYBOX = 1, sr.SCENERENDERFLAG_RENDERTRANSPARENT = 2, sr.FOGCOLOR = _e.propertyNameToID(
				"u_FogColor"), sr.FOGSTART = _e.propertyNameToID("u_FogStart"), sr.FOGRANGE = _e.propertyNameToID(
				"u_FogRange"), sr.DIRECTIONLIGHTCOUNT = _e.propertyNameToID("u_DirationLightCount"), sr.LIGHTBUFFER = _e
			.propertyNameToID("u_LightBuffer"), sr.CLUSTERBUFFER = _e.propertyNameToID("u_LightClusterBuffer"), sr
			.SUNLIGHTDIRECTION = _e.propertyNameToID("u_SunLight.direction"), sr.SUNLIGHTDIRCOLOR = _e.propertyNameToID(
				"u_SunLight.color"), sr.AMBIENTSHAR = _e.propertyNameToID("u_AmbientSHAr"), sr.AMBIENTSHAG = _e
			.propertyNameToID("u_AmbientSHAg"), sr.AMBIENTSHAB = _e.propertyNameToID("u_AmbientSHAb"), sr.AMBIENTSHBR =
			_e.propertyNameToID("u_AmbientSHBr"), sr.AMBIENTSHBG = _e.propertyNameToID("u_AmbientSHBg"), sr
			.AMBIENTSHBB = _e.propertyNameToID("u_AmbientSHBb"), sr.AMBIENTSHC = _e.propertyNameToID("u_AmbientSHC"), sr
			.LIGHTDIRECTION = _e.propertyNameToID("u_DirectionLight.direction"), sr.LIGHTDIRCOLOR = _e.propertyNameToID(
				"u_DirectionLight.color"), sr.POINTLIGHTPOS = _e.propertyNameToID("u_PointLight.position"), sr
			.POINTLIGHTRANGE = _e.propertyNameToID("u_PointLight.range"), sr.POINTLIGHTATTENUATION = _e
			.propertyNameToID("u_PointLight.attenuation"), sr.POINTLIGHTCOLOR = _e.propertyNameToID(
				"u_PointLight.color"), sr.SPOTLIGHTPOS = _e.propertyNameToID("u_SpotLight.position"), sr
			.SPOTLIGHTDIRECTION = _e.propertyNameToID("u_SpotLight.direction"), sr.SPOTLIGHTSPOTANGLE = _e
			.propertyNameToID("u_SpotLight.spot"), sr.SPOTLIGHTRANGE = _e.propertyNameToID("u_SpotLight.range"), sr
			.SPOTLIGHTCOLOR = _e.propertyNameToID("u_SpotLight.color"), sr.AMBIENTCOLOR = _e.propertyNameToID(
				"u_AmbientColor"), sr.TIME = _e.propertyNameToID("u_Time"), sr._configDefineValues = new ee;
		var lr = function(e) {
			function ShaderPass(e, t, r, n) {
				var i;
				for (var a in _classCallCheck(this, ShaderPass), (i = _possibleConstructorReturn(this,
							_getPrototypeOf(ShaderPass).call(this, t, r, null)))._cacheSharders = {}, i
						._cacheShaderHierarchy = 1, i._renderState = new at, i._validDefine = new ee, i._tags = {},
						i._owner = e, i._stateMap = n, i.defs) i._validDefine.add(_e.getDefineByName(a));
				return i
			}
			return _inherits(ShaderPass, e), _createClass(ShaderPass, [{
				key: "_compileToTree",
				value: function(e, r, n, i, a) {
					var o, s, l, u, c, h, _, d, f, m, p;
					for (f = n; f < r.length; f++)
						if (!((l = r[f]).length < 1) && 0 !== (h = l.indexOf("//"))) {
							if (h >= 0 && (l = l.substr(0, h)), o = d || new t.ShaderNode(i), d =
								null, o.text = l, o.noCompile = !0, (h = l.indexOf("#")) >= 0) {
								for (u = "#", p = h + 1, m = l.length; p < m; p++) {
									var T = l.charAt(p);
									if (" " === T || "\t" === T || "?" === T) break;
									u += T
								}
								switch (o.name = u, u) {
									case "#ifdef":
									case "#ifndef":
										if (o.src = l, o.noCompile = null != l.match(/[!&|()=<>]/),
											o.noCompile ? console.log("function():Boolean{return " +
												l.substr(h + o.name.length) + "}") : (_ = l.replace(
													/^\s*/, "").split(/\s+/), o.setCondition(_[1],
													"#ifdef" === u ? t.ShaderCompile.IFDEF_YES : t
													.ShaderCompile.IFDEF_ELSE), o.text = "//" + o
												.text), o.setParent(e), e = o, a)
											for (_ = l.substr(p).split(t.ShaderCompile
													._splitToWordExps3), p = 0; p < _.length; p++)(
												l = _[p]).length && (a[l] = !0);
										continue;
									case "#if":
									case "#elif":
										if (o.src = l, o.noCompile = !0, "#elif" == u && ((s = (e =
													e.parent).childs[e.childs.length - 1]).text = s
												.src, s.noCompile = !0, s.condition = null), o
											.setParent(e), e = o, a)
											for (_ = l.substr(p).split(t.ShaderCompile
													._splitToWordExps3), p = 0; p < _.length; p++)(
												l = _[p]).length && "defined" != l && (a[l] = !
												0);
										continue;
									case "#else":
										o.src = l, s = (e = e.parent).childs[e.childs.length - 1], o
											.noCompile = s.noCompile, o.noCompile || (o.condition =
												s.condition, o.conditionType = s.conditionType == t
												.ShaderCompile.IFDEF_YES ? t.ShaderCompile
												.IFDEF_ELSE : t.ShaderCompile.IFDEF_YES, o.text =
												"//" + o.text + " " + s.text + " " + o.conditionType
												), o.setParent(e), e = o;
										continue;
									case "#endif":
										s = (e = e.parent).childs[e.childs.length - 1], o
											.noCompile = s.noCompile, o.noCompile || (o.text =
												"//" + o.text), o.setParent(e);
										continue;
									case "#include":
										_ = t.ShaderCompile.splitToWords(l, null);
										var E = t.ShaderCompile.includes[_[1]];
										if (!E) throw "ShaderCompile error no this include file:" +
											_[1];
										if ((h = _[0].indexOf("?")) < 0) {
											o.setParent(e), l = E.getWith("with" == _[2] ? _[3] :
												null), this._compileToTree(o, l.split("\n"), 0,
												i, a), o.text = "";
											continue
										}
										o.setCondition(_[0].substr(h + 1), t.ShaderCompile
											.IFDEF_YES), o.text = E.getWith("with" == _[2] ? _[
											3] : null);
										break;
									case "#import":
										c = (_ = t.ShaderCompile.splitToWords(l, null))[1], i.push({
											node: o,
											file: t.ShaderCompile.includes[c],
											ofs: o.text.length
										});
										continue
								}
							} else {
								if ((s = e.childs[e.childs.length - 1]) && !s.name) {
									i.length > 0 && t.ShaderCompile.splitToWords(l, s), d = o, s
										.text += "\n" + l;
									continue
								}
								i.length > 0 && t.ShaderCompile.splitToWords(l, o)
							}
							o.setParent(e)
						}
				}
			}, {
				key: "_resizeCacheShaderMap",
				value: function(e, t, r) {
					var n = this._cacheShaderHierarchy - 1;
					if (t == n) {
						for (var i in e)
							for (var a = e[i], o = 0, s = r - n; o < s; o++) o == s - 1 ? e[0] = a :
								e = e[0 == o ? i : 0] = {};
						this._cacheShaderHierarchy = r
					} else
						for (var i in e) this._resizeCacheShaderMap(e[i], ++t, r)
				}
			}, {
				key: "_addDebugShaderVariantCollection",
				value: function(e, t, r) {
					var n = _e._debugShaderVariantInfo,
						i = this._owner,
						a = i._owner,
						o = e._mask;
					_e._getNamesByDefineData(e, t), r.length = o.length;
					for (var s = 0, l = o.length; s < l; s++) r[s] = o[s];
					n ? n.setValue(a, a._subShaders.indexOf(i), i._passes.indexOf(this), t) : _e
						._debugShaderVariantInfo = n = new ce(a, a._subShaders.indexOf(i), i._passes
							.indexOf(this), t), _e.debugShaderVariantCollection.add(n)
				}
			}, {
				key: "withCompile",
				value: function(e) {
					var r, n = ShaderPass._debugDefineString,
						i = ShaderPass._debugDefineMask;
					e._intersectionDefineDatas(this._validDefine), _e.debugMode && (r = e._length,
						this._addDebugShaderVariantCollection(e, n, i)), e.addDefineDatas(sr
						._configDefineValues);
					var a = this._cacheSharders,
						o = e._length;
					o > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(a, 0, o), this
						._cacheShaderHierarchy = o);
					for (var s = e._mask, l = e._length - 1, u = this._cacheShaderHierarchy - 1, c =
							0; c < u; c++) {
						var h = l < c ? 0 : s[c],
							_ = a[h];
						_ || (a[h] = _ = {}), a = _
					}
					var d = l < u ? 0 : s[u],
						f = a[d];
					if (f) return f;
					var m = ShaderPass._defineString;
					_e._getNamesByDefineData(e, m);
					var p, T, E = w._config,
						g = E.lightClusterCount,
						y = {},
						S = "";
					t.WebGL._isWebGL2 ? (p =
							"#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n",
							T =
							"#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n"
							) : (p = "", T =
							"#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"
							), S += "#define MAX_LIGHT_COUNT " + E.maxLightCount + "\n", S +=
						"#define MAX_LIGHT_COUNT_PER_CLUSTER " + E
						._maxAreaLightCountPerClusterAverage + "\n", S +=
						"#define CLUSTER_X_COUNT " + g.x + "\n", S += "#define CLUSTER_Y_COUNT " + g
						.y + "\n", S += "#define CLUSTER_Z_COUNT " + g.z + "\n", S +=
						"#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel +
						"\n";
					c = 0;
					for (var v = m.length; c < v; c++) {
						var R = m[c];
						S += "#define " + R + "\n", y[R] = !0
					}
					var C = this._VS.toscript(y, []),
						M = "";
					0 == C[0].indexOf("#version") && (M = C[0] + "\n", C.shift());
					var D = this._PS.toscript(y, []),
						x = "";
					0 == D[0].indexOf("#version") && (x = D[0] + "\n", D.shift());
					var A = _e.getAttributeMapByDefine(m, this._owner._attributeMap);
					if (f = new _t(M + p + S + C.join("\n"), x + T + S + D.join("\n"), A, this
							._owner._uniformMap || this._owner._owner._uniformMap, this), a[d] = f,
						_e.debugMode) {
						var I = "",
							L = "";
						for (c = 0, v = r; c < v; c++) L += c == v - 1 ? i[c] : i[c] + ",";
						for (c = 0, v = n.length; c < v; c++) I += c == v - 1 ? n[c] : n[c] + ",";
						console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this
							._owner._owner._name + " SubShaderIndex:" + this._owner._owner
							._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner
							._passes.indexOf(this) + " DefineMask:[" + L + "] DefineNames:[" +
							I + "]", "color:green")
					}
					return f
				}
			}, {
				key: "setTag",
				value: function(e, t) {
					t ? this._tags[e] = t : delete this._tags[e]
				}
			}, {
				key: "getTag",
				value: function(e) {
					return this._tags[e]
				}
			}, {
				key: "renderState",
				get: function() {
					return this._renderState
				}
			}]), ShaderPass
		}(t.ShaderCompile);
		lr._defineString = [], lr._debugDefineString = [], lr._debugDefineMask = [];
		var ur, cr = function() {
			function SubShader(e, t) {
				_classCallCheck(this, SubShader), this._flags = {}, this._passes = [], this._attributeMap = e, this
					._uniformMap = t
			}
			return _createClass(SubShader, [{
				key: "setFlag",
				value: function(e, t) {
					t ? this._flags[e] = t : delete this._flags[e]
				}
			}, {
				key: "getFlag",
				value: function(e) {
					return this._flags[e]
				}
			}, {
				key: "addShaderPass",
				value: function(e, t) {
					var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
						n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] :
						"Forward",
						i = new lr(this, e, t, r);
					return i._pipelineMode = n, this._passes.push(i), i
				}
			}]), SubShader
		}();
		(ur = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[ur.SpecularTextureAlpha = 0] =
		"SpecularTextureAlpha", ur[ur.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
		var hr = function(e) {
			function PBRSpecularMaterial() {
				var e;
				return _classCallCheck(this, PBRSpecularMaterial), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(PBRSpecularMaterial).call(this))).setShaderName("PBRSpecular"), e
					._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new i(.2, .2, .2, 1)), e
			}
			return _inherits(PBRSpecularMaterial, e), _createClass(PBRSpecularMaterial, [{
				key: "clone",
				value: function() {
					var e = new PBRSpecularMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "specularTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRSpecularMaterial
							.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(
							PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE), this
						._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, e)
				}
			}, {
				key: "specularColor",
				get: function() {
					return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, e)
				}
			}], [{
				key: "__init__",
				value: function() {
					PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE = _e.getDefineByName(
							"SPECULARGLOSSTEXTURE"), PBRSpecularMaterial
						.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = _e.getDefineByName(
							"SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
					var e = {
							a_Position: Ne.MESH_POSITION0,
							a_Normal: Ne.MESH_NORMAL0,
							a_Tangent0: Ne.MESH_TANGENT0,
							a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
							a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
							a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
							a_BoneIndices: Ne.MESH_BLENDINDICES0,
							a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
							a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
						},
						t = {
							u_Bones: _e.PERIOD_CUSTOM,
							u_MvpMatrix: _e.PERIOD_SPRITE,
							u_WorldMat: _e.PERIOD_SPRITE,
							u_LightmapScaleOffset: _e.PERIOD_SPRITE,
							u_LightMap: _e.PERIOD_SPRITE,
							u_LightMapDirection: _e.PERIOD_SPRITE,
							u_SimpleAnimatorTexture: _e.PERIOD_SPRITE,
							u_SimpleAnimatorParams: _e.PERIOD_SPRITE,
							u_SimpleAnimatorTextureSize: _e.PERIOD_SPRITE,
							u_ReflectCubeHDRParams: _e.PERIOD_SPRITE,
							u_ReflectTexture: _e.PERIOD_SPRITE,
							u_SpecCubeProbePosition: _e.PERIOD_SPRITE,
							u_SpecCubeBoxMax: _e.PERIOD_SPRITE,
							u_SpecCubeBoxMin: _e.PERIOD_SPRITE,
							u_CameraPos: _e.PERIOD_CAMERA,
							u_View: _e.PERIOD_CAMERA,
							u_ProjectionParams: _e.PERIOD_CAMERA,
							u_Viewport: _e.PERIOD_CAMERA,
							u_ViewProjection: _e.PERIOD_CAMERA,
							u_AlphaTestValue: _e.PERIOD_MATERIAL,
							u_AlbedoColor: _e.PERIOD_MATERIAL,
							u_EmissionColor: _e.PERIOD_MATERIAL,
							u_AlbedoTexture: _e.PERIOD_MATERIAL,
							u_NormalTexture: _e.PERIOD_MATERIAL,
							u_ParallaxTexture: _e.PERIOD_MATERIAL,
							u_OcclusionTexture: _e.PERIOD_MATERIAL,
							u_EmissionTexture: _e.PERIOD_MATERIAL,
							u_Smoothness: _e.PERIOD_MATERIAL,
							u_SmoothnessScale: _e.PERIOD_MATERIAL,
							u_occlusionStrength: _e.PERIOD_MATERIAL,
							u_NormalScale: _e.PERIOD_MATERIAL,
							u_ParallaxScale: _e.PERIOD_MATERIAL,
							u_TilingOffset: _e.PERIOD_MATERIAL,
							u_SpecGlossTexture: _e.PERIOD_MATERIAL,
							u_SpecularColor: _e.PERIOD_MATERIAL,
							u_AmbientColor: _e.PERIOD_SCENE,
							u_FogStart: _e.PERIOD_SCENE,
							u_FogRange: _e.PERIOD_SCENE,
							u_FogColor: _e.PERIOD_SCENE,
							u_DirationLightCount: _e.PERIOD_SCENE,
							u_LightBuffer: _e.PERIOD_SCENE,
							u_LightClusterBuffer: _e.PERIOD_SCENE,
							u_ShadowBias: _e.PERIOD_SCENE,
							u_ShadowLightDirection: _e.PERIOD_SCENE,
							u_ShadowMap: _e.PERIOD_SCENE,
							u_ShadowParams: _e.PERIOD_SCENE,
							u_ShadowSplitSpheres: _e.PERIOD_SCENE,
							u_ShadowMatrices: _e.PERIOD_SCENE,
							u_ShadowMapSize: _e.PERIOD_SCENE,
							u_SpotShadowMap: _e.PERIOD_SCENE,
							u_SpotViewProjectMatrix: _e.PERIOD_SCENE,
							u_ShadowLightPosition: _e.PERIOD_SCENE,
							u_AmbientSHAr: _e.PERIOD_SCENE,
							u_AmbientSHAg: _e.PERIOD_SCENE,
							u_AmbientSHAb: _e.PERIOD_SCENE,
							u_AmbientSHBr: _e.PERIOD_SCENE,
							u_AmbientSHBg: _e.PERIOD_SCENE,
							u_AmbientSHBb: _e.PERIOD_SCENE,
							u_AmbientSHC: _e.PERIOD_SCENE,
							"u_DirectionLight.direction": _e.PERIOD_SCENE,
							"u_DirectionLight.color": _e.PERIOD_SCENE,
							"u_PointLight.position": _e.PERIOD_SCENE,
							"u_PointLight.range": _e.PERIOD_SCENE,
							"u_PointLight.color": _e.PERIOD_SCENE,
							"u_SpotLight.position": _e.PERIOD_SCENE,
							"u_SpotLight.direction": _e.PERIOD_SCENE,
							"u_SpotLight.range": _e.PERIOD_SCENE,
							"u_SpotLight.spot": _e.PERIOD_SCENE,
							"u_SpotLight.color": _e.PERIOD_SCENE
						},
						r = {
							s_Cull: _e.RENDER_STATE_CULL,
							s_Blend: _e.RENDER_STATE_BLEND,
							s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
							s_BlendDst: _e.RENDER_STATE_BLEND_DST,
							s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
							s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
						},
						n = _e.add("PBRSpecular", e, t, !0, !0),
						i = new cr(e, t);
					n.addSubShader(i), i.addShaderPass(
						'#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
						'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}',
						r, "Forward"), i.addShaderPass(
						'#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}',
						'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}',
						r, "ShadowCaster")
				}
			}]), PBRSpecularMaterial
		}(ct);
		hr.SPECULARTEXTURE = _e.propertyNameToID("u_SpecGlossTexture"), hr.SPECULARCOLOR = _e.propertyNameToID(
			"u_SpecularColor");
		var _r;
		(_r = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[_r.MetallicGlossTextureAlpha = 0] =
		"MetallicGlossTextureAlpha", _r[_r.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
		var dr = function(e) {
			function PBRStandardMaterial() {
				var e;
				return _classCallCheck(this, PBRStandardMaterial), (e = _possibleConstructorReturn(this,
					_getPrototypeOf(PBRStandardMaterial).call(this)))._smoothnessSource = 0, e.setShaderName(
					"PBR"), e._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0), e
			}
			return _inherits(PBRStandardMaterial, e), _createClass(PBRStandardMaterial, [{
				key: "clone",
				value: function() {
					var e = new PBRStandardMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "metallicGlossTexture",
				get: function() {
					return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRStandardMaterial
							.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(
							PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE), this
						._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, e)
				}
			}, {
				key: "metallic",
				get: function() {
					return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC)
				},
				set: function(e) {
					this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0, Math.min(
						1, e)))
				}
			}, {
				key: "smoothnessSource",
				get: function() {
					return this._smoothnessSource
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(PBRStandardMaterial
							.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues
						.removeDefine(PBRStandardMaterial
							.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA), this
						._smoothnessSource = e
				}
			}], [{
				key: "__init__",
				value: function() {
					PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = _e.getDefineByName(
							"METALLICGLOSSTEXTURE"), PBRStandardMaterial
						.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = _e.getDefineByName(
							"SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
					var e = {
							a_Position: Ne.MESH_POSITION0,
							a_Normal: Ne.MESH_NORMAL0,
							a_Tangent0: Ne.MESH_TANGENT0,
							a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
							a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
							a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
							a_BoneIndices: Ne.MESH_BLENDINDICES0,
							a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
							a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
						},
						t = {
							u_Bones: _e.PERIOD_CUSTOM,
							u_MvpMatrix: _e.PERIOD_SPRITE,
							u_WorldMat: _e.PERIOD_SPRITE,
							u_LightmapScaleOffset: _e.PERIOD_SPRITE,
							u_LightMap: _e.PERIOD_SPRITE,
							u_LightMapDirection: _e.PERIOD_SPRITE,
							u_SimpleAnimatorTexture: _e.PERIOD_SPRITE,
							u_SimpleAnimatorParams: _e.PERIOD_SPRITE,
							u_SimpleAnimatorTextureSize: _e.PERIOD_SPRITE,
							u_ReflectCubeHDRParams: _e.PERIOD_SPRITE,
							u_ReflectTexture: _e.PERIOD_SPRITE,
							u_SpecCubeProbePosition: _e.PERIOD_SPRITE,
							u_SpecCubeBoxMax: _e.PERIOD_SPRITE,
							u_SpecCubeBoxMin: _e.PERIOD_SPRITE,
							u_CameraPos: _e.PERIOD_CAMERA,
							u_View: _e.PERIOD_CAMERA,
							u_ProjectionParams: _e.PERIOD_CAMERA,
							u_Viewport: _e.PERIOD_CAMERA,
							u_ViewProjection: _e.PERIOD_CAMERA,
							u_AlphaTestValue: _e.PERIOD_MATERIAL,
							u_AlbedoColor: _e.PERIOD_MATERIAL,
							u_EmissionColor: _e.PERIOD_MATERIAL,
							u_AlbedoTexture: _e.PERIOD_MATERIAL,
							u_NormalTexture: _e.PERIOD_MATERIAL,
							u_ParallaxTexture: _e.PERIOD_MATERIAL,
							u_OcclusionTexture: _e.PERIOD_MATERIAL,
							u_EmissionTexture: _e.PERIOD_MATERIAL,
							u_Smoothness: _e.PERIOD_MATERIAL,
							u_SmoothnessScale: _e.PERIOD_MATERIAL,
							u_occlusionStrength: _e.PERIOD_MATERIAL,
							u_NormalScale: _e.PERIOD_MATERIAL,
							u_ParallaxScale: _e.PERIOD_MATERIAL,
							u_TilingOffset: _e.PERIOD_MATERIAL,
							u_MetallicGlossTexture: _e.PERIOD_MATERIAL,
							u_Metallic: _e.PERIOD_MATERIAL,
							u_AmbientColor: _e.PERIOD_SCENE,
							u_FogStart: _e.PERIOD_SCENE,
							u_FogRange: _e.PERIOD_SCENE,
							u_FogColor: _e.PERIOD_SCENE,
							u_DirationLightCount: _e.PERIOD_SCENE,
							u_LightBuffer: _e.PERIOD_SCENE,
							u_LightClusterBuffer: _e.PERIOD_SCENE,
							u_ShadowBias: _e.PERIOD_SCENE,
							u_ShadowLightDirection: _e.PERIOD_SCENE,
							u_ShadowMap: _e.PERIOD_SCENE,
							u_ShadowParams: _e.PERIOD_SCENE,
							u_ShadowSplitSpheres: _e.PERIOD_SCENE,
							u_ShadowMatrices: _e.PERIOD_SCENE,
							u_ShadowMapSize: _e.PERIOD_SCENE,
							u_SpotShadowMap: _e.PERIOD_SCENE,
							u_SpotViewProjectMatrix: _e.PERIOD_SCENE,
							u_ShadowLightPosition: _e.PERIOD_SCENE,
							u_AmbientSHAr: _e.PERIOD_SCENE,
							u_AmbientSHAg: _e.PERIOD_SCENE,
							u_AmbientSHAb: _e.PERIOD_SCENE,
							u_AmbientSHBr: _e.PERIOD_SCENE,
							u_AmbientSHBg: _e.PERIOD_SCENE,
							u_AmbientSHBb: _e.PERIOD_SCENE,
							u_AmbientSHC: _e.PERIOD_SCENE,
							"u_DirectionLight.direction": _e.PERIOD_SCENE,
							"u_DirectionLight.color": _e.PERIOD_SCENE,
							"u_PointLight.position": _e.PERIOD_SCENE,
							"u_PointLight.range": _e.PERIOD_SCENE,
							"u_PointLight.color": _e.PERIOD_SCENE,
							"u_SpotLight.position": _e.PERIOD_SCENE,
							"u_SpotLight.direction": _e.PERIOD_SCENE,
							"u_SpotLight.range": _e.PERIOD_SCENE,
							"u_SpotLight.spot": _e.PERIOD_SCENE,
							"u_SpotLight.color": _e.PERIOD_SCENE
						},
						r = {
							s_Cull: _e.RENDER_STATE_CULL,
							s_Blend: _e.RENDER_STATE_BLEND,
							s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
							s_BlendDst: _e.RENDER_STATE_BLEND_DST,
							s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
							s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
						},
						n = _e.add("PBR", e, t, !0, !0),
						i = new cr(e, t);
					n.addSubShader(i), i.addShaderPass(
						'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n#include "Lighting.glsl";\r\n#include "LayaUtile.glsl"\r\n#include "Shadow.glsl"\r\n#include "PBRVSInput.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
						'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}',
						r, "Forward"), i.addShaderPass(
						'#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}',
						'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}',
						r, "ShadowCaster")
				}
			}]), PBRStandardMaterial
		}(ct);
		dr.METALLICGLOSSTEXTURE = _e.propertyNameToID("u_MetallicGlossTexture"), dr.METALLIC = _e.propertyNameToID(
			"u_Metallic");
		var fr = function(e) {
			function SkyBoxMaterial() {
				var e;
				return _classCallCheck(this, SkyBoxMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						SkyBoxMaterial).call(this))).setShaderName("SkyBox"), e.tintColor = new i(.5, .5, .5, .5), e
					.exposure = 1, e.rotation = 0, e
			}
			return _inherits(SkyBoxMaterial, e), _createClass(SkyBoxMaterial, [{
				key: "clone",
				value: function() {
					var e = new SkyBoxMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "tintColor",
				get: function() {
					return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, e)
				}
			}, {
				key: "exposure",
				get: function() {
					return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE)
				},
				set: function(e) {
					this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, e)
				}
			}, {
				key: "rotation",
				get: function() {
					return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION)
				},
				set: function(e) {
					this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, e)
				}
			}, {
				key: "textureCube",
				get: function() {
					return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE)
				},
				set: function(e) {
					this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {}
			}]), SkyBoxMaterial
		}(nt);
		fr.TINTCOLOR = _e.propertyNameToID("u_TintColor"), fr.EXPOSURE = _e.propertyNameToID("u_Exposure"), fr
			.ROTATION = _e.propertyNameToID("u_Rotation"), fr.TEXTURECUBE = _e.propertyNameToID("u_CubeTexture");
		var mr = function(e) {
			function SkyProceduralMaterial() {
				var e;
				return _classCallCheck(this, SkyProceduralMaterial), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(SkyProceduralMaterial).call(this))).setShaderName("SkyBoxProcedural"), e
					.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY, e.sunSize = .04, e.sunSizeConvergence = 5, e
					.atmosphereThickness = 1, e.skyTint = new i(.5, .5, .5, 1), e.groundTint = new i(.369, .349,
						.341, 1), e.exposure = 1.3, e
			}
			return _inherits(SkyProceduralMaterial, e), _createClass(SkyProceduralMaterial, [{
				key: "clone",
				value: function() {
					var e = new SkyProceduralMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "sunDisk",
				get: function() {
					return this._sunDisk
				},
				set: function(e) {
					switch (e) {
						case SkyProceduralMaterial.SUN_HIGH_QUALITY:
							this._shaderValues.removeDefine(SkyProceduralMaterial
								.SHADERDEFINE_SUN_SIMPLE), this._shaderValues.addDefine(
								SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
							break;
						case SkyProceduralMaterial.SUN_SIMPLE:
							this._shaderValues.removeDefine(SkyProceduralMaterial
								.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.addDefine(
								SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
							break;
						case SkyProceduralMaterial.SUN_NODE:
							this._shaderValues.removeDefine(SkyProceduralMaterial
									.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues
								.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
							break;
						default:
							throw "SkyBoxProceduralMaterial: unknown sun value."
					}
					this._sunDisk = e
				}
			}, {
				key: "sunSize",
				get: function() {
					return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE)
				},
				set: function(e) {
					e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(
						SkyProceduralMaterial.SUNSIZE, e)
				}
			}, {
				key: "sunSizeConvergence",
				get: function() {
					return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE)
				},
				set: function(e) {
					e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(
						SkyProceduralMaterial.SUNSIZECONVERGENCE, e)
				}
			}, {
				key: "atmosphereThickness",
				get: function() {
					return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS)
				},
				set: function(e) {
					e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(
						SkyProceduralMaterial.ATMOSPHERETHICKNESS, e)
				}
			}, {
				key: "skyTint",
				get: function() {
					return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT)
				},
				set: function(e) {
					this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, e)
				}
			}, {
				key: "groundTint",
				get: function() {
					return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT)
				},
				set: function(e) {
					this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, e)
				}
			}, {
				key: "exposure",
				get: function() {
					return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE)
				},
				set: function(e) {
					e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(
						SkyProceduralMaterial.EXPOSURE, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = _e.getDefineByName(
							"SUN_HIGH_QUALITY"), SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = _e
						.getDefineByName("SUN_SIMPLE")
				}
			}]), SkyProceduralMaterial
		}(nt);
		mr.SUN_NODE = 0, mr.SUN_SIMPLE = 1, mr.SUN_HIGH_QUALITY = 2, mr.SUNSIZE = _e.propertyNameToID("u_SunSize"), mr
			.SUNSIZECONVERGENCE = _e.propertyNameToID("u_SunSizeConvergence"), mr.ATMOSPHERETHICKNESS = _e
			.propertyNameToID("u_AtmosphereThickness"), mr.SKYTINT = _e.propertyNameToID("u_SkyTint"), mr.GROUNDTINT =
			_e.propertyNameToID("u_GroundTint"), mr.EXPOSURE = _e.propertyNameToID("u_Exposure");
		var pr = function(e) {
			function UnlitMaterial() {
				var e;
				return _classCallCheck(this, UnlitMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						UnlitMaterial).call(this)))._albedoColor = new i(1, 1, 1, 1), e._albedoIntensity = 1, e
					._enableVertexColor = !1, e.setShaderName("Unlit"), e._shaderValues.setVector(UnlitMaterial
						.ALBEDOCOLOR, new i(1, 1, 1, 1)), e.renderMode = UnlitMaterial.RENDERMODE_OPAQUE, e
			}
			return _inherits(UnlitMaterial, e), _createClass(UnlitMaterial, [{
				key: "clone",
				value: function() {
					var e = new UnlitMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "_ColorR",
				get: function() {
					return this._albedoColor.x
				},
				set: function(e) {
					this._albedoColor.x = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorG",
				get: function() {
					return this._albedoColor.y
				},
				set: function(e) {
					this._albedoColor.y = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorB",
				get: function() {
					return this._albedoColor.z
				},
				set: function(e) {
					this._albedoColor.z = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_ColorA",
				get: function() {
					return this._albedoColor.w
				},
				set: function(e) {
					this._albedoColor.w = e, this.albedoColor = this._albedoColor
				}
			}, {
				key: "_Color",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR)
				},
				set: function(e) {
					this.albedoColor = e
				}
			}, {
				key: "_AlbedoIntensity",
				get: function() {
					return this._albedoIntensity
				},
				set: function(e) {
					if (this._albedoIntensity !== e) {
						var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
						i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this
							._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t)
					}
				}
			}, {
				key: "_MainTex_STX",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x
				},
				set: function(e) {
					var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
					t.x = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STY",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y
				},
				set: function(e) {
					var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
					t.y = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STZ",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z
				},
				set: function(e) {
					var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
					t.z = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STW",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w
				},
				set: function(e) {
					var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
					t.w = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_ST",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET)
				},
				set: function(e) {
					this.tilingOffset = e
				}
			}, {
				key: "_Cutoff",
				get: function() {
					return this.alphaTestValue
				},
				set: function(e) {
					this.alphaTestValue = e
				}
			}, {
				key: "albedoColorR",
				get: function() {
					return this._ColorR
				},
				set: function(e) {
					this._ColorR = e
				}
			}, {
				key: "albedoColorG",
				get: function() {
					return this._ColorG
				},
				set: function(e) {
					this._ColorG = e
				}
			}, {
				key: "albedoColorB",
				get: function() {
					return this._ColorB
				},
				set: function(e) {
					this._ColorB = e
				}
			}, {
				key: "albedoColorA",
				get: function() {
					return this._ColorA
				},
				set: function(e) {
					this._ColorA = e
				}
			}, {
				key: "albedoColor",
				get: function() {
					return this._albedoColor
				},
				set: function(e) {
					var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
					i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues
						.setVector(UnlitMaterial.ALBEDOCOLOR, t)
				}
			}, {
				key: "albedoIntensity",
				get: function() {
					return this._albedoIntensity
				},
				set: function(e) {
					this._AlbedoIntensity = e
				}
			}, {
				key: "albedoTexture",
				get: function() {
					return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) :
						this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE),
						this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, e)
				}
			}, {
				key: "tilingOffsetX",
				get: function() {
					return this._MainTex_STX
				},
				set: function(e) {
					this._MainTex_STX = e
				}
			}, {
				key: "tilingOffsetY",
				get: function() {
					return this._MainTex_STY
				},
				set: function(e) {
					this._MainTex_STY = e
				}
			}, {
				key: "tilingOffsetZ",
				get: function() {
					return this._MainTex_STZ
				},
				set: function(e) {
					this._MainTex_STZ = e
				}
			}, {
				key: "tilingOffsetW",
				get: function() {
					return this._MainTex_STW
				},
				set: function(e) {
					this._MainTex_STW = e
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues
						.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues
						.setVector(UnlitMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "enableVertexColor",
				get: function() {
					return this._enableVertexColor
				},
				set: function(e) {
					this._enableVertexColor = e, e ? this._shaderValues.addDefine(UnlitMaterial
						.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(
						UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR)
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case UnlitMaterial.RENDERMODE_OPAQUE:
							this.alphaTest = !1, this.renderQueue = nt.RENDERQUEUE_OPAQUE, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS;
							break;
						case UnlitMaterial.RENDERMODE_CUTOUT:
							this.renderQueue = nt.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this
								.depthWrite = !0, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_DISABLE, this.depthTest = at.DEPTHTEST_LESS;
							break;
						case UnlitMaterial.RENDERMODE_TRANSPARENT:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_BACK, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS;
							break;
						default:
							throw new Error("UnlitMaterial : renderMode value error.")
					}
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(UnlitMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(UnlitMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(UnlitMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(UnlitMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(UnlitMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(UnlitMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = _e.getDefineByName("ALBEDOTEXTURE"),
						UnlitMaterial.SHADERDEFINE_TILINGOFFSET = _e.getDefineByName(
						"TILINGOFFSET"), UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = _e
						.getDefineByName("ENABLEVERTEXCOLOR")
				}
			}]), UnlitMaterial
		}(nt);
		pr.RENDERMODE_OPAQUE = 0, pr.RENDERMODE_CUTOUT = 1, pr.RENDERMODE_TRANSPARENT = 2, pr.RENDERMODE_ADDTIVE = 3, pr
			.ALBEDOTEXTURE = _e.propertyNameToID("u_AlbedoTexture"), pr.ALBEDOCOLOR = _e.propertyNameToID(
				"u_AlbedoColor"), pr.TILINGOFFSET = _e.propertyNameToID("u_TilingOffset"), pr.CULL = _e
			.propertyNameToID("s_Cull"), pr.BLEND = _e.propertyNameToID("s_Blend"), pr.BLEND_SRC = _e.propertyNameToID(
				"s_BlendSrc"), pr.BLEND_DST = _e.propertyNameToID("s_BlendDst"), pr.DEPTH_TEST = _e.propertyNameToID(
				"s_DepthTest"), pr.DEPTH_WRITE = _e.propertyNameToID("s_DepthWrite");
		var Tr = function(e) {
			function WaterPrimaryMaterial() {
				var e;
				return _classCallCheck(this, WaterPrimaryMaterial), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(WaterPrimaryMaterial).call(this))).setShaderName("WaterPrimary"), e
					._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new i(.172, .463, .435, 0)), e
					._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15), e._shaderValues.setVector(
						WaterPrimaryMaterial.WAVESPEED, new i(19, 9, -16, -7)), e
			}
			return _inherits(WaterPrimaryMaterial, e), _createClass(WaterPrimaryMaterial, [{
				key: "clone",
				value: function() {
					var e = new WaterPrimaryMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "horizonColor",
				get: function() {
					return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, e)
				}
			}, {
				key: "mainTexture",
				get: function() {
					return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(WaterPrimaryMaterial
						.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(
							WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE), this._shaderValues
						.setTexture(WaterPrimaryMaterial.MAINTEXTURE, e)
				}
			}, {
				key: "normalTexture",
				get: function() {
					return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(WaterPrimaryMaterial
							.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(
							WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE), this._shaderValues
						.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, e)
				}
			}, {
				key: "waveScale",
				get: function() {
					return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE)
				},
				set: function(e) {
					this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, e)
				}
			}, {
				key: "waveSpeed",
				get: function() {
					return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED)
				},
				set: function(e) {
					this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = _e.getDefineByName(
							"MAINTEXTURE"), WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = _e
						.getDefineByName("NORMALTEXTURE")
				}
			}]), WaterPrimaryMaterial
		}(nt);
		Tr.HORIZONCOLOR = _e.propertyNameToID("u_HorizonColor"), Tr.MAINTEXTURE = _e.propertyNameToID("u_MainTexture"),
			Tr.NORMALTEXTURE = _e.propertyNameToID("u_NormalTexture"), Tr.WAVESCALE = _e.propertyNameToID(
			"u_WaveScale"), Tr.WAVESPEED = _e.propertyNameToID("u_WaveSpeed");
		var Er = function MeshSprite3DShaderDeclaration() {
				_classCallCheck(this, MeshSprite3DShaderDeclaration)
			},
			gr = function(t) {
				function MeshRenderer(e) {
					var t;
					return _classCallCheck(this, MeshRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							MeshRenderer).call(this, e)))._revertStaticBatchDefineUV1 = !1, t
						._projectionViewWorldMatrix = new c, t
				}
				return _inherits(MeshRenderer, t), _createClass(MeshRenderer, [{
					key: "_createRenderElement",
					value: function() {
						return new Vt
					}
				}, {
					key: "_onMeshChange",
					value: function(e) {
						if (e) {
							var t = e.subMeshCount;
							this._renderElements.length = t;
							for (var r = 0; r < t; r++) {
								var n = this._renderElements[r];
								if (!n) {
									var i = this.sharedMaterials[r];
									(n = this._renderElements[r] = this._createRenderElement())
									.setTransform(this._owner._transform), n.render = this, n.material =
										i || ot.defaultMaterial
								}
								n.setGeometry(e.getSubMesh(r))
							}
						} else this._renderElements.length = 0;
						this._boundsChange = !0
					}
				}, {
					key: "_calculateBoundingBox",
					value: function() {
						var e = this._owner.meshFilter.sharedMesh;
						if (e) {
							var t = this._owner.transform.worldMatrix;
							e.bounds._tranform(t, this._bounds)
						}
					}
				}, {
					key: "_needRender",
					value: function(e, t) {
						return !e || e.intersects(this.bounds._getBoundBox())
					}
				}, {
					key: "_renderUpdate",
					value: function(t, r) {
						this._applyLightMapParams();
						var n = t.renderElement;
						switch (n.renderType) {
							case Ze.RENDERTYPE_NORMAL:
								this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, r.worldMatrix);
								break;
							case Ze.RENDERTYPE_STATICBATCH:
								r ? this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, r.worldMatrix) :
									this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, c.DEFAULT), this
									._shaderValues.hasDefine(Er.SHADERDEFINE_UV1) ? this
									._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(Er
										.SHADERDEFINE_UV1), this._revertStaticBatchDefineUV1 = !0), this
									._shaderValues.setVector(kt.LIGHTMAPSCALEOFFSET, Wt
										._defaultLightmapScaleOffset);
								break;
							case Ze.RENDERTYPE_VERTEXBATCH:
								this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, c.DEFAULT);
								break;
							case Ze.RENDERTYPE_INSTANCEBATCH:
								for (var i = Bt.instance.instanceWorldMatrixData, a = n
										.instanceBatchElementList, o = a.elements, s = a.length, l =
										0; l < s; l++) i.set(o[l]._transform.worldMatrix.elements, 16 *
									l);
								var u = Bt.instance.instanceWorldMatrixBuffer;
								u.orphanStorage(), u.setData(i.buffer, 0, 0, 16 * s * 4), this
									._shaderValues.addDefine(Er.SHADERDEFINE_GPU_INSTANCE)
						}
						this._probReflection && (this._reflectionMode == e.ReflectionProbeMode.off ? (
							this._shaderValues.removeDefine(Er
								.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
							.setVector(kt.REFLECTIONCUBE_HDR_PARAMS, zt
								.defaultTextureHDRDecodeValues), this._shaderValues.setTexture(
								kt.REFLECTIONTEXTURE, Dt.blackTexture)) : (this._probReflection
							.boxProjection ? (this._shaderValues.addDefine(Er
									.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
								.setVector3(kt.REFLECTIONCUBE_PROBEPOSITION, this
									._probReflection.probePosition), this._shaderValues
								.setVector3(kt.REFLECTIONCUBE_PROBEBOXMAX, this._probReflection
									.boundsMax), this._shaderValues.setVector3(kt
									.REFLECTIONCUBE_PROBEBOXMIN, this._probReflection.boundsMin)
								) : this._shaderValues.removeDefine(Er
								.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
							.setTexture(kt.REFLECTIONTEXTURE, this._probReflection
								.reflectionTexture), this._shaderValues.setVector(kt
								.REFLECTIONCUBE_HDR_PARAMS, this._probReflection
								.reflectionHDRParams)))
					}
				}, {
					key: "_renderUpdateWithCamera",
					value: function(e, t) {
						var r = e.projectionViewMatrix;
						if (r) {
							var n = e.renderElement;
							switch (n.renderType) {
								case Ze.RENDERTYPE_NORMAL:
								case Ze.RENDERTYPE_STATICBATCH:
								case Ze.RENDERTYPE_VERTEXBATCH:
									t ? (c.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
											this._shaderValues.setMatrix4x4(Ee.MVPMATRIX, this
												._projectionViewWorldMatrix)) : this._shaderValues
										.setMatrix4x4(Ee.MVPMATRIX, r);
									break;
								case Ze.RENDERTYPE_INSTANCEBATCH:
									for (var i = Bt.instance.instanceMVPMatrixData, a = n
											.instanceBatchElementList, o = a.elements, s = a.length, l =
											0; l < s; l++) {
										var u = o[l]._transform.worldMatrix;
										P.mulMatrixByArray(r.elements, 0, u.elements, 0, i, 16 * l)
									}
									var h = Bt.instance.instanceMVPMatrixBuffer;
									h.orphanStorage(), h.setData(i.buffer, 0, 0, 16 * s * 4)
							}
						}
					}
				}, {
					key: "_revertBatchRenderUpdate",
					value: function(e) {
						switch (e.renderElement.renderType) {
							case Ze.RENDERTYPE_STATICBATCH:
								this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(Er
									.SHADERDEFINE_UV1), this._shaderValues.setVector(kt
									.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
								break;
							case Ze.RENDERTYPE_INSTANCEBATCH:
								this._shaderValues.removeDefine(Er.SHADERDEFINE_GPU_INSTANCE)
						}
					}
				}, {
					key: "_destroy",
					value: function() {
						this._isPartOfStaticBatch && Ht.instance._removeRenderSprite(this._owner), _get(
							_getPrototypeOf(MeshRenderer.prototype), "_destroy", this).call(this)
					}
				}]), MeshRenderer
			}(Wt),
			yr = function() {
				function MeshFilter(e) {
					_classCallCheck(this, MeshFilter), this._owner = e
				}
				return _createClass(MeshFilter, [{
					key: "_getMeshDefine",
					value: function(e, t) {
						t.length = 0;
						for (var r = 0, n = e._subMeshes.length; r < n; r++)
							for (var i = e.getSubMesh(r)._vertexBuffer._vertexDeclaration
									._vertexElements, a = 0, o = i.length; a < o; a++) {
								switch (i[a]._elementUsage) {
									case Ne.MESH_COLOR0:
										t.push(Er.SHADERDEFINE_COLOR);
										break;
									case Ne.MESH_TEXTURECOORDINATE0:
										t.push(Er.SHADERDEFINE_UV0);
										break;
									case Ne.MESH_TEXTURECOORDINATE1:
										t.push(Er.SHADERDEFINE_UV1)
								}
							}
					}
				}, {
					key: "destroy",
					value: function() {
						this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(),
							this._sharedMesh = null)
					}
				}, {
					key: "sharedMesh",
					get: function() {
						return this._sharedMesh
					},
					set: function(e) {
						if (this._sharedMesh !== e) {
							var t = this._owner._render._shaderValues,
								r = this._sharedMesh;
							if (r) {
								r._removeReference(), this._getMeshDefine(r, MeshFilter
									._meshVerticeDefine);
								for (var n = 0, i = MeshFilter._meshVerticeDefine.length; n < i; n++) t
									.removeDefine(MeshFilter._meshVerticeDefine[n])
							}
							if (e) {
								e._addReference(), this._getMeshDefine(e, MeshFilter
								._meshVerticeDefine);
								for (n = 0, i = MeshFilter._meshVerticeDefine.length; n < i; n++) t
									.addDefine(MeshFilter._meshVerticeDefine[n])
							}
							this._owner._render._onMeshChange(e), this._sharedMesh = e
						}
					}
				}]), MeshFilter
			}();
		yr._meshVerticeDefine = [];
		var Sr = function(r) {
			function SubMeshDynamicBatch() {
				var r;
				_classCallCheck(this, SubMeshDynamicBatch), (r = _possibleConstructorReturn(this, _getPrototypeOf(
					SubMeshDynamicBatch).call(this)))._bufferState = new oe;
				var n = t.LayaGL.instance,
					i = Ne.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride *
					SubMeshDynamicBatch.maxIndicesCount;
				r._vertices = new Float32Array(i / 4), r._vertexBuffer = new te(i, n.DYNAMIC_DRAW), r._indices =
					new Int16Array(SubMeshDynamicBatch.maxIndicesCount), r._indexBuffer = new Oe(e.IndexFormat
						.UInt16, r._indices.length, n.DYNAMIC_DRAW);
				var a = r._vertexBuffer._byteLength + r._indexBuffer._byteLength;
				return t.Resource._addMemory(a, a), r
			}
			return _inherits(SubMeshDynamicBatch, r), _createClass(SubMeshDynamicBatch, [{
				key: "_getBatchVertices",
				value: function(e, t, r, n, i, a) {
					var o = e.vertexStride / 4,
						s = a._vertexBuffer.getFloat32Data(),
						l = (i.render.lightmapScaleOffset, i._dynamicMultiSubMesh),
						u = i._dynamicVertexCount;
					i._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l,
						u);
					for (var c = i._dynamicWorldPositions, h = i._dynamicWorldNormals, _ = a
							._indices, d = 0; d < u; d++) {
						var f = (l ? _[d] : d) * o,
							m = (d + r) * o,
							p = 3 * d,
							T = m + this._positionOffset;
						t[T] = c[p], t[T + 1] = c[p + 1], t[T + 2] = c[p + 2], -1 !== this
							._normalOffset && (t[T = m + this._normalOffset] = h[p], t[T + 1] = h[
								p + 1], t[T + 2] = h[p + 2]), -1 !== this._colorOffset && (T = m +
								this._colorOffset, p = f + this._colorOffset, t[T] = s[p], t[T +
								1] = s[p + 1], t[T + 2] = s[p + 2], t[T + 3] = s[p + 3]), -1 !==
							this._uv0Offset && (T = m + this._uv0Offset, p = f + this._uv0Offset, t[
								T] = s[p], t[T + 1] = s[p + 1]), -1 !== this._sTangentOffset && (T =
								m + this._sTangentOffset, p = f + this._sTangentOffset, t[T] = s[p],
								t[T + 1] = s[p + 1], t[T + 2] = s[p + 2], t[T + 3] = s[p + 3], T =
								m + this._sTangentOffset, p = f + this._sTangentOffset, t[T] = s[p],
								t[T + 1] = s[p + 1], t[T + 2] = s[p + 2], t[T + 3] = s[p + 3])
					}
				}
			}, {
				key: "_getBatchIndices",
				value: function(e, t, r, n, i, a) {
					var o, s, l, u = i._indices,
						c = n._isFrontFaceInvert;
					if (a)
						if (c)
							for (o = 0, s = u.length; o < s; o += 3) {
								var h = r + o;
								e[l = t + o] = h, e[l + 1] = h + 2, e[l + 2] = h + 1
							} else
								for (o = 0, s = u.length; o < s; o += 3) h = r + o, e[l = t + o] =
									h, e[l + 1] = h + 1, e[l + 2] = h + 2;
						else if (c)
						for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = r + u[o], e[l + 1] =
							r + u[o + 2], e[l + 2] = r + u[o + 1];
					else
						for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = r + u[o], e[l + 1] =
							r + u[o + 1], e[l + 2] = r + u[o + 2]
				}
			}, {
				key: "_flush",
				value: function(e, r) {
					var n = t.LayaGL.instance;
					this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState
						.vertexDeclaration.vertexStride), this._indexBuffer.setData(this
						._indices, 0, 0, r), n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0)
				}
			}, {
				key: "_prepareRender",
				value: function(e) {
					var t = e.renderElement.vertexBatchVertexDeclaration;
					this._bufferState = l.MeshRenderDynamicBatchManager.instance._getBufferState(t),
						this._positionOffset = t.getVertexElementByUsage(Ne.MESH_POSITION0)
						._offset / 4;
					var r = t.getVertexElementByUsage(Ne.MESH_NORMAL0);
					this._normalOffset = r ? r._offset / 4 : -1;
					var n = t.getVertexElementByUsage(Ne.MESH_COLOR0);
					this._colorOffset = n ? n._offset / 4 : -1;
					var i = t.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0);
					this._uv0Offset = i ? i._offset / 4 : -1;
					var a = t.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE1);
					this._uv1Offset = a ? a._offset / 4 : -1;
					var o = t.getVertexElementByUsage(Ne.MESH_TANGENT0);
					return this._sTangentOffset = o ? o._offset / 4 : -1, !0
				}
			}, {
				key: "_render",
				value: function(e) {
					this._bufferState.bind();
					for (var r = e.renderElement, n = r.vertexBatchVertexDeclaration, i = r
							.vertexBatchElementList, a = 0, o = 0, s = (n.vertexStride, 0), l = i
							.length, u = i.elements, c = 0; c < l; c++) {
						var h = u[c],
							_ = h._geometry,
							d = _._indexCount;
						o + d > SubMeshDynamicBatch.maxIndicesCount && (this._flush(a, o), s++, t
							.Stat.trianglesFaces += o / 3, a = o = 0);
						var f = h._transform;
						this._getBatchVertices(n, this._vertices, a, f, h, _), this
							._getBatchIndices(this._indices, o, a, f, _, h._dynamicMultiSubMesh),
							a += h._dynamicVertexCount, o += d
					}
					this._flush(a, o), s++, t.Stat.renderBatches += s, t.Stat.savedRenderBatches +=
						l - s, t.Stat.trianglesFaces += o / 3
				}
			}], [{
				key: "__init__",
				value: function() {
					SubMeshDynamicBatch.instance = new SubMeshDynamicBatch
				}
			}]), SubMeshDynamicBatch
		}(Ot);
		Sr.maxAllowVertexCount = 10, Sr.maxAllowAttribueCount = 900, Sr.maxIndicesCount = 32e3;
		var vr = function(e) {
			function MeshRenderDynamicBatchManager() {
				var e;
				return _classCallCheck(this, MeshRenderDynamicBatchManager), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(MeshRenderDynamicBatchManager).call(this)))._instanceBatchOpaqueMarks = [],
					e._vertexBatchOpaqueMarks = [], e._cacheBufferStates = [], e._updateCountMark = 0, e
			}
			return _inherits(MeshRenderDynamicBatchManager, e), _createClass(MeshRenderDynamicBatchManager, [{
				key: "getInstanceBatchOpaquaMark",
				value: function(e, t, r, n) {
					var i = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this
							._instanceBatchOpaqueMarks[e ? 0 : 1] = []),
						a = i[t] || (i[t] = []),
						o = a[r] || (a[r] = []);
					return o[n ? 1 : 0] || (o[n ? 1 : 0] = new wt)
				}
			}, {
				key: "getVertexBatchOpaquaMark",
				value: function(e, t, r, n) {
					var i = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[
						e] = []),
						a = i[t ? 0 : 1] || (i[t ? 0 : 1] = []),
						o = a[r] || (a[r] = []);
					return o[n] || (o[n] = new wt)
				}
			}, {
				key: "_getBufferState",
				value: function(e) {
					var t = this._cacheBufferStates[e.id];
					if (!t) {
						var r = Sr.instance;
						(t = new oe).bind();
						var n = r._vertexBuffer;
						n.vertexDeclaration = e, t.applyVertexBuffer(n), t.applyIndexBuffer(r
							._indexBuffer), t.unBind(), this._cacheBufferStates[e.id] = t
					}
					return t
				}
			}, {
				key: "_getBatchRenderElementFromPool",
				value: function() {
					var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
					return e || (e = new Vt, this._batchRenderElementPool[this
							._batchRenderElementPoolIndex - 1] = e, e.vertexBatchElementList =
						new R, e.instanceBatchElementList = new R), e
				}
			}, {
				key: "_clear",
				value: function() {
					_get(_getPrototypeOf(MeshRenderDynamicBatchManager.prototype), "_clear", this)
						.call(this), this._updateCountMark++
				}
			}]), MeshRenderDynamicBatchManager
		}(nr);
		vr.instance = new vr;
		var Rr = function(e) {
				function MeshSprite3D() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					return _classCallCheck(this, MeshSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							MeshSprite3D).call(this, r)))._meshFilter = new yr(_assertThisInitialized(e)), e._render =
						new gr(_assertThisInitialized(e)), t && (e._meshFilter.sharedMesh = t), e
				}
				return _inherits(MeshSprite3D, e), _createClass(MeshSprite3D, [{
					key: "_parse",
					value: function(e, r) {
						_get(_getPrototypeOf(MeshSprite3D.prototype), "_parse", this).call(this, e, r);
						var n = this.meshRenderer,
							a = e.lightmapIndex;
						null != a && (n.lightmapIndex = a);
						var o = e.lightmapScaleOffset;
						o && (n.lightmapScaleOffset = new i(o[0], o[1], o[2], o[3])), null != e
							.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)),
							null != e.enableRender && (n.enable = e.enableRender), null != e
							.receiveShadows && (n.receiveShadow = e.receiveShadows), null != e
							.castShadow && (n.castShadow = e.castShadow);
						var s = e.materials;
						if (s) {
							var l = n.sharedMaterials,
								u = s.length;
							l.length = u;
							for (var c = 0; c < u; c++) l[c] = t.Loader.getRes(s[c].path);
							n.sharedMaterials = l
						}
					}
				}, {
					key: "_addToInitStaticBatchManager",
					value: function() {
						this.meshFilter.sharedMesh && Ht.instance._addBatchSprite(this)
					}
				}, {
					key: "_cloneTo",
					value: function(e, t, r) {
						var n = e;
						n._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
						var i = this._render,
							a = n._render;
						a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i
							.castShadow;
						var o = i.lightmapScaleOffset;
						o && (a.lightmapScaleOffset = o.clone()), a.lightmapIndex = i.lightmapIndex, a
							.receiveShadow = i.receiveShadow, a.sortingFudge = i.sortingFudge, _get(
								_getPrototypeOf(MeshSprite3D.prototype), "_cloneTo", this).call(this, e,
								t, r)
					}
				}, {
					key: "destroy",
					value: function() {
						var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
						this.destroyed || (_get(_getPrototypeOf(MeshSprite3D.prototype), "destroy",
							this).call(this, e), this._meshFilter.destroy())
					}
				}, {
					key: "_create",
					value: function() {
						return new MeshSprite3D
					}
				}, {
					key: "meshFilter",
					get: function() {
						return this._meshFilter
					}
				}, {
					key: "meshRenderer",
					get: function() {
						return this._render
					}
				}], [{
					key: "__init__",
					value: function() {
						Er.SHADERDEFINE_UV0 = _e.getDefineByName("UV"), Er.SHADERDEFINE_COLOR = _e
							.getDefineByName("COLOR"), Er.SHADERDEFINE_UV1 = _e.getDefineByName("UV1"),
							Er.SHADERDEFINE_GPU_INSTANCE = _e.getDefineByName("GPU_INSTANCE"), Er
							.SHADERDEFINE_SPECCUBE_BOX_PROJECTION = _e.getDefineByName(
								"SPECCUBE_BOX_PROJECTION"), Ft._registerManager(Ht.instance), nr
							._registerManager(vr.instance)
					}
				}]), MeshSprite3D
			}(kt),
			Cr = function GradientMode() {
				_classCallCheck(this, GradientMode)
			};
		Cr.Blend = 0, Cr.Fixed = 1;
		var Mr, Dr = function() {
				function Gradient(e, t) {
					_classCallCheck(this, Gradient), this._mode = 0, this._maxColorRGBKeysCount = 0, this
						._maxColorAlphaKeysCount = 0, this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this
						._alphaElements = null, this._rgbElements = null, this._maxColorRGBKeysCount = e, this
						._maxColorAlphaKeysCount = t, this._rgbElements = new Float32Array(4 * e), this._alphaElements =
						new Float32Array(2 * t)
				}
				return _createClass(Gradient, [{
					key: "addColorRGB",
					value: function(e, t) {
						if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
							var r = 4 * this._colorRGBKeysCount;
							this._rgbElements[r] = e, this._rgbElements[r + 1] = t.r, this._rgbElements[
									r + 2] = t.g, this._rgbElements[r + 3] = t.b, this
								._colorRGBKeysCount++
						} else console.warn("Gradient:warning:data count must lessEqual than " + this
							._maxColorRGBKeysCount)
					}
				}, {
					key: "addColorAlpha",
					value: function(e, t) {
						if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
							var r = 2 * this._colorAlphaKeysCount;
							this._alphaElements[r] = e, this._alphaElements[r + 1] = t, this
								._colorAlphaKeysCount++
						} else console.warn("Gradient:warning:data count must lessEqual than " + this
							._maxColorAlphaKeysCount)
					}
				}, {
					key: "updateColorRGB",
					value: function(e, t, r) {
						if (e < this._colorRGBKeysCount) {
							var n = 4 * e;
							this._rgbElements[n] = t, this._rgbElements[n + 1] = r.r, this._rgbElements[
								n + 2] = r.g, this._rgbElements[n + 3] = r.b
						} else console.warn(
							"Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this
							._colorRGBKeysCount)
					}
				}, {
					key: "updateColorAlpha",
					value: function(e, t, r) {
						if (e < this._colorAlphaKeysCount) {
							var n = 2 * e;
							this._alphaElements[n] = t, this._alphaElements[n + 1] = r
						} else console.warn(
							"Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this
							._colorAlphaKeysCount)
					}
				}, {
					key: "evaluateColorRGB",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
							n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
						e = Math.min(Math.max(e, 0), 1);
						var i = this._rgbElements,
							a = r;
						if (n)
							for (var o = a; o >= 0; o--) {
								var s = 4 * o;
								if (e === (d = i[s])) return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s +
									3], a;
								switch (this._mode) {
									case Cr.Blend:
										if (e > d) {
											if (e > (_ = i[s + 4]))
											throw "Gradient:wrong startSearchIndex.";
											var l = _ - d,
												u = _ - e,
												c = e - d;
											return t.r = (u * i[s + 1] + c * i[s + 5]) / l, t.g = (u *
												i[s + 2] + c * i[s + 6]) / l, t.b = (u * i[s + 3] +
												c * i[s + 7]) / l, a
										}
										a--;
										continue;
									case Cr.Fixed:
										if (e > d) {
											if (e > i[s + 4]) throw "Gradient:wrong startSearchIndex.";
											return t.r = i[s + 5], t.g = i[s + 6], t.b = i[s + 7], a
										}
										a--;
										continue;
									default:
										throw "Gradient:unknown mode."
								}
							} else {
								o = 0;
								for (var h = this._rgbElements.length; o < h; o++) {
									var _;
									if (e === (_ = i[s = 4 * o])) return t.r = i[s + 1], t.g = i[s + 2],
										t.b = i[s + 3], a;
									switch (this._mode) {
										case Cr.Blend:
											if (e < _) {
												var d;
												if (e < (d = i[s - 4]))
												throw "Gradient:wrong startSearchIndex.";
												l = _ - d, u = _ - e, c = e - d;
												return t.r = (u * i[s - 3] + c * i[s + 1]) / l, t.g = (
													u * i[s - 2] + c * i[s + 2]) / l, t.b = (u * i[
													s - 1] + c * i[s + 3]) / l, a
											}
											a++;
											continue;
										case Cr.Fixed:
											if (e < _) {
												if (e < i[s - 4])
												throw "Gradient:wrong startSearchIndex.";
												return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], a
											}
											a++;
											continue;
										default:
											throw "Gradient:unknown mode."
									}
								}
							}
						return a
					}
				}, {
					key: "evaluateColorAlpha",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
							n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
						e = Math.min(Math.max(e, 0), 1);
						var i = this._alphaElements,
							a = r;
						if (n)
							for (var o = a; o >= 0; o--) {
								if (e === (d = i[h = 2 * o])) return t.a = i[h + 1], a;
								switch (this._mode) {
									case Cr.Blend:
										if (e > d) {
											if (e > (_ = i[h + 2]))
											throw "Gradient:wrong startSearchIndex.";
											var s = _ - d,
												l = _ - e,
												u = e - d;
											return t.a = (l * i[h + 1] + u * i[h + 3]) / s, a
										}
										a--;
										continue;
									case Cr.Fixed:
										if (e > d) {
											if (e > i[h + 2]) throw "Gradient:wrong startSearchIndex.";
											return t.a = i[h + 3], a
										}
										a--;
										continue;
									default:
										throw "Gradient:unknown mode."
								}
							} else {
								o = a;
								for (var c = this._alphaElements.length; o < c; o++) {
									var h, _;
									if (e === (_ = i[h = 2 * o])) return t.a = i[h + 1], a;
									switch (this._mode) {
										case Cr.Blend:
											if (e < _) {
												var d;
												if (e < (d = i[h - 2]))
												throw "Gradient:wrong startSearchIndex.";
												s = _ - d, l = _ - e, u = e - d;
												return t.a = (l * i[h - 1] + u * i[h + 1]) / s, a
											}
											a++;
											continue;
										case Cr.Fixed:
											if (e < _) {
												if (e < i[h - 2])
												throw "Gradient:wrong startSearchIndex.";
												return t.a = i[h + 1], a
											}
											a++;
											continue;
										default:
											throw "Gradient:unknown mode."
									}
								}
							}
						return a
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t, r, n = e;
						n._colorAlphaKeysCount = this._colorAlphaKeysCount;
						var i = n._alphaElements;
						for (t = 0, r = this._alphaElements.length; t < r; t++) i[t] = this
							._alphaElements[t];
						n._colorRGBKeysCount = this._colorRGBKeysCount;
						var a = n._rgbElements;
						for (t = 0, r = this._rgbElements.length; t < r; t++) a[t] = this._rgbElements[
							t]
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
						return this.cloneTo(e), e
					}
				}, {
					key: "mode",
					get: function() {
						return this._mode
					},
					set: function(e) {
						this._mode = e
					}
				}, {
					key: "colorRGBKeysCount",
					get: function() {
						return this._colorRGBKeysCount
					}
				}, {
					key: "colorAlphaKeysCount",
					get: function() {
						return this._colorAlphaKeysCount
					}
				}, {
					key: "maxColorRGBKeysCount",
					get: function() {
						return this._maxColorRGBKeysCount
					}
				}, {
					key: "maxColorAlphaKeysCount",
					get: function() {
						return this._maxColorAlphaKeysCount
					}
				}]), Gradient
			}(),
			xr = function() {
				function Burst(e, t, r) {
					_classCallCheck(this, Burst), this._time = e, this._minCount = t, this._maxCount = r
				}
				return _createClass(Burst, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Burst(this._time, this._minCount, this._maxCount);
						return this.cloneTo(e), e
					}
				}, {
					key: "time",
					get: function() {
						return this._time
					}
				}, {
					key: "minCount",
					get: function() {
						return this._minCount
					}
				}, {
					key: "maxCount",
					get: function() {
						return this._maxCount
					}
				}]), Burst
			}(),
			Ar = function() {
				function GradientColor() {
					_classCallCheck(this, GradientColor), this._type = 0, this._constant = null, this._constantMin =
						null, this._constantMax = null, this._gradient = null, this._gradientMin = null, this
						._gradientMax = null
				}
				return _createClass(GradientColor, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin
							.cloneTo(t._constantMin), this._constantMax.cloneTo(t._constantMax), this
							._gradient.cloneTo(t._gradient), this._gradientMin.cloneTo(t._gradientMin),
							this._gradientMax.cloneTo(t._gradientMax)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientColor;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "constant",
					get: function() {
						return this._constant
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}, {
					key: "gradient",
					get: function() {
						return this._gradient
					}
				}, {
					key: "gradientMin",
					get: function() {
						return this._gradientMin
					}
				}, {
					key: "gradientMax",
					get: function() {
						return this._gradientMax
					}
				}], [{
					key: "createByConstant",
					value: function(e) {
						var t = new GradientColor;
						return t._type = 0, t._constant = e, t
					}
				}, {
					key: "createByGradient",
					value: function(e) {
						var t = new GradientColor;
						return t._type = 1, t._gradient = e, t
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function(e, t) {
						var r = new GradientColor;
						return r._type = 2, r._constantMin = e, r._constantMax = t, r
					}
				}, {
					key: "createByRandomTwoGradient",
					value: function(e, t) {
						var r = new GradientColor;
						return r._type = 3, r._gradientMin = e, r._gradientMax = t, r
					}
				}]), GradientColor
			}(),
			Ir = function() {
				function ColorOverLifetime(e) {
					_classCallCheck(this, ColorOverLifetime), this._color = e
				}
				return _createClass(ColorOverLifetime, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this._color.cloneTo(t._color), t.enable = this.enable
					}
				}, {
					key: "clone",
					value: function() {
						var e;
						switch (this._color.type) {
							case 0:
								e = Ar.createByConstant(this._color.constant.clone());
								break;
							case 1:
								e = Ar.createByGradient(this._color.gradient.clone());
								break;
							case 2:
								e = Ar.createByRandomTwoConstant(this._color.constantMin.clone(), this
									._color.constantMax.clone());
								break;
							case 3:
								e = Ar.createByRandomTwoGradient(this._color.gradientMin.clone(), this
									._color.gradientMax.clone())
						}
						var t = new ColorOverLifetime(e);
						return t.enable = this.enable, t
					}
				}, {
					key: "color",
					get: function() {
						return this._color
					}
				}]), ColorOverLifetime
			}(),
			Lr = function() {
				function FrameOverTime() {
					_classCallCheck(this, FrameOverTime), this._type = 0, this._constant = 0, this._overTime = null,
						this._constantMin = 0, this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null
				}
				return _createClass(FrameOverTime, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, t._constant = this._constant, this._overTime && this
							._overTime.cloneTo(t._overTime), t._constantMin = this._constantMin, t
							._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin
							.cloneTo(t._overTimeMin), this._overTimeMax && this._overTimeMax.cloneTo(t
								._overTimeMax)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new FrameOverTime;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "constant",
					get: function() {
						return this._constant
					}
				}, {
					key: "frameOverTimeData",
					get: function() {
						return this._overTime
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}, {
					key: "frameOverTimeDataMin",
					get: function() {
						return this._overTimeMin
					}
				}, {
					key: "frameOverTimeDataMax",
					get: function() {
						return this._overTimeMax
					}
				}], [{
					key: "createByConstant",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
							t = new FrameOverTime;
						return t._type = 0, t._constant = e, t
					}
				}, {
					key: "createByOverTime",
					value: function(e) {
						var t = new FrameOverTime;
						return t._type = 1, t._overTime = e, t
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							r = new FrameOverTime;
						return r._type = 2, r._constantMin = e, r._constantMax = t, r
					}
				}, {
					key: "createByRandomTwoOverTime",
					value: function(e, t) {
						var r = new FrameOverTime;
						return r._type = 3, r._overTimeMin = e, r._overTimeMax = t, r
					}
				}]), FrameOverTime
			}(),
			Pr = function() {
				function GradientAngularVelocity() {
					_classCallCheck(this, GradientAngularVelocity), this._type = 0, this._separateAxes = !1, this
						._constant = 0, this._constantSeparate = null, this._gradient = null, this._gradientX = null,
						this._gradientY = null, this._gradientZ = null, this._gradientW = null, this._constantMin = 0,
						this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, this
						._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax =
						null, this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, this
						._gradientZMax = null, this._gradientWMin = null, this._gradientWMax = null
				}
				return _createClass(GradientAngularVelocity, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this
							._constant, this._constantSeparate.cloneTo(t._constantSeparate), this
							._gradient.cloneTo(t._gradient), this._gradientX.cloneTo(t._gradientX), this
							._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), t
							._constantMin = this._constantMin, t._constantMax = this._constantMax, this
							._constantMinSeparate.cloneTo(t._constantMinSeparate), this
							._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin
							.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax), this
							._gradientXMin.cloneTo(t._gradientXMin), this._gradientXMax.cloneTo(t
								._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), this
							._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t
								._gradientZMin), this._gradientZMax.cloneTo(t._gradientZMax)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientAngularVelocity;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "separateAxes",
					get: function() {
						return this._separateAxes
					}
				}, {
					key: "constant",
					get: function() {
						return this._constant
					}
				}, {
					key: "constantSeparate",
					get: function() {
						return this._constantSeparate
					}
				}, {
					key: "gradient",
					get: function() {
						return this._gradient
					}
				}, {
					key: "gradientX",
					get: function() {
						return this._gradientX
					}
				}, {
					key: "gradientY",
					get: function() {
						return this._gradientY
					}
				}, {
					key: "gradientZ",
					get: function() {
						return this._gradientZ
					}
				}, {
					key: "gradientW",
					get: function() {
						return this._gradientW
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}, {
					key: "constantMinSeparate",
					get: function() {
						return this._constantMinSeparate
					}
				}, {
					key: "constantMaxSeparate",
					get: function() {
						return this._constantMaxSeparate
					}
				}, {
					key: "gradientMin",
					get: function() {
						return this._gradientMin
					}
				}, {
					key: "gradientMax",
					get: function() {
						return this._gradientMax
					}
				}, {
					key: "gradientXMin",
					get: function() {
						return this._gradientXMin
					}
				}, {
					key: "gradientXMax",
					get: function() {
						return this._gradientXMax
					}
				}, {
					key: "gradientYMin",
					get: function() {
						return this._gradientYMin
					}
				}, {
					key: "gradientYMax",
					get: function() {
						return this._gradientYMax
					}
				}, {
					key: "gradientZMin",
					get: function() {
						return this._gradientZMin
					}
				}, {
					key: "gradientZMax",
					get: function() {
						return this._gradientZMax
					}
				}, {
					key: "gradientWMin",
					get: function() {
						return this._gradientWMin
					}
				}, {
					key: "gradientWMax",
					get: function() {
						return this._gradientWMax
					}
				}], [{
					key: "createByConstant",
					value: function(e) {
						var t = new GradientAngularVelocity;
						return t._type = 0, t._separateAxes = !1, t._constant = e, t
					}
				}, {
					key: "createByConstantSeparate",
					value: function(e) {
						var t = new GradientAngularVelocity;
						return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t
					}
				}, {
					key: "createByGradient",
					value: function(e) {
						var t = new GradientAngularVelocity;
						return t._type = 1, t._separateAxes = !1, t._gradient = e, t
					}
				}, {
					key: "createByGradientSeparate",
					value: function(e, t, r) {
						var n = new GradientAngularVelocity;
						return n._type = 1, n._separateAxes = !0, n._gradientX = e, n._gradientY = t, n
							._gradientZ = r, n
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function(e, t) {
						var r = new GradientAngularVelocity;
						return r._type = 2, r._separateAxes = !1, r._constantMin = e, r._constantMax =
							t, r
					}
				}, {
					key: "createByRandomTwoConstantSeparate",
					value: function(e, t) {
						var r = new GradientAngularVelocity;
						return r._type = 2, r._separateAxes = !0, r._constantMinSeparate = e, r
							._constantMaxSeparate = t, r
					}
				}, {
					key: "createByRandomTwoGradient",
					value: function(e, t) {
						var r = new GradientAngularVelocity;
						return r._type = 3, r._separateAxes = !1, r._gradientMin = e, r._gradientMax =
							t, r
					}
				}, {
					key: "createByRandomTwoGradientSeparate",
					value: function(e, t, r, n, i, a, o, s) {
						var l = new GradientAngularVelocity;
						return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax =
							t, l._gradientYMin = r, l._gradientYMax = n, l._gradientZMin = i, l
							._gradientZMax = a, l._gradientWMin = o, l._gradientWMax = s, l
					}
				}]), GradientAngularVelocity
			}(),
			Or = function() {
				function GradientDataInt() {
					_classCallCheck(this, GradientDataInt), this._currentLength = 0, this._elements = new Float32Array(
						8)
				}
				return _createClass(GradientDataInt, [{
					key: "add",
					value: function(e, t) {
						this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
								console.log("Warning:the forth key is  be force set to 1.")), this
							._elements[this._currentLength++] = e, this._elements[this
								._currentLength++] = t) : console.log(
							"Warning:data count must lessEqual than 4")
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._currentLength = this._currentLength;
						for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] =
							this._elements[n]
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientDataInt;
						return this.cloneTo(e), e
					}
				}, {
					key: "gradientCount",
					get: function() {
						return this._currentLength / 2
					}
				}]), GradientDataInt
			}(),
			Nr = function() {
				function GradientDataNumber() {
					_classCallCheck(this, GradientDataNumber), this._currentLength = 0, this._elements =
						new Float32Array(8)
				}
				return _createClass(GradientDataNumber, [{
					key: "add",
					value: function(e, t) {
						this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
							console.log(
								"GradientDataNumber warning:the forth key is  be force set to 1."
								)), this._elements[this._currentLength++] = e, this._elements[
							this._currentLength++] = t) : console.log(
							"GradientDataNumber warning:data count must lessEqual than 4")
					}
				}, {
					key: "getKeyByIndex",
					value: function(e) {
						return this._elements[2 * e]
					}
				}, {
					key: "getValueByIndex",
					value: function(e) {
						return this._elements[2 * e + 1]
					}
				}, {
					key: "getAverageValue",
					value: function() {
						for (var e = 0, t = 0, r = 0, n = this._currentLength - 2; r < n; r += 2) {
							var i = this._elements[r + 1];
							i += this._elements[r + 3], e += i *= this._elements[r + 2] - this
								._elements[r], t++
						}
						return e / t
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._currentLength = this._currentLength;
						for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] =
							this._elements[n]
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientDataNumber;
						return this.cloneTo(e), e
					}
				}, {
					key: "gradientCount",
					get: function() {
						return this._currentLength / 2
					}
				}]), GradientDataNumber
			}(),
			br = function() {
				function GradientSize() {
					_classCallCheck(this, GradientSize), this._type = 0, this._separateAxes = !1, this._gradient = null,
						this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = 0,
						this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null, this
						._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax =
						null, this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null, this
						._gradientZMax = null
				}
				return _createClass(GradientSize, [{
					key: "getMaxSizeInGradient",
					value: function() {
						var e, t, r = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
							n = -Number.MAX_VALUE;
						switch (this._type) {
							case 0:
								if (this._separateAxes) {
									for (e = 0, t = this._gradientX.gradientCount; e < t; e++) n = Math
										.max(n, this._gradientX.getValueByIndex(e));
									for (e = 0, t = this._gradientY.gradientCount; e < t; e++) n = Math
										.max(n, this._gradientY.getValueByIndex(e));
									if (r)
										for (e = 0, t = this._gradientZ.gradientCount; e < t; e++) n =
											Math.max(n, this._gradientZ.getValueByIndex(e))
								} else
									for (e = 0, t = this._gradient.gradientCount; e < t; e++) n = Math
										.max(n, this._gradient.getValueByIndex(e));
								break;
							case 1:
								this._separateAxes ? (n = Math.max(this._constantMinSeparate.x, this
									._constantMaxSeparate.x), n = Math.max(n, this
									._constantMinSeparate.y), r && (n = n = Math.max(n, this
									._constantMaxSeparate.z))) : n = Math.max(this._constantMin,
									this._constantMax);
								break;
							case 2:
								if (this._separateAxes) {
									for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientXMin.getValueByIndex(e));
									for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientXMax.getValueByIndex(e));
									for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientYMin.getValueByIndex(e));
									for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientZMax.getValueByIndex(e));
									if (r) {
										for (e = 0, t = this._gradientZMin.gradientCount; e < t; e++)
											n = Math.max(n, this._gradientZMin.getValueByIndex(e));
										for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++)
											n = Math.max(n, this._gradientZMax.getValueByIndex(e))
									}
								} else {
									for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientMin.getValueByIndex(e));
									for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) n =
										Math.max(n, this._gradientMax.getValueByIndex(e))
								}
						}
						return n
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, t._separateAxes = this._separateAxes, this._gradient
							.cloneTo(t._gradient), this._gradientX.cloneTo(t._gradientX), this
							._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), t
							._constantMin = this._constantMin, t._constantMax = this._constantMax, this
							._constantMinSeparate.cloneTo(t._constantMinSeparate), this
							._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin
							.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax), this
							._gradientXMin.cloneTo(t._gradientXMin), this._gradientXMax.cloneTo(t
								._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), this
							._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t
								._gradientZMin), this._gradientZMax.cloneTo(t._gradientZMax)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientSize;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "separateAxes",
					get: function() {
						return this._separateAxes
					}
				}, {
					key: "gradient",
					get: function() {
						return this._gradient
					}
				}, {
					key: "gradientX",
					get: function() {
						return this._gradientX
					}
				}, {
					key: "gradientY",
					get: function() {
						return this._gradientY
					}
				}, {
					key: "gradientZ",
					get: function() {
						return this._gradientZ
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}, {
					key: "constantMinSeparate",
					get: function() {
						return this._constantMinSeparate
					}
				}, {
					key: "constantMaxSeparate",
					get: function() {
						return this._constantMaxSeparate
					}
				}, {
					key: "gradientMin",
					get: function() {
						return this._gradientMin
					}
				}, {
					key: "gradientMax",
					get: function() {
						return this._gradientMax
					}
				}, {
					key: "gradientXMin",
					get: function() {
						return this._gradientXMin
					}
				}, {
					key: "gradientXMax",
					get: function() {
						return this._gradientXMax
					}
				}, {
					key: "gradientYMin",
					get: function() {
						return this._gradientYMin
					}
				}, {
					key: "gradientYMax",
					get: function() {
						return this._gradientYMax
					}
				}, {
					key: "gradientZMin",
					get: function() {
						return this._gradientZMin
					}
				}, {
					key: "gradientZMax",
					get: function() {
						return this._gradientZMax
					}
				}], [{
					key: "createByGradient",
					value: function(e) {
						var t = new GradientSize;
						return t._type = 0, t._separateAxes = !1, t._gradient = e, t
					}
				}, {
					key: "createByGradientSeparate",
					value: function(e, t, r) {
						var n = new GradientSize;
						return n._type = 0, n._separateAxes = !0, n._gradientX = e, n._gradientY = t, n
							._gradientZ = r, n
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function(e, t) {
						var r = new GradientSize;
						return r._type = 1, r._separateAxes = !1, r._constantMin = e, r._constantMax =
							t, r
					}
				}, {
					key: "createByRandomTwoConstantSeparate",
					value: function(e, t) {
						var r = new GradientSize;
						return r._type = 1, r._separateAxes = !0, r._constantMinSeparate = e, r
							._constantMaxSeparate = t, r
					}
				}, {
					key: "createByRandomTwoGradient",
					value: function(e, t) {
						var r = new GradientSize;
						return r._type = 2, r._separateAxes = !1, r._gradientMin = e, r._gradientMax =
							t, r
					}
				}, {
					key: "createByRandomTwoGradientSeparate",
					value: function(e, t, r, n, i, a) {
						var o = new GradientSize;
						return o._type = 2, o._separateAxes = !0, o._gradientXMin = e, o._gradientXMax =
							t, o._gradientYMin = r, o._gradientYMax = n, o._gradientZMin = i, o
							._gradientZMax = a, o
					}
				}]), GradientSize
			}(),
			kr = function() {
				function GradientVelocity() {
					_classCallCheck(this, GradientVelocity), this._type = 0, this._constant = null, this._gradientX =
						null, this._gradientY = null, this._gradientZ = null, this._constantMin = null, this
						._constantMax = null, this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin =
						null, this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null
				}
				return _createClass(GradientVelocity, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX
							.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this
							._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t
							._constantMin), this._constantMax.cloneTo(t._constantMax), this
							._gradientXMin.cloneTo(t._gradientXMin), this._gradientXMax.cloneTo(t
								._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin), this
							._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t
								._gradientZMin), this._gradientZMax.cloneTo(t._gradientZMax)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientVelocity;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "constant",
					get: function() {
						return this._constant
					}
				}, {
					key: "gradientX",
					get: function() {
						return this._gradientX
					}
				}, {
					key: "gradientY",
					get: function() {
						return this._gradientY
					}
				}, {
					key: "gradientZ",
					get: function() {
						return this._gradientZ
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}, {
					key: "gradientXMin",
					get: function() {
						return this._gradientXMin
					}
				}, {
					key: "gradientXMax",
					get: function() {
						return this._gradientXMax
					}
				}, {
					key: "gradientYMin",
					get: function() {
						return this._gradientYMin
					}
				}, {
					key: "gradientYMax",
					get: function() {
						return this._gradientYMax
					}
				}, {
					key: "gradientZMin",
					get: function() {
						return this._gradientZMin
					}
				}, {
					key: "gradientZMax",
					get: function() {
						return this._gradientZMax
					}
				}], [{
					key: "createByConstant",
					value: function(e) {
						var t = new GradientVelocity;
						return t._type = 0, t._constant = e, t
					}
				}, {
					key: "createByGradient",
					value: function(e, t, r) {
						var n = new GradientVelocity;
						return n._type = 1, n._gradientX = e, n._gradientY = t, n._gradientZ = r, n
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function(e, t) {
						var r = new GradientVelocity;
						return r._type = 2, r._constantMin = e, r._constantMax = t, r
					}
				}, {
					key: "createByRandomTwoGradient",
					value: function(e, t, r, n, i, a) {
						var o = new GradientVelocity;
						return o._type = 3, o._gradientXMin = e, o._gradientXMax = t, o._gradientYMin =
							r, o._gradientYMax = n, o._gradientZMin = i, o._gradientZMax = a, o
					}
				}]), GradientVelocity
			}(),
			wr = function() {
				function RotationOverLifetime(e) {
					_classCallCheck(this, RotationOverLifetime), this._angularVelocity = e
				}
				return _createClass(RotationOverLifetime, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this._angularVelocity.cloneTo(t._angularVelocity), t.enable = this.enable
					}
				}, {
					key: "clone",
					value: function() {
						var e;
						switch (this._angularVelocity.type) {
							case 0:
								e = this._angularVelocity.separateAxes ? Pr.createByConstantSeparate(
										this._angularVelocity.constantSeparate.clone()) : Pr
									.createByConstant(this._angularVelocity.constant);
								break;
							case 1:
								e = this._angularVelocity.separateAxes ? Pr.createByGradientSeparate(
										this._angularVelocity.gradientX.clone(), this._angularVelocity
										.gradientY.clone(), this._angularVelocity.gradientZ.clone()) :
									Pr.createByGradient(this._angularVelocity.gradient.clone());
								break;
							case 2:
								e = this._angularVelocity.separateAxes ? Pr
									.createByRandomTwoConstantSeparate(this._angularVelocity
										.constantMinSeparate.clone(), this._angularVelocity
										.constantMaxSeparate.clone()) : Pr.createByRandomTwoConstant(
										this._angularVelocity.constantMin, this._angularVelocity
										.constantMax);
								break;
							case 3:
								e = this._angularVelocity.separateAxes ? Pr
									.createByRandomTwoGradientSeparate(this._angularVelocity
										.gradientXMin.clone(), this._angularVelocity.gradientYMin
										.clone(), this._angularVelocity.gradientZMin.clone(), this
										._angularVelocity.gradientWMin.clone(), this._angularVelocity
										.gradientXMax.clone(), this._angularVelocity.gradientYMax
										.clone(), this._angularVelocity.gradientZMax.clone(), this
										._angularVelocity.gradientWMax.clone()) : Pr
									.createByRandomTwoGradient(this._angularVelocity.gradientMin
									.clone(), this._angularVelocity.gradientMax.clone())
						}
						var t = new RotationOverLifetime(e);
						return t.enable = this.enable, t
					}
				}, {
					key: "angularVelocity",
					get: function() {
						return this._angularVelocity
					}
				}]), RotationOverLifetime
			}();
		(Mr = e.ParticleSystemShapeType || (e.ParticleSystemShapeType = {}))[Mr.Box = 0] = "Box", Mr[Mr.Circle = 1] =
			"Circle", Mr[Mr.Cone = 2] = "Cone", Mr[Mr.Hemisphere = 3] = "Hemisphere", Mr[Mr.Sphere = 4] = "Sphere";
		var Br = function() {
				function BaseShape() {
					_classCallCheck(this, BaseShape), this.enable = !0, this.randomDirection = 0
				}
				return _createClass(BaseShape, [{
					key: "_getShapeBoundBox",
					value: function(e) {
						throw new Error("BaseShape: must override it.")
					}
				}, {
					key: "_getSpeedBoundBox",
					value: function(e) {
						throw new Error("BaseShape: must override it.")
					}
				}, {
					key: "generatePositionAndDirection",
					value: function(e, t) {
						arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments
							.length > 3 && void 0 !== arguments[3] && arguments[3];
						throw new Error("BaseShape: must override it.")
					}
				}, {
					key: "_calculateProceduralBounds",
					value: function(e, t, r) {
						this._getShapeBoundBox(e);
						var n = e.min,
							i = e.max;
						o.multiply(n, t, n), o.multiply(i, t, i);
						var a = new Lt(new o, new o);
						this.randomDirection ? (a.min = new o(-1, -1, -1), a.max = new o(1, 1, 1)) :
							this._getSpeedBoundBox(a);
						var s = new Lt(new o, new o),
							l = s.min,
							u = s.max;
						o.scale(a.min, r.y, l), o.scale(a.max, r.y, u), o.add(e.min, l, l), o.add(e.max,
							u, u), o.min(e.min, l, e.min), o.max(e.max, l, e.max);
						var c = new Lt(new o, new o),
							h = c.min,
							_ = c.max;
						o.scale(a.min, r.x, h), o.scale(a.max, r.x, _), o.min(c.min, _, l), o.max(c.min,
							_, u), o.min(e.min, l, e.min), o.max(e.max, l, e.max)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						e.enable = this.enable
					}
				}, {
					key: "clone",
					value: function() {
						var e = new BaseShape;
						return this.cloneTo(e), e
					}
				}]), BaseShape
			}(),
			Vr = function() {
				function ShapeUtils() {
					_classCallCheck(this, ShapeUtils)
				}
				return _createClass(ShapeUtils, null, [{
					key: "_randomPointUnitArcCircle",
					value: function(e, t) {
						var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
						null;
						r = n ? n.getFloat() * e : Math.random() * e, t.x = Math.cos(r), t.y = Math.sin(
							r)
					}
				}, {
					key: "_randomPointInsideUnitArcCircle",
					value: function(e, t) {
						var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
						null;
						ShapeUtils._randomPointUnitArcCircle(e, t, n), r = n ? Math.pow(n.getFloat(),
							.5) : Math.pow(Math.random(), .5), t.x = t.x * r, t.y = t.y * r
					}
				}, {
					key: "_randomPointUnitCircle",
					value: function(e) {
						var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
						null;
						t = r ? r.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math
							.cos(t), e.y = Math.sin(t)
					}
				}, {
					key: "_randomPointInsideUnitCircle",
					value: function(e) {
						var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
						null;
						ShapeUtils._randomPointUnitCircle(e), t = r ? Math.pow(r.getFloat(), .5) : Math
							.pow(Math.random(), .5), e.x = e.x * t, e.y = e.y * t
					}
				}, {
					key: "_randomPointUnitSphere",
					value: function(e) {
						var t, r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
							null;
						n ? (t = e.z = 2 * n.getFloat() - 1, r = n.getFloat() * Math.PI * 2) : (t = e
							.z = 2 * Math.random() - 1, r = Math.random() * Math.PI * 2);
						var i = Math.sqrt(1 - t * t);
						e.x = i * Math.cos(r), e.y = i * Math.sin(r)
					}
				}, {
					key: "_randomPointInsideUnitSphere",
					value: function(e) {
						var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
						null;
						ShapeUtils._randomPointUnitSphere(e), t = r ? Math.pow(r.getFloat(), 1 / 3) :
							Math.pow(Math.random(), 1 / 3), e.x = e.x * t, e.y = e.y * t, e.z = e.z * t
					}
				}, {
					key: "_randomPointInsideHalfUnitBox",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() -
							.5) : (e.x = Math.random() - .5, e.y = Math.random() - .5, e.z = Math
								.random() - .5)
					}
				}]), ShapeUtils
			}(),
			Fr = function(t) {
				function BoxShape() {
					var t;
					return _classCallCheck(this, BoxShape), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							BoxShape).call(this))).shapeType = e.ParticleSystemShapeType.Box, t.x = 1, t.y = 1, t.z = 1,
						t
				}
				return _inherits(BoxShape, t), _createClass(BoxShape, [{
					key: "_getShapeBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
						var r = e.max;
						r.x = .5 * this.x, r.y = .5 * this.y, r.z = .5 * this.z
					}
				}, {
					key: "_getSpeedBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = 0, t.y = 0, t.z = 0;
						var r = e.max;
						r.x = 0, r.y = 1, r.z = 0
					}
				}, {
					key: "generatePositionAndDirection",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
						r ? (r.seed = n[16], Vr._randomPointInsideHalfUnitBox(e, r), n[16] = r.seed) :
							Vr._randomPointInsideHalfUnitBox(e), e.x = this.x * e.x, e.y = this.y * e.y,
							e.z = this.z * e.z, this.randomDirection ? r ? (r.seed = n[17], Vr
								._randomPointUnitSphere(t, r), n[17] = r.seed) : Vr
							._randomPointUnitSphere(t) : (t.x = 0, t.y = 0, t.z = 1)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(BoxShape.prototype), "cloneTo", this).call(this, e);
						var t = e;
						t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this
							.randomDirection
					}
				}, {
					key: "clone",
					value: function() {
						var e = new BoxShape;
						return this.cloneTo(e), e
					}
				}]), BoxShape
			}(Br),
			Ur = function(t) {
				function CircleShape() {
					var t;
					return _classCallCheck(this, CircleShape), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							CircleShape).call(this))).shapeType = e.ParticleSystemShapeType.Circle, t.radius = 1, t
						.arc = 2 * Math.PI, t.emitFromEdge = !1, t
				}
				return _inherits(CircleShape, t), _createClass(CircleShape, [{
					key: "_getShapeBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.z = -this.radius, t.y = 0;
						var r = e.max;
						r.x = r.z = this.radius, r.y = 0
					}
				}, {
					key: "_getSpeedBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.y = -1, t.z = 0;
						var r = e.max;
						r.x = r.y = 1, r.z = 0
					}
				}, {
					key: "generatePositionAndDirection",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
							i = CircleShape._tempPositionPoint;
						r ? (r.seed = n[16], this.emitFromEdge ? Vr._randomPointUnitArcCircle(this.arc,
									CircleShape._tempPositionPoint, r) : Vr
								._randomPointInsideUnitArcCircle(this.arc, CircleShape
									._tempPositionPoint, r), n[16] = r.seed) : this.emitFromEdge ? Vr
							._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : Vr
							._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint),
							e.x = -i.x, e.y = i.y, e.z = 0, o.scale(e, this.radius, e), this
							.randomDirection ? r ? (r.seed = n[17], Vr._randomPointUnitSphere(t, r), n[
								17] = r.seed) : Vr._randomPointUnitSphere(t) : e.cloneTo(t)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(CircleShape.prototype), "cloneTo", this).call(this, e);
						var t = e;
						t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t
							.randomDirection = this.randomDirection
					}
				}, {
					key: "clone",
					value: function() {
						var e = new CircleShape;
						return this.cloneTo(e), e
					}
				}]), CircleShape
			}(Br);
		Ur._tempPositionPoint = new n;
		var Gr = function(t) {
			function ConeShape() {
				var t;
				return _classCallCheck(this, ConeShape), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						ConeShape).call(this))).shapeType = e.ParticleSystemShapeType.Cone, t.angle = 25 / 180 *
					Math.PI, t.radius = 1, t.length = 5, t.emitType = 0, t
			}
			return _inherits(ConeShape, t), _createClass(ConeShape, [{
				key: "_getShapeBoundBox",
				value: function(e) {
					var t = this.radius + this.length * Math.sin(this.angle),
						r = this.length * Math.cos(this.angle),
						n = e.min;
					n.x = n.y = -t, n.z = 0;
					var i = e.max;
					i.x = i.y = t, i.z = r
				}
			}, {
				key: "_getSpeedBoundBox",
				value: function(e) {
					var t = Math.sin(this.angle),
						r = e.min;
					r.x = r.y = -t, r.z = 0;
					var n = e.max;
					n.x = n.y = t, n.z = 1
				}
			}, {
				key: "generatePositionAndDirection",
				value: function(e, t) {
					var r, n, i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[
						2] : null,
						s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
						l = ConeShape._tempPositionPoint,
						u = Math.cos(this.angle),
						c = Math.sin(this.angle);
					switch (this.emitType) {
						case 0:
							a ? (a.seed = s[16], Vr._randomPointInsideUnitCircle(ConeShape
									._tempPositionPoint, a), s[16] = a.seed) : Vr
								._randomPointInsideUnitCircle(ConeShape._tempPositionPoint), r = l
								.x, n = l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0,
								this.randomDirection ? (a ? (a.seed = s[17], Vr
										._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,
											a), s[17] = a.seed) : Vr._randomPointInsideUnitCircle(
										ConeShape._tempDirectionPoint), i = ConeShape
									._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = r *
									c, t.y = n * c), t.z = u;
							break;
						case 1:
							a ? (a.seed = s[16], Vr._randomPointUnitCircle(ConeShape
									._tempPositionPoint, a), s[16] = a.seed) : Vr
								._randomPointUnitCircle(ConeShape._tempPositionPoint), r = l.x, n =
								l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0, this
								.randomDirection ? (a ? (a.seed = s[17], Vr
										._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint,
											a), s[17] = a.seed) : Vr._randomPointInsideUnitCircle(
										ConeShape._tempDirectionPoint), i = ConeShape
									._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = r *
									c, t.y = n * c), t.z = u;
							break;
						case 2:
							a ? (a.seed = s[16], Vr._randomPointInsideUnitCircle(ConeShape
									._tempPositionPoint, a)) : Vr._randomPointInsideUnitCircle(
									ConeShape._tempPositionPoint), r = l.x, n = l.y, e.x = r * this
								.radius, e.y = n * this.radius, e.z = 0, t.x = r * c, t.y = n * c, t
								.z = u, o.normalize(t, t), a ? (o.scale(t, this.length * a
								.getFloat(), t), s[16] = a.seed) : o.scale(t, this.length * Math
									.random(), t), o.add(e, t, e), this.randomDirection && (a ? (a
									.seed = s[17], Vr._randomPointUnitSphere(t, a), s[17] = a
									.seed) : Vr._randomPointUnitSphere(t));
							break;
						case 3:
							a ? (a.seed = s[16], Vr._randomPointUnitCircle(ConeShape
									._tempPositionPoint, a)) : Vr._randomPointUnitCircle(ConeShape
									._tempPositionPoint), r = l.x, n = l.y, e.x = r * this.radius, e
								.y = n * this.radius, e.z = 0, t.x = r * c, t.y = n * c, t.z = u, o
								.normalize(t, t), a ? (o.scale(t, this.length * a.getFloat(), t), s[
									16] = a.seed) : o.scale(t, this.length * Math.random(), t), o
								.add(e, t, e), this.randomDirection && (a ? (a.seed = s[17], Vr
										._randomPointUnitSphere(t, a), s[17] = a.seed) : Vr
									._randomPointUnitSphere(t));
							break;
						default:
							throw new Error("ConeShape:emitType is invalid.")
					}
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					_get(_getPrototypeOf(ConeShape.prototype), "cloneTo", this).call(this, e);
					var t = e;
					t.angle = this.angle, t.radius = this.radius, t.length = this.length, t
						.emitType = this.emitType, t.randomDirection = this.randomDirection
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ConeShape;
					return this.cloneTo(e), e
				}
			}]), ConeShape
		}(Br);
		Gr._tempPositionPoint = new n, Gr._tempDirectionPoint = new n;
		var Hr = function(t) {
				function HemisphereShape() {
					var t;
					return _classCallCheck(this, HemisphereShape), (t = _possibleConstructorReturn(this,
							_getPrototypeOf(HemisphereShape).call(this))).shapeType = e.ParticleSystemShapeType
						.Hemisphere, t.radius = 1, t.emitFromShell = !1, t
				}
				return _inherits(HemisphereShape, t), _createClass(HemisphereShape, [{
					key: "_getShapeBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.y = t.z = -this.radius;
						var r = e.max;
						r.x = r.y = this.radius, r.z = 0
					}
				}, {
					key: "_getSpeedBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.y = -1, t.z = 0;
						var r = e.max;
						r.x = r.y = r.z = 1
					}
				}, {
					key: "generatePositionAndDirection",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
						r ? (r.seed = n[16], this.emitFromShell ? Vr._randomPointUnitSphere(e, r) : Vr
								._randomPointInsideUnitSphere(e, r), n[16] = r.seed) : this
							.emitFromShell ? Vr._randomPointUnitSphere(e) : Vr
							._randomPointInsideUnitSphere(e), o.scale(e, this.radius, e);
						var i = e.z;
						i < 0 && (e.z = -1 * i), this.randomDirection ? r ? (r.seed = n[17], Vr
								._randomPointUnitSphere(t, r), n[17] = r.seed) : Vr
							._randomPointUnitSphere(t) : e.cloneTo(t)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(HemisphereShape.prototype), "cloneTo", this).call(this, e);
						var t = e;
						t.radius = this.radius, t.emitFromShell = this.emitFromShell, t
							.randomDirection = this.randomDirection
					}
				}, {
					key: "clone",
					value: function() {
						var e = new HemisphereShape;
						return this.cloneTo(e), e
					}
				}]), HemisphereShape
			}(Br),
			zr = function(t) {
				function SphereShape() {
					var t;
					return _classCallCheck(this, SphereShape), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							SphereShape).call(this))).shapeType = e.ParticleSystemShapeType.Sphere, t.radius = 1, t
						.emitFromShell = !1, t
				}
				return _inherits(SphereShape, t), _createClass(SphereShape, [{
					key: "_getShapeBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.y = t.z = -this.radius;
						var r = e.max;
						r.x = r.y = r.z = this.radius
					}
				}, {
					key: "_getSpeedBoundBox",
					value: function(e) {
						var t = e.min;
						t.x = t.y = t.z = -1;
						var r = e.max;
						r.x = r.y = r.z = 1
					}
				}, {
					key: "generatePositionAndDirection",
					value: function(e, t) {
						var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
							n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
						r ? (r.seed = n[16], this.emitFromShell ? Vr._randomPointUnitSphere(e, r) : Vr
								._randomPointInsideUnitSphere(e, r), n[16] = r.seed) : this
							.emitFromShell ? Vr._randomPointUnitSphere(e) : Vr
							._randomPointInsideUnitSphere(e), o.scale(e, this.radius, e), this
							.randomDirection ? r ? (r.seed = n[17], Vr._randomPointUnitSphere(t, r), n[
								17] = r.seed) : Vr._randomPointUnitSphere(t) : e.cloneTo(t)
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						_get(_getPrototypeOf(SphereShape.prototype), "cloneTo", this).call(this, e);
						var t = e;
						t.radius = this.radius, t.emitFromShell = this.emitFromShell, t
							.randomDirection = this.randomDirection
					}
				}, {
					key: "clone",
					value: function() {
						var e = new SphereShape;
						return this.cloneTo(e), e
					}
				}]), SphereShape
			}(Br),
			Wr = function() {
				function SizeOverLifetime(e) {
					_classCallCheck(this, SizeOverLifetime), this._size = e
				}
				return _createClass(SizeOverLifetime, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this._size.cloneTo(t._size), t.enable = this.enable
					}
				}, {
					key: "clone",
					value: function() {
						var e;
						switch (this._size.type) {
							case 0:
								e = this._size.separateAxes ? br.createByGradientSeparate(this._size
									.gradientX.clone(), this._size.gradientY.clone(), this._size
									.gradientZ.clone()) : br.createByGradient(this._size.gradient
									.clone());
								break;
							case 1:
								e = this._size.separateAxes ? br.createByRandomTwoConstantSeparate(this
									._size.constantMinSeparate.clone(), this._size
									.constantMaxSeparate.clone()) : br.createByRandomTwoConstant(
									this._size.constantMin, this._size.constantMax);
								break;
							case 2:
								e = this._size.separateAxes ? br.createByRandomTwoGradientSeparate(this
									._size.gradientXMin.clone(), this._size.gradientYMin.clone(),
									this._size.gradientZMin.clone(), this._size.gradientXMax
								.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax
									.clone()) : br.createByRandomTwoGradient(this._size.gradientMin
									.clone(), this._size.gradientMax.clone())
						}
						var t = new SizeOverLifetime(e);
						return t.enable = this.enable, t
					}
				}, {
					key: "size",
					get: function() {
						return this._size
					}
				}]), SizeOverLifetime
			}(),
			Xr = function() {
				function StartFrame() {
					_classCallCheck(this, StartFrame), this._type = 0, this._constant = 0, this._constantMin = 0, this
						._constantMax = 0
				}
				return _createClass(StartFrame, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._type = this._type, t._constant = this._constant, t._constantMin = this
							._constantMin, t._constantMax = this._constantMax
					}
				}, {
					key: "clone",
					value: function() {
						var e = new StartFrame;
						return this.cloneTo(e), e
					}
				}, {
					key: "type",
					get: function() {
						return this._type
					}
				}, {
					key: "constant",
					get: function() {
						return this._constant
					}
				}, {
					key: "constantMin",
					get: function() {
						return this._constantMin
					}
				}, {
					key: "constantMax",
					get: function() {
						return this._constantMax
					}
				}], [{
					key: "createByConstant",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
							t = new StartFrame;
						return t._type = 0, t._constant = e, t
					}
				}, {
					key: "createByRandomTwoConstant",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
							r = new StartFrame;
						return r._type = 1, r._constantMin = e, r._constantMax = t, r
					}
				}]), StartFrame
			}(),
			Yr = function() {
				function TextureSheetAnimation(e, t) {
					_classCallCheck(this, TextureSheetAnimation), this.type = 0, this.randomRow = !1, this.rowIndex = 0,
						this.cycles = 0, this.enableUVChannels = 0, this.enable = !1, this.tiles = new n(1, 1), this
						.type = 0, this.randomRow = !0, this.rowIndex = 0, this.cycles = 1, this.enableUVChannels = 1,
						this._frame = e, this._startFrame = t
				}
				return _createClass(TextureSheetAnimation, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t
							.rowIndex = this.rowIndex, t.cycles = this.cycles, t.enableUVChannels = this
							.enableUVChannels, t.enable = this.enable, this._frame.cloneTo(t._frame),
							this._startFrame.cloneTo(t._startFrame)
					}
				}, {
					key: "clone",
					value: function() {
						var e, t;
						switch (this._frame.type) {
							case 0:
								e = Lr.createByConstant(this._frame.constant);
								break;
							case 1:
								e = Lr.createByOverTime(this._frame.frameOverTimeData.clone());
								break;
							case 2:
								e = Lr.createByRandomTwoConstant(this._frame.constantMin, this._frame
									.constantMax);
								break;
							case 3:
								e = Lr.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin
								.clone(), this._frame.frameOverTimeDataMax.clone())
						}
						switch (this._startFrame.type) {
							case 0:
								t = Xr.createByConstant(this._startFrame.constant);
								break;
							case 1:
								t = Xr.createByRandomTwoConstant(this._startFrame.constantMin, this
									._startFrame.constantMax)
						}
						var r = new TextureSheetAnimation(e, t);
						return this.cloneTo(r), r
					}
				}, {
					key: "frame",
					get: function() {
						return this._frame
					}
				}, {
					key: "startFrame",
					get: function() {
						return this._startFrame
					}
				}]), TextureSheetAnimation
			}(),
			jr = function() {
				function VelocityOverLifetime(e) {
					_classCallCheck(this, VelocityOverLifetime), this.enable = !1, this.space = 0, this._velocity = e
				}
				return _createClass(VelocityOverLifetime, [{
					key: "cloneTo",
					value: function(e) {
						var t = e;
						this._velocity.cloneTo(t._velocity), t.enable = this.enable, t.space = this
							.space
					}
				}, {
					key: "clone",
					value: function() {
						var e;
						switch (this._velocity.type) {
							case 0:
								e = kr.createByConstant(this._velocity.constant.clone());
								break;
							case 1:
								e = kr.createByGradient(this._velocity.gradientX.clone(), this._velocity
									.gradientY.clone(), this._velocity.gradientZ.clone());
								break;
							case 2:
								e = kr.createByRandomTwoConstant(this._velocity.constantMin.clone(),
									this._velocity.constantMax.clone());
								break;
							case 3:
								e = kr.createByRandomTwoGradient(this._velocity.gradientXMin.clone(),
									this._velocity.gradientXMax.clone(), this._velocity.gradientYMin
									.clone(), this._velocity.gradientYMax.clone(), this._velocity
									.gradientZMin.clone(), this._velocity.gradientZMax.clone())
						}
						var t = new VelocityOverLifetime(e);
						return t.enable = this.enable, t.space = this.space, t
					}
				}, {
					key: "velocity",
					get: function() {
						return this._velocity
					}
				}]), VelocityOverLifetime
			}(),
			Zr = function ShuriKenParticle3DShaderDeclaration() {
				_classCallCheck(this, ShuriKenParticle3DShaderDeclaration)
			};
		Zr.WORLDPOSITION = _e.propertyNameToID("u_WorldPosition"), Zr.WORLDROTATION = _e.propertyNameToID(
				"u_WorldRotation"), Zr.POSITIONSCALE = _e.propertyNameToID("u_PositionScale"), Zr.SIZESCALE = _e
			.propertyNameToID("u_SizeScale"), Zr.SCALINGMODE = _e.propertyNameToID("u_ScalingMode"), Zr.GRAVITY = _e
			.propertyNameToID("u_Gravity"), Zr.THREEDSTARTROTATION = _e.propertyNameToID("u_ThreeDStartRotation"), Zr
			.STRETCHEDBILLBOARDLENGTHSCALE = _e.propertyNameToID("u_StretchedBillboardLengthScale"), Zr
			.STRETCHEDBILLBOARDSPEEDSCALE = _e.propertyNameToID("u_StretchedBillboardSpeedScale"), Zr.SIMULATIONSPACE =
			_e.propertyNameToID("u_SimulationSpace"), Zr.CURRENTTIME = _e.propertyNameToID("u_CurrentTime"), Zr
			.VOLVELOCITYCONST = _e.propertyNameToID("u_VOLVelocityConst"), Zr.VOLVELOCITYGRADIENTX = _e
			.propertyNameToID("u_VOLVelocityGradientX"), Zr.VOLVELOCITYGRADIENTY = _e.propertyNameToID(
				"u_VOLVelocityGradientY"), Zr.VOLVELOCITYGRADIENTZ = _e.propertyNameToID("u_VOLVelocityGradientZ"), Zr
			.VOLVELOCITYCONSTMAX = _e.propertyNameToID("u_VOLVelocityConstMax"), Zr.VOLVELOCITYGRADIENTXMAX = _e
			.propertyNameToID("u_VOLVelocityGradientMaxX"), Zr.VOLVELOCITYGRADIENTYMAX = _e.propertyNameToID(
				"u_VOLVelocityGradientMaxY"), Zr.VOLVELOCITYGRADIENTZMAX = _e.propertyNameToID(
				"u_VOLVelocityGradientMaxZ"), Zr.VOLSPACETYPE = _e.propertyNameToID("u_VOLSpaceType"), Zr
			.COLOROVERLIFEGRADIENTALPHAS = _e.propertyNameToID("u_ColorOverLifeGradientAlphas"), Zr
			.COLOROVERLIFEGRADIENTCOLORS = _e.propertyNameToID("u_ColorOverLifeGradientColors"), Zr
			.MAXCOLOROVERLIFEGRADIENTALPHAS = _e.propertyNameToID("u_MaxColorOverLifeGradientAlphas"), Zr
			.MAXCOLOROVERLIFEGRADIENTCOLORS = _e.propertyNameToID("u_MaxColorOverLifeGradientColors"), Zr
			.SOLSIZEGRADIENT = _e.propertyNameToID("u_SOLSizeGradient"), Zr.SOLSIZEGRADIENTX = _e.propertyNameToID(
				"u_SOLSizeGradientX"), Zr.SOLSIZEGRADIENTY = _e.propertyNameToID("u_SOLSizeGradientY"), Zr
			.SOLSizeGradientZ = _e.propertyNameToID("u_SOLSizeGradientZ"), Zr.SOLSizeGradientMax = _e.propertyNameToID(
				"u_SOLSizeGradientMax"), Zr.SOLSIZEGRADIENTXMAX = _e.propertyNameToID("u_SOLSizeGradientMaxX"), Zr
			.SOLSIZEGRADIENTYMAX = _e.propertyNameToID("u_SOLSizeGradientMaxY"), Zr.SOLSizeGradientZMAX = _e
			.propertyNameToID("u_SOLSizeGradientMaxZ"), Zr.ROLANGULARVELOCITYCONST = _e.propertyNameToID(
				"u_ROLAngularVelocityConst"), Zr.ROLANGULARVELOCITYCONSTSEPRARATE = _e.propertyNameToID(
				"u_ROLAngularVelocityConstSeprarate"), Zr.ROLANGULARVELOCITYGRADIENT = _e.propertyNameToID(
				"u_ROLAngularVelocityGradient"), Zr.ROLANGULARVELOCITYGRADIENTX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientX"), Zr.ROLANGULARVELOCITYGRADIENTY = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientY"), Zr.ROLANGULARVELOCITYGRADIENTZ = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientZ"), Zr.ROLANGULARVELOCITYCONSTMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityConstMax"), Zr.ROLANGULARVELOCITYCONSTMAXSEPRARATE = _e.propertyNameToID(
				"u_ROLAngularVelocityConstMaxSeprarate"), Zr.ROLANGULARVELOCITYGRADIENTMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientMax"), Zr.ROLANGULARVELOCITYGRADIENTXMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientMaxX"), Zr.ROLANGULARVELOCITYGRADIENTYMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientMaxY"), Zr.ROLANGULARVELOCITYGRADIENTZMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientMaxZ"), Zr.ROLANGULARVELOCITYGRADIENTWMAX = _e.propertyNameToID(
				"u_ROLAngularVelocityGradientMaxW"), Zr.TEXTURESHEETANIMATIONCYCLES = _e.propertyNameToID(
			"u_TSACycles"), Zr.TEXTURESHEETANIMATIONSUBUVLENGTH = _e.propertyNameToID("u_TSASubUVLength"), Zr
			.TEXTURESHEETANIMATIONGRADIENTUVS = _e.propertyNameToID("u_TSAGradientUVs"), Zr
			.TEXTURESHEETANIMATIONGRADIENTMAXUVS = _e.propertyNameToID("u_TSAMaxGradientUVs");
		var Qr = function(e) {
			function ShurikenParticleMaterial() {
				var e;
				return _classCallCheck(this, ShurikenParticleMaterial), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(ShurikenParticleMaterial).call(this))).setShaderName("PARTICLESHURIKEN"), e
					._color = new i(1, 1, 1, 1), e.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED, e
			}
			return _inherits(ShurikenParticleMaterial, e), _createClass(ShurikenParticleMaterial, [{
				key: "clone",
				value: function() {
					var e = new ShurikenParticleMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "_TintColor",
				get: function() {
					return this.color
				},
				set: function(e) {
					this.color = e
				}
			}, {
				key: "_TintColorR",
				get: function() {
					return this._color.x
				},
				set: function(e) {
					this._color.x = e, this.color = this._color
				}
			}, {
				key: "_TintColorG",
				get: function() {
					return this._color.y
				},
				set: function(e) {
					this._color.y = e, this.color = this._color
				}
			}, {
				key: "_TintColorB",
				get: function() {
					return this._color.z
				},
				set: function(e) {
					this._color.z = e, this.color = this._color
				}
			}, {
				key: "_TintColorA",
				get: function() {
					return this._color.w
				},
				set: function(e) {
					this._color.w = e, this.color = this._color
				}
			}, {
				key: "_MainTex_ST",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET)
				},
				set: function(e) {
					var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
					t.setValue(e.x, e.y, e.z, e.w), this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STX",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x
				},
				set: function(e) {
					var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
					t.x = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STY",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y
				},
				set: function(e) {
					var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
					t.y = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STZ",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z
				},
				set: function(e) {
					var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
					t.z = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STW",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w
				},
				set: function(e) {
					var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
					t.w = e, this.tilingOffset = t
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1,
								this.cull = at.CULL_NONE, this.blend = at.BLEND_ENABLE_ALL, this
								.blendSrc = at.BLENDPARAM_SRC_ALPHA, this.blendDst = at
								.BLENDPARAM_ONE, this.alphaTest = !1, this._shaderValues.addDefine(
									ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
							break;
						case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1,
								this.cull = at.CULL_NONE, this.blend = at.BLEND_ENABLE_ALL, this
								.blendSrc = at.BLENDPARAM_SRC_ALPHA, this.blendDst = at
								.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.alphaTest = !1, this
								._shaderValues.removeDefine(ShurikenParticleMaterial
									.SHADERDEFINE_ADDTIVEFOG);
							break;
						default:
							throw new Error("ShurikenParticleMaterial : renderMode value error.")
					}
				}
			}, {
				key: "colorR",
				get: function() {
					return this._TintColorR
				},
				set: function(e) {
					this._TintColorR = e
				}
			}, {
				key: "colorG",
				get: function() {
					return this._TintColorG
				},
				set: function(e) {
					this._TintColorG = e
				}
			}, {
				key: "colorB",
				get: function() {
					return this._TintColorB
				},
				set: function(e) {
					this._TintColorB = e
				}
			}, {
				key: "colorA",
				get: function() {
					return this._TintColorA
				},
				set: function(e) {
					this._TintColorA = e
				}
			}, {
				key: "color",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(ShurikenParticleMaterial
							.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(
							ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR), this._shaderValues
						.setVector(ShurikenParticleMaterial.TINTCOLOR, e)
				}
			}, {
				key: "tilingOffsetX",
				get: function() {
					return this._MainTex_STX
				},
				set: function(e) {
					this._MainTex_STX = e
				}
			}, {
				key: "tilingOffsetY",
				get: function() {
					return this._MainTex_STY
				},
				set: function(e) {
					this._MainTex_STY = e
				}
			}, {
				key: "tilingOffsetZ",
				get: function() {
					return this._MainTex_STZ
				},
				set: function(e) {
					this._MainTex_STZ = e
				}
			}, {
				key: "tilingOffsetW",
				get: function() {
					return this._MainTex_STW
				},
				set: function(e) {
					this._MainTex_STW = e
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this
						._shaderValues.removeDefine(ShurikenParticleMaterial
							.SHADERDEFINE_TILINGOFFSET), this._shaderValues.setVector(
							ShurikenParticleMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "texture",
				get: function() {
					return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(ShurikenParticleMaterial
							.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(
							ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP), this._shaderValues
						.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, e)
				}
			}, {
				key: "depthWrite",
				get: function() {
					return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE)
				},
				set: function(e) {
					this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, e)
				}
			}, {
				key: "cull",
				get: function() {
					return this._shaderValues.getInt(ShurikenParticleMaterial.CULL)
				},
				set: function(e) {
					this._shaderValues.setInt(ShurikenParticleMaterial.CULL, e)
				}
			}, {
				key: "blend",
				get: function() {
					return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND)
				},
				set: function(e) {
					this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, e)
				}
			}, {
				key: "blendSrc",
				get: function() {
					return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC)
				},
				set: function(e) {
					this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, e)
				}
			}, {
				key: "blendDst",
				get: function() {
					return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST)
				},
				set: function(e) {
					this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, e)
				}
			}, {
				key: "depthTest",
				get: function() {
					return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST)
				},
				set: function(e) {
					this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, e)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = _e.getDefineByName(
							"DIFFUSEMAP"), ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = _e
						.getDefineByName("TINTCOLOR"), ShurikenParticleMaterial
						.SHADERDEFINE_ADDTIVEFOG = _e.getDefineByName("ADDTIVEFOG"),
						ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = _e.getDefineByName(
							"TILINGOFFSET")
				}
			}]), ShurikenParticleMaterial
		}(nt);
		Qr.RENDERMODE_ALPHABLENDED = 0, Qr.RENDERMODE_ADDTIVE = 1, Qr.DIFFUSETEXTURE = _e.propertyNameToID("u_texture"),
			Qr.TINTCOLOR = _e.propertyNameToID("u_Tintcolor"), Qr.TILINGOFFSET = _e.propertyNameToID("u_TilingOffset"),
			Qr.CULL = _e.propertyNameToID("s_Cull"), Qr.BLEND = _e.propertyNameToID("s_Blend"), Qr.BLEND_SRC = _e
			.propertyNameToID("s_BlendSrc"), Qr.BLEND_DST = _e.propertyNameToID("s_BlendDst"), Qr.DEPTH_TEST = _e
			.propertyNameToID("s_DepthTest"), Qr.DEPTH_WRITE = _e.propertyNameToID("s_DepthWrite");
		var qr = function(e) {
				function ShurikenParticleRenderer(e) {
					var t;
					return _classCallCheck(this, ShurikenParticleRenderer), (t = _possibleConstructorReturn(this,
							_getPrototypeOf(ShurikenParticleRenderer).call(this, e)))._finalGravity = new o, t
						._tempRotationMatrix = new c, t._mesh = null, t.stretchedBillboardCameraSpeedScale = 0, t
						.stretchedBillboardSpeedScale = 0, t.stretchedBillboardLengthScale = 2, t._defaultBoundBox =
						new Lt(new o, new o), t.renderMode = 0, t._supportOctree = !1, t
				}
				return _inherits(ShurikenParticleRenderer, e), _createClass(ShurikenParticleRenderer, [{
					key: "_calculateBoundingBox",
					value: function() {
						var e = this._owner.particleSystem;
						if (e._useCustomBounds) e.customBounds._tranform(this._owner.transform
							.worldMatrix, this._bounds);
						else if (e._simulationSupported()) {
							if (e._generateBounds(), e._bounds._tranform(this._owner.transform
									.worldMatrix, this._bounds), 0 != e.gravityModifier) {
								var t = this._bounds.getMax(),
									r = this._bounds.getMin(),
									n = e._gravityOffset;
								t.y -= n.x, r.y -= n.y, this._bounds.setMax(t), this._bounds.setMin(r)
							}
						} else {
							(r = this._bounds.getMin()).setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -
								Number.MAX_VALUE), this._bounds.setMin(r), (t = this._bounds
							.getMax()).setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number
								.MAX_VALUE), this._bounds.setMax(t)
						}
					}
				}, {
					key: "_needRender",
					value: function(e, t) {
						return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner
							.particleSystem.isAlive
					}
				}, {
					key: "_renderUpdate",
					value: function(e, t) {
						var r = this._owner.particleSystem,
							n = this._shaderValues,
							i = this._owner.transform;
						switch (r.simulationSpace) {
							case 0:
								break;
							case 1:
								n.setVector3(Zr.WORLDPOSITION, i.position), n.setQuaternion(Zr
									.WORLDROTATION, i.rotation);
								break;
							default:
								throw new Error(
									"ShurikenParticleMaterial: SimulationSpace value is invalid.")
						}
						switch (r.scaleMode) {
							case 0:
								var a = i.getWorldLossyScale();
								n.setVector3(Zr.POSITIONSCALE, a), n.setVector3(Zr.SIZESCALE, a);
								break;
							case 1:
								var s = i.localScale;
								n.setVector3(Zr.POSITIONSCALE, s), n.setVector3(Zr.SIZESCALE, s);
								break;
							case 2:
								n.setVector3(Zr.POSITIONSCALE, i.getWorldLossyScale()), n.setVector3(Zr
									.SIZESCALE, o._ONE)
						}
						o.scale(m.gravity, r.gravityModifier, this._finalGravity), n.setVector3(Zr
								.GRAVITY, this._finalGravity), n.setInt(Zr.SIMULATIONSPACE, r
								.simulationSpace), n.setBool(Zr.THREEDSTARTROTATION, r
								.threeDStartRotation), n.setInt(Zr.SCALINGMODE, r.scaleMode), n
							.setNumber(Zr.STRETCHEDBILLBOARDLENGTHSCALE, this
								.stretchedBillboardLengthScale), n.setNumber(Zr
								.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale), n
							.setNumber(Zr.CURRENTTIME, r._currentTime)
					}
				}, {
					key: "_destroy",
					value: function() {
						_get(_getPrototypeOf(ShurikenParticleRenderer.prototype), "_destroy", this)
							.call(this), this._mesh && (this._mesh._removeReference(), this._mesh =
								null)
					}
				}, {
					key: "renderMode",
					get: function() {
						return this._renderMode
					},
					set: function(e) {
						if (this._renderMode !== e) {
							var t = this._shaderValues;
							switch (this._renderMode) {
								case 0:
									t.removeDefine(Zr.SHADERDEFINE_RENDERMODE_BILLBOARD);
									break;
								case 1:
									t.removeDefine(Zr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
									break;
								case 2:
									t.removeDefine(Zr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
									break;
								case 3:
									t.removeDefine(Zr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
									break;
								case 4:
									t.removeDefine(Zr.SHADERDEFINE_RENDERMODE_MESH)
							}
							switch (this._renderMode = e, e) {
								case 0:
									t.addDefine(Zr.SHADERDEFINE_RENDERMODE_BILLBOARD);
									break;
								case 1:
									t.addDefine(Zr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
									break;
								case 2:
									t.addDefine(Zr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
									break;
								case 3:
									t.addDefine(Zr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
									break;
								case 4:
									t.addDefine(Zr.SHADERDEFINE_RENDERMODE_MESH);
									break;
								default:
									throw new Error("ShurikenParticleRender: unknown renderMode Value.")
							}
							var r = this._owner.particleSystem;
							r && r._initBufferDatas()
						}
					}
				}, {
					key: "mesh",
					get: function() {
						return this._mesh
					},
					set: function(e) {
						this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh =
							e, e && e._addReference(), this._owner.particleSystem._initBufferDatas()
							)
					}
				}, {
					key: "bounds",
					get: function() {
						return this._boundsChange && (this._calculateBoundingBox(), this
							._boundsChange = !1), this._bounds
					}
				}]), ShurikenParticleRenderer
			}(Wt),
			Kr = function VertexShuriKenParticle() {
				_classCallCheck(this, VertexShuriKenParticle)
			};
		Kr.PARTICLE_CORNERTEXTURECOORDINATE0 = 5, Kr.PARTICLE_POSITION0 = 1, Kr.PARTICLE_COLOR0 = 2, Kr
			.PARTICLE_TEXTURECOORDINATE0 = 3, Kr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4, Kr.PARTICLE_DIRECTIONTIME = 0,
			Kr.PARTICLE_STARTCOLOR0 = 6, Kr.PARTICLE_ENDCOLOR0 = 7, Kr.PARTICLE_STARTSIZE = 8, Kr
			.PARTICLE_STARTROTATION = 9, Kr.PARTICLE_STARTSPEED = 10, Kr.PARTICLE_RANDOM0 = 11, Kr.PARTICLE_RANDOM1 =
			12, Kr.PARTICLE_SIMULATIONWORLDPOSTION = 13, Kr.PARTICLE_SIMULATIONWORLDROTATION = 14;
		var Jr = function(e) {
				function VertexShurikenParticleBillboard(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
					var f;
					return _classCallCheck(this, VertexShurikenParticleBillboard), (f = _possibleConstructorReturn(this,
							_getPrototypeOf(VertexShurikenParticleBillboard).call(this)))._cornerTextureCoordinate = e,
						f._positionStartLifeTime = t, f._velocity = r, f._startColor = n, f._startSize = i, f
						._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l, f
						._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1, f
						._simulationWorldPostion = d, f
				}
				return _inherits(VertexShurikenParticleBillboard, e), _createClass(VertexShurikenParticleBillboard, [{
					key: "cornerTextureCoordinate",
					get: function() {
						return this._cornerTextureCoordinate
					}
				}, {
					key: "positionStartLifeTime",
					get: function() {
						return this._positionStartLifeTime
					}
				}, {
					key: "velocity",
					get: function() {
						return this._velocity
					}
				}, {
					key: "startColor",
					get: function() {
						return this._startColor
					}
				}, {
					key: "startSize",
					get: function() {
						return this._startSize
					}
				}, {
					key: "startRotation0",
					get: function() {
						return this._startRotation0
					}
				}, {
					key: "startRotation1",
					get: function() {
						return this._startRotation1
					}
				}, {
					key: "startRotation2",
					get: function() {
						return this._startRotation2
					}
				}, {
					key: "startLifeTime",
					get: function() {
						return this._startLifeTime
					}
				}, {
					key: "time",
					get: function() {
						return this._time
					}
				}, {
					key: "startSpeed",
					get: function() {
						return this._startSpeed
					}
				}, {
					key: "random0",
					get: function() {
						return this._randoms0
					}
				}, {
					key: "random1",
					get: function() {
						return this._randoms1
					}
				}, {
					key: "simulationWorldPostion",
					get: function() {
						return this._simulationWorldPostion
					}
				}], [{
					key: "__init__",
					value: function() {
						VertexShurikenParticleBillboard._vertexDeclaration = new ie(152, [new ae(0, re
								.Vector4, Kr.PARTICLE_CORNERTEXTURECOORDINATE0), new ae(16, re
								.Vector4, Kr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new ae(32, re
								.Vector4, Kr.PARTICLE_DIRECTIONTIME), new ae(48, re.Vector4, Kr
								.PARTICLE_STARTCOLOR0), new ae(64, re.Vector3, Kr
								.PARTICLE_STARTSIZE), new ae(76, re.Vector3, Kr
								.PARTICLE_STARTROTATION), new ae(88, re.Single, Kr
								.PARTICLE_STARTSPEED), new ae(92, re.Vector4, Kr
								.PARTICLE_RANDOM0), new ae(108, re.Vector4, Kr
							.PARTICLE_RANDOM1), new ae(124, re.Vector3, Kr
								.PARTICLE_SIMULATIONWORLDPOSTION), new ae(136, re.Vector4, Kr
								.PARTICLE_SIMULATIONWORLDROTATION)
						])
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexShurikenParticleBillboard._vertexDeclaration
					}
				}]), VertexShurikenParticleBillboard
			}(Kr),
			$r = function(e) {
				function VertexShurikenParticleMesh(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
					var f;
					return _classCallCheck(this, VertexShurikenParticleMesh), (f = _possibleConstructorReturn(this,
							_getPrototypeOf(VertexShurikenParticleMesh).call(this)))._cornerTextureCoordinate = e, f
						._positionStartLifeTime = t, f._velocity = r, f._startColor = n, f._startSize = i, f
						._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l, f
						._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1, f
						._simulationWorldPostion = d, f
				}
				return _inherits(VertexShurikenParticleMesh, e), _createClass(VertexShurikenParticleMesh, [{
					key: "cornerTextureCoordinate",
					get: function() {
						return this._cornerTextureCoordinate
					}
				}, {
					key: "position",
					get: function() {
						return this._positionStartLifeTime
					}
				}, {
					key: "velocity",
					get: function() {
						return this._velocity
					}
				}, {
					key: "startColor",
					get: function() {
						return this._startColor
					}
				}, {
					key: "startSize",
					get: function() {
						return this._startSize
					}
				}, {
					key: "startRotation0",
					get: function() {
						return this._startRotation0
					}
				}, {
					key: "startRotation1",
					get: function() {
						return this._startRotation1
					}
				}, {
					key: "startRotation2",
					get: function() {
						return this._startRotation2
					}
				}, {
					key: "startLifeTime",
					get: function() {
						return this._startLifeTime
					}
				}, {
					key: "time",
					get: function() {
						return this._time
					}
				}, {
					key: "startSpeed",
					get: function() {
						return this._startSpeed
					}
				}, {
					key: "random0",
					get: function() {
						return this._randoms0
					}
				}, {
					key: "random1",
					get: function() {
						return this._randoms1
					}
				}, {
					key: "simulationWorldPostion",
					get: function() {
						return this._simulationWorldPostion
					}
				}], [{
					key: "__init__",
					value: function() {
						VertexShurikenParticleMesh._vertexDeclaration = new ie(172, [new ae(0, re
								.Vector3, Kr.PARTICLE_POSITION0), new ae(12, re.Vector4, Kr
								.PARTICLE_COLOR0), new ae(28, re.Vector2, Kr
								.PARTICLE_TEXTURECOORDINATE0), new ae(36, re.Vector4, Kr
								.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new ae(52, re.Vector4, Kr
								.PARTICLE_DIRECTIONTIME), new ae(68, re.Vector4, Kr
								.PARTICLE_STARTCOLOR0), new ae(84, re.Vector3, Kr
								.PARTICLE_STARTSIZE), new ae(96, re.Vector3, Kr
								.PARTICLE_STARTROTATION), new ae(108, re.Single, Kr
								.PARTICLE_STARTSPEED), new ae(112, re.Vector4, Kr
								.PARTICLE_RANDOM0), new ae(128, re.Vector4, Kr
							.PARTICLE_RANDOM1), new ae(144, re.Vector3, Kr
								.PARTICLE_SIMULATIONWORLDPOSTION), new ae(156, re.Vector4, Kr
								.PARTICLE_SIMULATIONWORLDROTATION)
						])
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexShurikenParticleMesh._vertexDeclaration
					}
				}]), VertexShurikenParticleMesh
			}(Kr),
			en = function() {
				function Rand(e) {
					_classCallCheck(this, Rand), this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this
						.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this
						.seeds[1] + 1, this.seeds[3] = 1812433253 * this.seeds[2] + 1
				}
				return _createClass(Rand, [{
					key: "getUint",
					value: function() {
						return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this
							.seeds[1], this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3],
							this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this
							._temp[0] >>> 8, this.seeds[3]
					}
				}, {
					key: "getFloat",
					value: function() {
						return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607)
					}
				}, {
					key: "getSignedFloat",
					value: function() {
						return 2 * this.getFloat() - 1
					}
				}, {
					key: "seed",
					get: function() {
						return this.seeds[0]
					},
					set: function(e) {
						this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[
							2] = 1812433253 * this.seeds[1] + 1, this.seeds[3] = 1812433253 * this
							.seeds[2] + 1
					}
				}], [{
					key: "getFloatFromInt",
					value: function(e) {
						return 1 / 8388607 * (8388607 & e)
					}
				}, {
					key: "getByteFromInt",
					value: function(e) {
						return (8388607 & e) >>> 15
					}
				}]), Rand
			}(),
			tn = function() {
				function Emission() {
					_classCallCheck(this, Emission), this._emissionRate = 10, this._destroyed = !1, this._bursts = []
				}
				return _createClass(Emission, [{
					key: "destroy",
					value: function() {
						this._bursts = null, this._destroyed = !0
					}
				}, {
					key: "getBurstsCount",
					value: function() {
						return this._bursts.length
					}
				}, {
					key: "getBurstByIndex",
					value: function(e) {
						return this._bursts[e]
					}
				}, {
					key: "addBurst",
					value: function(e) {
						var t = this._bursts.length;
						if (t > 0)
							for (var r = 0; r < t; r++) this._bursts[r].time > e.time && this._bursts
								.splice(r, 0, e);
						this._bursts.push(e)
					}
				}, {
					key: "removeBurst",
					value: function(e) {
						var t = this._bursts.indexOf(e); - 1 !== t && this._bursts.splice(t, 1)
					}
				}, {
					key: "removeBurstByIndex",
					value: function(e) {
						this._bursts.splice(e, 1)
					}
				}, {
					key: "clearBurst",
					value: function() {
						this._bursts.length = 0
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e,
							r = t._bursts;
						r.length = this._bursts.length;
						for (var n = 0, i = this._bursts.length; n < i; n++) {
							var a = r[n];
							a ? this._bursts[n].cloneTo(a) : r[n] = this._bursts[n].clone()
						}
						t._emissionRate = this._emissionRate, t.enable = this.enable
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Emission;
						return this.cloneTo(e), e
					}
				}, {
					key: "emissionRate",
					set: function(e) {
						if (e < 0) throw new Error(
							"ParticleBaseShape:emissionRate value must large or equal than 0.");
						this._emissionRate = e
					},
					get: function() {
						return this._emissionRate
					}
				}, {
					key: "destroyed",
					get: function() {
						return this._destroyed
					}
				}]), Emission
			}(),
			rn = function() {
				function ShurikenParticleData() {
					_classCallCheck(this, ShurikenParticleData)
				}
				return _createClass(ShurikenParticleData, null, [{
					key: "_getStartLifetimeFromGradient",
					value: function(e, r) {
						for (var n = 1, i = e.gradientCount; n < i; n++) {
							var a = e.getKeyByIndex(n);
							if (a >= r) {
								var o = e.getKeyByIndex(n - 1),
									s = (r - o) / (a - o);
								return t.MathUtil.lerp(e.getValueByIndex(n - 1), e.getValueByIndex(n),
									s)
							}
						}
						throw new Error(
							"ShurikenParticleData: can't get value foam startLifeTimeGradient.")
					}
				}, {
					key: "_randomInvertRoationArray",
					value: function(e, t, r, n, i) {
						var a;
						n ? (n.seed = i[6], a = n.getFloat(), i[6] = n.seed) : a = Math.random(), a <
							r ? (t.x = -e.x, t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z)
					}
				}, {
					key: "_randomInvertRoation",
					value: function(e, t, r, n) {
						var i;
						return r ? (r.seed = n[6], i = r.getFloat(), n[6] = r.seed) : i = Math.random(),
							i < t && (e = -e), e
					}
				}, {
					key: "create",
					value: function(e, r, n) {
						var a = e.autoRandomSeed,
							o = e._rand,
							s = e._randomSeeds;
						switch (e.startColorType) {
							case 0:
								var l = e.startColorConstant;
								ShurikenParticleData.startColor.x = l.x, ShurikenParticleData.startColor
									.y = l.y, ShurikenParticleData.startColor.z = l.z,
									ShurikenParticleData.startColor.w = l.w;
								break;
							case 2:
								a ? i.lerp(e.startColorConstantMin, e.startColorConstantMax, Math
									.random(), ShurikenParticleData.startColor) : (o.seed = s[3], i
									.lerp(e.startColorConstantMin, e.startColorConstantMax, o
										.getFloat(), ShurikenParticleData.startColor), s[3] = o.seed
									)
						}
						var u = e.colorOverLifetime;
						if (u && u.enable) {
							var c = u.color;
							switch (c.type) {
								case 0:
									ShurikenParticleData.startColor.x = ShurikenParticleData.startColor
										.x * c.constant.x, ShurikenParticleData.startColor.y =
										ShurikenParticleData.startColor.y * c.constant.y,
										ShurikenParticleData.startColor.z = ShurikenParticleData
										.startColor.z * c.constant.z, ShurikenParticleData.startColor
										.w = ShurikenParticleData.startColor.w * c.constant.w;
									break;
								case 2:
									var h;
									a ? h = Math.random() : (o.seed = s[10], h = o.getFloat(), s[10] = o
										.seed);
									var _ = c.constantMin,
										d = c.constantMax;
									ShurikenParticleData.startColor.x = ShurikenParticleData.startColor
										.x * t.MathUtil.lerp(_.x, d.x, h), ShurikenParticleData
										.startColor.y = ShurikenParticleData.startColor.y * t.MathUtil
										.lerp(_.y, d.y, h), ShurikenParticleData.startColor.z =
										ShurikenParticleData.startColor.z * t.MathUtil.lerp(_.z, d.z,
										h), ShurikenParticleData.startColor.w = ShurikenParticleData
										.startColor.w * t.MathUtil.lerp(_.w, d.w, h)
							}
						}
						var f = ShurikenParticleData.startSize;
						switch (e.startSizeType) {
							case 0:
								if (e.threeDStartSize) {
									var m = e.startSizeConstantSeparate;
									f[0] = m.x, f[1] = m.y, f[2] = m.z
								} else f[0] = f[1] = f[2] = e.startSizeConstant;
								break;
							case 2:
								if (e.threeDStartSize) {
									var p = e.startSizeConstantMinSeparate,
										T = e.startSizeConstantMaxSeparate;
									a ? (f[0] = t.MathUtil.lerp(p.x, T.x, Math.random()), f[1] = t
										.MathUtil.lerp(p.y, T.y, Math.random()), f[2] = t.MathUtil
										.lerp(p.z, T.z, Math.random())) : (o.seed = s[4], f[0] = t
										.MathUtil.lerp(p.x, T.x, o.getFloat()), f[1] = t.MathUtil
										.lerp(p.y, T.y, o.getFloat()), f[2] = t.MathUtil.lerp(p.z, T
											.z, o.getFloat()), s[4] = o.seed)
								} else a ? f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin,
									e.startSizeConstantMax, Math.random()) : (o.seed = s[4], f[0] =
									f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e
										.startSizeConstantMax, o.getFloat()), s[4] = o.seed)
						}
						var E = e.sizeOverLifetime;
						if (E && E.enable && 1 === E.size.type) {
							var g, y = E.size;
							if (y.separateAxes) a ? (f[0] = f[0] * t.MathUtil.lerp(y.constantMinSeparate
										.x, y.constantMaxSeparate.x, Math.random()), f[1] = f[1] * t
									.MathUtil.lerp(y.constantMinSeparate.y, y.constantMaxSeparate.y,
										Math.random()), f[2] = f[2] * t.MathUtil.lerp(y
										.constantMinSeparate.z, y.constantMaxSeparate.z, Math.random())
									) : (o.seed = s[11], f[0] = f[0] * t.MathUtil.lerp(y
										.constantMinSeparate.x, y.constantMaxSeparate.x, o.getFloat()),
									f[1] = f[1] * t.MathUtil.lerp(y.constantMinSeparate.y, y
										.constantMaxSeparate.y, o.getFloat()), f[2] = f[2] * t.MathUtil
									.lerp(y.constantMinSeparate.z, y.constantMaxSeparate.z, o
									.getFloat()), s[11] = o.seed);
							else a ? g = t.MathUtil.lerp(y.constantMin, y.constantMax, Math.random()) :
								(o.seed = s[11], g = t.MathUtil.lerp(y.constantMin, y.constantMax, o
									.getFloat()), s[11] = o.seed), f[0] = f[0] * g, f[1] = f[1] * g, f[
									2] = f[2] * g
						}
						var S = r.renderMode;
						if (1 !== S) switch (e.startRotationType) {
							case 0:
								if (e.threeDStartRotation) {
									var v = e.startRotationConstantSeparate,
										R = ShurikenParticleData._tempVector30;
									ShurikenParticleData._randomInvertRoationArray(v, R, e
											.randomizeRotationDirection, a ? null : o, s),
										ShurikenParticleData.startRotation[0] = R.x,
										ShurikenParticleData.startRotation[1] = R.y,
										ShurikenParticleData.startRotation[2] = 4 !== S ? -R.z : R.z
								} else ShurikenParticleData.startRotation[0] = ShurikenParticleData
									._randomInvertRoation(e.startRotationConstant, e
										.randomizeRotationDirection, a ? null : o, s),
									ShurikenParticleData.startRotation[1] = 0, ShurikenParticleData
									.startRotation[2] = 0;
								break;
							case 2:
								if (e.threeDStartRotation) {
									var C = e.startRotationConstantMinSeparate,
										M = e.startRotationConstantMaxSeparate,
										D = ShurikenParticleData._tempVector30;
									a ? (D.x = t.MathUtil.lerp(C.x, M.x, Math.random()), D.y = t
											.MathUtil.lerp(C.y, M.y, Math.random()), D.z = t
											.MathUtil.lerp(C.z, M.z, Math.random())) : (o.seed = s[
												5], D.x = t.MathUtil.lerp(C.x, M.x, o.getFloat()), D
											.y = t.MathUtil.lerp(C.y, M.y, o.getFloat()), D.z = t
											.MathUtil.lerp(C.z, M.z, o.getFloat()), s[5] = o.seed),
										ShurikenParticleData._randomInvertRoationArray(D, D, e
											.randomizeRotationDirection, a ? null : o, s),
										ShurikenParticleData.startRotation[0] = D.x,
										ShurikenParticleData.startRotation[1] = D.y,
										ShurikenParticleData.startRotation[2] = 4 !== S ? -D.z : D.z
								} else a ? ShurikenParticleData.startRotation[0] =
									ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e
											.startRotationConstantMin, e.startRotationConstantMax,
											Math.random()), e.randomizeRotationDirection, a ? null :
										o, s) : (o.seed = s[5], ShurikenParticleData.startRotation[
											0] = ShurikenParticleData._randomInvertRoation(t
											.MathUtil.lerp(e.startRotationConstantMin, e
												.startRotationConstantMax, o.getFloat()), e
											.randomizeRotationDirection, a ? null : o, s), s[5] = o
										.seed)
						}
						switch (e.startLifetimeType) {
							case 0:
								ShurikenParticleData.startLifeTime = e.startLifetimeConstant;
								break;
							case 1:
								ShurikenParticleData.startLifeTime = ShurikenParticleData
									._getStartLifetimeFromGradient(e.startLifeTimeGradient, e
										.emissionTime);
								break;
							case 2:
								a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e
									.startLifetimeConstantMin, e.startLifetimeConstantMax, Math
									.random()) : (o.seed = s[7], ShurikenParticleData
									.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e
										.startLifetimeConstantMax, o.getFloat()), s[7] = o.seed);
								break;
							case 3:
								var x = e.emissionTime;
								a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(
									ShurikenParticleData._getStartLifetimeFromGradient(e
										.startLifeTimeGradientMin, x), ShurikenParticleData
									._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, x),
									Math.random()) : (o.seed = s[7], ShurikenParticleData
									.startLifeTime = t.MathUtil.lerp(ShurikenParticleData
										._getStartLifetimeFromGradient(e.startLifeTimeGradientMin,
											x), ShurikenParticleData._getStartLifetimeFromGradient(e
											.startLifeTimeGradientMax, x), o.getFloat()), s[7] = o
									.seed)
						}
						var A = e.textureSheetAnimation;
						if (A && A.enable) {
							var I, L = A.tiles,
								P = L.x,
								O = L.y,
								N = 1 / P,
								b = 1 / O,
								k = A.startFrame;
							switch (k.type) {
								case 0:
									I = k.constant;
									break;
								case 1:
									a ? I = t.MathUtil.lerp(k.constantMin, k.constantMax, Math
									.random()) : (o.seed = s[14], I = t.MathUtil.lerp(k.constantMin, k
											.constantMax, o.getFloat()), s[14] = o.seed)
							}
							var w = A.frame,
								B = A.cycles;
							switch (w.type) {
								case 0:
									I += w.constant * B;
									break;
								case 2:
									a ? I += t.MathUtil.lerp(w.constantMin, w.constantMax, Math
									.random()) * B : (o.seed = s[15], I += t.MathUtil.lerp(w
											.constantMin, w.constantMax, o.getFloat()) * B, s[15] =
										o.seed)
							}
							var V = 0;
							switch (A.type) {
								case 0:
									V = Math.floor(I / P);
									break;
								case 1:
									A.randomRow ? a ? V = Math.floor(Math.random() * O) : (o.seed = s[
											13], V = Math.floor(o.getFloat() * O), s[13] = o.seed) : V =
										A.rowIndex
							}
							var F = Math.floor(I % P);
							ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo,
								ShurikenParticleData.startUVInfo[0] = N, ShurikenParticleData
								.startUVInfo[1] = b, ShurikenParticleData.startUVInfo[2] = F * N,
								ShurikenParticleData.startUVInfo[3] = V * b
						} else ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo,
							ShurikenParticleData.startUVInfo[0] = 1, ShurikenParticleData.startUVInfo[
							1] = 1, ShurikenParticleData.startUVInfo[2] = 0, ShurikenParticleData
							.startUVInfo[3] = 0
					}
				}]), ShurikenParticleData
			}();
		rn._tempVector30 = new o, rn.startColor = new i, rn.startSize = new Float32Array(3), rn.startRotation =
			new Float32Array(3), rn.startUVInfo = new Float32Array(4);
		var nn = function(r) {
			function ShurikenParticleSystem(e) {
				var t;
				return _classCallCheck(this, ShurikenParticleSystem), (t = _possibleConstructorReturn(this,
						_getPrototypeOf(ShurikenParticleSystem).call(this)))._boundingSphere = null, t
					._boundingBox = null, t._boundingBoxCorners = null, t._bounds = null, t._gravityOffset = new n,
					t._customBounds = null, t._useCustomBounds = !1, t._owner = null, t._ownerRender = null, t
					._vertices = null, t._floatCountPerVertex = 0, t._startLifeTimeIndex = 0, t._timeIndex = 0, t
					._simulateUpdate = !1, t._firstActiveElement = 0, t._firstNewElement = 0, t._firstFreeElement =
					0, t._firstRetiredElement = 0, t._drawCounter = 0, t._bufferMaxParticles = 0, t._emission =
					null, t._shape = null, t._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t
					._playStartDelay = 0, t._frameRateTime = 0, t._emissionTime = 0, t._totalDelayTime = 0, t
					._burstsIndex = 0, t._velocityOverLifetime = null, t._colorOverLifetime = null, t
					._sizeOverLifetime = null, t._rotationOverLifetime = null, t._textureSheetAnimation = null, t
					._startLifetimeType = 0, t._startLifetimeConstant = 0, t._startLifeTimeGradient = null, t
					._startLifetimeConstantMin = 0, t._startLifetimeConstantMax = 0, t._startLifeTimeGradientMin =
					null, t._startLifeTimeGradientMax = null, t._maxStartLifetime = 0, t._uvLength = new n, t
					._vertexStride = 0, t._indexStride = 0, t._vertexBuffer = null, t._indexBuffer = null, t
					._bufferState = new oe, t._updateMask = 0, t._currentTime = 0, t._startUpdateLoopCount = 0, t
					._rand = null, t._randomSeeds = null, t.duration = 0, t.looping = !1, t.prewarm = !1, t
					.startDelayType = 0, t.startDelay = 0, t.startDelayMin = 0, t.startDelayMax = 0, t
					.startSpeedType = 0, t.startSpeedConstant = 0, t.startSpeedConstantMin = 0, t
					.startSpeedConstantMax = 0, t.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant =
					0, t.startSizeConstantSeparate = null, t.startSizeConstantMin = 0, t.startSizeConstantMax = 0, t
					.startSizeConstantMinSeparate = null, t.startSizeConstantMaxSeparate = null, t
					.threeDStartRotation = !1, t.startRotationType = 0, t.startRotationConstant = 0, t
					.startRotationConstantSeparate = null, t.startRotationConstantMin = 0, t
					.startRotationConstantMax = 0, t.startRotationConstantMinSeparate = null, t
					.startRotationConstantMaxSeparate = null, t.randomizeRotationDirection = 0, t.startColorType =
					0, t.startColorConstant = new i(1, 1, 1, 1), t.startColorConstantMin = new i(0, 0, 0, 0), t
					.startColorConstantMax = new i(1, 1, 1, 1), t.gravityModifier = 0, t.simulationSpace = 0, t
					.simulationSpeed = 1, t.scaleMode = 1, t.playOnAwake = !1, t.randomSeed = null, t
					.autoRandomSeed = !1, t.isPerformanceMode = !1, t._firstActiveElement = 0, t._firstNewElement =
					0, t._firstFreeElement = 0, t._firstRetiredElement = 0, t._owner = e, t._ownerRender = e
					.particleRenderer, t._boundingBoxCorners = [], t._boundingSphere = new Jt(new o, Number
						.MAX_VALUE), t._boundingBox = new Lt(new o(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number
						.MAX_VALUE), new o(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)), t._bounds =
					new Pt(t._boundingBox.min, t._boundingBox.max), t._useCustomBounds = !1, t._currentTime = 0, t
					._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t._burstsIndex = 0, t._frameRateTime =
					0, t._emissionTime = 0, t._totalDelayTime = 0, t._simulateUpdate = !1, t._bufferMaxParticles =
					1, t.duration = 5, t.looping = !0, t.prewarm = !1, t.startDelayType = 0, t.startDelay = 0, t
					.startDelayMin = 0, t.startDelayMax = 0, t._startLifetimeType = 0, t._startLifetimeConstant = 5,
					t._startLifeTimeGradient = new Nr, t._startLifetimeConstantMin = 0, t
					._startLifetimeConstantMax = 5, t._startLifeTimeGradientMin = new Nr, t
					._startLifeTimeGradientMax = new Nr, t._maxStartLifetime = 5, t.startSpeedType = 0, t
					.startSpeedConstant = 5, t.startSpeedConstantMin = 0, t.startSpeedConstantMax = 5, t
					.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant = 1, t
					.startSizeConstantSeparate = new o(1, 1, 1), t.startSizeConstantMin = 0, t
					.startSizeConstantMax = 1, t.startSizeConstantMinSeparate = new o(0, 0, 0), t
					.startSizeConstantMaxSeparate = new o(1, 1, 1), t.threeDStartRotation = !1, t
					.startRotationType = 0, t.startRotationConstant = 0, t.startRotationConstantSeparate = new o(0,
						0, 0), t.startRotationConstantMin = 0, t.startRotationConstantMax = 0, t
					.startRotationConstantMinSeparate = new o(0, 0, 0), t.startRotationConstantMaxSeparate = new o(
						0, 0, 0), t.gravityModifier = 0, t.simulationSpace = 1, t.scaleMode = 1, t.playOnAwake = !0,
					t._rand = new en(0), t.autoRandomSeed = !0, t.randomSeed = new Uint32Array(1), t._randomSeeds =
					new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length), t.isPerformanceMode = !0, t
					._emission = new tn, t._emission.enable = !0, t
			}
			return _inherits(ShurikenParticleSystem, r), _createClass(ShurikenParticleSystem, [{
				key: "_getVertexBuffer",
				value: function() {
					var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
					return 0 === e ? this._vertexBuffer : null
				}
			}, {
				key: "_getIndexBuffer",
				value: function() {
					return this._indexBuffer
				}
			}, {
				key: "_generateBoundingSphere",
				value: function() {
					var e = this._boundingSphere.center;
					e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE
				}
			}, {
				key: "_generateBoundingBox",
				value: function() {
					var e, t, r, n, i, a, s, l, u, c = this._owner.particleRenderer,
						h = this._boundingBox.min,
						_ = this._boundingBox.max;
					switch (this.startLifetimeType) {
						case 0:
							r = this.startLifetimeConstant;
							break;
						case 1:
							r = -Number.MAX_VALUE;
							var d = d;
							for (e = 0, t = d.gradientCount; e < t; e++) r = Math.max(r, d
								.getValueByIndex(e));
							break;
						case 2:
							r = Math.max(this.startLifetimeConstantMin, this
								.startLifetimeConstantMax);
							break;
						case 3:
							r = -Number.MAX_VALUE;
							var f = f;
							for (e = 0, t = f.gradientCount; e < t; e++) r = Math.max(r, f
								.getValueByIndex(e));
							var m = m;
							for (e = 0, t = m.gradientCount; e < t; e++) r = Math.max(r, m
								.getValueByIndex(e))
					}
					switch (this.startSpeedType) {
						case 0:
							n = i = this.startSpeedConstant;
							break;
						case 1:
							break;
						case 2:
							n = this.startLifetimeConstantMin, i = this.startLifetimeConstantMax
					}
					this._shape && this._shape.enable || (a = s = o._ZERO, l = o._ZERO, u = o
						._UnitZ);
					var p, T, E = new o(l.x * n, l.y * n, l.z * n),
						g = new o(u.x * i, u.y * i, u.z * i);
					if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
						var y = this._velocityOverLifetime.velocity;
						switch (y.type) {
							case 0:
								y.constant;
								break;
							case 1:
								new o(y.gradientX.getAverageValue(), y.gradientY.getAverageValue(),
									y.gradientZ.getAverageValue());
								break;
							case 2:
								y.constantMin, y.constantMax;
								break;
							case 3:
								new o(y.gradientXMin.getAverageValue(), y.gradientYMin
										.getAverageValue(), y.gradientZMin.getAverageValue()),
									new o(y.gradientXMax.getAverageValue(), y.gradientYMax
										.getAverageValue(), y.gradientZMax.getAverageValue())
						}
					}
					var S, v, R, C, M = this._owner.transform,
						D = M.position,
						x = ShurikenParticleSystem._tempVector39,
						A = c.renderMode;
					switch (this.scaleMode) {
						case 0:
							var I = M.getWorldLossyScale();
							p = I, x.x = I.x, x.y = I.z, x.z = I.y, 1 === A && (T = I);
							break;
						case 1:
							var L = M.localScale;
							p = L, x.x = L.x, x.y = L.z, x.z = L.y, 1 === A && (T = L);
							break;
						case 2:
							p = M.getWorldLossyScale(), x.x = x.y = x.z = 1, 1 === A && (T = o._ONE)
					}
					switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (S =
						new o(E.x * r, E.y * r, E.z * r), v = new o(g.x * r, g.y * r, g.z * r),
						2 != this.scaleMode ? (o.add(a, S, h), o.multiply(p, h, h), o.add(s, v,
							_), o.multiply(p, _, _)) : (o.multiply(p, a, h), o.add(h, S, h), o
							.multiply(p, s, _), o.add(_, v, _))), this.simulationSpace) {
						case 0:
							break;
						case 1:
							o.add(h, D, h), o.add(_, D, _)
					}
					switch (this.startSizeType) {
						case 0:
							if (this.threeDStartSize) {
								var P = P;
								R = Math.max(P.x, P.y), 1 === A && (C = P.y)
							} else R = this.startSizeConstant, 1 === A && (C = this
								.startSizeConstant);
							break;
						case 1:
							break;
						case 2:
							if (this.threeDStartSize) {
								var O = O;
								R = Math.max(O.x, O.y), 1 === A && (C = O.y)
							} else R = this.startSizeConstantMax, 1 === A && (C = this
								.startSizeConstantMax)
					}
					if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
						this._sizeOverLifetime.size;
						R *= this._sizeOverLifetime.size.getMaxSizeInGradient()
					}
					var N, b, k = ShurikenParticleSystem._tempVector30;
					switch (A) {
						case 0:
							N = R * ShurikenParticleSystem.halfKSqrtOf2, o.scale(x, R, k), o
								.subtract(h, k, h), o.add(_, k, _);
							break;
						case 1:
							var w = ShurikenParticleSystem._tempVector31,
								B = ShurikenParticleSystem._tempVector32,
								V = ShurikenParticleSystem._tempVector33,
								F = ShurikenParticleSystem._tempVector34;
							this._velocityOverLifetime && this._velocityOverLifetime.enable || (o
								.multiply(T, g, B), o.multiply(T, E, V));
							var U = C * c.stretchedBillboardLengthScale,
								G = o.scalarLength(B) * c.stretchedBillboardSpeedScale + U,
								H = o.scalarLength(V) * c.stretchedBillboardSpeedScale + U,
								z = ShurikenParticleSystem._tempVector35,
								W = ShurikenParticleSystem._tempVector36;
							o.normalize(B, z), o.scale(z, G, F), o.subtract(v, F, F), o.normalize(V,
									W), o.scale(W, H, w), o.add(S, w, w), N = R *
								ShurikenParticleSystem.halfKSqrtOf2, o.scale(x, N, k);
							var X = ShurikenParticleSystem._tempVector37,
								Y = ShurikenParticleSystem._tempVector38;
							o.scale(z, .5, X), o.scale(W, .5, Y), o.multiply(X, x, X), o.multiply(Y,
									x, Y), o.add(h, Y, h), o.min(h, F, h), o.subtract(h, k, h), o
								.subtract(_, X, _), o.max(_, w, _), o.add(_, k, _);
							break;
						case 2:
							b = .5 * (R *= Math.cos(.7853981633974483)), k.x = x.x * b, k.y = x.z *
								b, o.subtract(h, k, h), o.add(_, k, _);
							break;
						case 3:
							b = .5 * (R *= Math.cos(.7853981633974483)), o.scale(x, b, k), o
								.subtract(h, k, h), o.add(_, k, _)
					}
					this._boundingBox.getCorners(this._boundingBoxCorners)
				}
			}, {
				key: "_generateBounds",
				value: function() {
					var t = this._owner.particleRenderer,
						r = this._bounds.getMin(),
						n = this._bounds.getMax(),
						i = 0;
					switch (this.startLifetimeType) {
						case 0:
							i = this._startLifetimeConstant;
							break;
						case 2:
							i = this._startLifetimeConstantMax
					}
					var a = 0;
					switch (this.startSpeedType) {
						case 0:
							a = this.startSpeedConstant;
							break;
						case 2:
							a = this.startSpeedConstantMax
					}
					var s = 0;
					if (this.threeDStartSize) switch (this.startSizeType) {
						case 0:
							s = Math.max(this.startSizeConstantSeparate.x, this
								.startSizeConstantSeparate.y, this.startSizeConstantSeparate
								.z);
							break;
						case 2:
							s = Math.max(this.startSizeConstantMaxSeparate.x, this
								.startSizeConstantMaxSeparate.y, this
								.startSizeConstantMaxSeparate.z)
					} else switch (this.startSizeType) {
						case 0:
							s = this.startSizeConstant;
							break;
						case 2:
							s = this.startSizeConstantMax
					}
					var l = ShurikenParticleSystem._tempVector30,
						u = ShurikenParticleSystem._tempVector31,
						c = ShurikenParticleSystem._tempVector32,
						h = ShurikenParticleSystem._tempVector33;
					if (l.setValue(0, 0, 1), u.setValue(0, 0, 0), c.setValue(0, 0, 0), h.setValue(0,
							0, 0), this.shape && this.shape.enable) switch (this.shape.shapeType) {
						case e.ParticleSystemShapeType.Sphere:
							var _ = this.shape;
							l.setValue(1, 1, 1), u.setValue(1, 1, 1), c.setValue(_.radius, _
								.radius, _.radius), h.setValue(_.radius, _.radius, _.radius);
							break;
						case e.ParticleSystemShapeType.Hemisphere:
							var d = this.shape;
							l.setValue(1, 1, 1), u.setValue(1, 1, 1), c.setValue(d.radius, d
								.radius, d.radius), h.setValue(d.radius, d.radius, 0);
							break;
						case e.ParticleSystemShapeType.Cone:
							var f = this.shape;
							if (0 == f.emitType || 1 == f.emitType) {
								var m = f.angle,
									p = Math.sin(m);
								l.setValue(p, p, 1), u.setValue(p, p, 0), c.setValue(f.radius, f
									.radius, 0), h.setValue(f.radius, f.radius, 0);
								break
							}
							if (2 == f.emitType || 3 == f.emitType) {
								m = f.angle, p = Math.sin(m);
								var T = f.length;
								l.setValue(p, p, 1), u.setValue(p, p, 0);
								var E = Math.tan(m),
									g = f.radius + T * E;
								c.setValue(g, g, T), h.setValue(g, g, 0)
							}
							break;
						case e.ParticleSystemShapeType.Box:
							var y = this.shape;
							0 != this.shape.randomDirection && (l.setValue(1, 1, 1), u.setValue(
									1, 1, 1)), c.setValue(y.x / 2, y.y / 2, y.z / 2), h
								.setValue(y.x / 2, y.y / 2, y.z / 2);
							break;
						case e.ParticleSystemShapeType.Circle:
							var S = this.shape;
							l.setValue(1, 1, 1), u.setValue(1, 1, 1), c.setValue(S.radius, S
								.radius, 0), h.setValue(S.radius, S.radius, 0)
					}
					var v = 0,
						R = 4 == t.renderMode;
					switch (t.renderMode) {
						case 0:
						case 1:
						case 2:
						case 3:
							v = ShurikenParticleSystem.halfKSqrtOf2;
							break;
						case 4:
							var C = t.mesh.bounds;
							v = Math.sqrt(Math.pow(C.getExtent().x, 2) + Math.pow(C.getExtent().y,
								2) + Math.pow(C.getExtent().z, 2))
					}
					var M = ShurikenParticleSystem._tempVector36;
					if (M.setValue(1, 1, 1), this.sizeOverLifetime && this.sizeOverLifetime
						.enable) {
						var D = this.sizeOverLifetime.size.getMaxSizeInGradient(R);
						M.setValue(D, D, D)
					}
					var x = v * s;
					o.scale(M, x, M);
					var A = ShurikenParticleSystem._tempVector34,
						I = ShurikenParticleSystem._tempVector35;
					if (a > 0 ? (o.scale(l, a, A), o.scale(u, a, I)) : (o.scale(l, -a, I), o.scale(
							u, -a, A)), this.velocityOverLifetime && this.velocityOverLifetime
						.enable) {
						var L = this.velocityOverLifetime.velocity,
							P = ShurikenParticleSystem._tempVector37;
						switch (P.setValue(0, 0, 0), L.type) {
							case 0:
								L.constant.cloneTo(P);
								break;
							case 2:
								L.constantMax.cloneTo(P);
								break;
							case 1:
								var O = L.gradientX.getAverageValue(),
									N = L.gradientY.getAverageValue(),
									b = L.gradientZ.getAverageValue();
								P.setValue(O, N, b);
								break;
							case 3:
								var k = L.gradientXMax.getAverageValue(),
									w = L.gradientYMax.getAverageValue(),
									B = L.gradientZMax.getAverageValue();
								P.setValue(k, w, B)
						}
						1 == this.velocityOverLifetime.space && o.transformV3ToV3(P, this._owner
								.transform.worldMatrix, P), o.add(A, P, A), o.subtract(I, P, I), o
							.max(A, o._ZERO, A), o.max(I, o._ZERO, I)
					}
					o.scale(A, i, A), o.scale(I, i, I);
					var V = this.gravityModifier;
					if (0 != V) {
						var F = .5 * ShurikenParticleSystem.g * V * i * i,
							U = A.y - F,
							G = I.y + F;
						U = U > 0 ? U : 0, G = G > 0 ? G : 0, this._gravityOffset.setValue(A.y - U,
							G - I.y)
					}
					o.add(A, M, n), o.add(n, c, n), o.add(I, M, r), o.add(r, h, r), o.scale(r, -1,
						r), this._bounds.setMin(r), this._bounds.setMax(n)
				}
			}, {
				key: "_simulationSupported",
				value: function() {
					return 0 != this.simulationSpace
				}
			}, {
				key: "_updateEmission",
				value: function() {
					if (this.isAlive)
						if (this._simulateUpdate) this._simulateUpdate = !1;
						else {
							var e = this._startUpdateLoopCount === t.Stat.loopCount || this
								._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
							e = Math.min(ShurikenParticleSystem._maxElapsedTime, e * this
								.simulationSpeed), this._updateParticles(e)
						}
				}
			}, {
				key: "_updateParticles",
				value: function(e) {
					(4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this
						._currentTime += e, this._retireActiveParticles(), this
						._freeRetiredParticles(), this._totalDelayTime += e, this._totalDelayTime <
						this._playStartDelay || this._emission.enable && this._isEmitting && !this
						._isPaused && this._advanceTime(e, this._currentTime))
				}
			}, {
				key: "_updateParticlesSimulationRestart",
				value: function(e) {
					this._firstActiveElement = 0, this._firstNewElement = 0, this
						._firstFreeElement = 0, this._firstRetiredElement = 0, this._burstsIndex =
						0, this._frameRateTime = e, this._emissionTime = 0, this._totalDelayTime =
						0, this._currentTime = e;
					var t = e;
					t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable &&
						this._advanceTime(e, e)
				}
			}, {
				key: "_retireActiveParticles",
				value: function() {
					for (; this._firstActiveElement != this._firstNewElement;) {
						var e = this._firstActiveElement * this._floatCountPerVertex * this
							._vertexStride,
							t = e + this._timeIndex;
						if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this
								._startLifeTimeIndex]) break;
						this._vertices[t] = this._drawCounter, this._firstActiveElement++, this
							._firstActiveElement >= this._bufferMaxParticles && (this
								._firstActiveElement = 0)
					}
				}
			}, {
				key: "_freeRetiredParticles",
				value: function() {
					for (; this._firstRetiredElement != this._firstActiveElement;) {
						this._drawCounter, this._vertices[this._firstRetiredElement * this
							._floatCountPerVertex * this._vertexStride + this._timeIndex];
						this._firstRetiredElement++, this._firstRetiredElement >= this
							._bufferMaxParticles && (this._firstRetiredElement = 0)
					}
				}
			}, {
				key: "_burst",
				value: function(e, r) {
					for (var n = 0, i = this._emission._bursts, a = i.length; this._burstsIndex <
						a; this._burstsIndex++) {
						var o, s = i[this._burstsIndex],
							l = s.time;
						if (!(e <= l && l < r)) break;
						this.autoRandomSeed ? o = t.MathUtil.lerp(s.minCount, s.maxCount, Math
							.random()) : (this._rand.seed = this._randomSeeds[0], o = t.MathUtil
							.lerp(s.minCount, s.maxCount, this._rand.getFloat()), this
							._randomSeeds[0] = this._rand.seed), n += o
					}
					return n
				}
			}, {
				key: "_advanceTime",
				value: function(e, t) {
					var r, n = this._emissionTime;
					this._emissionTime += e;
					var i = 0;
					if (this._emissionTime > this.duration) {
						if (!this.looping) {
							for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), r =
								0; r < i; r++) this.emit(t);
							return this._isPlaying = !1, void this.stop()
						}
						i += this._burst(n, this._emissionTime), this._emissionTime -= this
							.duration, this._burstsIndex = 0, i += this._burst(0, this
								._emissionTime)
					} else i += this._burst(n, this._emissionTime);
					for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), r = 0; r <
						i; r++) this.emit(t);
					var a = this.emission.emissionRate;
					if (a > 0) {
						var o = 1 / a;
						for (this._frameRateTime += o, this._frameRateTime = this._currentTime - (
								this._currentTime - this._frameRateTime) % this
							._maxStartLifetime; this._frameRateTime <= t && this.emit(this
								._frameRateTime);) this._frameRateTime += o;
						this._frameRateTime = Math.floor(t / o) * o
					}
				}
			}, {
				key: "_initBufferDatas",
				value: function() {
					if (this._vertexBuffer) {
						var r = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
						this._vertexBuffer.destroy(), this._indexBuffer.destroy(), t.Resource
							._addMemory(-r, -r)
					}
					var n = t.LayaGL.instance,
						i = this._ownerRender,
						a = i.renderMode;
					if (-1 !== a && this.maxParticles > 0) {
						var o, s, l, u, c, h, _, d = 0,
							f = (r = 0, i.mesh);
						if (4 === a) {
							if (f) {
								_ = $r.vertexDeclaration, this._floatCountPerVertex = _
									.vertexStride / 4, this._startLifeTimeIndex = 12, this
									._timeIndex = 16, this._vertexStride = f._vertexCount;
								var m = this._bufferMaxParticles * this._vertexStride,
									p = m % 65535;
								if (Math.floor(m / 65535) + 1 > 1) throw new Error(
									"ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535."
									);
								d = _.vertexStride * p, this._vertexBuffer = new te(d, n
										.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _,
									this._vertices = new Float32Array(this._floatCountPerVertex *
									p), this._indexStride = f._indexBuffer.indexCount;
								var T = f._indexBuffer.getData(),
									E = this._bufferMaxParticles * this._indexStride;
								for (this._indexBuffer = new Oe(e.IndexFormat.UInt16, E, n
										.STATIC_DRAW), o = new Uint16Array(E), r = d + 2 * E, c = 0,
									s = 0; s < this._bufferMaxParticles; s++) {
									var g = s * this._vertexStride;
									for (l = 0, u = T.length; l < u; l++) o[c++] = g + T[l]
								}
								this._indexBuffer.setData(o), this._bufferState.bind(), this
									._bufferState.applyVertexBuffer(this._vertexBuffer), this
									._bufferState.applyIndexBuffer(this._indexBuffer), this
									._bufferState.unBind()
							}
						} else {
							for (_ = Jr.vertexDeclaration, this._floatCountPerVertex = _
								.vertexStride / 4, this._startLifeTimeIndex = 7, this._timeIndex =
								11, this._vertexStride = 4, d = _.vertexStride * this
								._bufferMaxParticles * this._vertexStride, this._vertexBuffer =
								new te(d, n.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _,
								this._vertices = new Float32Array(this._floatCountPerVertex * this
									._bufferMaxParticles * this._vertexStride), s = 0; s < this
								._bufferMaxParticles; s++) h = s * this._floatCountPerVertex * this
								._vertexStride, this._vertices[h] = -.5, this._vertices[h + 1] = -
								.5, this._vertices[h + 2] = 0, this._vertices[h + 3] = 1, h += this
								._floatCountPerVertex, this._vertices[h] = .5, this._vertices[h +
								1] = -.5, this._vertices[h + 2] = 1, this._vertices[h + 3] = 1, h +=
								this._floatCountPerVertex, this._vertices[h] = .5, this._vertices[
									h + 1] = .5, this._vertices[h + 2] = 1, this._vertices[h + 3] =
								0, h += this._floatCountPerVertex, this._vertices[h] = -.5, this
								._vertices[h + 1] = .5, this._vertices[h + 2] = 0, this._vertices[
									h + 3] = 0;
							for (this._indexStride = 6, this._indexBuffer = new Oe(e.IndexFormat
									.UInt16, 6 * this._bufferMaxParticles, n.STATIC_DRAW), o =
								new Uint16Array(6 * this._bufferMaxParticles), s = 0; s < this
								._bufferMaxParticles; s++) {
								c = 6 * s;
								var y = s * this._vertexStride,
									S = y + 2;
								o[c++] = y, o[c++] = S, o[c++] = y + 1, o[c++] = y, o[c++] = y + 3,
									o[c++] = S
							}
							this._indexBuffer.setData(o), r = d + 6 * this._bufferMaxParticles * 2,
								this._bufferState.bind(), this._bufferState.applyVertexBuffer(this
									._vertexBuffer), this._bufferState.applyIndexBuffer(this
									._indexBuffer), this._bufferState.unBind()
						}
						t.Resource._addMemory(r, r)
					}
				}
			}, {
				key: "destroy",
				value: function() {
					_get(_getPrototypeOf(ShurikenParticleSystem.prototype), "destroy", this).call(
						this);
					var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
					t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer
						.destroy(), this._indexBuffer.destroy(), this._emission.destroy(), this
						._boundingBox = null, this._boundingSphere = null, this
						._boundingBoxCorners = null, this._bounds = null, this._customBounds = null,
						this._bufferState = null, this._vertexBuffer = null, this._indexBuffer =
						null, this._owner = null, this._vertices = null, this._indexBuffer = null,
						this._emission = null, this._shape = null, this.startLifeTimeGradient =
						null, this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax =
						null, this.startSizeConstantSeparate = null, this
						.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate =
						null, this.startRotationConstantSeparate = null, this
						.startRotationConstantMinSeparate = null, this
						.startRotationConstantMaxSeparate = null, this.startColorConstant = null,
						this.startColorConstantMin = null, this.startColorConstantMax = null, this
						._velocityOverLifetime = null, this._colorOverLifetime = null, this
						._sizeOverLifetime = null, this._rotationOverLifetime = null, this
						._textureSheetAnimation = null
				}
			}, {
				key: "emit",
				value: function(e) {
					var t = ShurikenParticleSystem._tempPosition,
						r = ShurikenParticleSystem._tempDirection;
					return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape
						.generatePositionAndDirection(t, r) : this._shape
						.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x =
							t.y = t.z = 0, r.x = r.y = 0, r.z = 1), this.addParticle(t, r, e)
				}
			}, {
				key: "addParticle",
				value: function(e, r, n) {
					o.normalize(r, r);
					var i = this._firstFreeElement + 1;
					if (i >= this._bufferMaxParticles && (i = 0), i === this._firstRetiredElement)
						return !1;
					var a, s, l, u, c, h, _, d, f, m, p = this._owner.transform;
					if (rn.create(this, this._ownerRender, p), this._currentTime - n >= rn
						.startLifeTime) return !0;
					switch (0 == this.simulationSpace && (a = p.position, s = p.rotation), this
						.startSpeedType) {
						case 0:
							l = this.startSpeedConstant;
							break;
						case 2:
							this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin,
								this.startSpeedConstantMax, Math.random()) : (this._rand.seed =
								this._randomSeeds[8], l = t.MathUtil.lerp(this
									.startSpeedConstantMin, this.startSpeedConstantMax, this
									._rand.getFloat()), this._randomSeeds[8] = this._rand.seed)
					}
					var T = this._velocityOverLifetime && this._velocityOverLifetime.enable;
					if (T) {
						var E = this._velocityOverLifetime.velocity.type;
						2 === E || 3 === E ? this.autoRandomSeed ? (u = Math.random(), c = Math
							.random(), h = Math.random()) : (this._rand.seed = this
							._randomSeeds[9], u = this._rand.getFloat(), c = this._rand
							.getFloat(), h = this._rand.getFloat(), this._randomSeeds[9] = this
							._rand.seed) : T = !1
					} else T = !1;
					var g = this._colorOverLifetime && this._colorOverLifetime.enable;
					g ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? _ = Math
						.random() : (this._rand.seed = this._randomSeeds[10], _ = this._rand
							.getFloat(), this._randomSeeds[10] = this._rand.seed) : g = !1 : g = !1;
					var y = this._sizeOverLifetime && this._sizeOverLifetime.enable;
					y ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? d = Math
						.random() : (this._rand.seed = this._randomSeeds[11], d = this._rand
							.getFloat(), this._randomSeeds[11] = this._rand.seed) : y = !1 : y = !1;
					var S = this._rotationOverLifetime && this._rotationOverLifetime.enable;
					if (S) {
						var v = this._rotationOverLifetime.angularVelocity.type;
						2 === v || 3 === v ? this.autoRandomSeed ? f = Math.random() : (this._rand
							.seed = this._randomSeeds[12], f = this._rand.getFloat(), this
							._randomSeeds[12] = this._rand.seed) : S = !1
					} else S = !1;
					var R = this._textureSheetAnimation && this._textureSheetAnimation.enable;
					R ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? m =
						Math.random() : (this._rand.seed = this._randomSeeds[15], m = this._rand
							.getFloat(), this._randomSeeds[15] = this._rand.seed) : R = !1 : R = !1;
					var C, M, D, x, A, I, L = this._firstFreeElement * this._floatCountPerVertex *
						this._vertexStride,
						P = rn.startUVInfo[0],
						O = rn.startUVInfo[1],
						N = rn.startUVInfo[2],
						b = rn.startUVInfo[3],
						k = this._ownerRender;
					if (4 === k.renderMode) {
						var w = k.mesh._vertexBuffer;
						C = w.getFloat32Data();
						var B = w.vertexDeclaration;
						D = B.getVertexElementByUsage(Ne.MESH_POSITION0)._offset / 4;
						var V = B.getVertexElementByUsage(Ne.MESH_COLOR0);
						x = V ? V._offset / 4 : -1;
						var F = B.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0);
						A = F ? F._offset / 4 : -1, M = B.vertexStride / 4, I = 0
					} else {
						this._vertices[L + 2] = N, this._vertices[L + 3] = b + O;
						var U = L + this._floatCountPerVertex;
						this._vertices[U + 2] = N + P, this._vertices[U + 3] = b + O;
						var G = U + this._floatCountPerVertex;
						this._vertices[G + 2] = N + P, this._vertices[G + 3] = b;
						var H = G + this._floatCountPerVertex;
						this._vertices[H + 2] = N, this._vertices[H + 3] = b
					}
					for (var z = L, W = L + this._floatCountPerVertex * this._vertexStride; z <
						W; z += this._floatCountPerVertex) {
						var X;
						if (4 === k.renderMode) {
							X = z;
							var Y = M * I++,
								j = Y + D;
							this._vertices[X++] = C[j++], this._vertices[X++] = C[j++], this
								._vertices[X++] = C[j], -1 === x ? (this._vertices[X++] = 1, this
									._vertices[X++] = 1, this._vertices[X++] = 1, this._vertices[
										X++] = 1) : (j = Y + x, this._vertices[X++] = C[j++], this
									._vertices[X++] = C[j++], this._vertices[X++] = C[j++], this
									._vertices[X++] = C[j]), -1 === A ? (this._vertices[X++] = 0,
									this._vertices[X++] = 0) : (j = Y + A, this._vertices[X++] = N +
									C[j++] * P, this._vertices[X++] = b + C[j] * O)
						} else X = z + 4;
						switch (this._vertices[X++] = e.x, this._vertices[X++] = e.y, this
							._vertices[X++] = e.z, this._vertices[X++] = rn.startLifeTime, this
							._vertices[X++] = r.x, this._vertices[X++] = r.y, this._vertices[X++] =
							r.z, this._vertices[X++] = n, this._vertices[X++] = rn.startColor.x,
							this._vertices[X++] = rn.startColor.y, this._vertices[X++] = rn
							.startColor.z, this._vertices[X++] = rn.startColor.w, this._vertices[
								X++] = rn.startSize[0], this._vertices[X++] = rn.startSize[1], this
							._vertices[X++] = rn.startSize[2], this._vertices[X++] = rn
							.startRotation[0], this._vertices[X++] = rn.startRotation[1], this
							._vertices[X++] = rn.startRotation[2], this._vertices[X++] = l, g && (
								this._vertices[X + 1] = _), y && (this._vertices[X + 2] = d), S && (
								this._vertices[X + 3] = f), R && (this._vertices[X + 4] = m), T && (
								this._vertices[X + 5] = u, this._vertices[X + 6] = c, this
								._vertices[X + 7] = h), this.simulationSpace) {
							case 0:
								X += 8, this._vertices[X++] = a.x, this._vertices[X++] = a.y, this
									._vertices[X++] = a.z, this._vertices[X++] = s.x, this
									._vertices[X++] = s.y, this._vertices[X++] = s.z, this
									._vertices[X++] = s.w;
								break;
							case 1:
								break;
							default:
								throw new Error(
									"ShurikenParticleMaterial: SimulationSpace value is invalid."
									)
						}
					}
					return this._firstFreeElement = i, !0
				}
			}, {
				key: "addNewParticlesToVertexBuffer",
				value: function() {
					var e, t = this._vertexStride * this._floatCountPerVertex * 4;
					this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t,
							this._vertexBuffer.setData(this._vertices.buffer, e, e, (this
								._firstFreeElement - this._firstNewElement) * t)) : (e = this
							._firstNewElement * t, this._vertexBuffer.setData(this._vertices.buffer,
								e, e, (this._bufferMaxParticles - this._firstNewElement) * t), this
							._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices
								.buffer, 0, 0, this._firstFreeElement * t)), this._firstNewElement =
						this._firstFreeElement
				}
			}, {
				key: "_getType",
				value: function() {
					return ShurikenParticleSystem._type
				}
			}, {
				key: "_prepareRender",
				value: function(e) {
					return this._updateMask != t.Stat.loopCount && (this._updateMask = t.Stat
						.loopCount, this._updateEmission(), this._firstNewElement != this
						._firstFreeElement && this.addNewParticlesToVertexBuffer(), this
						._drawCounter++), this._firstActiveElement != this._firstFreeElement
				}
			}, {
				key: "_render",
				value: function(e) {
					var r;
					this._bufferState.bind();
					var n = t.LayaGL.instance;
					this._firstActiveElement < this._firstFreeElement ? (r = (this
							._firstFreeElement - this._firstActiveElement) * this._indexStride,
						n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this
							._firstActiveElement * this._indexStride), t.Stat.trianglesFaces +=
						r / 3, t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this
							._firstActiveElement) * this._indexStride, n.drawElements(n
							.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this._firstActiveElement * this
							._indexStride), t.Stat.trianglesFaces += r / 3, t.Stat
						.renderBatches++, this._firstFreeElement > 0 && (r = this
							._firstFreeElement * this._indexStride, n.drawElements(n.TRIANGLES,
								r, n.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3, t.Stat
							.renderBatches++))
				}
			}, {
				key: "play",
				value: function() {
					if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this
						._isPaused = !1, this._emissionTime = 0, this._totalDelayTime = 0, !this
						.autoRandomSeed)
						for (var e = 0, r = this._randomSeeds.length; e < r; e++) this._randomSeeds[
							e] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[e];
					switch (this.startDelayType) {
						case 0:
							this._playStartDelay = this.startDelay;
							break;
						case 1:
							this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this
								.startDelayMin, this.startDelayMax, Math.random()) : (this._rand
								.seed = this._randomSeeds[2], this._playStartDelay = t.MathUtil
								.lerp(this.startDelayMin, this.startDelayMax, this._rand
									.getFloat()), this._randomSeeds[2] = this._rand.seed);
							break;
						default:
							throw new Error("Utils3D: startDelayType is invalid.")
					}
					this._frameRateTime = this._currentTime + this._playStartDelay, this
						._startUpdateLoopCount = t.Stat.loopCount
				}
			}, {
				key: "pause",
				value: function() {
					this._isPaused = !0
				}
			}, {
				key: "simulate",
				value: function(e) {
					var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
					this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this
						._isPaused = !1, this._updateParticles(e)), this.pause()
				}
			}, {
				key: "stop",
				value: function() {
					this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e;
					t._useCustomBounds = this._useCustomBounds, this._customBounds && this
						._customBounds.cloneTo(t._customBounds), t.duration = this.duration, t
						.looping = this.looping, t.prewarm = this.prewarm, t.startDelayType = this
						.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this
						.startDelayMin, t.startDelayMax = this.startDelayMax, t._maxStartLifetime =
						this._maxStartLifetime, t.startLifetimeType = this.startLifetimeType, t
						.startLifetimeConstant = this.startLifetimeConstant, this
						.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t
						.startLifetimeConstantMin = this.startLifetimeConstantMin, t
						.startLifetimeConstantMax = this.startLifetimeConstantMax, this
						.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin), this
						.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t
						.startSpeedType = this.startSpeedType, t.startSpeedConstant = this
						.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin, t
						.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize =
						this.threeDStartSize, t.startSizeType = this.startSizeType, t
						.startSizeConstant = this.startSizeConstant, this.startSizeConstantSeparate
						.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this
						.startSizeConstantMin, t.startSizeConstantMax = this.startSizeConstantMax,
						this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate),
						this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t
						.threeDStartRotation = this.threeDStartRotation, t.startRotationType = this
						.startRotationType, t.startRotationConstant = this.startRotationConstant,
						this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate),
						t.startRotationConstantMin = this.startRotationConstantMin, t
						.startRotationConstantMax = this.startRotationConstantMax, this
						.startRotationConstantMinSeparate.cloneTo(t
							.startRotationConstantMinSeparate), this
						.startRotationConstantMaxSeparate.cloneTo(t
							.startRotationConstantMaxSeparate), t.randomizeRotationDirection = this
						.randomizeRotationDirection, t.startColorType = this.startColorType, this
						.startColorConstant.cloneTo(t.startColorConstant), this
						.startColorConstantMin.cloneTo(t.startColorConstantMin), this
						.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier =
						this.gravityModifier, t.simulationSpace = this.simulationSpace, t
						.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake, t
						.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0],
						t.maxParticles = this.maxParticles, this._emission && (t._emission = this
							._emission.clone()), this.shape && (t.shape = this.shape.clone()), this
						.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime
							.clone()), this.colorOverLifetime && (t.colorOverLifetime = this
							.colorOverLifetime.clone()), this.sizeOverLifetime && (t
							.sizeOverLifetime = this.sizeOverLifetime.clone()), this
						.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime
							.clone()), this.textureSheetAnimation && (t.textureSheetAnimation = this
							.textureSheetAnimation.clone()), t.isPerformanceMode = this
						.isPerformanceMode, t._isEmitting = this._isEmitting, t._isPlaying = this
						._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this
						._playStartDelay, t._frameRateTime = this._frameRateTime, t._emissionTime =
						this._emissionTime, t._totalDelayTime = this._totalDelayTime, t
						._burstsIndex = this._burstsIndex
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ShurikenParticleSystem(null);
					return this.cloneTo(e), e
				}
			}, {
				key: "maxParticles",
				get: function() {
					return this._bufferMaxParticles - 1
				},
				set: function(e) {
					var t = e + 1;
					t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this
						._initBufferDatas())
				}
			}, {
				key: "emission",
				get: function() {
					return this._emission
				}
			}, {
				key: "aliveParticleCount",
				get: function() {
					return this._firstNewElement >= this._firstRetiredElement ? this
						._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles -
						this._firstRetiredElement + this._firstNewElement
				}
			}, {
				key: "emissionTime",
				get: function() {
					return this._emissionTime > this.duration ? this.duration : this._emissionTime
				}
			}, {
				key: "shape",
				get: function() {
					return this._shape
				},
				set: function(e) {
					this._shape !== e && (e && e.enable ? this._owner._render._shaderValues
						.addDefine(Zr.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues
						.removeDefine(Zr.SHADERDEFINE_SHAPE), this._shape = e)
				}
			}, {
				key: "isAlive",
				get: function() {
					return !!(this._isPlaying || this.aliveParticleCount > 0)
				}
			}, {
				key: "isEmitting",
				get: function() {
					return this._isEmitting
				}
			}, {
				key: "isPlaying",
				get: function() {
					return this._isPlaying
				}
			}, {
				key: "isPaused",
				get: function() {
					return this._isPaused
				}
			}, {
				key: "startLifetimeType",
				get: function() {
					return this._startLifetimeType
				},
				set: function(e) {
					var t, r;
					switch (this.startLifetimeType) {
						case 0:
							this._maxStartLifetime = this.startLifetimeConstant;
							break;
						case 1:
							this._maxStartLifetime = -Number.MAX_VALUE;
							var n = n;
							for (t = 0, r = n.gradientCount; t < r; t++) this._maxStartLifetime =
								Math.max(this._maxStartLifetime, n.getValueByIndex(t));
							break;
						case 2:
							this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this
								.startLifetimeConstantMax);
							break;
						case 3:
							this._maxStartLifetime = -Number.MAX_VALUE;
							var i = i;
							for (t = 0, r = i.gradientCount; t < r; t++) this._maxStartLifetime =
								Math.max(this._maxStartLifetime, i.getValueByIndex(t));
							var a = a;
							for (t = 0, r = a.gradientCount; t < r; t++) this._maxStartLifetime =
								Math.max(this._maxStartLifetime, a.getValueByIndex(t))
					}
					this._startLifetimeType = e
				}
			}, {
				key: "startLifetimeConstant",
				get: function() {
					return this._startLifetimeConstant
				},
				set: function(e) {
					0 === this._startLifetimeType && (this._maxStartLifetime = e), this
						._startLifetimeConstant = e
				}
			}, {
				key: "startLifeTimeGradient",
				get: function() {
					return this._startLifeTimeGradient
				},
				set: function(e) {
					if (1 === this._startLifetimeType) {
						this._maxStartLifetime = -Number.MAX_VALUE;
						for (var t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime =
							Math.max(this._maxStartLifetime, e.getValueByIndex(t))
					}
					this._startLifeTimeGradient = e
				}
			}, {
				key: "startLifetimeConstantMin",
				get: function() {
					return this._startLifetimeConstantMin
				},
				set: function(e) {
					2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this
						._startLifetimeConstantMax)), this._startLifetimeConstantMin = e
				}
			}, {
				key: "startLifetimeConstantMax",
				get: function() {
					return this._startLifetimeConstantMax
				},
				set: function(e) {
					2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this
						._startLifetimeConstantMin, e)), this._startLifetimeConstantMax = e
				}
			}, {
				key: "startLifeTimeGradientMin",
				get: function() {
					return this._startLifeTimeGradientMin
				},
				set: function(e) {
					if (3 === this._startLifetimeType) {
						var t, r;
						for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = e
							.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this
							._maxStartLifetime, e.getValueByIndex(t));
						for (t = 0, r = this._startLifeTimeGradientMax.gradientCount; t < r; t++)
							this._maxStartLifetime = Math.max(this._maxStartLifetime, this
								._startLifeTimeGradientMax.getValueByIndex(t))
					}
					this._startLifeTimeGradientMin = e
				}
			}, {
				key: "startLifeTimeGradientMax",
				get: function() {
					return this._startLifeTimeGradientMax
				},
				set: function(e) {
					if (3 === this._startLifetimeType) {
						var t, r;
						for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = this
							._startLifeTimeGradientMin.gradientCount; t < r; t++) this
							._maxStartLifetime = Math.max(this._maxStartLifetime, this
								._startLifeTimeGradientMin.getValueByIndex(t));
						for (t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math
							.max(this._maxStartLifetime, e.getValueByIndex(t))
					}
					this._startLifeTimeGradientMax = e
				}
			}, {
				key: "velocityOverLifetime",
				get: function() {
					return this._velocityOverLifetime
				},
				set: function(e) {
					var t = this._owner._render._shaderValues;
					if (e) {
						var r = e.velocity,
							n = r.type;
						if (e.enable) switch (n) {
							case 0:
								t.addDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
								break;
							case 1:
								t.addDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
								break;
							case 2:
								t.addDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
								break;
							case 3:
								t.addDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE)
						} else t.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t
							.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), t
							.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t
							.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
						switch (n) {
							case 0:
								t.setVector3(Zr.VOLVELOCITYCONST, r.constant);
								break;
							case 1:
								t.setBuffer(Zr.VOLVELOCITYGRADIENTX, r.gradientX._elements), t
									.setBuffer(Zr.VOLVELOCITYGRADIENTY, r.gradientY._elements), t
									.setBuffer(Zr.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
								break;
							case 2:
								t.setVector3(Zr.VOLVELOCITYCONST, r.constantMin), t.setVector3(Zr
									.VOLVELOCITYCONSTMAX, r.constantMax);
								break;
							case 3:
								t.setBuffer(Zr.VOLVELOCITYGRADIENTX, r.gradientXMin._elements), t
									.setBuffer(Zr.VOLVELOCITYGRADIENTXMAX, r.gradientXMax
									._elements), t.setBuffer(Zr.VOLVELOCITYGRADIENTY, r.gradientYMin
										._elements), t.setBuffer(Zr.VOLVELOCITYGRADIENTYMAX, r
										.gradientYMax._elements), t.setBuffer(Zr
										.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements), t
									.setBuffer(Zr.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements)
						}
						t.setInt(Zr.VOLSPACETYPE, e.space)
					} else t.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t
						.removeDefine(Zr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE), t.removeDefine(Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
					this._velocityOverLifetime = e
				}
			}, {
				key: "colorOverLifetime",
				get: function() {
					return this._colorOverLifetime
				},
				set: function(e) {
					var t = this._owner._render._shaderValues;
					if (e) {
						var r = e.color;
						if (e.enable) switch (r.type) {
							case 1:
								t.addDefine(Zr.SHADERDEFINE_COLOROVERLIFETIME);
								break;
							case 3:
								t.addDefine(Zr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME)
						} else t.removeDefine(Zr.SHADERDEFINE_COLOROVERLIFETIME), t
							.removeDefine(Zr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
						switch (r.type) {
							case 1:
								var n = r.gradient;
								t.setBuffer(Zr.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t
									.setBuffer(Zr.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
								break;
							case 3:
								var i = r.gradientMin,
									a = r.gradientMax;
								t.setBuffer(Zr.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t
									.setBuffer(Zr.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements), t
									.setBuffer(Zr.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements),
									t.setBuffer(Zr.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements)
						}
					} else t.removeDefine(Zr.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Zr
						.SHADERDEFINE_RANDOMCOLOROVERLIFETIME), t.setBuffer(Zr
						.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Zr
						.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements), t.setBuffer(Zr
						.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Zr
						.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements), t.setBuffer(Zr
						.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Zr
						.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
					this._colorOverLifetime = e
				}
			}, {
				key: "sizeOverLifetime",
				get: function() {
					return this._sizeOverLifetime
				},
				set: function(e) {
					var t = this._owner._render._shaderValues;
					if (e) {
						var r = e.size,
							n = r.separateAxes,
							i = r.type;
						if (e.enable) switch (i) {
							case 0:
								n ? t.addDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) :
									t.addDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
								break;
							case 2:
								n ? t.addDefine(Zr
										.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t
									.addDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES)
						} else t.removeDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t
							.removeDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), t
							.removeDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t
							.removeDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
						switch (i) {
							case 0:
								n ? (t.setBuffer(Zr.SOLSIZEGRADIENTX, r.gradientX._elements), t
										.setBuffer(Zr.SOLSIZEGRADIENTY, r.gradientY._elements), t
										.setBuffer(Zr.SOLSizeGradientZ, r.gradientZ._elements)) : t
									.setBuffer(Zr.SOLSIZEGRADIENT, r.gradient._elements);
								break;
							case 2:
								n ? (t.setBuffer(Zr.SOLSIZEGRADIENTX, r.gradientXMin._elements), t
									.setBuffer(Zr.SOLSIZEGRADIENTXMAX, r.gradientXMax
									._elements), t.setBuffer(Zr.SOLSIZEGRADIENTY, r.gradientYMin
										._elements), t.setBuffer(Zr.SOLSIZEGRADIENTYMAX, r
										.gradientYMax._elements), t.setBuffer(Zr
										.SOLSizeGradientZ, r.gradientZMin._elements), t
									.setBuffer(Zr.SOLSizeGradientZMAX, r.gradientZMax._elements)
									) : (t.setBuffer(Zr.SOLSIZEGRADIENT, r.gradientMin
									._elements), t.setBuffer(Zr.SOLSizeGradientMax, r
									.gradientMax._elements))
						}
					} else t.removeDefine(Zr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Zr
						.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE), t.removeDefine(Zr
						.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Zr
						.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
					this._sizeOverLifetime = e
				}
			}, {
				key: "rotationOverLifetime",
				get: function() {
					return this._rotationOverLifetime
				},
				set: function(e) {
					var t = this._owner._render._shaderValues;
					if (e) {
						var r = e.angularVelocity;
						if (!r) return;
						var n = r.separateAxes,
							i = r.type;
						if (e.enable) switch (n ? t.addDefine(Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIME), i) {
							case 0:
								t.addDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
								break;
							case 1:
								t.addDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
								break;
							case 2:
								t.addDefine(Zr
								.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
								break;
							case 3:
								t.addDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES)
						} else t.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIME), t
							.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), t
							.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t
							.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), t
							.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS),
							t.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
						switch (i) {
							case 0:
								n ? t.setVector3(Zr.ROLANGULARVELOCITYCONSTSEPRARATE, r
									.constantSeparate) : t.setNumber(Zr.ROLANGULARVELOCITYCONST,
									r.constant);
								break;
							case 1:
								n ? (t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENTX, r.gradientX
										._elements), t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENTY,
										r.gradientY._elements), t.setBuffer(Zr
										.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t
									.setBuffer(Zr.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
								break;
							case 2:
								n ? (t.setVector3(Zr.ROLANGULARVELOCITYCONSTSEPRARATE, r
									.constantMinSeparate), t.setVector3(Zr
									.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r
									.constantMaxSeparate)) : (t.setNumber(Zr
									.ROLANGULARVELOCITYCONST, r.constantMin), t.setNumber(Zr
									.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
								break;
							case 3:
								n ? (t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin
									._elements), t.setBuffer(Zr
									.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax
									._elements), t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENTY,
									r.gradientYMin._elements), t.setBuffer(Zr
									.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax
									._elements), t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENTZ,
									r.gradientZMin._elements), t.setBuffer(Zr
									.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax
									._elements)) : (t.setBuffer(Zr.ROLANGULARVELOCITYGRADIENT, r
										.gradientMin._elements), t.setBuffer(Zr
										.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements
										))
						}
					} else t.removeDefine(Zr.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Zr
						.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE), t.removeDefine(Zr
						.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Zr
						.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE), t.removeDefine(Zr
						.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Zr
						.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
					this._rotationOverLifetime = e
				}
			}, {
				key: "textureSheetAnimation",
				get: function() {
					return this._textureSheetAnimation
				},
				set: function(e) {
					var t = this._owner._render._shaderValues;
					if (e) {
						var r = e.frame,
							n = r.type;
						if (e.enable) switch (n) {
							case 1:
								t.addDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
								break;
							case 3:
								t.addDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE)
						} else t.removeDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t
							.removeDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
						if (1 === n || 3 === n) {
							t.setNumber(Zr.TEXTURESHEETANIMATIONCYCLES, e.cycles);
							var i = e.tiles,
								a = this._uvLength;
							a.x = 1 / i.x, a.y = 1 / i.y, t.setVector2(Zr
								.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength)
						}
						switch (n) {
							case 1:
								t.setBuffer(Zr.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData
									._elements);
								break;
							case 3:
								t.setBuffer(Zr.TEXTURESHEETANIMATIONGRADIENTUVS, r
									.frameOverTimeDataMin._elements), t.setBuffer(Zr
									.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax
									._elements)
						}
					} else t.removeDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t
						.removeDefine(Zr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
					this._textureSheetAnimation = e
				}
			}, {
				key: "customBounds",
				get: function() {
					return this._customBounds
				},
				set: function(e) {
					this._useCustomBounds = !!e, this._customBounds = e
				}
			}]), ShurikenParticleSystem
		}(Ot);
		nn._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713,
				2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623,
				2941263940, 2786374529, 271901988, 4233252447
			]), nn.halfKSqrtOf2 = .71, nn.g = 9.8, nn._maxElapsedTime = 1 / 3, nn._tempVector30 = new o, nn
			._tempVector31 = new o, nn._tempVector32 = new o, nn._tempVector33 = new o, nn._tempVector34 = new o, nn
			._tempVector35 = new o, nn._tempVector36 = new o, nn._tempVector37 = new o, nn._tempVector38 = new o, nn
			._tempVector39 = new o, nn._tempPosition = new o, nn._tempDirection = new o, nn._type = Ot._typeCounter++;
		var an = function(e) {
				function ShuriKenParticle3D() {
					var e;
					_classCallCheck(this, ShuriKenParticle3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							ShuriKenParticle3D).call(this, null)))._render = new qr(_assertThisInitialized(e)), e
						._particleSystem = new nn(_assertThisInitialized(e));
					var t = e._render._renderElements[0] = new Ze;
					return t.setTransform(e._transform), t.render = e._render, t.setGeometry(e._particleSystem), t
						.material = Qr.defaultMaterial, e
				}
				return _inherits(ShuriKenParticle3D, e), _createClass(ShuriKenParticle3D, [{
					key: "_parseModule",
					value: function(e, r) {
						for (var n in r) switch (n) {
							case "bases":
								var i = r.bases;
								for (var a in i) e[a] = i[a];
								break;
							case "vector2s":
								var o = r.vector2s;
								for (var a in o) {
									var s = e[a],
										l = o[a];
									s.setValue(l[0], l[1]), e[a] = s
								}
								break;
							case "vector3s":
								var u = r.vector3s;
								for (var a in u) {
									var c = e[a],
										h = u[a];
									c.setValue(h[0], h[1], h[2]), e[a] = c
								}
								break;
							case "vector4s":
								var _ = r.vector4s;
								for (var a in _) {
									var d = e[a],
										f = _[a];
									d.setValue(f[0], f[1], f[2], f[3]), e[a] = d
								}
								break;
							case "gradientDataNumbers":
								var m = r.gradientDataNumbers;
								for (var a in m) {
									for (var p = e[a], T = r[a], E = 0, g = T.length; E < g; E++) {
										var y = T[E];
										p.add(y.key, y.value)
									}
									e[a] = p
								}
								break;
							case "resources":
								var S = r.resources;
								for (var a in S) e[a] = t.Loader.getRes(S[a]);
								break;
							case "bursts":
								var v = r.bursts;
								for (E = 0, g = v.length; E < g; E++) {
									var R = v[E];
									e.addBurst(new xr(R.time, R.min, R.max))
								}
								break;
							case "randomSeed":
								e.randomSeed[0] = r.randomSeed;
								break;
							case "shapeType":
							case "type":
							case "color":
							case "size":
							case "frame":
							case "startFrame":
							case "angularVelocity":
							case "velocity":
								break;
							default:
								throw "ShurikenParticle3D:unknown type."
						}
					}
				}, {
					key: "_parse",
					value: function(e, t) {
						if (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_parse", this).call(
								this, e, t), e.main) {
							var r = this.particleSystem,
								n = this.particleRenderer;
							this._parseModule(n, e.renderer), this._parseModule(r, e.main), this
								._parseModule(r.emission, e.emission);
							var a = e.shape;
							if (a) {
								var s;
								switch (a.shapeType) {
									case 0:
										s = new zr;
										break;
									case 1:
										s = new Hr;
										break;
									case 2:
										s = new Gr;
										break;
									case 3:
										s = new Fr;
										break;
									case 7:
										s = new Ur;
										break;
									default:
										throw "ShuriKenParticle3D:unknown shape type."
								}
								this._parseModule(s, a), r.shape = s
							}
							var l = e.velocityOverLifetime;
							if (l) {
								var u, c = l.velocity;
								switch (c.type) {
									case 0:
										var h = c.constant;
										u = kr.createByConstant(h ? new o(h[0], h[1], h[2]) : new o(0,
											0, 0));
										break;
									case 1:
										u = kr.createByGradient(this._initParticleVelocity(c.gradientX),
											this._initParticleVelocity(c.gradientY), this
											._initParticleVelocity(c.gradientZ));
										break;
									case 2:
										var _ = c.constantMin,
											d = c.constantMax;
										u = kr.createByRandomTwoConstant(_ ? new o(_[0], _[1], _[2]) :
											new o(0, 0, 0), d ? new o(d[0], d[1], d[2]) : new o(0,
												0, 0));
										break;
									case 3:
										u = kr.createByRandomTwoGradient(this._initParticleVelocity(c
											.gradientXMin), this._initParticleVelocity(c
											.gradientXMax), this._initParticleVelocity(c
											.gradientYMin), this._initParticleVelocity(c
											.gradientYMax), this._initParticleVelocity(c
											.gradientZMin), this._initParticleVelocity(c
											.gradientZMax))
								}
								var f = new jr(u);
								this._parseModule(f, l), r.velocityOverLifetime = f
							}
							var m = e.colorOverLifetime;
							if (m) {
								var p, T = m.color;
								switch (T.type) {
									case 0:
										var E = T.constant;
										p = Ar.createByConstant(E ? new i(E[0], E[1], E[2], E[3]) :
											new i(0, 0, 0, 0));
										break;
									case 1:
										p = Ar.createByGradient(this._initParticleColor(T.gradient));
										break;
									case 2:
										var g = T.constantMin,
											y = T.constantMax;
										p = Ar.createByRandomTwoConstant(g ? new i(g[0], g[1], g[2], g[
											3]) : new i(0, 0, 0, 0), g ? new i(y[0], y[1], y[2],
											y[3]) : new i(0, 0, 0, 0));
										break;
									case 3:
										p = Ar.createByRandomTwoGradient(this._initParticleColor(T
											.gradientMin), this._initParticleColor(T
											.gradientMax))
								}
								var S = new Ir(p);
								this._parseModule(S, m), r.colorOverLifetime = S
							}
							var v = e.sizeOverLifetime;
							if (v) {
								var R, C = v.size;
								switch (C.type) {
									case 0:
										R = C.separateAxes ? br.createByGradientSeparate(this
												._initParticleSize(C.gradientX), this._initParticleSize(
													C.gradientY), this._initParticleSize(C.gradientZ)) :
											br.createByGradient(this._initParticleSize(C.gradient));
										break;
									case 1:
										if (C.separateAxes) {
											var M = C.constantMinSeparate,
												D = C.constantMaxSeparate;
											R = br.createByRandomTwoConstantSeparate(M ? new o(M[0], M[
												1], M[2]) : new o(0, 0, 0), D ? new o(D[0], D[
												1], D[2]) : new o(0, 0, 0))
										} else R = br.createByRandomTwoConstant(C.constantMin || 0, C
											.constantMax || 0);
										break;
									case 2:
										R = C.separateAxes ? br.createByRandomTwoGradientSeparate(this
												._initParticleSize(C.gradientXMin), this
												._initParticleSize(C.gradientYMin), this
												._initParticleSize(C.gradientZMin), this
												._initParticleSize(C.gradientXMax), this
												._initParticleSize(C.gradientYMax), this
												._initParticleSize(C.gradientZMax)) : br
											.createByRandomTwoGradient(this._initParticleSize(C
													.gradientMin), this._initParticleSize(C
												.gradientMax))
								}
								var x = new Wr(R);
								this._parseModule(x, v), r.sizeOverLifetime = x
							}
							var A = e.rotationOverLifetime;
							if (A) {
								var I, L = A.angularVelocity;
								switch (L.type) {
									case 0:
										if (L.separateAxes) {
											var P = L.constantSeparate;
											I = Pr.createByConstantSeparate(P ? new o(P[0], P[1], P[
												2]) : new o(0, 0, Math.PI / 4))
										} else I = Pr.createByConstant(L.constant || Math.PI / 4);
										break;
									case 1:
										I = L.separateAxes ? Pr.createByGradientSeparate(this
												._initParticleRotation(L.gradientX), this
												._initParticleRotation(L.gradientY), this
												._initParticleRotation(L.gradientZ)) : Pr
											.createByGradient(this._initParticleRotation(L.gradient));
										break;
									case 2:
										if (L.separateAxes) {
											var O = L.constantMinSeparate,
												N = L.constantMaxSeparate;
											I = Pr.createByRandomTwoConstantSeparate(O ? new o(O[0], O[
												1], O[2]) : new o(0, 0, 0), N ? new o(N[0], N[
												1], N[2]) : new o(0, 0, Math.PI / 4))
										} else I = Pr.createByRandomTwoConstant(L.constantMin || 0, L
											.constantMax || Math.PI / 4);
										break;
									case 3:
										L.separateAxes || (I = Pr.createByRandomTwoGradient(this
											._initParticleRotation(L.gradientMin), this
											._initParticleRotation(L.gradientMax)))
								}
								var b = new wr(I);
								this._parseModule(b, A), r.rotationOverLifetime = b
							}
							var k = e.textureSheetAnimation;
							if (k) {
								var w, B = k.frame;
								switch (B.type) {
									case 0:
										w = Lr.createByConstant(B.constant);
										break;
									case 1:
										w = Lr.createByOverTime(this._initParticleFrame(B.overTime));
										break;
									case 2:
										w = Lr.createByRandomTwoConstant(B.constantMin, B.constantMax);
										break;
									case 3:
										w = Lr.createByRandomTwoOverTime(this._initParticleFrame(B
											.overTimeMin), this._initParticleFrame(B
											.overTimeMax))
								}
								var V, F = k.startFrame;
								switch (F.type) {
									case 0:
										V = Xr.createByConstant(F.constant);
										break;
									case 1:
										V = Xr.createByRandomTwoConstant(F.constantMin, F.constantMax)
								}
								var U = new Yr(w, V);
								this._parseModule(U, k), r.textureSheetAnimation = U
							}
						} else this._parseOld(e)
					}
				}, {
					key: "_activeHierarchy",
					value: function(e) {
						_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_activeHierarchy", this)
							.call(this, e), this.particleSystem.playOnAwake && this.particleSystem
							.play()
					}
				}, {
					key: "_inActiveHierarchy",
					value: function(e) {
						_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_inActiveHierarchy", this)
							.call(this, e), this.particleSystem.isAlive && this.particleSystem.simulate(
								0, !0)
					}
				}, {
					key: "_cloneTo",
					value: function(e, t, r) {
						var n = e,
							i = n._particleSystem;
						this._particleSystem.cloneTo(i);
						var a = n._render,
							o = this._render;
						a.sharedMaterials = o.sharedMaterials, a.enable = o.enable, a.renderMode = o
							.renderMode, a.mesh = o.mesh, a.stretchedBillboardCameraSpeedScale = o
							.stretchedBillboardCameraSpeedScale, a.stretchedBillboardSpeedScale = o
							.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = o
							.stretchedBillboardLengthScale, a.sortingFudge = o.sortingFudge, _get(
								_getPrototypeOf(ShuriKenParticle3D.prototype), "_cloneTo", this).call(
								this, e, t, r)
					}
				}, {
					key: "destroy",
					value: function() {
						var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
						this.destroyed || (_get(_getPrototypeOf(ShuriKenParticle3D.prototype),
								"destroy", this).call(this, e), this._particleSystem.destroy(), this
							._particleSystem = null)
					}
				}, {
					key: "_create",
					value: function() {
						return new ShuriKenParticle3D
					}
				}, {
					key: "_parseOld",
					value: function(e) {
						var r, a, s, l = Math.PI / 180,
							u = this.particleRenderer,
							c = e.material;
						c && (s = t.Loader.getRes(c.path)), u.sharedMaterial = s;
						var h = e.meshPath;
						h && (u.mesh = t.Loader.getRes(h)), u.renderMode = e.renderMode, u
							.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale,
							u.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, u
							.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale, u
							.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
						var _ = this.particleSystem;
						_.isPerformanceMode = e.isPerformanceMode, _.duration = e.duration, _.looping =
							e.looping, _.prewarm = e.prewarm, _.startDelayType = e.startDelayType, _
							.startDelay = e.startDelay, _.startDelayMin = e.startDelayMin, _
							.startDelayMax = e.startDelayMax, _.startLifetimeType = e.startLifetimeType,
							_.startLifetimeConstant = e.startLifetimeConstant, _.startLifeTimeGradient =
							ShuriKenParticle3D._initStartLife(e.startLifetimeGradient), _
							.startLifetimeConstantMin = e.startLifetimeConstantMin, _
							.startLifetimeConstantMax = e.startLifetimeConstantMax, _
							.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(e
								.startLifetimeGradientMin), _.startLifeTimeGradientMax =
							ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMax), _
							.startSpeedType = e.startSpeedType, _.startSpeedConstant = e
							.startSpeedConstant, _.startSpeedConstantMin = e.startSpeedConstantMin, _
							.startSpeedConstantMax = e.startSpeedConstantMax, _.threeDStartSize = e
							.threeDStartSize, _.startSizeType = e.startSizeType, _.startSizeConstant = e
							.startSizeConstant;
						var d = e.startSizeConstantSeparate,
							f = _.startSizeConstantSeparate;
						f.x = d[0], f.y = d[1], f.z = d[2], _.startSizeConstantMin = e
							.startSizeConstantMin, _.startSizeConstantMax = e.startSizeConstantMax;
						var m = e.startSizeConstantMinSeparate,
							p = _.startSizeConstantMinSeparate;
						p.x = m[0], p.y = m[1], p.z = m[2];
						var T = e.startSizeConstantMaxSeparate,
							E = _.startSizeConstantMaxSeparate;
						E.x = T[0], E.y = T[1], E.z = T[2], _.threeDStartRotation = e
							.threeDStartRotation, _.startRotationType = e.startRotationType, _
							.startRotationConstant = e.startRotationConstant * l;
						var g = e.startRotationConstantSeparate,
							y = _.startRotationConstantSeparate;
						y.x = g[0] * l, y.y = g[1] * l, y.z = g[2] * l, _.startRotationConstantMin = e
							.startRotationConstantMin * l, _.startRotationConstantMax = e
							.startRotationConstantMax * l;
						var S = e.startRotationConstantMinSeparate,
							v = _.startRotationConstantMinSeparate;
						v.x = S[0] * l, v.y = S[1] * l, v.z = S[2] * l;
						var R = e.startRotationConstantMaxSeparate,
							C = _.startRotationConstantMaxSeparate;
						C.x = R[0] * l, C.y = R[1] * l, C.z = R[2] * l, _.randomizeRotationDirection = e
							.randomizeRotationDirection, _.startColorType = e.startColorType;
						var M = e.startColorConstant,
							D = _.startColorConstant;
						D.x = M[0], D.y = M[1], D.z = M[2], D.w = M[3];
						var x = e.startColorConstantMin,
							A = _.startColorConstantMin;
						A.x = x[0], A.y = x[1], A.z = x[2], A.w = x[3];
						var I = e.startColorConstantMax,
							L = _.startColorConstantMax;
						L.x = I[0], L.y = I[1], L.z = I[2], L.w = I[3], _.gravityModifier = e
							.gravityModifier, _.simulationSpace = e.simulationSpace, void 0 !== e
							.simulationSpeed && (_.simulationSpeed = e.simulationSpeed), _.scaleMode = e
							.scaleMode, _.playOnAwake = e.playOnAwake, _.maxParticles = e.maxParticles;
						var P = e.autoRandomSeed;
						null != P && (_.autoRandomSeed = P);
						var O = e.randomSeed;
						null != O && (_.randomSeed[0] = O);
						var N = e.emission,
							b = _.emission;
						if (N) {
							b.emissionRate = N.emissionRate;
							var k = N.bursts;
							if (k)
								for (r = 0, a = k.length; r < a; r++) {
									var w = k[r];
									b.addBurst(new xr(w.time, w.min, w.max))
								}
							b.enable = N.enable
						} else b.enable = !1;
						var B = e.shape;
						if (B) {
							var V;
							switch (B.shapeType) {
								case 0:
									var F;
									V = F = new zr, F.radius = B.sphereRadius, F.emitFromShell = B
										.sphereEmitFromShell, F.randomDirection = B
										.sphereRandomDirection;
									break;
								case 1:
									var U;
									V = U = new Hr, U.radius = B.hemiSphereRadius, U.emitFromShell = B
										.hemiSphereEmitFromShell, U.randomDirection = B
										.hemiSphereRandomDirection;
									break;
								case 2:
									var G;
									V = G = new Gr, G.angle = B.coneAngle * l, G.radius = B.coneRadius,
										G.length = B.coneLength, G.emitType = B.coneEmitType, G
										.randomDirection = B.coneRandomDirection;
									break;
								case 3:
									var H;
									V = H = new Fr, H.x = B.boxX, H.y = B.boxY, H.z = B.boxZ, H
										.randomDirection = B.boxRandomDirection;
									break;
								case 7:
									var z;
									V = z = new Ur, z.radius = B.circleRadius, z.arc = B.circleArc * l,
										z.emitFromEdge = B.circleEmitFromEdge, z.randomDirection = B
										.circleRandomDirection;
									break;
								default:
									var W;
									V = W = new Ur, W.radius = B.circleRadius, W.arc = B.circleArc * l,
										W.emitFromEdge = B.circleEmitFromEdge, W.randomDirection = B
										.circleRandomDirection
							}
							V.enable = B.enable, _.shape = V
						}
						var X = e.velocityOverLifetime;
						if (X) {
							var Y, j = X.velocity;
							switch (j.type) {
								case 0:
									var Z = j.constant;
									Y = kr.createByConstant(new o(Z[0], Z[1], Z[2]));
									break;
								case 1:
									Y = kr.createByGradient(this._initParticleVelocity(j.gradientX),
										this._initParticleVelocity(j.gradientY), this
										._initParticleVelocity(j.gradientZ));
									break;
								case 2:
									var Q = j.constantMin,
										q = j.constantMax;
									Y = kr.createByRandomTwoConstant(new o(Q[0], Q[1], Q[2]), new o(q[
										0], q[1], q[2]));
									break;
								case 3:
									Y = kr.createByRandomTwoGradient(this._initParticleVelocity(j
										.gradientXMin), this._initParticleVelocity(j
										.gradientXMax), this._initParticleVelocity(j
										.gradientYMin), this._initParticleVelocity(j
										.gradientYMax), this._initParticleVelocity(j
										.gradientZMin), this._initParticleVelocity(j
										.gradientZMax))
							}
							var K = new jr(Y);
							K.space = X.space, K.enable = X.enable, _.velocityOverLifetime = K
						}
						var J = e.colorOverLifetime;
						if (J) {
							var $, ee = J.color;
							switch (ee.type) {
								case 0:
									var te = ee.constant;
									$ = Ar.createByConstant(new i(te[0], te[1], te[2], te[3]));
									break;
								case 1:
									$ = Ar.createByGradient(this._initParticleColor(ee.gradient));
									break;
								case 2:
									var re = ee.constantMin,
										ne = ee.constantMax;
									$ = Ar.createByRandomTwoConstant(new i(re[0], re[1], re[2], re[3]),
										new i(ne[0], ne[1], ne[2], ne[3]));
									break;
								case 3:
									$ = Ar.createByRandomTwoGradient(this._initParticleColor(ee
										.gradientMin), this._initParticleColor(ee.gradientMax))
							}
							var ie = new Ir($);
							ie.enable = J.enable, _.colorOverLifetime = ie
						}
						var ae = e.sizeOverLifetime;
						if (ae) {
							var oe, se = ae.size;
							switch (se.type) {
								case 0:
									oe = se.separateAxes ? br.createByGradientSeparate(this
											._initParticleSize(se.gradientX), this._initParticleSize(se
												.gradientY), this._initParticleSize(se.gradientZ)) : br
										.createByGradient(this._initParticleSize(se.gradient));
									break;
								case 1:
									if (se.separateAxes) {
										var le = se.constantMinSeparate,
											ue = se.constantMaxSeparate;
										oe = br.createByRandomTwoConstantSeparate(new o(le[0], le[1],
											le[2]), new o(ue[0], ue[1], ue[2]))
									} else oe = br.createByRandomTwoConstant(se.constantMin, se
										.constantMax);
									break;
								case 2:
									oe = se.separateAxes ? br.createByRandomTwoGradientSeparate(this
											._initParticleSize(se.gradientXMin), this._initParticleSize(
												se.gradientYMin), this._initParticleSize(se
												.gradientZMin), this._initParticleSize(se.gradientXMax),
											this._initParticleSize(se.gradientYMax), this
											._initParticleSize(se.gradientZMax)) : br
										.createByRandomTwoGradient(this._initParticleSize(se
											.gradientMin), this._initParticleSize(se.gradientMax))
							}
							var ce = new Wr(oe);
							ce.enable = ae.enable, _.sizeOverLifetime = ce
						}
						var he = e.rotationOverLifetime;
						if (he) {
							var _e, de = he.angularVelocity;
							switch (de.type) {
								case 0:
									if (de.separateAxes) {
										var fe = de.constantSeparate;
										_e = Pr.createByConstantSeparate(new o(fe[0] * l, fe[1] * l, fe[
											2] * l))
									} else _e = Pr.createByConstant(de.constant * l);
									break;
								case 1:
									_e = de.separateAxes ? Pr.createByGradientSeparate(this
										._initParticleRotation(de.gradientX), this
										._initParticleRotation(de.gradientY), this
										._initParticleRotation(de.gradientZ)) : Pr.createByGradient(
										this._initParticleRotation(de.gradient));
									break;
								case 2:
									if (de.separateAxes) {
										var me = de.constantMinSeparate,
											pe = de.constantMaxSeparate;
										_e = Pr.createByRandomTwoConstantSeparate(new o(me[0] * l, me[
											1] * l, me[2] * l), new o(pe[0] * l, pe[1] * l, pe[
											2] * l))
									} else _e = Pr.createByRandomTwoConstant(de.constantMin * l, de
										.constantMax * l);
									break;
								case 3:
									de.separateAxes || (_e = Pr.createByRandomTwoGradient(this
										._initParticleRotation(de.gradientMin), this
										._initParticleRotation(de.gradientMax)))
							}
							var Te = new wr(_e);
							Te.enable = he.enable, _.rotationOverLifetime = Te
						}
						var Ee = e.textureSheetAnimation;
						if (Ee) {
							var ge, ye = Ee.frame;
							switch (ye.type) {
								case 0:
									ge = Lr.createByConstant(ye.constant);
									break;
								case 1:
									ge = Lr.createByOverTime(this._initParticleFrame(ye.overTime));
									break;
								case 2:
									ge = Lr.createByRandomTwoConstant(ye.constantMin, ye.constantMax);
									break;
								case 3:
									ge = Lr.createByRandomTwoOverTime(this._initParticleFrame(ye
										.overTimeMin), this._initParticleFrame(ye.overTimeMax))
							}
							var Se, ve = Ee.startFrame;
							switch (ve.type) {
								case 0:
									Se = Xr.createByConstant(ve.constant);
									break;
								case 1:
									Se = Xr.createByRandomTwoConstant(ve.constantMin, ve.constantMax)
							}
							var Re = new Yr(ge, Se);
							Re.enable = Ee.enable;
							var Ce = Ee.tiles;
							Re.tiles = new n(Ce[0], Ce[1]), Re.type = Ee.type, Re.randomRow = Ee
								.randomRow;
							var Me = Ee.rowIndex;
							void 0 !== Me && (Re.rowIndex = Me), Re.cycles = Ee.cycles, _
								.textureSheetAnimation = Re
						}
					}
				}, {
					key: "_initParticleColor",
					value: function(e) {
						var t = new Dr(4, 4);
						if (e) {
							var r, n, i = e.alphas;
							if (i)
								for (r = 0, n = i.length; r < n; r++) {
									3 == r && n > 4 && (r = n - 1, console.warn(
										"GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."
										));
									var a = i[r];
									t.addColorAlpha(a.key, a.value)
								} else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1);
							var o = e.rgbs;
							if (o)
								for (r = 0, n = o.length; r < n; r++) {
									3 == r && n > 4 && (r = n - 1, console.warn(
										"GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."
										));
									var s = o[r],
										l = s.value;
									t.addColorRGB(s.key, new ft(l[0], l[1], l[2], 1))
								} else t.addColorRGB(0, new ft(1, 1, 1, 1)), t.addColorRGB(1, new ft(1,
									1, 1, 1))
						} else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1), t.addColorRGB(0, new ft(1,
							1, 1, 1)), t.addColorRGB(1, new ft(1, 1, 1, 1));
						return t
					}
				}, {
					key: "_initParticleFrame",
					value: function(e) {
						var t = new Or;
						if (e)
							for (var r = e.frames, n = 0, i = r.length; n < i; n++) {
								var a = r[n];
								t.add(a.key, a.value)
							} else t.add(0, 0), t.add(1, 1);
						return t
					}
				}, {
					key: "_initParticleVelocity",
					value: function(e) {
						for (var t = new Nr, r = e.velocitys, n = 0, i = r.length; n < i; n++) {
							var a = r[n];
							t.add(a.key, a.value)
						}
						return t
					}
				}, {
					key: "_initParticleSize",
					value: function(e) {
						var t = new Nr;
						if (e)
							for (var r = e.sizes, n = 0, i = r.length; n < i; n++) {
								var a = r[n];
								t.add(a.key, a.value)
							} else t.add(0, 0), t.add(1, 1);
						return t
					}
				}, {
					key: "_initParticleRotation",
					value: function(e) {
						for (var t = new Nr, r = e.angularVelocitys, n = 0, i = r.length; n < i; n++) {
							var a = r[n];
							t.add(a.key, a.value / 180 * Math.PI)
						}
						return t
					}
				}, {
					key: "particleSystem",
					get: function() {
						return this._particleSystem
					}
				}, {
					key: "particleRenderer",
					get: function() {
						return this._render
					}
				}], [{
					key: "__init__",
					value: function() {
						Zr.SHADERDEFINE_RENDERMODE_BILLBOARD = _e.getDefineByName("SPHERHBILLBOARD"), Zr
							.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = _e.getDefineByName(
								"STRETCHEDBILLBOARD"), Zr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD =
							_e.getDefineByName("HORIZONTALBILLBOARD"), Zr
							.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = _e.getDefineByName(
								"VERTICALBILLBOARD"), Zr.SHADERDEFINE_COLOROVERLIFETIME = _e
							.getDefineByName("COLOROVERLIFETIME"), Zr
							.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = _e.getDefineByName(
								"RANDOMCOLOROVERLIFETIME"), Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = _e.getDefineByName(
								"VELOCITYOVERLIFETIMECONSTANT"), Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = _e.getDefineByName(
								"VELOCITYOVERLIFETIMECURVE"), Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = _e.getDefineByName(
								"VELOCITYOVERLIFETIMERANDOMCONSTANT"), Zr
							.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = _e.getDefineByName(
								"VELOCITYOVERLIFETIMERANDOMCURVE"), Zr
							.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = _e.getDefineByName(
								"TEXTURESHEETANIMATIONCURVE"), Zr
							.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = _e.getDefineByName(
								"TEXTURESHEETANIMATIONRANDOMCURVE"), Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIME = _e.getDefineByName(
								"ROTATIONOVERLIFETIME"), Zr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE =
							_e.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"), Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = _e.getDefineByName(
								"ROTATIONOVERLIFETIMECONSTANT"), Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = _e.getDefineByName(
								"ROTATIONOVERLIFETIMECURVE"), Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = _e.getDefineByName(
								"ROTATIONOVERLIFETIMERANDOMCONSTANTS"), Zr
							.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = _e.getDefineByName(
								"ROTATIONOVERLIFETIMERANDOMCURVES"), Zr
							.SHADERDEFINE_SIZEOVERLIFETIMECURVE = _e.getDefineByName(
								"SIZEOVERLIFETIMECURVE"), Zr
							.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = _e.getDefineByName(
								"SIZEOVERLIFETIMECURVESEPERATE"), Zr
							.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = _e.getDefineByName(
								"SIZEOVERLIFETIMERANDOMCURVES"), Zr
							.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = _e.getDefineByName(
								"SIZEOVERLIFETIMERANDOMCURVESSEPERATE"), Zr
							.SHADERDEFINE_RENDERMODE_MESH = _e.getDefineByName("RENDERMODE_MESH"), Zr
							.SHADERDEFINE_SHAPE = _e.getDefineByName("SHAPE")
					}
				}, {
					key: "_initStartLife",
					value: function(e) {
						for (var t = new Nr, r = e.startLifetimes, n = 0, i = r.length; n < i; n++) {
							var a = r[n];
							t.add(a.key, a.value)
						}
						return t
					}
				}]), ShuriKenParticle3D
			}(kt),
			on = function SkinnedMeshSprite3DShaderDeclaration() {
				_classCallCheck(this, SkinnedMeshSprite3DShaderDeclaration)
			},
			sn = function(r) {
				function SkinnedMeshRenderer(e) {
					var t;
					return _classCallCheck(this, SkinnedMeshRenderer), (t = _possibleConstructorReturn(this,
							_getPrototypeOf(SkinnedMeshRenderer).call(this, e)))._bones = [], t
						._skinnedDataLoopMarks = [], t._localBounds = new Pt(o._ZERO, o._ZERO), t
						._cacheAnimationNode = [], t
				}
				return _inherits(SkinnedMeshRenderer, r), _createClass(SkinnedMeshRenderer, [{
					key: "_computeSkinnedData",
					value: function() {
						if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this
							._cacheAvatar)
							for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh
									._skinnedMatrixCaches, r = 0, n = this._cacheMesh.subMeshCount; r <
								n; r++)
								for (var i = this._cacheMesh.getSubMesh(r)._boneIndicesList, a = this
										._skinnedData[r], o = 0, s = i.length; o < s; o++) {
									var l = i[o];
									this._computeSubSkinnedData(e, l, a[o], t)
								}
					}
				}, {
					key: "_computeSubSkinnedData",
					value: function(e, r, n, i) {
						for (var a = 0, o = r.length; a < o; a++) {
							var s = r[a];
							if (this._skinnedDataLoopMarks[s] === t.Stat.loopCount)
								for (var l = i[s], u = this._skinnedData[l.subMeshIndex][l.batchIndex],
										c = 16 * l.batchBoneIndex, h = 16 * a, _ = 0; _ < 16; _++) n[h +
									_] = u[c + _];
							else this._cacheAvatar ? P._mulMatrixArray(this._cacheAnimationNode[s]
									.transform.getWorldMatrix(), e[s].elements, 0, n, 16 * a) : P
								._mulMatrixArray(this._bones[s].transform.worldMatrix.elements, e[s]
									.elements, 0, n, 16 * a), this._skinnedDataLoopMarks[s] = t.Stat
								.loopCount
						}
					}
				}, {
					key: "_onWorldMatNeedChange",
					value: function(e) {
						this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this
							._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(
								this) : (e &= f.TRANSFORM_WORLDPOSITION | f
								.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE) && -1 === this
							._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(
								this))
					}
				}, {
					key: "_createRenderElement",
					value: function() {
						return new Ze
					}
				}, {
					key: "_onMeshChange",
					value: function(e) {
						_get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_onMeshChange", this)
							.call(this, e), this._cacheMesh = e;
						var t = e.subMeshCount;
						this._skinnedData = [], this._skinnedDataLoopMarks.length = e._inverseBindPoses
							.length;
						for (var r = 0; r < t; r++)
							for (var n = e.getSubMesh(r)._boneIndicesList, i = n.length, a = this
									._skinnedData[r] = [], o = 0; o < i; o++) a[o] = new Float32Array(
								16 * n[o].length);
						this._cacheAvatar && e && this._getCacheAnimationNodes()
					}
				}, {
					key: "_setCacheAnimator",
					value: function(e) {
						this._cacheAnimator = e, this._shaderValues.addDefine(on.SHADERDEFINE_BONE),
							this._setRootNode()
					}
				}, {
					key: "_calculateBoundingBox",
					value: function() {
						if (this._cacheAvatar)
							if (this._cacheAnimator && this._rootBone) {
								var e = SkinnedMeshRenderer._tempMatrix4x4;
								P.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix,
										this._cacheRootAnimationNode.transform.getWorldMatrix(), e),
									this._localBounds._tranform(e, this._bounds)
							} else _get(_getPrototypeOf(SkinnedMeshRenderer.prototype),
								"_calculateBoundingBox", this).call(this);
						else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone
							.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this
							._owner.transform.worldMatrix, this._bounds)
					}
				}, {
					key: "_renderUpdate",
					value: function(t, r) {
						if (this._cacheAnimator)
							if (this._computeSkinnedData(), this._cacheAvatar) {
								var n = this._cacheAnimator.owner._transform;
								this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, n.worldMatrix)
							} else this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, c.DEFAULT);
						else this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, r.worldMatrix);
						this._probReflection && (this._reflectionMode == e.ReflectionProbeMode.off ? (
							this._shaderValues.removeDefine(Er
								.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
							.setVector(kt.REFLECTIONCUBE_HDR_PARAMS, zt
								.defaultTextureHDRDecodeValues), this._shaderValues.setTexture(
								kt.REFLECTIONTEXTURE, Dt.blackTexture)) : (this._probReflection
							.boxProjection ? (this._shaderValues.addDefine(Er
									.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
								.setVector3(kt.REFLECTIONCUBE_PROBEPOSITION, this
									._probReflection.probePosition), this._shaderValues
								.setVector3(kt.REFLECTIONCUBE_PROBEBOXMAX, this._probReflection
									.boundsMax), this._shaderValues.setVector3(kt
									.REFLECTIONCUBE_PROBEBOXMIN, this._probReflection.boundsMin)
								) : this._shaderValues.removeDefine(Er
								.SHADERDEFINE_SPECCUBE_BOX_PROJECTION), this._shaderValues
							.setTexture(kt.REFLECTIONTEXTURE, this._probReflection
								.reflectionTexture), this._shaderValues.setVector(kt
								.REFLECTIONCUBE_HDR_PARAMS, this._probReflection
								.reflectionHDRParams)))
					}
				}, {
					key: "_renderUpdateWithCamera",
					value: function(e, t) {
						var r = e.projectionViewMatrix;
						if (this._cacheAnimator)
							if (this._cacheAvatar) {
								var n = this._cacheAnimator.owner._transform;
								c.multiply(r, n.worldMatrix, this._projectionViewWorldMatrix), this
									._shaderValues.setMatrix4x4(Ee.MVPMATRIX, this
										._projectionViewWorldMatrix)
							} else this._shaderValues.setMatrix4x4(Ee.MVPMATRIX, r);
						else c.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this
							._shaderValues.setMatrix4x4(Ee.MVPMATRIX, this._projectionViewWorldMatrix)
					}
				}, {
					key: "_destroy",
					value: function() {
						_get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_destroy", this).call(
								this), this._cacheAvatar ? this._cacheRootAnimationNode && this
							._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this
								._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone
							.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED,
								this, this._onWorldMatNeedChange) : this._owner && !this._owner
							.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this,
								this._onWorldMatNeedChange)
					}
				}, {
					key: "_setRootBone",
					value: function(e) {
						this._rootBone = e, this._setRootNode()
					}
				}, {
					key: "_setRootNode",
					value: function() {
						var e;
						e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this
							._cacheAnimator._avatarNodeMap[this._rootBone] : null, this
							._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(f
									.TRANSFORM_WORLDPOSITION | f.TRANSFORM_WORLDQUATERNION | f
									.TRANSFORM_WORLDSCALE), this._owner.transform.off(t.Event
									.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), this
								._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t
									.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange), e && e
								.transform.on(t.Event.TRANSFORM_CHANGED, this, this
									._onWorldMatNeedChange), this._cacheRootAnimationNode = e)
					}
				}, {
					key: "_getCacheAnimationNodes",
					value: function() {
						var e = this._cacheMesh._boneNames,
							t = this._cacheMesh._inverseBindPoses.length;
						this._cacheAnimationNode.length = t;
						for (var r = this._cacheAnimator._avatarNodeMap, n = 0; n < t; n++) {
							var i = r[e[n]];
							this._cacheAnimationNode[n] = i
						}
					}
				}, {
					key: "_setCacheAvatar",
					value: function(e) {
						this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this
								._shaderValues.addDefine(on.SHADERDEFINE_BONE), this
								._getCacheAnimationNodes())) : this._cacheAvatar = e, this
							._setRootNode())
					}
				}, {
					key: "_computeSubSkinnedDataNative",
					value: function(e, r, n, i, a) {
						t.LayaGL.instance.computeSubSkinnedData(e, r, n, i, a)
					}
				}, {
					key: "_computeSkinnedDataForNative",
					value: function() {
						if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this
							._cacheAvatar)
							for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh
									._skinnedMatrixCaches, r = 0, n = this._cacheMesh.subMeshCount; r <
								n; r++)
								for (var i = this._cacheMesh.getSubMesh(r)._boneIndicesList, a = this
										._skinnedData[r], o = 0, s = i.length; o < s; o++) {
									var l = i[o];
									this._computeSubSkinnedData(e, l, a[o], t)
								}
					}
				}, {
					key: "localBounds",
					get: function() {
						return this._localBounds
					},
					set: function(e) {
						this._localBounds = e
					}
				}, {
					key: "rootBone",
					get: function() {
						return this._cacheRootBone
					},
					set: function(e) {
						this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform
							.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this
							._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this
								._onWorldMatNeedChange), e ? e.transform.on(t.Event
								.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner
							.transform.on(t.Event.TRANSFORM_CHANGED, this, this
								._onWorldMatNeedChange), this._cacheRootBone = e, this
							._onWorldMatNeedChange(f.TRANSFORM_WORLDPOSITION | f
								.TRANSFORM_WORLDQUATERNION | f.TRANSFORM_WORLDSCALE))
					}
				}, {
					key: "bones",
					get: function() {
						return this._bones
					}
				}, {
					key: "bounds",
					get: function() {
						return (this._boundsChange || this._cacheAvatar) && (this
						._calculateBoundingBox(), this._boundsChange = !1), this._bounds
					}
				}]), SkinnedMeshRenderer
			}(gr);
		sn._tempMatrix4x4 = new c;
		var ln = function(e) {
			function SkinnedMeshSprite3D() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
					r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
				return _classCallCheck(this, SkinnedMeshSprite3D), (e = _possibleConstructorReturn(this,
					_getPrototypeOf(SkinnedMeshSprite3D).call(this, r)))._meshFilter = new yr(
					_assertThisInitialized(e)), e._render = new sn(_assertThisInitialized(e)), t && (e
					._meshFilter.sharedMesh = t), e
			}
			return _inherits(SkinnedMeshSprite3D, e), _createClass(SkinnedMeshSprite3D, [{
				key: "_parse",
				value: function(e, r) {
					_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_parse", this).call(this,
						e, r);
					var n = this.skinnedMeshRenderer,
						a = e.lightmapIndex;
					null != a && (n.lightmapIndex = a);
					var s, l = e.lightmapScaleOffset;
					if (l && (n.lightmapScaleOffset = new i(l[0], l[1], l[2], l[3])), null != e
						.enableRender && (n.enable = e.enableRender), null != e.receiveShadows && (n
							.receiveShadow = e.receiveShadows), null != e.castShadow && (n
							.castShadow = e.castShadow), s = e.meshPath) {
						var u = t.Loader.getRes(s);
						u && (this.meshFilter.sharedMesh = u)
					}
					var c = e.materials;
					if (c) {
						var h = n.sharedMaterials,
							_ = c.length;
						h.length = _;
						for (var d = 0; d < _; d++) h[d] = t.Loader.getRes(c[d].path);
						n.sharedMaterials = h
					}
					var f = e.boundBox,
						m = f.min,
						p = f.max;
					if (n.localBounds.setMin(new o(m[0], m[1], m[2])), n.localBounds.setMax(new o(p[
							0], p[1], p[2])), r) {
						var T = e.rootBone;
						n.rootBone = r[T];
						var E, g = e.bones;
						for (d = 0, E = g.length; d < E; d++) n.bones.push(r[g[d]])
					} else e.rootBone && n._setRootBone(e.rootBone)
				}
			}, {
				key: "_changeHierarchyAnimator",
				value: function(e) {
					_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_changeHierarchyAnimator",
						this).call(this, e), this.skinnedMeshRenderer._setCacheAnimator(e)
				}
			}, {
				key: "_changeAnimatorAvatar",
				value: function(e) {
					this.skinnedMeshRenderer._setCacheAvatar(e)
				}
			}, {
				key: "_cloneTo",
				value: function(e, t, r) {
					var n = e;
					n.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
					var i = this._render,
						a = n._render;
					a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i
						.castShadow;
					var o = i.lightmapScaleOffset;
					o && (a.lightmapScaleOffset = o.clone()), a.receiveShadow = i.receiveShadow, a
						.sortingFudge = i.sortingFudge, a._rootBone = i._rootBone;
					var s = i.bones,
						l = a.bones,
						u = s.length;
					l.length = u;
					var c = i.rootBone;
					if (c) {
						var h = P._getHierarchyPath(t, c, SkinnedMeshSprite3D._tempArray0);
						a.rootBone = h ? P._getNodeByHierarchyPath(r, h) : c
					}
					for (var _ = 0; _ < s.length; _++) h = P._getHierarchyPath(t, s[_],
						SkinnedMeshSprite3D._tempArray0), l[_] = h ? P._getNodeByHierarchyPath(
						r, h) : s[_];
					var d = i.localBounds;
					d && d.cloneTo(a.localBounds), _get(_getPrototypeOf(SkinnedMeshSprite3D
						.prototype), "_cloneTo", this).call(this, e, t, r)
				}
			}, {
				key: "destroy",
				value: function() {
					var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					this.destroyed || (_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype),
						"destroy", this).call(this, e), this._meshFilter.destroy())
				}
			}, {
				key: "_create",
				value: function() {
					return new SkinnedMeshSprite3D
				}
			}, {
				key: "meshFilter",
				get: function() {
					return this._meshFilter
				}
			}, {
				key: "skinnedMeshRenderer",
				get: function() {
					return this._render
				}
			}], [{
				key: "__init__",
				value: function() {
					on.SHADERDEFINE_BONE = _e.getDefineByName("BONE"), on.SHADERDEFINE_SIMPLEBONE =
						_e.getDefineByName("SIMPLEBONE")
				}
			}]), SkinnedMeshSprite3D
		}(kt);
		ln._tempArray0 = [], ln.BONES = _e.propertyNameToID("u_Bones"), ln.SIMPLE_SIMPLEANIMATORTEXTURE = _e
			.propertyNameToID("u_SimpleAnimatorTexture"), ln.SIMPLE_SIMPLEANIMATORPARAMS = _e.propertyNameToID(
				"u_SimpleAnimatorParams"), ln.SIMPLE_SIMPLEANIMATORTEXTURESIZE = _e.propertyNameToID(
				"u_SimpleAnimatorTextureSize");
		var un = function(e) {
			function TrailMaterial() {
				var e;
				return _classCallCheck(this, TrailMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						TrailMaterial).call(this))).setShaderName("Trail"), e._color = new i(1, 1, 1, 1), e
					._shaderValues.setVector(TrailMaterial.TINTCOLOR, new i(1, 1, 1, 1)), e.renderMode =
					TrailMaterial.RENDERMODE_ALPHABLENDED, e
			}
			return _inherits(TrailMaterial, e), _createClass(TrailMaterial, [{
				key: "clone",
				value: function() {
					var e = new TrailMaterial;
					return this.cloneTo(e), e
				}
			}, {
				key: "_TintColorR",
				get: function() {
					return this._color.x
				},
				set: function(e) {
					this._color.x = e, this.color = this._color
				}
			}, {
				key: "_TintColorG",
				get: function() {
					return this._color.y
				},
				set: function(e) {
					this._color.y = e, this.color = this._color
				}
			}, {
				key: "_TintColorB",
				get: function() {
					return this._color.z
				},
				set: function(e) {
					this._color.z = e, this.color = this._color
				}
			}, {
				key: "_TintColorA",
				get: function() {
					return this._color.w
				},
				set: function(e) {
					this._color.w = e, this.color = this._color
				}
			}, {
				key: "_MainTex_STX",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x
				},
				set: function(e) {
					var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
					t.x = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STY",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y
				},
				set: function(e) {
					var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
					t.y = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STZ",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z
				},
				set: function(e) {
					var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
					t.z = e, this.tilingOffset = t
				}
			}, {
				key: "_MainTex_STW",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w
				},
				set: function(e) {
					var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
					t.w = e, this.tilingOffset = t
				}
			}, {
				key: "renderMode",
				set: function(e) {
					switch (e) {
						case TrailMaterial.RENDERMODE_ADDTIVE:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_NONE, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE, this.depthTest = at.DEPTHTEST_LESS,
								this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
							break;
						case TrailMaterial.RENDERMODE_ALPHABLENDED:
							this.renderQueue = nt.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this
								.depthWrite = !1, this.cull = at.CULL_NONE, this.blend = at
								.BLEND_ENABLE_ALL, this.blendSrc = at.BLENDPARAM_SRC_ALPHA, this
								.blendDst = at.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = at
								.DEPTHTEST_LESS, this._shaderValues.removeDefine(TrailMaterial
									.SHADERDEFINE_ADDTIVEFOG);
							break;
						default:
							throw new Error("TrailMaterial : renderMode value error.")
					}
				}
			}, {
				key: "colorR",
				get: function() {
					return this._TintColorR
				},
				set: function(e) {
					this._TintColorR = e
				}
			}, {
				key: "colorG",
				get: function() {
					return this._TintColorG
				},
				set: function(e) {
					this._TintColorG = e
				}
			}, {
				key: "colorB",
				get: function() {
					return this._TintColorB
				},
				set: function(e) {
					this._TintColorB = e
				}
			}, {
				key: "colorA",
				get: function() {
					return this._TintColorA
				},
				set: function(e) {
					this._TintColorA = e
				}
			}, {
				key: "color",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TINTCOLOR)
				},
				set: function(e) {
					this._shaderValues.setVector(TrailMaterial.TINTCOLOR, e)
				}
			}, {
				key: "texture",
				get: function() {
					return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE)
				},
				set: function(e) {
					e ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this
						._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE), this
						._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, e)
				}
			}, {
				key: "tilingOffsetX",
				get: function() {
					return this._MainTex_STX
				},
				set: function(e) {
					this._MainTex_STX = e
				}
			}, {
				key: "tilingOffsetY",
				get: function() {
					return this._MainTex_STY
				},
				set: function(e) {
					this._MainTex_STY = e
				}
			}, {
				key: "tilingOffsetZ",
				get: function() {
					return this._MainTex_STZ
				},
				set: function(e) {
					this._MainTex_STZ = e
				}
			}, {
				key: "tilingOffsetW",
				get: function() {
					return this._MainTex_STW
				},
				set: function(e) {
					this._MainTex_STW = e
				}
			}, {
				key: "tilingOffset",
				get: function() {
					return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET)
				},
				set: function(e) {
					e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues
						.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues
						.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET), this._shaderValues
						.setVector(TrailMaterial.TILINGOFFSET, e)
				}
			}, {
				key: "depthWrite",
				set: function(e) {
					this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, e)
				},
				get: function() {
					return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE)
				}
			}, {
				key: "cull",
				set: function(e) {
					this._shaderValues.setInt(TrailMaterial.CULL, e)
				},
				get: function() {
					return this._shaderValues.getInt(TrailMaterial.CULL)
				}
			}, {
				key: "blend",
				set: function(e) {
					this._shaderValues.setInt(TrailMaterial.BLEND, e)
				},
				get: function() {
					return this._shaderValues.getInt(TrailMaterial.BLEND)
				}
			}, {
				key: "blendSrc",
				set: function(e) {
					this._shaderValues.setInt(TrailMaterial.BLEND_SRC, e)
				},
				get: function() {
					return this._shaderValues.getInt(TrailMaterial.BLEND_SRC)
				}
			}, {
				key: "blendDst",
				set: function(e) {
					this._shaderValues.setInt(TrailMaterial.BLEND_DST, e)
				},
				get: function() {
					return this._shaderValues.getInt(TrailMaterial.BLEND_DST)
				}
			}, {
				key: "depthTest",
				set: function(e) {
					this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, e)
				},
				get: function() {
					return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST)
				}
			}], [{
				key: "__initDefine__",
				value: function() {
					TrailMaterial.SHADERDEFINE_MAINTEXTURE = _e.getDefineByName("MAINTEXTURE"),
						TrailMaterial.SHADERDEFINE_TILINGOFFSET = _e.getDefineByName(
						"TILINGOFFSET"), TrailMaterial.SHADERDEFINE_ADDTIVEFOG = _e.getDefineByName(
							"ADDTIVEFOG")
				}
			}]), TrailMaterial
		}(nt);
		un.RENDERMODE_ALPHABLENDED = 0, un.RENDERMODE_ADDTIVE = 1, un.MAINTEXTURE = _e.propertyNameToID(
			"u_MainTexture"), un.TINTCOLOR = _e.propertyNameToID("u_MainColor"), un.TILINGOFFSET = _e.propertyNameToID(
				"u_TilingOffset"), un.CULL = _e.propertyNameToID("s_Cull"), un.BLEND = _e.propertyNameToID("s_Blend"),
			un.BLEND_SRC = _e.propertyNameToID("s_BlendSrc"), un.BLEND_DST = _e.propertyNameToID("s_BlendDst"), un
			.DEPTH_TEST = _e.propertyNameToID("s_DepthTest"), un.DEPTH_WRITE = _e.propertyNameToID("s_DepthWrite");
		var cn, hn = function TextureMode() {
			_classCallCheck(this, TextureMode)
		};
		hn.Stretch = 0, hn.Tile = 1, (cn = e.TrailAlignment || (e.TrailAlignment = {}))[cn.View = 0] = "View", cn[cn
			.TransformZ = 1] = "TransformZ";
		var _n = function() {
			function VertexTrail() {
				_classCallCheck(this, VertexTrail)
			}
			return _createClass(VertexTrail, [{
				key: "vertexDeclaration",
				get: function() {
					return VertexTrail._vertexDeclaration1
				}
			}], [{
				key: "__init__",
				value: function() {
					VertexTrail._vertexDeclaration1 = new ie(32, [new ae(0, re.Vector3, VertexTrail
						.TRAIL_POSITION0), new ae(12, re.Vector3, VertexTrail
						.TRAIL_OFFSETVECTOR), new ae(24, re.Single, VertexTrail
						.TRAIL_TIME0), new ae(28, re.Single, VertexTrail
						.TRAIL_TEXTURECOORDINATE0Y)]), VertexTrail._vertexDeclaration2 = new ie(
						20, [new ae(0, re.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X),
							new ae(4, re.Color, VertexTrail.TRAIL_COLOR)
						])
				}
			}, {
				key: "vertexDeclaration1",
				get: function() {
					return VertexTrail._vertexDeclaration1
				}
			}, {
				key: "vertexDeclaration2",
				get: function() {
					return VertexTrail._vertexDeclaration2
				}
			}]), VertexTrail
		}();
		_n.TRAIL_POSITION0 = 0, _n.TRAIL_OFFSETVECTOR = 1, _n.TRAIL_TIME0 = 2, _n.TRAIL_TEXTURECOORDINATE0Y = 3, _n
			.TRAIL_TEXTURECOORDINATE0X = 4, _n.TRAIL_COLOR = 5;
		var dn = function(n) {
			function TrailGeometry(e) {
				var t;
				_classCallCheck(this, TrailGeometry), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						TrailGeometry).call(this)))._floatCountPerVertices1 = 8, t._floatCountPerVertices2 = 5, t
					._increaseSegementCount = 16, t._activeIndex = 0, t._endIndex = 0, t._needAddFirstVertex = !1, t
					._isTempEndVertex = !1, t._vertices1 = null, t._vertices2 = null, t._lastFixedVertexPosition =
					new o, t._bufferState = new oe, t.tmpColor = new ft, t._disappearBoundsMode = !1, t._owner = e,
					t._segementCount = t._increaseSegementCount, t._resizeData(t._segementCount, t._bufferState);
				var r = t._owner._owner.trailRenderer.bounds,
					n = t._owner._owner.transform.position;
				return r.setMin(n), r.setMax(n), t
			}
			return _inherits(TrailGeometry, n), _createClass(TrailGeometry, [{
				key: "_resizeData",
				value: function(e, r) {
					this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(
						e);
					var n = t.LayaGL.instance,
						i = 2 * e,
						a = _n.vertexDeclaration1,
						o = _n.vertexDeclaration2,
						s = [],
						l = i * a.vertexStride,
						u = i * o.vertexStride,
						c = l + u;
					this._vertices1 = new Float32Array(i * this._floatCountPerVertices1), this
						._vertices2 = new Float32Array(i * this._floatCountPerVertices2), this
						._vertexBuffer1 = new te(l, n.STATIC_DRAW, !1), this._vertexBuffer1
						.vertexDeclaration = a, this._vertexBuffer2 = new te(u, n.DYNAMIC_DRAW, !1),
						this._vertexBuffer2.vertexDeclaration = o, s.push(this._vertexBuffer1), s
						.push(this._vertexBuffer2), r.bind(), r.applyVertexBuffers(s), r.unBind(), t
						.Resource._addMemory(c, c)
				}
			}, {
				key: "_resetData",
				value: function() {
					var e = this._endIndex - this._activeIndex,
						r = new Float32Array(this._vertices1.buffer, 2 * this
							._floatCountPerVertices1 * this._activeIndex * 4, 2 * this
							._floatCountPerVertices1 * e),
						n = new Float32Array(this._vertices2.buffer, 2 * this
							._floatCountPerVertices2 * this._activeIndex * 4, 2 * this
							._floatCountPerVertices2 * e),
						i = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e),
						a = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
					if (e === this._segementCount) {
						var o = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
						t.Resource._addMemory(-o, -o), this._vertexBuffer1.destroy(), this
							._vertexBuffer2.destroy(), this._segementCount += this
							._increaseSegementCount, this._resizeData(this._segementCount, this
								._bufferState)
					}
					this._vertices1.set(r, 0), this._vertices2.set(n, 0), this._subDistance.set(i,
							0), this._subBirthTime.set(a, 0), this._endIndex = e, this
						._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0,
							2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this
							._floatCountPerVertices1 * e * 4), this._vertexBuffer2.setData(this
							._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this
							._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4)
				}
			}, {
				key: "_updateTrail",
				value: function(e, t, r) {
					o.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this
						._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r))
				}
			}, {
				key: "_addTrailByFirstPosition",
				value: function(e, t) {
					this._endIndex === this._segementCount && this._resetData(), this._subDistance[
							this._endIndex] = 0, this._subBirthTime[this._endIndex] = this._owner
						._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition), this
						._needAddFirstVertex = !0
				}
			}, {
				key: "_addTrailByNextPosition",
				value: function(t, n) {
					var i = TrailGeometry._tempVector30,
						a = TrailGeometry._tempVector31;
					switch (this._owner.alignment) {
						case e.TrailAlignment.View:
							var s = t.viewMatrix;
							o.transformCoordinate(n, s, TrailGeometry._tempVector33), o
								.transformCoordinate(this._lastFixedVertexPosition, s, TrailGeometry
									._tempVector34), o.subtract(TrailGeometry._tempVector33,
									TrailGeometry._tempVector34, i), o.cross(TrailGeometry
									._tempVector33, i, a);
							break;
						case e.TrailAlignment.TransformZ:
							o.subtract(n, this._lastFixedVertexPosition, i);
							var l = TrailGeometry._tempVector32;
							this._owner._owner.transform.getForward(l), o.cross(i, l, a)
					}
					o.normalize(a, a), o.scale(a, this._owner.widthMultiplier / 2, a);
					var u, c, h = o.scalarLength(i);
					this._needAddFirstVertex && (this._updateVerticesByPositionData(n, a, this
							._endIndex - 1), this._needAddFirstVertex = !1), h - this._owner
						.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (u = this
							._endIndex - 1, c = h - this._subDistance[u], this
							._updateVerticesByPosition(n, a, h, u), this._owner._totalLength +=
							c) : (this._endIndex === this._segementCount && this._resetData(),
							this._updateVerticesByPosition(n, a, h, this._endIndex), this._owner
							._totalLength += h, this._endIndex++), n.cloneTo(this
							._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this
							._isTempEndVertex ? (u = this._endIndex - 1, c = h - this._subDistance[
									u], this._updateVerticesByPosition(n, a, h, u), this._owner
								._totalLength += c) : (this._endIndex === this._segementCount &&
								this._resetData(), this._updateVerticesByPosition(n, a, h, this
									._endIndex), this._owner._totalLength += h, this._endIndex++),
							this._isTempEndVertex = !0)
				}
			}, {
				key: "_updateVerticesByPositionData",
				value: function(e, t, r) {
					var n = 2 * this._floatCountPerVertices1 * r,
						i = this._owner._curtime;
					this._vertices1[n] = e.x, this._vertices1[n + 1] = e.y, this._vertices1[n + 2] =
						e.z, this._vertices1[n + 3] = -t.x, this._vertices1[n + 4] = -t.y, this
						._vertices1[n + 5] = -t.z, this._vertices1[n + 6] = i, this._vertices1[n +
							7] = 1, this._vertices1[n + 8] = e.x, this._vertices1[n + 9] = e.y, this
						._vertices1[n + 10] = e.z, this._vertices1[n + 11] = t.x, this._vertices1[
							n + 12] = t.y, this._vertices1[n + 13] = t.z, this._vertices1[n + 14] =
						i, this._vertices1[n + 15] = 0;
					var a = this._owner._owner.trailRenderer.bounds,
						s = a.getMin(),
						l = a.getMax(),
						u = TrailGeometry._tempVector35,
						c = TrailGeometry._tempVector36,
						h = TrailGeometry._tempVector32;
					o.add(e, t, u), o.subtract(e, t, c), o.min(c, u, h), o.min(s, h, s), a.setMin(
						s), o.max(u, c, h), o.max(l, h, l), a.setMax(l);
					var _ = 2 * this._floatCountPerVertices1;
					this._vertexBuffer1.setData(this._vertices1.buffer, 4 * n, 4 * n, 4 * _)
				}
			}, {
				key: "_updateVerticesByPosition",
				value: function(e, t, r, n) {
					this._updateVerticesByPositionData(e, t, n), this._subDistance[n] = r, this
						._subBirthTime[n] = this._owner._curtime
				}
			}, {
				key: "_updateVertexBufferUV",
				value: function() {
					var e, t, r;
					if (this._disappearBoundsMode) {
						e = this._owner._owner.trailRenderer.bounds;
						var n = this._owner._owner.transform.position;
						e.setMin(n), e.setMax(n), t = e.getMin(), r = e.getMax()
					}
					for (var i = this._endIndex, a = 0, s = this._owner.colorGradient, l = s
							.colorAlphaKeysCount - 1, u = s.colorRGBKeysCount - 1, c = this._owner
							._totalLength, h = 2 * this._floatCountPerVertices2, _ = this
							._activeIndex; _ < i; _++) {
						var d, f;
						_ !== this._activeIndex && (a += this._subDistance[_]), this._owner
							.textureMode == hn.Stretch ? f = d = 1 - a / c : (f = 1 - a / c, d = 1 -
								(c - a)), u = s.evaluateColorRGB(f, this.tmpColor, u, !0), l = s
							.evaluateColorAlpha(f, this.tmpColor, l, !0);
						var m = _ * h;
						if (this._vertices2[m + 0] = d, this._vertices2[m + 1] = this.tmpColor.r,
							this._vertices2[m + 2] = this.tmpColor.g, this._vertices2[m + 3] = this
							.tmpColor.b, this._vertices2[m + 4] = this.tmpColor.a, this._vertices2[
								m + 5] = d, this._vertices2[m + 6] = this.tmpColor.r, this
							._vertices2[m + 7] = this.tmpColor.g, this._vertices2[m + 8] = this
							.tmpColor.b, this._vertices2[m + 9] = this.tmpColor.a, this
							._disappearBoundsMode) {
							var p = 2 * this._floatCountPerVertices1 * _,
								T = TrailGeometry._tempVector32,
								E = TrailGeometry._tempVector33,
								g = TrailGeometry._tempVector34;
							T.setValue(this._vertices1[p + 0], this._vertices1[p + 1], this
									._vertices1[p + 2]), E.setValue(this._vertices1[p + 3], this
									._vertices1[p + 4], this._vertices1[p + 5]), o.add(T, E, g), o
								.min(g, t, t), o.max(g, r, r), o.subtract(T, E, g), o.min(g, t, t),
								o.max(g, r, r)
						}
					}
					this._disappearBoundsMode && (e.setMin(t), e.setMax(r), this
						._disappearBoundsMode = !1);
					var y = this._activeIndex * h;
					this._vertexBuffer2.setData(this._vertices2.buffer, 4 * y, 4 * y, 4 * (i * h -
						y))
				}
			}, {
				key: "_updateDisappear",
				value: function() {
					for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner
						._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++
						) {
						var n = t + 1;
						if (n !== e && (this._owner._totalLength -= this._subDistance[n]), this
							._isTempEndVertex && n === e - 1) {
							this._floatCountPerVertices1;
							var i = this._lastFixedVertexPosition;
							i.x = this._vertices1[0], i.y = this._vertices1[1], i.z = this
								._vertices1[2], this._isTempEndVertex = !1
						}
						this._activeIndex++, this._disappearBoundsMode = !0
					}
				}
			}, {
				key: "_getType",
				value: function() {
					return TrailGeometry._type
				}
			}, {
				key: "_prepareRender",
				value: function(e) {
					return this._endIndex - this._activeIndex > 1
				}
			}, {
				key: "_render",
				value: function(e) {
					this._bufferState.bind();
					var r = t.LayaGL.instance,
						n = 2 * this._activeIndex,
						i = 2 * this._endIndex - n;
					r.drawArrays(r.TRIANGLE_STRIP, n, i), t.Stat.renderBatches++, t.Stat
						.trianglesFaces += i - 2
				}
			}, {
				key: "destroy",
				value: function() {
					_get(_getPrototypeOf(TrailGeometry.prototype), "destroy", this).call(this);
					var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
					t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1
						.destroy(), this._vertexBuffer2.destroy(), this._bufferState = null, this
						._vertices1 = null, this._vertexBuffer1 = null, this._vertices2 = null, this
						._vertexBuffer2 = null, this._subBirthTime = null, this._subDistance = null,
						this._lastFixedVertexPosition = null, this._disappearBoundsMode = !1
				}
			}, {
				key: "clear",
				value: function() {
					this._activeIndex = 0, this._endIndex = 0, this._disappearBoundsMode = !1, this
						._subBirthTime.fill(0), this._subDistance.fill(0), this._segementCount = 0,
						this._isTempEndVertex = !1, this._needAddFirstVertex = !1, this
						._lastFixedVertexPosition.setValue(0, 0, 0)
				}
			}]), TrailGeometry
		}(Ot);
		dn.ALIGNMENT_VIEW = 0, dn.ALIGNMENT_TRANSFORM_Z = 1, dn._tempVector30 = new o, dn._tempVector31 = new o, dn
			._tempVector32 = new o, dn._tempVector33 = new o, dn._tempVector34 = new o, dn._tempVector35 = new o, dn
			._tempVector36 = new o, dn._type = Ot._typeCounter++;
		var fn = function() {
			function TrailFilter(e) {
				_classCallCheck(this, TrailFilter), this._totalLength = 0, this._lastPosition = new o, this
					._curtime = 0, this.alignment = TrailFilter.ALIGNMENT_VIEW, this._owner = e, this
					._initDefaultData(), this.addRenderElement()
			}
			return _createClass(TrailFilter, [{
				key: "addRenderElement",
				value: function() {
					var e = this._owner._render,
						t = e._renderElements,
						r = e.sharedMaterials[0];
					r || (r = un.defaultMaterial);
					var n = new Ze;
					n.setTransform(this._owner._transform), n.render = e, n.material = r, this
						._trialGeometry = new dn(this), n.setGeometry(this._trialGeometry), t.push(
							n)
				}
			}, {
				key: "_update",
				value: function(e) {
					var t = this._owner._render;
					this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(
						TrailFilter.CURTIME, this._curtime);
					var r = this._owner.transform.position,
						n = t._renderElements[0]._geometry;
					n._updateDisappear(), n._updateTrail(e.camera, this._lastPosition, r), n
						._updateVertexBufferUV(), r.cloneTo(this._lastPosition)
				}
			}, {
				key: "_initDefaultData",
				value: function() {
					this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this
						.textureMode = hn.Stretch;
					var e = [],
						t = new U;
					t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
					var r = new U;
					r.time = 1, r.inTangent = 0, r.outTangent = 0, r.value = 1, e.push(r), this
						.widthCurve = e;
					var n = new Dr(2, 2);
					n.mode = Cr.Blend, n.addColorRGB(0, ft.WHITE), n.addColorRGB(1, ft.WHITE), n
						.addColorAlpha(0, 1), n.addColorAlpha(1, 1), this.colorGradient = n
				}
			}, {
				key: "destroy",
				value: function() {
					this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve =
						null, this._colorGradient = null
				}
			}, {
				key: "clear",
				value: function() {
					this._trialGeometry.clear(), this._lastPosition.setValue(0, 0, 0), this
						._curtime = 0, this._totalLength = 0
				}
			}, {
				key: "time",
				get: function() {
					return this._time
				},
				set: function(e) {
					this._time = e, this._owner._render._shaderValues.setNumber(TrailFilter
						.LIFETIME, e)
				}
			}, {
				key: "minVertexDistance",
				get: function() {
					return this._minVertexDistance
				},
				set: function(e) {
					this._minVertexDistance = e
				}
			}, {
				key: "widthMultiplier",
				get: function() {
					return this._widthMultiplier
				},
				set: function(e) {
					this._widthMultiplier = e
				}
			}, {
				key: "widthCurve",
				get: function() {
					return this._widthCurve
				},
				set: function(e) {
					this._widthCurve = e;
					var t, r, n = new Float32Array(4 * e.length),
						i = 0;
					for (t = 0, r = e.length; t < r; t++) n[i++] = e[t].time, n[i++] = e[t]
						.inTangent, n[i++] = e[t].outTangent, n[i++] = e[t].value;
					this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, n), this
						._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, e
							.length)
				}
			}, {
				key: "colorGradient",
				get: function() {
					return this._colorGradient
				},
				set: function(e) {
					this._colorGradient = e
				}
			}, {
				key: "textureMode",
				get: function() {
					return this._textureMode
				},
				set: function(e) {
					this._textureMode = e
				}
			}]), TrailFilter
		}();
		fn.CURTIME = _e.propertyNameToID("u_CurTime"), fn.LIFETIME = _e.propertyNameToID("u_LifeTime"), fn.WIDTHCURVE =
			_e.propertyNameToID("u_WidthCurve"), fn.WIDTHCURVEKEYLENGTH = _e.propertyNameToID("u_WidthCurveKeyLength"),
			fn.ALIGNMENT_VIEW = 0, fn.ALIGNMENT_TRANSFORM_Z = 1;
		var mn = function(e) {
				function TrailRenderer(e) {
					var t;
					return _classCallCheck(this, TrailRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						TrailRenderer).call(this, e)))._projectionViewWorldMatrix = new c, t
				}
				return _inherits(TrailRenderer, e), _createClass(TrailRenderer, [{
					key: "_calculateBoundingBox",
					value: function() {}
				}, {
					key: "_needRender",
					value: function(e, t) {
						return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds
							._getBoundBox())
					}
				}, {
					key: "_updateForNative",
					value: function(e) {
						this._owner.trailFilter._update(e)
					}
				}, {
					key: "_renderUpdate",
					value: function(e, t) {
						_get(_getPrototypeOf(TrailRenderer.prototype), "_renderUpdate", this).call(this,
							e, t)
					}
				}, {
					key: "_renderUpdateWithCamera",
					value: function(e, t) {
						var r = e.projectionViewMatrix;
						t ? (c.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this
							._shaderValues.setMatrix4x4(Ee.MVPMATRIX, this
								._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(Ee
							.MVPMATRIX, r)
					}
				}]), TrailRenderer
			}(Wt),
			pn = function(e) {
				function TrailSprite3D() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
					return _classCallCheck(this, TrailSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							TrailSprite3D).call(this, t)))._render = new mn(_assertThisInitialized(e)), e
						._geometryFilter = new fn(_assertThisInitialized(e)), e
				}
				return _inherits(TrailSprite3D, e), _createClass(TrailSprite3D, [{
					key: "_parse",
					value: function(e, r) {
						_get(_getPrototypeOf(TrailSprite3D.prototype), "_parse", this).call(this, e, r);
						var n, i, a = this._render,
							o = this._geometryFilter,
							s = e.materials;
						if (s) {
							var l = a.sharedMaterials,
								u = s.length;
							for (l.length = u, n = 0; n < u; n++) l[n] = t.Loader.getRes(s[n].path);
							a.sharedMaterials = l
						}
						o.time = e.time, o.minVertexDistance = e.minVertexDistance, o.widthMultiplier =
							e.widthMultiplier, o.textureMode = e.textureMode, null != e.alignment && (o
								.alignment = e.alignment);
						var c = [],
							h = e.widthCurve;
						for (n = 0, i = h.length; n < i; n++) {
							var _ = new U;
							_.time = h[n].time, _.inTangent = h[n].inTangent, _.outTangent = h[n]
								.outTangent, _.value = h[n].value, c.push(_)
						}
						o.widthCurve = c;
						var d = e.colorGradient,
							f = d.colorKeys,
							m = d.alphaKeys,
							p = new Dr(f.length, m.length);
						for (p.mode = d.mode, n = 0, i = f.length; n < i; n++) {
							var T = f[n];
							p.addColorRGB(T.time, new ft(T.value[0], T.value[1], T.value[2], 1))
						}
						for (n = 0, i = m.length; n < i; n++) {
							var E = m[n];
							p.addColorAlpha(E.time, E.value)
						}
						o.colorGradient = p
					}
				}, {
					key: "_onActive",
					value: function() {
						_get(_getPrototypeOf(TrailSprite3D.prototype), "_onActive", this).call(this),
							this._transform.position.cloneTo(this._geometryFilter._lastPosition)
					}
				}, {
					key: "_cloneTo",
					value: function(e, t, r) {
						var n, i;
						_get(_getPrototypeOf(TrailSprite3D.prototype), "_cloneTo", this).call(this, e,
							t, r);
						var a = e,
							o = a.trailFilter;
						o.time = this.trailFilter.time, o.minVertexDistance = this.trailFilter
							.minVertexDistance, o.widthMultiplier = this.trailFilter.widthMultiplier, o
							.textureMode = this.trailFilter.textureMode, o.alignment = this.trailFilter
							.alignment;
						var s = this.trailFilter.widthCurve,
							l = [];
						for (n = 0, i = s.length; n < i; n++) {
							var u = new U;
							s[n].cloneTo(u), l.push(u)
						}
						o.widthCurve = l;
						var c = new Dr(this.trailFilter.colorGradient.maxColorRGBKeysCount, this
							.trailFilter.colorGradient.maxColorAlphaKeysCount);
						this.trailFilter.colorGradient.cloneTo(c), o.colorGradient = c, a.trailRenderer
							.sharedMaterial = this.trailRenderer.sharedMaterial
					}
				}, {
					key: "destroy",
					value: function() {
						var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
						this.destroyed || (_get(_getPrototypeOf(TrailSprite3D.prototype), "destroy",
								this).call(this, e), this._geometryFilter.destroy(), this
							._geometryFilter = null)
					}
				}, {
					key: "clear",
					value: function() {
						this._geometryFilter.clear()
					}
				}, {
					key: "_create",
					value: function() {
						return new TrailSprite3D
					}
				}, {
					key: "trailFilter",
					get: function() {
						return this._geometryFilter
					}
				}, {
					key: "trailRenderer",
					get: function() {
						return this._render
					}
				}], [{
					key: "__init__",
					value: function() {}
				}]), TrailSprite3D
			}(kt),
			Tn = function() {
				function VertexPositionTerrain(e, t, r, n) {
					_classCallCheck(this, VertexPositionTerrain), this._position = e, this._normal = t, this
						._textureCoord0 = r, this._textureCoord1 = n
				}
				return _createClass(VertexPositionTerrain, [{
					key: "position",
					get: function() {
						return this._position
					}
				}, {
					key: "normal",
					get: function() {
						return this._normal
					}
				}, {
					key: "textureCoord0",
					get: function() {
						return this._textureCoord0
					}
				}, {
					key: "textureCoord1",
					get: function() {
						return this._textureCoord1
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexPositionTerrain._vertexDeclaration
					}
				}], [{
					key: "__init__",
					value: function() {
						VertexPositionTerrain._vertexDeclaration = new ie(40, [new ae(0, re.Vector3,
							VertexPositionTerrain.TERRAIN_POSITION0), new ae(12, re.Vector3,
							VertexPositionTerrain.TERRAIN_NORMAL0), new ae(24, re.Vector2,
							VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0), new ae(32, re
							.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1)])
					}
				}, {
					key: "vertexDeclaration",
					get: function() {
						return VertexPositionTerrain._vertexDeclaration
					}
				}]), VertexPositionTerrain
			}();
		Tn.TERRAIN_POSITION0 = 0, Tn.TERRAIN_NORMAL0 = 1, Tn.TERRAIN_TEXTURECOORDINATE0 = 2, Tn
			.TERRAIN_TEXTURECOORDINATE1 = 3;
		var En = function BulletInteractive() {
			_classCallCheck(this, BulletInteractive)
		};
		En._interactive = {
			getWorldTransform: function(e, t) {},
			setWorldTransform: function(e, t) {
				var r = v._physicObjectsMap[e];
				r._simulation._updatedRigidbodies++, r._updateTransformComponent(t)
			}
		};
		var gn = function(e) {
				function PhysicsCollider() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : m
						.COLLISIONFILTERGROUP_DEFAULTFILTER,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : m
						.COLLISIONFILTERGROUP_ALLFILTER;
					return _classCallCheck(this, PhysicsCollider), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(PhysicsCollider).call(this, t, r)))._enableProcessCollisions = !1, e
				}
				return _inherits(PhysicsCollider, e), _createClass(PhysicsCollider, [{
					key: "_addToSimulation",
					value: function() {
						this._simulation._addPhysicsCollider(this, this._collisionGroup, this
							._canCollideWith)
					}
				}, {
					key: "_removeFromSimulation",
					value: function() {
						this._simulation._removePhysicsCollider(this)
					}
				}, {
					key: "_parse",
					value: function(e) {
						null != e.friction && (this.friction = e.friction), null != e.rollingFriction &&
							(this.rollingFriction = e.rollingFriction), null != e.restitution && (this
								.restitution = e.restitution), null != e.isTrigger && (this.isTrigger =
								e.isTrigger), _get(_getPrototypeOf(PhysicsCollider.prototype), "_parse",
								this).call(this, e), this._parseShape(e.shapes)
					}
				}, {
					key: "_onAdded",
					value: function() {
						var e = k._bullet,
							t = e.btCollisionObject_create();
						e.btCollisionObject_setUserIndex(t, this.id), e
							.btCollisionObject_forceActivationState(t, v
								.ACTIVATIONSTATE_DISABLE_SIMULATION);
						var r = e.btCollisionObject_getCollisionFlags(t);
						this.owner.isStatic ? ((r & v.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (r ^= v
									.COLLISIONFLAGS_KINEMATIC_OBJECT), r |= v
								.COLLISIONFLAGS_STATIC_OBJECT) : ((r & v.COLLISIONFLAGS_STATIC_OBJECT) >
								0 && (r ^= v.COLLISIONFLAGS_STATIC_OBJECT), r |= v
								.COLLISIONFLAGS_KINEMATIC_OBJECT), e
							.btCollisionObject_setCollisionFlags(t, r), this._btColliderObject = t,
							_get(_getPrototypeOf(PhysicsCollider.prototype), "_onAdded", this).call(
								this)
					}
				}]), PhysicsCollider
			}(N),
			yn = function(r) {
				function SubMesh(e) {
					var t;
					return _classCallCheck(this, SubMesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							SubMesh).call(this)))._id = ++SubMesh._uniqueIDCounter, t._mesh = e, t
					._boneIndicesList = [], t._subIndexBufferStart = [], t._subIndexBufferCount = [], t
				}
				return _inherits(SubMesh, r), _createClass(SubMesh, [{
					key: "_setIndexRange",
					value: function(e, t) {
						this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this
							._indexBuffer.getData().buffer, 2 * e, t)
					}
				}, {
					key: "_getType",
					value: function() {
						return SubMesh._type
					}
				}, {
					key: "_prepareRender",
					value: function(e) {
						return this._mesh._uploadVerticesData(), !0
					}
				}, {
					key: "_render",
					value: function(r) {
						var n = this._mesh;
						if (n.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance
							.supportElementIndexUint32()) {
							var i, a, o = t.LayaGL.instance,
								s = r.renderElement.render._skinnedData;
							switch (n.indexFormat) {
								case e.IndexFormat.UInt32:
									i = o.UNSIGNED_INT, a = 4;
									break;
								case e.IndexFormat.UInt16:
									i = o.UNSIGNED_SHORT, a = 2;
									break;
								case e.IndexFormat.UInt8:
									i = o.UNSIGNED_BYTE, a = 1
							}
							if (n._bufferState.bind(), s)
								for (var l = s[this._indexInMesh], u = 0, c = this._boneIndicesList
										.length; u < c; u++) r.shader.uploadCustomUniform(ln.BONES, l[
									u]), o.drawElements(o.TRIANGLES, this._subIndexBufferCount[u],
									i, this._subIndexBufferStart[u] * a);
							else o.drawElements(o.TRIANGLES, this._indexCount, i, this._indexStart * a);
							t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++
						} else console.warn("SubMesh:this device do not support IndexFormat.UInt32.")
					}
				}, {
					key: "getIndices",
					value: function() {
						if (this._mesh._isReadable) return this._indices.slice();
						throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true."
					}
				}, {
					key: "setIndices",
					value: function(e) {
						this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount)
					}
				}, {
					key: "destroy",
					value: function() {
						this._destroyed || (_get(_getPrototypeOf(SubMesh.prototype), "destroy", this)
							.call(this), this._indexBuffer.destroy(), this._indexBuffer = null, this
							._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart =
							null, this._subIndexBufferCount = null, this._skinAnimationDatas = null)
					}
				}, {
					key: "indexCount",
					get: function() {
						return this._indexCount
					}
				}]), SubMesh
			}(Ot);
		yn._uniqueIDCounter = 0, yn._type = Ot._typeCounter++;
		var Sn = function skinnedMatrixCache(e, t, r) {
				_classCallCheck(this, skinnedMatrixCache), this.subMeshIndex = e, this.batchIndex = t, this
					.batchBoneIndex = r
			},
			vn = function(r) {
				function Mesh() {
					var t, r = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
					return _classCallCheck(this, Mesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(Mesh)
							.call(this)))._tempVector30 = new o, t._tempVector31 = new o, t._tempVector32 = new o, t
						._minVerticesUpdate = -1, t._maxVerticesUpdate = -1, t._needUpdateBounds = !0, t._bounds =
						new Pt(new o, new o), t._bufferState = new oe, t._instanceBufferState = new oe, t
						._instanceBufferStateType = 0, t._vertexBuffer = null, t._indexBuffer = null, t
						._skinnedMatrixCaches = [], t._vertexCount = 0, t._indexFormat = e.IndexFormat.UInt16, t
						._isReadable = r, t._subMeshes = [], t
				}
				return _inherits(Mesh, r), _createClass(Mesh, [{
					key: "_getPositionElement",
					value: function(e) {
						for (var t = e.vertexDeclaration._vertexElements, r = 0, n = t.length; r <
							n; r++) {
							var i = t[r];
							if (i._elementFormat === re.Vector3 && i._elementUsage === Ne
								.MESH_POSITION0) return i
						}
						return null
					}
				}, {
					key: "_getVerticeElementData",
					value: function(e, t) {
						e.length = this._vertexCount;
						var r = this._vertexBuffer.vertexDeclaration,
							a = r.getVertexElementByUsage(t);
						if (a) {
							var s = this._vertexBuffer.getUint8Data(),
								l = this._vertexBuffer.getFloat32Data(),
								u = r.vertexStride,
								c = u / 4,
								h = a._offset,
								_ = h / 4;
							switch (t) {
								case Ne.MESH_TEXTURECOORDINATE0:
								case Ne.MESH_TEXTURECOORDINATE1:
									for (var d = 0; d < this._vertexCount; d++) {
										var f = c * d + _;
										e[d] = new n(l[f], l[f + 1])
									}
									break;
								case Ne.MESH_POSITION0:
								case Ne.MESH_NORMAL0:
									for (d = 0; d < this._vertexCount; d++) {
										f = c * d + _;
										e[d] = new o(l[f], l[f + 1], l[f + 2])
									}
									break;
								case Ne.MESH_TANGENT0:
								case Ne.MESH_BLENDWEIGHT0:
									for (d = 0; d < this._vertexCount; d++) {
										f = c * d + _;
										e[d] = new i(l[f], l[f + 1], l[f + 2], l[f + 3])
									}
									break;
								case Ne.MESH_COLOR0:
									for (d = 0; d < this._vertexCount; d++) {
										f = c * d + _;
										e[d] = new ft(l[f], l[f + 1], l[f + 2], l[f + 3])
									}
									break;
								case Ne.MESH_BLENDINDICES0:
									for (d = 0; d < this._vertexCount; d++) {
										f = u * d + h;
										e[d] = new i(s[f], s[f + 1], s[f + 2], s[f + 3])
									}
									break;
								default:
									throw "Mesh:Unknown elementUsage."
							}
						}
					}
				}, {
					key: "_setVerticeElementData",
					value: function(e, t) {
						var r = this._vertexBuffer.vertexDeclaration,
							n = r.getVertexElementByUsage(t);
						if (n) {
							var i = this._vertexBuffer.getUint8Data(),
								a = this._vertexBuffer.getFloat32Data(),
								o = r.vertexStride,
								s = o / 4,
								l = n._offset,
								u = l / 4;
							switch (t) {
								case Ne.MESH_TEXTURECOORDINATE0:
								case Ne.MESH_TEXTURECOORDINATE1:
									for (var c = 0, h = e.length; c < h; c++) {
										var _ = s * c + u,
											d = e[c];
										a[_] = d.x, a[_ + 1] = d.y
									}
									break;
								case Ne.MESH_POSITION0:
								case Ne.MESH_NORMAL0:
									for (c = 0, h = e.length; c < h; c++) {
										_ = s * c + u;
										var f = e[c];
										a[_] = f.x, a[_ + 1] = f.y, a[_ + 2] = f.z
									}
									break;
								case Ne.MESH_TANGENT0:
								case Ne.MESH_BLENDWEIGHT0:
									for (c = 0, h = e.length; c < h; c++) {
										_ = s * c + u;
										var m = e[c];
										a[_] = m.x, a[_ + 1] = m.y, a[_ + 2] = m.z, a[_ + 3] = m.w
									}
									break;
								case Ne.MESH_COLOR0:
									for (c = 0, h = e.length; c < h; c++) {
										_ = s * c + u;
										var p = e[c];
										a[_] = p.r, a[_ + 1] = p.g, a[_ + 2] = p.b, a[_ + 3] = p.a
									}
									break;
								case Ne.MESH_BLENDINDICES0:
									for (c = 0, h = e.length; c < h; c++) {
										_ = o * c + l, m = e[c];
										i[_] = m.x, i[_ + 1] = m.y, i[_ + 2] = m.z, i[_ + 3] = m.w
									}
									break;
								default:
									throw "Mesh:Unknown elementUsage."
							}
							this._minVerticesUpdate = 0, this._maxVerticesUpdate = Number
								.MAX_SAFE_INTEGER
						} else console.warn("Mesh: the mesh don't have  this VertexElement.")
					}
				}, {
					key: "_disposeResource",
					value: function() {
						for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e]
							.destroy();
						this._btTriangleMesh && k._bullet.btStridingMeshInterface_destroy(this
								._btTriangleMesh), this._vertexBuffer.destroy(), this._indexBuffer
							.destroy(), this._bufferState.destroy(), this._instanceBufferState
						.destroy(), this._setCPUMemory(0), this._setGPUMemory(0), this._bufferState =
							null, this._instanceBufferState = null, this._vertexBuffer = null, this
							._indexBuffer = null, this._subMeshes = null, this._btTriangleMesh = null,
							this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses =
							null
					}
				}, {
					key: "_setSubMeshes",
					value: function(e) {
						this._subMeshes = e;
						for (var t = 0, r = e.length; t < r; t++) e[t]._indexInMesh = t
					}
				}, {
					key: "_setBuffer",
					value: function(e, t) {
						var r = this._bufferState;
						r.bind(), r.applyVertexBuffer(e), r.applyIndexBuffer(t), r.unBind()
					}
				}, {
					key: "_setInstanceBuffer",
					value: function(e) {
						var t = this._instanceBufferState;
						switch (t.bind(), t.applyVertexBuffer(this._vertexBuffer), t
							.applyInstanceVertexBuffer(Bt.instance.instanceWorldMatrixBuffer), t
							.applyInstanceVertexBuffer(Bt.instance.instanceMVPMatrixBuffer), e) {
							case Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR:
								t.applyInstanceVertexBuffer(Bt.instance.instanceSimpleAnimatorBuffer)
						}
						t.applyIndexBuffer(this._indexBuffer), t.unBind()
					}
				}, {
					key: "_getPhysicMesh",
					value: function() {
						if (!this._btTriangleMesh) {
							for (var e = k._bullet, t = e.btTriangleMesh_create(), r = Mesh
									._nativeTempVector30, n = Mesh._nativeTempVector31, i = Mesh
									._nativeTempVector32, a = this._tempVector30, o = this
									._tempVector31, s = this._tempVector32, l = this._vertexBuffer, u =
									this._getPositionElement(l), c = l.getFloat32Data(), h = l
									.vertexDeclaration.vertexStride / 4, _ = u._offset / 4, d = this
									._indexBuffer.getData(), f = 0, m = d.length; f < m; f += 3) {
								var p = d[f] * h + _,
									T = d[f + 1] * h + _,
									E = d[f + 2] * h + _;
								a.setValue(c[p], c[p + 1], c[p + 2]), o.setValue(c[T], c[T + 1], c[T +
										2]), s.setValue(c[E], c[E + 1], c[E + 2]), P
									._convertToBulletVec3(a, r, !0), P._convertToBulletVec3(o, n, !0), P
									._convertToBulletVec3(s, i, !0), e.btTriangleMesh_addTriangle(t, r,
										n, i, !0)
							}
							this._btTriangleMesh = t
						}
						return this._btTriangleMesh
					}
				}, {
					key: "_uploadVerticesData",
					value: function() {
						var e = this._minVerticesUpdate,
							t = this._maxVerticesUpdate;
						if (-1 !== e && -1 !== t) {
							var r = e;
							this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r,
								t - e), this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1
						}
					}
				}, {
					key: "getSubMesh",
					value: function(e) {
						return this._subMeshes[e]
					}
				}, {
					key: "getPositions",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get positions on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_POSITION0)
					}
				}, {
					key: "setPositions",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_POSITION0), this._needUpdateBounds = !0
					}
				}, {
					key: "getColors",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get colors on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_COLOR0)
					}
				}, {
					key: "setColors",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setColors() need isReadable must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_COLOR0)
					}
				}, {
					key: "getUVs",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
						if (!this._isReadable)
						throw "Mesh:can't get uvs on mesh,isReadable must be true.";
						switch (t) {
							case 0:
								this._getVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE0);
								break;
							case 1:
								this._getVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE1);
								break;
							default:
								throw "Mesh:Invalid channel."
						}
					}
				}, {
					key: "setUVs",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
						if (!this._isReadable)
						throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
						switch (t) {
							case 0:
								this._setVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE0);
								break;
							case 1:
								this._setVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE1);
								break;
							default:
								throw "Mesh:Invalid channel."
						}
					}
				}, {
					key: "getNormals",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get colors on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_NORMAL0)
					}
				}, {
					key: "setNormals",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setNormals() need must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_NORMAL0)
					}
				}, {
					key: "getTangents",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get colors on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_TANGENT0)
					}
				}, {
					key: "setTangents",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_TANGENT0)
					}
				}, {
					key: "getBoneWeights",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_BLENDWEIGHT0)
					}
				}, {
					key: "setBoneWeights",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_BLENDWEIGHT0)
					}
				}, {
					key: "getBoneIndices",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
						this._getVerticeElementData(e, Ne.MESH_BLENDINDICES0)
					}
				}, {
					key: "setBoneIndices",
					value: function(e) {
						if (!this._isReadable)
						throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
						this._setVerticeElementData(e, Ne.MESH_BLENDINDICES0)
					}
				}, {
					key: "markAsUnreadbale",
					value: function() {
						this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this
							._isReadable = !1
					}
				}, {
					key: "getVertexDeclaration",
					value: function() {
						return this._vertexBuffer._vertexDeclaration
					}
				}, {
					key: "getVertices",
					value: function() {
						if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
						throw "Mesh:can't get vertices on mesh,isReadable must be true."
					}
				}, {
					key: "setVertices",
					value: function(e) {
						this._vertexBuffer.setData(e), this._needUpdateBounds = !0
					}
				}, {
					key: "getIndices",
					value: function() {
						if (this._isReadable) return this._indexBuffer.getData().slice();
						throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true."
					}
				}, {
					key: "setIndices",
					value: function(r) {
						var n;
						r instanceof Uint32Array ? n = e.IndexFormat.UInt32 : r instanceof Uint16Array ?
							n = e.IndexFormat.UInt16 : r instanceof Uint8Array && (n = e.IndexFormat
								.UInt8);
						var i = this._indexBuffer;
						this._indexFormat === n && i.indexCount === r.length || (i.destroy(), this
							._indexBuffer = i = new Oe(n, r.length, t.LayaGL.instance.STATIC_DRAW,
								this._isReadable)), i.setData(r), this._indexFormat = n
					}
				}, {
					key: "calculateBounds",
					value: function() {
						if (!this._isReadable)
						throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
						if (this._needUpdateBounds) {
							var e = this._tempVector30,
								t = this._tempVector31;
							e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
							for (var r = this._vertexBuffer, n = this._getPositionElement(r), i = r
									.getFloat32Data(), a = r.vertexDeclaration.vertexStride / 4, o = n
									._offset / 4, s = 0, l = i.length; s < l; s += a) {
								var u = s + o,
									c = i[u],
									h = i[u + 1],
									_ = i[u + 2];
								e.x = Math.min(e.x, c), e.y = Math.min(e.y, h), e.z = Math.min(e.z, _),
									t.x = Math.max(t.x, c), t.y = Math.max(t.y, h), t.z = Math.max(t.z,
										_)
							}
							this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1
						}
					}
				}, {
					key: "cloneTo",
					value: function(t) {
						var r = t,
							n = this._vertexBuffer,
							i = new te(n._byteLength, n.bufferUsage, n.canRead);
						i.vertexDeclaration = n.vertexDeclaration, i.setData(n.getUint8Data().slice()
							.buffer), r._vertexBuffer = i, r._vertexCount = this._vertexCount;
						var a, o = this._indexBuffer,
							s = new Oe(e.IndexFormat.UInt16, o.indexCount, o.bufferUsage, o.canRead);
						s.setData(o.getData().slice()), r._indexBuffer = s, r._setBuffer(r
								._vertexBuffer, s), r._setInstanceBuffer(this._instanceBufferStateType),
							r._setCPUMemory(this.cpuMemory), r._setGPUMemory(this.gpuMemory);
						var l = this._boneNames;
						if (l) {
							var u = r._boneNames = [];
							for (a = 0; a < l.length; a++) u[a] = l[a]
						}
						var c = this._inverseBindPoses;
						if (c) {
							var h = r._inverseBindPoses = [];
							for (a = 0; a < c.length; a++) h[a] = c[a]
						}
						var _ = this._skinnedMatrixCaches.length;
						for (r._skinnedMatrixCaches.length = _, a = 0; a < _; a++) {
							var d = this._skinnedMatrixCaches[a];
							r._skinnedMatrixCaches[a] = new Sn(d.subMeshIndex, d.batchIndex, d
								.batchBoneIndex)
						}
						for (a = 0; a < this.subMeshCount; a++) {
							var f = this._subMeshes[a],
								m = f._subIndexBufferStart,
								p = f._subIndexBufferCount,
								T = f._boneIndicesList,
								E = new yn(r);
							E._subIndexBufferStart.length = m.length, E._subIndexBufferCount.length = p
								.length, E._boneIndicesList.length = T.length;
							for (var g = 0; g < m.length; g++) E._subIndexBufferStart[g] = m[g];
							for (g = 0; g < p.length; g++) E._subIndexBufferCount[g] = p[g];
							for (g = 0; g < T.length; g++) E._boneIndicesList[g] = new Uint16Array(T[
							g]);
							E._indexBuffer = s, E._indexStart = f._indexStart, E._indexCount = f
								._indexCount, E._indices = new Uint16Array(s.getData().buffer, 2 * f
									._indexStart, f._indexCount);
							var y = r._vertexBuffer;
							E._vertexBuffer = y, r._subMeshes.push(E)
						}
						r._setSubMeshes(r._subMeshes)
					}
				}, {
					key: "clone",
					value: function() {
						var e = new Mesh;
						return this.cloneTo(e), e
					}
				}, {
					key: "inverseAbsoluteBindPoses",
					get: function() {
						return this._inverseBindPoses
					}
				}, {
					key: "vertexCount",
					get: function() {
						return this._vertexCount
					}
				}, {
					key: "indexCount",
					get: function() {
						return this._indexBuffer.indexCount
					}
				}, {
					key: "subMeshCount",
					get: function() {
						return this._subMeshes.length
					}
				}, {
					key: "bounds",
					get: function() {
						return this._bounds
					},
					set: function(e) {
						this._bounds !== e && e.cloneTo(this._bounds)
					}
				}, {
					key: "indexFormat",
					get: function() {
						return this._indexFormat
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = k._bullet;
						e && (Mesh._nativeTempVector30 = e.btVector3_create(0, 0, 0), Mesh
							._nativeTempVector31 = e.btVector3_create(0, 0, 0), Mesh
							._nativeTempVector32 = e.btVector3_create(0, 0, 0))
					}
				}, {
					key: "load",
					value: function(e, r) {
						t.ILaya.loader.create(e, r, null, Mesh.MESH)
					}
				}]), Mesh
			}(t.Resource);
		vn.MESH = "MESH", vn.MESH_INSTANCEBUFFER_TYPE_NORMAL = 0, vn.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR = 1;
		var Rn = function() {
				function PrimitiveMesh() {
					_classCallCheck(this, PrimitiveMesh)
				}
				return _createClass(PrimitiveMesh, null, [{
					key: "__init__",
					value: function() {}
				}, {
					key: "_createMesh",
					value: function(r, n, i) {
						var a = t.LayaGL.instance,
							o = new vn,
							s = new yn(o),
							l = new te(4 * n.length, a.STATIC_DRAW, !0);
						l.vertexDeclaration = r, l.setData(n.buffer), o._vertexBuffer = l, o
							._vertexCount = l._byteLength / r.vertexStride;
						var u = new Oe(e.IndexFormat.UInt16, i.length, a.STATIC_DRAW, !0);
						u.setData(i), o._indexBuffer = u, o._setBuffer(l, u), o._setInstanceBuffer(o
								._instanceBufferStateType), s._vertexBuffer = l, s._indexBuffer = u, s
							._setIndexRange(0, u.indexCount);
						var c = s._subIndexBufferStart,
							h = s._subIndexBufferCount,
							_ = s._boneIndicesList;
						c.length = 1, h.length = 1, _.length = 1, c[0] = 0, h[0] = u.indexCount;
						var d = [];
						d.push(s), o._setSubMeshes(d), o.calculateBounds();
						var f = l._byteLength + u._byteLength;
						return o._setCPUMemory(f), o._setGPUMemory(f), o
					}
				}, {
					key: "createBox",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
							n = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
							i = e / 2,
							a = t / 2,
							o = r / 2,
							s = new Float32Array([-i, a, -o, 0, 1, 0, 0, 0, i, a, -o, 0, 1, 0, 1, 0, i,
								a, o, 0, 1, 0, 1, 1, -i, a, o, 0, 1, 0, 0, 1, -i, -a, -o, 0, -1, 0,
								0, 1, i, -a, -o, 0, -1, 0, 1, 1, i, -a, o, 0, -1, 0, 1, 0, -i, -a,
								o, 0, -1, 0, 0, 0, -i, a, -o, -1, 0, 0, 0, 0, -i, a, o, -1, 0, 0, 1,
								0, -i, -a, o, -1, 0, 0, 1, 1, -i, -a, -o, -1, 0, 0, 0, 1, i, a, -o,
								1, 0, 0, 1, 0, i, a, o, 1, 0, 0, 0, 0, i, -a, o, 1, 0, 0, 0, 1, i, -
								a, -o, 1, 0, 0, 1, 1, -i, a, o, 0, 0, 1, 0, 0, i, a, o, 0, 0, 1, 1,
								0, i, -a, o, 0, 0, 1, 1, 1, -i, -a, o, 0, 0, 1, 0, 1, -i, a, -o, 0,
								0, -1, 1, 0, i, a, -o, 0, 0, -1, 0, 0, i, -a, -o, 0, 0, -1, 0, 1, -
								i, -a, -o, 0, 0, -1, 1, 1
							]),
							l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11,
								8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22,
								21, 20
							]);
						return PrimitiveMesh._createMesh(n, s, l)
					}
				}, {
					key: "createCapsule",
					value: function() {
						var e, t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
							.5,
							n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2,
							i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16,
							a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32,
							o = (i + 1) * (a + 1) * 2 + 2 * (a + 1),
							s = 3 * i * (a + 1) * 2 * 2 + 2 * a * 3,
							l = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
							u = l.vertexStride / 4,
							c = new Float32Array(o * u),
							h = new Uint16Array(s),
							_ = Math.PI / 2 / i,
							d = 2 * Math.PI / a,
							f = n / 2 - r,
							m = 0,
							p = 0,
							T = 0,
							E = 0,
							g = 0,
							y = 0;
						for (e = 0; e <= i; e++)
							for (t = 0; t <= a; t++) m = r * Math.cos(e * _) * Math.cos(t * d + Math
								.PI), p = r * Math.sin(e * _), T = r * Math.cos(e * _) * Math.sin(t *
									d + Math.PI), c[E++] = m, c[E++] = p + f, c[E++] = T, c[E++] = m, c[
									E++] = p, c[E++] = T, c[E++] = 1 - t / a, c[E++] = (1 - e / i) * (
									Math.PI * r / 2 / (n + Math.PI * r)), e < i && (h[g++] = e * (a +
									1) + t + (a + 1), h[g++] = e * (a + 1) + t, h[g++] = e * (a + 1) +
									t + 1, h[g++] = e * (a + 1) + t + a, h[g++] = e * (a + 1) + t, h[
										g++] = e * (a + 1) + t + (a + 1));
						for (y += (i + 1) * (a + 1), e = 0; e <= i; e++)
							for (t = 0; t <= a; t++) m = r * Math.cos(e * _) * Math.cos(t * d + Math
								.PI), p = r * Math.sin(-e * _), T = r * Math.cos(e * _) * Math.sin(t *
									d + Math.PI), c[E++] = m, c[E++] = p - f, c[E++] = T, c[E++] = m, c[
									E++] = p, c[E++] = T, c[E++] = 1 - t / a, c[E++] = (e / i * (Math
									.PI * r / 2) + (n + Math.PI * r / 2)) / (n + Math.PI * r), e < i &&
								(h[g++] = y + e * (a + 1) + t, h[g++] = y + e * (a + 1) + t + (a + 1),
									h[g++] = y + e * (a + 1) + t + 1, h[g++] = y + e * (a + 1) + t, h[
										g++] = y + e * (a + 1) + t + a, h[g++] = y + e * (a + 1) + t + (
										a + 1));
						for (y += (i + 1) * (a + 1), t = 0; t <= a; t++) m = r * Math.cos(t * d + Math
								.PI), p = f, T = r * Math.sin(t * d + Math.PI), c[E++] = m, c[E + 8 * (
								a + 1) - 1] = m, c[E++] = p, c[E + 8 * (a + 1) - 1] = -p, c[E++] = T, c[
								E + 8 * (a + 1) - 1] = T, c[E++] = m, c[E + 8 * (a + 1) - 1] = m, c[
							E++] = 0, c[E + 8 * (a + 1) - 1] = 0, c[E++] = T, c[E + 8 * (a + 1) - 1] =
							T, c[E++] = 1 - 1 * t / a, c[E + 8 * (a + 1) - 1] = 1 - 1 * t / a, c[E++] =
							Math.PI * r / 2 / (n + Math.PI * r), c[E + 8 * (a + 1) - 1] = (Math.PI * r /
								2 + n) / (n + Math.PI * r);
						for (t = 0; t < a; t++) h[g++] = t + y + (a + 1), h[g++] = t + y + 1, h[g++] =
							t + y, h[g++] = t + y + (a + 1), h[g++] = t + y + (a + 1) + 1, h[g++] = t +
							y + 1;
						return y += 2 * (a + 1), PrimitiveMesh._createMesh(l, c, h)
					}
				}, {
					key: "createCone",
					value: function() {
						for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
								.5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
								1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
								32, i = n + 1 + 1 + 2 * (n + 1), a = 6 * n + 3 * n, s = Ne
								.getVertexDeclaration("POSITION,NORMAL,UV"), l = s.vertexStride / 4, c =
								new Float32Array(i * l), h = new Uint16Array(a), _ = 2 * Math.PI / n,
								d = r / 2, f = 0, m = 0, p = 0, T = 0, E = 0, g = new o, y = new o(0, -
									1, 0), S = new o(0, d, 0), v = new o, R = new o, C = new u, M =
								new o, D = 0, x = 0, A = 0; A <= n; A++) f = A * _, p = Math.cos(f +
								Math.PI) * t, T = d, E = Math.sin(f + Math.PI) * t, c[D++] = 0, c[D +
								8 * (n + 1) - 1] = p, c[D++] = T, c[D + 8 * (n + 1) - 1] = -T, c[D++] =
							0, c[D + 8 * (n + 1) - 1] = E, g.x = p, g.y = 0, g.z = E, v.x = p, v.y = -T,
							v.z = E, o.subtract(v, S, R), o.normalize(R, R), e = Math.acos(o.dot(y, R)),
							o.cross(y, R, M), o.normalize(M, M), u.createFromAxisAngle(M, e, C), o
							.normalize(g, g), o.transformQuat(g, C, g), o.normalize(g, g), c[D++] = g.x,
							c[D + 8 * (n + 1) - 1] = g.x, c[D++] = g.y, c[D + 8 * (n + 1) - 1] = g.y, c[
								D++] = g.z, c[D + 8 * (n + 1) - 1] = g.z, c[D++] = 1 - 1 * A / n, c[D +
								8 * (n + 1) - 1] = 1 - 1 * A / n, c[D++] = 0, c[D + 8 * (n + 1) - 1] =
							1;
						D += 8 * (n + 1);
						for (var I = 0; I < n; I++) h[x++] = I + m + (n + 1), h[x++] = I + m + 1, h[
							x++] = I + m, h[x++] = I + m + (n + 1), h[x++] = I + m + (n + 1) + 1, h[
							x++] = I + m + 1;
						m += 2 * (n + 1);
						for (var L = 0; L <= n; L++) 0 === L && (c[D++] = 0, c[D++] = -d, c[D++] = 0, c[
								D++] = 0, c[D++] = -1, c[D++] = 0, c[D++] = .5, c[D++] = .5), f = L * _,
							p = Math.cos(f + Math.PI) * t, T = -d, E = Math.sin(f + Math.PI) * t, c[
							D++] = p, c[D++] = T, c[D++] = E, c[D++] = 0, c[D++] = -1, c[D++] = 0, c[
								D++] = .5 + .5 * Math.cos(f), c[D++] = .5 + .5 * Math.sin(f);
						for (var P = 0; P < n; P++) h[x++] = 0 + m, h[x++] = P + 2 + m, h[x++] = P + 1 +
							m;
						return m += n + 1 + 1, PrimitiveMesh._createMesh(s, c, h)
					}
				}, {
					key: "createCylinder",
					value: function() {
						for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
								.5, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
								2, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
								32, n = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), i = 3 * r + 6 * r + 3 *
								r, a = Ne.getVertexDeclaration("POSITION,NORMAL,UV"), o = a
								.vertexStride / 4, s = new Float32Array(n * o), l = new Uint16Array(i),
								u = 2 * Math.PI / r, c = t / 2, h = 0, _ = 0, d = 0, f = 0, m = 0, p =
								0, T = 0, E = 0; E <= r; E++) 0 === E && (s[p++] = 0, s[p++] = c, s[
								p++] = 0, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5, s[p++] = .5),
							h = E * u, d = Math.cos(h) * e, f = c, m = Math.sin(h) * e, s[p++] = d, s[
								p++] = f, s[p++] = m, s[p++] = 0, s[p++] = 1, s[p++] = 0, s[p++] = .5 +
							.5 * Math.cos(h), s[p++] = .5 + .5 * Math.sin(h);
						for (var g = 0; g < r; g++) l[T++] = 0, l[T++] = g + 1, l[T++] = g + 2;
						_ += r + 1 + 1;
						for (var y = 0; y <= r; y++) h = y * u, d = Math.cos(h + Math.PI) * e, f = c,
							m = Math.sin(h + Math.PI) * e, s[p++] = d, s[p + 8 * (r + 1) - 1] = d, s[
								p++] = f, s[p + 8 * (r + 1) - 1] = -f, s[p++] = m, s[p + 8 * (r + 1) -
								1] = m, s[p++] = d, s[p + 8 * (r + 1) - 1] = d, s[p++] = 0, s[p + 8 * (
								r + 1) - 1] = 0, s[p++] = m, s[p + 8 * (r + 1) - 1] = m, s[p++] = 1 -
							1 * y / r, s[p + 8 * (r + 1) - 1] = 1 - 1 * y / r, s[p++] = 0, s[p + 8 * (
								r + 1) - 1] = 1;
						p += 8 * (r + 1);
						for (var S = 0; S < r; S++) l[T++] = S + _ + (r + 1), l[T++] = S + _ + 1, l[
							T++] = S + _, l[T++] = S + _ + (r + 1), l[T++] = S + _ + (r + 1) + 1, l[
							T++] = S + _ + 1;
						_ += 2 * (r + 1);
						for (var v = 0; v <= r; v++) 0 === v && (s[p++] = 0, s[p++] = -c, s[p++] = 0, s[
								p++] = 0, s[p++] = -1, s[p++] = 0, s[p++] = .5, s[p++] = .5), h = v * u,
							d = Math.cos(h + Math.PI) * e, f = -c, m = Math.sin(h + Math.PI) * e, s[
							p++] = d, s[p++] = f, s[p++] = m, s[p++] = 0, s[p++] = -1, s[p++] = 0, s[
								p++] = .5 + .5 * Math.cos(h), s[p++] = .5 + .5 * Math.sin(h);
						for (var R = 0; R < r; R++) l[T++] = 0 + _, l[T++] = R + 2 + _, l[T++] = R + 1 +
							_;
						return _ += r + 1 + 1, PrimitiveMesh._createMesh(a, s, l)
					}
				}, {
					key: "createPlane",
					value: function() {
						for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] :
								10, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] :
								10, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] :
								10, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] :
								10, i = (r + 1) * (n + 1), a = r * n * 2 * 3, o = new Uint16Array(a),
								s = Ne.getVertexDeclaration("POSITION,NORMAL,UV"), l = s.vertexStride /
								4, u = new Float32Array(i * l), c = e / 2, h = t / 2, _ = e / r, d = t /
								n, f = 0, m = 0; m <= n; m++)
							for (var p = 0; p <= r; p++) u[f++] = p * _ - c, u[f++] = 0, u[f++] = m *
								d - h, u[f++] = 0, u[f++] = 1, u[f++] = 0, u[f++] = 1 * p / r, u[f++] =
								1 * m / n;
						var T = 0;
						for (m = 0; m < n; m++)
							for (p = 0; p < r; p++) o[T++] = (m + 1) * (r + 1) + p, o[T++] = m * (r +
								1) + p, o[T++] = (m + 1) * (r + 1) + p + 1, o[T++] = m * (r + 1) + p, o[
									T++] = m * (r + 1) + p + 1, o[T++] = (m + 1) * (r + 1) + p + 1;
						return PrimitiveMesh._createMesh(s, u, o)
					}
				}, {
					key: "createQuad",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
							r = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
							n = e / 2,
							i = t / 2,
							a = new Float32Array([-n, i, 0, 0, 0, 1, 0, 0, n, i, 0, 0, 0, 1, 1, 0, -n, -
								i, 0, 0, 0, 1, 0, 1, n, -i, 0, 0, 0, 1, 1, 1
							]),
							o = new Uint16Array([0, 1, 2, 3, 2, 1]);
						return PrimitiveMesh._createMesh(r, a, o)
					}
				}, {
					key: "createSphere",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32,
							r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32,
							n = (t + 1) * (r + 1),
							i = 3 * t * (r + 1) * 2,
							a = new Uint16Array(i),
							o = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
							s = o.vertexStride / 4,
							l = new Float32Array(n * s),
							u = Math.PI / t,
							c = 2 * Math.PI / r,
							h = 0;
						n = 0, i = 0;
						for (var _ = 0; _ < t + 1; _++)
							for (var d = Math.sin(_ * u), f = Math.cos(_ * u), m = 0; m < r + 1; m++) {
								var p = d * Math.sin(m * c + 1 * Math.PI / 2),
									T = d * Math.cos(m * c + 1 * Math.PI / 2);
								l[n + 0] = p * e, l[n + 1] = f * e, l[n + 2] = T * e, l[n + 3] = p, l[
										n + 4] = f, l[n + 5] = T, l[n + 6] = m / r, l[n + 7] = _ / t,
									n += s, _ != t - 1 && (a[i++] = h + (r + 1), a[i++] = h, a[i++] =
										h + 1, a[i++] = h + r, a[i++] = h, a[i++] = h + (r + 1), h++)
							}
						return PrimitiveMesh._createMesh(o, l, a)
					}
				}]), PrimitiveMesh
			}(),
			Cn =
			'#include "Lighting.glsl";\r\n#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
			Mn = function() {
				function ShaderInit3D() {
					_classCallCheck(this, ShaderInit3D)
				}
				return _createClass(ShaderInit3D, null, [{
					key: "__init__",
					value: function() {
						_e.SHADERDEFINE_LEGACYSINGALLIGHTING = _e.getDefineByName(
								"LEGACYSINGLELIGHTING"), _e.SHADERDEFINE_GRAPHICS_API_GLES2 = _e
							.getDefineByName("GRAPHICS_API_GLES2"), _e.SHADERDEFINE_GRAPHICS_API_GLES3 =
							_e.getDefineByName("GRAPHICS_API_GLES3"), _e.addInclude("Lighting.glsl",
								"#ifdef GRAPHICS_API_GLES3\r\n\t#define INVERSE_MAT(mat) inverse(mat)\r\n#else\r\n\t#define INVERSE_MAT(mat) inverseMat(mat)\r\n#endif\r\n\r\nstruct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\n#ifndef GRAPHICS_API_GLES3\r\n\tmat3 inverseMat(mat3 m) {\r\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n\t\tfloat b01 = a22 * a11 - a12 * a21;\r\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\r\n\t\tfloat b21 = a21 * a10 - a11 * a20;\r\n\r\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n\t}\r\n#endif\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else //pixelComponent==3\r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = normalLightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n\r\n\r\n\r\n"
								), _e.addInclude("ShadowSampleTent.glsl",
								'// ------------------------------------------------------------------\r\n//  PCF Filtering Tent Functions\r\n// ------------------------------------------------------------------\r\n\r\n// Assuming a isoceles right angled triangle of height "triangleHeight" (as drawn below).\r\n// This function return the area of the triangle above the first texel(in Y the first texel).\r\n//\r\n// |\\      <-- 45 degree slop isosceles right angled triangle\r\n// | \\\r\n// ----    <-- length of this side is "triangleHeight"\r\n// _ _ _ _ <-- texels\r\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight)\r\n{\r\n    return triangleHeight - 0.5;\r\n}\r\n\r\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\r\n// This function return the area of the triangle above each of those texels.\r\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\r\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\r\n//  /   \\\r\n// _ _ _ _ <-- texels\r\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut)\r\n{\r\n    // Compute the exterior areas,a and h is same.\r\n    float a = offset + 0.5;\r\n    float offsetSquaredHalved = a * a * 0.5;\r\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\r\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\r\n\r\n    // Compute the middle areas\r\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\r\n    // intersect the axis between Y and Z (ie where offset = 0).\r\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\r\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\r\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\r\n    float clampedOffsetLeft = min(offset,0.0);\r\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\r\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\r\n\r\n    // We do the same for the Z but with the right part of the isoceles triangle\r\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\r\n    float clampedOffsetRight = max(offset,0.0);\r\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\r\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\r\n}\r\n\r\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\r\n// This function return the weight of each texels area relative to the full triangle area.\r\n//  /       \\\r\n// _ _ _ _ _ _ <-- texels\r\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB)\r\n{\r\n    vec4 areaFrom3texelTriangle;\r\n    vec4 areaUncutFrom3texelTriangle;\r\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\r\n\r\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\r\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\r\n    // 0.16 is 1/(the triangle area)\r\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\r\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\r\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\r\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\r\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\r\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\r\n}\r\n\r\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\r\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\r\n{\r\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\r\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\r\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\r\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\r\n\r\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\r\n    vec3 texelsWeightsUA, texelsWeightsUB;\r\n    vec3 texelsWeightsVA, texelsWeightsVB;\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\r\n\r\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\r\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\r\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\r\n\r\n    // move the PCF bilinear fetches to respect texels weights\r\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\r\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\r\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\r\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\r\n\r\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\r\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\r\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\r\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\r\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\r\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\r\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\r\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\r\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\r\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\r\n\r\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\r\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\r\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\r\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\r\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\r\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\r\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\r\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\r\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\r\n}'
								), _e.addInclude("GlobalIllumination.glsl",
								'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n\tvec3 worldPos;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n#ifdef SPECCUBE_BOX_PROJECTION\r\n\tuniform vec3 u_SpecCubeProbePosition;\r\n\tuniform vec3 u_SpecCubeBoxMax;\r\n\tuniform vec3 u_SpecCubeBoxMin;\r\n#endif\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n mediump vec3 BoxProjectedCubemapDirection(mediump vec3 worldRefl,mediump vec3 worldPos,mediump vec3 cubemapCenter,mediump vec3 boxMin,mediump vec3 boxMax){\r\n\t mediump vec3 nrdir = normalize(worldRefl);\r\n\t mediump vec3 rbmax = (boxMax - worldPos);\r\n\t mediump vec3 rbmin = (boxMin - worldPos);\r\n\t mediump vec3 select = step(vec3(0.0), worldRefl);\r\n\t mediump vec3 rbminmax = mix(rbmin, rbmax, select);\r\n\trbminmax = rbminmax / nrdir;\r\n\tmediump float scalar = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\r\n\t mediump vec3 worldChangeRefl = nrdir * scalar + (worldPos - cubemapCenter);\r\n\treturn worldChangeRefl;\r\n}\r\n\r\n\r\nmediump vec3 layaDecodeDirectionalLightmap (mediump vec3 color, lowp vec4 dirTex, mediump vec3 normalWorld)\r\n{\r\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\r\n    // in a way, that using it for half Lambert and then dividing by a "rebalancing coefficient"\r\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\r\n\r\n    // Note that dir is not unit length on purpose. Its length is "directionality", like\r\n    // for the directional specular lightmaps.\r\n\tlowp vec3 directional=dirTex.xyz - 0.5;\r\n\tdirectional.x=-directional.x;//NOTE:because coord System\r\n    mediump float halfLambert = dot(normalWorld,directional) + 0.5;\r\n\r\n    return color * halfLambert / max(1e-4, dirTex.w);\r\n}\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tmediump vec3 bakedColor =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\t\tlowp vec4 bakedDirTex = texture2D (u_LightMapDirection, giInput.lightmapUV);\r\n            indirectDiffuse = layaDecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);\r\n\t\t#else //unDirectional lightmap\r\n\t\t\tindirectDiffuse = bakedColor;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor; //already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\t#ifdef SPECCUBE_BOX_PROJECTION\r\n\t\tvec3 originalReflUVW = glossIn.xyz;\r\n\t\tglossIn.xyz =BoxProjectedCubemapDirection(originalReflUVW,giInput.worldPos,u_SpecCubeProbePosition,u_SpecCubeBoxMin,u_SpecCubeBoxMax);\r\n\t#endif\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n'
								), _e.addInclude("Shadow.glsl",
								'#ifndef GRAPHICS_API_GLES3\r\n\t#define NO_NATIVE_SHADOWMAP\r\n#endif\r\n\r\n#if defined(NO_NATIVE_SHADOWMAP)\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2D textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName,coord3.xy).r<coord3.z?0.0:1.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\r\n#else\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2DShadow textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName,coord3,0.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW)\r\n    #define CALCULATE_SHADOWS\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW_SPOT)\r\n\t#define CALCULATE_SPOTSHADOWS\r\n#endif\r\n\r\nuniform vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n\r\n#if defined(CALCULATE_SHADOWS)||defined(CALCULATE_SPOTSHADOWS)\r\n\t#include "ShadowSampleTent.glsl"\r\n\tuniform vec4 u_ShadowMapSize;\r\n\tuniform vec4 u_ShadowParams; // x: shadowStrength y: ShadowSpotLightStrength\r\n\r\n\t\r\n\tfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tvec4 attenuation4;\r\n\t\tvec2 offset=shadowMapSize.xy/2.0;\r\n\t\tvec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\r\n\t\tvec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\r\n\t\tvec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\r\n\t\tvec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\r\n\t\tattenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\r\n\t\tattenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\r\n\t\tattenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\r\n\t\tattenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\r\n\t\tattenuation = dot(attenuation4, vec4(0.25));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tfloat fetchesWeights[9];\r\n\t\tvec2 fetchesUV[9];\r\n\t\tsampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\r\n\t\tattenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n#if defined(CALCULATE_SHADOWS)\r\n\r\n\tTEXTURE2D_SHADOW(u_ShadowMap);\r\n\r\n\tuniform mat4 u_ShadowMatrices[4];\r\n\tuniform vec4 u_ShadowSplitSpheres[4];// max cascade is 4\r\n\r\n\tmediump int computeCascadeIndex(vec3 positionWS)\r\n\t{\r\n\t\tvec3 fromCenter0 = positionWS - u_ShadowSplitSpheres[0].xyz;\r\n\t\tvec3 fromCenter1 = positionWS - u_ShadowSplitSpheres[1].xyz;\r\n\t\tvec3 fromCenter2 = positionWS - u_ShadowSplitSpheres[2].xyz;\r\n\t\tvec3 fromCenter3 = positionWS - u_ShadowSplitSpheres[3].xyz;\r\n\r\n\t\tmediump vec4 comparison = vec4(\r\n\t\t\tdot(fromCenter0, fromCenter0)<u_ShadowSplitSpheres[0].w,\r\n\t\t\tdot(fromCenter1, fromCenter1)<u_ShadowSplitSpheres[1].w,\r\n\t\t\tdot(fromCenter2, fromCenter2)<u_ShadowSplitSpheres[2].w,\r\n\t\t\tdot(fromCenter3, fromCenter3)<u_ShadowSplitSpheres[3].w);\r\n\t\tcomparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\r\n\t\tmediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\r\n\t\tmediump int index = 4 - int(dot(comparison, indexCoefficient));\r\n\t\treturn index;\r\n\t}\r\n\r\n\tvec4 getShadowCoord(vec4 positionWS)\r\n\t{\r\n\t\t#ifdef SHADOW_CASCADE\r\n\t\t\tmediump int cascadeIndex = computeCascadeIndex(positionWS.xyz);\r\n\t\t\tif(cascadeIndex > 3)// out of shadow range cascadeIndex is 4.\r\n\t\t\t\treturn vec4(0.0);\r\n\t\t\t\r\n\t\t\t#ifdef GRAPHICS_API_GLES3\r\n\t\t\t\treturn u_ShadowMatrices[cascadeIndex] * positionWS;\r\n\t\t\t#else\r\n\t\t\t\tmat4 shadowMat;\r\n\t\t\t\tif(cascadeIndex == 0)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[0];\r\n\t\t\t\telse if(cascadeIndex == 1)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[1];\r\n\t\t\t\telse if(cascadeIndex == 2)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[2];\r\n\t\t\t\telse\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[3];\r\n\t\t\t\treturn shadowMat * positionWS;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\treturn u_ShadowMatrices[0] * positionWS;\r\n\t\t#endif\r\n\t}\r\n\r\n\tfloat sampleShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.x);//shadowParams.x:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\n#if defined(CALCULATE_SPOTSHADOWS)//shader���Զ���ĺ겻����ifdef ����ĳ�if defined\r\n\tTEXTURE2D_SHADOW(u_SpotShadowMap);\r\n\tuniform mat4 u_SpotViewProjectMatrix;\r\n\tfloat sampleSpotShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tshadowCoord.xy +=1.0;\r\n\t\tshadowCoord.xy/=2.0; \r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SPOT_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_SpotShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SPOT_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_SpotShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_SpotShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.y);//shadowParams.y:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\nvec3 applyShadowBias(vec3 positionWS, vec3 normalWS, vec3 lightDirection)\r\n{\r\n    float invNdotL = 1.0 - clamp(dot(-lightDirection, normalWS),0.0,1.0);\r\n    float scale = invNdotL * u_ShadowBias.y;\r\n\r\n    // normal bias is negative since we want to apply an inset normal offset\r\n    positionWS += -lightDirection * u_ShadowBias.xxx;\r\n    positionWS += normalWS * vec3(scale);\r\n    return positionWS;\r\n}\r\n'
								), _e.addInclude("ShadowCasterVS.glsl",
								'#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform mat4 u_ViewProjection;\r\n\r\n#ifdef SHADOW\r\n\tuniform vec3 u_ShadowLightDirection;\r\n#endif\r\n\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nvec4 shadowCasterVertex()\r\n{\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\t\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform;\r\n\t \t#ifdef SIMPLEBONE\r\n\t\t\tfloat currentPixelPos;\r\n\t\t\t#ifdef GPU_INSTANCE\r\n\t\t\t\tcurrentPixelPos = a_SimpleTextureParams.x+a_SimpleTextureParams.y;\r\n\t\t\t#else\r\n\t\t\t\tcurrentPixelPos = u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\r\n\t\t\t#endif\r\n\t\t\tfloat offset = 1.0/u_SimpleAnimatorTextureSize;\r\n\t\t\tskinTransform =  loadMatFromTexture(currentPixelPos,int(a_BoneIndices.x),offset) * a_BoneWeights.x;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.y),offset) * a_BoneWeights.y;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.z),offset) * a_BoneWeights.z;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.w),offset) * a_BoneWeights.w;\r\n\t\t#else\r\n\t\t\tskinTransform =  u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\t#endif\r\n\t\tworldMat = worldMat * skinTransform;\r\n\t#endif\r\n\r\n\tvec4 positionWS = worldMat * a_Position;\r\n\tvec3 normalWS = normalize(a_Normal*INVERSE_MAT(mat3(worldMat)));//if no normalize will cause precision problem\r\n\r\n\t#ifdef SHADOW\r\n\t\tpositionWS.xyz = applyShadowBias(positionWS.xyz,normalWS,u_ShadowLightDirection);\r\n\t#endif\r\n\r\n\tvec4 positionCS = u_ViewProjection * positionWS;\r\n\t#ifdef SHADOW_SPOT\r\n\t\tpositionCS.z = positionCS.z-u_ShadowBias.x/positionCS.w;\r\n\t#endif\r\n\tpositionCS.z = max(positionCS.z, 0.0);//min ndc z is 0.0\r\n\t\r\n\t// //TODO没考虑UV动画呢\r\n\t// #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tv_Texcoord0=a_Texcoord0;\r\n\t// #endif\r\n    return positionCS;\r\n}\r\n'
								), _e.addInclude("ShadowCasterFS.glsl",
								"// #ifdef ALPHATEST\r\n// \tuniform float u_AlphaTestValue;\r\n// #endif\r\n\r\n// #ifdef DIFFUSEMAP\r\n// \tuniform sampler2D u_DiffuseTexture;\r\n// #endif\r\n\r\n// #if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n// \tvarying vec2 v_Texcoord0;\r\n// #endif\r\n\r\nvec4 shadowCasterFragment()\r\n{\r\n    return vec4(0.0);\r\n    // #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t// \tif( alpha < u_AlphaTestValue )\r\n\t// \t{\r\n\t// \t\tdiscard;\r\n\t// \t}\r\n\t// #endif\r\n}\r\n"
								), _e.addInclude("Colors.glsl",
								'#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}'
								), _e.addInclude("Sampling.glsl",
								"// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}"
								), _e.addInclude("StdLib.glsl",
								"#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}"
								), _e.addInclude("PBRVSInput.glsl",
								"attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif"
								), _e.addInclude("PBRFSInput.glsl",
								"#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\tuniform sampler2D u_LightMapDirection;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float getAlpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float getOcclusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 getMetallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
								), _e.addInclude("LayaPBRBRDF.glsl",
								'// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------'
								), _e.addInclude("PBRCore.glsl",
								"struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#if !defined(SETUP_BRDF_INPUT)//shader内部的宏需要将改成#ifdef改成#if类型 不然会被Laya的shader分析器优化掉\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = getMetallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal,vec3 worldPos)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\tgiInput.worldPos = worldPos;\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = getAlpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = getOcclusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld,posworld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\tfloat shadowAttenuation = 1.0;\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\t#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tshadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t#endif\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tshadowAttenuation = 1.0;\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\tshadowAttenuation = sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t#endif\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tshadowAttenuation *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowAttenuation);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tshadowAttenuation = 1.0;\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\t\t\t\tshadowAttenuation= sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n\r\n"
								), _e.addInclude("PBRVertex.glsl",
								"vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform;\r\n\t \t#ifdef SIMPLEBONE\r\n\t\t\tfloat currentPixelPos;\r\n\t\t\t#ifdef GPU_INSTANCE\r\n\t\t\t\tcurrentPixelPos = a_SimpleTextureParams.x+a_SimpleTextureParams.y;\r\n\t\t\t#else\r\n\t\t\t\tcurrentPixelPos = u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\r\n\t\t\t#endif\r\n\t\t\tfloat offset = 1.0/u_SimpleAnimatorTextureSize;\r\n\t\t\tskinTransform =  loadMatFromTexture(currentPixelPos,int(a_BoneIndices.x),offset) * a_BoneWeights.x;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.y),offset) * a_BoneWeights.y;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.z),offset) * a_BoneWeights.z;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.w),offset) * a_BoneWeights.w;\r\n\t\t#else\r\n\t\t\tskinTransform =  u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\t#endif\r\n\t\tposition=skinTransform*a_Position;\r\n\t #else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax =(u_CameraPos*worldInvMat-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\tv_SpotShadowCoord = u_SpotViewProjectMatrix*vec4(v_PositionWorld,1.0);\r\n\t#endif\r\n}"
								), _e.addInclude("LayaUtile.glsl",
								"\r\n\r\n//SimpleSkinnedMesh\r\n#ifdef SIMPLEBONE\r\n\t#ifdef GPU_INSTANCE\r\n\t\tattribute vec4 a_SimpleTextureParams;\r\n\t#else\r\n\t\tuniform vec4 u_SimpleAnimatorParams;\r\n\t#endif\r\n\tuniform sampler2D u_SimpleAnimatorTexture;\r\n\r\n\tuniform float u_SimpleAnimatorTextureSize; \r\n#endif\r\n\r\n\r\n#ifdef SIMPLEBONE\r\n\tmat4 loadMatFromTexture(float FramePos,int boneIndices,float offset)\r\n\t{\r\n\t\tvec2 uv;\r\n\t\tfloat PixelPos = FramePos+float(boneIndices)*4.0;\r\n\t\tfloat halfOffset = offset * 0.5;\r\n\t\tfloat uvoffset = PixelPos/u_SimpleAnimatorTextureSize;\r\n\t\tuv.y = floor(uvoffset)*offset+halfOffset;\r\n\t\tuv.x = mod(float(PixelPos),u_SimpleAnimatorTextureSize)*offset+halfOffset;\r\n\t\tvec4 mat0row = texture2D(u_SimpleAnimatorTexture,uv);\r\n\t\tuv.x+=offset;\r\n\t\tvec4 mat1row = texture2D(u_SimpleAnimatorTexture,uv);\r\n\t\tuv.x+=offset;\r\n\t\tvec4 mat2row = texture2D(u_SimpleAnimatorTexture,uv);\r\n\t\tuv.x+=offset;\r\n\t\tvec4 mat3row = texture2D(u_SimpleAnimatorTexture,uv);\r\n\t\tmat4 m =mat4(mat0row.x,mat0row.y,mat0row.z,mat0row.w,\r\n\t\t\t\tmat1row.x,mat1row.y,mat1row.z,mat1row.w,\r\n\t\t\t\tmat2row.x,mat2row.y,mat2row.z,mat2row.w,\r\n\t\t\t\tmat3row.x,mat3row.y,mat3row.z,mat3row.w);\r\n\t\treturn m;\r\n\t}\r\n#endif\r\n\r\n"
								);
						var e = {
								a_Position: Ne.MESH_POSITION0,
								a_Color: Ne.MESH_COLOR0,
								a_Normal: Ne.MESH_NORMAL0,
								a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
								a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
								a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
								a_BoneIndices: Ne.MESH_BLENDINDICES0,
								a_Tangent0: Ne.MESH_TANGENT0,
								a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
								a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
							},
							t = {
								u_Bones: _e.PERIOD_CUSTOM,
								u_DiffuseTexture: _e.PERIOD_MATERIAL,
								u_SpecularTexture: _e.PERIOD_MATERIAL,
								u_NormalTexture: _e.PERIOD_MATERIAL,
								u_AlphaTestValue: _e.PERIOD_MATERIAL,
								u_DiffuseColor: _e.PERIOD_MATERIAL,
								u_MaterialSpecular: _e.PERIOD_MATERIAL,
								u_Shininess: _e.PERIOD_MATERIAL,
								u_TilingOffset: _e.PERIOD_MATERIAL,
								u_WorldMat: _e.PERIOD_SPRITE,
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_LightmapScaleOffset: _e.PERIOD_SPRITE,
								u_LightMap: _e.PERIOD_SPRITE,
								u_LightMapDirection: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTexture: _e.PERIOD_SPRITE,
								u_SimpleAnimatorParams: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTextureSize: _e.PERIOD_SPRITE,
								u_CameraPos: _e.PERIOD_CAMERA,
								u_Viewport: _e.PERIOD_CAMERA,
								u_ProjectionParams: _e.PERIOD_CAMERA,
								u_View: _e.PERIOD_CAMERA,
								u_ViewProjection: _e.PERIOD_CAMERA,
								u_ReflectTexture: _e.PERIOD_SCENE,
								u_FogStart: _e.PERIOD_SCENE,
								u_FogRange: _e.PERIOD_SCENE,
								u_FogColor: _e.PERIOD_SCENE,
								u_DirationLightCount: _e.PERIOD_SCENE,
								u_LightBuffer: _e.PERIOD_SCENE,
								u_LightClusterBuffer: _e.PERIOD_SCENE,
								u_AmbientColor: _e.PERIOD_SCENE,
								u_ShadowBias: _e.PERIOD_SCENE,
								u_ShadowLightDirection: _e.PERIOD_SCENE,
								u_ShadowMap: _e.PERIOD_SCENE,
								u_ShadowParams: _e.PERIOD_SCENE,
								u_ShadowSplitSpheres: _e.PERIOD_SCENE,
								u_ShadowMatrices: _e.PERIOD_SCENE,
								u_ShadowMapSize: _e.PERIOD_SCENE,
								u_SpotShadowMap: _e.PERIOD_SCENE,
								u_SpotViewProjectMatrix: _e.PERIOD_SCENE,
								u_ShadowLightPosition: _e.PERIOD_SCENE,
								u_AmbientSHAr: _e.PERIOD_SCENE,
								u_AmbientSHAg: _e.PERIOD_SCENE,
								u_AmbientSHAb: _e.PERIOD_SCENE,
								u_AmbientSHBr: _e.PERIOD_SCENE,
								u_AmbientSHBg: _e.PERIOD_SCENE,
								u_AmbientSHBb: _e.PERIOD_SCENE,
								u_AmbientSHC: _e.PERIOD_SCENE,
								"u_DirectionLight.color": _e.PERIOD_SCENE,
								"u_DirectionLight.direction": _e.PERIOD_SCENE,
								"u_PointLight.position": _e.PERIOD_SCENE,
								"u_PointLight.range": _e.PERIOD_SCENE,
								"u_PointLight.color": _e.PERIOD_SCENE,
								"u_SpotLight.position": _e.PERIOD_SCENE,
								"u_SpotLight.direction": _e.PERIOD_SCENE,
								"u_SpotLight.range": _e.PERIOD_SCENE,
								"u_SpotLight.spot": _e.PERIOD_SCENE,
								"u_SpotLight.color": _e.PERIOD_SCENE
							},
							r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							},
							n = _e.add("BLINNPHONG", null, null, !0),
							i = new cr(e, t);
						n.addSubShader(i), i.addShaderPass(
							'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n#include "Lighting.glsl";\r\n#include "LayaUtile.glsl"\r\n#include "Shadow.glsl";\r\n\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform;\r\n\t \t#ifdef SIMPLEBONE\r\n\t\t\tfloat currentPixelPos;\r\n\t\t\t#ifdef GPU_INSTANCE\r\n\t\t\t\tcurrentPixelPos = a_SimpleTextureParams.x+a_SimpleTextureParams.y;\r\n\t\t\t#else\r\n\t\t\t\tcurrentPixelPos = u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\r\n\t\t\t#endif\r\n\t\t\tfloat offset = 1.0/u_SimpleAnimatorTextureSize;\r\n\t\t\tskinTransform =  loadMatFromTexture(currentPixelPos,int(a_BoneIndices.x),offset) * a_BoneWeights.x;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.y),offset) * a_BoneWeights.y;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.z),offset) * a_BoneWeights.z;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.w),offset) * a_BoneWeights.w;\r\n\t\t#else\r\n\t\t\tskinTransform =  u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\t#endif\r\n\t\tposition=skinTransform*a_Position;\r\n\t #else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif  \r\n\tv_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\t\tvec3 positionWS=(worldMat*position).xyz;\r\n\t\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tv_ViewDir = u_CameraPos-positionWS;\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\t\t\tv_PositionWorld = positionWS;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord =getShadowCoord(vec4(positionWS,1.0));\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\tv_SpotShadowCoord = u_SpotViewProjectMatrix*vec4(positionWS,1.0);\r\n\t#endif\r\n\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
							'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))||defined(CALCULATE_SPOTSHADOWS)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tvarying vec4 v_SpotShadowCoord;\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\t#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tfloat shadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t\tdif *= shadowAttenuation;\r\n\t\t\t\tspe *= shadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\tfloat spotShadowAttenuation = sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\tdif *= spotShadowAttenuation;\r\n\t\t\t\tspe *= spotShadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\t#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tdirectionLight.color *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\t#if defined(CALCULATE_SPOTSHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvec4 spotShadowcoord = v_SpotShadowCoord;\r\n\t\t\t\t\t\t\tspotLight.color *= sampleSpotShadowmap(spotShadowcoord);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tgl_FragColor.rgb+=specular;\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\n',
							r, "Forward");
						i.addShaderPass(
							'#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}',
							'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}',
							r, "ShadowCaster");
						e = {
								a_Position: Ne.MESH_POSITION0,
								a_Color: Ne.MESH_COLOR0
							}, t = {
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_Color: _e.PERIOD_MATERIAL
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("LineShader"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n",
								r), e = {
								a_Position: Ne.MESH_POSITION0,
								a_Color: Ne.MESH_COLOR0,
								a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
								a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
								a_BoneIndices: Ne.MESH_BLENDINDICES0,
								a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0
							}, t = {
								u_Bones: _e.PERIOD_CUSTOM,
								u_AlbedoTexture: _e.PERIOD_MATERIAL,
								u_AlbedoColor: _e.PERIOD_MATERIAL,
								u_TilingOffset: _e.PERIOD_MATERIAL,
								u_AlphaTestValue: _e.PERIOD_MATERIAL,
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTexture: _e.PERIOD_SPRITE,
								u_SimpleAnimatorParams: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTextureSize: _e.PERIOD_SPRITE,
								u_FogStart: _e.PERIOD_SCENE,
								u_FogRange: _e.PERIOD_SCENE,
								u_FogColor: _e.PERIOD_SCENE
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("Unlit", null, null, !0), i = new cr(e, t), n.addSubShader(i),
							i.addShaderPass(
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n#include "Lighting.glsl";\r\n#include "LayaUtile.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform;\r\n\t \t#ifdef SIMPLEBONE\r\n\t\t\tfloat currentPixelPos;\r\n\t\t\t#ifdef GPU_INSTANCE\r\n\t\t\t\tcurrentPixelPos = a_SimpleTextureParams.x+a_SimpleTextureParams.y;\r\n\t\t\t#else\r\n\t\t\t\tcurrentPixelPos = u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\r\n\t\t\t#endif\r\n\t\t\tfloat offset = 1.0/u_SimpleAnimatorTextureSize;\r\n\t\t\tskinTransform =  loadMatFromTexture(currentPixelPos,int(a_BoneIndices.x),offset) * a_BoneWeights.x;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.y),offset) * a_BoneWeights.y;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.z),offset) * a_BoneWeights.z;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.w),offset) * a_BoneWeights.w;\r\n\t\t#else\r\n\t\t\tskinTransform =  u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\t#endif\r\n\t\tposition=skinTransform*a_Position;\r\n\t #else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n",
								r), e = {
								a_Position: Ne.MESH_POSITION0,
								a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
								a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
								a_BoneIndices: Ne.MESH_BLENDINDICES0,
								a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0
							}, t = {
								u_Bones: _e.PERIOD_CUSTOM,
								u_AlbedoTexture: _e.PERIOD_MATERIAL,
								u_AlbedoColor: _e.PERIOD_MATERIAL,
								u_TilingOffset: _e.PERIOD_MATERIAL,
								u_AlphaTestValue: _e.PERIOD_MATERIAL,
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTexture: _e.PERIOD_SPRITE,
								u_SimpleAnimatorParams: _e.PERIOD_SPRITE,
								u_SimpleAnimatorTextureSize: _e.PERIOD_SPRITE,
								u_FogStart: _e.PERIOD_SCENE,
								u_FogRange: _e.PERIOD_SCENE,
								u_FogColor: _e.PERIOD_SCENE
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("Effect", null, null, !0), i = new cr(e, t), n.addSubShader(
							i), i.addShaderPass(
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n#include "Lighting.glsl";\r\n#include "LayaUtile.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform;\r\n\t \t#ifdef SIMPLEBONE\r\n\t\t\tfloat currentPixelPos;\r\n\t\t\t#ifdef GPU_INSTANCE\r\n\t\t\t\tcurrentPixelPos = a_SimpleTextureParams.x+a_SimpleTextureParams.y;\r\n\t\t\t#else\r\n\t\t\t\tcurrentPixelPos = u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\r\n\t\t\t#endif\r\n\t\t\tfloat offset = 1.0/u_SimpleAnimatorTextureSize;\r\n\t\t\tskinTransform =  loadMatFromTexture(currentPixelPos,int(a_BoneIndices.x),offset) * a_BoneWeights.x;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.y),offset) * a_BoneWeights.y;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.z),offset) * a_BoneWeights.z;\r\n\t\t\tskinTransform += loadMatFromTexture(currentPixelPos,int(a_BoneIndices.w),offset) * a_BoneWeights.w;\r\n\t\t#else\r\n\t\t\tskinTransform =  u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\t#endif\r\n\t\tposition=skinTransform*a_Position;\r\n\t #else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n",
								r), e = {
								a_CornerTextureCoordinate: Kr.PARTICLE_CORNERTEXTURECOORDINATE0,
								a_MeshPosition: Kr.PARTICLE_POSITION0,
								a_MeshColor: Kr.PARTICLE_COLOR0,
								a_MeshTextureCoordinate: Kr.PARTICLE_TEXTURECOORDINATE0,
								a_ShapePositionStartLifeTime: Kr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
								a_DirectionTime: Kr.PARTICLE_DIRECTIONTIME,
								a_StartColor: Kr.PARTICLE_STARTCOLOR0,
								a_EndColor: Kr.PARTICLE_ENDCOLOR0,
								a_StartSize: Kr.PARTICLE_STARTSIZE,
								a_StartRotation0: Kr.PARTICLE_STARTROTATION,
								a_StartSpeed: Kr.PARTICLE_STARTSPEED,
								a_Random0: Kr.PARTICLE_RANDOM0,
								a_Random1: Kr.PARTICLE_RANDOM1,
								a_SimulationWorldPostion: Kr.PARTICLE_SIMULATIONWORLDPOSTION,
								a_SimulationWorldRotation: Kr.PARTICLE_SIMULATIONWORLDROTATION
							}, t = {
								u_Tintcolor: _e.PERIOD_MATERIAL,
								u_TilingOffset: _e.PERIOD_MATERIAL,
								u_texture: _e.PERIOD_MATERIAL,
								u_WorldPosition: _e.PERIOD_SPRITE,
								u_WorldRotation: _e.PERIOD_SPRITE,
								u_PositionScale: _e.PERIOD_SPRITE,
								u_SizeScale: _e.PERIOD_SPRITE,
								u_ScalingMode: _e.PERIOD_SPRITE,
								u_Gravity: _e.PERIOD_SPRITE,
								u_ThreeDStartRotation: _e.PERIOD_SPRITE,
								u_StretchedBillboardLengthScale: _e.PERIOD_SPRITE,
								u_StretchedBillboardSpeedScale: _e.PERIOD_SPRITE,
								u_SimulationSpace: _e.PERIOD_SPRITE,
								u_CurrentTime: _e.PERIOD_SPRITE,
								u_ColorOverLifeGradientAlphas: _e.PERIOD_SPRITE,
								u_ColorOverLifeGradientColors: _e.PERIOD_SPRITE,
								u_MaxColorOverLifeGradientAlphas: _e.PERIOD_SPRITE,
								u_MaxColorOverLifeGradientColors: _e.PERIOD_SPRITE,
								u_VOLVelocityConst: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientX: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientY: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientZ: _e.PERIOD_SPRITE,
								u_VOLVelocityConstMax: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientMaxX: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientMaxY: _e.PERIOD_SPRITE,
								u_VOLVelocityGradientMaxZ: _e.PERIOD_SPRITE,
								u_VOLSpaceType: _e.PERIOD_SPRITE,
								u_SOLSizeGradient: _e.PERIOD_SPRITE,
								u_SOLSizeGradientX: _e.PERIOD_SPRITE,
								u_SOLSizeGradientY: _e.PERIOD_SPRITE,
								u_SOLSizeGradientZ: _e.PERIOD_SPRITE,
								u_SOLSizeGradientMax: _e.PERIOD_SPRITE,
								u_SOLSizeGradientMaxX: _e.PERIOD_SPRITE,
								u_SOLSizeGradientMaxY: _e.PERIOD_SPRITE,
								u_SOLSizeGradientMaxZ: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityConst: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityConstSeprarate: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradient: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientX: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientY: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientZ: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityConstMax: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityConstMaxSeprarate: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientMax: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientMaxX: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientMaxY: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientMaxZ: _e.PERIOD_SPRITE,
								u_ROLAngularVelocityGradientMaxW: _e.PERIOD_SPRITE,
								u_TSACycles: _e.PERIOD_SPRITE,
								u_TSASubUVLength: _e.PERIOD_SPRITE,
								u_TSAGradientUVs: _e.PERIOD_SPRITE,
								u_TSAMaxGradientUVs: _e.PERIOD_SPRITE,
								u_CameraPos: _e.PERIOD_CAMERA,
								u_CameraDirection: _e.PERIOD_CAMERA,
								u_CameraUp: _e.PERIOD_CAMERA,
								u_View: _e.PERIOD_CAMERA,
								u_Projection: _e.PERIOD_CAMERA,
								u_FogStart: _e.PERIOD_SCENE,
								u_FogRange: _e.PERIOD_SCENE,
								u_FogColor: _e.PERIOD_SCENE
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("PARTICLESHURIKEN"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'// #include "Lighting.glsl";\r\n\r\n//修改这里剔除没有用到的光照函数，增加粒子的编译速度\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}",
								r), e = {
								a_Position: Ne.MESH_POSITION0
							}, t = {
								u_TintColor: _e.PERIOD_MATERIAL,
								u_Exposure: _e.PERIOD_MATERIAL,
								u_Rotation: _e.PERIOD_MATERIAL,
								u_CubeTexture: _e.PERIOD_MATERIAL,
								u_ViewProjection: _e.PERIOD_CAMERA
							}, n = _e.add("SkyBox"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n"
								), e = {
								a_Position: Ne.MESH_POSITION0
							}, t = {
								u_SunSize: _e.PERIOD_MATERIAL,
								u_SunSizeConvergence: _e.PERIOD_MATERIAL,
								u_AtmosphereThickness: _e.PERIOD_MATERIAL,
								u_SkyTint: _e.PERIOD_MATERIAL,
								u_GroundTint: _e.PERIOD_MATERIAL,
								u_Exposure: _e.PERIOD_MATERIAL,
								u_ViewProjection: _e.PERIOD_CAMERA,
								"u_SunLight.direction": _e.PERIOD_SCENE,
								"u_SunLight.color": _e.PERIOD_SCENE
							}, n = _e.add("SkyBoxProcedural"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n",
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n'
								), e = {
								a_Position: Ne.MESH_POSITION0,
								a_Normal: Ne.MESH_NORMAL0,
								a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0
							}, t = {
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_WorldMat: _e.PERIOD_SPRITE,
								u_CameraPos: _e.PERIOD_CAMERA,
								u_Viewport: _e.PERIOD_CAMERA,
								u_ProjectionParams: _e.PERIOD_CAMERA,
								u_View: _e.PERIOD_CAMERA,
								u_LightmapScaleOffset: _e.PERIOD_SPRITE,
								u_LightMap: _e.PERIOD_SPRITE,
								u_SplatAlphaTexture: _e.PERIOD_MATERIAL,
								u_DiffuseTexture1: _e.PERIOD_MATERIAL,
								u_DiffuseTexture2: _e.PERIOD_MATERIAL,
								u_DiffuseTexture3: _e.PERIOD_MATERIAL,
								u_DiffuseTexture4: _e.PERIOD_MATERIAL,
								u_DiffuseTexture5: _e.PERIOD_MATERIAL,
								u_DiffuseScaleOffset1: _e.PERIOD_MATERIAL,
								u_DiffuseScaleOffset2: _e.PERIOD_MATERIAL,
								u_DiffuseScaleOffset3: _e.PERIOD_MATERIAL,
								u_DiffuseScaleOffset4: _e.PERIOD_MATERIAL,
								u_DiffuseScaleOffset5: _e.PERIOD_MATERIAL,
								u_FogStart: _e.PERIOD_SCENE,
								u_FogRange: _e.PERIOD_SCENE,
								u_FogColor: _e.PERIOD_SCENE,
								u_DirationLightCount: _e.PERIOD_SCENE,
								u_LightBuffer: _e.PERIOD_SCENE,
								u_LightClusterBuffer: _e.PERIOD_SCENE,
								u_AmbientColor: _e.PERIOD_SCENE,
								u_ShadowMap: _e.PERIOD_SCENE,
								u_shadowMap2: _e.PERIOD_SCENE,
								u_shadowMap3: _e.PERIOD_SCENE,
								u_ShadowSplitSpheres: _e.PERIOD_SCENE,
								u_ShadowMatrices: _e.PERIOD_SCENE,
								u_ShadowMapSize: _e.PERIOD_SCENE,
								"u_DirectionLight.color": _e.PERIOD_SCENE,
								"u_DirectionLight.direction": _e.PERIOD_SCENE,
								"u_PointLight.position": _e.PERIOD_SCENE,
								"u_PointLight.range": _e.PERIOD_SCENE,
								"u_PointLight.color": _e.PERIOD_SCENE,
								"u_SpotLight.position": _e.PERIOD_SCENE,
								"u_SpotLight.direction": _e.PERIOD_SCENE,
								"u_SpotLight.range": _e.PERIOD_SCENE,
								"u_SpotLight.spot": _e.PERIOD_SCENE,
								"u_SpotLight.color": _e.PERIOD_SCENE
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("ExtendTerrain"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)//shader���Զ���ĺ겻����ifdef ����ĳ�if defined\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)//shader���Զ���ĺ겻����ifdef ����ĳ�if defined\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "Shadow.glsl"\r\n#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\tfloat shadowValue = shadowValue = sampleShadowmap(v_ShadowCoord);\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#if defined(CALCULATE_SHADOWS)//shader中自定义的宏不可用ifdef 必须改成if defined\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n',
								r), e = {
								a_Position: _n.TRAIL_POSITION0,
								a_OffsetVector: _n.TRAIL_OFFSETVECTOR,
								a_Texcoord0X: _n.TRAIL_TEXTURECOORDINATE0X,
								a_Texcoord0Y: _n.TRAIL_TEXTURECOORDINATE0Y,
								a_BirthTime: _n.TRAIL_TIME0,
								a_Color: _n.TRAIL_COLOR
							}, t = {
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_View: _e.PERIOD_CAMERA,
								u_Projection: _e.PERIOD_CAMERA,
								u_TilingOffset: _e.PERIOD_MATERIAL,
								u_MainTexture: _e.PERIOD_MATERIAL,
								u_MainColor: _e.PERIOD_MATERIAL,
								u_CurTime: _e.PERIOD_SPRITE,
								u_LifeTime: _e.PERIOD_SPRITE,
								u_WidthCurve: _e.PERIOD_SPRITE,
								u_WidthCurveKeyLength: _e.PERIOD_SPRITE,
								u_GradientColorkey: _e.PERIOD_SPRITE,
								u_GradientAlphakey: _e.PERIOD_SPRITE
							}, r = {
								s_Cull: _e.RENDER_STATE_CULL,
								s_Blend: _e.RENDER_STATE_BLEND,
								s_BlendSrc: _e.RENDER_STATE_BLEND_SRC,
								s_BlendDst: _e.RENDER_STATE_BLEND_DST,
								s_DepthTest: _e.RENDER_STATE_DEPTH_TEST,
								s_DepthWrite: _e.RENDER_STATE_DEPTH_WRITE
							}, n = _e.add("Trail"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
								"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ",
								r), e = {
								a_Position: Ne.MESH_POSITION0,
								a_Normal: Ne.MESH_NORMAL0,
								a_Tangent0: Ne.MESH_TANGENT0
							}, t = {
								u_MvpMatrix: _e.PERIOD_SPRITE,
								u_WorldMat: _e.PERIOD_SPRITE,
								u_CameraPos: _e.PERIOD_CAMERA,
								u_Time: _e.PERIOD_SCENE,
								u_MainTexture: _e.PERIOD_MATERIAL,
								u_NormalTexture: _e.PERIOD_MATERIAL,
								u_HorizonColor: _e.PERIOD_MATERIAL,
								u_WaveScale: _e.PERIOD_MATERIAL,
								u_WaveSpeed: _e.PERIOD_MATERIAL
							}, n = _e.add("WaterPrimary"), i = new cr(e, t), n.addSubShader(i), i
							.addShaderPass(
								'#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n'
								), e = {
								a_PositionTexcoord: Ne.MESH_POSITION0
							}, t = {
								u_MainTex: _e.PERIOD_MATERIAL,
								u_OffsetScale: _e.PERIOD_MATERIAL
							}, n = _e.add("BlitScreen"), i = new cr(e, t), n.addSubShader(i);
						var a = i.addShaderPass(
							'#include "Lighting.glsl";\r\n#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
							"#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n"
							).renderState;
						a.depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a.cull = at.CULL_NONE, a
							.blend = at.BLEND_DISABLE, e = {
								a_PositionTexcoord: Ne.MESH_POSITION0
							}, t = {
								u_MainTex: _e.PERIOD_MATERIAL,
								u_BloomTex: _e.PERIOD_MATERIAL,
								u_AutoExposureTex: _e.PERIOD_MATERIAL,
								u_MainTex_TexelSize: _e.PERIOD_MATERIAL,
								u_SampleScale: _e.PERIOD_MATERIAL,
								u_Threshold: _e.PERIOD_MATERIAL,
								u_Params: _e.PERIOD_MATERIAL
							}, n = _e.add("PostProcessBloom"), i = new cr(e, t), n.addSubShader(i), (a =
								i.addShaderPass(Cn,
									'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}'
									).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, i = new cr(e, t), n
							.addSubShader(i), (a = i.addShaderPass(Cn,
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, i = new cr(e, t), n
							.addSubShader(i), (a = i.addShaderPass(Cn,
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, i = new cr(e, t), n
							.addSubShader(i), (a = i.addShaderPass(Cn,
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, i = new cr(e, t), n
							.addSubShader(i), (a = i.addShaderPass(Cn,
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, i = new cr(e, t), n
							.addSubShader(i), (a = i.addShaderPass(Cn,
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE, e = {
								a_PositionTexcoord: Ne.MESH_POSITION0
							}, t = {
								u_MainTex: _e.PERIOD_MATERIAL,
								u_BloomTex: _e.PERIOD_MATERIAL,
								u_AutoExposureTex: _e.PERIOD_MATERIAL,
								u_Bloom_DirtTileOffset: _e.PERIOD_MATERIAL,
								u_Bloom_DirtTex: _e.PERIOD_MATERIAL,
								u_BloomTex_TexelSize: _e.PERIOD_MATERIAL,
								u_Bloom_Settings: _e.PERIOD_MATERIAL,
								u_Bloom_Color: _e.PERIOD_MATERIAL
							}, n = _e.add("PostProcessComposite"), i = new cr(e, t), n.addSubShader(i),
							(a = i.addShaderPass(
								'#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
								'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}'
								).renderState).depthTest = at.DEPTHTEST_ALWAYS, a.depthWrite = !1, a
							.cull = at.CULL_NONE, a.blend = at.BLEND_DISABLE
					}
				}]), ShaderInit3D
			}(),
			Dn = function(t) {
				function DirectionLight() {
					var t;
					return _classCallCheck(this, DirectionLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							DirectionLight).call(this)))._direction = new o, t._shadowCascadesMode = e
						.ShadowCascadesMode.NoCascades, t._shadowTwoCascadeSplits = 1 / 3, t._shadowFourCascadeSplits =
						new o(1 / 15, .2, 7 / 15), t._lightType = e.LightType.Directional, t
				}
				return _inherits(DirectionLight, t), _createClass(DirectionLight, [{
					key: "_addToLightQueue",
					value: function() {
						this._scene._directionLights.add(this)
					}
				}, {
					key: "_removeFromLightQueue",
					value: function() {
						this._scene._directionLights.remove(this)
					}
				}, {
					key: "_create",
					value: function() {
						return new DirectionLight
					}
				}, {
					key: "shadowCascadesMode",
					get: function() {
						return this._shadowCascadesMode
					},
					set: function(e) {
						this._shadowCascadesMode = e
					}
				}, {
					key: "shadowTwoCascadeSplits",
					get: function() {
						return this._shadowTwoCascadeSplits
					},
					set: function(e) {
						this._shadowTwoCascadeSplits = e
					}
				}, {
					key: "shadowFourCascadeSplits",
					get: function() {
						return this._shadowFourCascadeSplits
					},
					set: function(e) {
						if (e.x > e.y || e.y > e.z || e.z > 1) throw "DiretionLight:Invalid value.";
						e.cloneTo(this._shadowFourCascadeSplits)
					}
				}]), DirectionLight
			}(ze),
			xn = function(t) {
				function PointLight() {
					var t;
					return _classCallCheck(this, PointLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						PointLight).call(this)))._range = 6, t._lightType = e.LightType.Point, t
				}
				return _inherits(PointLight, t), _createClass(PointLight, [{
					key: "_addToLightQueue",
					value: function() {
						this._scene._pointLights.add(this)
					}
				}, {
					key: "_removeFromLightQueue",
					value: function() {
						this._scene._pointLights.remove(this)
					}
				}, {
					key: "_parse",
					value: function(e, t) {
						_get(_getPrototypeOf(PointLight.prototype), "_parse", this).call(this, e, t),
							this.range = e.range
					}
				}, {
					key: "_cloneTo",
					value: function(t, r, n) {
						_get(_getPrototypeOf(PointLight.prototype), "_cloneTo", this).call(this, t, r,
							n);
						var i = t;
						i.range = this.range, i._lightType = e.LightType.Point
					}
				}, {
					key: "_create",
					value: function() {
						return new PointLight
					}
				}, {
					key: "range",
					get: function() {
						return this._range
					},
					set: function(e) {
						this._range = e
					}
				}]), PointLight
			}(ze),
			An = function(t) {
				function SpotLight() {
					var t;
					return _classCallCheck(this, SpotLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(
							SpotLight).call(this)))._spotAngle = 30, t._range = 10, t._direction = new o, t._lightType =
						e.LightType.Spot, t
				}
				return _inherits(SpotLight, t), _createClass(SpotLight, [{
					key: "_addToLightQueue",
					value: function() {
						this._scene._spotLights.add(this)
					}
				}, {
					key: "_removeFromLightQueue",
					value: function() {
						this._scene._spotLights.remove(this)
					}
				}, {
					key: "_parse",
					value: function(e, t) {
						_get(_getPrototypeOf(SpotLight.prototype), "_parse", this).call(this, e, t),
							this.range = e.range, this.spotAngle = e.spotAngle
					}
				}, {
					key: "_cloneTo",
					value: function(e, t, r) {
						_get(_getPrototypeOf(SpotLight.prototype), "_cloneTo", this).call(this, e, t,
						r);
						var n = e;
						n.range = this.range, n.spotAngle = this.spotAngle
					}
				}, {
					key: "_create",
					value: function() {
						return new SpotLight
					}
				}, {
					key: "spotAngle",
					get: function() {
						return this._spotAngle
					},
					set: function(e) {
						this._spotAngle = Math.max(Math.min(e, 179), 0)
					}
				}, {
					key: "range",
					get: function() {
						return this._range
					},
					set: function(e) {
						this._range = e
					}
				}]), SpotLight
			}(ze),
			In = function(e) {
				function SimpleSkinnedMeshRenderer(e) {
					var t;
					return _classCallCheck(this, SimpleSkinnedMeshRenderer), (t = _possibleConstructorReturn(this,
							_getPrototypeOf(SimpleSkinnedMeshRenderer).call(this, e)))._simpleAnimatorParams = new i, t
						._simpleAnimatorOffset = new n, t._shaderValues.addDefine(on.SHADERDEFINE_SIMPLEBONE), t
						._shaderValues.addDefine(on.SHADERDEFINE_BONE), t
				}
				return _inherits(SimpleSkinnedMeshRenderer, e), _createClass(SimpleSkinnedMeshRenderer, [{
					key: "_computeAnimatorParamsData",
					value: function() {
						this._cacheMesh && (this._simpleAnimatorParams.x = this._simpleAnimatorOffset.x,
							this._simpleAnimatorParams.y = Math.round(this._simpleAnimatorOffset
							.y) * this._bonesNums * 4)
					}
				}, {
					key: "_createRenderElement",
					value: function() {
						return new Vt
					}
				}, {
					key: "_setCacheAnimator",
					value: function(e) {
						this._cacheAnimator = e, this._shaderValues.addDefine(on
							.SHADERDEFINE_SIMPLEBONE)
					}
				}, {
					key: "_onMeshChange",
					value: function(e) {
						_get(_getPrototypeOf(SimpleSkinnedMeshRenderer.prototype), "_onMeshChange",
							this).call(this, e), this._cacheMesh = e
					}
				}, {
					key: "_renderUpdate",
					value: function(e, t) {
						var r = e.renderElement;
						switch (r.renderType) {
							case Ze.RENDERTYPE_NORMAL:
								if (this._cacheAnimator) {
									var n = this._cacheAnimator.owner.transform.worldMatrix;
									this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, n)
								} else this._shaderValues.setMatrix4x4(Ee.WORLDMATRIX, t.worldMatrix);
								this._computeAnimatorParamsData(), this._shaderValues.setVector(
									SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORPARAMS, this
									._simpleAnimatorParams);
								break;
							case Ze.RENDERTYPE_INSTANCEBATCH:
								var i = Bt.instance.instanceWorldMatrixData,
									a = r.instanceBatchElementList,
									o = a.elements,
									s = a.length;
								if (this._cacheAnimator)
									for (var l = 0; l < s; l++) {
										var u = o[l].render._cacheAnimator.owner._transform.worldMatrix;
										i.set(u.elements, 16 * l)
									} else
										for (l = 0; l < s; l++) i.set(o[l]._transform.worldMatrix
											.elements, 16 * l);
								var c = Bt.instance.instanceWorldMatrixBuffer;
								c.orphanStorage(), c.setData(i.buffer, 0, 0, 16 * s * 4), this
									._shaderValues.addDefine(Er.SHADERDEFINE_GPU_INSTANCE);
								var h = Bt.instance.instanceSimpleAnimatorData;
								if (this._cacheAnimator)
									for (l = 0; l < s; l++) {
										var _ = o[l].render;
										_._computeAnimatorParamsData();
										var d = _._simpleAnimatorParams,
											f = 4 * l;
										h[f] = d.x, h[f + 1] = d.y
									} else
										for (l = 0; l < s; l++) h[f] = 0, h[f + 1] = 0;
								var m = Bt.instance.instanceSimpleAnimatorBuffer;
								m.orphanStorage(), m.setData(h.buffer, 0, 0, 4 * s * 4)
						}
					}
				}, {
					key: "_renderUpdateWithCamera",
					value: function(e, t) {
						var r = e.projectionViewMatrix;
						if (r) {
							var n = e.renderElement;
							switch (n.renderType) {
								case Ze.RENDERTYPE_NORMAL:
									if (this._cacheAnimator) {
										var i = this._cacheAnimator.owner._transform.worldMatrix;
										c.multiply(r, i, this._projectionViewWorldMatrix), this
											._shaderValues.setMatrix4x4(Ee.MVPMATRIX, this
												._projectionViewWorldMatrix)
									} else c.multiply(r, t.worldMatrix, this
										._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(Ee
											.MVPMATRIX, this._projectionViewWorldMatrix);
									break;
								case Ze.RENDERTYPE_INSTANCEBATCH:
									var a = Bt.instance.instanceMVPMatrixData,
										o = n.instanceBatchElementList,
										s = o.elements,
										l = o.length;
									if (this._cacheAnimator)
										for (var u = 0; u < l; u++) {
											var h = s[u].render._cacheAnimator.owner._transform
												.worldMatrix;
											P.mulMatrixByArray(r.elements, 0, h.elements, 0, a, 16 * u)
										} else
											for (u = 0; u < l; u++) {
												h = s[u]._transform.worldMatrix;
												P.mulMatrixByArray(r.elements, 0, h.elements, 0, a, 16 *
													u)
											}
									var _ = Bt.instance.instanceMVPMatrixBuffer;
									_.orphanStorage(), _.setData(a.buffer, 0, 0, 16 * l * 4)
							}
						}
					}
				}, {
					key: "_destroy",
					value: function() {
						this._cacheRootBone && !this._cacheRootBone.destroyed && this._cacheRootBone
							.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
							this._simpleAnimatorTexture && this._simpleAnimatorTexture
							._removeReference(), this._simpleAnimatorTexture = null
					}
				}, {
					key: "simpleAnimatorTexture",
					get: function() {
						return this._simpleAnimatorTexture
					},
					set: function(e) {
						this._simpleAnimatorTexture = e, this._simpleAnimatorTextureSize = e.width, this
							._shaderValues.setTexture(SimpleSkinnedMeshRenderer
								.SIMPLE_SIMPLEANIMATORTEXTURE, e), e._addReference(), this._shaderValues
							.setNumber(SimpleSkinnedMeshRenderer.SIMPLE_SIMPLEANIMATORTEXTURESIZE, this
								._simpleAnimatorTextureSize)
					}
				}, {
					key: "simpleAnimatorOffset",
					get: function() {
						return this._simpleAnimatorOffset
					},
					set: function(e) {
						e.cloneTo(this._simpleAnimatorOffset)
					}
				}]), SimpleSkinnedMeshRenderer
			}(sn),
			Ln = function(e) {
				function SimpleSkinnedMeshSprite3D() {
					var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
						r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
					return _classCallCheck(this, SimpleSkinnedMeshSprite3D), (e = _possibleConstructorReturn(this,
						_getPrototypeOf(SimpleSkinnedMeshSprite3D).call(this, r)))._meshFilter = new yr(
						_assertThisInitialized(e)), e._render = new In(_assertThisInitialized(e)), t && (e
						._meshFilter.sharedMesh = t), e
				}
				return _inherits(SimpleSkinnedMeshSprite3D, e), _createClass(SimpleSkinnedMeshSprite3D, [{
					key: "_parse",
					value: function(e, r) {
						_get(_getPrototypeOf(SimpleSkinnedMeshSprite3D.prototype), "_parse", this).call(
							this, e, r);
						var n = this.simpleSkinnedMeshRenderer,
							a = e.lightmapIndex;
						null != a && (n.lightmapIndex = a);
						var s, l = e.lightmapScaleOffset;
						if (l && (n.lightmapScaleOffset = new i(l[0], l[1], l[2], l[3])), null != e
							.enableRender && (n.enable = e.enableRender), null != e.receiveShadows && (n
								.receiveShadow = e.receiveShadows), null != e.castShadow && (n
								.castShadow = e.castShadow), s = e.meshPath) {
							var u = t.Loader.getRes(s);
							u && (this.meshFilter.sharedMesh = u)
						}
						var c = e.materials;
						if (c) {
							var h = n.sharedMaterials,
								_ = c.length;
							h.length = _;
							for (var d = 0; d < _; d++) h[d] = t.Loader.getRes(c[d].path);
							n.sharedMaterials = h
						}
						var f = e.boundBox,
							m = f.min,
							p = f.max;
						if (n.localBounds.setMin(new o(m[0], m[1], m[2])), n.localBounds.setMax(new o(p[
								0], p[1], p[2])), r) {
							var T = e.rootBone;
							n.rootBone = r[T];
							var E, g = e.bones;
							for (d = 0, E = g.length; d < E; d++) n.bones.push(r[g[d]]);
							n._bonesNums = e.bonesNums ? e.bonesNums : n.bones.length
						} else e.rootBone && n._setRootBone(e.rootBone);
						var y = e.animatorTexture;
						if (y) {
							var S = t.Loader.getRes(y);
							n.simpleAnimatorTexture = S
						}
					}
				}, {
					key: "_changeHierarchyAnimator",
					value: function(e) {
						_get(_getPrototypeOf(SimpleSkinnedMeshSprite3D.prototype),
								"_changeHierarchyAnimator", this).call(this, e), this
							.simpleSkinnedMeshRenderer._setCacheAnimator(e)
					}
				}, {
					key: "_cloneTo",
					value: function(e, t, r) {
						var n = e;
						n.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
						var i = this._render,
							a = n._render;
						a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i
							.castShadow;
						var o = i.lightmapScaleOffset;
						o && (a.lightmapScaleOffset = o.clone()), a.receiveShadow = i.receiveShadow, a
							.sortingFudge = i.sortingFudge, a._rootBone = i._rootBone;
						var s = i.bones,
							l = a.bones,
							u = s.length;
						l.length = u;
						var c = i.rootBone;
						if (c) {
							var h = P._getHierarchyPath(t, c, SimpleSkinnedMeshSprite3D._tempArray0);
							a.rootBone = h ? P._getNodeByHierarchyPath(r, h) : c
						}
						for (var _ = 0; _ < s.length; _++) h = P._getHierarchyPath(t, s[_],
								SimpleSkinnedMeshSprite3D._tempArray0), l[_] = h ? P
							._getNodeByHierarchyPath(r, h) : s[_];
						var d = i.localBounds;
						d && d.cloneTo(a.localBounds), a.simpleAnimatorOffset = i.simpleAnimatorOffset,
							a.simpleAnimatorTexture = i.simpleAnimatorTexture, a._bonesNums = i
							._bonesNums, _get(_getPrototypeOf(SimpleSkinnedMeshSprite3D.prototype),
								"_cloneTo", this).call(this, e, t, r)
					}
				}, {
					key: "destroy",
					value: function() {
						var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
						this.destroyed || (_get(_getPrototypeOf(SimpleSkinnedMeshSprite3D.prototype),
							"destroy", this).call(this, e), this._meshFilter.destroy())
					}
				}, {
					key: "_create",
					value: function() {
						return new SimpleSkinnedMeshSprite3D
					}
				}, {
					key: "meshFilter",
					get: function() {
						return this._meshFilter
					}
				}, {
					key: "simpleSkinnedMeshRenderer",
					get: function() {
						return this._render
					}
				}], [{
					key: "__init__",
					value: function() {
						In.SIMPLE_SIMPLEANIMATORPARAMS = SimpleSkinnedMeshSprite3D
							.SIMPLE_SIMPLEANIMATORPARAMS, In.SIMPLE_SIMPLEANIMATORTEXTURE =
							SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE, In
							.SIMPLE_SIMPLEANIMATORTEXTURESIZE = SimpleSkinnedMeshSprite3D
							.SIMPLE_SIMPLEANIMATORTEXTURESIZE
					}
				}]), SimpleSkinnedMeshSprite3D
			}(kt);
		Ln._tempArray0 = [], Ln.SIMPLE_SIMPLEANIMATORTEXTURE = _e.propertyNameToID("u_SimpleAnimatorTexture"), Ln
			.SIMPLE_SIMPLEANIMATORPARAMS = _e.propertyNameToID("u_SimpleAnimatorParams"), Ln
			.SIMPLE_SIMPLEANIMATORTEXTURESIZE = _e.propertyNameToID("u_SimpleAnimatorTextureSize");
		var Pn = function() {
				function Scene3DUtils() {
					_classCallCheck(this, Scene3DUtils)
				}
				return _createClass(Scene3DUtils, null, [{
					key: "_createSprite3DInstance",
					value: function(e, t, r) {
						var n;
						switch (e.type) {
							case "Scene3D":
								n = new sr;
								break;
							case "Sprite3D":
								n = new Ee;
								break;
							case "MeshSprite3D":
								n = new Rr, r && e.props.isStatic && r.push(n);
								break;
							case "SkinnedMeshSprite3D":
								n = new ln;
								break;
							case "SimpleSkinnedMeshSprite3D":
								n = new Ln;
								break;
							case "ShuriKenParticle3D":
								n = new an;
								break;
							case "Camera":
								n = new je;
								break;
							case "DirectionLight":
								n = new Dn;
								break;
							case "PointLight":
								n = new xn;
								break;
							case "SpotLight":
								n = new An;
								break;
							case "TrailSprite3D":
								n = new pn;
								break;
							case "ReflectionProbe":
								n = new zt;
								break;
							default:
								throw new Error("Utils3D:unidentified class type in (.lh) file.")
						}
						var i = e.child;
						if (i)
							for (var a = 0, o = i.length; a < o; a++) {
								var s = Scene3DUtils._createSprite3DInstance(i[a], t, r);
								n.addChild(s)
							}
						return t[e.instanceID] = n, n
					}
				}, {
					key: "_createComponentInstance",
					value: function(e, r, n) {
						var i = r[e.instanceID];
						i._parse(e.props, r);
						var a = e.child;
						if (a)
							for (var o = 0, s = a.length; o < s; o++) Scene3DUtils
								._createComponentInstance(a[o], r, n);
						var l = e.components;
						if (l)
							for (var u = 0, c = l.length; u < c; u++) {
								var h = l[u],
									_ = t.ClassUtils.getRegClass(h.type);
								if (_) i.addComponent(_)._parse(h, n);
								else console.warn("Unkown component type.")
							}
					}
				}, {
					key: "_createNodeByJson02",
					value: function(e, t) {
						var r = {},
							n = {
								component: [],
								data: []
							},
							i = Scene3DUtils._createSprite3DInstance(e, r, t);
						return Scene3DUtils._createComponentInstance(e, r, n), Scene3DUtils
							._createInteractInstance(n, r), i
					}
				}, {
					key: "_createInteractInstance",
					value: function(e, t) {
						for (var r = e.component, n = e.data, i = 0, a = r.length; i < a; i++) r[i]
							._parseInteractive(n[i], t)
					}
				}, {
					key: "_parse",
					value: function(e) {
						arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
							.length > 2 && void 0 !== arguments[2] && arguments[2];
						var t, r = e.data,
							n = [];
						switch (e.version) {
							case "LAYAHIERARCHY:02":
								t = Scene3DUtils._createNodeByJson02(r, n);
								break;
							default:
								t = Scene3DUtils._createNodeByJson(r, n)
						}
						return Ft.combine(t, n), t
					}
				}, {
					key: "_parseScene",
					value: function(e) {
						arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
							.length > 2 && void 0 !== arguments[2] && arguments[2];
						var t, r = e.data,
							n = [];
						switch (e.version) {
							case "LAYASCENE3D:02":
								t = Scene3DUtils._createNodeByJson02(r, n);
								break;
							default:
								t = Scene3DUtils._createNodeByJson(r, n)
						}
						return Ft.combine(null, n), t
					}
				}, {
					key: "_createNodeByJson",
					value: function(e, r) {
						var n;
						switch (e.type) {
							case "Scene3D":
								n = new sr;
								break;
							case "Sprite3D":
								n = new Ee;
								break;
							case "MeshSprite3D":
								n = new Rr, r && e.props.isStatic && r.push(n);
								break;
							case "SkinnedMeshSprite3D":
								n = new ln;
								break;
							case "ShuriKenParticle3D":
								n = new an;
								break;
							case "Camera":
								n = new je;
								break;
							case "DirectionLight":
								n = new Dn;
								break;
							case "PointLight":
								n = new xn;
								break;
							case "SpotLight":
								n = new An;
								break;
							case "TrailSprite3D":
								n = new pn;
								break;
							default:
								throw new Error("Utils3D:unidentified class type in (.lh) file.")
						}
						var i = e.child;
						if (i)
							for (var a = 0, o = i.length; a < o; a++) {
								var s = Scene3DUtils._createNodeByJson(i[a], r);
								n.addChild(s)
							}
						var l = e.components;
						if (l)
							for (var u = 0, c = l.length; u < c; u++) {
								var h = l[u],
									_ = t.ClassUtils.getRegClass(h.type);
								if (_) n.addComponent(_)._parse(h);
								else console.warn("Unkown component type.")
							}
						return n._parse(e.props, null), n
					}
				}]), Scene3DUtils
			}(),
			On = function() {
				function LoadModelV04() {
					_classCallCheck(this, LoadModelV04)
				}
				return _createClass(LoadModelV04, null, [{
					key: "parse",
					value: function(e, t, r, n) {
						LoadModelV04._mesh = r, LoadModelV04._subMeshes = n, LoadModelV04._version = t,
							LoadModelV04._readData = e, LoadModelV04.READ_DATA(), LoadModelV04
							.READ_BLOCK(), LoadModelV04.READ_STRINGS();
						for (var i = 0, a = LoadModelV04._BLOCK.count; i < a; i++) {
							LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
							var o = LoadModelV04._readData.getUint16(),
								s = LoadModelV04._strings[o],
								l = LoadModelV04["READ_" + s];
							if (null == l) throw new Error("model file err,no this function:" + o +
								" " + s);
							l.call(null)
						}
						LoadModelV04._strings.length = 0, LoadModelV04._readData = null, LoadModelV04
							._version = null, LoadModelV04._mesh = null, LoadModelV04._subMeshes = null
					}
				}, {
					key: "_readString",
					value: function() {
						return LoadModelV04._strings[LoadModelV04._readData.getUint16()]
					}
				}, {
					key: "READ_DATA",
					value: function() {
						LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(), LoadModelV04
							._DATA.size = LoadModelV04._readData.getUint32()
					}
				}, {
					key: "READ_BLOCK",
					value: function() {
						for (var e = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), t =
								LoadModelV04._BLOCK.blockStarts = [], r = LoadModelV04._BLOCK
								.blockLengths = [], n = 0; n < e; n++) t.push(LoadModelV04._readData
							.getUint32()), r.push(LoadModelV04._readData.getUint32())
					}
				}, {
					key: "READ_STRINGS",
					value: function() {
						var e = LoadModelV04._readData.getUint32(),
							t = LoadModelV04._readData.getUint16(),
							r = LoadModelV04._readData.pos;
						LoadModelV04._readData.pos = e + LoadModelV04._DATA.offset;
						for (var n = 0; n < t; n++) LoadModelV04._strings[n] = LoadModelV04._readData
							.readUTFString();
						LoadModelV04._readData.pos = r
					}
				}, {
					key: "READ_MESH",
					value: function() {
						var r, n = t.LayaGL.instance,
							i = (LoadModelV04._readString(), LoadModelV04._readData.__getBuffer()),
							a = 0,
							o = LoadModelV04._readData.getInt16(),
							s = LoadModelV04._DATA.offset;
						for (r = 0; r < o; r++) {
							var l, u = s + LoadModelV04._readData.getUint32(),
								h = LoadModelV04._readData.getUint32(),
								_ = i.slice(u, u + h),
								d = new Float32Array(_),
								f = LoadModelV04._readString();
							switch (LoadModelV04._version) {
								case "LAYAMODEL:0301":
								case "LAYAMODEL:0400":
									l = Ne.getVertexDeclaration(f);
									break;
								case "LAYAMODEL:0401":
									l = Ne.getVertexDeclaration(f, !1);
									break;
								default:
									throw new Error("LoadModelV03: unknown version.")
							}
							if (!l) throw new Error("LoadModelV03: unknown vertexDeclaration.");
							var m = new te(4 * d.length, n.STATIC_DRAW, !0);
							m.vertexDeclaration = l, m.setData(d.buffer), LoadModelV04._mesh
								._vertexBuffer = m, LoadModelV04._mesh._vertexCount += m._byteLength / l
								.vertexStride, a += 4 * d.length
						}
						var p = s + LoadModelV04._readData.getUint32(),
							T = LoadModelV04._readData.getUint32(),
							E = new Uint16Array(i.slice(p, p + T)),
							g = new Oe(e.IndexFormat.UInt16, T / 2, n.STATIC_DRAW, !0);
						g.setData(E), LoadModelV04._mesh._indexBuffer = g, a += 2 * g.indexCount,
							LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, g),
							LoadModelV04._mesh._setCPUMemory(a), LoadModelV04._mesh._setGPUMemory(a);
						var y = LoadModelV04._mesh._boneNames = [],
							S = LoadModelV04._readData.getUint16();
						for (y.length = S, r = 0; r < S; r++) y[r] = LoadModelV04._strings[LoadModelV04
							._readData.getUint16()];
						LoadModelV04._readData.pos += 8;
						var v = LoadModelV04._readData.getUint32(),
							R = LoadModelV04._readData.getUint32(),
							C = new Float32Array(i.slice(s + v, s + v + R)),
							M = C.length,
							D = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * M);
						for (LoadModelV04._mesh._inverseBindPoses = [], LoadModelV04._mesh
							._instanceBufferStateType = 0 != M ? vn
							.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR : vn
							.MESH_INSTANCEBUFFER_TYPE_NORMAL, LoadModelV04._mesh._setInstanceBuffer(
								LoadModelV04._mesh._instanceBufferStateType), r = 0; r < M; r += 16) {
							var x = new c(C[r + 0], C[r + 1], C[r + 2], C[r + 3], C[r + 4], C[r + 5], C[
								r + 6], C[r + 7], C[r + 8], C[r + 9], C[r + 10], C[r + 11], C[
								r + 12], C[r + 13], C[r + 14], C[r + 15], new Float32Array(D,
								4 * r, 16));
							LoadModelV04._mesh._inverseBindPoses[r / 16] = x
						}
						return !0
					}
				}, {
					key: "READ_SUBMESH",
					value: function() {
						var e = LoadModelV04._readData.__getBuffer(),
							t = new yn(LoadModelV04._mesh);
						LoadModelV04._readData.getInt16(), LoadModelV04._readData.getUint32(),
							LoadModelV04._readData.getUint32();
						var r = LoadModelV04._readData.getUint32(),
							n = LoadModelV04._readData.getUint32(),
							i = LoadModelV04._mesh._indexBuffer;
						t._indexBuffer = i, t._setIndexRange(r, n);
						var a = LoadModelV04._mesh._vertexBuffer;
						t._vertexBuffer = a;
						var o = LoadModelV04._DATA.offset,
							s = t._subIndexBufferStart,
							l = t._subIndexBufferCount,
							u = t._boneIndicesList,
							c = LoadModelV04._readData.getUint16();
						s.length = c, l.length = c, u.length = c;
						var h = LoadModelV04._mesh._skinnedMatrixCaches,
							_ = LoadModelV04._subMeshes.length;
						h.length = LoadModelV04._mesh._inverseBindPoses.length;
						for (var d = 0; d < c; d++) {
							s[d] = LoadModelV04._readData.getUint32(), l[d] = LoadModelV04._readData
								.getUint32();
							for (var f = LoadModelV04._readData.getUint32(), m = LoadModelV04._readData
									.getUint32(), p = u[d] = new Uint16Array(e.slice(o + f, o + f + m)),
									T = p.length, E = 0; E < T; E++) {
								var g = p[E];
								h[g] || (h[g] = new Sn(_, d, E))
							}
						}
						return LoadModelV04._subMeshes.push(t), !0
					}
				}]), LoadModelV04
			}();
		On._BLOCK = {
			count: 0
		}, On._DATA = {
			offset: 0,
			size: 0
		}, On._strings = [];
		var Nn = function() {
			function LoadModelV05() {
				_classCallCheck(this, LoadModelV05)
			}
			return _createClass(LoadModelV05, null, [{
				key: "parse",
				value: function(e, t, r, n) {
					LoadModelV05._mesh = r, LoadModelV05._subMeshes = n, LoadModelV05._version = t,
						LoadModelV05._readData = e, LoadModelV05.READ_DATA(), LoadModelV05
						.READ_BLOCK(), LoadModelV05.READ_STRINGS();
					for (var i = 0, a = LoadModelV05._BLOCK.count; i < a; i++) {
						LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
						var o = LoadModelV05._readData.getUint16(),
							s = LoadModelV05._strings[o],
							l = LoadModelV05["READ_" + s];
						if (null == l) throw new Error("model file err,no this function:" + o +
							" " + s);
						l.call(null)
					}
					LoadModelV05._strings.length = 0, LoadModelV05._readData = null, LoadModelV05
						._version = null, LoadModelV05._mesh = null, LoadModelV05._subMeshes = null
				}
			}, {
				key: "_readString",
				value: function() {
					return LoadModelV05._strings[LoadModelV05._readData.getUint16()]
				}
			}, {
				key: "READ_DATA",
				value: function() {
					LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(), LoadModelV05
						._DATA.size = LoadModelV05._readData.getUint32()
				}
			}, {
				key: "READ_BLOCK",
				value: function() {
					for (var e = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), t =
							LoadModelV05._BLOCK.blockStarts = [], r = LoadModelV05._BLOCK
							.blockLengths = [], n = 0; n < e; n++) t.push(LoadModelV05._readData
						.getUint32()), r.push(LoadModelV05._readData.getUint32())
				}
			}, {
				key: "READ_STRINGS",
				value: function() {
					var e = LoadModelV05._readData.getUint32(),
						t = LoadModelV05._readData.getUint16(),
						r = LoadModelV05._readData.pos;
					LoadModelV05._readData.pos = e + LoadModelV05._DATA.offset;
					for (var n = 0; n < t; n++) LoadModelV05._strings[n] = LoadModelV05._readData
						.readUTFString();
					LoadModelV05._readData.pos = r
				}
			}, {
				key: "READ_MESH",
				value: function() {
					var r, n = t.LayaGL.instance,
						i = 0,
						a = (LoadModelV05._readString(), LoadModelV05._readData),
						o = a.__getBuffer(),
						s = a.getInt16(),
						l = LoadModelV05._DATA.offset;
					for (r = 0; r < s; r++) {
						var u, h, _, d = l + a.getUint32(),
							f = a.getUint32(),
							m = LoadModelV05._readString(),
							p = Ne.getVertexDeclaration(m, !1),
							T = p.vertexStride,
							E = m.split(","),
							g = E.length,
							y = LoadModelV05._mesh;
						switch (LoadModelV05._version) {
							case "LAYAMODEL:05":
							case "LAYAMODEL:0501":
								u = o.slice(d, d + f * T), h = new Float32Array(u), _ =
									new Uint8Array(u);
								break;
							case "LAYAMODEL:COMPRESSION_05":
							case "LAYAMODEL:COMPRESSION_0501":
								u = new ArrayBuffer(T * f), h = new Float32Array(u), _ =
									new Uint8Array(u);
								var S = a.pos;
								a.pos = d;
								for (var v = 0; v < f; v++)
									for (var R, C = v * T, M = 0; M < g; M++) switch (E[M]) {
										case "POSITION":
											h[R = C / 4] = t.HalfFloatUtils.convertToNumber(a
													.getUint16()), h[R + 1] = t.HalfFloatUtils
												.convertToNumber(a.getUint16()), h[R + 2] = t
												.HalfFloatUtils.convertToNumber(a.getUint16()),
												C += 12;
											break;
										case "NORMAL":
											h[R = C / 4] = a.getUint8() / 127.5 - 1, h[R + 1] =
												a.getUint8() / 127.5 - 1, h[R + 2] = a
												.getUint8() / 127.5 - 1, C += 12;
											break;
										case "COLOR":
											h[R = C / 4] = a.getUint8() / 255, h[R + 1] = a
												.getUint8() / 255, h[R + 2] = a.getUint8() /
												255, h[R + 3] = a.getUint8() / 255, C += 16;
											break;
										case "UV":
										case "UV1":
											h[R = C / 4] = t.HalfFloatUtils.convertToNumber(a
													.getUint16()), h[R + 1] = t.HalfFloatUtils
												.convertToNumber(a.getUint16()), C += 8;
											break;
										case "BLENDWEIGHT":
											h[R = C / 4] = a.getUint8() / 255, h[R + 1] = a
												.getUint8() / 255, h[R + 2] = a.getUint8() /
												255, h[R + 3] = a.getUint8() / 255, C += 16;
											break;
										case "BLENDINDICES":
											_[C] = a.getUint8(), _[C + 1] = a.getUint8(), _[C +
													2] = a.getUint8(), _[C + 3] = a.getUint8(),
												C += 4;
											break;
										case "TANGENT":
											h[R = C / 4] = a.getUint8() / 127.5 - 1, h[R + 1] =
												a.getUint8() / 127.5 - 1, h[R + 2] = a
												.getUint8() / 127.5 - 1, h[R + 3] = a
											.getUint8() / 127.5 - 1, C += 16
									}
								a.pos = S
						}
						var D = new te(u.byteLength, n.STATIC_DRAW, !0);
						D.vertexDeclaration = p, D.setData(u);
						f = D._byteLength / p.vertexStride;
						y._indexFormat = f > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16, y
							._vertexBuffer = D, y._vertexCount += f, i += 4 * h.length
					}
					var x, A = l + a.getUint32(),
						I = a.getUint32();
					x = y.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(o.slice(A, A + I)) :
						new Uint16Array(o.slice(A, A + I));
					var L = new Oe(y.indexFormat, x.length, n.STATIC_DRAW, !0);
					if (L.setData(x), y._indexBuffer = L, y._setBuffer(y._vertexBuffer, L), i += 2 *
						L.indexCount, y._setCPUMemory(i), y._setGPUMemory(i), "LAYAMODEL:0501" ==
						LoadModelV05._version || "LAYAMODEL:COMPRESSION_0501" == LoadModelV05
						._version) {
						var P = y.bounds,
							O = P.getMin(),
							N = P.getMax();
						O.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()), N.setValue(a
								.getFloat32(), a.getFloat32(), a.getFloat32()), P.setMin(O), P
							.setMax(N), y.bounds = P
					}
					var b = y._boneNames = [],
						k = a.getUint16();
					for (b.length = k, r = 0; r < k; r++) b[r] = LoadModelV05._strings[a
					.getUint16()];
					var w = a.getUint32(),
						B = a.getUint32(),
						V = new Float32Array(o.slice(l + w, l + w + B)),
						F = V.length,
						U = y._inverseBindPosesBuffer = new ArrayBuffer(4 * F);
					for (y._inverseBindPoses = [], y._instanceBufferStateType = 0 != F ? vn
						.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR : vn
						.MESH_INSTANCEBUFFER_TYPE_NORMAL, y._setInstanceBuffer(y
							._instanceBufferStateType), r = 0; r < F; r += 16) {
						var G = new c(V[r + 0], V[r + 1], V[r + 2], V[r + 3], V[r + 4], V[r + 5], V[
							r + 6], V[r + 7], V[r + 8], V[r + 9], V[r + 10], V[r + 11], V[
							r + 12], V[r + 13], V[r + 14], V[r + 15], new Float32Array(U,
							4 * r, 16));
						y._inverseBindPoses[r / 16] = G
					}
					return !0
				}
			}, {
				key: "READ_SUBMESH",
				value: function() {
					var e = LoadModelV05._readData,
						t = e.__getBuffer(),
						r = new yn(LoadModelV05._mesh);
					e.getInt16();
					var n = e.getUint32(),
						i = e.getUint32(),
						a = LoadModelV05._mesh._indexBuffer;
					r._indexBuffer = a, r._setIndexRange(n, i);
					var o = LoadModelV05._mesh._vertexBuffer;
					r._vertexBuffer = o;
					var s = LoadModelV05._DATA.offset,
						l = r._subIndexBufferStart,
						u = r._subIndexBufferCount,
						c = r._boneIndicesList,
						h = e.getUint16();
					l.length = h, u.length = h, c.length = h;
					var _ = LoadModelV05._mesh._skinnedMatrixCaches,
						d = LoadModelV05._subMeshes.length;
					_.length = LoadModelV05._mesh._inverseBindPoses.length;
					for (var f = 0; f < h; f++) {
						l[f] = e.getUint32(), u[f] = e.getUint32();
						for (var m = e.getUint32(), p = e.getUint32(), T = c[f] = new Uint16Array(t
								.slice(s + m, s + m + p)), E = 0, g = T.length; E < g; E++) {
							var y = T[E];
							_[y] || (_[y] = new Sn(d, f, E))
						}
					}
					return LoadModelV05._subMeshes.push(r), !0
				}
			}]), LoadModelV05
		}();
		Nn._BLOCK = {
			count: 0
		}, Nn._DATA = {
			offset: 0,
			size: 0
		}, Nn._strings = [];
		var bn = function() {
				function MeshReader() {
					_classCallCheck(this, MeshReader)
				}
				return _createClass(MeshReader, null, [{
					key: "_parse",
					value: function(e) {
						arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments
							.length > 2 && void 0 !== arguments[2] && arguments[2];
						var t = new vn;
						return MeshReader.read(e, t, t._subMeshes), t
					}
				}, {
					key: "read",
					value: function(e, r, n) {
						var i = new t.Byte(e);
						i.pos = 0;
						var a = i.readUTFString();
						switch (a) {
							case "LAYAMODEL:0301":
							case "LAYAMODEL:0400":
							case "LAYAMODEL:0401":
								On.parse(i, a, r, n);
								break;
							case "LAYAMODEL:05":
							case "LAYAMODEL:COMPRESSION_05":
							case "LAYAMODEL:0501":
							case "LAYAMODEL:COMPRESSION_0501":
								Nn.parse(i, a, r, n);
								break;
							default:
								throw new Error("MeshReader: unknown mesh version.")
						}
						r._setSubMeshes(n), "LAYAMODEL:0501" != a && "LAYAMODEL:COMPRESSION_0501" !=
							a && r.calculateBounds()
					}
				}]), MeshReader
			}(),
			kn = function(e) {
				function SkyPanoramicMaterial() {
					var e;
					_classCallCheck(this, SkyPanoramicMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							SkyPanoramicMaterial).call(this)))._exposure = 1, e._textureDecodeFormat = t
						.TextureDecodeFormat.Normal, e._textureHDRParams = new i(1, 0, 0, 1), e.setShaderName(
							"SkyPanoramic");
					var r = e._shaderValues;
					return r.setVector(SkyPanoramicMaterial.TINTCOLOR, new i(.5, .5, .5, .5)), r.setNumber(
						SkyPanoramicMaterial.ROTATION, 0), r.setVector(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, e
						._textureHDRParams), e
				}
				return _inherits(SkyPanoramicMaterial, e), _createClass(SkyPanoramicMaterial, [{
					key: "tintColor",
					get: function() {
						return this._shaderValues.getVector(SkyPanoramicMaterial.TINTCOLOR)
					},
					set: function(e) {
						this._shaderValues.setVector(SkyPanoramicMaterial.TINTCOLOR, e)
					}
				}, {
					key: "exposure",
					get: function() {
						return this._exposure
					},
					set: function(e) {
						this._exposure !== e && (this._exposure = e, this._textureDecodeFormat == t
							.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture
							._rgbmRange : this._textureHDRParams.x = e)
					}
				}, {
					key: "rotation",
					get: function() {
						return this._shaderValues.getNumber(SkyPanoramicMaterial.ROTATION)
					},
					set: function(e) {
						this._shaderValues.setNumber(SkyPanoramicMaterial.ROTATION, e)
					}
				}, {
					key: "panoramicTexture",
					get: function() {
						return this._shaderValues.getTexture(SkyPanoramicMaterial.TEXTURE)
					},
					set: function(e) {
						this._shaderValues.setTexture(SkyPanoramicMaterial.TEXTURE, e)
					}
				}, {
					key: "panoramicTextureDecodeFormat",
					get: function() {
						return this._textureDecodeFormat
					},
					set: function(e) {
						this._textureDecodeFormat !== e && (this._textureDecodeFormat = e, e == t
							.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure *
							t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure)
					}
				}], [{
					key: "__init__",
					value: function() {
						var e = {
								a_Position: Ne.MESH_POSITION0
							},
							t = {
								u_TintColor: _e.PERIOD_MATERIAL,
								u_TextureHDRParams: _e.PERIOD_MATERIAL,
								u_Rotation: _e.PERIOD_MATERIAL,
								u_Texture: _e.PERIOD_MATERIAL,
								u_ViewProjection: _e.PERIOD_CAMERA
							},
							r = _e.add("SkyPanoramic"),
							n = new cr(e, t);
						r.addSubShader(n), n.addShaderPass(
							'#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n',
							'#if defined(GL_FRAGMENT_PRECISION_HIGH)// 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n'
							)
					}
				}]), SkyPanoramicMaterial
			}(nt);
		kn.TINTCOLOR = _e.propertyNameToID("u_TintColor"), kn.EXPOSURE = _e.propertyNameToID("u_Exposure"), kn
			.ROTATION = _e.propertyNameToID("u_Rotation"), kn.TEXTURE = _e.propertyNameToID("u_Texture"), kn
			.TEXTURE_HDR_PARAMS = _e.propertyNameToID("u_TextureHDRParams");
		var wn = function(e) {
			function ConstraintComponent(e) {
				var t;
				_classCallCheck(this, ConstraintComponent), (t = _possibleConstructorReturn(this, _getPrototypeOf(
						ConstraintComponent).call(this)))._anchor = new o, t._connectAnchor = new o, t
					._feedbackEnabled = !1, t._getJointFeedBack = !1, t._currentForce = new o, t._currentTorque =
					new o, t._constraintType = e;
				var r = k._bullet;
				return t._btframATrans = r.btTransform_create(), t._btframBTrans = r.btTransform_create(), r
					.btTransform_setIdentity(t._btframATrans), r.btTransform_setIdentity(t._btframBTrans), t
					._btframAPos = r.btVector3_create(0, 0, 0), t._btframBPos = r.btVector3_create(0, 0, 0), r
					.btTransform_setOrigin(t._btframATrans, t._btframAPos), r.btTransform_setOrigin(t._btframBTrans,
						t._btframBPos), t._breakForce = -1, t._breakTorque = -1, t
			}
			return _inherits(ConstraintComponent, e), _createClass(ConstraintComponent, [{
				key: "setOverrideNumSolverIterations",
				value: function(e) {
					k._bullet.btTypedConstraint_setOverrideNumSolverIterations(this._btConstraint,
						e)
				}
			}, {
				key: "setConstraintEnabled",
				value: function(e) {
					k._bullet.btTypedConstraint_setEnabled(this._btConstraint, e)
				}
			}, {
				key: "_onEnable",
				value: function() {
					_get(_getPrototypeOf(ConstraintComponent.prototype), "_onEnable", this).call(
						this), this.enabled = !0
				}
			}, {
				key: "_onDisable",
				value: function() {
					_get(_getPrototypeOf(ConstraintComponent.prototype), "_onDisable", this).call(
						this), this.enabled = !1
				}
			}, {
				key: "setFrames",
				value: function() {
					var e = k._bullet;
					e.btVector3_setValue(this._btframAPos, -this._anchor.x, this.anchor.y, this
							.anchor.z), e.btVector3_setValue(this._btframBPos, -this._connectAnchor
							.x, this._connectAnchor.y, this._connectAnchor.z), e
						.btTransform_setOrigin(this._btframATrans, this._btframAPos), e
						.btTransform_setOrigin(this._btframBTrans, this._btframBPos)
				}
			}, {
				key: "_addToSimulation",
				value: function() {}
			}, {
				key: "_removeFromSimulation",
				value: function() {}
			}, {
				key: "_createConstraint",
				value: function() {}
			}, {
				key: "setConnectRigidBody",
				value: function(e, t) {
					var r = e && !!(e._simulation && e._enabled && e.colliderShape),
						n = t && !!(t._simulation && t._enabled && t.colliderShape);
					if (!r || !n) throw "ownerRigid or connectRigidBody is not in Simulation";
					e == this._ownBody && t == this._connectedBody || (!(!this.enabled || !this
							._simulation) && this._removeFromSimulation(), this._ownBody = e,
						this._connectedBody = t, this._ownBody.constaintRigidbodyA = this, this
						._connectedBody.constaintRigidbodyB = this, this._createConstraint())
				}
			}, {
				key: "getcurrentForce",
				value: function(e) {
					if (!this._btJointFeedBackObj) throw "this Constraint is not simulation";
					var t = k._bullet,
						r = t.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj);
					e.setValue(t.btVector3_x(r), t.btVector3_y(r), t.btVector3_z(r))
				}
			}, {
				key: "getcurrentTorque",
				value: function(e) {
					if (!this._btJointFeedBackObj) throw "this Constraint is not simulation";
					var t = k._bullet,
						r = t.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
					e.setValue(t.btVector3_x(r), t.btVector3_y(r), t.btVector3_z(r))
				}
			}, {
				key: "_onDestroy",
				value: function() {
					var e = k._bullet;
					this._simulation && this._removeFromSimulation(), this._btConstraint && this
						._btJointFeedBackObj && this._simulation && (e.btTypedConstraint_destroy(
								this._btConstraint), e.btJointFeedback_destroy(this
								._btJointFeedBackObj), this._btJointFeedBackObj = null, this
							._btConstraint = null), _get(_getPrototypeOf(ConstraintComponent
							.prototype), "_onDisable", this).call(this)
				}
			}, {
				key: "_isBreakConstrained",
				value: function() {
					if (this._getJointFeedBack = !1, -1 == this.breakForce && -1 == this
						.breakTorque) return !1;
					this._getFeedBackInfo();
					var e = -1 != this._breakForce && o.scalarLength(this._currentForce) > this
						._breakForce,
						t = -1 != this._breakTorque && o.scalarLength(this._currentTorque) > this
						._breakTorque;
					return !(!e && !t) && (this._breakConstrained(), !0)
				}
			}, {
				key: "_parse",
				value: function(e) {
					this._anchor.fromArray(e.anchor), this._connectAnchor.fromArray(e
						.connectAnchor), this.setFrames()
				}
			}, {
				key: "_getFeedBackInfo",
				value: function() {
					var e = k._bullet,
						t = e.btJointFeedback_getAppliedForceBodyA(this._btJointFeedBackObj),
						r = e.btJointFeedback_getAppliedTorqueBodyA(this._btJointFeedBackObj);
					this._currentTorque.setValue(e.btVector3_x(r), e.btVector3_y(r), e.btVector3_z(
						r)), this._currentForce.setValue(e.btVector3_x(t), e.btVector3_y(t), e
						.btVector3_z(t)), this._getJointFeedBack = !0
				}
			}, {
				key: "_breakConstrained",
				value: function() {
					this.ownBody.constaintRigidbodyA = null, this.connectedBody && (this
						.connectedBody.constaintRigidbodyB = null), this.destroy()
				}
			}, {
				key: "enabled",
				get: function() {
					return _get(_getPrototypeOf(ConstraintComponent.prototype), "enabled", this)
				},
				set: function(e) {
					_set(_getPrototypeOf(ConstraintComponent.prototype), "enabled", e, this, !0)
				}
			}, {
				key: "appliedImpulse",
				get: function() {
					return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0), this
						._feedbackEnabled = !0), this._btConstraint.AppliedImpulse
				}
			}, {
				key: "connectedBody",
				set: function(e) {
					this._connectedBody = e, e && (e.constaintRigidbodyB = this)
				},
				get: function() {
					return this._connectedBody
				}
			}, {
				key: "ownBody",
				get: function() {
					return this._ownBody
				},
				set: function(e) {
					this._ownBody = e, e.constaintRigidbodyA = this
				}
			}, {
				key: "currentForce",
				get: function() {
					return this._getJointFeedBack || this._getFeedBackInfo(), this._currentForce
				}
			}, {
				key: "currentTorque",
				get: function() {
					return this._getJointFeedBack || this._getFeedBackInfo(), this._currentTorque
				}
			}, {
				key: "breakForce",
				get: function() {
					return this._breakForce
				},
				set: function(e) {
					this._breakForce = e
				}
			}, {
				key: "breakTorque",
				get: function() {
					return this._breakTorque
				},
				set: function(e) {
					this._breakTorque = e
				}
			}, {
				key: "anchor",
				set: function(e) {
					e.cloneTo(this._anchor), this.setFrames()
				},
				get: function() {
					return this._anchor
				}
			}, {
				key: "connectAnchor",
				set: function(e) {
					e.cloneTo(this._connectAnchor), this.setFrames()
				},
				get: function() {
					return this._connectAnchor
				}
			}]), ConstraintComponent
		}(t.Component);
		wn.CONSTRAINT_POINT2POINT_CONSTRAINT_TYPE = 3, wn.CONSTRAINT_HINGE_CONSTRAINT_TYPE = 4, wn
			.CONSTRAINT_CONETWIST_CONSTRAINT_TYPE = 5, wn.CONSTRAINT_D6_CONSTRAINT_TYPE = 6, wn
			.CONSTRAINT_SLIDER_CONSTRAINT_TYPE = 7, wn.CONSTRAINT_CONTACT_CONSTRAINT_TYPE = 8, wn
			.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE = 9, wn.CONSTRAINT_GEAR_CONSTRAINT_TYPE = 10, wn
			.CONSTRAINT_FIXED_CONSTRAINT_TYPE = 11, wn.CONSTRAINT_MAX_CONSTRAINT_TYPE = 12, wn
			.CONSTRAINT_CONSTRAINT_ERP = 1, wn.CONSTRAINT_CONSTRAINT_STOP_ERP = 2, wn.CONSTRAINT_CONSTRAINT_CFM = 3, wn
			.CONSTRAINT_CONSTRAINT_STOP_CFM = 4, wn.tempForceV3 = new o;
		var Bn = function(e) {
				function FixedConstraint() {
					var e;
					return _classCallCheck(this, FixedConstraint), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(FixedConstraint).call(this, wn.CONSTRAINT_FIXED_CONSTRAINT_TYPE)))
						.breakForce = -1, e.breakTorque = -1, e
				}
				return _inherits(FixedConstraint, e), _createClass(FixedConstraint, [{
					key: "_addToSimulation",
					value: function() {
						this._simulation && this._simulation.addConstraint(this, this.enabled)
					}
				}, {
					key: "_removeFromSimulation",
					value: function() {
						this._simulation.removeConstraint(this), this._simulation = null
					}
				}, {
					key: "_createConstraint",
					value: function() {
						if (this.ownBody && this.ownBody._simulation && this.connectedBody && this
							.connectedBody._simulation) {
							var e = k._bullet;
							this._btConstraint = e.btFixedConstraint_create(this.ownBody
									.btColliderObject, this._btframATrans, this.connectedBody
									.btColliderObject, this._btframBTrans), this._btJointFeedBackObj = e
								.btJointFeedback_create(this._btConstraint), e
								.btTypedConstraint_setJointFeedback(this._btConstraint, this
									._btJointFeedBackObj), this._simulation = this.owner._scene
								.physicsSimulation, this._addToSimulation(), k._bullet
								.btTypedConstraint_setEnabled(this._btConstraint, !0)
						}
					}
				}, {
					key: "_onAdded",
					value: function() {
						_get(_getPrototypeOf(FixedConstraint.prototype), "_onAdded", this).call(this)
					}
				}, {
					key: "_onEnable",
					value: function() {
						this._btConstraint && (_get(_getPrototypeOf(FixedConstraint.prototype),
								"_onEnable", this).call(this), this._btConstraint && k._bullet
							.btTypedConstraint_setEnabled(this._btConstraint, !0))
					}
				}, {
					key: "_onDisable",
					value: function() {
						_get(_getPrototypeOf(FixedConstraint.prototype), "_onDisable", this).call(this),
							this.connectedBody || this._removeFromSimulation(), this._btConstraint && k
							._bullet.btTypedConstraint_setEnabled(this._btConstraint, !1)
					}
				}, {
					key: "_onDestroy",
					value: function() {
						_get(_getPrototypeOf(FixedConstraint.prototype), "_onDestroy", this).call(this)
					}
				}, {
					key: "_parse",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						_get(_getPrototypeOf(FixedConstraint.prototype), "_parse", this).call(this, e),
							-1 != e.rigidbodyID && -1 != e.connectRigidbodyID && (t.component.push(
								this), t.data.push(e)), null != e.breakForce && (this.breakForce = e
								.breakForce), null != e.breakTorque && (this.breakTorque = e
								.breakTorque)
					}
				}, {
					key: "_parseInteractive",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
							r = t[e.rigidbodyID],
							n = r.getComponent(b),
							i = t[e.connectRigidbodyID],
							a = i.getComponent(b);
						this.ownBody = n, this.connectedBody = a
					}
				}, {
					key: "_cloneTo",
					value: function(e) {}
				}]), FixedConstraint
			}(wn),
			Vn = function(e) {
				function ConfigurableConstraint() {
					var e;
					_classCallCheck(this, ConfigurableConstraint), (e = _possibleConstructorReturn(this,
							_getPrototypeOf(ConfigurableConstraint).call(this, wn
								.CONSTRAINT_D6_SPRING_CONSTRAINT_TYPE)))._axis = new o, e._secondaryAxis = new o, e
						._minLinearLimit = new o, e._maxLinearLimit = new o, e._minAngularLimit = new o, e
						._maxAngularLimit = new o, e._linearLimitSpring = new o, e._angularLimitSpring = new o, e
						._linearBounce = new o, e._angularBounce = new o, e._linearDamp = new o, e._angularDamp = new o,
						e._xMotion = 0, e._yMotion = 0, e._zMotion = 0, e._angularXMotion = 0, e._angularYMotion = 0, e
						._angularZMotion = 0;
					var t = k._bullet;
					return e._btAxis = t.btVector3_create(-1, 0, 0), e._btSecondaryAxis = t.btVector3_create(0, 1, 0), e
				}
				return _inherits(ConfigurableConstraint, e), _createClass(ConfigurableConstraint, [{
					key: "setAxis",
					value: function(e, t) {
						if (this._btConstraint) {
							var r = k._bullet;
							this._axis.setValue(e.x, e.y, e.y), this._secondaryAxis.setValue(t.x, t.y, t
									.z), this._btAxis = r.btVector3_setValue(-e.x, e.y, e.z), this
								._btSecondaryAxis = r.btVector3_setValue(-t.x, t.y, t.z), r
								.btGeneric6DofSpring2Constraint_setAxis(this._btConstraint, this
									._btAxis, this._btSecondaryAxis)
						}
					}
				}, {
					key: "setLimit",
					value: function(e, t, r, n) {
						if (this._btConstraint) {
							var i = k._bullet;
							switch (t) {
								case ConfigurableConstraint.CONFIG_MOTION_TYPE_LOCKED:
									i.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, e, 0,
										0);
									break;
								case ConfigurableConstraint.CONFIG_MOTION_TYPE_LIMITED:
									r < n && i.btGeneric6DofSpring2Constraint_setLimit(this
										._btConstraint, e, r, n);
									break;
								case ConfigurableConstraint.CONFIG_MOTION_TYPE_FREE:
									i.btGeneric6DofSpring2Constraint_setLimit(this._btConstraint, e, 1,
										0);
									break;
								default:
									throw "No Type of Axis Motion"
							}
						}
					}
				}, {
					key: "setSpring",
					value: function(e, t) {
						var r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						if (this._btConstraint) {
							var n = k._bullet,
								i = t > 0;
							n.btGeneric6DofSpring2Constraint_enableSpring(this._btConstraint, e, i),
								i && n.btGeneric6DofSpring2Constraint_setStiffness(this._btConstraint,
									e, t, r)
						}
					}
				}, {
					key: "setBounce",
					value: function(e, t) {
						this._btConstraint && (t = t <= 0 ? 0 : t, k._bullet
							.btGeneric6DofSpring2Constraint_setBounce(this._btConstraint, e, t))
					}
				}, {
					key: "setDamping",
					value: function(e, t) {
						var r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
						if (this._btConstraint) {
							var n = k._bullet;
							t = t <= 0 ? 0 : t, n.btGeneric6DofSpring2Constraint_setDamping(this
								._btConstraint, e, t, r)
						}
					}
				}, {
					key: "setEquilibriumPoint",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_setEquilibriumPoint(this._btConstraint,
							e, t)
					}
				}, {
					key: "enableMotor",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_enableMotor(this._btConstraint, e, t)
					}
				}, {
					key: "setServo",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_setServo(this._btConstraint, e, t)
					}
				}, {
					key: "setTargetVelocity",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_setTargetVelocity(this._btConstraint,
							e, t)
					}
				}, {
					key: "setTargetPosition",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_setServoTarget(this._btConstraint, e,
							t)
					}
				}, {
					key: "setMaxMotorForce",
					value: function(e, t) {
						k._bullet.btGeneric6DofSpring2Constraint_setMaxMotorForce(this._btConstraint, e,
							t)
					}
				}, {
					key: "setParam",
					value: function(e, t, r) {
						k._bullet.btTypedConstraint_setParam(this._btConstraint, e, t, r)
					}
				}, {
					key: "setFrames",
					value: function() {
						_get(_getPrototypeOf(ConfigurableConstraint.prototype), "setFrames", this).call(
							this);
						var e = k._bullet;
						this._btConstraint && e.btGeneric6DofSpring2Constraint_setFrames(this
							._btConstraint, this._btframATrans, this._btframBTrans)
					}
				}, {
					key: "_addToSimulation",
					value: function() {
						this._simulation && this._simulation.addConstraint(this, this.enabled)
					}
				}, {
					key: "_removeFromSimulation",
					value: function() {
						this._simulation.removeConstraint(this), this._simulation = null
					}
				}, {
					key: "_createConstraint",
					value: function() {
						var e = k._bullet;
						this._btConstraint = e.btGeneric6DofSpring2Constraint_create(this.ownBody
								.btColliderObject, this._btframAPos, this.connectedBody
								.btColliderObject, this._btframBPos, ConfigurableConstraint.RO_XYZ),
							this._btJointFeedBackObj = e.btJointFeedback_create(this._btConstraint), e
							.btTypedConstraint_setJointFeedback(this._btConstraint, this
								._btJointFeedBackObj), this._simulation = this.owner._scene
							.physicsSimulation, this._initAllConstraintInfo(), this._addToSimulation(),
							k._bullet.btTypedConstraint_setEnabled(this._btConstraint, !0)
					}
				}, {
					key: "_initAllConstraintInfo",
					value: function() {
						this.setLimit(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._xMotion, -this
								._maxLinearLimit.x, -this._minLinearLimit.x), this.setLimit(
								ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._yMotion, this
								._minLinearLimit.y, this._maxLinearLimit.y), this.setLimit(
								ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this._zMotion, this
								._minLinearLimit.z, this._maxLinearLimit.z), this.setLimit(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularXMotion, -
								this._maxAngularLimit.x, -this._minAngularLimit.x), this.setLimit(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularYMotion,
								this._minAngularLimit.y, this._maxAngularLimit.y), this.setLimit(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this._angularZMotion,
								this._minAngularLimit.z, this._maxAngularLimit.z), this.setSpring(
								ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearLimitSpring.x
								), this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this
								._linearLimitSpring.y), this.setSpring(ConfigurableConstraint
								.MOTION_LINEAR_INDEX_Z, this._linearLimitSpring.z), this.setSpring(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularLimitSpring
								.x), this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this
								._angularLimitSpring.y), this.setSpring(ConfigurableConstraint
								.MOTION_ANGULAR_INDEX_Z, this._angularLimitSpring.z), this.setBounce(
								ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearBounce.x),
							this.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this
								._linearBounce.y), this.setBounce(ConfigurableConstraint
								.MOTION_LINEAR_INDEX_Z, this._linearBounce.z), this.setBounce(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, this._angularBounce.x),
							this.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this
								._angularBounce.y), this.setBounce(ConfigurableConstraint
								.MOTION_ANGULAR_INDEX_Z, this._angularBounce.z), this.setDamping(
								ConfigurableConstraint.MOTION_LINEAR_INDEX_X, this._linearDamp.x), this
							.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, this._linearDamp
								.y), this.setDamping(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, this
								._linearDamp.z), this.setDamping(ConfigurableConstraint
								.MOTION_ANGULAR_INDEX_X, this._angularDamp.x), this.setDamping(
								ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, this._angularDamp.y),
							this.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, this
								._angularDamp.z), this.setFrames(), this.setEquilibriumPoint(0, 0)
					}
				}, {
					key: "_onAdded",
					value: function() {
						_get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onAdded", this).call(
							this)
					}
				}, {
					key: "_onEnable",
					value: function() {
						this._btConstraint && (_get(_getPrototypeOf(ConfigurableConstraint.prototype),
								"_onEnable", this).call(this), this._btConstraint && k._bullet
							.btTypedConstraint_setEnabled(this._btConstraint, !0))
					}
				}, {
					key: "_onDisable",
					value: function() {
						_get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onDisable", this)
							.call(this), !this.connectedBody && this._simulation && this
							._removeFromSimulation(), this._btConstraint && k._bullet
							.btTypedConstraint_setEnabled(this._btConstraint, !1)
					}
				}, {
					key: "_parse",
					value: function(e) {
						var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
						_get(_getPrototypeOf(ConfigurableConstraint.prototype), "_parse", this).call(
							this, e), this._axis.fromArray(e.axis), this._secondaryAxis.fromArray(e
							.secondaryAxis);
						var r = e.linearLimit;
						this._minLinearLimit.setValue(-r, -r, -r), this._maxLinearLimit.setValue(r, r,
							r);
						var n = e.linearLimitSpring;
						this._linearLimitSpring.setValue(n, n, n);
						var i = e.linearLimitDamper;
						this._linearDamp.setValue(i, i, i);
						var a = e.linearLimitBounciness;
						this._linearBounce.setValue(a, a, a);
						var o = e.lowAngularXLimit,
							s = e.highAngularXLimit,
							l = e.angularYLimit,
							u = e.angularZLimit;
						this._minAngularLimit.setValue(o, -l, -u), this._maxAngularLimit.setValue(s, l,
							u);
						var c = e.highAngularXLimitBounciness,
							h = e.angularYLimitBounciness,
							_ = e.angularZLimitBounciness;
						this._angularBounce.setValue(c, h, _);
						var d = e.angularXLimitSpring,
							f = e.angularYZLimitSpring;
						this._angularLimitSpring.setValue(d, f, f);
						var m = e.angularXLimitDamper,
							p = e.angularYZLimitDamper;
						this._angularDamp.setValue(m, p, p), this.XMotion = e.xMotion, this.YMotion = e
							.yMotion, this.ZMotion = e.zMotion, this.angularXMotion = e.angularXMotion,
							this.angularYMotion = e.angularYMotion, this.angularZMotion = e
							.angularZMotion, -1 != e.rigidbodyID && -1 != e.connectRigidbodyID && (t
								.component.push(this), t.data.push(e)), null != e.breakForce && (this
								.breakForce = e.breakForce), null != e.breakTorque && (this
								.breakTorque = e.breakTorque)
					}
				}, {
					key: "_parseInteractive",
					value: function() {
						var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
							t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
							r = t[e.rigidbodyID],
							n = r.getComponent(b),
							i = t[e.connectRigidbodyID],
							a = i.getComponent(b);
						this.ownBody = n, this.connectedBody = a
					}
				}, {
					key: "_onDestroy",
					value: function() {
						_get(_getPrototypeOf(ConfigurableConstraint.prototype), "_onDestroy", this)
							.call(this)
					}
				}, {
					key: "_cloneTo",
					value: function(e) {}
				}, {
					key: "axis",
					get: function() {
						return this._axis
					}
				}, {
					key: "secondaryAxis",
					get: function() {
						return this._secondaryAxis
					}
				}, {
					key: "maxAngularLimit",
					set: function(e) {
						e.cloneTo(this._maxAngularLimit)
					},
					get: function() {
						return this._maxAngularLimit
					}
				}, {
					key: "minAngularLimit",
					set: function(e) {
						e.cloneTo(this._minAngularLimit)
					},
					get: function() {
						return this._minAngularLimit
					}
				}, {
					key: "maxLinearLimit",
					set: function(e) {
						e.cloneTo(this._maxLinearLimit)
					},
					get: function() {
						return this._maxLinearLimit
					}
				}, {
					key: "minLinearLimit",
					set: function(e) {
						e.cloneTo(this._minLinearLimit)
					},
					get: function() {
						return this._minLinearLimit
					}
				}, {
					key: "XMotion",
					set: function(e) {
						this._xMotion != e && (this._xMotion = e, this.setLimit(ConfigurableConstraint
							.MOTION_LINEAR_INDEX_X, e, -this._maxLinearLimit.x, -this
							._minLinearLimit.x))
					},
					get: function() {
						return this._xMotion
					}
				}, {
					key: "YMotion",
					set: function(e) {
						this._yMotion != e && (this._yMotion = e, this.setLimit(ConfigurableConstraint
							.MOTION_LINEAR_INDEX_Y, e, this._minLinearLimit.y, this
							._maxLinearLimit.y))
					},
					get: function() {
						return this._yMotion
					}
				}, {
					key: "ZMotion",
					set: function(e) {
						this._zMotion != e && (this._zMotion = e, this.setLimit(ConfigurableConstraint
							.MOTION_LINEAR_INDEX_Z, e, this._minLinearLimit.z, this
							._maxLinearLimit.z))
					},
					get: function() {
						return this._zMotion
					}
				}, {
					key: "angularXMotion",
					set: function(e) {
						this._angularXMotion != e && (this._angularXMotion = e, this.setLimit(
							ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e, -this
							._maxAngularLimit.x, -this._minAngularLimit.x))
					},
					get: function() {
						return this._angularXMotion
					}
				}, {
					key: "angularYMotion",
					set: function(e) {
						this._angularYMotion != e && (this._angularYMotion = e, this.setLimit(
							ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e, this
							._minAngularLimit.y, this._maxAngularLimit.y))
					},
					get: function() {
						return this._angularYMotion
					}
				}, {
					key: "angularZMotion",
					set: function(e) {
						this._angularZMotion != e && (this._angularZMotion = e, this.setLimit(
							ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e, this
							._minAngularLimit.z, this._maxAngularLimit.z))
					},
					get: function() {
						return this._angularZMotion
					}
				}, {
					key: "linearLimitSpring",
					set: function(e) {
						o.equals(this._linearLimitSpring, e) || (e.cloneTo(this._linearLimitSpring),
							this.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), this
							.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this
							.setSpring(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._linearLimitSpring
					}
				}, {
					key: "angularLimitSpring",
					set: function(e) {
						o.equals(this._angularLimitSpring, e) || (e.cloneTo(this._angularLimitSpring),
							this.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), this
							.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this
							.setSpring(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._angularLimitSpring
					}
				}, {
					key: "linearBounce",
					set: function(e) {
						o.equals(this._linearBounce, e) || (e.cloneTo(this._linearBounce), this
							.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), this
							.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this
							.setBounce(ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._linearBounce
					}
				}, {
					key: "angularBounce",
					set: function(e) {
						o.equals(this._angularBounce, e) || (e.cloneTo(this._angularBounce), this
							.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), this
							.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this
							.setBounce(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._angularBounce
					}
				}, {
					key: "linearDamp",
					set: function(e) {
						o.equals(this._linearDamp, e) || (e.cloneTo(this._linearDamp), this.setDamping(
							ConfigurableConstraint.MOTION_LINEAR_INDEX_X, e.x), this.setDamping(
							ConfigurableConstraint.MOTION_LINEAR_INDEX_Y, e.y), this.setDamping(
							ConfigurableConstraint.MOTION_LINEAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._linearDamp
					}
				}, {
					key: "angularDamp",
					set: function(e) {
						o.equals(this._angularDamp, e) || (e.cloneTo(this._angularDamp), this
							.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_X, e.x), this
							.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Y, e.y), this
							.setDamping(ConfigurableConstraint.MOTION_ANGULAR_INDEX_Z, e.z))
					},
					get: function() {
						return this._angularDamp
					}
				}, {
					key: "anchor",
					set: function(e) {
						e.cloneTo(this._anchor), this.setFrames()
					},
					get: function() {
						return this._anchor
					}
				}, {
					key: "connectAnchor",
					set: function(e) {
						e.cloneTo(this._connectAnchor), this.setFrames()
					},
					get: function() {
						return this._connectAnchor
					}
				}]), ConfigurableConstraint
			}(wn);
		Vn.CONFIG_MOTION_TYPE_LOCKED = 0, Vn.CONFIG_MOTION_TYPE_LIMITED = 1, Vn.CONFIG_MOTION_TYPE_FREE = 2, Vn
			.MOTION_LINEAR_INDEX_X = 0, Vn.MOTION_LINEAR_INDEX_Y = 1, Vn.MOTION_LINEAR_INDEX_Z = 2, Vn
			.MOTION_ANGULAR_INDEX_X = 3, Vn.MOTION_ANGULAR_INDEX_Y = 4, Vn.MOTION_ANGULAR_INDEX_Z = 5, Vn.RO_XYZ = 0, Vn
			.RO_XZY = 1, Vn.RO_YXZ = 2, Vn.RO_YZX = 3, Vn.RO_ZXY = 4, Vn.RO_ZYX = 5;
		var Fn = function() {
			function Laya3D() {
				_classCallCheck(this, Laya3D)
			}
			return _createClass(Laya3D, null, [{
				key: "_cancelLoadByUrl",
				value: function(e) {
					t.Laya.loader.cancelLoadByUrl(e), Laya3D._innerFirstLevelLoaderManager
						.cancelLoadByUrl(e), Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(
							e), Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(e), Laya3D
						._innerFourthLevelLoaderManager.cancelLoadByUrl(e)
				}
			}, {
				key: "_changeWebGLSize",
				value: function(e, r) {
					t.WebGL.onStageResize(e, r), J.clientWidth = e, J.clientHeight = r
				}
			}, {
				key: "__init__",
				value: function(r, n, i) {
					if (t.Config.isAntialias = i.isAntialias, t.Config.isAlpha = i.isAlpha, t.Config
						.premultipliedAlpha = i.premultipliedAlpha, t.Config.isStencil = i
						.isStencil, t.WebGL.enable()) {
						t.RunDriver.changeWebGLSize = Laya3D._changeWebGLSize, t.Render.is3DMode = !
							0, t.Laya.init(r, n), t.Render.supportWebGLPlusRendering || (t.LayaGL
								.instance = t.WebGLContext.mainContext, t.LayaGL.instance
								.createCommandEncoder = function() {
									var e = arguments.length > 0 && void 0 !== arguments[0] ?
										arguments[0] : 128,
										r = arguments.length > 1 && void 0 !== arguments[1] ?
										arguments[1] : 64,
										n = arguments.length > 2 && void 0 !== arguments[2] &&
										arguments[2];
									return new t.CommandEncoder(this, e, r, n)
								}), i._multiLighting = i.enableMultiLight && t.SystemUtils
							.supportTextureFormat(t.TextureFormat.R32G32B32A32), l.Shader3D = _e, l
							.Scene3D = sr, l.MeshRenderStaticBatchManager = Ht, l
							.MeshRenderDynamicBatchManager = vr, l.SubMeshDynamicBatch = Sr, l
							.Laya3D = Laya3D, l.Matrix4x4 = c, l.Physics3D = k, l.ShadowLightType =
							e.ShadowLightType, Laya3D.enableNative3D(), i
							.isUseCannonPhysicsEngine && k.__cannoninit__(), k.__bulletinit__(), re
							.__init__(), Ne.__init__(), Jr.__init__(), $r.__init__(), Ct.__init__(),
							_n.__init__(), Tn.__init__(), Nt.__init__(), Bt.__init__(), Sr
							.__init__(), Mn.__init__(), Ye.init(), ct.__init__(), dr.__init__(), hr
							.__init__(), kn.__init__(), vn.__init__(), Rn.__init__(), Ee.__init__(),
							kt.__init__(), Rr.__init__(), ln.__init__(), Ln.__init__(), an
							.__init__(), pn.__init__(), $e.__init__(), sr.__init__(), Ht.__init__(),
							nt.__initDefine__(), it.__initDefine__(), ot.__initDefine__(), mr
							.__initDefine__(), pr.__initDefine__(), un.__initDefine__(), st
							.__initDefine__(), Tr.__initDefine__(), Qr.__initDefine__(), ut
							.__initDefine__(), It.__initDefine__(), fr.__initDefine__(), de
							.__init__(), t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", kn), t
							.ClassUtils.regClass("Laya.EffectMaterial", st), t.ClassUtils.regClass(
								"Laya.UnlitMaterial", pr), t.ClassUtils.regClass(
								"Laya.BlinnPhongMaterial", ot), t.ClassUtils.regClass(
								"Laya.SkyProceduralMaterial", mr), t.ClassUtils.regClass(
								"Laya.PBRStandardMaterial", dr), t.ClassUtils.regClass(
								"Laya.PBRSpecularMaterial", hr), t.ClassUtils.regClass(
								"Laya.SkyBoxMaterial", fr), t.ClassUtils.regClass(
								"Laya.WaterPrimaryMaterial", Tr), t.ClassUtils.regClass(
								"Laya.ExtendTerrainMaterial", ut), t.ClassUtils.regClass(
								"Laya.ShurikenParticleMaterial", Qr), t.ClassUtils.regClass(
								"Laya.TrailMaterial", un), t.ClassUtils.regClass(
								"Laya.PhysicsCollider", gn), t.ClassUtils.regClass(
								"Laya.Rigidbody3D", b), t.ClassUtils.regClass(
								"Laya.CharacterController", O), t.ClassUtils.regClass(
								"Laya.Animator", K), t.ClassUtils.regClass("PhysicsCollider", gn), t
							.ClassUtils.regClass("CharacterController", O), t.ClassUtils.regClass(
								"Animator", K), t.ClassUtils.regClass("Rigidbody3D", b), t
							.ClassUtils.regClass("FixedConstraint", Bn), t.ClassUtils.regClass(
								"ConfigurableConstraint", Vn), It.defaultMaterial = new It, ot
							.defaultMaterial = new ot, st.defaultMaterial = new st, pr
							.defaultMaterial = new pr, Qr.defaultMaterial = new Qr, un
							.defaultMaterial = new un, mr.defaultMaterial = new mr, fr
							.defaultMaterial = new fr, Tr.defaultMaterial = new Tr, It
							.defaultMaterial.lock = !0, ot.defaultMaterial.lock = !0, st
							.defaultMaterial.lock = !0, pr.defaultMaterial.lock = !0, Qr
							.defaultMaterial.lock = !0, un.defaultMaterial.lock = !0, mr
							.defaultMaterial.lock = !0, fr.defaultMaterial.lock = !0, Tr
							.defaultMaterial.lock = !0, t.Texture2D.__init__(), Dt.__init__(), ke
							.__init__(), Mt.__init__(), se.__init__(), le.__init__(), Tt.__init__(),
							t.HalfFloatUtils.__init__();
						var a = t.LoaderManager.createMap;
						a.lh = [Laya3D.HIERARCHY, Pn._parse], a.ls = [Laya3D.HIERARCHY, Pn
								._parseScene
							], a.lm = [Laya3D.MESH, bn._parse], a.lmat = [Laya3D.MATERIAL, nt
								._parse], a.jpg = [Laya3D.TEXTURE2D, t.Texture2D._parse], a.jpeg = [
								Laya3D.TEXTURE2D, t.Texture2D._parse
							], a.bmp = [Laya3D.TEXTURE2D, t.Texture2D._parse], a.gif = [Laya3D
								.TEXTURE2D, t.Texture2D._parse
							], a.png = [Laya3D.TEXTURE2D, t.Texture2D._parse], a.dds = [Laya3D
								.TEXTURE2D, t.Texture2D._parse
							], a.ktx = [Laya3D.TEXTURE2D, t.Texture2D._parse], a.pvr = [Laya3D
								.TEXTURE2D, t.Texture2D._parse
							], a.lani = [Laya3D.ANIMATIONCLIP, Y._parse], a.lav = [Laya3D.AVATAR, rt
								._parse
							], a.ltc = [Laya3D.TEXTURECUBE, Dt._parse], a.ltcb = [Laya3D
								.TEXTURECUBEBIN, Dt._parseBin
							], a["ltcb.ls"] = [Laya3D.TEXTURECUBEBIN, Dt._parseBin], a[
							"lanit.ls"] = [Laya3D.TEXTURE2D, t.Texture2D
								._SimpleAnimatorTextureParse];
						var o = t.Loader.parserMap;
						o[Laya3D.HIERARCHY] = Laya3D._loadHierarchy, o[Laya3D.MESH] = Laya3D
							._loadMesh, o[Laya3D.MATERIAL] = Laya3D._loadMaterial, o[Laya3D
								.TEXTURECUBE] = Laya3D._loadTextureCube, o[Laya3D.TEXTURECUBEBIN] =
							Laya3D._loadTextureCubeBin, o[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D,
							o[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip, o[Laya3D.AVATAR] =
							Laya3D._loadAvatar, o[Laya3D.SIMPLEANIMATORBIN] = Laya3D
							._loadSimpleAnimator, Laya3D._innerFirstLevelLoaderManager.on(t.Event
								.ERROR, null, Laya3D._eventLoadManagerError), Laya3D
							._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Laya3D
								._eventLoadManagerError), Laya3D._innerThirdLevelLoaderManager.on(t
								.Event.ERROR, null, Laya3D._eventLoadManagerError), Laya3D
							._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Laya3D
								._eventLoadManagerError)
					} else alert("Laya3D init error,must support webGL!")
				}
			}, {
				key: "enableNative3D",
				value: function() {
					var e = ne,
						r = _t;
					t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype
						._initDataForNative, e.prototype.setBool = e.prototype.setBoolForNative,
						e.prototype.getBool = e.prototype.getBoolForNative, e.prototype.setInt =
						e.prototype.setIntForNative, e.prototype.getInt = e.prototype
						.getIntForNative, e.prototype.setNumber = e.prototype
						.setNumberForNative, e.prototype.getNumber = e.prototype
						.getNumberForNative, e.prototype.setVector = e.prototype
						.setVectorForNative, e.prototype.getVector = e.prototype
						.getVectorForNative, e.prototype.setVector2 = e.prototype
						.setVector2ForNative, e.prototype.getVector2 = e.prototype
						.getVector2ForNative, e.prototype.setVector3 = e.prototype
						.setVector3ForNative, e.prototype.getVector3 = e.prototype
						.getVector3ForNative, e.prototype.setQuaternion = e.prototype
						.setQuaternionForNative, e.prototype.getQuaternion = e.prototype
						.getQuaternionForNative, e.prototype.setMatrix4x4 = e.prototype
						.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype
						.getMatrix4x4ForNative, e.prototype.setBuffer = e.prototype
						.setBufferForNative, e.prototype.getBuffer = e.prototype
						.getBufferForNative, e.prototype.setTexture = e.prototype
						.setTextureForNative, e.prototype.getTexture = e.prototype
						.getTextureForNative, e.prototype.setAttribute = e.prototype
						.setAttributeForNative, e.prototype.getAttribute = e.prototype
						.getAttributeForNative, e.prototype.cloneTo = e.prototype
						.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative, r
						.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative, r
						.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative, r
						.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative, t
						.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner
						.uploadShaderUniformsForNative)
				}
			}, {
				key: "formatRelativePath",
				value: function(e, t) {
					var r;
					if (r = e + t, "." === t.charAt(0)) {
						for (var n = r.split("/"), i = 0, a = n.length; i < a; i++)
							if (".." == n[i]) {
								var o = i - 1;
								o > 0 && ".." !== n[o] && (n.splice(o, 2), i -= 2)
							} r = n.join("/")
					}
					return r
				}
			}, {
				key: "_endLoad",
				value: function(e) {
					var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
						n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
					if (n)
						for (var i = 0, a = n.length; i < a; i++) {
							var o = t.Loader.getRes(n[i]);
							o && o._removeReference()
						}
					e.endLoad(r)
				}
			}, {
				key: "_eventLoadManagerError",
				value: function(e) {
					t.Laya.loader.event(t.Event.ERROR, e)
				}
			}, {
				key: "_addHierarchyInnerUrls",
				value: function(e, t, r, n, i, a) {
					var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
						s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
						l = Laya3D.formatRelativePath(n, i);
					return r && (l += r), e.push({
						url: l,
						type: a,
						constructParams: o,
						propertyParams: s
					}), t.push(l), l
				}
			}, {
				key: "_getSprite3DHierarchyInnerUrls",
				value: function(e, t, r, n, i, a, o, s) {
					var l, u, c = e.props;
					switch (e.type) {
						case "Scene3D":
							var h = c.lightmaps;
							for (l = 0, u = h.length; l < u; l++) {
								var _ = h[l];
								if (_.path) _.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, _
									.path, Laya3D.TEXTURE2D, _.constructParams, _.propertyParams
									);
								else {
									var d = _.color;
									d.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, d.path,
										Laya3D.TEXTURE2D, d.constructParams, d.propertyParams);
									var f = _.direction;
									f && (f.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, f.path,
										Laya3D.TEXTURE2D, f.constructParams, f
										.propertyParams))
								}
							}
							var m = c.reflectionTexture;
							m && (c.reflection = Laya3D._addHierarchyInnerUrls(n, a, o, s, m, Laya3D
								.TEXTURECUBE));
							var p = c.reflection;
							if (p && (c.reflection = Laya3D._addHierarchyInnerUrls(i, a, o, s, p,
									Laya3D.TEXTURECUBEBIN)), c.sky) {
								var T = c.sky.material;
								T && (T.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, T.path,
									Laya3D.MATERIAL))
							}
							break;
						case "Camera":
							var E = c.skyboxMaterial;
							E && (E.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, E.path, Laya3D
								.MATERIAL));
							break;
						case "TrailSprite3D":
						case "MeshSprite3D":
						case "SkinnedMeshSprite3D":
						case "SimpleSkinnedMeshSprite3D":
							var g = c.meshPath;
							g && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, g, Laya3D
								.MESH));
							var y = c.materials;
							if (y)
								for (l = 0, u = y.length; l < u; l++) y[l].path = Laya3D
									._addHierarchyInnerUrls(r, a, o, s, y[l].path, Laya3D.MATERIAL);
							"SimpleSkinnedMeshSprite3D" == e.type && c.animatorTexture && (c
								.animatorTexture = Laya3D._addHierarchyInnerUrls(i, a, o, s, c
									.animatorTexture, Laya3D.SIMPLEANIMATORBIN));
							break;
						case "ShuriKenParticle3D":
							if (c.main) {
								var S = c.renderer.resources,
									v = S.mesh,
									R = S.material;
								v && (S.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, v, Laya3D
									.MESH)), R && (S.material = Laya3D._addHierarchyInnerUrls(r,
									a, o, s, R, Laya3D.MATERIAL))
							} else {
								var C = c.meshPath;
								C && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, C,
										Laya3D.MESH)), c.material.path = Laya3D
									._addHierarchyInnerUrls(r, a, o, s, c.material.path, Laya3D
										.MATERIAL)
							}
							break;
						case "Terrain":
							Laya3D._addHierarchyInnerUrls(i, a, o, s, c.dataPath, Laya3D
							.TERRAINRES);
							break;
						case "ReflectionProbe":
							var M = c.reflection;
							M && (c.reflection = Laya3D._addHierarchyInnerUrls(t, a, o, s, M, Laya3D
								.TEXTURECUBEBIN))
					}
					var D = e.components;
					if (D)
						for (var x = 0, A = D.length; x < A; x++) {
							var I = D[x];
							switch (I.type) {
								case "Animator":
									I.avatarPath;
									var L = I.avatar;
									L && (L.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, L.path,
										Laya3D.AVATAR));
									var P = I.clipPaths;
									if (P)
										for (l = 0, u = P.length; l < u; l++) P[l] = Laya3D
											._addHierarchyInnerUrls(i, a, o, s, P[l], Laya3D
												.ANIMATIONCLIP);
									else {
										var O = I.layers;
										for (l = 0; l < O.length; l++)
											for (var N = O[l].states, b = 0, k = N.length; b <
												k; b++) {
												var w = N[b].clipPath;
												w && (N[b].clipPath = Laya3D._addHierarchyInnerUrls(
													i, a, o, s, w, Laya3D.ANIMATIONCLIP))
											}
									}
									break;
								case "PhysicsCollider":
								case "Rigidbody3D":
								case "CharacterController":
									var B = I.shapes;
									for (l = 0; l < B.length; l++) {
										var V = B[l];
										if ("MeshColliderShape" === V.type)(v = V.mesh) && (V.mesh =
											Laya3D._addHierarchyInnerUrls(t, a, o, s, v, Laya3D
												.MESH))
									}
							}
						}
					var F = e.child;
					for (l = 0, u = F.length; l < u; l++) Laya3D._getSprite3DHierarchyInnerUrls(F[
						l], t, r, n, i, a, o, s)
				}
			}, {
				key: "_loadHierarchy",
				value: function(e) {
					e._originType = e.type, e.on(t.Event.LOADED, null, Laya3D._onHierarchylhLoaded,
						[e]), e.load(e.url, t.Loader.JSON, !1, null, !0)
				}
			}, {
				key: "_onHierarchylhLoaded",
				value: function(e, r) {
					var n = e.url,
						i = P.getURLVerion(n),
						a = t.URL.getPath(n),
						o = [],
						s = [],
						l = [],
						u = [],
						c = [];
					Laya3D._getSprite3DHierarchyInnerUrls(r.data, o, s, l, u, c, i, a);
					var h = o.length + s.length + u.length,
						_ = h + 1,
						d = 1 / _;
					if (Laya3D._onProcessChange(e, 0, d, 1), u.length > 0) {
						var f = h / _,
							m = t.Handler.create(null, Laya3D._onProcessChange, [e, d, f], !1);
						Laya3D._innerFourthLevelLoaderManager._create(u, !1, t.Handler.create(null,
							Laya3D._onHierarchyInnerForthLevResouLoaded, [e, m, r, c, o, s,
								l, d + f * u.length, f
							]), m, null, null, null, 1, !0)
					} else Laya3D._onHierarchyInnerForthLevResouLoaded(e, null, r, c, o, s, l, d, f)
				}
			}, {
				key: "_onHierarchyInnerForthLevResouLoaded",
				value: function(e, r, n, i, a, o, s, l, u) {
					if (r && r.recover(), s.length > 0) {
						var c = t.Handler.create(null, Laya3D._onProcessChange, [e, l, u], !1);
						Laya3D._innerThirdLevelLoaderManager._create(s, !1, t.Handler.create(null,
							Laya3D._onHierarchyInnerThirdLevResouLoaded, [e, c, n, i, a, o,
								l + u * o.length, u
							]), r, null, null, null, 1, !0)
					} else Laya3D._onHierarchyInnerThirdLevResouLoaded(e, null, n, i, a, o, l, u)
				}
			}, {
				key: "_onHierarchyInnerThirdLevResouLoaded",
				value: function(e, r, n, i, a, o, s, l) {
					if (r && r.recover(), o.length > 0) {
						var u = t.Handler.create(null, Laya3D._onProcessChange, [e, s, l], !1);
						Laya3D._innerSecondLevelLoaderManager._create(o, !1, t.Handler.create(null,
							Laya3D._onHierarchyInnerSecondLevResouLoaded, [e, u, n, i, a,
								s + l * o.length, l
							]), r, null, null, null, 1, !0)
					} else Laya3D._onHierarchyInnerSecondLevResouLoaded(e, null, n, i, a, s, l)
				}
			}, {
				key: "_onHierarchyInnerSecondLevResouLoaded",
				value: function(e, r, n, i, a, o, s) {
					if (r && r.recover(), a.length > 0) {
						var l = t.Handler.create(null, Laya3D._onProcessChange, [e, o, s], !1);
						Laya3D._innerFirstLevelLoaderManager._create(a, !1, t.Handler.create(null,
								Laya3D._onHierarchyInnerFirstLevResouLoaded, [e, l, n, i]), r,
							null, null, null, 1, !0)
					} else Laya3D._onHierarchyInnerFirstLevResouLoaded(e, null, n, i)
				}
			}, {
				key: "_onHierarchyInnerFirstLevResouLoaded",
				value: function(e, t, r, n) {
					t && t.recover(), e._cache = e._createCache;
					var i = "Scene3D" === r.data.type ? Pn._parseScene(r, e._propertyParams, e
						._constructParams) : Pn._parse(r, e._propertyParams, e._constructParams);
					Laya3D._endLoad(e, i, n)
				}
			}, {
				key: "_loadMesh",
				value: function(e) {
					e.on(t.Event.LOADED, null, Laya3D._onMeshLmLoaded, [e]), e.load(e.url, t.Loader
						.BUFFER, !1, null, !0)
				}
			}, {
				key: "_onMeshLmLoaded",
				value: function(e, t) {
					e._cache = e._createCache;
					var r = bn._parse(t, e._propertyParams, e._constructParams);
					Laya3D._endLoad(e, r)
				}
			}, {
				key: "_loadMaterial",
				value: function(e) {
					e.on(t.Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [e]), e.load(e.url, t
						.Loader.JSON, !1, null, !0)
				}
			}, {
				key: "_onMaterilLmatLoaded",
				value: function(e, r) {
					var n, i = e.url,
						a = P.getURLVerion(i),
						o = t.URL.getPath(i),
						s = [],
						l = [];
					r.customProps;
					switch (r.version) {
						case "LAYAMATERIAL:01":
						case "LAYAMATERIAL:02":
							var u, c, h = r.props.textures;
							if (h)
								for (u = 0, c = h.length; u < c; u++) {
									var _ = h[u],
										d = _.path;
									d && (n = Laya3D.formatRelativePath(o, d), a && (n += a), s
										.push({
											url: n,
											constructParams: _.constructParams,
											propertyParams: _.propertyParams
										}), l.push(n), _.path = n)
								}
							break;
						default:
							throw new Error("Laya3D:unkonwn version.")
					}
					var f = s.length,
						m = f + 1,
						p = 1 / m;
					if (Laya3D._onProcessChange(e, 0, p, 1), f > 0) {
						var T = t.Handler.create(null, Laya3D._onProcessChange, [e, p, f / m], !1);
						Laya3D._innerFourthLevelLoaderManager._create(s, !1, t.Handler.create(null,
								Laya3D._onMateialTexturesLoaded, [e, T, r, l]), T, null, null,
							null, 1, !0)
					} else Laya3D._onMateialTexturesLoaded(e, null, r, null)
				}
			}, {
				key: "_onMateialTexturesLoaded",
				value: function(e, t, r, n) {
					e._cache = e._createCache;
					var i = nt._parse(r, e._propertyParams, e._constructParams);
					Laya3D._endLoad(e, i, n), t && t.recover()
				}
			}, {
				key: "_loadAvatar",
				value: function(e) {
					e.on(t.Event.LOADED, null, (function(t) {
						e._cache = e._createCache;
						var r = rt._parse(t, e._propertyParams, e._constructParams);
						Laya3D._endLoad(e, r)
					})), e.load(e.url, t.Loader.JSON, !1, null, !0)
				}
			}, {
				key: "_loadSimpleAnimator",
				value: function(e) {
					e.on(t.Event.LOADED, null, (function(r) {
						e._cache = e._createCache;
						var n = t.Texture2D._SimpleAnimatorTextureParse(r, e
							._propertyParams, e._constructParams);
						Laya3D._endLoad(e, n)
					})), e.load(e.url, t.Loader.BUFFER, !1, null, !0)
				}
			}, {
				key: "_loadAnimationClip",
				value: function(e) {
					e.on(t.Event.LOADED, null, (function(t) {
						e._cache = e._createCache;
						var r = Y._parse(t, e._propertyParams, e._constructParams);
						Laya3D._endLoad(e, r)
					})), e.load(e.url, t.Loader.BUFFER, !1, null, !0)
				}
			}, {
				key: "_loadTexture2D",
				value: function(e) {
					var r, n = e.url,
						i = n.lastIndexOf(".") + 1,
						a = n.indexOf("?"),
						o = -1 == a ? n.length : a;
					switch (n.substr(i, o - i)) {
						case "jpg":
						case "jpeg":
						case "bmp":
						case "gif":
						case "png":
							r = "nativeimage";
							break;
						case "dds":
						case "ktx":
						case "pvr":
							r = t.Loader.BUFFER
					}
					e.on(t.Event.LOADED, null, (function(r) {
						e._cache = e._createCache;
						var n = t.Texture2D._parse(r, e._propertyParams, e
							._constructParams);
						Laya3D._endLoad(e, n)
					})), e.load(e.url, r, !1, null, !0)
				}
			}, {
				key: "_loadTextureCube",
				value: function(e) {
					e.on(t.Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [e]), e.load(e.url, t
						.Loader.JSON, !1, null, !0)
				}
			}, {
				key: "_loadTextureCubeBin",
				value: function(e) {
					e.on(t.Event.LOADED, null, (function(r) {
						e._cache = e._createCache;
						var n = new t.Byte(r);
						if ("LAYATEXTURECUBE:0000" !== n.readUTFString())
						throw "Laya3D:unknow version.";
						var i = n.readUint8(),
							a = n.getUint8(),
							o = n.readUint16(),
							s = n.getUint8(),
							l = n.getUint8(),
							u = n.getUint8(),
							c = n.getUint8(),
							h = new Dt(o, i, a > 1);
						h.filterMode = s, h.wrapModeU = l, h.wrapModeV = u, h
							.anisoLevel = c;
						for (var _ = n.pos, d = o, f = 0; f < a; f++) {
							for (var m = new Array(6), p = d * d * h
									._getFormatByteCount(), T = 0; T < 6; T++) m[T] =
								new Uint8Array(r, _, p), _ += p;
							h.setSixSidePixels(m, f), d /= 2
						}
						Laya3D._endLoad(e, h)
					})), e.load(e.url, t.Loader.BUFFER, !1, null, !0)
				}
			}, {
				key: "_onTextureCubeLtcLoaded",
				value: function(e, r) {
					var n = t.URL.getPath(e.url),
						i = [Laya3D.formatRelativePath(n, r.front), Laya3D.formatRelativePath(n, r
								.back), Laya3D.formatRelativePath(n, r.left), Laya3D
							.formatRelativePath(n, r.right), Laya3D.formatRelativePath(n, r.up),
							Laya3D.formatRelativePath(n, r.down)
						];
					Laya3D._onProcessChange(e, 0, 1 / 7, 1);
					var a = t.Handler.create(null, Laya3D._onProcessChange, [e, 1 / 7, 6 / 7], !1);
					Laya3D._innerFourthLevelLoaderManager.load(i, t.Handler.create(null, Laya3D
						._onTextureCubeImagesLoaded, [e, i, a]), a, "nativeimage")
				}
			}, {
				key: "_onTextureCubeImagesLoaded",
				value: function(e, r, n) {
					for (var i = new Array(6), a = 0; a < 6; a++) i[a] = t.Loader.getRes(r[a]);
					e._cache = e._createCache;
					var o = Dt._parse(i, e._propertyParams, e._constructParams);
					for (n.recover(), a = 0; a < 6; a++) t.Loader.clearRes(r[a]);
					Laya3D._endLoad(e, o)
				}
			}, {
				key: "_onProcessChange",
				value: function(e, r, n, i) {
					(i = r + i * n) < 1 && e.event(t.Event.PROGRESS, 2 * i / 3 + 1 / 3)
				}
			}, {
				key: "init",
				value: function(e, t) {
					var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
						n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
					if (Laya3D._isInit) n && n.run();
					else {
						Laya3D._isInit = !0, r && r.cloneTo(w._config), r = w._config, Tt
							.debugFrustumCulling = r.debugFrustumCulling, Laya3D
							._editerEnvironment = r._editerEnvironment, sr.octreeCulling = r
							.octreeCulling, sr.octreeInitialSize = r.octreeInitialSize, sr
							.octreeInitialCenter = r.octreeInitialCenter, sr.octreeMinNodeSize = r
							.octreeMinNodeSize, sr.octreeLooseness = r.octreeLooseness;
						var i = window.Physics3D;
						null == i || r.isUseCannonPhysicsEngine ? (k._enablePhysics = !1, Laya3D
							.__init__(e, t, r), n && n.run()) : (k._enablePhysics = !0, i(16 * r
							.defaultPhysicsMemory, En._interactive).then((function() {
							Laya3D.__init__(e, t, r), n && n.run()
						})))
					}
				}
			}, {
				key: "enablePhysics",
				get: function() {
					return k._enablePhysics
				}
			}]), Laya3D
		}();
		Fn.HIERARCHY = "HIERARCHY", Fn.MESH = "MESH", Fn.MATERIAL = "MATERIAL", Fn.TEXTURE2D = "TEXTURE2D", Fn
			.TEXTURECUBE = "TEXTURECUBE", Fn.TEXTURECUBEBIN = "TEXTURECUBEBIN", Fn.ANIMATIONCLIP = "ANIMATIONCLIP", Fn
			.AVATAR = "AVATAR", Fn.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Fn.TERRAINRES = "TERRAIN", Fn
			.SIMPLEANIMATORBIN = "SIMPLEANIMATOR", Fn._innerFirstLevelLoaderManager = new t.LoaderManager, Fn
			._innerSecondLevelLoaderManager = new t.LoaderManager, Fn._innerThirdLevelLoaderManager = new t
			.LoaderManager, Fn._innerFourthLevelLoaderManager = new t.LoaderManager, Fn._isInit = !1, Fn
			._editerEnvironment = !1, Fn.physicsSettings = new Rt, window.Laya3D = Fn;
		var Un = function(e) {
				function CastShadowList() {
					return _classCallCheck(this, CastShadowList), _possibleConstructorReturn(this, _getPrototypeOf(
						CastShadowList).call(this))
				}
				return _inherits(CastShadowList, e), _createClass(CastShadowList, [{
					key: "add",
					value: function(e) {
						if (-1 !== e._indexInCastShadowList)
						throw "CastShadowList:element has  in  CastShadowList.";
						this._add(e), e._indexInCastShadowList = this.length++
					}
				}, {
					key: "remove",
					value: function(e) {
						var t = e._indexInCastShadowList;
						if (this.length--, t !== this.length) {
							var r = this.elements[this.length];
							this.elements[t] = r, r._indexInCastShadowList = t
						}
						e._indexInCastShadowList = -1
					}
				}]), CastShadowList
			}(R),
			Gn = function() {
				function AnimatorStateScript() {
					_classCallCheck(this, AnimatorStateScript)
				}
				return _createClass(AnimatorStateScript, [{
					key: "onStateEnter",
					value: function() {}
				}, {
					key: "onStateUpdate",
					value: function() {}
				}, {
					key: "onStateExit",
					value: function() {}
				}]), AnimatorStateScript
			}(),
			Hn = function(e) {
				function Script3D() {
					var e;
					return _classCallCheck(this, Script3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(
						Script3D).apply(this, arguments)))._indexInPool = -1, e
				}
				return _inherits(Script3D, e), _createClass(Script3D, [{
					key: "_checkProcessTriggers",
					value: function() {
						var e = Script3D.prototype;
						return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e
							.onTriggerStay || this.onTriggerExit !== e.onTriggerExit)
					}
				}, {
					key: "_checkProcessCollisions",
					value: function() {
						var e = Script3D.prototype;
						return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !==
							e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit)
					}
				}, {
					key: "_onAwake",
					value: function() {
						this.onAwake(), this.onStart !== Script3D.prototype.onStart && t.Laya.startTimer
							.callLater(this, this.onStart)
					}
				}, {
					key: "_onEnable",
					value: function() {
						this.owner._scene._addScript(this), this.onEnable()
					}
				}, {
					key: "_onDisable",
					value: function() {
						this.owner._scene._removeScript(this), this.owner.offAllCaller(this), this
							.onDisable()
					}
				}, {
					key: "_onDestroy",
					value: function() {
						var e = this.owner._scripts;
						e.splice(e.indexOf(this), 1);
						var t = this.owner;
						t._needProcessTriggers = !1;
						for (var r = 0, n = e.length; r < n; r++)
							if (e[r]._checkProcessTriggers()) {
								t._needProcessTriggers = !0;
								break
							} for (t._needProcessCollisions = !1, r = 0, n = e.length; r < n; r++)
							if (e[r]._checkProcessCollisions()) {
								t._needProcessCollisions = !0;
								break
							} this.onDestroy()
					}
				}, {
					key: "_isScript",
					value: function() {
						return !0
					}
				}, {
					key: "_onAdded",
					value: function() {
						var e = this.owner,
							t = e._scripts;
						t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e
								._needProcessCollisions = this._checkProcessCollisions()), e
							._needProcessTriggers || (e._needProcessTriggers = this
								._checkProcessTriggers())
					}
				}, {
					key: "onAwake",
					value: function() {}
				}, {
					key: "onEnable",
					value: function() {}
				}, {
					key: "onStart",
					value: function() {}
				}, {
					key: "onTriggerEnter",
					value: function(e) {}
				}, {
					key: "onTriggerStay",
					value: function(e) {}
				}, {
					key: "onTriggerExit",
					value: function(e) {}
				}, {
					key: "onCollisionEnter",
					value: function(e) {}
				}, {
					key: "onCollisionStay",
					value: function(e) {}
				}, {
					key: "onCollisionExit",
					value: function(e) {}
				}, {
					key: "onJointBreak",
					value: function() {}
				}, {
					key: "onMouseDown",
					value: function() {}
				}, {
					key: "onMouseDrag",
					value: function() {}
				}, {
					key: "onMouseClick",
					value: function() {}
				}, {
					key: "onMouseUp",
					value: function() {}
				}, {
					key: "onMouseEnter",
					value: function() {}
				}, {
					key: "onMouseOver",
					value: function() {}
				}, {
					key: "onMouseOut",
					value: function() {}
				}, {
					key: "onUpdate",
					value: function() {}
				}, {
					key: "onLateUpdate",
					value: function() {}
				}, {
					key: "onPreRender",
					value: function() {}
				}, {
					key: "onPostRender",
					value: function() {}
				}, {
					key: "onDisable",
					value: function() {}
				}, {
					key: "onDestroy",
					value: function() {}
				}, {
					key: "isSingleton",
					get: function() {
						return !1
					}
				}]), Script3D
			}(t.Component),
			zn = function() {
				function HeightMap(e, t, r, n) {
					_classCallCheck(this, HeightMap), this._datas = [], this._w = e, this._h = t, this._minHeight = r,
						this._maxHeight = n
				}
				return _createClass(HeightMap, [{
					key: "_inBounds",
					value: function(e, t) {
						return e >= 0 && e < this._h && t >= 0 && t < this._w
					}
				}, {
					key: "getHeight",
					value: function(e, t) {
						return this._inBounds(e, t) ? this._datas[e][t] : NaN
					}
				}, {
					key: "width",
					get: function() {
						return this._w
					}
				}, {
					key: "height",
					get: function() {
						return this._h
					}
				}, {
					key: "maxHeight",
					get: function() {
						return this._maxHeight
					}
				}, {
					key: "minHeight",
					get: function() {
						return this._minHeight
					}
				}], [{
					key: "creatFromMesh",
					value: function(e, t, r, n) {
						for (var i = [], a = [], s = e.subMeshCount, l = 0; l < s; l++) {
							for (var u = e.getSubMesh(l), c = u._vertexBuffer, h = c.getFloat32Data(),
									_ = [], d = 0; d < h.length; d += c.vertexDeclaration.vertexStride /
								4) {
								var f = new o(h[d + 0], h[d + 1], h[d + 2]);
								_.push(f)
							}
							i.push(_);
							var m = u._indexBuffer;
							a.push(m.getData())
						}
						var p = e.bounds,
							T = p.getMin().x,
							E = p.getMin().z,
							g = p.getMax().x,
							y = p.getMax().z,
							S = p.getMin().y,
							v = p.getMax().y,
							R = g - T,
							C = y - E,
							M = n.x = R / (t - 1),
							D = n.y = C / (r - 1),
							x = new HeightMap(t, r, S, v),
							A = HeightMap._tempRay,
							I = A.direction;
						I.x = 0, I.y = -1, I.z = 0;
						var L = v + .1;
						A.origin.y = L;
						for (var P = 0; P < r; P++) {
							var O = E + P * D;
							x._datas[P] = [];
							for (var N = 0; N < t; N++) {
								var b = T + N * M,
									k = A.origin;
								k.x = b, k.z = O;
								var w = HeightMap._getPosition(A, i, a);
								x._datas[P][N] = w === Number.MAX_VALUE ? NaN : L - w
							}
						}
						return x
					}
				}, {
					key: "createFromImage",
					value: function(e, t, r) {
						for (var n = e.width, i = e.height, a = new HeightMap(n, i, t, r), o = (r - t) /
								254, s = e.getPixels(), l = 0, u = 0; u < i; u++)
							for (var c = a._datas[u] = [], h = 0; h < n; h++) {
								var _ = s[l++],
									d = s[l++],
									f = s[l++],
									m = s[l++];
								c[h] = 255 == _ && 255 == d && 255 == f && 255 == m ? NaN : (_ + d +
									f) / 3 * o + t
							}
						return a
					}
				}, {
					key: "_getPosition",
					value: function(e, t, r) {
						for (var n = Number.MAX_VALUE, i = 0; i < t.length; i++)
							for (var a = t[i], o = r[i], s = 0; s < o.length; s += 3) {
								var l = a[o[s + 0]],
									u = a[o[s + 1]],
									c = a[o[s + 2]],
									h = Pe.rayIntersectsTriangle(e, l, u, c);
								!isNaN(h) && h < n && (n = h)
							}
						return n
					}
				}]), HeightMap
			}();
		zn._tempRay = new Ce(new o, new o);
		var Wn = function(e) {
			function MeshTerrainSprite3D(e, t) {
				var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
				return _classCallCheck(this, MeshTerrainSprite3D), (r = _possibleConstructorReturn(this,
						_getPrototypeOf(MeshTerrainSprite3D).call(this, e, i)))._heightMap = t, r._cellSize = new n,
					r
			}
			return _inherits(MeshTerrainSprite3D, e), _createClass(MeshTerrainSprite3D, [{
				key: "_disableRotation",
				value: function() {
					var e = this.transform.rotation;
					e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e
				}
			}, {
				key: "_getScaleX",
				value: function() {
					var e = this.transform.worldMatrix.elements,
						t = e[0],
						r = e[1],
						n = e[2];
					return Math.sqrt(t * t + r * r + n * n)
				}
			}, {
				key: "_getScaleZ",
				value: function() {
					var e = this.transform.worldMatrix.elements,
						t = e[8],
						r = e[9],
						n = e[10];
					return Math.sqrt(t * t + r * r + n * n)
				}
			}, {
				key: "_initCreateFromMesh",
				value: function(e, t) {
					this._heightMap = zn.creatFromMesh(this.meshFilter.sharedMesh, e, t, this
						._cellSize);
					var r = this.meshFilter.sharedMesh.bounds,
						n = r.getMin();
					r.getMax();
					this._minX = n.x, this._minZ = n.z
				}
			}, {
				key: "_initCreateFromMeshHeightMap",
				value: function(e, t, r) {
					var n = this.meshFilter.sharedMesh.bounds;
					this._heightMap = zn.createFromImage(e, t, r), this._computeCellSize(n);
					var i = n.getMin();
					n.getMax();
					this._minX = i.x, this._minZ = i.z
				}
			}, {
				key: "_computeCellSize",
				value: function(e) {
					var t = e.getMin(),
						r = e.getMax(),
						n = t.x,
						i = t.z,
						a = r.x - n,
						o = r.z - i;
					this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = o / (this
						._heightMap.height - 1)
				}
			}, {
				key: "_update",
				value: function(e) {
					this._disableRotation()
				}
			}, {
				key: "getHeight",
				value: function(e, t) {
					MeshTerrainSprite3D._tempVector3.x = e, MeshTerrainSprite3D._tempVector3.y = 0,
						MeshTerrainSprite3D._tempVector3.z = t, this._disableRotation();
					var r = this.transform.worldMatrix;
					r.invert(MeshTerrainSprite3D._tempMatrix4x4), o.transformCoordinate(
							MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4,
							MeshTerrainSprite3D._tempVector3), e = MeshTerrainSprite3D._tempVector3
						.x, t = MeshTerrainSprite3D._tempVector3.z;
					var n = (e - this._minX) / this._cellSize.x,
						i = (t - this._minZ) / this._cellSize.y,
						a = Math.floor(i),
						s = Math.floor(n),
						l = n - s,
						u = i - a,
						c = r.elements,
						h = c[4],
						_ = c[5],
						d = c[6],
						f = Math.sqrt(h * h + _ * _ + d * d),
						m = c[13],
						p = this._heightMap.getHeight(a, s + 1),
						T = this._heightMap.getHeight(a + 1, s);
					if (isNaN(p) || isNaN(T)) return NaN;
					if (l + u <= 1) {
						var E = this._heightMap.getHeight(a, s);
						return isNaN(E) ? NaN : (E + l * (p - E) + u * (T - E)) * f + m
					}
					var g = this._heightMap.getHeight(a + 1, s + 1);
					return isNaN(g) ? NaN : (g + (1 - l) * (T - g) + (1 - u) * (p - g)) * f + m
				}
			}, {
				key: "minX",
				get: function() {
					var e = this.transform.worldMatrix.elements;
					return this._minX * this._getScaleX() + e[12]
				}
			}, {
				key: "minZ",
				get: function() {
					var e = this.transform.worldMatrix.elements;
					return this._minZ * this._getScaleZ() + e[14]
				}
			}, {
				key: "width",
				get: function() {
					return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX()
				}
			}, {
				key: "depth",
				get: function() {
					return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ()
				}
			}], [{
				key: "createFromMesh",
				value: function(e, t, r) {
					var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
						i = new MeshTerrainSprite3D(e, null, n);
					return i._initCreateFromMesh(t, r), i
				}
			}, {
				key: "createFromMeshAndHeightMap",
				value: function(e, t, r, n) {
					var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
						a = new MeshTerrainSprite3D(e, null, i);
					return a._initCreateFromMeshHeightMap(t, r, n), a
				}
			}]), MeshTerrainSprite3D
		}(Rr);
		Wn._tempVector3 = new o, Wn._tempMatrix4x4 = new c;
		var Xn = function() {
				function GradientDataVector2() {
					_classCallCheck(this, GradientDataVector2), this._currentLength = 0, this._elements =
						new Float32Array(12)
				}
				return _createClass(GradientDataVector2, [{
					key: "add",
					value: function(e, t) {
						this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1,
								console.log(
									"GradientDataVector2 warning:the forth key is  be force set to 1."
									)), this._elements[this._currentLength++] = e, this._elements[
								this._currentLength++] = t.x, this._elements[this
							._currentLength++] = t.y) : console.log(
							"GradientDataVector2 warning:data count must lessEqual than 4")
					}
				}, {
					key: "cloneTo",
					value: function(e) {
						var t = e;
						t._currentLength = this._currentLength;
						for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] =
							this._elements[n]
					}
				}, {
					key: "clone",
					value: function() {
						var e = new GradientDataVector2;
						return this.cloneTo(e), e
					}
				}, {
					key: "gradientCount",
					get: function() {
						return this._currentLength / 3
					}
				}]), GradientDataVector2
			}(),
			Yn = function() {
				function PixelLineData() {
					_classCallCheck(this, PixelLineData), this.startPosition = new o, this.endPosition = new o, this
						.startColor = new ft, this.endColor = new ft
				}
				return _createClass(PixelLineData, [{
					key: "cloneTo",
					value: function(e) {
						this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e
								.endPosition), this.startColor.cloneTo(e.startColor), this.endColor
							.cloneTo(e.endColor)
					}
				}]), PixelLineData
			}(),
			jn = function() {
				function PostProcessEffect() {
					_classCallCheck(this, PostProcessEffect)
				}
				return _createClass(PostProcessEffect, [{
					key: "render",
					value: function(e) {}
				}]), PostProcessEffect
			}(),
			Zn = function(e) {
				function BloomEffect() {
					var e;
					return _classCallCheck(this, BloomEffect), (e = _possibleConstructorReturn(this, _getPrototypeOf(
							BloomEffect).call(this)))._shader = null, e._shaderData = new ne, e._linearColor = new ft, e
						._bloomTextureTexelSize = new i, e._shaderThreshold = new i, e._shaderParams = new i, e
						._pyramid = null, e._intensity = 0, e._threshold = 1, e._softKnee = .5, e._diffusion = 7, e
						._anamorphicRatio = 0, e._dirtIntensity = 0, e._shaderSetting = new i, e._dirtTileOffset =
						new i, e.clamp = 65472, e.color = new ft(1, 1, 1, 1), e.fastMode = !1, e.dirtTexture = null, e
						._shader = _e.find("PostProcessBloom"), e._pyramid = new Array(2 * BloomEffect.MAXPYRAMIDSIZE),
						e
				}
				return _inherits(BloomEffect, e), _createClass(BloomEffect, [{
					key: "render",
					value: function(e) {
						var r = e.command,
							n = e.camera.viewport;
						this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D
							.whiteTexture);
						var a, o = this._anamorphicRatio,
							s = o < 0 ? -o : 0,
							l = o > 0 ? o : 0,
							u = Math.floor(n.width / (2 - s)),
							c = Math.floor(n.height / (2 - l)),
							h = Math.max(u, c);
						a = Math.log2(h) + this._diffusion - 10;
						var _ = Math.floor(a),
							d = Math.min(Math.max(_, 1), BloomEffect.MAXPYRAMIDSIZE),
							f = .5 + a - _;
						this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, f);
						var m = ft.gammaToLinearSpace(this.threshold),
							p = m * this._softKnee + 1e-5;
						this._shaderThreshold.setValue(m, m - p, 2 * p, .25 / p), this._shaderData
							.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
						var T = ft.gammaToLinearSpace(this.clamp);
						this._shaderParams.setValue(T, 0, 0, 0), this._shaderData.setVector(BloomEffect
							.SHADERVALUE_PARAMS, this._shaderParams);
						for (var E = this.fastMode ? 1 : 0, g = e.source, y = 0; y < d; y++) {
							var S = 2 * y,
								v = S + 1,
								R = 0 == y ? BloomEffect.SUBSHADER_PREFILTER13 + E : BloomEffect
								.SUBSHADER_DOWNSAMPLE13 + E,
								C = $.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t
									.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
							if (C.filterMode = t.FilterMode.Bilinear, this._pyramid[S] = C, y !== d -
								1) {
								var M = $.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t
									.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
								M.filterMode = t.FilterMode.Bilinear, this._pyramid[v] = M
							}
							r.blitScreenTriangle(g, C, null, this._shader, this._shaderData, R), g = C,
								u = Math.max(Math.floor(u / 2), 1), c = Math.max(Math.floor(c / 2), 1)
						}
						var D = this._pyramid[2 * (d - 1)];
						for (y = d - 2; y >= 0; y--) v = (S = 2 * y) + 1, C = this._pyramid[S], M = this
							._pyramid[v], r.setShaderDataTexture(this._shaderData, BloomEffect
								.SHADERVALUE_BLOOMTEX, C), r.blitScreenTriangle(D, M, null, this
								._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + E), D =
							M;
						var x = this._linearColor;
						this.color.toLinear(x);
						var A = Math.pow(2, this._intensity / 10) - 1,
							I = this._shaderSetting;
						this._shaderSetting.setValue(f, A, this._dirtIntensity, d);
						var L = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture,
							P = L.width / L.height,
							O = n.width / n.height,
							N = this._dirtTileOffset;
						P > O ? N.setValue(O / P, 1, .5 * (1 - N.x), 0) : P < O && N.setValue(1, P / O,
							0, .5 * (1 - N.y));
						var b = e.compositeShaderData;
						for (this.fastMode ? b.addDefine($e.SHADERDEFINE_BLOOM_LOW) : b.addDefine($e
								.SHADERDEFINE_BLOOM), this._bloomTextureTexelSize.setValue(1 / D.width,
								1 / D.height, D.width, D.height), b.setVector($e
								.SHADERVALUE_BLOOM_DIRTTILEOFFSET, N), b.setVector($e
								.SHADERVALUE_BLOOM_SETTINGS, I), b.setVector($e.SHADERVALUE_BLOOM_COLOR,
								new i(x.r, x.g, x.b, x.a)), b.setTexture($e.SHADERVALUE_BLOOM_DIRTTEX,
								L), b.setTexture($e.SHADERVALUE_BLOOMTEX, D), b.setVector($e
								.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize), y =
							0; y < d; y++) v = (S = 2 * y) + 1, $.recoverToPool(this._pyramid[S]), 0 !==
							y && y !== d - 1 && $.recoverToPool(this._pyramid[v]);
						e.deferredReleaseTextures.push(D)
					}
				}, {
					key: "intensity",
					get: function() {
						return this._intensity
					},
					set: function(e) {
						this._intensity = Math.max(e, 0)
					}
				}, {
					key: "threshold",
					get: function() {
						return this._threshold
					},
					set: function(e) {
						this._threshold = Math.max(e, 0)
					}
				}, {
					key: "softKnee",
					get: function() {
						return this._softKnee
					},
					set: function(e) {
						this._softKnee = Math.min(Math.max(e, 0), 1)
					}
				}, {
					key: "diffusion",
					get: function() {
						return this._diffusion
					},
					set: function(e) {
						this._diffusion = Math.min(Math.max(e, 1), 10)
					}
				}, {
					key: "anamorphicRatio",
					get: function() {
						return this._anamorphicRatio
					},
					set: function(e) {
						this._anamorphicRatio = Math.min(Math.max(e, -1), 1)
					}
				}, {
					key: "dirtIntensity",
					get: function() {
						return this._dirtIntensity
					},
					set: function(e) {
						this._dirtIntensity = Math.max(e, 0)
					}
				}]), BloomEffect
			}(jn);
		Zn.SHADERVALUE_MAINTEX = _e.propertyNameToID("u_MainTex"), Zn.SHADERVALUE_AUTOEXPOSURETEX = _e.propertyNameToID(
				"u_AutoExposureTex"), Zn.SHADERVALUE_SAMPLESCALE = _e.propertyNameToID("u_SampleScale"), Zn
			.SHADERVALUE_THRESHOLD = _e.propertyNameToID("u_Threshold"), Zn.SHADERVALUE_PARAMS = _e.propertyNameToID(
				"u_Params"), Zn.SHADERVALUE_BLOOMTEX = _e.propertyNameToID("u_BloomTex"), Zn.SUBSHADER_PREFILTER13 = 0,
			Zn.SUBSHADER_PREFILTER4 = 1, Zn.SUBSHADER_DOWNSAMPLE13 = 2, Zn.SUBSHADER_DOWNSAMPLE4 = 3, Zn
			.SUBSHADER_UPSAMPLETENT = 4, Zn.SUBSHADER_UPSAMPLEBOX = 5, Zn.MAXPYRAMIDSIZE = 16;
		var Qn = function() {
			function ConchVector4() {
				var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
				_classCallCheck(this, ConchVector4);
				var i = this.elements = new Float32Array(4);
				i[0] = e, i[1] = t, i[2] = r, i[3] = n
			}
			return _createClass(ConchVector4, [{
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[
						t + 2], this.elements[3] = e[t + 3]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e.elements,
						r = this.elements;
					t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3]
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ConchVector4;
					return this.cloneTo(e), e
				}
			}, {
				key: "length",
				value: function() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w *
						this.w)
				}
			}, {
				key: "lengthSquared",
				value: function() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
			}, {
				key: "x",
				get: function() {
					return this.elements[0]
				},
				set: function(e) {
					this.elements[0] = e
				}
			}, {
				key: "y",
				get: function() {
					return this.elements[1]
				},
				set: function(e) {
					this.elements[1] = e
				}
			}, {
				key: "z",
				get: function() {
					return this.elements[2]
				},
				set: function(e) {
					this.elements[2] = e
				}
			}, {
				key: "w",
				get: function() {
					return this.elements[3]
				},
				set: function(e) {
					this.elements[3] = e
				}
			}], [{
				key: "lerp",
				value: function(e, t, r, n) {
					var i = n.elements,
						a = e.elements,
						o = t.elements,
						s = a[0],
						l = a[1],
						u = a[2],
						c = a[3];
					i[0] = s + r * (o[0] - s), i[1] = l + r * (o[1] - l), i[2] = u + r * (o[2] - u),
						i[3] = c + r * (o[3] - c)
				}
			}, {
				key: "transformByM4x4",
				value: function(e, t, r) {
					var n = e.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = t.elements,
						u = r.elements;
					u[0] = i * l[0] + a * l[4] + o * l[8] + s * l[12], u[1] = i * l[1] + a * l[5] +
						o * l[9] + s * l[13], u[2] = i * l[2] + a * l[6] + o * l[10] + s * l[14], u[
							3] = i * l[3] + a * l[7] + o * l[11] + s * l[15]
				}
			}, {
				key: "equals",
				value: function(e, t) {
					var n = e.elements,
						i = t.elements;
					return r.nearEqual(Math.abs(n[0]), Math.abs(i[0])) && r.nearEqual(Math.abs(n[
							1]), Math.abs(i[1])) && r.nearEqual(Math.abs(n[2]), Math.abs(i[2])) && r
						.nearEqual(Math.abs(n[3]), Math.abs(i[3]))
				}
			}, {
				key: "normalize",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = e.length();
					i > 0 && (n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = r[3] * i)
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2], n[3] = i[3] + a[3]
				}
			}, {
				key: "subtract",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] - a[0], n[1] = i[1] - a[1], n[2] = i[2] - a[2], n[3] = i[3] - a[3]
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] * a[0], n[1] = i[1] * a[1], n[2] = i[2] * a[2], n[3] = i[3] * a[3]
				}
			}, {
				key: "scale",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements;
					n[0] = i[0] * t, n[1] = i[1] * t, n[2] = i[2] * t, n[3] = i[3] * t
				}
			}, {
				key: "Clamp",
				value: function(e, t, r, n) {
					var i = e.elements,
						a = i[0],
						o = i[1],
						s = i[2],
						l = i[3],
						u = t.elements,
						c = u[0],
						h = u[1],
						_ = u[2],
						d = u[3],
						f = r.elements,
						m = f[0],
						p = f[1],
						T = f[2],
						E = f[3],
						g = n.elements;
					a = (a = a > m ? m : a) < c ? c : a, o = (o = o > p ? p : o) < h ? h : o, s = (
						s = s > T ? T : s) < _ ? _ : s, l = (l = l > E ? E : l) < d ? d : l, g[
						0] = a, g[1] = o, g[2] = s, g[3] = l
				}
			}, {
				key: "distanceSquared",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = r[0] - n[0],
						a = r[1] - n[1],
						o = r[2] - n[2],
						s = r[3] - n[3];
					return i * i + a * a + o * o + s * s
				}
			}, {
				key: "distance",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = r[0] - n[0],
						a = r[1] - n[1],
						o = r[2] - n[2],
						s = r[3] - n[3];
					return Math.sqrt(i * i + a * a + o * o + s * s)
				}
			}, {
				key: "dot",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements;
					return r[0] * n[0] + r[1] * n[1] + r[2] * n[2] + r[3] * n[3]
				}
			}, {
				key: "min",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = Math.min(i[0], a[0]), n[1] = Math.min(i[1], a[1]), n[2] = Math.min(i[2],
						a[2]), n[3] = Math.min(i[3], a[3])
				}
			}, {
				key: "max",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = Math.max(i[0], a[0]), n[1] = Math.max(i[1], a[1]), n[2] = Math.max(i[2],
						a[2]), n[3] = Math.max(i[3], a[3])
				}
			}]), ConchVector4
		}();
		Qn.ZERO = new Qn, Qn.ONE = new Qn(1, 1, 1, 1), Qn.UnitX = new Qn(1, 0, 0, 0), Qn.UnitY = new Qn(0, 1, 0, 0), Qn
			.UnitZ = new Qn(0, 0, 1, 0), Qn.UnitW = new Qn(0, 0, 0, 1);
		var qn = function() {
			function ConchVector3() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
				_classCallCheck(this, ConchVector3), e = i || new Float32Array(3), this.elements = e, e[0] = t, e[
					1] = r, e[2] = n
			}
			return _createClass(ConchVector3, [{
				key: "setValue",
				value: function(e, t, r) {
					this.elements[0] = e, this.elements[1] = t, this.elements[2] = r
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[
						t + 2]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t = e.elements,
						r = this.elements;
					t[0] = r[0], t[1] = r[1], t[2] = r[2]
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ConchVector3;
					return this.cloneTo(e), e
				}
			}, {
				key: "toDefault",
				value: function() {
					this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0
				}
			}, {
				key: "x",
				get: function() {
					return this.elements[0]
				},
				set: function(e) {
					this.elements[0] = e
				}
			}, {
				key: "y",
				get: function() {
					return this.elements[1]
				},
				set: function(e) {
					this.elements[1] = e
				}
			}, {
				key: "z",
				get: function() {
					return this.elements[2]
				},
				set: function(e) {
					this.elements[2] = e
				}
			}], [{
				key: "distanceSquared",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = r[0] - n[0],
						a = r[1] - n[1],
						o = r[2] - n[2];
					return i * i + a * a + o * o
				}
			}, {
				key: "distance",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = r[0] - n[0],
						a = r[1] - n[1],
						o = r[2] - n[2];
					return Math.sqrt(i * i + a * a + o * o)
				}
			}, {
				key: "min",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = Math.min(i[0], a[0]), n[1] = Math.min(i[1], a[1]), n[2] = Math.min(i[2],
						a[2])
				}
			}, {
				key: "max",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = Math.max(i[0], a[0]), n[1] = Math.max(i[1], a[1]), n[2] = Math.max(i[2],
						a[2])
				}
			}, {
				key: "transformQuat",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements,
						o = i[0],
						s = i[1],
						l = i[2],
						u = a[0],
						c = a[1],
						h = a[2],
						_ = a[3],
						d = _ * o + c * l - h * s,
						f = _ * s + h * o - u * l,
						m = _ * l + u * s - c * o,
						p = -u * o - c * s - h * l;
					n[0] = d * _ + p * -u + f * -h - m * -c, n[1] = f * _ + p * -c + m * -u - d * -
						h, n[2] = m * _ + p * -h + d * -c - f * -u
				}
			}, {
				key: "scalarLength",
				value: function(e) {
					var t = e.elements,
						r = t[0],
						n = t[1],
						i = t[2];
					return Math.sqrt(r * r + n * n + i * i)
				}
			}, {
				key: "scalarLengthSquared",
				value: function(e) {
					var t = e.elements,
						r = t[0],
						n = t[1],
						i = t[2];
					return r * r + n * n + i * i
				}
			}, {
				key: "normalize",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements,
						i = r[0],
						a = r[1],
						o = r[2],
						s = i * i + a * a + o * o;
					s > 0 && (s = 1 / Math.sqrt(s), n[0] = r[0] * s, n[1] = r[1] * s, n[2] = r[2] *
						s)
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] * a[0], n[1] = i[1] * a[1], n[2] = i[2] * a[2]
				}
			}, {
				key: "scale",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements;
					n[0] = i[0] * t, n[1] = i[1] * t, n[2] = i[2] * t
				}
			}, {
				key: "lerp",
				value: function(e, t, r, n) {
					var i = n.elements,
						a = e.elements,
						o = t.elements,
						s = a[0],
						l = a[1],
						u = a[2];
					i[0] = s + r * (o[0] - s), i[1] = l + r * (o[1] - l), i[2] = u + r * (o[2] - u)
				}
			}, {
				key: "transformV3ToV3",
				value: function(e, t, r) {
					var n = ConchVector3._tempVector4;
					ConchVector3.transformV3ToV4(e, t, n);
					var i = n.elements,
						a = r.elements;
					a[0] = i[0], a[1] = i[1], a[2] = i[2]
				}
			}, {
				key: "transformV3ToV4",
				value: function(e, t, r) {
					var n = e.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = t.elements,
						l = r.elements;
					l[0] = i * s[0] + a * s[4] + o * s[8] + s[12], l[1] = i * s[1] + a * s[5] + o *
						s[9] + s[13], l[2] = i * s[2] + a * s[6] + o * s[10] + s[14], l[3] = i * s[
							3] + a * s[7] + o * s[11] + s[15]
				}
			}, {
				key: "TransformNormal",
				value: function(e, t, r) {
					var n = e.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = t.elements,
						l = r.elements;
					l[0] = i * s[0] + a * s[4] + o * s[8], l[1] = i * s[1] + a * s[5] + o * s[9], l[
						2] = i * s[2] + a * s[6] + o * s[10]
				}
			}, {
				key: "transformCoordinate",
				value: function(e, t, r) {
					var n = e.elements,
						i = n[0],
						a = n[1],
						o = n[2],
						s = t.elements,
						l = i * s[3] + a * s[7] + o * s[11] + s[15],
						u = r.elements;
					u[0] = i * s[0] + a * s[4] + o * s[8] + s[12] / l, u[1] = i * s[1] + a * s[5] +
						o * s[9] + s[13] / l, u[2] = i * s[2] + a * s[6] + o * s[10] + s[14] / l
				}
			}, {
				key: "Clamp",
				value: function(e, t, r, n) {
					var i = e.elements,
						a = i[0],
						o = i[1],
						s = i[2],
						l = t.elements,
						u = l[0],
						c = l[1],
						h = l[2],
						_ = r.elements,
						d = _[0],
						f = _[1],
						m = _[2],
						p = n.elements;
					a = (a = a > d ? d : a) < u ? u : a, o = (o = o > f ? f : o) < c ? c : o, s = (
						s = s > m ? m : s) < h ? h : s, p[0] = a, p[1] = o, p[2] = s
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2]
				}
			}, {
				key: "subtract",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] - a[0], n[1] = i[1] - a[1], n[2] = i[2] - a[2]
				}
			}, {
				key: "cross",
				value: function(e, t, r) {
					var n = e.elements,
						i = t.elements,
						a = r.elements,
						o = n[0],
						s = n[1],
						l = n[2],
						u = i[0],
						c = i[1],
						h = i[2];
					a[0] = s * h - l * c, a[1] = l * u - o * h, a[2] = o * c - s * u
				}
			}, {
				key: "dot",
				value: function(e, t) {
					var r = e.elements,
						n = t.elements;
					return r[0] * n[0] + r[1] * n[1] + r[2] * n[2]
				}
			}, {
				key: "equals",
				value: function(e, t) {
					var n = e.elements,
						i = t.elements;
					return r.nearEqual(n[0], i[0]) && r.nearEqual(n[1], i[1]) && r.nearEqual(n[2],
						i[2])
				}
			}]), ConchVector3
		}();
		qn._tempVector4 = new Qn, qn.ZERO = new qn(0, 0, 0), qn.ONE = new qn(1, 1, 1), qn.NegativeUnitX = new qn(-1, 0,
				0), qn.UnitX = new qn(1, 0, 0), qn.UnitY = new qn(0, 1, 0), qn.UnitZ = new qn(0, 0, 1), qn.ForwardRH =
			new qn(0, 0, -1), qn.ForwardLH = new qn(0, 0, 1), qn.Up = new qn(0, 1, 0), qn.NAN = new qn(NaN, NaN, NaN);
		var Kn = function() {
			function ConchQuaternion() {
				var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
					r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
					n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
					i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
					a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
				_classCallCheck(this, ConchQuaternion), (e = a || new Float32Array(4))[0] = t, e[1] = r, e[2] = n,
					e[3] = i, this.elements = e
			}
			return _createClass(ConchQuaternion, [{
				key: "scaling",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements;
					r[0] = n[0] * e, r[1] = n[1] * e, r[2] = n[2] * e, r[3] = n[3] * e
				}
			}, {
				key: "normalize",
				value: function(e) {
					ConchQuaternion._normalizeArray(this.elements, e.elements)
				}
			}, {
				key: "length",
				value: function() {
					var e = this.elements,
						t = e[0],
						r = e[1],
						n = e[2],
						i = e[3];
					return Math.sqrt(t * t + r * r + n * n + i * i)
				}
			}, {
				key: "rotateX",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements;
					e *= .5;
					var i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = Math.sin(e),
						u = Math.cos(e);
					r[0] = i * u + s * l, r[1] = a * u + o * l, r[2] = o * u - a * l, r[3] = s * u -
						i * l
				}
			}, {
				key: "rotateY",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements;
					e *= .5;
					var i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = Math.sin(e),
						u = Math.cos(e);
					r[0] = i * u - o * l, r[1] = a * u + s * l, r[2] = o * u + i * l, r[3] = s * u -
						a * l
				}
			}, {
				key: "rotateZ",
				value: function(e, t) {
					var r = t.elements,
						n = this.elements;
					e *= .5;
					var i = n[0],
						a = n[1],
						o = n[2],
						s = n[3],
						l = Math.sin(e),
						u = Math.cos(e);
					r[0] = i * u + a * l, r[1] = a * u - i * l, r[2] = o * u + s * l, r[3] = s * u -
						o * l
				}
			}, {
				key: "getYawPitchRoll",
				value: function(e) {
					qn.transformQuat(qn.ForwardRH, this, ConchQuaternion.TEMPVector31), qn
						.transformQuat(qn.Up, this, ConchQuaternion.TEMPVector32);
					var t = ConchQuaternion.TEMPVector32.elements;
					ConchQuaternion.angleTo(qn.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion
						.TEMPVector33);
					var r = ConchQuaternion.TEMPVector33.elements;
					r[0] == Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(t[2], t[0]), r[2] =
						0) : r[0] == -Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(-t[2], -t[
							0]), r[2] = 0) : (c.createRotationY(-r[1], ConchQuaternion.TEMPMatrix0),
							c.createRotationX(-r[0], ConchQuaternion.TEMPMatrix1), qn
							.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion
								.TEMPMatrix0, ConchQuaternion.TEMPVector32), qn.transformCoordinate(
								ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1,
								ConchQuaternion.TEMPVector32), r[2] = ConchQuaternion.arcTanAngle(t[
								1], -t[0])), r[1] <= -Math.PI && (r[1] = Math.PI), r[2] <= -Math
						.PI && (r[2] = Math.PI), r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0, r[
							2] = 0, r[0] = Math.PI - r[0]);
					var n = e.elements;
					n[0] = r[1], n[1] = r[0], n[2] = r[2]
				}
			}, {
				key: "invert",
				value: function(e) {
					var t = e.elements,
						r = this.elements,
						n = r[0],
						i = r[1],
						a = r[2],
						o = r[3],
						s = n * n + i * i + a * a + o * o,
						l = s ? 1 / s : 0;
					t[0] = -n * l, t[1] = -i * l, t[2] = -a * l, t[3] = o * l
				}
			}, {
				key: "identity",
				value: function() {
					var e = this.elements;
					e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1
				}
			}, {
				key: "fromArray",
				value: function(e) {
					var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
					this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[
						t + 2], this.elements[3] = e[t + 3]
				}
			}, {
				key: "cloneTo",
				value: function(e) {
					var t, r, n;
					if ((r = this.elements) !== (n = e.elements))
						for (t = 0; t < 4; ++t) n[t] = r[t]
				}
			}, {
				key: "clone",
				value: function() {
					var e = new ConchQuaternion;
					return this.cloneTo(e), e
				}
			}, {
				key: "equals",
				value: function(e) {
					var t = this.elements,
						n = e.elements;
					return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2],
						n[2]) && r.nearEqual(t[3], n[3])
				}
			}, {
				key: "lengthSquared",
				value: function() {
					var e = this.elements[0],
						t = this.elements[1],
						r = this.elements[2],
						n = this.elements[3];
					return e * e + t * t + r * r + n * n
				}
			}, {
				key: "x",
				get: function() {
					return this.elements[0]
				},
				set: function(e) {
					this.elements[0] = e
				}
			}, {
				key: "y",
				get: function() {
					return this.elements[1]
				},
				set: function(e) {
					this.elements[1] = e
				}
			}, {
				key: "z",
				get: function() {
					return this.elements[2]
				},
				set: function(e) {
					this.elements[2] = e
				}
			}, {
				key: "w",
				get: function() {
					return this.elements[3]
				},
				set: function(e) {
					this.elements[3] = e
				}
			}], [{
				key: "_dotArray",
				value: function(e, t) {
					return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3]
				}
			}, {
				key: "_normalizeArray",
				value: function(e, t) {
					var r = e[0],
						n = e[1],
						i = e[2],
						a = e[3],
						o = r * r + n * n + i * i + a * a;
					o > 0 && (o = 1 / Math.sqrt(o), t[0] = r * o, t[1] = n * o, t[2] = i * o, t[3] =
						a * o)
				}
			}, {
				key: "_lerpArray",
				value: function(e, t, r, n) {
					var i = 1 - r;
					ConchQuaternion._dotArray(e, t) >= 0 ? (n[0] = i * e[0] + r * t[0], n[1] = i *
							e[1] + r * t[1], n[2] = i * e[2] + r * t[2], n[3] = i * e[3] + r * t[3]
							) : (n[0] = i * e[0] - r * t[0], n[1] = i * e[1] - r * t[1], n[2] = i *
							e[2] - r * t[2], n[3] = i * e[3] - r * t[3]), ConchQuaternion
						._normalizeArray(n, n)
				}
			}, {
				key: "createFromYawPitchRoll",
				value: function(e, t, r, n) {
					var i = .5 * r,
						a = .5 * t,
						o = .5 * e,
						s = Math.sin(i),
						l = Math.cos(i),
						u = Math.sin(a),
						c = Math.cos(a),
						h = Math.sin(o),
						_ = Math.cos(o),
						d = n.elements;
					d[0] = _ * u * l + h * c * s, d[1] = h * c * l - _ * u * s, d[2] = _ * c * s -
						h * u * l, d[3] = _ * c * l + h * u * s
				}
			}, {
				key: "multiply",
				value: function(e, t, r) {
					var n = e.elements,
						i = t.elements,
						a = r.elements,
						o = n[0],
						s = n[1],
						l = n[2],
						u = n[3],
						c = i[0],
						h = i[1],
						_ = i[2],
						d = i[3],
						f = s * _ - l * h,
						m = l * c - o * _,
						p = o * h - s * c,
						T = o * c + s * h + l * _;
					a[0] = o * d + c * u + f, a[1] = s * d + h * u + m, a[2] = l * d + _ * u + p, a[
						3] = u * d - T
				}
			}, {
				key: "arcTanAngle",
				value: function(e, t) {
					return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) :
						e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0
				}
			}, {
				key: "angleTo",
				value: function(e, t, r) {
					qn.subtract(t, e, ConchQuaternion.TEMPVector30), qn.normalize(ConchQuaternion
							.TEMPVector30, ConchQuaternion.TEMPVector30), r.elements[0] = Math.asin(
							ConchQuaternion.TEMPVector30.y), r.elements[1] = ConchQuaternion
						.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30
							.x)
				}
			}, {
				key: "createFromAxisAngle",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements;
					t *= .5;
					var a = Math.sin(t);
					n[0] = a * i[0], n[1] = a * i[1], n[2] = a * i[2], n[3] = Math.cos(t)
				}
			}, {
				key: "createFromMatrix3x3",
				value: function(e, t) {
					var r, n = t.elements,
						i = e.elements,
						a = i[0] + i[4] + i[8];
					if (a > 0) r = Math.sqrt(a + 1), n[3] = .5 * r, r = .5 / r, n[0] = (i[5] - i[
						7]) * r, n[1] = (i[6] - i[2]) * r, n[2] = (i[1] - i[3]) * r;
					else {
						var o = 0;
						i[4] > i[0] && (o = 1), i[8] > i[3 * o + o] && (o = 2);
						var s = (o + 1) % 3,
							l = (o + 2) % 3;
						r = Math.sqrt(i[3 * o + o] - i[3 * s + s] - i[3 * l + l] + 1), n[o] = .5 *
							r, r = .5 / r, n[3] = (i[3 * s + l] - i[3 * l + s]) * r, n[s] = (i[3 *
								s + o] + i[3 * o + s]) * r, n[l] = (i[3 * l + o] + i[3 * o + l]) * r
					}
				}
			}, {
				key: "createFromMatrix4x4",
				value: function(e, t) {
					var r, n, i = e.elements,
						a = t.elements,
						o = i[0] + i[5] + i[10];
					o > 0 ? (r = Math.sqrt(o + 1), a[3] = .5 * r, r = .5 / r, a[0] = (i[6] - i[9]) *
							r, a[1] = (i[8] - i[2]) * r, a[2] = (i[1] - i[4]) * r) : i[0] >= i[5] &&
						i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])), a[0] =
							.5 * r, a[1] = (i[1] + i[4]) * n, a[2] = (i[2] + i[8]) * n, a[3] = (i[
								6] - i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] -
							i[0] - i[10])), a[0] = (i[4] + i[1]) * n, a[1] = .5 * r, a[2] = (i[
							9] + i[6]) * n, a[3] = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 +
							i[10] - i[0] - i[5])), a[0] = (i[8] + i[2]) * n, a[1] = (i[9] + i[
							6]) * n, a[2] = .5 * r, a[3] = (i[1] - i[4]) * n)
				}
			}, {
				key: "slerp",
				value: function(e, t, r, n) {
					var i, a, o, s, l, u = e.elements,
						c = t.elements,
						h = n.elements,
						_ = u[0],
						d = u[1],
						f = u[2],
						m = u[3],
						p = c[0],
						T = c[1],
						E = c[2],
						g = c[3];
					return (a = _ * p + d * T + f * E + m * g) < 0 && (a = -a, p = -p, T = -T, E = -
							E, g = -g), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math
							.sin((1 - r) * i) / o, l = Math.sin(r * i) / o) : (s = 1 - r, l = r), h[
							0] = s * _ + l * p, h[1] = s * d + l * T, h[2] = s * f + l * E, h[3] =
						s * m + l * g, h
				}
			}, {
				key: "lerp",
				value: function(e, t, r, n) {
					ConchQuaternion._lerpArray(e.elements, t.elements, r, n.elements)
				}
			}, {
				key: "add",
				value: function(e, t, r) {
					var n = r.elements,
						i = e.elements,
						a = t.elements;
					n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2], n[3] = i[3] + a[3]
				}
			}, {
				key: "dot",
				value: function(e, t) {
					return ConchQuaternion._dotArray(e.elements, t.elements)
				}
			}, {
				key: "rotationLookAt",
				value: function(e, t, r) {
					ConchQuaternion.lookAt(qn.ZERO, e, t, r)
				}
			}, {
				key: "lookAt",
				value: function(e, t, r, n) {
					s.lookAt(e, t, r, ConchQuaternion._tempMatrix3x3), ConchQuaternion
						.rotationMatrix(ConchQuaternion._tempMatrix3x3, n)
				}
			}, {
				key: "invert",
				value: function(e, t) {
					var n = e.elements,
						i = t.elements,
						a = e.lengthSquared();
					r.isZero(a) || (a = 1 / a, i[0] = -n[0] * a, i[1] = -n[1] * a, i[2] = -n[2] * a,
						i[3] = n[3] * a)
				}
			}, {
				key: "rotationMatrix",
				value: function(e, t) {
					var r, n, i = e.elements,
						a = i[0],
						o = i[1],
						s = i[2],
						l = i[3],
						u = i[4],
						c = i[5],
						h = i[6],
						_ = i[7],
						d = i[8],
						f = t.elements,
						m = a + u + d;
					m > 0 ? (r = Math.sqrt(m + 1), f[3] = .5 * r, r = .5 / r, f[0] = (c - _) * r, f[
						1] = (h - s) * r, f[2] = (o - l) * r) : a >= u && a >= d ? (n = .5 / (
						r = Math.sqrt(1 + a - u - d)), f[0] = .5 * r, f[1] = (o + l) * n, f[
						2] = (s + h) * n, f[3] = (c - _) * n) : u > d ? (n = .5 / (r = Math
						.sqrt(1 + u - a - d)), f[0] = (l + o) * n, f[1] = .5 * r, f[2] = (
						_ + c) * n, f[3] = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a -
						u)), f[0] = (h + s) * n, f[1] = (_ + c) * n, f[2] = .5 * r, f[3] = (
						o - l) * n)
				}
			}]), ConchQuaternion
		}();
		Kn.TEMPVector30 = new qn, Kn.TEMPVector31 = new qn, Kn.TEMPVector32 = new qn, Kn.TEMPVector33 = new qn, Kn
			.TEMPMatrix0 = new c, Kn.TEMPMatrix1 = new c, Kn._tempMatrix3x3 = new s, Kn.DEFAULT = new Kn, Kn.NAN =
			new Kn(NaN, NaN, NaN, NaN);
		var Jn = function() {
			function RandX(e) {
				if (_classCallCheck(this, RandX), !(e instanceof Array) || 4 !== e.length) throw new Error(
					"Rand:Seed must be an array with 4 numbers");
				this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[
					3]
			}
			return _createClass(RandX, [{
				key: "randomint",
				value: function() {
					var e = this._state0U,
						t = this._state0L,
						r = this._state1U,
						n = this._state1L,
						i = (n >>> 0) + (t >>> 0),
						a = r + e + (i / 2 >>> 31) >>> 0,
						o = i >>> 0;
					this._state0U = r, this._state0L = n;
					var s = 0,
						l = 0;
					s = (e ^= s = e << 23 | (-512 & t) >>> 9) ^ r, l = (t ^= l = t << 23) ^ n;
					s ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
					return s ^= r >>> 5, l ^= n >>> 5 | (31 & r) << 27, this._state1U = s, this
						._state1L = l, [a, o]
				}
			}, {
				key: "random",
				value: function() {
					var e = this.randomint(),
						t = e[0],
						r = 1023 << 20 | t >>> 12,
						n = 0 | (e[1] >>> 12 | (4095 & t) << 20);
					return RandX._CONVERTION_BUFFER.setUint32(0, r, !1), RandX._CONVERTION_BUFFER
						.setUint32(4, n, !1), RandX._CONVERTION_BUFFER.getFloat64(0, !1) - 1
				}
			}]), RandX
		}();
		Jn._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Jn.defaultRand = new Jn([0, Date.now() / 65536, 0,
			Date.now() % 65536
		]);
		var $n = function() {
				function Point2PointConstraint() {
					_classCallCheck(this, Point2PointConstraint), this._pivotInA = new o, this._pivotInB = new o
				}
				return _createClass(Point2PointConstraint, [{
					key: "pivotInA",
					get: function() {
						return this._pivotInA
					},
					set: function(e) {
						this._pivotInA = e
					}
				}, {
					key: "pivotInB",
					get: function() {
						return this._pivotInB
					},
					set: function(e) {
						this._pivotInB = e
					}
				}, {
					key: "damping",
					get: function() {
						return this._damping
					},
					set: function(e) {
						this._damping = e
					}
				}, {
					key: "impulseClamp",
					get: function() {
						return this._impulseClamp
					},
					set: function(e) {
						this._impulseClamp = e
					}
				}, {
					key: "tau",
					get: function() {
						return this._tau
					},
					set: function(e) {
						this._tau = e
					}
				}]), Point2PointConstraint
			}(),
			ei = function() {
				function TextMesh() {
					_classCallCheck(this, TextMesh)
				}
				return _createClass(TextMesh, [{
					key: "_createVertexBuffer",
					value: function(e) {}
				}, {
					key: "_resizeVertexBuffer",
					value: function(e) {}
				}, {
					key: "_addChar",
					value: function() {}
				}, {
					key: "text",
					get: function() {
						return this._text
					},
					set: function(e) {
						this._text = e
					}
				}, {
					key: "fontSize",
					get: function() {
						return this._fontSize
					},
					set: function(e) {
						this._fontSize = e
					}
				}, {
					key: "color",
					get: function() {
						return this._color
					},
					set: function(e) {
						this._color = e
					}
				}]), TextMesh
			}(),
			ti = function() {
				function Size(e, t) {
					_classCallCheck(this, Size), this._width = 0, this._height = 0, this._width = e, this._height = t
				}
				return _createClass(Size, [{
					key: "width",
					get: function() {
						return -1 === this._width ? J.clientWidth : this._width
					}
				}, {
					key: "height",
					get: function() {
						return -1 === this._height ? J.clientHeight : this._height
					}
				}], [{
					key: "fullScreen",
					get: function() {
						return new Size(-1, -1)
					}
				}]), Size
			}();
		e.AlternateLightQueue = At, e.AnimationClip = Y, e.AnimationClipParser03 = z, e.AnimationClipParser04 = W, e
			.AnimationEvent = V, e.AnimationNode = tt, e.AnimationTransform3D = et, e.Animator = K, e
			.AnimatorControllerLayer = Z, e.AnimatorPlayState = j, e.AnimatorState = Q, e.AnimatorStateScript = Gn, e
			.Avatar = rt, e.BaseCamera = Ve, e.BaseMaterial = it, e.BaseRender = Wt, e.BaseShape = Br, e.BatchMark = wt,
			e.BlinnPhongMaterial = ot, e.BlitScreenQuadCMD = fe, e.BloomEffect = Zn, e.BoundBox = Lt, e.BoundFrustum =
			Ae, e.BoundSphere = Jt, e.Bounds = Pt, e.BoundsOctree = qt, e.BoundsOctreeNode = Zt, e.BoxColliderShape = p,
			e.BoxShape = Fr, e.BufferState = oe, e.BulletInteractive = En, e.Burst = xr, e.Camera = je, e
			.CameraCullInfo = mt, e.CapsuleColliderShape = T, e.CastShadowList = Un, e.CharacterController = O, e
			.CircleShape = Ur, e.ClearRenderTextureCMD = ye, e.Cluster = ve, e.ColliderShape = h, e.Collision = x, e
			.CollisionTool = A, e.CollisionUtils = xe, e.Color = ft, e.ColorOverLifetime = Ir, e.Command = de, e
			.CommandBuffer = Ke, e.CompoundColliderShape = d, e.ConchQuaternion = Kn, e.ConchVector3 = qn, e
			.ConchVector4 = Qn, e.ConeColliderShape = E, e.ConeShape = Gr, e.Config3D = w, e.ConfigurableConstraint =
			Vn, e.Constraint3D = function Constraint3D() {
				_classCallCheck(this, Constraint3D)
			}, e.ConstraintComponent = wn, e.ContactPoint = M, e.ContainmentType = Me, e.CylinderColliderShape = g, e
			.DefineDatas = ee, e.DirectionLight = Dn, e.DrawMeshCMD = ge, e.DrawRenderCMD = Qe, e.DynamicBatchManager =
			nr, e.EffectMaterial = st, e.Emission = tn, e.ExtendTerrainMaterial = ut, e.FixedConstraint = Bn, e
			.FloatKeyframe = U, e.FrameOverTime = Lr, e.FrustumCulling = Tt, e.GeometryElement = Ot, e.Gradient = Dr, e
			.GradientAngularVelocity = Pr, e.GradientColor = Ar, e.GradientDataInt = Or, e.GradientDataNumber = Nr, e
			.GradientDataVector2 = Xn, e.GradientMode = Cr, e.GradientSize = br, e.GradientVelocity = kr, e.HeightMap =
			zn, e.HeightfieldColliderShape = function HeightfieldColliderShape() {
				_classCallCheck(this, HeightfieldColliderShape)
			}, e.HemisphereShape = Hr, e.HitResult = D, e.ILaya3D = l, e.IndexBuffer3D = Oe, e.Input3D = St, e
			.Keyframe = F, e.KeyframeNode = B, e.KeyframeNodeList = X, e.KeyframeNodeOwner = q, e.Laya3D = Fn, e
			.LightQueue = xt, e.LightSprite = ze, e.Lightmap = Kt, e.LoadModelV04 = On, e.LoadModelV05 = Nn, e
			.Material = nt, e.MathUtils3D = r, e.Matrix3x3 = s, e.Matrix4x4 = c, e.Mesh = vn, e.MeshColliderShape = y, e
			.MeshFilter = yr, e.MeshReader = bn, e.MeshRenderDynamicBatchManager = vr, e.MeshRenderStaticBatchManager =
			Ht, e.MeshRenderer = gr, e.MeshSprite3D = Rr, e.MeshSprite3DShaderDeclaration = Er, e.MeshTerrainSprite3D =
			Wn, e.MouseTouch = gt, e.OctreeMotionList = Qt, e.PBRMaterial = ct, e.PBRSpecularMaterial = hr, e
			.PBRStandardMaterial = dr, e.Physics3D = k, e.Physics3DUtils = m, e.PhysicsCollider = gn, e
			.PhysicsComponent = v, e.PhysicsSettings = Rt, e.PhysicsSimulation = I, e.PhysicsTriggerComponent = N, e
			.PhysicsUpdateList = C, e.Picker = Pe, e.PixelLineData = Yn, e.PixelLineFilter = bt, e.PixelLineMaterial =
			It, e.PixelLineRenderer = Xt, e.PixelLineSprite3D = Yt, e.PixelLineVertex = Nt, e.Plane = Re, e
			.Point2PointConstraint = $n, e.PointLight = xn, e.PostProcess = $e, e.PostProcessEffect = jn, e
			.PostProcessRenderContext = Je, e.PrimitiveMesh = Rn, e.Quaternion = u, e.QuaternionKeyframe = G, e.Rand =
			en, e.RandX = Jn, e.Ray = Ce, e.ReflectionProbe = zt, e.ReflectionProbeList = ar, e.ReflectionProbeManager =
			or, e.RenderContext3D = J, e.RenderElement = Ze, e.RenderQueue = jt, e.RenderState = at, e.RenderTexture =
			$, e.RenderableSprite3D = kt, e.Rigidbody3D = b, e.RotationOverLifetime = wr, e.Scene3D = sr, e
			.Scene3DShaderDeclaration = Ue, e.Scene3DUtils = Pn, e.SceneManager = function SceneManager() {
				_classCallCheck(this, SceneManager)
			}, e.ScreenQuad = se, e.ScreenTriangle = le, e.Script3D = Hn, e.SetGlobalShaderDataCMD = qe, e
			.SetRenderTargetCMD = pe, e.SetShaderDataCMD = Te, e.Shader3D = _e, e.ShaderData = ne, e.ShaderDefine = ue,
			e.ShaderInit3D = Mn, e.ShaderInstance = _t, e.ShaderPass = lr, e.ShaderVariable = ht, e.ShaderVariant = ce,
			e.ShaderVariantCollection = he, e.ShadowCasterPass = rr, e.ShadowCullInfo = pt, e.ShadowSliceData = er, e
			.ShadowSpotData = tr, e.ShadowUtils = Ye, e.ShapeUtils = Vr, e.ShuriKenParticle3D = an, e
			.ShuriKenParticle3DShaderDeclaration = Zr, e.ShurikenParticleData = rn, e.ShurikenParticleMaterial = Qr, e
			.ShurikenParticleRenderer = qr, e.ShurikenParticleSystem = nn, e.SimpleSingletonList = dt, e
			.SimpleSkinnedMeshRenderer = In, e.SimpleSkinnedMeshSprite3D = Ln, e.SingletonList = R, e.Size = ti, e
			.SizeOverLifetime = Wr, e.SkinnedMeshRenderer = sn, e.SkinnedMeshSprite3D = ln, e
			.SkinnedMeshSprite3DShaderDeclaration = on, e.SkyBox = ke, e.SkyBoxMaterial = fr, e.SkyDome = Mt, e
			.SkyMesh = be, e.SkyPanoramicMaterial = kn, e.SkyProceduralMaterial = mr, e.SkyRenderer = we, e
			.SphereColliderShape = S, e.SphereShape = zr, e.SphericalHarmonicsL2 = Et, e.SpotLight = An, e.Sprite3D =
			Ee, e.StartFrame = Xr, e.StaticBatchManager = Ft, e.StaticPlaneColliderShape = _, e.SubMesh = yn, e
			.SubMeshDynamicBatch = Sr, e.SubMeshInstanceBatch = Bt, e.SubMeshRenderElement = Vt, e.SubMeshStaticBatch =
			Ut, e.SubShader = cr, e.TextMesh = ei, e.TextureCube = Dt, e.TextureGenerator = L, e.TextureMode = hn, e
			.TextureSheetAnimation = Yr, e.Touch = yt, e.TrailFilter = fn, e.TrailGeometry = dn, e.TrailMaterial = un, e
			.TrailRenderer = mn, e.TrailSprite3D = pn, e.Transform3D = f, e.UnlitMaterial = pr, e.Utils3D = P, e
			.Vector2 = n, e.Vector3 = o, e.Vector3Keyframe = H, e.Vector4 = i, e.VelocityOverLifetime = jr, e
			.VertexBuffer3D = te, e.VertexDeclaration = ie, e.VertexElement = ae, e.VertexElementFormat = re, e
			.VertexMesh = Ne, e.VertexPositionTerrain = Tn, e.VertexPositionTexture0 = Ct, e.VertexShuriKenParticle =
			Kr, e.VertexShurikenParticleBillboard = Jr, e.VertexShurikenParticleMesh = $r, e.VertexTrail = _n, e
			.Viewport = Ie, e.WaterPrimaryMaterial = Tr, e.skinnedMatrixCache = Sn
	}(window.Laya = window.Laya || {}, Laya);
}()
