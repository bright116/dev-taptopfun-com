function _typeof(e) {
    return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e;
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    })(e);
}

function set(e, t, r, n) {
    return (set = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(e, t, r, n) {
        var i, a = _superPropBase(e, t);
        if (a) {
            if ((i = Object.getOwnPropertyDescriptor(a, t)).set) return i.set.call(n, r), !0;
            if (!i.writable) return !1;
        }
        if (i = Object.getOwnPropertyDescriptor(n, t)) {
            if (!i.writable) return !1;
            i.value = r, Object.defineProperty(n, t, i);
        } else _defineProperty(n, t, r);
        return !0;
    })(e, t, r, n);
}

function _set(e, t, r, n, i) {
    if (!set(e, t, r, n || e) && i) throw new Error("failed to set property");
    return r;
}

function _defineProperty(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e;
}

function _possibleConstructorReturn(e, t) {
    return !t || "object" !== _typeof(t) && "function" != typeof t ? _assertThisInitialized(e) : t;
}

function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
}

function _get(e, t, r) {
    return (_get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(e, t, r) {
        var n = _superPropBase(e, t);
        if (n) {
            var i = Object.getOwnPropertyDescriptor(n, t);
            return i.get ? i.get.call(r) : i.value;
        }
    })(e, t, r || e);
}

function _superPropBase(e, t) {
    for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = _getPrototypeOf(e)););
    return e;
}

function _getPrototypeOf(e) {
    return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
    })(e);
}

function _inherits(e, t) {
    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), t && _setPrototypeOf(e, t);
}

function _setPrototypeOf(e, t) {
    return (_setPrototypeOf = Object.setPrototypeOf || function(e, t) {
        return e.__proto__ = t, e;
    })(e, t);
}

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, t) {
    for (var r = 0; r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0),
            Object.defineProperty(e, n.key, n);
    }
}

function _createClass(e, t, r) {
    return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
}

! function(e, t) {
    var r = function() {
        function MathUtils3D() {
            _classCallCheck(this, MathUtils3D);
        }
        return _createClass(MathUtils3D, null, [{
            key: "isZero",
            value: function(e) {
                return Math.abs(e) < MathUtils3D.zeroTolerance;
            }
        }, {
            key: "nearEqual",
            value: function(e, t) {
                return !!MathUtils3D.isZero(e - t);
            }
        }, {
            key: "fastInvSqrt",
            value: function(e) {
                return MathUtils3D.isZero(e) ? e : 1 / Math.sqrt(e);
            }
        }]), MathUtils3D;
    }();
    r.zeroTolerance = 1e-6, r.MaxValue = 3.40282347e38, r.MinValue = -3.40282347e38,
        r.Deg2Rad = Math.PI / 180;
    var n = function() {
        function Vector2() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            _classCallCheck(this, Vector2), this.x = e, this.y = t;
        }
        return _createClass(Vector2, [{
            key: "setValue",
            value: function(e, t) {
                this.x = e, this.y = t;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector2();
                return this.cloneTo(e), e;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]),
                    Vector2.rewriteNumProperty(this, "x", 0), Vector2.rewriteNumProperty(this, "y", 1);
            }
        }], [{
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t, r.y = e.y * t;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.x,
                    n = e.y,
                    i = r * r + n * n;
                i > 0 && (i = 1 / Math.sqrt(i), t.x = r * i, t.y = n * i);
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x,
                    r = e.y;
                return Math.sqrt(t * t + r * r);
            }
        }, {
            key: "rewriteNumProperty",
            value: function(e, t, r) {
                Object.defineProperty(e, t, {
                    get: function() {
                        return this.elements[r];
                    },
                    set: function(e) {
                        this.elements[r] = e;
                    }
                });
            }
        }]), Vector2;
    }();
    n.ZERO = new n(0, 0), n.ONE = new n(1, 1);
    var i = function() {
        function Vector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, Vector4), this.x = e, this.y = t, this.z = r, this.w = n;
        }
        return _createClass(Vector4, [{
            key: "setValue",
            value: function(e, t, r, n) {
                this.x = e, this.y = t, this.z = r, this.w = n;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    n.rewriteNumProperty(this, "x", 0), n.rewriteNumProperty(this, "y", 1), n.rewriteNumProperty(this, "z", 2),
                    n.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "lerp",
            value: function(e, t, r, n) {
                var i = e.x,
                    a = e.y,
                    o = e.z,
                    s = e.w;
                n.x = i + r * (t.x - i), n.y = a + r * (t.y - a), n.z = o + r * (t.z - o), n.w = s + r * (t.w - s);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = e.w,
                    s = t.elements;
                r.x = n * s[0] + i * s[4] + a * s[8] + o * s[12], r.y = n * s[1] + i * s[5] + a * s[9] + o * s[13],
                    r.z = n * s[2] + i * s[6] + a * s[10] + o * s[14], r.w = n * s[3] + i * s[7] + a * s[11] + o * s[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y), Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r.nearEqual(Math.abs(e.w), Math.abs(t.w));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.length();
                if (r > 0) {
                    var n = 1 / r;
                    t.x = e.x * n, t.y = e.y * n, t.z = e.z * n, t.w = e.w * n;
                }
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r.w = e.w - t.w;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r.w = e.w * t.w;
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.x,
                    a = e.y,
                    o = e.z,
                    s = e.w,
                    l = t.x,
                    u = t.y,
                    c = t.z,
                    h = t.w,
                    _ = r.x,
                    d = r.y,
                    f = r.z,
                    m = r.w;
                i = (i = i > _ ? _ : i) < l ? l : i, a = (a = a > d ? d : a) < u ? u : a, o = (o = o > f ? f : o) < c ? c : o,
                    s = (s = s > m ? m : s) < h ? h : s, n.x = i, n.y = a, n.z = o, n.w = s;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.x - t.x,
                    n = e.y - t.y,
                    i = e.z - t.z,
                    a = e.w - t.w;
                return r * r + n * n + i * i + a * a;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.x - t.x,
                    n = e.y - t.y,
                    i = e.z - t.z,
                    a = e.w - t.w;
                return Math.sqrt(r * r + n * n + i * i + a * a);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z), r.w = Math.min(e.w, t.w);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z), r.w = Math.max(e.w, t.w);
            }
        }]), Vector4;
    }();
    i.ZERO = new i(), i.ONE = new i(1, 1, 1, 1), i.UnitX = new i(1, 0, 0, 0), i.UnitY = new i(0, 1, 0, 0),
        i.UnitZ = new i(0, 0, 1, 0), i.UnitW = new i(0, 0, 0, 1);
    var a, o = function() {
        function Vector3() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
            arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            _classCallCheck(this, Vector3), this.x = e, this.y = t, this.z = r;
        }
        return _createClass(Vector3, [{
            key: "setValue",
            value: function(e, t, r) {
                this.x = e, this.y = t, this.z = r;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.x = this.x, t.y = this.y, t.z = this.z;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Vector3();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.x = 0, this.y = 0, this.z = 0;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]),
                    n.rewriteNumProperty(this, "x", 0), n.rewriteNumProperty(this, "y", 1), n.rewriteNumProperty(this, "z", 2);
            }
        }], [{
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.x - t.x,
                    n = e.y - t.y,
                    i = e.z - t.z;
                return r * r + n * n + i * i;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.x - t.x,
                    n = e.y - t.y,
                    i = e.z - t.z;
                return Math.sqrt(r * r + n * n + i * i);
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.x,
                    s = t.y,
                    l = t.z,
                    u = t.w,
                    c = u * n + s * a - l * i,
                    h = u * i + l * n - o * a,
                    _ = u * a + o * i - s * n,
                    d = -o * n - s * i - l * a;
                r.x = c * u + d * -o + h * -l - _ * -s, r.y = h * u + d * -s + _ * -o - c * -l,
                    r.z = _ * u + d * -l + c * -s - h * -o;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.x,
                    r = e.y,
                    n = e.z;
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.x,
                    r = e.y,
                    n = e.z;
                return t * t + r * r + n * n;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.x,
                    n = e.y,
                    i = e.z,
                    a = r * r + n * n + i * i;
                a > 0 && (a = 1 / Math.sqrt(a), t.x = r * a, t.y = n * a, t.z = i * a);
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z;
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                r.x = e.x * t, r.y = e.y * t, r.z = e.z * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = e.x,
                    a = e.y,
                    o = e.z;
                n.x = i + r * (t.x - i), n.y = a + r * (t.y - a), n.z = o + r * (t.z - o);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, r) {
                var n = Vector3._tempVector4;
                Vector3.transformV3ToV4(e, t, n), r.x = n.x, r.y = n.y, r.z = n.z;
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.elements;
                r.x = n * o[0] + i * o[4] + a * o[8] + o[12], r.y = n * o[1] + i * o[5] + a * o[9] + o[13],
                    r.z = n * o[2] + i * o[6] + a * o[10] + o[14], r.w = n * o[3] + i * o[7] + a * o[11] + o[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.elements;
                r.x = n * o[0] + i * o[4] + a * o[8], r.y = n * o[1] + i * o[5] + a * o[9], r.z = n * o[2] + i * o[6] + a * o[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.elements,
                    s = n * o[3] + i * o[7] + a * o[11] + o[15];
                r.x = (n * o[0] + i * o[4] + a * o[8] + o[12]) / s, r.y = (n * o[1] + i * o[5] + a * o[9] + o[13]) / s,
                    r.z = (n * o[2] + i * o[6] + a * o[10] + o[14]) / s;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.x,
                    a = e.y,
                    o = e.z,
                    s = t.x,
                    l = t.y,
                    u = t.z,
                    c = r.x,
                    h = r.y,
                    _ = r.z;
                i = (i = i > c ? c : i) < s ? s : i, a = (a = a > h ? h : a) < l ? l : a, o = (o = o > _ ? _ : o) < u ? u : o,
                    n.x = i, n.y = a, n.z = o;
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z;
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z;
            }
        }, {
            key: "cross",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.x,
                    s = t.y,
                    l = t.z;
                r.x = i * l - a * s, r.y = a * o - n * l, r.z = n * s - i * o;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z;
            }
        }, {
            key: "equals",
            value: function(e, t) {
                return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z);
            }
        }]), Vector3;
    }();
    o._tempVector4 = new i(), o._ZERO = new o(0, 0, 0), o._ONE = new o(1, 1, 1), o._NegativeUnitX = new o(-1, 0, 0),
        o._UnitX = new o(1, 0, 0), o._UnitY = new o(0, 1, 0), o._UnitZ = new o(0, 0, 1),
        o._ForwardRH = new o(0, 0, -1), o._ForwardLH = new o(0, 0, 1), o._Up = new o(0, 1, 0),
        (a = e.PBRRenderQuality || (e.PBRRenderQuality = {}))[a.High = 0] = "High", a[a.Low = 1] = "Low";
    var s = function() {
        function Config3D() {
            _classCallCheck(this, Config3D), this._defaultPhysicsMemory = 16, this._maxLightCount = 32,
                this._lightClusterCount = new o(12, 12, 12), this._editerEnvironment = !1, this.isAntialias = !0,
                this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.enableMultiLight = !0,
                this.octreeCulling = !1, this.octreeInitialSize = 64, this.octreeInitialCenter = new o(0, 0, 0),
                this.octreeMinNodeSize = 2, this.octreeLooseness = 1.25, this.debugFrustumCulling = !1,
                this.pbrRenderQuality = e.PBRRenderQuality.High, this._maxAreaLightCountPerClusterAverage = Math.min(4 * Math.floor(2048 / this._lightClusterCount.z - 1), this._maxLightCount);
        }
        return _createClass(Config3D, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment,
                    t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha,
                    t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter),
                    t.octreeInitialSize = this.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize,
                    t.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this.debugFrustumCulling,
                    t.maxLightCount = this.maxLightCount, t.enableMultiLight = this.enableMultiLight;
                var r = t.lightClusterCount;
                this.lightClusterCount.cloneTo(r), t.lightClusterCount = r, t.pbrRenderQuality = this.pbrRenderQuality;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Config3D();
                return this.cloneTo(e), e;
            }
        }, {
            key: "defaultPhysicsMemory",
            get: function() {
                return this._defaultPhysicsMemory;
            },
            set: function(e) {
                if (e < 16) throw "defaultPhysicsMemory must large than 16M";
                this._defaultPhysicsMemory = e;
            }
        }, {
            key: "maxLightCount",
            get: function() {
                return this._maxLightCount;
            },
            set: function(e) {
                e > 2048 ? (this._maxLightCount = 2048, console.warn("Config3D: maxLightCount must less equal 2048.")) : this._maxLightCount = e;
            }
        }, {
            key: "lightClusterCount",
            get: function() {
                return this._lightClusterCount;
            },
            set: function(e) {
                e.x > 128 || e.y > 128 || e.z > 128 ? (this._lightClusterCount.setValue(Math.min(e.x, 128), Math.min(e.y, 128), Math.min(e.z, 128)),
                    console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.")) : e.cloneTo(this._lightClusterCount);
                var t = 4 * Math.floor(2048 / this._lightClusterCount.z - 1);
                t < this._maxLightCount && console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + t + ",maybe the far away culster will ingonre some light."),
                    this._maxAreaLightCountPerClusterAverage = Math.min(t, this._maxLightCount);
            }
        }]), Config3D;
    }();
    s._config = new s(), window.Config3D = s;
    var l = function ILaya3D() {
        _classCallCheck(this, ILaya3D);
    };
    l.Shader3D = null, l.Scene3D = null, l.MeshRenderStaticBatchManager = null, l.MeshRenderDynamicBatchManager = null,
        l.SubMeshDynamicBatch = null, l.Laya3D = null, l.Matrix4x4 = null;
    var u = function() {
            function KeyframeNode() {
                _classCallCheck(this, KeyframeNode), this._ownerPath = [], this._propertys = [],
                    this._keyFrames = [];
            }
            return _createClass(KeyframeNode, [{
                key: "_setOwnerPathCount",
                value: function(e) {
                    this._ownerPath.length = e;
                }
            }, {
                key: "_setOwnerPathByIndex",
                value: function(e, t) {
                    this._ownerPath[e] = t;
                }
            }, {
                key: "_joinOwnerPath",
                value: function(e) {
                    return this._ownerPath.join(e);
                }
            }, {
                key: "_setPropertyCount",
                value: function(e) {
                    this._propertys.length = e;
                }
            }, {
                key: "_setPropertyByIndex",
                value: function(e, t) {
                    this._propertys[e] = t;
                }
            }, {
                key: "_joinProperty",
                value: function(e) {
                    return this._propertys.join(e);
                }
            }, {
                key: "_setKeyframeCount",
                value: function(e) {
                    this._keyFrames.length = e;
                }
            }, {
                key: "_setKeyframeByIndex",
                value: function(e, t) {
                    this._keyFrames[e] = t;
                }
            }, {
                key: "getOwnerPathByIndex",
                value: function(e) {
                    return this._ownerPath[e];
                }
            }, {
                key: "getPropertyByIndex",
                value: function(e) {
                    return this._propertys[e];
                }
            }, {
                key: "getKeyframeByIndex",
                value: function(e) {
                    return this._keyFrames[e];
                }
            }, {
                key: "ownerPathCount",
                get: function() {
                    return this._ownerPath.length;
                }
            }, {
                key: "propertyCount",
                get: function() {
                    return this._propertys.length;
                }
            }, {
                key: "keyFramesCount",
                get: function() {
                    return this._keyFrames.length;
                }
            }]), KeyframeNode;
        }(),
        c = function AnimationEvent() {
            _classCallCheck(this, AnimationEvent);
        },
        h = function() {
            function Keyframe() {
                _classCallCheck(this, Keyframe);
            }
            return _createClass(Keyframe, [{
                key: "cloneTo",
                value: function(e) {
                    e.time = this.time;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Keyframe();
                    return this.cloneTo(e), e;
                }
            }]), Keyframe;
        }(),
        _ = function(e) {
            function FloatKeyframe() {
                return _classCallCheck(this, FloatKeyframe), _possibleConstructorReturn(this, _getPrototypeOf(FloatKeyframe).call(this));
            }
            return _inherits(FloatKeyframe, h), _createClass(FloatKeyframe, [{
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(FloatKeyframe.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this.value;
                }
            }]), FloatKeyframe;
        }(),
        d = function() {
            function Matrix3x3() {
                _classCallCheck(this, Matrix3x3);
                var e = this.elements = new Float32Array(9);
                e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                    e[8] = 1;
            }
            return _createClass(Matrix3x3, [{
                key: "determinant",
                value: function() {
                    var e = this.elements,
                        t = e[0],
                        r = e[1],
                        n = e[2],
                        i = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        u = e[8];
                    return t * (u * a - o * l) + r * (-u * i + o * s) + n * (l * i - a * s);
                }
            }, {
                key: "translate",
                value: function(e, t) {
                    var r = t.elements,
                        n = this.elements,
                        i = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        l = n[4],
                        u = n[5],
                        c = n[6],
                        h = n[7],
                        _ = n[8],
                        d = e.x,
                        f = e.y;
                    r[0] = i, r[1] = a, r[2] = o, r[3] = s, r[4] = l, r[5] = u, r[6] = d * i + f * s + c,
                        r[7] = d * a + f * l + h, r[8] = d * o + f * u + _;
                }
            }, {
                key: "rotate",
                value: function(e, t) {
                    var r = t.elements,
                        n = this.elements,
                        i = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        l = n[4],
                        u = n[5],
                        c = n[6],
                        h = n[7],
                        _ = n[8],
                        d = Math.sin(e),
                        f = Math.cos(e);
                    r[0] = f * i + d * s, r[1] = f * a + d * l, r[2] = f * o + d * u, r[3] = f * s - d * i,
                        r[4] = f * l - d * a, r[5] = f * u - d * o, r[6] = c, r[7] = h, r[8] = _;
                }
            }, {
                key: "scale",
                value: function(e, t) {
                    var r = t.elements,
                        n = this.elements,
                        i = e.x,
                        a = e.y;
                    r[0] = i * n[0], r[1] = i * n[1], r[2] = i * n[2], r[3] = a * n[3], r[4] = a * n[4],
                        r[5] = a * n[5], r[6] = n[6], r[7] = n[7], r[8] = n[8];
                }
            }, {
                key: "invert",
                value: function(e) {
                    var t = e.elements,
                        r = this.elements,
                        n = r[0],
                        i = r[1],
                        a = r[2],
                        o = r[3],
                        s = r[4],
                        l = r[5],
                        u = r[6],
                        c = r[7],
                        h = r[8],
                        _ = h * s - l * c,
                        d = -h * o + l * u,
                        f = c * o - s * u,
                        m = n * _ + i * d + a * f;
                    m || (e = null), m = 1 / m, t[0] = _ * m, t[1] = (-h * i + a * c) * m, t[2] = (l * i - a * s) * m,
                        t[3] = d * m, t[4] = (h * n - a * u) * m, t[5] = (-l * n + a * o) * m, t[6] = f * m,
                        t[7] = (-c * n + i * u) * m, t[8] = (s * n - i * o) * m;
                }
            }, {
                key: "transpose",
                value: function(e) {
                    var t = e.elements,
                        r = this.elements;
                    if (e === this) {
                        var n = r[1],
                            i = r[2],
                            a = r[5];
                        t[1] = r[3], t[2] = r[6], t[3] = n, t[5] = r[7], t[6] = i, t[7] = a;
                    } else t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] = r[7],
                        t[6] = r[2], t[7] = r[5], t[8] = r[8];
                }
            }, {
                key: "identity",
                value: function() {
                    var e = this.elements;
                    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                        e[8] = 1;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t, r, n;
                    if ((r = this.elements) !== (n = e.elements))
                        for (t = 0; t < 9; ++t) n[t] = r[t];
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Matrix3x3();
                    return this.cloneTo(e), e;
                }
            }], [{
                key: "createRotationQuaternion",
                value: function(e, t) {
                    var r = e.x,
                        n = e.y,
                        i = e.z,
                        a = e.w,
                        o = r * r,
                        s = n * n,
                        l = i * i,
                        u = r * n,
                        c = i * a,
                        h = i * r,
                        _ = n * a,
                        d = n * i,
                        f = r * a,
                        m = t.elements;
                    m[0] = 1 - 2 * (s + l), m[1] = 2 * (u + c), m[2] = 2 * (h - _), m[3] = 2 * (u - c),
                        m[4] = 1 - 2 * (l + o), m[5] = 2 * (d + f), m[6] = 2 * (h + _), m[7] = 2 * (d - f),
                        m[8] = 1 - 2 * (s + o);
                }
            }, {
                key: "createFromTranslation",
                value: function(e, t) {
                    var r = t.elements;
                    r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 1, r[5] = 0, r[6] = e.x, r[7] = e.y,
                        r[8] = 1;
                }
            }, {
                key: "createFromRotation",
                value: function(e, t) {
                    var r = t.elements,
                        n = Math.sin(e),
                        i = Math.cos(e);
                    r[0] = i, r[1] = n, r[2] = 0, r[3] = -n, r[4] = i, r[5] = 0, r[6] = 0, r[7] = 0,
                        r[8] = 1;
                }
            }, {
                key: "createFromScaling",
                value: function(e, t) {
                    var r = t.elements;
                    r[0] = e.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = e.y, r[5] = 0, r[6] = 0, r[7] = 0,
                        r[8] = e.z;
                }
            }, {
                key: "createFromMatrix4x4",
                value: function(e, t) {
                    var r = e.elements,
                        n = t.elements;
                    n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[4], n[4] = r[5], n[5] = r[6], n[6] = r[8],
                        n[7] = r[9], n[8] = r[10];
                }
            }, {
                key: "multiply",
                value: function(e, t, r) {
                    var n = e.elements,
                        i = t.elements,
                        a = r.elements,
                        o = n[0],
                        s = n[1],
                        l = n[2],
                        u = n[3],
                        c = n[4],
                        h = n[5],
                        _ = n[6],
                        d = n[7],
                        f = n[8],
                        m = i[0],
                        T = i[1],
                        p = i[2],
                        v = i[3],
                        E = i[4],
                        g = i[5],
                        y = i[6],
                        S = i[7],
                        R = i[8];
                    a[0] = m * o + T * u + p * _, a[1] = m * s + T * c + p * S, a[2] = m * l + T * h + p * f,
                        a[3] = v * o + E * u + g * _, a[4] = v * s + E * c + g * d, a[5] = v * l + E * h + g * f,
                        a[6] = y * o + S * u + R * _, a[7] = y * s + S * c + R * d, a[8] = y * l + S * h + R * f;
                }
            }, {
                key: "lookAt",
                value: function(e, t, r, n) {
                    o.subtract(e, t, Matrix3x3._tempV30), o.normalize(Matrix3x3._tempV30, Matrix3x3._tempV30),
                        o.cross(r, Matrix3x3._tempV30, Matrix3x3._tempV31), o.normalize(Matrix3x3._tempV31, Matrix3x3._tempV31),
                        o.cross(Matrix3x3._tempV30, Matrix3x3._tempV31, Matrix3x3._tempV32);
                    var i = Matrix3x3._tempV30,
                        a = Matrix3x3._tempV31,
                        s = Matrix3x3._tempV32,
                        l = n.elements;
                    l[0] = a.x, l[3] = a.y, l[6] = a.z, l[1] = s.x, l[4] = s.y, l[7] = s.z, l[2] = i.x,
                        l[5] = i.y, l[8] = i.z;
                }
            }]), Matrix3x3;
        }();
    d.DEFAULT = new d(), d._tempV30 = new o(), d._tempV31 = new o(), d._tempV32 = new o();
    var f = function() {
        function Quaternion() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
            arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
            _classCallCheck(this, Quaternion), this.x = e, this.y = t, this.z = r, this.w = n;
        }
        return _createClass(Quaternion, [{
            key: "scaling",
            value: function(e, t) {
                t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t,
                    e.w = this.w * t);
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    n = Math.cos(e);
                t.x = this.x * n + this.w * r, t.y = this.y * n + this.z * r, t.z = this.z * n - this.y * r,
                    t.w = this.w * n - this.x * r;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    n = Math.cos(e);
                t.x = this.x * n - this.z * r, t.y = this.y * n + this.w * r, t.z = this.z * n + this.x * r,
                    t.w = this.w * n - this.y * r;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                e *= .5;
                var r = Math.sin(e),
                    n = Math.cos(e);
                t.x = this.x * n + this.y * r, t.y = this.y * n - this.x * r, t.z = this.z * n + this.w * r,
                    t.w = this.w * n - this.z * r;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                o.transformQuat(o._ForwardRH, this, Quaternion.TEMPVector31), o.transformQuat(o._Up, this, Quaternion.TEMPVector32);
                var t = Quaternion.TEMPVector32;
                Quaternion.angleTo(o._ZERO, Quaternion.TEMPVector31, Quaternion.TEMPVector33);
                var r = Quaternion.TEMPVector33;
                r.x == Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(t.z, t.x), r.z = 0) : r.x == -Math.PI / 2 ? (r.y = Quaternion.arcTanAngle(-t.z, -t.x),
                        r.z = 0) : (l.Matrix4x4.createRotationY(-r.y, l.Matrix4x4.TEMPMatrix0), l.Matrix4x4.createRotationX(-r.x, l.Matrix4x4.TEMPMatrix1),
                        o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix0, Quaternion.TEMPVector32),
                        o.transformCoordinate(Quaternion.TEMPVector32, l.Matrix4x4.TEMPMatrix1, Quaternion.TEMPVector32),
                        r.z = Quaternion.arcTanAngle(t.y, -t.x)), r.y <= -Math.PI && (r.y = Math.PI), r.z <= -Math.PI && (r.z = Math.PI),
                    r.y >= Math.PI && r.z >= Math.PI && (r.y = 0, r.z = 0, r.x = Math.PI - r.x);
                var n = e;
                n.x = r.y, n.y = r.x, n.z = r.z;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.x,
                    r = this.y,
                    n = this.z,
                    i = this.w,
                    a = t * t + r * r + n * n + i * i,
                    o = a ? 1 / a : 0;
                e.x = -t * o, e.y = -r * o, e.z = -n * o, e.w = i * o;
            }
        }, {
            key: "identity",
            value: function() {
                this.x = 0, this.y = 0, this.z = 0, this.w = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Quaternion();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function(e) {
                return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this.z, e.z) && r.nearEqual(this.w, e.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "forNativeElement",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                        this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                    n.rewriteNumProperty(this, "x", 0), n.rewriteNumProperty(this, "y", 1), n.rewriteNumProperty(this, "z", 2),
                    n.rewriteNumProperty(this, "w", 3);
            }
        }], [{
            key: "createFromYawPitchRoll",
            value: function(e, t, r, n) {
                var i = .5 * r,
                    a = .5 * t,
                    o = .5 * e,
                    s = Math.sin(i),
                    l = Math.cos(i),
                    u = Math.sin(a),
                    c = Math.cos(a),
                    h = Math.sin(o),
                    _ = Math.cos(o);
                n.x = _ * u * l + h * c * s, n.y = h * c * l - _ * u * s, n.z = _ * c * s - h * u * l,
                    n.w = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = e.w,
                    s = t.x,
                    l = t.y,
                    u = t.z,
                    c = t.w,
                    h = i * u - a * l,
                    _ = a * s - n * u,
                    d = n * l - i * s,
                    f = n * s + i * l + a * u;
                r.x = n * c + s * o + h, r.y = i * c + l * o + _, r.z = a * c + u * o + d, r.w = o * c - f;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, r) {
                o.subtract(t, e, Quaternion.TEMPVector30), o.normalize(Quaternion.TEMPVector30, Quaternion.TEMPVector30),
                    r.x = Math.asin(Quaternion.TEMPVector30.y), r.y = Quaternion.arcTanAngle(-Quaternion.TEMPVector30.z, -Quaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, r) {
                t *= .5;
                var n = Math.sin(t);
                r.x = n * e.x, r.y = n * e.y, r.z = n * e.z, r.w = Math.cos(t);
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var r, n, i = e.elements,
                    a = i[0] + i[5] + i[10];
                a > 0 ? (r = Math.sqrt(a + 1), t.w = .5 * r, r = .5 / r, t.x = (i[6] - i[9]) * r,
                    t.y = (i[8] - i[2]) * r, t.z = (i[1] - i[4]) * r) : i[0] >= i[5] && i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])),
                    t.x = .5 * r, t.y = (i[1] + i[4]) * n, t.z = (i[2] + i[8]) * n, t.w = (i[6] - i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] - i[0] - i[10])),
                    t.x = (i[4] + i[1]) * n, t.y = .5 * r, t.z = (i[9] + i[6]) * n, t.w = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 + i[10] - i[0] - i[5])),
                    t.x = (i[8] + i[2]) * n, t.y = (i[9] + i[6]) * n, t.z = .5 * r, t.w = (i[1] - i[4]) * n);
            }
        }, {
            key: "slerp",
            value: function(e, t, r, n) {
                var i, a, o, s, l, u = e.x,
                    c = e.y,
                    h = e.z,
                    _ = e.w,
                    d = t.x,
                    f = t.y,
                    m = t.z,
                    T = t.w;
                return (a = u * d + c * f + h * m + _ * T) < 0 && (a = -a, d = -d, f = -f, m = -m,
                        T = -T), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math.sin((1 - r) * i) / o,
                        l = Math.sin(r * i) / o) : (s = 1 - r, l = r), n.x = s * u + l * d, n.y = s * c + l * f,
                    n.z = s * h + l * m, n.w = s * _ + l * T, n;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = 1 - r;
                Quaternion.dot(e, t) >= 0 ? (n.x = i * e.x + r * t.x, n.y = i * e.y + r * t.y, n.z = i * e.z + r * t.z,
                    n.w = i * e.w + r * t.w) : (n.x = i * e.x - r * t.x, n.y = i * e.y - r * t.y, n.z = i * e.z - r * t.z,
                    n.w = i * e.w - r * t.w), n.normalize(n);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, r) {
                Quaternion.lookAt(o._ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function(e, t, r, n) {
                d.lookAt(e, t, r, Quaternion._tempMatrix3x3), Quaternion.rotationMatrix(Quaternion._tempMatrix3x3, n);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var n = e.lengthSquared();
                r.isZero(n) || (n = 1 / n, t.x = -e.x * n, t.y = -e.y * n, t.z = -e.z * n, t.w = e.w * n);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var r, n, i = e.elements,
                    a = i[0],
                    o = i[1],
                    s = i[2],
                    l = i[3],
                    u = i[4],
                    c = i[5],
                    h = i[6],
                    _ = i[7],
                    d = i[8],
                    f = a + u + d;
                f > 0 ? (r = Math.sqrt(f + 1), t.w = .5 * r, r = .5 / r, t.x = (c - _) * r, t.y = (h - s) * r,
                    t.z = (o - l) * r) : a >= u && a >= d ? (n = .5 / (r = Math.sqrt(1 + a - u - d)),
                    t.x = .5 * r, t.y = (o + l) * n, t.z = (s + h) * n, t.w = (c - _) * n) : u > d ? (n = .5 / (r = Math.sqrt(1 + u - a - d)),
                    t.x = (l + o) * n, t.y = .5 * r, t.z = (_ + c) * n, t.w = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a - u)),
                    t.x = (h + s) * n, t.y = (_ + c) * n, t.z = .5 * r, t.w = (o - l) * n);
            }
        }]), Quaternion;
    }();
    f.TEMPVector30 = new o(), f.TEMPVector31 = new o(), f.TEMPVector32 = new o(), f.TEMPVector33 = new o(),
        f._tempMatrix3x3 = new d(), f.DEFAULT = new f(), f.NAN = new f(NaN, NaN, NaN, NaN);
    var m = function(e) {
            function QuaternionKeyframe() {
                var e;
                return _classCallCheck(this, QuaternionKeyframe), (e = _possibleConstructorReturn(this, _getPrototypeOf(QuaternionKeyframe).call(this))).inTangent = new i(),
                    e.outTangent = new i(), e.value = new f(), e;
            }
            return _inherits(QuaternionKeyframe, h), _createClass(QuaternionKeyframe, [{
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(QuaternionKeyframe.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
                }
            }]), QuaternionKeyframe;
        }(),
        T = function(e) {
            function Vector3Keyframe() {
                var e;
                return _classCallCheck(this, Vector3Keyframe), (e = _possibleConstructorReturn(this, _getPrototypeOf(Vector3Keyframe).call(this))).inTangent = new o(),
                    e.outTangent = new o(), e.value = new o(), e;
            }
            return _inherits(Vector3Keyframe, h), _createClass(Vector3Keyframe, [{
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(Vector3Keyframe.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
                }
            }]), Vector3Keyframe;
        }(),
        p = function() {
            function AnimationClipParser03() {
                _classCallCheck(this, AnimationClipParser03);
            }
            return _createClass(AnimationClipParser03, null, [{
                key: "READ_DATA",
                value: function() {
                    AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32(),
                        AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
                }
            }, {
                key: "READ_BLOCK",
                value: function() {
                    for (var e = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16(), t = AnimationClipParser03._BLOCK.blockStarts = [], r = AnimationClipParser03._BLOCK.blockLengths = [], n = 0; n < e; n++) t.push(AnimationClipParser03._reader.getUint32()),
                        r.push(AnimationClipParser03._reader.getUint32());
                }
            }, {
                key: "READ_STRINGS",
                value: function() {
                    var e = AnimationClipParser03._reader.getUint32(),
                        t = AnimationClipParser03._reader.getUint16(),
                        r = AnimationClipParser03._reader.pos;
                    AnimationClipParser03._reader.pos = e + AnimationClipParser03._DATA.offset;
                    for (var n = 0; n < t; n++) AnimationClipParser03._strings[n] = AnimationClipParser03._reader.readUTFString();
                    AnimationClipParser03._reader.pos = r;
                }
            }, {
                key: "parse",
                value: function(e, t) {
                    AnimationClipParser03._animationClip = e, AnimationClipParser03._reader = t;
                    t.__getBuffer();
                    AnimationClipParser03.READ_DATA(), AnimationClipParser03.READ_BLOCK(), AnimationClipParser03.READ_STRINGS();
                    for (var r = 0, n = AnimationClipParser03._BLOCK.count; r < n; r++) {
                        var i = t.getUint16(),
                            a = AnimationClipParser03._strings[i],
                            o = AnimationClipParser03["READ_" + a];
                        if (null == o) throw new Error("model file err,no this function:" + i + " " + a);
                        o.call(null);
                    }
                }
            }, {
                key: "READ_ANIMATIONS",
                value: function() {
                    var e, r, n, i = AnimationClipParser03._reader,
                        a = (i.__getBuffer(), []),
                        o = i.getUint16();
                    for (a.length = o, e = 0; e < o; e++) a[e] = i.getFloat32();
                    var s = AnimationClipParser03._animationClip;
                    s.name = AnimationClipParser03._strings[i.getUint16()];
                    var l = s._duration = i.getFloat32();
                    s.islooping = !!i.getByte(), s._frameRate = i.getInt16();
                    var h = i.getInt16(),
                        d = s._nodes;
                    d.count = h;
                    var f = s._nodesMap = {},
                        p = s._nodesDic = {};
                    for (e = 0; e < h; e++) {
                        n = new u(), d.setNodeByIndex(e, n), n._indexInList = e;
                        var v = n.type = i.getUint8(),
                            E = i.getUint16();
                        for (n._setOwnerPathCount(E), r = 0; r < E; r++) n._setOwnerPathByIndex(r, AnimationClipParser03._strings[i.getUint16()]);
                        var g = n._joinOwnerPath("/"),
                            y = f[g];
                        y || (f[g] = y = []), y.push(n), n.propertyOwner = AnimationClipParser03._strings[i.getUint16()];
                        var S = i.getUint16();
                        for (n._setPropertyCount(S), r = 0; r < S; r++) n._setPropertyByIndex(r, AnimationClipParser03._strings[i.getUint16()]);
                        var R = g + "." + n.propertyOwner + "." + n._joinProperty(".");
                        p[R] = n, n.fullPath = R;
                        var C = i.getUint16();
                        for (n._setKeyframeCount(C), r = 0; r < C; r++) switch (v) {
                            case 0:
                                var M = new _();
                                n._setKeyframeByIndex(r, M), M.time = a[i.getUint16()], M.inTangent = i.getFloat32(),
                                    M.outTangent = i.getFloat32(), M.value = i.getFloat32();
                                break;

                            case 1:
                            case 3:
                            case 4:
                                var x = new T();
                                if (n._setKeyframeByIndex(r, x), x.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (var D = x.data = new Float32Array(9), A = 0; A < 3; A++) D[A] = i.getFloat32();
                                    for (A = 0; A < 3; A++) D[3 + A] = i.getFloat32();
                                    for (A = 0; A < 3; A++) D[6 + A] = i.getFloat32();
                                } else {
                                    var L = x.inTangent,
                                        I = x.outTangent,
                                        O = x.value;
                                    L.x = i.getFloat32(), L.y = i.getFloat32(), L.z = i.getFloat32(), I.x = i.getFloat32(),
                                        I.y = i.getFloat32(), I.z = i.getFloat32(), O.x = i.getFloat32(), O.y = i.getFloat32(),
                                        O.z = i.getFloat32();
                                }
                                break;

                            case 2:
                                var P = new m();
                                if (n._setKeyframeByIndex(r, P), P.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (D = P.data = new Float32Array(12), A = 0; A < 4; A++) D[A] = i.getFloat32();
                                    for (A = 0; A < 4; A++) D[4 + A] = i.getFloat32();
                                    for (A = 0; A < 4; A++) D[8 + A] = i.getFloat32();
                                } else {
                                    var N = P.inTangent,
                                        b = P.outTangent,
                                        k = P.value;
                                    N.x = i.getFloat32(), N.y = i.getFloat32(), N.z = i.getFloat32(), N.w = i.getFloat32(),
                                        b.x = i.getFloat32(), b.y = i.getFloat32(), b.z = i.getFloat32(), b.w = i.getFloat32(),
                                        k.x = i.getFloat32(), k.y = i.getFloat32(), k.z = i.getFloat32(), k.w = i.getFloat32();
                                }
                                break;

                            default:
                                throw "AnimationClipParser03:unknown type.";
                        }
                    }
                    var V = i.getUint16();
                    for (e = 0; e < V; e++) {
                        var B, w = new c();
                        w.time = Math.min(l, i.getFloat32()), w.eventName = AnimationClipParser03._strings[i.getUint16()];
                        var F = i.getUint16();
                        for (F > 0 && (w.params = B = []), r = 0; r < F; r++) {
                            switch (i.getByte()) {
                                case 0:
                                    B.push(!!i.getByte());
                                    break;

                                case 1:
                                    B.push(i.getInt32());
                                    break;

                                case 2:
                                    B.push(i.getFloat32());
                                    break;

                                case 3:
                                    B.push(AnimationClipParser03._strings[i.getUint16()]);
                                    break;

                                default:
                                    throw new Error("unknown type.");
                            }
                        }
                        s.addEvent(w);
                    }
                }
            }]), AnimationClipParser03;
        }();
    p._strings = [], p._BLOCK = {
        count: 0
    }, p._DATA = {
        offset: 0,
        size: 0
    };
    var v = function() {
        function HalfFloatUtils() {
            _classCallCheck(this, HalfFloatUtils);
        }
        return _createClass(HalfFloatUtils, null, [{
            key: "__init__",
            value: function() {
                for (var e = 0; e < 256; ++e) {
                    var t = e - 127;
                    t < -27 ? (HalfFloatUtils._baseTable[0 | e] = 0, HalfFloatUtils._baseTable[256 | e] = 32768,
                        HalfFloatUtils._shiftTable[0 | e] = 24, HalfFloatUtils._shiftTable[256 | e] = 24) : t < -14 ? (HalfFloatUtils._baseTable[0 | e] = 1024 >> -t - 14,
                        HalfFloatUtils._baseTable[256 | e] = 1024 >> -t - 14 | 32768, HalfFloatUtils._shiftTable[0 | e] = -t - 1,
                        HalfFloatUtils._shiftTable[256 | e] = -t - 1) : t <= 15 ? (HalfFloatUtils._baseTable[0 | e] = t + 15 << 10,
                        HalfFloatUtils._baseTable[256 | e] = t + 15 << 10 | 32768, HalfFloatUtils._shiftTable[0 | e] = 13,
                        HalfFloatUtils._shiftTable[256 | e] = 13) : t < 128 ? (HalfFloatUtils._baseTable[0 | e] = 31744,
                        HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 24,
                        HalfFloatUtils._shiftTable[256 | e] = 24) : (HalfFloatUtils._baseTable[0 | e] = 31744,
                        HalfFloatUtils._baseTable[256 | e] = 64512, HalfFloatUtils._shiftTable[0 | e] = 13,
                        HalfFloatUtils._shiftTable[256 | e] = 13);
                }
                for (HalfFloatUtils._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                    var r = e << 13;
                    for (t = 0; 0 == (8388608 & r);) t -= 8388608, r <<= 1;
                    r &= -8388609, t += 947912704, HalfFloatUtils._mantissaTable[e] = r | t;
                }
                for (e = 1024; e < 2048; ++e) HalfFloatUtils._mantissaTable[e] = 939524096 + (e - 1024 << 13);
                for (HalfFloatUtils._exponentTable[0] = 0, e = 1; e < 31; ++e) HalfFloatUtils._exponentTable[e] = e << 23;
                for (HalfFloatUtils._exponentTable[31] = 1199570944, HalfFloatUtils._exponentTable[32] = 2147483648,
                    e = 33; e < 63; ++e) HalfFloatUtils._exponentTable[e] = 2147483648 + (e - 32 << 23);
                for (HalfFloatUtils._exponentTable[63] = 3347054592, HalfFloatUtils._offsetTable[0] = 0,
                    e = 1; e < 64; ++e) HalfFloatUtils._offsetTable[e] = 32 === e ? 0 : 1024;
            }
        }, {
            key: "roundToFloat16Bits",
            value: function(e) {
                HalfFloatUtils._floatView[0] = e;
                var t = HalfFloatUtils._uint32View[0],
                    r = t >> 23 & 511;
                return HalfFloatUtils._baseTable[r] + ((8388607 & t) >> HalfFloatUtils._shiftTable[r]);
            }
        }, {
            key: "convertToNumber",
            value: function(e) {
                var t = e >> 10;
                return HalfFloatUtils._uint32View[0] = HalfFloatUtils._mantissaTable[HalfFloatUtils._offsetTable[t] + (1023 & e)] + HalfFloatUtils._exponentTable[t],
                    HalfFloatUtils._floatView[0];
            }
        }]), HalfFloatUtils;
    }();
    v._buffer = new ArrayBuffer(4), v._floatView = new Float32Array(v._buffer), v._uint32View = new Uint32Array(v._buffer),
        v._baseTable = new Uint32Array(512), v._shiftTable = new Uint32Array(512), v._mantissaTable = new Uint32Array(2048),
        v._exponentTable = new Uint32Array(64), v._offsetTable = new Uint32Array(64);
    var E = function() {
        function AnimationClipParser04() {
            _classCallCheck(this, AnimationClipParser04);
        }
        return _createClass(AnimationClipParser04, null, [{
            key: "READ_DATA",
            value: function() {
                AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32(),
                    AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16(), t = AnimationClipParser04._BLOCK.blockStarts = [], r = AnimationClipParser04._BLOCK.blockLengths = [], n = 0; n < e; n++) t.push(AnimationClipParser04._reader.getUint32()),
                    r.push(AnimationClipParser04._reader.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = AnimationClipParser04._reader.getUint32(),
                    t = AnimationClipParser04._reader.getUint16(),
                    r = AnimationClipParser04._reader.pos;
                AnimationClipParser04._reader.pos = e + AnimationClipParser04._DATA.offset;
                for (var n = 0; n < t; n++) AnimationClipParser04._strings[n] = AnimationClipParser04._reader.readUTFString();
                AnimationClipParser04._reader.pos = r;
            }
        }, {
            key: "parse",
            value: function(e, t, r) {
                AnimationClipParser04._animationClip = e, AnimationClipParser04._reader = t, AnimationClipParser04._version = r,
                    AnimationClipParser04.READ_DATA(), AnimationClipParser04.READ_BLOCK(), AnimationClipParser04.READ_STRINGS();
                for (var n = 0, i = AnimationClipParser04._BLOCK.count; n < i; n++) {
                    var a = t.getUint16(),
                        o = AnimationClipParser04._strings[a],
                        s = AnimationClipParser04["READ_" + o];
                    if (null == s) throw new Error("model file err,no this function:" + a + " " + o);
                    s.call(null);
                }
                AnimationClipParser04._version = null, AnimationClipParser04._reader = null, AnimationClipParser04._animationClip = null;
            }
        }, {
            key: "READ_ANIMATIONS",
            value: function() {
                var e, r, n, i = AnimationClipParser04._reader,
                    a = (i.__getBuffer(), []),
                    o = i.getUint16();
                for (a.length = o, e = 0; e < o; e++) a[e] = i.getFloat32();
                var s = AnimationClipParser04._animationClip;
                s.name = AnimationClipParser04._strings[i.getUint16()];
                var l = s._duration = i.getFloat32();
                s.islooping = !!i.getByte(), s._frameRate = i.getInt16();
                var h = i.getInt16(),
                    d = s._nodes;
                d.count = h;
                var f = s._nodesMap = {},
                    p = s._nodesDic = {};
                for (e = 0; e < h; e++) {
                    n = new u(), d.setNodeByIndex(e, n), n._indexInList = e;
                    var E = n.type = i.getUint8(),
                        g = i.getUint16();
                    for (n._setOwnerPathCount(g), r = 0; r < g; r++) n._setOwnerPathByIndex(r, AnimationClipParser04._strings[i.getUint16()]);
                    var y = n._joinOwnerPath("/"),
                        S = f[y];
                    S || (f[y] = S = []), S.push(n), n.propertyOwner = AnimationClipParser04._strings[i.getUint16()];
                    var R = i.getUint16();
                    for (n._setPropertyCount(R), r = 0; r < R; r++) n._setPropertyByIndex(r, AnimationClipParser04._strings[i.getUint16()]);
                    var C = y + "." + n.propertyOwner + "." + n._joinProperty(".");
                    p[C] = n, n.fullPath = C;
                    var M = i.getUint16();
                    switch (n._setKeyframeCount(M), AnimationClipParser04._version) {
                        case "LAYAANIMATION:04":
                            for (r = 0; r < M; r++) switch (E) {
                                case 0:
                                    var x = new _();
                                    n._setKeyframeByIndex(r, x), x.time = a[i.getUint16()], x.inTangent = i.getFloat32(),
                                        x.outTangent = i.getFloat32(), x.value = i.getFloat32();
                                    break;

                                case 1:
                                case 3:
                                case 4:
                                    var D = new T();
                                    if (n._setKeyframeByIndex(r, D), D.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                        for (var A = D.data = new Float32Array(9), L = 0; L < 3; L++) A[L] = i.getFloat32();
                                        for (L = 0; L < 3; L++) A[3 + L] = i.getFloat32();
                                        for (L = 0; L < 3; L++) A[6 + L] = i.getFloat32();
                                    } else {
                                        var I = D.inTangent,
                                            O = D.outTangent,
                                            P = D.value;
                                        I.x = i.getFloat32(), I.y = i.getFloat32(), I.z = i.getFloat32(), O.x = i.getFloat32(),
                                            O.y = i.getFloat32(), O.z = i.getFloat32(), P.x = i.getFloat32(), P.y = i.getFloat32(),
                                            P.z = i.getFloat32();
                                    }
                                    break;

                                case 2:
                                    var N = new m();
                                    if (n._setKeyframeByIndex(r, N), N.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                        for (A = N.data = new Float32Array(12), L = 0; L < 4; L++) A[L] = i.getFloat32();
                                        for (L = 0; L < 4; L++) A[4 + L] = i.getFloat32();
                                        for (L = 0; L < 4; L++) A[8 + L] = i.getFloat32();
                                    } else {
                                        var b = N.inTangent,
                                            k = N.outTangent,
                                            V = N.value;
                                        b.x = i.getFloat32(), b.y = i.getFloat32(), b.z = i.getFloat32(), b.w = i.getFloat32(),
                                            k.x = i.getFloat32(), k.y = i.getFloat32(), k.z = i.getFloat32(), k.w = i.getFloat32(),
                                            V.x = i.getFloat32(), V.y = i.getFloat32(), V.z = i.getFloat32(), V.w = i.getFloat32();
                                    }
                                    break;

                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                            break;

                        case "LAYAANIMATION:COMPRESSION_04":
                            for (r = 0; r < M; r++) switch (E) {
                                case 0:
                                    x = new _(), n._setKeyframeByIndex(r, x), x.time = a[i.getUint16()], x.inTangent = v.convertToNumber(i.getUint16()),
                                        x.outTangent = v.convertToNumber(i.getUint16()), x.value = v.convertToNumber(i.getUint16());
                                    break;

                                case 1:
                                case 3:
                                case 4:
                                    if (D = new T(), n._setKeyframeByIndex(r, D), D.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                        for (A = D.data = new Float32Array(9), L = 0; L < 3; L++) A[L] = v.convertToNumber(i.getUint16());
                                        for (L = 0; L < 3; L++) A[3 + L] = v.convertToNumber(i.getUint16());
                                        for (L = 0; L < 3; L++) A[6 + L] = v.convertToNumber(i.getUint16());
                                    } else I = D.inTangent, O = D.outTangent, P = D.value, I.x = v.convertToNumber(i.getUint16()),
                                        I.y = v.convertToNumber(i.getUint16()), I.z = v.convertToNumber(i.getUint16()),
                                        O.x = v.convertToNumber(i.getUint16()), O.y = v.convertToNumber(i.getUint16()),
                                        O.z = v.convertToNumber(i.getUint16()), P.x = v.convertToNumber(i.getUint16()),
                                        P.y = v.convertToNumber(i.getUint16()), P.z = v.convertToNumber(i.getUint16());
                                    break;

                                case 2:
                                    if (N = new m(), n._setKeyframeByIndex(r, N), N.time = a[i.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                        for (A = N.data = new Float32Array(12), L = 0; L < 4; L++) A[L] = v.convertToNumber(i.getUint16());
                                        for (L = 0; L < 4; L++) A[4 + L] = v.convertToNumber(i.getUint16());
                                        for (L = 0; L < 4; L++) A[8 + L] = v.convertToNumber(i.getUint16());
                                    } else b = N.inTangent, k = N.outTangent, V = N.value, b.x = v.convertToNumber(i.getUint16()),
                                        b.y = v.convertToNumber(i.getUint16()), b.z = v.convertToNumber(i.getUint16()),
                                        b.w = v.convertToNumber(i.getUint16()), k.x = v.convertToNumber(i.getUint16()),
                                        k.y = v.convertToNumber(i.getUint16()), k.z = v.convertToNumber(i.getUint16()),
                                        k.w = v.convertToNumber(i.getUint16()), V.x = v.convertToNumber(i.getUint16()),
                                        V.y = v.convertToNumber(i.getUint16()), V.z = v.convertToNumber(i.getUint16()),
                                        V.w = v.convertToNumber(i.getUint16());
                                    break;

                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                    }
                }
                var B = i.getUint16();
                for (e = 0; e < B; e++) {
                    var w, F = new c();
                    F.time = Math.min(l, i.getFloat32()), F.eventName = AnimationClipParser04._strings[i.getUint16()];
                    var U = i.getUint16();
                    for (U > 0 && (F.params = w = []), r = 0; r < U; r++) {
                        switch (i.getByte()) {
                            case 0:
                                w.push(!!i.getByte());
                                break;

                            case 1:
                                w.push(i.getInt32());
                                break;

                            case 2:
                                w.push(i.getFloat32());
                                break;

                            case 3:
                                w.push(AnimationClipParser04._strings[i.getUint16()]);
                                break;

                            default:
                                throw new Error("unknown type.");
                        }
                    }
                    s.addEvent(F);
                }
            }
        }]), AnimationClipParser04;
    }();
    E._strings = [], E._BLOCK = {
        count: 0
    }, E._DATA = {
        offset: 0,
        size: 0
    };
    var g = function() {
            function KeyframeNodeList() {
                _classCallCheck(this, KeyframeNodeList), this._nodes = [];
            }
            return _createClass(KeyframeNodeList, [{
                key: "getNodeByIndex",
                value: function(e) {
                    return this._nodes[e];
                }
            }, {
                key: "setNodeByIndex",
                value: function(e, t) {
                    this._nodes[e] = t;
                }
            }, {
                key: "count",
                get: function() {
                    return this._nodes.length;
                },
                set: function(e) {
                    this._nodes.length = e;
                }
            }]), KeyframeNodeList;
        }(),
        y = function Physics3D() {
            _classCallCheck(this, Physics3D);
        };
    y._bullet = null, y._enablePhysics = !1;
    var S = function() {
            function TextureGenerator() {
                _classCallCheck(this, TextureGenerator);
            }
            return _createClass(TextureGenerator, null, [{
                key: "lightAttenTexture",
                value: function(e, t, r, n, i, a) {
                    var o = e / r,
                        s = 1 / (1 + 25 * o);
                    o >= .64 && (o > 1 ? s = 0 : s *= 1 - (o - .64) / .36), a[i] = Math.floor(255 * s + .5);
                }
            }, {
                key: "haloTexture",
                value: function(e, t, r, n, i, a) {
                    var o = (e - (r >>= 1)) / r,
                        s = (t - (n >>= 1)) / n,
                        l = o * o + s * s;
                    l > 1 && (l = 1), a[i] = Math.floor(255 * (1 - l) + .5);
                }
            }, {
                key: "_generateTexture2D",
                value: function(e, r, n, i) {
                    var a = 0,
                        o = 0;
                    switch (e.format) {
                        case t.TextureFormat.R8G8B8:
                            o = 3;
                            break;

                        case t.TextureFormat.R8G8B8A8:
                            o = 4;
                            break;

                        case t.TextureFormat.Alpha8:
                            o = 1;
                            break;

                        default:
                            throw "GeneratedTexture._generateTexture: unkonw texture format.";
                    }
                    for (var s = new Uint8Array(r * n * o), l = 0; l < n; l++)
                        for (var u = 0; u < r; u++) i(u, l, r, n, a, s),
                            a += o;
                    e.setPixels(s);
                }
            }]), TextureGenerator;
        }(),
        R = function() {
            function Utils3D() {
                _classCallCheck(this, Utils3D);
            }
            return _createClass(Utils3D, null, [{
                key: "_createFloatTextureBuffer",
                value: function(e, r) {
                    var n = new t.Texture2D(e, r, t.TextureFormat.R32G32B32A32, !1, !1);
                    return n.filterMode = t.FilterMode.Point, n.wrapModeU = t.WarpMode.Clamp, n.wrapModeV = t.WarpMode.Clamp,
                        n.anisoLevel = 0, n;
                }
            }, {
                key: "_convertToLayaVec3",
                value: function(e, t, r) {
                    var n = y._bullet;
                    t.x = r ? -n.btVector3_x(e) : n.btVector3_x(e), t.y = n.btVector3_y(e), t.z = n.btVector3_z(e);
                }
            }, {
                key: "_convertToBulletVec3",
                value: function(e, t, r) {
                    y._bullet.btVector3_setValue(t, r ? -e.x : e.x, e.y, e.z);
                }
            }, {
                key: "_rotationTransformScaleSkinAnimation",
                value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
                    var _, d, f, m, T, p = Utils3D._tempArray16_0,
                        v = Utils3D._tempArray16_1,
                        E = Utils3D._tempArray16_2,
                        g = n + n,
                        y = i + i,
                        S = a + a,
                        R = n * g,
                        C = i * g,
                        M = i * y,
                        x = a * g,
                        D = a * y,
                        A = a * S,
                        L = o * g,
                        I = o * y,
                        O = o * S;
                    for (p[15] = 1, p[0] = 1 - M - A, p[1] = C + O, p[2] = x - I, p[4] = C - O, p[5] = 1 - R - A,
                        p[6] = D + L, p[8] = x + I, p[9] = D - L, p[10] = 1 - R - M, v[15] = 1, v[0] = s,
                        v[5] = l, v[10] = u, _ = 0; _ < 4; _++) d = p[_], f = p[_ + 4], m = p[_ + 8], T = p[_ + 12],
                        E[_] = d, E[_ + 4] = f, E[_ + 8] = m, E[_ + 12] = d * e + f * t + m * r + T;
                    for (_ = 0; _ < 4; _++) d = E[_], f = E[_ + 4], m = E[_ + 8], T = E[_ + 12], c[_ + h] = d * v[0] + f * v[1] + m * v[2] + T * v[3],
                        c[_ + h + 4] = d * v[4] + f * v[5] + m * v[6] + T * v[7], c[_ + h + 8] = d * v[8] + f * v[9] + m * v[10] + T * v[11],
                        c[_ + h + 12] = d * v[12] + f * v[13] + m * v[14] + T * v[15];
                }
            }, {
                key: "_computeBoneAndAnimationDatasByBindPoseMatrxix",
                value: function(e, t, r, n, i, a) {
                    var o, s, l = 0,
                        u = 0,
                        c = e.length;
                    for (o = 0; o < c; l += e[o].keyframeWidth, u += 16, o++) Utils3D._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], n, u),
                        0 != o && (s = 16 * e[o].parentIndex, Utils3D.mulMatrixByArray(n, s, n, u, n, u));
                    var h = r.length;
                    for (o = 0; o < h; o++) Utils3D.mulMatrixByArrayAndMatrixFast(n, 16 * a[o], r[o], i, 16 * o);
                }
            }, {
                key: "_computeAnimationDatasByArrayAndMatrixFast",
                value: function(e, t, r, n) {
                    for (var i = 0, a = e.length; i < a; i++) Utils3D.mulMatrixByArrayAndMatrixFast(t, 16 * n[i], e[i], r, 16 * i);
                }
            }, {
                key: "_computeBoneAndAnimationDatasByBindPoseMatrxixOld",
                value: function(e, t, r, n, i) {
                    var a, o, s = 0,
                        l = 0,
                        u = e.length;
                    for (a = 0; a < u; s += e[a].keyframeWidth, l += 16, a++) Utils3D._rotationTransformScaleSkinAnimation(t[s + 7], t[s + 8], t[s + 9], t[s + 3], t[s + 4], t[s + 5], t[s + 6], t[s + 0], t[s + 1], t[s + 2], n, l),
                        0 != a && (o = 16 * e[a].parentIndex, Utils3D.mulMatrixByArray(n, o, n, l, n, l));
                    var c = r.length;
                    for (a = 0; a < c; a++) {
                        var h = 16 * a;
                        Utils3D.mulMatrixByArrayAndMatrixFast(n, h, r[a], i, h);
                    }
                }
            }, {
                key: "_computeAnimationDatasByArrayAndMatrixFastOld",
                value: function(e, t, r) {
                    for (var n = e.length, i = 0; i < n; i++) {
                        var a = 16 * i;
                        Utils3D.mulMatrixByArrayAndMatrixFast(t, a, e[i], r, a);
                    }
                }
            }, {
                key: "_computeRootAnimationData",
                value: function(e, t, r) {
                    for (var n = 0, i = 0, a = 0, o = e.length; n < o; i += e[n].keyframeWidth, a += 16,
                        n++) Utils3D.createAffineTransformationArray(t[i + 0], t[i + 1], t[i + 2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i + 8], t[i + 9], r, a);
                }
            }, {
                key: "transformVector3ArrayByQuat",
                value: function(e, t, r, n, i) {
                    var a = e[t],
                        o = e[t + 1],
                        s = e[t + 2],
                        l = r.x,
                        u = r.y,
                        c = r.z,
                        h = r.w,
                        _ = h * a + u * s - c * o,
                        d = h * o + c * a - l * s,
                        f = h * s + l * o - u * a,
                        m = -l * a - u * o - c * s;
                    n[i] = _ * h + m * -l + d * -c - f * -u, n[i + 1] = d * h + m * -u + f * -l - _ * -c,
                        n[i + 2] = f * h + m * -c + _ * -u - d * -l;
                }
            }, {
                key: "mulMatrixByArray",
                value: function(e, t, r, n, i, a) {
                    var o, s, l, u, c;
                    if (i === r) {
                        for (r = Utils3D._tempArray16_3, o = 0; o < 16; ++o) r[o] = i[a + o];
                        n = 0;
                    }
                    for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[t + o + 12],
                        i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c * r[n + 3], i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[n + 7],
                        i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c * r[n + 11], i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] + c * r[n + 15];
                }
            }, {
                key: "mulMatrixByArrayFast",
                value: function(e, t, r, n, i, a) {
                    var o, s, l, u, c;
                    for (o = 0; o < 4; o++) s = e[t + o], l = e[t + o + 4], u = e[t + o + 8], c = e[t + o + 12],
                        i[a + o] = s * r[n + 0] + l * r[n + 1] + u * r[n + 2] + c * r[n + 3], i[a + o + 4] = s * r[n + 4] + l * r[n + 5] + u * r[n + 6] + c * r[n + 7],
                        i[a + o + 8] = s * r[n + 8] + l * r[n + 9] + u * r[n + 10] + c * r[n + 11], i[a + o + 12] = s * r[n + 12] + l * r[n + 13] + u * r[n + 14] + c * r[n + 15];
                }
            }, {
                key: "mulMatrixByArrayAndMatrixFast",
                value: function(e, t, r, n, i) {
                    var a, o, s, l, u, c = r.elements,
                        h = c[0],
                        _ = c[1],
                        d = c[2],
                        f = c[3],
                        m = c[4],
                        T = c[5],
                        p = c[6],
                        v = c[7],
                        E = c[8],
                        g = c[9],
                        y = c[10],
                        S = c[11],
                        R = c[12],
                        C = c[13],
                        M = c[14],
                        x = c[15],
                        D = t,
                        A = t + 4,
                        L = t + 8,
                        I = t + 12,
                        O = i,
                        P = i + 4,
                        N = i + 8,
                        b = i + 12;
                    for (a = 0; a < 4; a++) o = e[D + a], s = e[A + a], l = e[L + a], u = e[I + a],
                        n[O + a] = o * h + s * _ + l * d + u * f, n[P + a] = o * m + s * T + l * p + u * v,
                        n[N + a] = o * E + s * g + l * y + u * S, n[b + a] = o * R + s * C + l * M + u * x;
                }
            }, {
                key: "createAffineTransformationArray",
                value: function(e, t, r, n, i, a, o, s, l, u, c, h) {
                    var _ = n + n,
                        d = i + i,
                        f = a + a,
                        m = n * _,
                        T = n * d,
                        p = n * f,
                        v = i * d,
                        E = i * f,
                        g = a * f,
                        y = o * _,
                        S = o * d,
                        R = o * f;
                    c[h + 0] = (1 - (v + g)) * s, c[h + 1] = (T + R) * s, c[h + 2] = (p - S) * s, c[h + 3] = 0,
                        c[h + 4] = (T - R) * l, c[h + 5] = (1 - (m + g)) * l, c[h + 6] = (E + y) * l, c[h + 7] = 0,
                        c[h + 8] = (p + S) * u, c[h + 9] = (E - y) * u, c[h + 10] = (1 - (m + v)) * u, c[h + 11] = 0,
                        c[h + 12] = e, c[h + 13] = t, c[h + 14] = r, c[h + 15] = 1;
                }
            }, {
                key: "transformVector3ArrayToVector3ArrayCoordinate",
                value: function(e, t, r, n, i) {
                    var a = e[t + 0],
                        o = e[t + 1],
                        s = e[t + 2],
                        l = r.elements,
                        u = a * l[3] + o * l[7] + s * l[11] + l[15];
                    n[i] = a * l[0] + o * l[4] + s * l[8] + l[12] / u, n[i + 1] = a * l[1] + o * l[5] + s * l[9] + l[13] / u,
                        n[i + 2] = a * l[2] + o * l[6] + s * l[10] + l[14] / u;
                }
            }, {
                key: "transformVector3ArrayToVector3ArrayNormal",
                value: function(e, t, r, n, i) {
                    var a = e[t + 0],
                        o = e[t + 1],
                        s = e[t + 2],
                        l = r.elements;
                    n[i] = a * l[0] + o * l[4] + s * l[8], n[i + 1] = a * l[1] + o * l[5] + s * l[9],
                        n[i + 2] = a * l[2] + o * l[6] + s * l[10];
                }
            }, {
                key: "transformLightingMapTexcoordArray",
                value: function(e, t, r, n, i) {
                    n[i + 0] = e[t + 0] * r.x + r.z, n[i + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w);
                }
            }, {
                key: "getURLVerion",
                value: function(e) {
                    var t = e.indexOf("?");
                    return t >= 0 ? e.substr(t) : null;
                }
            }, {
                key: "_createAffineTransformationArray",
                value: function(e, t, r, n) {
                    var i = t.x,
                        a = t.y,
                        o = t.z,
                        s = t.w,
                        l = i + i,
                        u = a + a,
                        c = o + o,
                        h = i * l,
                        _ = i * u,
                        d = i * c,
                        f = a * u,
                        m = a * c,
                        T = o * c,
                        p = s * l,
                        v = s * u,
                        E = s * c,
                        g = r.x,
                        y = r.y,
                        S = r.z;
                    n[0] = (1 - (f + T)) * g, n[1] = (_ + E) * g, n[2] = (d - v) * g, n[3] = 0, n[4] = (_ - E) * y,
                        n[5] = (1 - (h + T)) * y, n[6] = (m + p) * y, n[7] = 0, n[8] = (d + v) * S, n[9] = (m - p) * S,
                        n[10] = (1 - (h + f)) * S, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1;
                }
            }, {
                key: "_mulMatrixArray",
                value: function(e, t, r, n, i) {
                    var a = t,
                        o = e,
                        s = n,
                        l = a[r],
                        u = a[r + 1],
                        c = a[r + 2],
                        h = a[r + 3],
                        _ = a[r + 4],
                        d = a[r + 5],
                        f = a[r + 6],
                        m = a[r + 7],
                        T = a[r + 8],
                        p = a[r + 9],
                        v = a[r + 10],
                        E = a[r + 11],
                        g = a[r + 12],
                        y = a[r + 13],
                        S = a[r + 14],
                        R = a[r + 15],
                        C = o[0],
                        M = o[1],
                        x = o[2],
                        D = o[3],
                        A = o[4],
                        L = o[5],
                        I = o[6],
                        O = o[7],
                        P = o[8],
                        N = o[9],
                        b = o[10],
                        k = o[11],
                        V = o[12],
                        B = o[13],
                        w = o[14],
                        F = o[15];
                    s[i] = l * C + u * A + c * P + h * V, s[i + 1] = l * M + u * L + c * N + h * B,
                        s[i + 2] = l * x + u * I + c * b + h * w, s[i + 3] = l * D + u * O + c * k + h * F,
                        s[i + 4] = _ * C + d * A + f * P + m * V, s[i + 5] = _ * M + d * L + f * N + m * B,
                        s[i + 6] = _ * x + d * I + f * b + m * w, s[i + 7] = _ * D + d * O + f * k + m * F,
                        s[i + 8] = T * C + p * A + v * P + E * V, s[i + 9] = T * M + p * L + v * N + E * B,
                        s[i + 10] = T * x + p * I + v * b + E * w, s[i + 11] = T * D + p * O + v * k + E * F,
                        s[i + 12] = g * C + y * A + S * P + R * V, s[i + 13] = g * M + y * L + S * N + R * B,
                        s[i + 14] = g * x + y * I + S * b + R * w, s[i + 15] = g * D + y * O + S * k + R * F;
                }
            }, {
                key: "arcTanAngle",
                value: function(e, t) {
                    return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
                }
            }, {
                key: "angleTo",
                value: function(e, t, r) {
                    o.subtract(t, e, f.TEMPVector30), o.normalize(f.TEMPVector30, f.TEMPVector30), r.x = Math.asin(f.TEMPVector30.y),
                        r.y = Utils3D.arcTanAngle(-f.TEMPVector30.z, -f.TEMPVector30.x);
                }
            }, {
                key: "transformQuat",
                value: function(e, t, r) {
                    var n = t,
                        i = e.x,
                        a = e.y,
                        o = e.z,
                        s = n[0],
                        l = n[1],
                        u = n[2],
                        c = n[3],
                        h = c * i + l * o - u * a,
                        _ = c * a + u * i - s * o,
                        d = c * o + s * a - l * i,
                        f = -s * i - l * a - u * o;
                    r.x = h * c + f * -s + _ * -u - d * -l, r.y = _ * c + f * -l + d * -s - h * -u,
                        r.z = d * c + f * -u + h * -l - _ * -s;
                }
            }, {
                key: "quaternionWeight",
                value: function(e, t, r) {
                    r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w;
                }
            }, {
                key: "quaternionConjugate",
                value: function(e, t) {
                    t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
                }
            }, {
                key: "scaleWeight",
                value: function(e, t, r) {
                    var n = e.x,
                        i = e.y,
                        a = e.z;
                    r.x = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t), r.y = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t),
                        r.z = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t);
                }
            }, {
                key: "scaleBlend",
                value: function(e, t, r, n) {
                    var i = Utils3D._tempVector3_0,
                        a = Utils3D._tempVector3_1;
                    Utils3D.scaleWeight(e, 1 - r, i), Utils3D.scaleWeight(t, r, a);
                    var o = r > .5 ? t : e;
                    n.x = o.x > 0 ? Math.abs(i.x * a.x) : -Math.abs(i.x * a.x), n.y = o.y > 0 ? Math.abs(i.y * a.y) : -Math.abs(i.y * a.y),
                        n.z = o.z > 0 ? Math.abs(i.z * a.z) : -Math.abs(i.z * a.z);
                }
            }, {
                key: "matrix4x4MultiplyFFF",
                value: function(e, t, r) {
                    var n, i, a, o, s;
                    if (r === t)
                        for (t = new Float32Array(16), n = 0; n < 16; ++n) t[n] = r[n];
                    var l = t[0],
                        u = t[1],
                        c = t[2],
                        h = t[3],
                        _ = t[4],
                        d = t[5],
                        f = t[6],
                        m = t[7],
                        T = t[8],
                        p = t[9],
                        v = t[10],
                        E = t[11],
                        g = t[12],
                        y = t[13],
                        S = t[14],
                        R = t[15];
                    for (n = 0; n < 4; n++) i = e[n], a = e[n + 4], o = e[n + 8], s = e[n + 12], r[n] = i * l + a * u + o * c + s * h,
                        r[n + 4] = i * _ + a * d + o * f + s * m, r[n + 8] = i * T + a * p + o * v + s * E,
                        r[n + 12] = i * g + a * y + o * S + s * R;
                }
            }, {
                key: "matrix4x4MultiplyFFFForNative",
                value: function(e, r, n) {
                    t.LayaGL.instance.matrix4x4Multiply(e, r, n);
                }
            }, {
                key: "matrix4x4MultiplyMFM",
                value: function(e, t, r) {
                    Utils3D.matrix4x4MultiplyFFF(e.elements, t, r.elements);
                }
            }, {
                key: "_buildTexture2D",
                value: function(e, r, n, i) {
                    var a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                        o = new t.Texture2D(e, r, n, a, !0);
                    return o.anisoLevel = 1, o.filterMode = t.FilterMode.Point, S._generateTexture2D(o, e, r, i),
                        o;
                }
            }, {
                key: "_drawBound",
                value: function(e, t, r) {
                    e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
                    var n = Utils3D._tempVector3_0,
                        i = Utils3D._tempVector3_1,
                        a = t.min,
                        o = t.max;
                    n.setValue(a.x, a.y, a.z), i.setValue(o.x, a.y, a.z), e.addLine(n, i, r, r), n.setValue(a.x, a.y, a.z),
                        i.setValue(a.x, a.y, o.z), e.addLine(n, i, r, r), n.setValue(o.x, a.y, a.z), i.setValue(o.x, a.y, o.z),
                        e.addLine(n, i, r, r), n.setValue(a.x, a.y, o.z), i.setValue(o.x, a.y, o.z), e.addLine(n, i, r, r),
                        n.setValue(a.x, a.y, a.z), i.setValue(a.x, o.y, a.z), e.addLine(n, i, r, r), n.setValue(a.x, a.y, o.z),
                        i.setValue(a.x, o.y, o.z), e.addLine(n, i, r, r), n.setValue(o.x, a.y, a.z), i.setValue(o.x, o.y, a.z),
                        e.addLine(n, i, r, r), n.setValue(o.x, a.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(n, i, r, r),
                        n.setValue(a.x, o.y, a.z), i.setValue(o.x, o.y, a.z), e.addLine(n, i, r, r), n.setValue(a.x, o.y, a.z),
                        i.setValue(a.x, o.y, o.z), e.addLine(n, i, r, r), n.setValue(o.x, o.y, a.z), i.setValue(o.x, o.y, o.z),
                        e.addLine(n, i, r, r), n.setValue(a.x, o.y, o.z), i.setValue(o.x, o.y, o.z), e.addLine(n, i, r, r);
                }
            }, {
                key: "_getHierarchyPath",
                value: function(e, t, r) {
                    r.length = 0;
                    for (var n = t; n !== e;) {
                        var i = n._parent;
                        if (!i) return null;
                        r.push(i.getChildIndex(n)), n = i;
                    }
                    return r;
                }
            }, {
                key: "_getNodeByHierarchyPath",
                value: function(e, t) {
                    for (var r = e, n = t.length - 1; n >= 0; n--) r = r.getChildAt(t[n]);
                    return r;
                }
            }]), Utils3D;
        }();
    R._tempVector3_0 = new o(), R._tempVector3_1 = new o(), R._tempArray16_0 = new Float32Array(16),
        R._tempArray16_1 = new Float32Array(16), R._tempArray16_2 = new Float32Array(16),
        R._tempArray16_3 = new Float32Array(16), R._compIdToNode = new Object();
    var C = function(e) {
        function AnimationClip() {
            var e;
            return _classCallCheck(this, AnimationClip), (e = _possibleConstructorReturn(this, _getPrototypeOf(AnimationClip).call(this)))._nodes = new g(),
                e._animationEvents = [], e;
        }
        return _inherits(AnimationClip, t.Resource), _createClass(AnimationClip, [{
            key: "duration",
            value: function() {
                return this._duration;
            }
        }, {
            key: "_hermiteInterpolate",
            value: function(e, t, r, n) {
                var i = e.outTangent,
                    a = t.inTangent;
                if (Number.isFinite(i) && Number.isFinite(a)) {
                    var o = r * r,
                        s = o * r,
                        l = s - 2 * o + r,
                        u = s - o,
                        c = -2 * s + 3 * o;
                    return (2 * s - 3 * o + 1) * e.value + l * i * n + u * a * n + c * t.value;
                }
                return e.value;
            }
        }, {
            key: "_hermiteInterpolateVector3",
            value: function(e, t, r, n, i) {
                var a = e.value,
                    o = e.outTangent,
                    s = t.value,
                    l = t.inTangent,
                    u = r * r,
                    c = u * r,
                    h = 2 * c - 3 * u + 1,
                    _ = c - 2 * u + r,
                    d = c - u,
                    f = -2 * c + 3 * u,
                    m = o.x,
                    T = l.x;
                Number.isFinite(m) && Number.isFinite(T) ? i.x = h * a.x + _ * m * n + d * T * n + f * s.x : i.x = a.x,
                    m = o.y, T = l.y, Number.isFinite(m) && Number.isFinite(T) ? i.y = h * a.y + _ * m * n + d * T * n + f * s.y : i.y = a.y,
                    m = o.z, T = l.z, Number.isFinite(m) && Number.isFinite(T) ? i.z = h * a.z + _ * m * n + d * T * n + f * s.z : i.z = a.z;
            }
        }, {
            key: "_hermiteInterpolateQuaternion",
            value: function(e, t, r, n, i) {
                var a = e.value,
                    o = e.outTangent,
                    s = t.value,
                    l = t.inTangent,
                    u = r * r,
                    c = u * r,
                    h = 2 * c - 3 * u + 1,
                    _ = c - 2 * u + r,
                    d = c - u,
                    f = -2 * c + 3 * u,
                    m = o.x,
                    T = l.x;
                Number.isFinite(m) && Number.isFinite(T) ? i.x = h * a.x + _ * m * n + d * T * n + f * s.x : i.x = a.x,
                    m = o.y, T = l.y, Number.isFinite(m) && Number.isFinite(T) ? i.y = h * a.y + _ * m * n + d * T * n + f * s.y : i.y = a.y,
                    m = o.z, T = l.z, Number.isFinite(m) && Number.isFinite(T) ? i.z = h * a.z + _ * m * n + d * T * n + f * s.z : i.z = a.z,
                    m = o.w, T = l.w, Number.isFinite(m) && Number.isFinite(T) ? i.w = h * a.w + _ * m * n + d * T * n + f * s.w : i.w = a.w;
            }
        }, {
            key: "_evaluateClipDatasRealTime",
            value: function(e, t, r, n, i, a) {
                for (var o = 0, s = e.count; o < s; o++) {
                    var l, u = e.getNodeByIndex(o),
                        c = u.type,
                        h = u._keyFrames,
                        _ = h.length,
                        d = r[o];
                    if (i)
                        for (-1 !== d && t < h[d].time && (d = -1, r[o] = d), l = d + 1; l < _ && !(h[l].time > t);) d++,
                            l++, r[o] = d;
                    else
                        for ((l = d + 1) !== _ && t > h[l].time && (d = _ - 1, r[o] = d),
                            l = d + 1; d > -1 && !(h[d].time < t);) d--, l--, r[o] = d;
                    var m = l === _;
                    switch (c) {
                        case 0:
                            if (-1 !== d) {
                                var T = h[d];
                                if (m) a[o] = T.value;
                                else {
                                    var p, v = h[l],
                                        E = v.time - T.time;
                                    p = 0 !== E ? (t - T.time) / E : 0, a[o] = this._hermiteInterpolate(T, v, p, E);
                                }
                            } else a[o] = h[0].value;
                            n && (a[o] = a[o] - h[0].value);
                            break;

                        case 1:
                        case 4:
                            var g = a[o];
                            if (this._evaluateFrameNodeVector3DatasRealTime(h, d, m, t, g), n) {
                                var y = h[0].value;
                                g.x -= y.x, g.y -= y.y, g.z -= y.z;
                            }
                            break;

                        case 2:
                            var S = a[o];
                            if (this._evaluateFrameNodeQuaternionDatasRealTime(h, d, m, t, S), n) {
                                var C = AnimationClip._tempQuaternion0,
                                    M = h[0].value;
                                R.quaternionConjugate(M, C), f.multiply(C, S, S);
                            }
                            break;

                        case 3:
                            g = a[o], this._evaluateFrameNodeVector3DatasRealTime(h, d, m, t, g), n && (y = h[0].value,
                                g.x /= y.x, g.y /= y.y, g.z /= y.z);
                            break;

                        default:
                            throw "AnimationClip:unknown node type.";
                    }
                }
            }
        }, {
            key: "_evaluateClipDatasRealTimeForNative",
            value: function(e, r, n, i) {
                t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, n, i);
            }
        }, {
            key: "_evaluateFrameNodeVector3DatasRealTime",
            value: function(e, t, r, n, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (r) {
                        var o = a.value;
                        i.x = o.x, i.y = o.y, i.z = o.z;
                    } else {
                        var s, l = e[t + 1],
                            u = a.time,
                            c = l.time - u;
                        s = 0 !== c ? (n - u) / c : 0, this._hermiteInterpolateVector3(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x, i.y = h.y, i.z = h.z;
                }
            }
        }, {
            key: "_evaluateFrameNodeQuaternionDatasRealTime",
            value: function(e, t, r, n, i) {
                if (-1 !== t) {
                    var a = e[t];
                    if (r) {
                        var o = a.value;
                        i.x = o.x, i.y = o.y, i.z = o.z, i.w = o.w;
                    } else {
                        var s, l = e[t + 1],
                            u = a.time,
                            c = l.time - u;
                        s = 0 !== c ? (n - u) / c : 0, this._hermiteInterpolateQuaternion(a, l, s, c, i);
                    }
                } else {
                    var h = e[0].value;
                    i.x = h.x, i.y = h.y, i.z = h.z, i.w = h.w;
                }
            }
        }, {
            key: "_binarySearchEventIndex",
            value: function(e) {
                for (var t, r = 0, n = this._animationEvents.length - 1; r <= n;) {
                    t = Math.floor((r + n) / 2);
                    var i = this._animationEvents[t].time;
                    if (i == e) return t;
                    i > e ? n = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "addEvent",
            value: function(e) {
                var t = this._binarySearchEventIndex(e.time);
                this._animationEvents.splice(t, 0, e);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._nodes = null, this._nodesMap = null;
            }
        }], [{
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var r = new AnimationClip(),
                    n = new t.Byte(e),
                    i = n.readUTFString();
                switch (i) {
                    case "LAYAANIMATION:03":
                        p.parse(r, n);
                        break;

                    case "LAYAANIMATION:04":
                    case "LAYAANIMATION:COMPRESSION_04":
                        E.parse(r, n, i);
                        break;

                    default:
                        throw "unknown animationClip version.";
                }
                return r;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, AnimationClip.ANIMATIONCLIP);
            }
        }]), AnimationClip;
    }();
    C.ANIMATIONCLIP = "ANIMATIONCLIP", C._tempQuaternion0 = new f();
    var M = function() {
            function AnimatorPlayState() {
                _classCallCheck(this, AnimatorPlayState), this._currentState = null;
            }
            return _createClass(AnimatorPlayState, [{
                key: "_resetPlayState",
                value: function(e) {
                    this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0,
                        this._lastIsFront = !0;
                }
            }, {
                key: "_cloneTo",
                value: function(e) {
                    e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime,
                        e._normalizedTime = this._normalizedTime, e._normalizedPlayTime = this._normalizedPlayTime,
                        e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
                }
            }, {
                key: "normalizedTime",
                get: function() {
                    return this._normalizedTime;
                }
            }, {
                key: "duration",
                get: function() {
                    return this._duration;
                }
            }, {
                key: "animatorState",
                get: function() {
                    return this._currentState;
                }
            }]), AnimatorPlayState;
        }(),
        x = function() {
            function AnimatorControllerLayer(e) {
                _classCallCheck(this, AnimatorControllerLayer), this._defaultState = null, this._referenceCount = 0,
                    this._playType = -1, this._crossDuration = -1, this._crossMark = 0, this._crossNodesOwnersCount = 0,
                    this._crossNodesOwners = [], this._crossNodesOwnersIndicesMap = {}, this._srcCrossClipNodeIndices = [],
                    this._destCrossClipNodeIndices = [], this._statesMap = {}, this._states = [], this._playStateInfo = new M(),
                    this._crossPlayStateInfo = new M(), this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE,
                    this.defaultWeight = 1, this.playOnWake = !0, this.name = e;
            }
            return _createClass(AnimatorControllerLayer, [{
                key: "_removeClip",
                value: function(e, t, r, n) {
                    var i = n._clip,
                        a = e[r];
                    if (e.splice(r, 1), delete t[n.name], this._animator) {
                        var o = i._nodes,
                            s = a._nodeOwners;
                        i._removeReference();
                        for (var l = 0, u = o.count; l < u; l++) this._animator._removeKeyframeNodeOwner(s, o.getNodeByIndex(l));
                    }
                }
            }, {
                key: "_getReferenceCount",
                value: function() {
                    return this._referenceCount;
                }
            }, {
                key: "_addReference",
                value: function() {
                    for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, r = this._states.length; t < r; t++) this._states[t]._addReference(e);
                    this._referenceCount += e;
                }
            }, {
                key: "_removeReference",
                value: function() {
                    for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = 0, r = this._states.length; t < r; t++) this._states[t]._removeReference(e);
                    this._referenceCount -= e;
                }
            }, {
                key: "_clearReference",
                value: function() {
                    this._removeReference(-this._referenceCount);
                }
            }, {
                key: "getCurrentPlayState",
                value: function() {
                    return this._playStateInfo;
                }
            }, {
                key: "getAnimatorState",
                value: function(e) {
                    var t = this._statesMap[e];
                    return t || null;
                }
            }, {
                key: "addState",
                value: function(e) {
                    var t = e.name;
                    if (this._statesMap[t]) throw "AnimatorControllerLayer:this stat's name has exist.";
                    this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip._addReference(),
                        this._animator._getOwnersByClip(e));
                }
            }, {
                key: "removeState",
                value: function(e) {
                    for (var t = this._states, r = -1, n = 0, i = t.length; n < i; n++)
                        if (t[n] === e) {
                            r = n;
                            break;
                        } -
                    1 !== r && this._removeClip(t, this._statesMap, r, e);
                }
            }, {
                key: "destroy",
                value: function() {
                    this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null,
                        this._crossPlayStateInfo = null, this._defaultState = null;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight,
                        t.playOnWake = this.playOnWake;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new AnimatorControllerLayer(this.name);
                    return this.cloneTo(e), e;
                }
            }, {
                key: "defaultState",
                get: function() {
                    return this._defaultState;
                },
                set: function(e) {
                    this._defaultState = e, this._statesMap[e.name] = e;
                }
            }]), AnimatorControllerLayer;
        }();
    x.BLENDINGMODE_OVERRIDE = 0, x.BLENDINGMODE_ADDTIVE = 1;
    var D = function() {
        function ConchVector4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
            _classCallCheck(this, ConchVector4);
            var i = this.elements = new Float32Array(4);
            i[0] = e, i[1] = t, i[2] = r, i[3] = n;
        }
        return _createClass(ConchVector4, [{
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                    this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements,
                    r = this.elements;
                t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "length",
            value: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "lerp",
            value: function(e, t, r, n) {
                var i = n.elements,
                    a = e.elements,
                    o = t.elements,
                    s = a[0],
                    l = a[1],
                    u = a[2],
                    c = a[3];
                i[0] = s + r * (o[0] - s), i[1] = l + r * (o[1] - l), i[2] = u + r * (o[2] - u),
                    i[3] = c + r * (o[3] - c);
            }
        }, {
            key: "transformByM4x4",
            value: function(e, t, r) {
                var n = e.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    l = t.elements,
                    u = r.elements;
                u[0] = i * l[0] + a * l[4] + o * l[8] + s * l[12], u[1] = i * l[1] + a * l[5] + o * l[9] + s * l[13],
                    u[2] = i * l[2] + a * l[6] + o * l[10] + s * l[14], u[3] = i * l[3] + a * l[7] + o * l[11] + s * l[15];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var n = e.elements,
                    i = t.elements;
                return r.nearEqual(Math.abs(n[0]), Math.abs(i[0])) && r.nearEqual(Math.abs(n[1]), Math.abs(i[1])) && r.nearEqual(Math.abs(n[2]), Math.abs(i[2])) && r.nearEqual(Math.abs(n[3]), Math.abs(i[3]));
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = e.length();
                i > 0 && (n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = r[3] * i);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2], n[3] = i[3] + a[3];
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] - a[0], n[1] = i[1] - a[1], n[2] = i[2] - a[2], n[3] = i[3] - a[3];
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] * a[0], n[1] = i[1] * a[1], n[2] = i[2] * a[2], n[3] = i[3] * a[3];
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements;
                n[0] = i[0] * t, n[1] = i[1] * t, n[2] = i[2] * t, n[3] = i[3] * t;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.elements,
                    a = i[0],
                    o = i[1],
                    s = i[2],
                    l = i[3],
                    u = t.elements,
                    c = u[0],
                    h = u[1],
                    _ = u[2],
                    d = u[3],
                    f = r.elements,
                    m = f[0],
                    T = f[1],
                    p = f[2],
                    v = f[3],
                    E = n.elements;
                a = (a = a > m ? m : a) < c ? c : a, o = (o = o > T ? T : o) < h ? h : o, s = (s = s > p ? p : s) < _ ? _ : s,
                    l = (l = l > v ? v : l) < d ? d : l, E[0] = a, E[1] = o, E[2] = s, E[3] = l;
            }
        }, {
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = r[0] - n[0],
                    a = r[1] - n[1],
                    o = r[2] - n[2],
                    s = r[3] - n[3];
                return i * i + a * a + o * o + s * s;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = r[0] - n[0],
                    a = r[1] - n[1],
                    o = r[2] - n[2],
                    s = r[3] - n[3];
                return Math.sqrt(i * i + a * a + o * o + s * s);
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements;
                return r[0] * n[0] + r[1] * n[1] + r[2] * n[2] + r[3] * n[3];
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = Math.min(i[0], a[0]), n[1] = Math.min(i[1], a[1]), n[2] = Math.min(i[2], a[2]),
                    n[3] = Math.min(i[3], a[3]);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = Math.max(i[0], a[0]), n[1] = Math.max(i[1], a[1]), n[2] = Math.max(i[2], a[2]),
                    n[3] = Math.max(i[3], a[3]);
            }
        }]), ConchVector4;
    }();
    D.ZERO = new D(), D.ONE = new D(1, 1, 1, 1), D.UnitX = new D(1, 0, 0, 0), D.UnitY = new D(0, 1, 0, 0),
        D.UnitZ = new D(0, 0, 1, 0), D.UnitW = new D(0, 0, 0, 1);
    var A = function() {
        function ConchVector3() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
            _classCallCheck(this, ConchVector3), e = i || new Float32Array(3), this.elements = e,
                e[0] = t, e[1] = r, e[2] = n;
        }
        return _createClass(ConchVector3, [{
            key: "setValue",
            value: function(e, t, r) {
                this.elements[0] = e, this.elements[1] = t, this.elements[2] = r;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e.elements,
                    r = this.elements;
                t[0] = r[0], t[1] = r[1], t[2] = r[2];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchVector3();
                return this.cloneTo(e), e;
            }
        }, {
            key: "toDefault",
            value: function() {
                this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }], [{
            key: "distanceSquared",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = r[0] - n[0],
                    a = r[1] - n[1],
                    o = r[2] - n[2];
                return i * i + a * a + o * o;
            }
        }, {
            key: "distance",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = r[0] - n[0],
                    a = r[1] - n[1],
                    o = r[2] - n[2];
                return Math.sqrt(i * i + a * a + o * o);
            }
        }, {
            key: "min",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = Math.min(i[0], a[0]), n[1] = Math.min(i[1], a[1]), n[2] = Math.min(i[2], a[2]);
            }
        }, {
            key: "max",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = Math.max(i[0], a[0]), n[1] = Math.max(i[1], a[1]), n[2] = Math.max(i[2], a[2]);
            }
        }, {
            key: "transformQuat",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements,
                    o = i[0],
                    s = i[1],
                    l = i[2],
                    u = a[0],
                    c = a[1],
                    h = a[2],
                    _ = a[3],
                    d = _ * o + c * l - h * s,
                    f = _ * s + h * o - u * l,
                    m = _ * l + u * s - c * o,
                    T = -u * o - c * s - h * l;
                n[0] = d * _ + T * -u + f * -h - m * -c, n[1] = f * _ + T * -c + m * -u - d * -h,
                    n[2] = m * _ + T * -h + d * -c - f * -u;
            }
        }, {
            key: "scalarLength",
            value: function(e) {
                var t = e.elements,
                    r = t[0],
                    n = t[1],
                    i = t[2];
                return Math.sqrt(r * r + n * n + i * i);
            }
        }, {
            key: "scalarLengthSquared",
            value: function(e) {
                var t = e.elements,
                    r = t[0],
                    n = t[1],
                    i = t[2];
                return r * r + n * n + i * i;
            }
        }, {
            key: "normalize",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements,
                    i = r[0],
                    a = r[1],
                    o = r[2],
                    s = i * i + a * a + o * o;
                s > 0 && (s = 1 / Math.sqrt(s), n[0] = r[0] * s, n[1] = r[1] * s, n[2] = r[2] * s);
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] * a[0], n[1] = i[1] * a[1], n[2] = i[2] * a[2];
            }
        }, {
            key: "scale",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements;
                n[0] = i[0] * t, n[1] = i[1] * t, n[2] = i[2] * t;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                var i = n.elements,
                    a = e.elements,
                    o = t.elements,
                    s = a[0],
                    l = a[1],
                    u = a[2];
                i[0] = s + r * (o[0] - s), i[1] = l + r * (o[1] - l), i[2] = u + r * (o[2] - u);
            }
        }, {
            key: "transformV3ToV3",
            value: function(e, t, r) {
                var n = ConchVector3._tempVector4;
                ConchVector3.transformV3ToV4(e, t, n);
                var i = n.elements,
                    a = r.elements;
                a[0] = i[0], a[1] = i[1], a[2] = i[2];
            }
        }, {
            key: "transformV3ToV4",
            value: function(e, t, r) {
                var n = e.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = t.elements,
                    l = r.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8] + s[12], l[1] = i * s[1] + a * s[5] + o * s[9] + s[13],
                    l[2] = i * s[2] + a * s[6] + o * s[10] + s[14], l[3] = i * s[3] + a * s[7] + o * s[11] + s[15];
            }
        }, {
            key: "TransformNormal",
            value: function(e, t, r) {
                var n = e.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = t.elements,
                    l = r.elements;
                l[0] = i * s[0] + a * s[4] + o * s[8], l[1] = i * s[1] + a * s[5] + o * s[9], l[2] = i * s[2] + a * s[6] + o * s[10];
            }
        }, {
            key: "transformCoordinate",
            value: function(e, t, r) {
                var n = e.elements,
                    i = n[0],
                    a = n[1],
                    o = n[2],
                    s = t.elements,
                    l = i * s[3] + a * s[7] + o * s[11] + s[15],
                    u = r.elements;
                u[0] = i * s[0] + a * s[4] + o * s[8] + s[12] / l, u[1] = i * s[1] + a * s[5] + o * s[9] + s[13] / l,
                    u[2] = i * s[2] + a * s[6] + o * s[10] + s[14] / l;
            }
        }, {
            key: "Clamp",
            value: function(e, t, r, n) {
                var i = e.elements,
                    a = i[0],
                    o = i[1],
                    s = i[2],
                    l = t.elements,
                    u = l[0],
                    c = l[1],
                    h = l[2],
                    _ = r.elements,
                    d = _[0],
                    f = _[1],
                    m = _[2],
                    T = n.elements;
                a = (a = a > d ? d : a) < u ? u : a, o = (o = o > f ? f : o) < c ? c : o, s = (s = s > m ? m : s) < h ? h : s,
                    T[0] = a, T[1] = o, T[2] = s;
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2];
            }
        }, {
            key: "subtract",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] - a[0], n[1] = i[1] - a[1], n[2] = i[2] - a[2];
            }
        }, {
            key: "cross",
            value: function(e, t, r) {
                var n = e.elements,
                    i = t.elements,
                    a = r.elements,
                    o = n[0],
                    s = n[1],
                    l = n[2],
                    u = i[0],
                    c = i[1],
                    h = i[2];
                a[0] = s * h - l * c, a[1] = l * u - o * h, a[2] = o * c - s * u;
            }
        }, {
            key: "dot",
            value: function(e, t) {
                var r = e.elements,
                    n = t.elements;
                return r[0] * n[0] + r[1] * n[1] + r[2] * n[2];
            }
        }, {
            key: "equals",
            value: function(e, t) {
                var n = e.elements,
                    i = t.elements;
                return r.nearEqual(n[0], i[0]) && r.nearEqual(n[1], i[1]) && r.nearEqual(n[2], i[2]);
            }
        }]), ConchVector3;
    }();
    A._tempVector4 = new D(), A.ZERO = new A(0, 0, 0), A.ONE = new A(1, 1, 1), A.NegativeUnitX = new A(-1, 0, 0),
        A.UnitX = new A(1, 0, 0), A.UnitY = new A(0, 1, 0), A.UnitZ = new A(0, 0, 1), A.ForwardRH = new A(0, 0, -1),
        A.ForwardLH = new A(0, 0, 1), A.Up = new A(0, 1, 0), A.NAN = new A(NaN, NaN, NaN);
    var L = function() {
        function Matrix4x4() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1,
                o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 0,
                s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : 0,
                l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                u = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
                c = arguments.length > 10 && void 0 !== arguments[10] ? arguments[10] : 1,
                h = arguments.length > 11 && void 0 !== arguments[11] ? arguments[11] : 0,
                _ = arguments.length > 12 && void 0 !== arguments[12] ? arguments[12] : 0,
                d = arguments.length > 13 && void 0 !== arguments[13] ? arguments[13] : 0,
                f = arguments.length > 14 && void 0 !== arguments[14] ? arguments[14] : 0,
                m = arguments.length > 15 && void 0 !== arguments[15] ? arguments[15] : 1,
                T = arguments.length > 16 && void 0 !== arguments[16] ? arguments[16] : null;
            _classCallCheck(this, Matrix4x4);
            var p = this.elements = T || new Float32Array(16);
            p[0] = e, p[1] = t, p[2] = r, p[3] = n, p[4] = i, p[5] = a, p[6] = o, p[7] = s,
                p[8] = l, p[9] = u, p[10] = c, p[11] = h, p[12] = _, p[13] = d, p[14] = f, p[15] = m;
        }
        return _createClass(Matrix4x4, [{
            key: "setRotation",
            value: function(e) {
                var t = e.x,
                    r = e.y,
                    n = e.z,
                    i = e.w,
                    a = t * t,
                    o = r * r,
                    s = n * n,
                    l = t * r,
                    u = n * i,
                    c = n * t,
                    h = r * i,
                    _ = r * n,
                    d = t * i,
                    f = this.elements;
                f[0] = 1 - 2 * (o + s), f[1] = 2 * (l + u), f[2] = 2 * (c - h), f[4] = 2 * (l - u),
                    f[5] = 1 - 2 * (s + a), f[6] = 2 * (_ + d), f[8] = 2 * (c + h), f[9] = 2 * (_ - d),
                    f[10] = 1 - 2 * (o + a);
            }
        }, {
            key: "setPosition",
            value: function(e) {
                var t = this.elements;
                t[12] = e.x, t[13] = e.y, t[14] = e.z;
            }
        }, {
            key: "getElementByRowColumn",
            value: function(e, t) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                return this.elements[4 * e + t];
            }
        }, {
            key: "setElementByRowColumn",
            value: function(e, t, r) {
                if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
                if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
                this.elements[4 * e + t] = r;
            }
        }, {
            key: "equalsOtherMatrix",
            value: function(e) {
                var t = this.elements,
                    n = e.elements;
                return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2], n[2]) && r.nearEqual(t[3], n[3]) && r.nearEqual(t[4], n[4]) && r.nearEqual(t[5], n[5]) && r.nearEqual(t[6], n[6]) && r.nearEqual(t[7], n[7]) && r.nearEqual(t[8], n[8]) && r.nearEqual(t[9], n[9]) && r.nearEqual(t[10], n[10]) && r.nearEqual(t[11], n[11]) && r.nearEqual(t[12], n[12]) && r.nearEqual(t[13], n[13]) && r.nearEqual(t[14], n[14]) && r.nearEqual(t[15], n[15]);
            }
        }, {
            key: "decomposeTransRotScale",
            value: function(e, t, r) {
                var n = Matrix4x4._tempMatrix4x4;
                return this.decomposeTransRotMatScale(e, n, r) ? (f.createFromMatrix4x4(n, t), !0) : (t.identity(), !1);
            }
        }, {
            key: "decomposeTransRotMatScale",
            value: function(e, t, n) {
                var i = this.elements,
                    a = e,
                    s = t.elements,
                    l = n;
                a.x = i[12], a.y = i[13], a.z = i[14];
                var u = i[0],
                    c = i[1],
                    h = i[2],
                    _ = i[4],
                    d = i[5],
                    f = i[6],
                    m = i[8],
                    T = i[9],
                    p = i[10],
                    v = l.x = Math.sqrt(u * u + c * c + h * h),
                    E = l.y = Math.sqrt(_ * _ + d * d + f * f),
                    g = l.z = Math.sqrt(m * m + T * T + p * p);
                if (r.isZero(v) || r.isZero(E) || r.isZero(g)) return s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[8] = s[9] = s[11] = s[12] = s[13] = s[14] = 0,
                    s[0] = s[5] = s[10] = s[15] = 1, !1;
                var y = Matrix4x4._tempVector0;
                y.x = m / g, y.y = T / g, y.z = p / g;
                var S = Matrix4x4._tempVector1;
                S.x = u / v, S.y = c / v, S.z = h / v;
                var R = Matrix4x4._tempVector2;
                o.cross(y, S, R);
                var C = Matrix4x4._tempVector1;
                return o.cross(R, y, C), s[3] = s[7] = s[11] = s[12] = s[13] = s[14] = 0, s[15] = 1,
                    s[0] = C.x, s[1] = C.y, s[2] = C.z, s[4] = R.x, s[5] = R.y, s[6] = R.z, s[8] = y.x,
                    s[9] = y.y, s[10] = y.z, s[0] * u + s[1] * c + s[2] * h < 0 && (l.x = -v), s[4] * _ + s[5] * d + s[6] * f < 0 && (l.y = -E),
                    s[8] * m + s[9] * T + s[10] * p < 0 && (l.z = -g), !0;
            }
        }, {
            key: "decomposeYawPitchRoll",
            value: function(e) {
                var t = Math.asin(-this.elements[9]);
                e.y = t, Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]),
                    e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]),
                    e.x = 0);
            }
        }, {
            key: "normalize",
            value: function() {
                var e = this.elements,
                    t = e[0],
                    r = e[1],
                    n = e[2],
                    i = Math.sqrt(t * t + r * r + n * n);
                if (!i) return e[0] = 0, e[1] = 0, void(e[2] = 0);
                1 != i && (i = 1 / i, e[0] = t * i, e[1] = r * i, e[2] = n * i);
            }
        }, {
            key: "transpose",
            value: function() {
                var e, t;
                return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8],
                    e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7],
                    e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = this.elements,
                    r = e.elements,
                    n = t[0],
                    i = t[1],
                    a = t[2],
                    o = t[3],
                    s = t[4],
                    l = t[5],
                    u = t[6],
                    c = t[7],
                    h = t[8],
                    _ = t[9],
                    d = t[10],
                    f = t[11],
                    m = t[12],
                    T = t[13],
                    p = t[14],
                    v = t[15],
                    E = n * l - i * s,
                    g = n * u - a * s,
                    y = n * c - o * s,
                    S = i * u - a * l,
                    R = i * c - o * l,
                    C = a * c - o * u,
                    M = h * T - _ * m,
                    x = h * p - d * m,
                    D = h * v - f * m,
                    A = _ * p - d * T,
                    L = _ * v - f * T,
                    I = d * v - f * p,
                    O = E * I - g * L + y * A + S * D - R * x + C * M;
                0 !== Math.abs(O) && (O = 1 / O, r[0] = (l * I - u * L + c * A) * O, r[1] = (a * L - i * I - o * A) * O,
                    r[2] = (T * C - p * R + v * S) * O, r[3] = (d * R - _ * C - f * S) * O, r[4] = (u * D - s * I - c * x) * O,
                    r[5] = (n * I - a * D + o * x) * O, r[6] = (p * y - m * C - v * g) * O, r[7] = (h * C - d * y + f * g) * O,
                    r[8] = (s * L - l * D + c * M) * O, r[9] = (i * D - n * L - o * M) * O, r[10] = (m * R - T * y + v * E) * O,
                    r[11] = (_ * y - h * R - f * E) * O, r[12] = (l * x - s * A - u * M) * O, r[13] = (n * A - i * x + a * M) * O,
                    r[14] = (T * g - m * S - p * E) * O, r[15] = (h * S - _ * g + d * E) * O);
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                    e[0] = e[5] = e[10] = e[15] = 1;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n;
                if ((r = this.elements) !== (n = e.elements))
                    for (t = 0; t < 16; ++t) n[t] = r[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Matrix4x4();
                return this.cloneTo(e), e;
            }
        }, {
            key: "getTranslationVector",
            value: function(e) {
                var t = this.elements;
                e.x = t[12], e.y = t[13], e.z = t[14];
            }
        }, {
            key: "setTranslationVector",
            value: function(e) {
                var t = this.elements,
                    r = e;
                t[12] = r.x, t[13] = r.y, t[14] = r.z;
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "setForward",
            value: function(e) {
                var t = this.elements;
                t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
            }
        }], [{
            key: "createRotationX",
            value: function(e, t) {
                var r = t.elements,
                    n = Math.sin(e),
                    i = Math.cos(e);
                r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0, r[0] = r[15] = 1,
                    r[5] = r[10] = i, r[6] = n, r[9] = -n;
            }
        }, {
            key: "createRotationY",
            value: function(e, t) {
                var r = t.elements,
                    n = Math.sin(e),
                    i = Math.cos(e);
                r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[5] = r[15] = 1,
                    r[0] = r[10] = i, r[2] = -n, r[8] = n;
            }
        }, {
            key: "createRotationZ",
            value: function(e, t) {
                var r = t.elements,
                    n = Math.sin(e),
                    i = Math.cos(e);
                r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[10] = r[15] = 1,
                    r[0] = r[5] = i, r[1] = n, r[4] = -n;
            }
        }, {
            key: "createRotationYawPitchRoll",
            value: function(e, t, r, n) {
                f.createFromYawPitchRoll(e, t, r, Matrix4x4._tempQuaternion), Matrix4x4.createRotationQuaternion(Matrix4x4._tempQuaternion, n);
            }
        }, {
            key: "createRotationAxis",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = Math.cos(t),
                    s = Math.sin(t),
                    l = n * n,
                    u = i * i,
                    c = a * a,
                    h = n * i,
                    _ = n * a,
                    d = i * a,
                    f = r.elements;
                f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + o * (1 - l),
                    f[1] = h - o * h + s * a, f[2] = _ - o * _ - s * i, f[4] = h - o * h - s * a, f[5] = u + o * (1 - u),
                    f[6] = d - o * d + s * n, f[8] = _ - o * _ + s * i, f[9] = d - o * d - s * n, f[10] = c + o * (1 - c);
            }
        }, {
            key: "createRotationQuaternion",
            value: function(e, t) {
                var r = t.elements,
                    n = e.x,
                    i = e.y,
                    a = e.z,
                    o = e.w,
                    s = n * n,
                    l = i * i,
                    u = a * a,
                    c = n * i,
                    h = a * o,
                    _ = a * n,
                    d = i * o,
                    f = i * a,
                    m = n * o;
                r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0, r[15] = 1, r[0] = 1 - 2 * (l + u),
                    r[1] = 2 * (c + h), r[2] = 2 * (_ - d), r[4] = 2 * (c - h), r[5] = 1 - 2 * (u + s),
                    r[6] = 2 * (f + m), r[8] = 2 * (_ + d), r[9] = 2 * (f - m), r[10] = 1 - 2 * (l + s);
            }
        }, {
            key: "createTranslate",
            value: function(e, t) {
                var r = t.elements;
                r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0, r[0] = r[5] = r[10] = r[15] = 1,
                    r[12] = e.x, r[13] = e.y, r[14] = e.z;
            }
        }, {
            key: "createScaling",
            value: function(e, t) {
                var r = t.elements;
                r[0] = e.x, r[5] = e.y, r[10] = e.z, r[1] = r[4] = r[8] = r[12] = r[9] = r[13] = r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0,
                    r[15] = 1;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = t.elements,
                    i = e.elements,
                    a = r.elements,
                    o = n[0],
                    s = n[1],
                    l = n[2],
                    u = n[3],
                    c = n[4],
                    h = n[5],
                    _ = n[6],
                    d = n[7],
                    f = n[8],
                    m = n[9],
                    T = n[10],
                    p = n[11],
                    v = n[12],
                    E = n[13],
                    g = n[14],
                    y = n[15],
                    S = i[0],
                    R = i[1],
                    C = i[2],
                    M = i[3],
                    x = i[4],
                    D = i[5],
                    A = i[6],
                    L = i[7],
                    I = i[8],
                    O = i[9],
                    P = i[10],
                    N = i[11],
                    b = i[12],
                    k = i[13],
                    V = i[14],
                    B = i[15];
                a[0] = o * S + s * x + l * I + u * b, a[1] = o * R + s * D + l * O + u * k, a[2] = o * C + s * A + l * P + u * V,
                    a[3] = o * M + s * L + l * N + u * B, a[4] = c * S + h * x + _ * I + d * b, a[5] = c * R + h * D + _ * O + d * k,
                    a[6] = c * C + h * A + _ * P + d * V, a[7] = c * M + h * L + _ * N + d * B, a[8] = f * S + m * x + T * I + p * b,
                    a[9] = f * R + m * D + T * O + p * k, a[10] = f * C + m * A + T * P + p * V, a[11] = f * M + m * L + T * N + p * B,
                    a[12] = v * S + E * x + g * I + y * b, a[13] = v * R + E * D + g * O + y * k, a[14] = v * C + E * A + g * P + y * V,
                    a[15] = v * M + E * L + g * N + y * B;
            }
        }, {
            key: "multiplyForNative",
            value: function(e, r, n) {
                t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, n.elements);
            }
        }, {
            key: "createFromQuaternion",
            value: function(e, t) {
                var r = t.elements,
                    n = e.x,
                    i = e.y,
                    a = e.z,
                    o = e.w,
                    s = n + n,
                    l = i + i,
                    u = a + a,
                    c = n * s,
                    h = i * s,
                    _ = i * l,
                    d = a * s,
                    f = a * l,
                    m = a * u,
                    T = o * s,
                    p = o * l,
                    v = o * u;
                r[0] = 1 - _ - m, r[1] = h + v, r[2] = d - p, r[3] = 0, r[4] = h - v, r[5] = 1 - c - m,
                    r[6] = f + T, r[7] = 0, r[8] = d + p, r[9] = f - T, r[10] = 1 - c - _, r[11] = 0,
                    r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1;
            }
        }, {
            key: "createAffineTransformation",
            value: function(e, t, r, n) {
                var i = n.elements,
                    a = t.x,
                    o = t.y,
                    s = t.z,
                    l = t.w,
                    u = a + a,
                    c = o + o,
                    h = s + s,
                    _ = a * u,
                    d = a * c,
                    f = a * h,
                    m = o * c,
                    T = o * h,
                    p = s * h,
                    v = l * u,
                    E = l * c,
                    g = l * h,
                    y = r.x,
                    S = r.y,
                    R = r.z;
                i[0] = (1 - (m + p)) * y, i[1] = (d + g) * y, i[2] = (f - E) * y, i[3] = 0, i[4] = (d - g) * S,
                    i[5] = (1 - (_ + p)) * S, i[6] = (T + v) * S, i[7] = 0, i[8] = (f + E) * R, i[9] = (T - v) * R,
                    i[10] = (1 - (_ + m)) * R, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
            }
        }, {
            key: "createLookAt",
            value: function(e, t, r, n) {
                var i = n.elements,
                    a = Matrix4x4._tempVector0,
                    s = Matrix4x4._tempVector1,
                    l = Matrix4x4._tempVector2;
                o.subtract(e, t, l), o.normalize(l, l), o.cross(r, l, a), o.normalize(a, a), o.cross(l, a, s),
                    i[3] = i[7] = i[11] = 0, i[15] = 1, i[0] = a.x, i[4] = a.y, i[8] = a.z, i[1] = s.x,
                    i[5] = s.y, i[9] = s.z, i[2] = l.x, i[6] = l.y, i[10] = l.z, i[12] = -o.dot(a, e),
                    i[13] = -o.dot(s, e), i[14] = -o.dot(l, e);
            }
        }, {
            key: "createPerspective",
            value: function(e, t, r, n, i) {
                var a = 1 / Math.tan(.5 * e),
                    o = r / (a / t),
                    s = r / a;
                Matrix4x4.createPerspectiveOffCenter(-o, o, -s, s, r, n, i);
            }
        }, {
            key: "createPerspectiveOffCenter",
            value: function(e, t, r, n, i, a, o) {
                var s = o.elements,
                    l = a / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[7] = s[12] = s[13] = s[15] = 0, s[0] = 2 * i / (t - e),
                    s[5] = 2 * i / (n - r), s[8] = (e + t) / (t - e), s[9] = (n + r) / (n - r), s[10] = -l,
                    s[11] = -1, s[14] = -i * l;
            }
        }, {
            key: "createOrthoOffCenter",
            value: function(e, t, r, n, i, a, o) {
                var s = o.elements,
                    l = 1 / (a - i);
                s[1] = s[2] = s[3] = s[4] = s[6] = s[8] = s[7] = s[9] = s[11] = 0, s[15] = 1, s[0] = 2 / (t - e),
                    s[5] = 2 / (n - r), s[10] = -l, s[12] = (e + t) / (e - t), s[13] = (n + r) / (r - n),
                    s[14] = -i * l;
            }
        }, {
            key: "billboard",
            value: function(e, t, n, i, a, s) {
                o.subtract(e, t, Matrix4x4._tempVector0);
                var l = o.scalarLengthSquared(Matrix4x4._tempVector0);
                r.isZero(l) ? (o.scale(a, -1, Matrix4x4._tempVector1), Matrix4x4._tempVector1.cloneTo(Matrix4x4._tempVector0)) : o.scale(Matrix4x4._tempVector0, 1 / Math.sqrt(l), Matrix4x4._tempVector0),
                    o.cross(i, Matrix4x4._tempVector0, Matrix4x4._tempVector2), o.normalize(Matrix4x4._tempVector2, Matrix4x4._tempVector2),
                    o.cross(Matrix4x4._tempVector0, Matrix4x4._tempVector2, Matrix4x4._tempVector3);
                var u = Matrix4x4._tempVector2,
                    c = Matrix4x4._tempVector3,
                    h = Matrix4x4._tempVector0,
                    _ = e,
                    d = s.elements;
                d[0] = u.x, d[1] = u.y, d[2] = u.z, d[3] = 0, d[4] = c.x, d[5] = c.y, d[6] = c.z,
                    d[7] = 0, d[8] = h.x, d[9] = h.y, d[10] = h.z, d[11] = 0, d[12] = _.x, d[13] = _.y,
                    d[14] = _.z, d[15] = 1;
            }
        }, {
            key: "translation",
            value: function(e, t) {
                var r = t.elements;
                r[0] = r[5] = r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z;
            }
        }]), Matrix4x4;
    }();
    L._tempMatrix4x4 = new L(), L.TEMPMatrix0 = new L(), L.TEMPMatrix1 = new L(), L._tempVector0 = new o(),
        L._tempVector1 = new o(), L._tempVector2 = new o(), L._tempVector3 = new o(), L._tempQuaternion = new f(),
        L.DEFAULT = new L(), L.ZERO = new L(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    var I = function() {
        function ConchQuaternion() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            _classCallCheck(this, ConchQuaternion), (e = a || new Float32Array(4))[0] = t, e[1] = r,
                e[2] = n, e[3] = i, this.elements = e;
        }
        return _createClass(ConchQuaternion, [{
            key: "scaling",
            value: function(e, t) {
                var r = t.elements,
                    n = this.elements;
                r[0] = n[0] * e, r[1] = n[1] * e, r[2] = n[2] * e, r[3] = n[3] * e;
            }
        }, {
            key: "normalize",
            value: function(e) {
                ConchQuaternion._normalizeArray(this.elements, e.elements);
            }
        }, {
            key: "length",
            value: function() {
                var e = this.elements,
                    t = e[0],
                    r = e[1],
                    n = e[2],
                    i = e[3];
                return Math.sqrt(t * t + r * r + n * n + i * i);
            }
        }, {
            key: "rotateX",
            value: function(e, t) {
                var r = t.elements,
                    n = this.elements;
                e *= .5;
                var i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    l = Math.sin(e),
                    u = Math.cos(e);
                r[0] = i * u + s * l, r[1] = a * u + o * l, r[2] = o * u - a * l, r[3] = s * u - i * l;
            }
        }, {
            key: "rotateY",
            value: function(e, t) {
                var r = t.elements,
                    n = this.elements;
                e *= .5;
                var i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    l = Math.sin(e),
                    u = Math.cos(e);
                r[0] = i * u - o * l, r[1] = a * u + s * l, r[2] = o * u + i * l, r[3] = s * u - a * l;
            }
        }, {
            key: "rotateZ",
            value: function(e, t) {
                var r = t.elements,
                    n = this.elements;
                e *= .5;
                var i = n[0],
                    a = n[1],
                    o = n[2],
                    s = n[3],
                    l = Math.sin(e),
                    u = Math.cos(e);
                r[0] = i * u + a * l, r[1] = a * u - i * l, r[2] = o * u + s * l, r[3] = s * u - o * l;
            }
        }, {
            key: "getYawPitchRoll",
            value: function(e) {
                A.transformQuat(A.ForwardRH, this, ConchQuaternion.TEMPVector31), A.transformQuat(A.Up, this, ConchQuaternion.TEMPVector32);
                var t = ConchQuaternion.TEMPVector32.elements;
                ConchQuaternion.angleTo(A.ZERO, ConchQuaternion.TEMPVector31, ConchQuaternion.TEMPVector33);
                var r = ConchQuaternion.TEMPVector33.elements;
                r[0] == Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(t[2], t[0]), r[2] = 0) : r[0] == -Math.PI / 2 ? (r[1] = ConchQuaternion.arcTanAngle(-t[2], -t[0]),
                        r[2] = 0) : (L.createRotationY(-r[1], ConchQuaternion.TEMPMatrix0), L.createRotationX(-r[0], ConchQuaternion.TEMPMatrix1),
                        A.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix0, ConchQuaternion.TEMPVector32),
                        A.transformCoordinate(ConchQuaternion.TEMPVector32, ConchQuaternion.TEMPMatrix1, ConchQuaternion.TEMPVector32),
                        r[2] = ConchQuaternion.arcTanAngle(t[1], -t[0])), r[1] <= -Math.PI && (r[1] = Math.PI),
                    r[2] <= -Math.PI && (r[2] = Math.PI), r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0,
                        r[2] = 0, r[0] = Math.PI - r[0]);
                var n = e.elements;
                n[0] = r[1], n[1] = r[0], n[2] = r[2];
            }
        }, {
            key: "invert",
            value: function(e) {
                var t = e.elements,
                    r = this.elements,
                    n = r[0],
                    i = r[1],
                    a = r[2],
                    o = r[3],
                    s = n * n + i * i + a * a + o * o,
                    l = s ? 1 / s : 0;
                t[0] = -n * l, t[1] = -i * l, t[2] = -a * l, t[3] = o * l;
            }
        }, {
            key: "identity",
            value: function() {
                var e = this.elements;
                e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
            }
        }, {
            key: "fromArray",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                    this.elements[3] = e[t + 3];
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t, r, n;
                if ((r = this.elements) !== (n = e.elements))
                    for (t = 0; t < 4; ++t) n[t] = r[t];
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConchQuaternion();
                return this.cloneTo(e), e;
            }
        }, {
            key: "equals",
            value: function(e) {
                var t = this.elements,
                    n = e.elements;
                return r.nearEqual(t[0], n[0]) && r.nearEqual(t[1], n[1]) && r.nearEqual(t[2], n[2]) && r.nearEqual(t[3], n[3]);
            }
        }, {
            key: "lengthSquared",
            value: function() {
                var e = this.elements[0],
                    t = this.elements[1],
                    r = this.elements[2],
                    n = this.elements[3];
                return e * e + t * t + r * r + n * n;
            }
        }, {
            key: "x",
            get: function() {
                return this.elements[0];
            },
            set: function(e) {
                this.elements[0] = e;
            }
        }, {
            key: "y",
            get: function() {
                return this.elements[1];
            },
            set: function(e) {
                this.elements[1] = e;
            }
        }, {
            key: "z",
            get: function() {
                return this.elements[2];
            },
            set: function(e) {
                this.elements[2] = e;
            }
        }, {
            key: "w",
            get: function() {
                return this.elements[3];
            },
            set: function(e) {
                this.elements[3] = e;
            }
        }], [{
            key: "_dotArray",
            value: function(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
            }
        }, {
            key: "_normalizeArray",
            value: function(e, t) {
                var r = e[0],
                    n = e[1],
                    i = e[2],
                    a = e[3],
                    o = r * r + n * n + i * i + a * a;
                o > 0 && (o = 1 / Math.sqrt(o), t[0] = r * o, t[1] = n * o, t[2] = i * o, t[3] = a * o);
            }
        }, {
            key: "_lerpArray",
            value: function(e, t, r, n) {
                var i = 1 - r;
                ConchQuaternion._dotArray(e, t) >= 0 ? (n[0] = i * e[0] + r * t[0], n[1] = i * e[1] + r * t[1],
                        n[2] = i * e[2] + r * t[2], n[3] = i * e[3] + r * t[3]) : (n[0] = i * e[0] - r * t[0],
                        n[1] = i * e[1] - r * t[1], n[2] = i * e[2] - r * t[2], n[3] = i * e[3] - r * t[3]),
                    ConchQuaternion._normalizeArray(n, n);
            }
        }, {
            key: "createFromYawPitchRoll",
            value: function(e, t, r, n) {
                var i = .5 * r,
                    a = .5 * t,
                    o = .5 * e,
                    s = Math.sin(i),
                    l = Math.cos(i),
                    u = Math.sin(a),
                    c = Math.cos(a),
                    h = Math.sin(o),
                    _ = Math.cos(o),
                    d = n.elements;
                d[0] = _ * u * l + h * c * s, d[1] = h * c * l - _ * u * s, d[2] = _ * c * s - h * u * l,
                    d[3] = _ * c * l + h * u * s;
            }
        }, {
            key: "multiply",
            value: function(e, t, r) {
                var n = e.elements,
                    i = t.elements,
                    a = r.elements,
                    o = n[0],
                    s = n[1],
                    l = n[2],
                    u = n[3],
                    c = i[0],
                    h = i[1],
                    _ = i[2],
                    d = i[3],
                    f = s * _ - l * h,
                    m = l * c - o * _,
                    T = o * h - s * c,
                    p = o * c + s * h + l * _;
                a[0] = o * d + c * u + f, a[1] = s * d + h * u + m, a[2] = l * d + _ * u + T, a[3] = u * d - p;
            }
        }, {
            key: "arcTanAngle",
            value: function(e, t) {
                return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
            }
        }, {
            key: "angleTo",
            value: function(e, t, r) {
                A.subtract(t, e, ConchQuaternion.TEMPVector30), A.normalize(ConchQuaternion.TEMPVector30, ConchQuaternion.TEMPVector30),
                    r.elements[0] = Math.asin(ConchQuaternion.TEMPVector30.y), r.elements[1] = ConchQuaternion.arcTanAngle(-ConchQuaternion.TEMPVector30.z, -ConchQuaternion.TEMPVector30.x);
            }
        }, {
            key: "createFromAxisAngle",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements;
                t *= .5;
                var a = Math.sin(t);
                n[0] = a * i[0], n[1] = a * i[1], n[2] = a * i[2], n[3] = Math.cos(t);
            }
        }, {
            key: "createFromMatrix3x3",
            value: function(e, t) {
                var r, n = t.elements,
                    i = e.elements,
                    a = i[0] + i[4] + i[8];
                if (a > 0) r = Math.sqrt(a + 1), n[3] = .5 * r, r = .5 / r, n[0] = (i[5] - i[7]) * r,
                    n[1] = (i[6] - i[2]) * r, n[2] = (i[1] - i[3]) * r;
                else {
                    var o = 0;
                    i[4] > i[0] && (o = 1), i[8] > i[3 * o + o] && (o = 2);
                    var s = (o + 1) % 3,
                        l = (o + 2) % 3;
                    r = Math.sqrt(i[3 * o + o] - i[3 * s + s] - i[3 * l + l] + 1), n[o] = .5 * r, r = .5 / r,
                        n[3] = (i[3 * s + l] - i[3 * l + s]) * r, n[s] = (i[3 * s + o] + i[3 * o + s]) * r,
                        n[l] = (i[3 * l + o] + i[3 * o + l]) * r;
                }
            }
        }, {
            key: "createFromMatrix4x4",
            value: function(e, t) {
                var r, n, i = e.elements,
                    a = t.elements,
                    o = i[0] + i[5] + i[10];
                o > 0 ? (r = Math.sqrt(o + 1), a[3] = .5 * r, r = .5 / r, a[0] = (i[6] - i[9]) * r,
                    a[1] = (i[8] - i[2]) * r, a[2] = (i[1] - i[4]) * r) : i[0] >= i[5] && i[0] >= i[10] ? (n = .5 / (r = Math.sqrt(1 + i[0] - i[5] - i[10])),
                    a[0] = .5 * r, a[1] = (i[1] + i[4]) * n, a[2] = (i[2] + i[8]) * n, a[3] = (i[6] - i[9]) * n) : i[5] > i[10] ? (n = .5 / (r = Math.sqrt(1 + i[5] - i[0] - i[10])),
                    a[0] = (i[4] + i[1]) * n, a[1] = .5 * r, a[2] = (i[9] + i[6]) * n, a[3] = (i[8] - i[2]) * n) : (n = .5 / (r = Math.sqrt(1 + i[10] - i[0] - i[5])),
                    a[0] = (i[8] + i[2]) * n, a[1] = (i[9] + i[6]) * n, a[2] = .5 * r, a[3] = (i[1] - i[4]) * n);
            }
        }, {
            key: "slerp",
            value: function(e, t, r, n) {
                var i, a, o, s, l, u = e.elements,
                    c = t.elements,
                    h = n.elements,
                    _ = u[0],
                    d = u[1],
                    f = u[2],
                    m = u[3],
                    T = c[0],
                    p = c[1],
                    v = c[2],
                    E = c[3];
                return (a = _ * T + d * p + f * v + m * E) < 0 && (a = -a, T = -T, p = -p, v = -v,
                        E = -E), 1 - a > 1e-6 ? (i = Math.acos(a), o = Math.sin(i), s = Math.sin((1 - r) * i) / o,
                        l = Math.sin(r * i) / o) : (s = 1 - r, l = r), h[0] = s * _ + l * T, h[1] = s * d + l * p,
                    h[2] = s * f + l * v, h[3] = s * m + l * E, h;
            }
        }, {
            key: "lerp",
            value: function(e, t, r, n) {
                ConchQuaternion._lerpArray(e.elements, t.elements, r, n.elements);
            }
        }, {
            key: "add",
            value: function(e, t, r) {
                var n = r.elements,
                    i = e.elements,
                    a = t.elements;
                n[0] = i[0] + a[0], n[1] = i[1] + a[1], n[2] = i[2] + a[2], n[3] = i[3] + a[3];
            }
        }, {
            key: "dot",
            value: function(e, t) {
                return ConchQuaternion._dotArray(e.elements, t.elements);
            }
        }, {
            key: "rotationLookAt",
            value: function(e, t, r) {
                ConchQuaternion.lookAt(A.ZERO, e, t, r);
            }
        }, {
            key: "lookAt",
            value: function(e, t, r, n) {
                d.lookAt(e, t, r, ConchQuaternion._tempMatrix3x3), ConchQuaternion.rotationMatrix(ConchQuaternion._tempMatrix3x3, n);
            }
        }, {
            key: "invert",
            value: function(e, t) {
                var n = e.elements,
                    i = t.elements,
                    a = e.lengthSquared();
                r.isZero(a) || (a = 1 / a, i[0] = -n[0] * a, i[1] = -n[1] * a, i[2] = -n[2] * a,
                    i[3] = n[3] * a);
            }
        }, {
            key: "rotationMatrix",
            value: function(e, t) {
                var r, n, i = e.elements,
                    a = i[0],
                    o = i[1],
                    s = i[2],
                    l = i[3],
                    u = i[4],
                    c = i[5],
                    h = i[6],
                    _ = i[7],
                    d = i[8],
                    f = t.elements,
                    m = a + u + d;
                m > 0 ? (r = Math.sqrt(m + 1), f[3] = .5 * r, r = .5 / r, f[0] = (c - _) * r, f[1] = (h - s) * r,
                    f[2] = (o - l) * r) : a >= u && a >= d ? (n = .5 / (r = Math.sqrt(1 + a - u - d)),
                    f[0] = .5 * r, f[1] = (o + l) * n, f[2] = (s + h) * n, f[3] = (c - _) * n) : u > d ? (n = .5 / (r = Math.sqrt(1 + u - a - d)),
                    f[0] = (l + o) * n, f[1] = .5 * r, f[2] = (_ + c) * n, f[3] = (h - s) * n) : (n = .5 / (r = Math.sqrt(1 + d - a - u)),
                    f[0] = (h + s) * n, f[1] = (_ + c) * n, f[2] = .5 * r, f[3] = (o - l) * n);
            }
        }]), ConchQuaternion;
    }();
    I.TEMPVector30 = new A(), I.TEMPVector31 = new A(), I.TEMPVector32 = new A(), I.TEMPVector33 = new A(),
        I.TEMPMatrix0 = new L(), I.TEMPMatrix1 = new L(), I._tempMatrix3x3 = new d(), I.DEFAULT = new I(),
        I.NAN = new I(NaN, NaN, NaN, NaN);
    var O = function() {
            function AnimatorState() {
                _classCallCheck(this, AnimatorState), this._referenceCount = 0, this._clip = null,
                    this._nodeOwners = [], this._currentFrameIndices = null, this._realtimeDatas = [],
                    this._scripts = null, this.speed = 1, this.clipStart = 0, this.clipEnd = 1;
            }
            return _createClass(AnimatorState, [{
                key: "_getReferenceCount",
                value: function() {
                    return this._referenceCount;
                }
            }, {
                key: "_addReference",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                    this._clip && this._clip._addReference(e), this._referenceCount += e;
                }
            }, {
                key: "_removeReference",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                    this._clip && this._clip._removeReference(e), this._referenceCount -= e;
                }
            }, {
                key: "_clearReference",
                value: function() {
                    this._removeReference(-this._referenceCount);
                }
            }, {
                key: "_resetFrameIndices",
                value: function() {
                    for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this._currentFrameIndices[e] = -1;
                }
            }, {
                key: "addScript",
                value: function(e) {
                    var t = new e();
                    return this._scripts = this._scripts || [], this._scripts.push(t), t;
                }
            }, {
                key: "getScript",
                value: function(e) {
                    if (this._scripts)
                        for (var t = 0, r = this._scripts.length; t < r; t++) {
                            var n = this._scripts[t];
                            if (n instanceof e) return n;
                        }
                    return null;
                }
            }, {
                key: "getScripts",
                value: function(e) {
                    var t;
                    if (this._scripts)
                        for (var r = 0, n = this._scripts.length; r < n; r++) {
                            var i = this._scripts[r];
                            i instanceof e && (t = t || []).push(i);
                        }
                    return t;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd,
                        t.clip = this._clip;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new AnimatorState();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "clip",
                get: function() {
                    return this._clip;
                },
                set: function(e) {
                    if (this._clip !== e) {
                        if (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount),
                            e) {
                            var r = this._realtimeDatas,
                                n = e._nodes,
                                i = n.count;
                            this._currentFrameIndices = new Int16Array(i), this._resetFrameIndices(), this._referenceCount > 0 && e._addReference(this._referenceCount),
                                this._realtimeDatas.length = i;
                            for (var a = 0; a < i; a++) switch (n.getNodeByIndex(a).type) {
                                case 0:
                                    break;

                                case 1:
                                case 3:
                                case 4:
                                    r[a] = t.Render.supportWebGLPlusAnimation ? new A() : new o();
                                    break;

                                case 2:
                                    r[a] = t.Render.supportWebGLPlusAnimation ? new I() : new f();
                                    break;

                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        this._clip = e;
                    }
                }
            }]), AnimatorState;
        }(),
        P = function() {
            function KeyframeNodeOwner() {
                _classCallCheck(this, KeyframeNodeOwner), this.indexInList = -1, this.referenceCount = 0,
                    this.updateMark = -1, this.type = -1, this.fullPath = null, this.propertyOwner = null,
                    this.property = null, this.defaultValue = null, this.value = null, this.crossFixedValue = null;
            }
            return _createClass(KeyframeNodeOwner, [{
                key: "saveCrossFixedValue",
                value: function() {
                    if (this.propertyOwner) switch (this.type) {
                        case 0:
                            this.crossFixedValue = this.value;
                            break;

                        case 1:
                        case 3:
                        case 4:
                        case 2:
                            this.value.cloneTo(this.crossFixedValue);
                            break;

                        default:
                            throw "Animator:unknown type.";
                    }
                }
            }]), KeyframeNodeOwner;
        }(),
        N = function(e) {
            function Animator() {
                var e;
                return _classCallCheck(this, Animator), (e = _possibleConstructorReturn(this, _getPrototypeOf(Animator).call(this)))._keyframeNodeOwners = [],
                    e._linkAvatarSpritesData = {}, e._linkAvatarSprites = [], e._renderableSprites = [],
                    e.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY, e._controllerLayers = [], e._linkSprites = {},
                    e._speed = 1, e._keyframeNodeOwnerMap = {}, e._updateMark = 0, e;
            }
            return _inherits(Animator, t.Component), _createClass(Animator, [{
                key: "_linkToSprites",
                value: function(e) {
                    for (var t in e) {
                        for (var r = this.owner, n = e[t], i = 0, a = n.length; i < a; i++) {
                            var o = n[i];
                            if ("" === o) break;
                            if (!(r = r.getChildByName(o))) break;
                        }
                        r && this.linkSprite3DToAvatarNode(t, r);
                    }
                }
            }, {
                key: "_addKeyframeNodeOwner",
                value: function(e, t, r) {
                    var n = t._indexInList,
                        i = t.fullPath,
                        a = this._keyframeNodeOwnerMap[i];
                    if (a) a.referenceCount++, e[n] = a;
                    else {
                        for (var o = r, s = 0, l = t.propertyCount; s < l && (o = o[t.getPropertyByIndex(s)]); s++);
                        (a = this._keyframeNodeOwnerMap[i] = new P()).fullPath = i, a.indexInList = this._keyframeNodeOwners.length,
                            a.referenceCount = 1, a.propertyOwner = r;
                        var u = t.propertyCount,
                            c = [];
                        for (s = 0; s < u; s++) c[s] = t.getPropertyByIndex(s);
                        if (a.property = c, a.type = t.type, o)
                            if (0 === t.type) a.defaultValue = o;
                            else {
                                var h = new o.constructor();
                                o.cloneTo(h), a.defaultValue = h, a.value = new o.constructor(), a.crossFixedValue = new o.constructor();
                            }
                        this._keyframeNodeOwners.push(a), e[n] = a;
                    }
                }
            }, {
                key: "_removeKeyframeNodeOwner",
                value: function(e, t) {
                    var r = t.fullPath,
                        n = this._keyframeNodeOwnerMap[r];
                    n && (n.referenceCount--, 0 === n.referenceCount && (delete this._keyframeNodeOwnerMap[r],
                        this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(n), 1)), e[t._indexInList] = null);
                }
            }, {
                key: "_getOwnersByClip",
                value: function(e) {
                    var t = e._clip._nodes,
                        r = t.count,
                        n = e._nodeOwners;
                    n.length = r;
                    for (var i = 0; i < r; i++) {
                        for (var a = t.getNodeByIndex(i), o = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, s = 0, l = a.ownerPathCount; s < l; s++) {
                            var u = a.getOwnerPathByIndex(s);
                            if ("" === u) break;
                            if (!(o = o.getChildByName(u))) break;
                        }
                        if (o) {
                            var c = a.propertyOwner;
                            c && (o = o[c]), o && this._addKeyframeNodeOwner(n, a, o);
                        }
                    }
                }
            }, {
                key: "_updatePlayer",
                value: function(e, t, r, n) {
                    var i = e._clip._duration * (e.clipEnd - e.clipStart),
                        a = t._elapsedTime,
                        o = a + r;
                    t._lastElapsedTime = a, t._elapsedTime = o;
                    var s = o / i;
                    t._normalizedTime = s;
                    var l = s % 1;
                    t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = i;
                    var u = e._scripts;
                    if (!n && o >= i) {
                        if (t._finish = !0, t._elapsedTime = i, t._normalizedPlayTime = 1, u)
                            for (var c = 0, h = u.length; c < h; c++) u[c].onStateExit();
                    } else if (u)
                        for (c = 0, h = u.length; c < h; c++) u[c].onStateUpdate();
                }
            }, {
                key: "_eventScript",
                value: function(e, t, r, n, i) {
                    if (i)
                        for (var a = t.length; r < a; r++) {
                            var o = t[r];
                            if (!(o.time <= n)) break;
                            for (var s = 0, l = e.length; s < l; s++) {
                                var u = e[s],
                                    c = u[o.eventName];
                                c && c.apply(u, o.params);
                            }
                        } else
                            for (; r >= 0 && (o = t[r]).time >= n; r--)
                                for (s = 0, l = e.length; s < l; s++)(c = (u = e[s])[o.eventName]) && c.apply(u, o.params);
                    return r;
                }
            }, {
                key: "_updateEventScript",
                value: function(e, t) {
                    var r = this.owner._scripts;
                    if (r) {
                        var n = e._clip,
                            i = n._animationEvents,
                            a = n._duration,
                            o = t._elapsedTime,
                            s = o % a,
                            l = Math.abs(Math.floor(o / a) - Math.floor(t._lastElapsedTime / a)),
                            u = t._elapsedTime >= t._lastElapsedTime;
                        if (t._lastIsFront !== u && (u ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = u),
                            u) {
                            t._playEventIndex = this._eventScript(r, i, t._playEventIndex, l > 0 ? a : s, !0);
                            for (var c = 0, h = l - 1; c < h; c++) this._eventScript(r, i, 0, a, !0);
                            l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, 0, s, !0));
                        } else {
                            t._playEventIndex = this._eventScript(r, i, t._playEventIndex, l > 0 ? 0 : s, !1);
                            var _ = i.length - 1;
                            for (c = 0, h = l - 1; c < h; c++) this._eventScript(r, i, _, 0, !1);
                            l > 0 && s > 0 && (t._playEventIndex = this._eventScript(r, i, _, s, !1));
                        }
                    }
                }
            }, {
                key: "_updateClipDatas",
                value: function(e, t, r, n) {
                    var i = e._clip,
                        a = i._duration,
                        o = e.clipStart * a + r._normalizedPlayTime * r._duration,
                        s = e._currentFrameIndices,
                        l = r._elapsedTime > r._lastElapsedTime;
                    i._evaluateClipDatasRealTime(i._nodes, o, s, t, l, e._realtimeDatas);
                }
            }, {
                key: "_applyFloat",
                value: function(e, t, r, n, i, a, o) {
                    if (r.updateMark === this._updateMark)
                        if (n) e[t] += i * o;
                        else {
                            var s = e[t];
                            e[t] = s + i * (o - s);
                        }
                    else if (a) e[t] = n ? r.defaultValue + o : o;
                    else if (n) e[t] = r.defaultValue + i * o;
                    else {
                        var l = r.defaultValue;
                        e[t] = l + i * (o - l);
                    }
                }
            }, {
                key: "_applyPositionAndRotationEuler",
                value: function(e, t, r, n, i, a) {
                    if (e.updateMark === this._updateMark)
                        if (t) a.x += r * i.x, a.y += r * i.y, a.z += r * i.z;
                        else {
                            var o = a.x,
                                s = a.y,
                                l = a.z;
                            a.x = o + r * (i.x - o), a.y = s + r * (i.y - s), a.z = l + r * (i.z - l);
                        }
                    else if (n)
                        if (t) {
                            var u = e.defaultValue;
                            a.x = u.x + i.x, a.y = u.y + i.y, a.z = u.z + i.z;
                        } else a.x = i.x, a.y = i.y, a.z = i.z;
                    else if (u = e.defaultValue, t) a.x = u.x + r * i.x,
                        a.y = u.y + r * i.y, a.z = u.z + r * i.z;
                    else {
                        var c = u.x,
                            h = u.y,
                            _ = u.z;
                        a.x = c + r * (i.x - c), a.y = h + r * (i.y - h), a.z = _ + r * (i.z - _);
                    }
                }
            }, {
                key: "_applyRotation",
                value: function(e, t, r, n, i, a) {
                    if (e.updateMark === this._updateMark)
                        if (t) {
                            var o = Animator._tempQuaternion1;
                            R.quaternionWeight(i, r, o), o.normalize(o), f.multiply(a, o, a);
                        } else f.lerp(a, i, r, a);
                    else if (n)
                        if (t) {
                            var s = e.defaultValue;
                            f.multiply(s, i, a);
                        } else a.x = i.x, a.y = i.y, a.z = i.z, a.w = i.w;
                    else s = e.defaultValue, t ? (o = Animator._tempQuaternion1,
                        R.quaternionWeight(i, r, o), o.normalize(o), f.multiply(s, o, a)) : f.lerp(s, i, r, a);
                }
            }, {
                key: "_applyScale",
                value: function(e, t, r, n, i, a) {
                    if (e.updateMark === this._updateMark)
                        if (t) {
                            var o = Animator._tempVector31;
                            R.scaleWeight(i, r, o), a.x = a.x * o.x, a.y = a.y * o.y, a.z = a.z * o.z;
                        } else R.scaleBlend(a, i, r, a);
                    else if (n)
                        if (t) {
                            var s = e.defaultValue;
                            a.x = s.x * i.x, a.y = s.y * i.y, a.z = s.z * i.z;
                        } else a.x = i.x, a.y = i.y, a.z = i.z;
                    else s = e.defaultValue, t ? (o = Animator._tempVector31,
                        R.scaleWeight(i, r, o), a.x = s.x * o.x, a.y = s.y * o.y, a.z = s.z * o.z) : R.scaleBlend(s, i, r, a);
                }
            }, {
                key: "_applyCrossData",
                value: function(e, t, r, n, i, a, o) {
                    var s = e.propertyOwner;
                    if (s) {
                        switch (e.type) {
                            case 0:
                                for (var l = e.property, u = l.length - 1, c = 0; c < u && (s = s[l[c]]); c++);
                                var h = i + o * (a - i);
                                e.value = h, this._applyFloat(s, l[u], e, t, r, n, h);
                                break;

                            case 1:
                                var _ = s.localPosition,
                                    d = e.value,
                                    m = i.x,
                                    T = i.y,
                                    p = i.z;
                                d.x = m + o * (a.x - m), d.y = T + o * (a.y - T), d.z = p + o * (a.z - p), this._applyPositionAndRotationEuler(e, t, r, n, d, _),
                                    s.localPosition = _;
                                break;

                            case 2:
                                var v = s.localRotation,
                                    E = e.value;
                                f.lerp(i, a, o, E), this._applyRotation(e, t, r, n, E, v), s.localRotation = v;
                                break;

                            case 3:
                                var g = s.localScale,
                                    y = e.value;
                                R.scaleBlend(i, a, o, y), this._applyScale(e, t, r, n, y, g), s.localScale = g;
                                break;

                            case 4:
                                var S = s.localRotationEuler,
                                    C = e.value;
                                m = i.x, T = i.y, p = i.z, C.x = m + o * (a.x - m), C.y = T + o * (a.y - T), C.z = p + o * (a.z - p),
                                    this._applyPositionAndRotationEuler(e, t, r, n, C, S), s.localRotationEuler = S;
                        }
                        e.updateMark = this._updateMark;
                    }
                }
            }, {
                key: "_setClipDatasToNode",
                value: function(e, t, r, n) {
                    for (var i = e._realtimeDatas, a = e._clip._nodes, o = e._nodeOwners, s = 0, l = a.count; s < l; s++) {
                        var u = o[s];
                        if (u) {
                            var c = u.propertyOwner;
                            if (c) {
                                switch (u.type) {
                                    case 0:
                                        for (var h = u.property, _ = h.length - 1, d = 0; d < _ && (c = c[h[d]]); d++);
                                        this._applyFloat(c, h[_], u, t, r, n, i[s]);
                                        break;

                                    case 1:
                                        var f = c.localPosition;
                                        this._applyPositionAndRotationEuler(u, t, r, n, i[s], f), c.localPosition = f;
                                        break;

                                    case 2:
                                        var m = c.localRotation;
                                        this._applyRotation(u, t, r, n, i[s], m), c.localRotation = m;
                                        break;

                                    case 3:
                                        var T = c.localScale;
                                        this._applyScale(u, t, r, n, i[s], T), c.localScale = T;
                                        break;

                                    case 4:
                                        var p = c.localRotationEuler;
                                        this._applyPositionAndRotationEuler(u, t, r, n, i[s], p), c.localRotationEuler = p;
                                }
                                u.updateMark = this._updateMark;
                            }
                        }
                    }
                }
            }, {
                key: "_setCrossClipDatasToNode",
                value: function(e, t, r, n, i) {
                    for (var a = e._crossNodesOwners, o = e._crossNodesOwnersCount, s = e.blendingMode !== x.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, u = r._realtimeDatas, c = e._destCrossClipNodeIndices, h = r._nodeOwners, _ = t._realtimeDatas, d = e._srcCrossClipNodeIndices, f = t._nodeOwners, m = 0; m < o; m++) {
                        var T = a[m];
                        if (T) {
                            var p = d[m],
                                v = c[m],
                                E = -1 !== p ? _[p] : h[v].defaultValue,
                                g = -1 !== v ? u[v] : f[p].defaultValue;
                            this._applyCrossData(T, s, l, i, E, g, n);
                        }
                    }
                }
            }, {
                key: "_setFixedCrossClipDatasToNode",
                value: function(e, t, r, n) {
                    for (var i = e._crossNodesOwners, a = e._crossNodesOwnersCount, o = e.blendingMode !== x.BLENDINGMODE_OVERRIDE, s = e.defaultWeight, l = t._realtimeDatas, u = e._destCrossClipNodeIndices, c = 0; c < a; c++) {
                        var h = i[c];
                        if (h) {
                            var _ = u[c],
                                d = h.crossFixedValue,
                                f = -1 !== _ ? l[_] : h.defaultValue;
                            this._applyCrossData(h, o, s, n, d, f, r);
                        }
                    }
                }
            }, {
                key: "_revertDefaultKeyframeNodes",
                value: function(e) {
                    for (var t = e._nodeOwners, r = 0, n = t.length; r < n; r++) {
                        var i = t[r];
                        if (i) {
                            var a = i.propertyOwner;
                            if (a) switch (i.type) {
                                case 0:
                                    for (var o = i.property, s = o.length - 1, l = 0; l < s && (a = a[o[l]]); l++);
                                    a[o[s]] = i.defaultValue;
                                    break;

                                case 1:
                                    var u = a.localPosition,
                                        c = i.defaultValue;
                                    u.x = c.x, u.y = c.y, u.z = c.z, a.localPosition = u;
                                    break;

                                case 2:
                                    var h = a.localRotation,
                                        _ = i.defaultValue;
                                    h.x = _.x, h.y = _.y, h.z = _.z, h.w = _.w, a.localRotation = h;
                                    break;

                                case 3:
                                    var d = a.localScale;
                                    c = i.defaultValue, d.x = c.x, d.y = c.y, d.z = c.z, a.localScale = d;
                                    break;

                                case 4:
                                    var f = a.localRotationEuler;
                                    c = i.defaultValue, f.x = c.x, f.y = c.y, f.z = c.z, a.localRotationEuler = f;
                                    break;

                                default:
                                    throw "Animator:unknown type.";
                            }
                        }
                    }
                }
            }, {
                key: "_onAdded",
                value: function() {
                    var e = this.owner._parent;
                    this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
                }
            }, {
                key: "_onDestroy",
                value: function() {
                    for (var e = 0, t = this._controllerLayers.length; e < t; e++) this._controllerLayers[e]._removeReference();
                    var r = this.owner._parent;
                    this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null);
                }
            }, {
                key: "_onEnable",
                value: function() {
                    this.owner._scene._animatorPool.add(this);
                    for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                        if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
                    }
                }
            }, {
                key: "_onDisable",
                value: function() {
                    this.owner._scene._animatorPool.remove(this);
                }
            }, {
                key: "_handleSpriteOwnersBySprite",
                value: function(e, t, r) {
                    for (var n = 0, i = this._controllerLayers.length; n < i; n++)
                        for (var a = this._controllerLayers[n]._states, o = 0, s = a.length; o < s; o++) {
                            var l = a[o],
                                u = l._clip,
                                c = t.join("/"),
                                h = u._nodesMap[c];
                            if (h)
                                for (var _ = l._nodeOwners, d = 0, f = h.length; d < f; d++) e ? this._addKeyframeNodeOwner(_, h[d], r) : this._removeKeyframeNodeOwner(_, h[d]);
                        }
                }
            }, {
                key: "_parse",
                value: function(e) {
                    var r = e.avatar;
                    if (r) {
                        this.avatar = t.Loader.getRes(r.path);
                        var n = r.linkSprites;
                        this._linkSprites = n, this._linkToSprites(n);
                    }
                    e.clipPaths;
                    for (var i = e.playOnWake, a = e.layers, o = 0; o < a.length; o++) {
                        var s = a[o],
                            l = new x(s.name);
                        l.defaultWeight = 0 === o ? 1 : s.weight;
                        var u = s.blendingMode;
                        u && (l.blendingMode = u), this.addControllerLayer(l);
                        for (var c = s.states, h = 0, _ = c.length; h < _; h++) {
                            var d = c[h],
                                f = d.clipPath;
                            if (f) {
                                var m, T = d.name;
                                if (m = t.Loader.getRes(f)) {
                                    var p = new O();
                                    p.name = T, p.clip = m, l.addState(p), 0 === h && (this.getControllerLayer(o).defaultState = p);
                                }
                            }
                        }
                        void 0 !== i && (l.playOnWake = i);
                    }
                    var v = e.cullingMode;
                    void 0 !== v && (this.cullingMode = v);
                }
            }, {
                key: "_update",
                value: function() {
                    var e = this.owner._scene.timer,
                        r = e._delta / 1e3;
                    if (0 !== this._speed && 0 !== r) {
                        var n;
                        if (this.cullingMode === Animator.CULLINGMODE_CULLCOMPLETELY) {
                            n = !1;
                            for (var i = 0, a = this._renderableSprites.length; i < a; i++)
                                if (this._renderableSprites[i]._render.isRender) {
                                    n = !0;
                                    break;
                                }
                        } else n = !0;
                        this._updateMark++;
                        var o = e.scale;
                        for (i = 0, a = this._controllerLayers.length; i < a; i++) {
                            var s = this._controllerLayers[i],
                                l = s._playStateInfo,
                                u = s._crossPlayStateInfo;
                            switch (f = s.blendingMode !== x.BLENDINGMODE_OVERRIDE, s._playType) {
                                case 0:
                                    var c = l._currentState,
                                        h = c._clip,
                                        _ = this._speed * c.speed,
                                        d = l._finish;
                                    if (d || this._updatePlayer(c, l, r * _, h.islooping), n) {
                                        var f = s.blendingMode !== x.BLENDINGMODE_OVERRIDE;
                                        this._updateClipDatas(c, f, l, o * _), this._setClipDatasToNode(c, f, s.defaultWeight, 0 === i),
                                            d || this._updateEventScript(c, l);
                                    }
                                    break;

                                case 1:
                                    h = (c = l._currentState)._clip;
                                    var m = s._crossPlayState,
                                        T = m._clip,
                                        p = s._crossDuration,
                                        v = u._startPlayTime,
                                        E = T._duration - v,
                                        g = p > E ? E / p : 1,
                                        y = this._speed * m.speed;
                                    this._updatePlayer(m, u, r * g * y, T.islooping);
                                    var S = (u._elapsedTime - v) / g / p;
                                    S >= 1 ? n && (this._updateClipDatas(m, f, u, o * y), this._setClipDatasToNode(m, f, s.defaultWeight, 0 === i),
                                            s._playType = 0, l._currentState = m, u._cloneTo(l)) : (l._finish || (_ = this._speed * c.speed,
                                                this._updatePlayer(c, l, r * _, h.islooping), n && this._updateClipDatas(c, f, l, o * _)),
                                            n && (this._updateClipDatas(m, f, u, o * g * y), this._setCrossClipDatasToNode(s, c, m, S, 0 === i))),
                                        n && (this._updateEventScript(c, l), this._updateEventScript(m, u));
                                    break;

                                case 2:
                                    T = (m = s._crossPlayState)._clip, p = s._crossDuration, v = u._startPlayTime, g = p > (E = T._duration - v) ? E / p : 1,
                                        y = this._speed * m.speed, this._updatePlayer(m, u, r * g * y, T.islooping), n && ((S = (u._elapsedTime - v) / g / p) >= 1 ? (this._updateClipDatas(m, f, u, o * y),
                                                this._setClipDatasToNode(m, f, 1, 0 === i), s._playType = 0, l._currentState = m,
                                                u._cloneTo(l)) : (this._updateClipDatas(m, f, u, o * g * y), this._setFixedCrossClipDatasToNode(s, m, S, 0 === i)),
                                            this._updateEventScript(m, u));
                            }
                        }
                        n && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices),
                            this._updateAvatarNodesToSprite());
                    }
                }
            }, {
                key: "_cloneTo",
                value: function(e) {
                    var t = e;
                    t.avatar = this.avatar, t.cullingMode = this.cullingMode;
                    for (var r = 0, n = this._controllerLayers.length; r < n; r++) {
                        var i = this._controllerLayers[r];
                        t.addControllerLayer(i.clone());
                        for (var a = i._states, o = 0, s = a.length; o < s; o++) {
                            var l = a[o].clone(),
                                u = t.getControllerLayer(r);
                            u.addState(l), 0 == o && (u.defaultState = l);
                        }
                    }
                    t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
                }
            }, {
                key: "getDefaultState",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    return this._controllerLayers[e].defaultState;
                }
            }, {
                key: "addState",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    this._controllerLayers[t].addState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
                }
            }, {
                key: "removeState",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    this._controllerLayers[t].removeState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
                }
            }, {
                key: "addControllerLayer",
                value: function(e) {
                    this._controllerLayers.push(e), e._animator = this, e._addReference();
                    for (var t = e._states, r = 0, n = t.length; r < n; r++) this._getOwnersByClip(t[r]);
                }
            }, {
                key: "getControllerLayer",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    return this._controllerLayers[e];
                }
            }, {
                key: "play",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.NEGATIVE_INFINITY,
                        n = this._controllerLayers[t];
                    if (n) {
                        var i = n.defaultState;
                        if (!e && !i) throw new Error("Animator:must have default clip value,please set clip property.");
                        var a = n._playStateInfo,
                            o = a._currentState,
                            s = e ? n._statesMap[e] : i,
                            l = s._clip._duration;
                        o !== s ? (r !== Number.NEGATIVE_INFINITY ? a._resetPlayState(l * r) : a._resetPlayState(0),
                            null !== o && o !== s && this._revertDefaultKeyframeNodes(o), n._playType = 0, a._currentState = s) : r !== Number.NEGATIVE_INFINITY && (a._resetPlayState(l * r),
                            n._playType = 0);
                        var u = s._scripts;
                        if (u)
                            for (var c = 0, h = u.length; c < h; c++) u[c].onStateEnter();
                    } else console.warn("Invalid layerIndex " + t + ".");
                }
            }, {
                key: "crossFade",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.NEGATIVE_INFINITY,
                        i = this._controllerLayers[r];
                    if (i) {
                        var a = i._statesMap[e];
                        if (a) {
                            var o = i._playType;
                            if (-1 === o) return void this.play(e, r, n);
                            var s = i._crossPlayStateInfo,
                                l = i._crossNodesOwners,
                                u = i._crossNodesOwnersIndicesMap,
                                c = i._playStateInfo._currentState,
                                h = a._nodeOwners,
                                _ = i._destCrossClipNodeIndices,
                                d = a._clip,
                                f = d._nodes,
                                m = d._nodesDic;
                            switch (o) {
                                case 0:
                                    var T = c._nodeOwners,
                                        p = i._srcCrossClipNodeIndices,
                                        v = c._clip,
                                        E = v._nodes,
                                        g = v._nodesDic;
                                    i._playType = 1;
                                    for (var y = ++i._crossMark, S = i._crossNodesOwnersCount = 0, R = 0, C = E.count; R < C; R++) {
                                        var M = E.getNodeByIndex(R),
                                            x = M._indexInList,
                                            D = T[x];
                                        if (D) {
                                            var A = M.fullPath;
                                            p[S] = x;
                                            var L = m[A];
                                            _[S] = L ? L._indexInList : -1, u[A] = y, l[S] = D, S++;
                                        }
                                    }
                                    for (R = 0, C = f.count; R < C; R++) {
                                        var I = (L = f.getNodeByIndex(R))._indexInList,
                                            O = h[I];
                                        if (O) {
                                            var P = L.fullPath;
                                            g[P] || (p[S] = -1, _[S] = I, u[P] = y, l[S] = O, S++);
                                        }
                                    }
                                    break;

                                case 1:
                                case 2:
                                    for (i._playType = 2, R = 0, C = l.length; R < C; R++) {
                                        var N = l[R];
                                        N.saveCrossFixedValue(), L = m[N.fullPath], _[R] = L ? L._indexInList : -1;
                                    }
                                    for (S = i._crossNodesOwnersCount, y = i._crossMark, R = 0, C = f.count; R < C; R++)(O = h[I = (L = f.getNodeByIndex(R))._indexInList]) && u[P = L.fullPath] !== y && (_[S] = I,
                                        u[P] = y, N = h[I], l[S] = N, N.saveCrossFixedValue(), S++);
                            }
                            i._crossNodesOwnersCount = S, i._crossPlayState = a, i._crossDuration = c._clip._duration * t,
                                n !== Number.NEGATIVE_INFINITY ? s._resetPlayState(d._duration * n) : s._resetPlayState(0);
                            var b = a._scripts;
                            if (b)
                                for (R = 0, C = b.length; R < C; R++) b[R].onStateEnter();
                        } else console.warn("Invalid name " + r + ".");
                    } else console.warn("Invalid layerIndex " + r + ".");
                }
            }, {
                key: "getCurrentAnimatorPlayState",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    return this._controllerLayers[e]._playStateInfo;
                }
            }, {
                key: "_isLinkSpriteToAnimationNodeData",
                value: function(e, t, r) {
                    var n = this._linkAvatarSpritesData[t];
                    if (r) n || (this._linkAvatarSpritesData[t] = n = []), n.push(e);
                    else {
                        var i = n.indexOf(e);
                        n.splice(i, 1);
                    }
                }
            }, {
                key: "_getAvatarOwnersAndInitDatasAsync",
                value: function() {
                    for (var e = 0, t = this._controllerLayers.length; e < t; e++)
                        for (var r = this._controllerLayers[e]._states, n = 0, i = r.length; n < i; n++) this._getOwnersByClip(r[n]);
                    for (var a in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                        var o = this._linkAvatarSpritesData[a];
                        if (o)
                            for (var s = 0, l = o.length; s < l; s++) this._isLinkSpriteToAnimationNode(o[s], a, !0);
                    }
                }
            }, {
                key: "_isLinkSpriteToAnimationNode",
                value: function(e, t, r) {
                    if (this._avatar) {
                        var n = this._avatarNodeMap[t];
                        if (n)
                            if (r) {
                                e._transform._dummy = n.transform, this._linkAvatarSprites.push(e);
                                var i = n.transform,
                                    a = e.transform;
                                if (!a.owner.isStatic && i) {
                                    var o = a.worldMatrix,
                                        s = this.owner._transform._parent;
                                    if (s) R.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), o);
                                    else
                                        for (var l = o.elements, u = i.getWorldMatrix(), c = 0; c < 16; c++) l[c] = u[c];
                                    a.worldMatrix = o;
                                }
                            } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
                    }
                }
            }, {
                key: "_updateAvatarNodesToSprite",
                value: function() {
                    for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                        var r = this._linkAvatarSprites[e],
                            n = r.transform._dummy,
                            i = r.transform;
                        if (!i.owner.isStatic && n) {
                            var a = i.worldMatrix,
                                o = this.owner._transform;
                            R.matrix4x4MultiplyMFM(o.worldMatrix, n.getWorldMatrix(), a), i.worldMatrix = a;
                        }
                    }
                }
            }, {
                key: "linkSprite3DToAvatarNode",
                value: function(e, t) {
                    return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), !0;
                }
            }, {
                key: "unLinkSprite3DToAvatarNode",
                value: function(e) {
                    var t = e.transform._dummy;
                    if (t) {
                        var r = t._owner.name;
                        return this._isLinkSpriteToAnimationNodeData(e, r, !1), this._isLinkSpriteToAnimationNode(e, r, !1), !0;
                    }
                    return !1;
                }
            }, {
                key: "_updateAnimationNodeWorldMatix",
                value: function(e, r, n, i, a) {
                    t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, n, a, i);
                }
            }, {
                key: "speed",
                get: function() {
                    return this._speed;
                },
                set: function(e) {
                    this._speed = e;
                }
            }, {
                key: "avatar",
                get: function() {
                    return this._avatar;
                },
                set: function(e) {
                    if (this._avatar !== e)
                        if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(),
                            this.owner._changeHierarchyAnimatorAvatar(this, e);
                        else {
                            var t = this.owner._parent;
                            this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
                        }
                }
            }], [{
                key: "_update",
                value: function(e) {
                    for (var t = e._animatorPool, r = t.elements, n = 0, i = t.length; n < i; n++) {
                        var a = r[n];
                        a && a.enabled && a._update();
                    }
                }
            }]), Animator;
        }();
    N._tempVector30 = new o(), N._tempVector31 = new o(), N._tempQuaternion0 = new f(),
        N._tempQuaternion1 = new f(), N.CULLINGMODE_ALWAYSANIMATE = 0, N.CULLINGMODE_CULLCOMPLETELY = 2;
    var b = function PostProcessRenderContext() {
            _classCallCheck(this, PostProcessRenderContext), this.source = null, this.destination = null,
                this.camera = null, this.compositeShaderData = null, this.command = null, this.deferredReleaseTextures = [];
        },
        k = function RenderContext3D() {
            _classCallCheck(this, RenderContext3D), this.invertY = !1;
        };
    k._instance = new k();
    var V = function(e) {
        function RenderTexture(e, r) {
            var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8,
                a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16;
            return _classCallCheck(this, RenderTexture), (n = _possibleConstructorReturn(this, _getPrototypeOf(RenderTexture).call(this, i, !1)))._inPool = !1,
                n._isCameraTarget = !1, n._glTextureType = t.LayaGL.instance.TEXTURE_2D, n._width = e,
                n._height = r, n._depthStencilFormat = a, n._mipmapCount = 1, n._create(e, r), n;
        }
        return _inherits(RenderTexture, t.BaseTexture), _createClass(RenderTexture, [{
            key: "_create",
            value: function(e, r) {
                var n = t.LayaGL.instance,
                    i = n,
                    a = this._glTextureType,
                    o = t.LayaGL.layaGPUInstance,
                    s = o._isWebGL2,
                    l = this._format;
                if (this._frameBuffer = n.createFramebuffer(), n.bindFramebuffer(n.FRAMEBUFFER, this._frameBuffer),
                    l !== t.RenderTextureFormat.Depth && l !== t.RenderTextureFormat.ShadowMap) {
                    switch (t.WebGLContext.bindTexture(n, a, this._glTexture), l) {
                        case t.RenderTextureFormat.R8G8B8:
                            s ? i.texStorage2D(a, this._mipmapCount, i.RGB8, e, r) : n.texImage2D(a, 0, n.RGB, e, r, 0, n.RGB, n.UNSIGNED_BYTE, null);
                            break;

                        case t.RenderTextureFormat.R8G8B8A8:
                            s ? i.texStorage2D(a, this._mipmapCount, i.RGBA8, e, r) : n.texImage2D(a, 0, n.RGBA, e, r, 0, n.RGBA, n.UNSIGNED_BYTE, null);
                            break;

                        case t.RenderTextureFormat.Alpha8:
                            s ? i.texStorage2D(a, 0, i.R8, e, r) : n.texImage2D(a, 0, n.ALPHA, e, r, 0, n.ALPHA, n.UNSIGNED_BYTE, null);
                            break;

                        case t.RenderTextureFormat.R16G16B16A16:
                            s ? i.texStorage2D(a, this._mipmapCount, i.RGBA16F, e, r) : n.texImage2D(a, 0, n.RGBA, e, r, 0, n.RGBA, o._oesTextureHalfFloat.HALF_FLOAT_OES, null);
                    }
                    n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, this._glTexture, 0);
                }
                if (l == t.RenderTextureFormat.Depth || l == t.RenderTextureFormat.ShadowMap) {
                    switch (t.WebGLContext.bindTexture(n, a, this._glTexture), this._depthStencilFormat) {
                        case t.RenderTextureDepthFormat.DEPTH_16:
                            s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH_COMPONENT16, e, r) : n.texImage2D(a, 0, n.DEPTH_COMPONENT, e, r, 0, n.DEPTH_COMPONENT, n.UNSIGNED_SHORT, null),
                                n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, this._glTexture, 0);
                            break;

                        case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                            s ? i.texStorage2D(a, this._mipmapCount, i.DEPTH24_STENCIL8, e, r) : n.texImage2D(a, 0, n.DEPTH_STENCIL, e, r, 0, n.DEPTH_STENCIL, o._webgl_depth_texture.UNSIGNED_INT_24_8_WEBGL, null),
                                n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, this._glTexture, 0);
                            break;

                        default:
                            throw "RenderTexture: depth format RenderTexture must use depthFormat with DEPTH_16 and DEPTHSTENCIL_16_8.";
                    }
                    s && l == t.RenderTextureFormat.ShadowMap && i.texParameteri(a, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE);
                } else if (this._depthStencilFormat !== t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE) {
                    switch (this._depthStencilBuffer = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, this._depthStencilBuffer),
                        this._depthStencilFormat) {
                        case t.RenderTextureDepthFormat.DEPTH_16:
                            n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, e, r), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                            break;

                        case t.RenderTextureDepthFormat.STENCIL_8:
                            n.renderbufferStorage(n.RENDERBUFFER, n.STENCIL_INDEX8, e, r), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.STENCIL_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                            break;

                        case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                            n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_STENCIL, e, r), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, this._depthStencilBuffer);
                            break;

                        default:
                            throw "RenderTexture: unkonw depth format.";
                    }
                    n.bindRenderbuffer(n.RENDERBUFFER, null);
                }
                n.bindFramebuffer(n.FRAMEBUFFER, null), this._setWarpMode(n.TEXTURE_WRAP_S, this._wrapModeU),
                    this._setWarpMode(n.TEXTURE_WRAP_T, this._wrapModeV), this._setFilterMode(this._filterMode),
                    this._setAnisotropy(this._anisoLevel), this._readyed = !0, this._activeResource(),
                    this._setGPUMemory(e * r * 4);
            }
        }, {
            key: "_start",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), RenderTexture._currentActive = this,
                    this._isCameraTarget && (k._instance.invertY = !0), this._readyed = !1;
            }
        }, {
            key: "_end",
            value: function() {
                var e = t.LayaGL.instance;
                e.bindFramebuffer(e.FRAMEBUFFER, null), RenderTexture._currentActive = null, this._isCameraTarget && (k._instance.invertY = !1),
                    this._readyed = !0;
            }
        }, {
            key: "getData",
            value: function(e, r, n, i, a) {
                if (t.Render.isConchApp && 2 == window.conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
                var o = t.LayaGL.instance;
                return o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o.checkFramebufferStatus(o.FRAMEBUFFER) === o.FRAMEBUFFER_COMPLETE ? (o.readPixels(e, r, n, i, o.RGBA, o.UNSIGNED_BYTE, a),
                    o.bindFramebuffer(o.FRAMEBUFFER, null), a) : (o.bindFramebuffer(o.FRAMEBUFFER, null),
                    null);
            }
        }, {
            key: "_disposeResource",
            value: function() {
                if (this._frameBuffer) {
                    var e = t.LayaGL.instance;
                    e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer),
                        this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null,
                        this._setGPUMemory(0);
                }
            }
        }, {
            key: "getDataAsync",
            value: function(e, r, n, i, a) {
                var o = t.LayaGL.instance;
                o.bindFramebuffer(o.FRAMEBUFFER, this._frameBuffer), o.readPixelsAsync(e, r, n, i, o.RGBA, o.UNSIGNED_BYTE, function(e) {
                    a(new Uint8Array(e));
                }), o.bindFramebuffer(o.FRAMEBUFFER, null);
            }
        }, {
            key: "depthStencilFormat",
            get: function() {
                return this._depthStencilFormat;
            }
        }, {
            key: "defaulteTexture",
            get: function() {
                return t.Texture2D.grayTexture;
            }
        }], [{
            key: "createFromPool",
            value: function(e, r) {
                for (var n, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t.RenderTextureFormat.R8G8B8, a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.RenderTextureDepthFormat.DEPTH_16, o = 0, s = RenderTexture._pool.length; o < s; o++)
                    if ((n = RenderTexture._pool[o])._width == e && n._height == r && n._format == i && n._depthStencilFormat == a) {
                        n._inPool = !1;
                        var l = RenderTexture._pool[s - 1];
                        return RenderTexture._pool[o] = l, RenderTexture._pool.length -= 1, n;
                    }
                return (n = new RenderTexture(e, r, i, a)).lock = !0, n;
            }
        }, {
            key: "recoverToPool",
            value: function(e) {
                e._inPool || (RenderTexture._pool.push(e), e._inPool = !0);
            }
        }, {
            key: "currentActive",
            get: function() {
                return RenderTexture._currentActive;
            }
        }]), RenderTexture;
    }();
    V._pool = [];
    var B = function() {
            function DefineDatas() {
                _classCallCheck(this, DefineDatas), this._mask = [], this._length = 0;
            }
            return _createClass(DefineDatas, [{
                key: "_intersectionDefineDatas",
                value: function(e) {
                    for (var t = e._mask, r = this._mask, n = this._length - 1; n >= 0; n--) {
                        var i = r[n] & t[n];
                        0 == i && n == this._length - 1 ? this._length-- : r[n] = i;
                    }
                }
            }, {
                key: "add",
                value: function(e) {
                    var t = e._index,
                        r = t + 1,
                        n = this._mask,
                        i = this._length;
                    if (i < r) {
                        for (n.length < r && (n.length = r); i < t; i++) n[i] = 0;
                        n[t] = e._value, this._length = r;
                    } else r > this._length ? (n[t] = e._value, this._length = r) : n[t] |= e._value;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._index,
                        r = this._mask,
                        n = this._length - 1;
                    if (!(t > n)) {
                        var i = r[t] & ~e._value;
                        t == n && 0 === i ? this._length-- : r[t] = i;
                    }
                }
            }, {
                key: "addDefineDatas",
                value: function(e) {
                    var t = e._mask,
                        r = e._length,
                        n = this._mask,
                        i = n.length;
                    if (i < r) {
                        n.length = r;
                        for (var a = 0; a < i; a++) n[a] |= t[a];
                        for (; i < r; i++) n[i] = t[i];
                        this._length = r;
                    } else {
                        for (a = 0; a < r; a++) n[a] |= t[a];
                        this._length = Math.max(this._length, r);
                    }
                }
            }, {
                key: "removeDefineDatas",
                value: function(e) {
                    for (var t = e._mask, r = this._mask, n = this._length - 1, i = e._length - 1; i >= 0; i--)
                        if (!(i > n)) {
                            var a = r[i] & ~t[i];
                            i == n && 0 === a ? (n--, this._length--) : r[i] = a;
                        }
                }
            }, {
                key: "has",
                value: function(e) {
                    var t = e._index;
                    return !(t >= this._length) && 0 != (this._mask[t] & e._value);
                }
            }, {
                key: "clear",
                value: function() {
                    this._length = 0;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e,
                        r = t._mask,
                        n = this._mask,
                        i = this._length;
                    r.length = i;
                    for (var a = 0; a < i; a++) r[a] = n[a];
                    t._length = i;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new DefineDatas();
                    return this.cloneTo(e), e;
                }
            }]), DefineDatas;
        }(),
        w = function ShaderDefine(e, t) {
            _classCallCheck(this, ShaderDefine), this._index = e, this._value = t;
        },
        F = function() {
            function ShaderVariant(e, t, r, n) {
                _classCallCheck(this, ShaderVariant), this._subShaderIndex = 0, this._passIndex = 0,
                    this.setValue(e, t, r, n);
            }
            return _createClass(ShaderVariant, [{
                key: "setValue",
                value: function(e, t, r, n) {
                    if (!e) throw "ShaderVariantInfo:Shader can't be null.";
                    var i = e.getSubShaderAt(t);
                    if (!i) throw "ShaderVariantInfo:Shader don't have subShaderIndex of ".concat(t, ".");
                    var a = i._passes[r];
                    if (!a) throw "ShaderVariantInfo:Shader don't have passIndex of ".concat(r, ".");
                    for (var o = a._validDefine, s = 0, u = n.length; s < u; s++) {
                        var c = n[s];
                        if (!o.has(l.Shader3D.getDefineByName(c))) throw "ShaderVariantInfo:Invalid defineName ".concat(c, " in ").concat(e._name, " subShaderIndex of ").concat(t, " passIndex of ").concat(r, ".");
                    }
                    this._shader = e, this._subShaderIndex = t, this._passIndex = r, this._defineNames = n;
                }
            }, {
                key: "equal",
                value: function(e) {
                    if (this._shader !== e._shader || this._subShaderIndex !== e._subShaderIndex || this._passIndex !== e._passIndex) return !1;
                    var t = this._defineNames,
                        r = e._defineNames;
                    if (t.length !== r.length) return !1;
                    for (var n = 0, i = this._defineNames.length; n < i; n++)
                        if (t[n] !== r[n]) return !1;
                    return !0;
                }
            }, {
                key: "clone",
                value: function() {
                    return new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
                }
            }, {
                key: "shader",
                get: function() {
                    return this._shader;
                }
            }, {
                key: "subShaderIndex",
                get: function() {
                    return this._subShaderIndex;
                }
            }, {
                key: "passIndex",
                get: function() {
                    return this._passIndex;
                }
            }, {
                key: "defineNames",
                get: function() {
                    return this._defineNames;
                }
            }]), ShaderVariant;
        }(),
        U = function() {
            function ShaderVariantCollection() {
                _classCallCheck(this, ShaderVariantCollection), this._allCompiled = !1, this._variants = [];
            }
            return _createClass(ShaderVariantCollection, [{
                key: "add",
                value: function(e) {
                    for (var t = 0, r = this._variants.length; t < r; t++)
                        if (this._variants[t].equal(e)) return !1;
                    return this._variants.push(e.clone()), this._allCompiled = !1, !0;
                }
            }, {
                key: "remove",
                value: function(e) {
                    for (var t = 0, r = this._variants.length; t < r; t++)
                        if (this._variants[t].equal(e)) return this._variants.splice(t, 1), !0;
                    return !1;
                }
            }, {
                key: "contatins",
                value: function(e) {
                    for (var t = 0, r = this._variants.length; t < r; t++)
                        if (this._variants[t].equal(e)) return !0;
                    return !1;
                }
            }, {
                key: "getByIndex",
                value: function(e) {
                    return this._variants[e];
                }
            }, {
                key: "clear",
                value: function() {
                    this._variants.length = 0;
                }
            }, {
                key: "compile",
                value: function() {
                    if (!this._allCompiled) {
                        for (var e = this._variants, t = 0, r = e.length; t < r; t++) {
                            var n = e[t];
                            l.Shader3D.compileShaderByDefineNames(n._shader._name, n._subShaderIndex, n._passIndex, n._defineNames);
                        }
                        this._allCompiled = !0;
                    }
                }
            }, {
                key: "allCompiled",
                get: function() {
                    return this._allCompiled;
                }
            }, {
                key: "variantCount",
                get: function() {
                    return this._variants.length;
                }
            }]), ShaderVariantCollection;
        }(),
        G = function() {
            function Shader3D(e, t, r, n) {
                _classCallCheck(this, Shader3D), this._attributeMap = null, this._uniformMap = null,
                    this._enableInstancing = !1, this._subShaders = [], this._name = e, this._attributeMap = t,
                    this._uniformMap = r, this._enableInstancing = n;
            }
            return _createClass(Shader3D, [{
                key: "addSubShader",
                value: function(e) {
                    this._subShaders.push(e), e._owner = this;
                }
            }, {
                key: "getSubShaderAt",
                value: function(e) {
                    return this._subShaders[e];
                }
            }, {
                key: "name",
                get: function() {
                    return this._name;
                }
            }], [{
                key: "_getNamesByDefineData",
                value: function(e, t) {
                    var r = Shader3D._maskMap,
                        n = e._mask;
                    t.length = 0;
                    for (var i = 0, a = e._length; i < a; i++)
                        for (var o = r[i], s = n[i], l = 0; l < 32; l++) {
                            var u = 1 << l;
                            if (s > 0 && u > s) break;
                            s & u && t.push(o[u]);
                        }
                }
            }, {
                key: "getDefineByName",
                value: function(e) {
                    var t = Shader3D._defineMap[e];
                    if (!t) {
                        var r = Shader3D._maskMap,
                            n = Shader3D._defineCounter,
                            i = Math.floor(n / 32),
                            a = 1 << n % 32;
                        t = new w(i, a), Shader3D._defineMap[e] = t, i == r.length && (r.length++, r[i] = {}),
                            r[i][a] = e, Shader3D._defineCounter++;
                    }
                    return t;
                }
            }, {
                key: "propertyNameToID",
                value: function(e) {
                    if (null != Shader3D._propertyNameMap[e]) return Shader3D._propertyNameMap[e];
                    var t = Shader3D._propertyNameCounter++;
                    return Shader3D._propertyNameMap[e] = t, t;
                }
            }, {
                key: "addInclude",
                value: function(e, r) {
                    r = r.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, r);
                }
            }, {
                key: "compileShaderByDefineNames",
                value: function(e, t, r, n) {
                    var i = Shader3D.find(e);
                    if (i) {
                        var a = i.getSubShaderAt(t);
                        if (a) {
                            var o = a._passes[r];
                            if (o) {
                                var s = Shader3D._compileDefineDatas;
                                s.clear();
                                for (var l = 0, u = n.length; l < u; l++) s.add(Shader3D.getDefineByName(n[l]));
                                o.withCompile(s);
                            } else console.warn("Shader3D: unknown passIndex.");
                        } else console.warn("Shader3D: unknown subShaderIndex.");
                    } else console.warn("Shader3D: unknown shader name.");
                }
            }, {
                key: "add",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    return Shader3D._preCompileShader[e] = new Shader3D(e, t, r, n);
                }
            }, {
                key: "find",
                value: function(e) {
                    return Shader3D._preCompileShader[e];
                }
            }, {
                key: "compileShader",
                value: function(e, t, r) {
                    var n = Shader3D.find(e);
                    if (n) {
                        var i = n.getSubShaderAt(t);
                        if (i) {
                            var a = i._passes[r];
                            if (a) {
                                var o = Shader3D._compileDefineDatas,
                                    s = o._mask;
                                s.length = 0;
                                for (var l = 0, u = arguments.length <= 3 ? 0 : arguments.length - 3; l < u; l++) s.push(l + 3 < 3 || arguments.length <= l + 3 ? void 0 : arguments[l + 3]);
                                o._length = arguments.length <= 3 ? 0 : arguments.length - 3, a.withCompile(o);
                            } else console.warn("Shader3D: unknown passIndex.");
                        } else console.warn("Shader3D: unknown subShaderIndex.");
                    } else console.warn("Shader3D: unknown shader name.");
                }
            }]), Shader3D;
        }();
    G._compileDefineDatas = new B(), G.RENDER_STATE_CULL = 0, G.RENDER_STATE_BLEND = 1,
        G.RENDER_STATE_BLEND_SRC = 2, G.RENDER_STATE_BLEND_DST = 3, G.RENDER_STATE_BLEND_SRC_RGB = 4,
        G.RENDER_STATE_BLEND_DST_RGB = 5, G.RENDER_STATE_BLEND_SRC_ALPHA = 6, G.RENDER_STATE_BLEND_DST_ALPHA = 7,
        G.RENDER_STATE_BLEND_CONST_COLOR = 8, G.RENDER_STATE_BLEND_EQUATION = 9, G.RENDER_STATE_BLEND_EQUATION_RGB = 10,
        G.RENDER_STATE_BLEND_EQUATION_ALPHA = 11, G.RENDER_STATE_DEPTH_TEST = 12, G.RENDER_STATE_DEPTH_WRITE = 13,
        G.PERIOD_CUSTOM = 0, G.PERIOD_MATERIAL = 1, G.PERIOD_SPRITE = 2, G.PERIOD_CAMERA = 3,
        G.PERIOD_SCENE = 4, G._propertyNameCounter = 0, G._propertyNameMap = {}, G._defineCounter = 0,
        G._defineMap = {}, G._preCompileShader = {}, G._maskMap = [], G.debugMode = !1,
        G.debugShaderVariantCollection = new U();
    var z = function() {
        function ShaderData() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
            _classCallCheck(this, ShaderData), this._ownerResource = null, this._data = null,
                this._defineDatas = new B(), this._runtimeCopyValues = [], this._ownerResource = e,
                this._initData();
        }
        return _createClass(ShaderData, [{
            key: "_initData",
            value: function() {
                this._data = new Object();
            }
        }, {
            key: "getData",
            value: function() {
                return this._data;
            }
        }, {
            key: "addDefine",
            value: function(e) {
                this._defineDatas.add(e);
            }
        }, {
            key: "removeDefine",
            value: function(e) {
                this._defineDatas.remove(e);
            }
        }, {
            key: "hasDefine",
            value: function(e) {
                return this._defineDatas.has(e);
            }
        }, {
            key: "clearDefine",
            value: function() {
                this._defineDatas.clear();
            }
        }, {
            key: "getBool",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBool",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getInt",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setInt",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getNumber",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setNumber",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector2",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector2",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector3",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector3",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getVector",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setVector",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getQuaternion",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setQuaternion",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getMatrix4x4",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setMatrix4x4",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getBuffer",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setBuffer",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "setTexture",
            value: function(e, t) {
                var r = this._data[e];
                this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                    t && t._addReference());
            }
        }, {
            key: "getTexture",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "setAttribute",
            value: function(e, t) {
                this._data[e] = t;
            }
        }, {
            key: "getAttribute",
            value: function(e) {
                return this._data[e];
            }
        }, {
            key: "getLength",
            value: function() {
                return this._data.length;
            }
        }, {
            key: "setLength",
            value: function(e) {
                this._data.length = e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var r = e,
                    a = r._data;
                for (var s in this._data) {
                    var l = this._data[s];
                    if (null != l)
                        if ("number" == typeof l) a[s] = l;
                        else if ("number" == typeof l) a[s] = l;
                    else if ("boolean" == typeof l) a[s] = l;
                    else if (l instanceof n) {
                        var u = a[s] || (a[s] = new n());
                        l.cloneTo(u), a[s] = u;
                    } else if (l instanceof o) {
                        var c = a[s] || (a[s] = new o());
                        l.cloneTo(c), a[s] = c;
                    } else if (l instanceof i) {
                        var h = a[s] || (a[s] = new i());
                        l.cloneTo(h), a[s] = h;
                    } else if (l instanceof L) {
                        var _ = a[s] || (a[s] = new L());
                        l.cloneTo(_), a[s] = _;
                    } else l instanceof t.BaseTexture && (a[s] = l);
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShaderData();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneToForNative",
            value: function(e) {
                var r = e;
                this._int32Data.length - r._int32Data.length > 0 && r.needRenewArrayBufferForNative(this._int32Data.length),
                    r._int32Data.set(this._int32Data, 0);
                var a = r._nativeArray,
                    s = this._nativeArray.length;
                a.length = s;
                for (var l = 0; l < s; l++) {
                    var u = this._nativeArray[l];
                    if (u)
                        if ("number" == typeof u) a[l] = u, r.setNumber(l, u);
                        else if ("number" == typeof u) a[l] = u,
                        r.setInt(l, u);
                    else if ("boolean" == typeof u) a[l] = u, r.setBool(l, u);
                    else if (u instanceof n) {
                        var c = a[l] || (a[l] = new n());
                        u.cloneTo(c), a[l] = c, r.setVector2(l, c);
                    } else if (u instanceof o) {
                        var h = a[l] || (a[l] = new o());
                        u.cloneTo(h), a[l] = h, r.setVector3(l, h);
                    } else if (u instanceof i) {
                        var _ = a[l] || (a[l] = new i());
                        u.cloneTo(_), a[l] = _, r.setVector(l, _);
                    } else if (u instanceof L) {
                        var d = a[l] || (a[l] = new L());
                        u.cloneTo(d), a[l] = d, r.setMatrix4x4(l, d);
                    } else u instanceof t.BaseTexture && (a[l] = u, r.setTexture(l, u));
                }
                this._defineDatas.cloneTo(r._defineDatas);
            }
        }, {
            key: "_initDataForNative",
            value: function() {
                this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [],
                    this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data),
                    this._float32Data = new Float32Array(this._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
            }
        }, {
            key: "needRenewArrayBufferForNative",
            value: function(e) {
                if (e >= this._int32Data.length) {
                    var r = 4 * (e + 1),
                        n = this._int32Data,
                        i = this._data.conchRef,
                        a = this._data._ptrID;
                    this._data = new ArrayBuffer(r), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data),
                        this._data.conchRef = i, this._data._ptrID = a, n && this._int32Data.set(n, 0);
                    var o = t.LayaGL.instance;
                    o.updateArrayBufferRef ? o.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data) : window.conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
                }
            }
        }, {
            key: "getDataForNative",
            value: function() {
                return this._nativeArray;
            }
        }, {
            key: "getIntForNative",
            value: function(e) {
                return this._int32Data[e];
            }
        }, {
            key: "setIntForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getBoolForNative",
            value: function(e) {
                return 1 == this._int32Data[e];
            }
        }, {
            key: "setBoolForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this._nativeArray[e] = t;
            }
        }, {
            key: "getNumberForNative",
            value: function(e) {
                return this._float32Data[e];
            }
        }, {
            key: "setNumberForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
            }
        }, {
            key: "getMatrix4x4ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setMatrix4x4ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVectorForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVectorForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector2ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector2ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getVector3ForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setVector3ForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getQuaternionForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setQuaternionForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
                var r = this.setReferenceForNative(t.elements);
                this._int32Data[e] = r;
            }
        }, {
            key: "getBufferForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setBufferForNative",
            value: function(e, t) {
                this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
                var r = this.setReferenceForNative(t);
                this._int32Data[e] = r;
            }
        }, {
            key: "getAttributeForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setAttributeForNative",
            value: function(e, r) {
                this._nativeArray[e] = r, r._ptrID || t.LayaGL.instance.createArrayBufferRef(r, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0),
                    t.LayaGL.instance.syncBufferToRenderThread(r), this._int32Data[e] = r._ptrID;
            }
        }, {
            key: "getTextureForNative",
            value: function(e) {
                return this._nativeArray[e];
            }
        }, {
            key: "setTextureForNative",
            value: function(e, t) {
                if (t) {
                    this.needRenewArrayBufferForNative(e);
                    var r = this._nativeArray[e];
                    this._nativeArray[e] = t;
                    var n = t._getSource() || t.defaulteTexture._getSource();
                    this._int32Data[e] = n.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                        t && t._addReference());
                }
            }
        }, {
            key: "setReferenceForNative",
            value: function(e) {
                this.clearRuntimeCopyArray();
                var r = 0,
                    n = 0;
                return ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE),
                    r = 0, n = e.getPtrID(r)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY),
                    r = e.getRefNum() - 1, n = e.getPtrID(r), this._runtimeCopyValues.push({
                        obj: e,
                        refID: r,
                        ptrID: n
                    })), t.LayaGL.instance.syncBufferToRenderThread(e, r), n;
            }
        }, {
            key: "clearRuntimeCopyArray",
            value: function() {
                var e = t.Stat.loopCount;
                if (this._frameCount != e) {
                    this._frameCount = e;
                    for (var r = 0, n = this._runtimeCopyValues.length; r < n; r++) {
                        this._runtimeCopyValues[r].obj.clearRefNum();
                    }
                    this._runtimeCopyValues.length = 0;
                }
            }
        }], [{
            key: "setRuntimeValueMode",
            value: function(e) {
                ShaderData._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
            }
        }]), ShaderData;
    }();
    z._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    var H = function() {
        function PostProcess() {
            _classCallCheck(this, PostProcess), this._compositeShader = G.find("PostProcessComposite"),
                this._compositeShaderData = new z(), this._effects = [], this._context = null, this._context = new b(),
                this._context.compositeShaderData = this._compositeShaderData;
        }
        return _createClass(PostProcess, [{
            key: "_init",
            value: function(e, t) {
                this._context.camera = e, this._context.command = t;
            }
        }, {
            key: "_render",
            value: function() {
                var e = z._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(!1);
                var r = this._context.camera,
                    n = r.viewport,
                    i = V.createFromPool(k.clientWidth, k.clientHeight, r._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE),
                    a = r._internalRenderTexture;
                this._context.command.clear(), this._context.source = i, this._context.destination = a,
                    this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(a, i),
                    this._context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                for (var o = 0, s = this._effects.length; o < s; o++) this._effects[o].render(this._context);
                this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
                var l = r._offScreenRenderTexture,
                    u = l || null;
                this._context.destination = u;
                var c = r._getCanvasWidth(),
                    h = r._getCanvasHeight();
                r._screenOffsetScale.setValue(n.x / c, n.y / h, n.width / c, n.height / h), this._context.command.blitScreenTriangle(this._context.source, u, r._screenOffsetScale, this._compositeShader, this._compositeShaderData),
                    V.recoverToPool(i);
                var _ = this._context.deferredReleaseTextures;
                for (o = 0, s = _.length; o < s; o++) V.recoverToPool(_[o]);
                _.length = 0, t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(e);
            }
        }, {
            key: "addEffect",
            value: function(e) {
                this._effects.push(e);
            }
        }, {
            key: "removeEffect",
            value: function(e) {
                var t = this._effects.indexOf(e); -
                1 !== t && this._effects.splice(t, 1);
            }
        }], [{
            key: "__init__",
            value: function() {
                PostProcess.SHADERDEFINE_BLOOM_LOW = G.getDefineByName("BLOOM_LOW"), PostProcess.SHADERDEFINE_BLOOM = G.getDefineByName("BLOOM"),
                    PostProcess.SHADERDEFINE_FINALPASS = G.getDefineByName("FINALPASS");
            }
        }]), PostProcess;
    }();
    H.SHADERVALUE_MAINTEX = G.propertyNameToID("u_MainTex"), H.SHADERVALUE_BLOOMTEX = G.propertyNameToID("u_BloomTex"),
        H.SHADERVALUE_AUTOEXPOSURETEX = G.propertyNameToID("u_AutoExposureTex"), H.SHADERVALUE_BLOOM_DIRTTEX = G.propertyNameToID("u_Bloom_DirtTex"),
        H.SHADERVALUE_BLOOMTEX_TEXELSIZE = G.propertyNameToID("u_BloomTex_TexelSize"), H.SHADERVALUE_BLOOM_DIRTTILEOFFSET = G.propertyNameToID("u_Bloom_DirtTileOffset"),
        H.SHADERVALUE_BLOOM_SETTINGS = G.propertyNameToID("u_Bloom_Settings"), H.SHADERVALUE_BLOOM_COLOR = G.propertyNameToID("u_Bloom_Color");
    var W = function(e) {
        function AnimationTransform3D(e) {
            var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
            return _classCallCheck(this, AnimationTransform3D), (r = _possibleConstructorReturn(this, _getPrototypeOf(AnimationTransform3D).call(this)))._owner = e,
                r._children = [], r._localMatrix = new Float32Array(16), t.Render.supportWebGLPlusAnimation ? (r._localPosition = new A(0, 0, 0, n),
                    r._localRotation = new I(0, 0, 0, 1, i), r._localScale = new A(0, 0, 0, a), r._worldMatrix = s) : (r._localPosition = new o(),
                    r._localRotation = new f(), r._localScale = new o(), r._worldMatrix = new Float32Array(16)),
                r._localQuaternionUpdate = !1, r._locaEulerlUpdate = !1, r._localUpdate = !1, r._worldUpdate = !0,
                r;
        }
        return _inherits(AnimationTransform3D, t.EventDispatcher), _createClass(AnimationTransform3D, [{
            key: "_getlocalMatrix",
            value: function() {
                return this._localUpdate && (R._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix),
                    this._localUpdate = !1), this._localMatrix;
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!this._worldUpdate) {
                    this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "getWorldMatrix",
            value: function() {
                if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                    if (null != this._parent) R.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                    else {
                        var e = this._worldMatrix;
                        e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                            e[0] = e[5] = e[10] = e[15] = 1;
                    }
                    this._worldUpdate = !1;
                }
                return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1),
                    this._worldMatrix;
            }
        }, {
            key: "setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children,
                            r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._localQuaternionUpdate) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / AnimationTransform3D._angleToRandin, e.x / AnimationTransform3D._angleToRandin, e.z / AnimationTransform3D._angleToRandin, this._localRotation),
                        this._localQuaternionUpdate = !1;
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1,
                    this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._locaEulerlUpdate) {
                    this._localRotation.getYawPitchRoll(AnimationTransform3D._tempVector3);
                    var e = AnimationTransform3D._tempVector3,
                        t = this._localRotationEuler;
                    t.x = e.y * AnimationTransform3D._angleToRandin, t.y = e.x * AnimationTransform3D._angleToRandin,
                        t.z = e.z * AnimationTransform3D._angleToRandin, this._locaEulerlUpdate = !1;
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0,
                    this._localUpdate = !0, this._onWorldTransform();
            }
        }]), AnimationTransform3D;
    }();
    W._tempVector3 = new o(), W._angleToRandin = 180 / Math.PI;
    var X = function() {
            function AnimationNode() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                _classCallCheck(this, AnimationNode), this._children = [], this.transform = new W(this, e, t, r, n);
            }
            return _createClass(AnimationNode, [{
                key: "addChild",
                value: function(e) {
                    e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
                }
            }, {
                key: "removeChild",
                value: function(e) {
                    var t = this._children.indexOf(e); -
                    1 !== t && this._children.splice(t, 1);
                }
            }, {
                key: "getChildByName",
                value: function(e) {
                    for (var t = 0, r = this._children.length; t < r; t++) {
                        var n = this._children[t];
                        if (n.name === e) return n;
                    }
                    return null;
                }
            }, {
                key: "getChildByIndex",
                value: function(e) {
                    return this._children[e];
                }
            }, {
                key: "getChildCount",
                value: function() {
                    return this._children.length;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.name = this.name;
                    for (var r = 0, n = this._children.length; r < n; r++) {
                        var i = this._children[r],
                            a = i.clone();
                        t.addChild(a);
                        var o = i.transform,
                            s = a.transform,
                            l = s.localPosition,
                            u = s.localRotation,
                            c = s.localScale;
                        o.localPosition.cloneTo(l), o.localRotation.cloneTo(u), o.localScale.cloneTo(c),
                            s.localPosition = l, s.localRotation = u, s.localScale = c;
                    }
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new AnimationNode();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "_cloneNative",
                value: function(e, t, r, n, i, a, o) {
                    var s = o._nativeCurCloneCount;
                    i[s] = a;
                    var l = new AnimationNode(new Float32Array(e.buffer, 3 * s * 4, 3), new Float32Array(t.buffer, 4 * s * 4, 4), new Float32Array(r.buffer, 3 * s * 4, 3), new Float32Array(n.buffer, 16 * s * 4, 16));
                    return l._worldMatrixIndex = s, this._cloneToNative(l, e, t, r, n, i, s, o), l;
                }
            }, {
                key: "_cloneToNative",
                value: function(e, t, r, n, i, a, o, s) {
                    var l = e;
                    l.name = this.name;
                    for (var u = 0, c = this._children.length; u < c; u++) {
                        var h = this._children[u];
                        s._nativeCurCloneCount++;
                        var _ = h._cloneNative(t, r, n, i, a, o, s);
                        l.addChild(_);
                        var d = h.transform,
                            f = _.transform,
                            m = f.localPosition,
                            T = f.localRotation,
                            p = f.localScale;
                        d.localPosition.cloneTo(m), d.localRotation.cloneTo(T), d.localScale.cloneTo(p),
                            f.localPosition = m, f.localRotation = T, f.localScale = p;
                    }
                }
            }]), AnimationNode;
        }(),
        Y = function(e) {
            function Avatar() {
                var e;
                return _classCallCheck(this, Avatar), (e = _possibleConstructorReturn(this, _getPrototypeOf(Avatar).call(this)))._nativeNodeCount = 0,
                    e._nativeCurCloneCount = 0, e;
            }
            return _inherits(Avatar, t.Resource), _createClass(Avatar, [{
                key: "_initCloneToAnimator",
                value: function(e, t) {
                    t._avatarNodeMap[e.name] = e;
                    for (var r = 0, n = e.getChildCount(); r < n; r++) this._initCloneToAnimator(e.getChildByIndex(r), t);
                }
            }, {
                key: "_parseNode",
                value: function(e, r) {
                    var n = e.props.name;
                    r.name = n;
                    var i = e.props,
                        a = r.transform,
                        o = a.localPosition,
                        s = a.localRotation,
                        l = a.localScale;
                    o.fromArray(i.translate), s.fromArray(i.rotation), l.fromArray(i.scale), a.localPosition = o,
                        a.localRotation = s, a.localScale = l;
                    for (var u = e.child, c = 0, h = u.length; c < h; c++) {
                        var _ = u[c],
                            d = new X(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                        r.addChild(d), t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(_, d);
                    }
                }
            }, {
                key: "_cloneDatasToAnimator",
                value: function(e) {
                    var t;
                    t = this._rootNode.clone();
                    var r = this._rootNode.transform,
                        n = t.transform,
                        i = n.localPosition,
                        a = n.localRotation,
                        o = n.localScale;
                    r.localPosition.cloneTo(i), r.localRotation.cloneTo(a), r.localScale.cloneTo(o),
                        n.localPosition = i, n.localRotation = a, n.localScale = o, e._avatarNodeMap = {},
                        this._initCloneToAnimator(t, e);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e,
                        r = this._rootNode.clone();
                    t._rootNode = r;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Avatar();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "_cloneDatasToAnimatorNative",
                value: function(e) {
                    var t = new Float32Array(3 * this._nativeNodeCount),
                        r = new Float32Array(4 * this._nativeNodeCount),
                        n = new Float32Array(3 * this._nativeNodeCount),
                        i = new Float32Array(16 * this._nativeNodeCount),
                        a = new Int16Array(this._nativeNodeCount);
                    e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = r, e._animationNodeLocalScales = n,
                        e._animationNodeWorldMatrixs = i, e._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
                    var o = this._rootNode._cloneNative(t, r, n, i, a, -1, this),
                        s = this._rootNode.transform,
                        l = o.transform,
                        u = l.localPosition,
                        c = l.localRotation,
                        h = l.localScale;
                    s.localPosition.cloneTo(u), s.localRotation.cloneTo(c), s.localScale.cloneTo(h),
                        l.localPosition = u, l.localRotation = c, l.localScale = h, e._avatarNodeMap = {},
                        this._initCloneToAnimator(o, e);
                }
            }], [{
                key: "_parse",
                value: function(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    var r = new Avatar();
                    if (r._rootNode = new X(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)),
                        t.Render.supportWebGLPlusAnimation && r._nativeNodeCount++, e.version) {
                        var n = e.rootNode;
                        n && r._parseNode(n, r._rootNode);
                    }
                    return r;
                }
            }, {
                key: "load",
                value: function(e, r) {
                    t.ILaya.loader.create(e, r, null, Avatar.AVATAR);
                }
            }]), Avatar;
        }();
    Y.AVATAR = "AVATAR";
    var j = function(e) {
        function Material() {
            var e;
            return _classCallCheck(this, Material), (e = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this)))._shaderValues = null,
                e._shaderValues = new z(_assertThisInitialized(e)), e.renderQueue = Material.RENDERQUEUE_OPAQUE,
                e._alphaTest = !1, e;
        }
        return _inherits(Material, t.Resource), _createClass(Material, [{
            key: "_removeTetxureReference",
            value: function() {
                var e = this._shaderValues.getData();
                for (var r in e) {
                    var n = e[r];
                    n && n instanceof t.BaseTexture && n._removeReference();
                }
            }
        }, {
            key: "_disposeResource",
            value: function() {
                this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
            }
        }, {
            key: "_addReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_addReference", this).call(this, e);
                var r = this._shaderValues.getData();
                for (var n in r) {
                    var i = r[n];
                    i && i instanceof t.BaseTexture && i._addReference();
                }
            }
        }, {
            key: "_removeReference",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1;
                _get(_getPrototypeOf(Material.prototype), "_removeReference", this).call(this, e),
                    this._removeTetxureReference();
            }
        }, {
            key: "setShaderName",
            value: function(e) {
                if (this._shader = G.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.name = this.name, t.renderQueue = this.renderQueue, this._shaderValues.cloneTo(t._shaderValues);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Material();
                return this.cloneTo(e), e;
            }
        }, {
            key: "shaderData",
            get: function() {
                return this._shaderValues;
            }
        }, {
            key: "alphaTestValue",
            get: function() {
                return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Material.ALPHATESTVALUE, e);
            }
        }, {
            key: "alphaTest",
            get: function() {
                return this._alphaTest;
            },
            set: function(e) {
                this._alphaTest = e, e ? this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
            }
        }, {
            key: "_defineDatas",
            get: function() {
                return this._shaderValues._defineDatas;
            }
        }], [{
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, Material.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                Material.SHADERDEFINE_ALPHATEST = G.getDefineByName("ALPHATEST");
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                var r, a = e,
                    s = a.props,
                    l = s.type,
                    u = t.ClassUtils.getRegClass(l);
                if (!u) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
                switch (r = new u(), a.version) {
                    case "LAYAMATERIAL:01":
                    case "LAYAMATERIAL:02":
                        var c, h;
                        for (var _ in s) switch (_) {
                            case "type":
                                break;

                            case "vectors":
                                var d = s[_];
                                for (c = 0, h = d.length; c < h; c++) {
                                    var f = d[c],
                                        m = f.value;
                                    switch (m.length) {
                                        case 2:
                                            r[f.name] = new n(m[0], m[1]);
                                            break;

                                        case 3:
                                            r[f.name] = new o(m[0], m[1], m[2]);
                                            break;

                                        case 4:
                                            r[f.name] = new i(m[0], m[1], m[2], m[3]);
                                            break;

                                        default:
                                            throw new Error("BaseMaterial:unkonwn color length.");
                                    }
                                }
                                break;

                            case "textures":
                                var T = s[_];
                                for (c = 0, h = T.length; c < h; c++) {
                                    var p = T[c],
                                        v = p.path;
                                    v && (r[p.name] = t.Loader.getRes(v));
                                }
                                break;

                            case "defines":
                                var E = s[_];
                                for (c = 0, h = E.length; c < h; c++) {
                                    var g = G.getDefineByName(E[c]);
                                    r._shaderValues.addDefine(g);
                                }
                                break;

                            case "renderStates":
                                var y = s[_][0],
                                    S = r;
                                S.blend = y.blend, S.cull = y.cull, S.depthTest = y.depthTest, S.depthWrite = y.depthWrite,
                                    S.blendSrc = y.srcBlend, S.blendDst = y.dstBlend;
                                break;

                            case "cull":
                                r.cull = s[_];
                                break;

                            case "blend":
                                r.blend = s[_];
                                break;

                            case "depthWrite":
                                r.depthWrite = s[_];
                                break;

                            case "srcBlend":
                                r.blendSrc = s[_];
                                break;

                            case "dstBlend":
                                r.blendDst = s[_];
                                break;

                            default:
                                r[_] = s[_];
                        }
                        break;

                    default:
                        throw new Error("BaseMaterial:unkonwn version.");
                }
                return r;
            }
        }]), Material;
    }();
    j.MATERIAL = "MATERIAL", j.RENDERQUEUE_OPAQUE = 2e3, j.RENDERQUEUE_ALPHATEST = 2450,
        j.RENDERQUEUE_TRANSPARENT = 3e3, j.ALPHATESTVALUE = G.propertyNameToID("u_AlphaTestValue"),
        j.SHADERDEFINE_ALPHATEST = null;
    var Q = function() {
        function BaseMaterial() {
            _classCallCheck(this, BaseMaterial);
        }
        return _createClass(BaseMaterial, null, [{
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, j.MATERIAL);
            }
        }, {
            key: "__initDefine__",
            value: function() {
                BaseMaterial.SHADERDEFINE_ALPHATEST = j.SHADERDEFINE_ALPHATEST;
            }
        }]), BaseMaterial;
    }();
    Q.MATERIAL = "MATERIAL", Q.RENDERQUEUE_OPAQUE = 2e3, Q.RENDERQUEUE_ALPHATEST = 2450,
        Q.RENDERQUEUE_TRANSPARENT = 3e3, Q.ALPHATESTVALUE = G.propertyNameToID("u_AlphaTestValue"),
        Q.SHADERDEFINE_ALPHATEST = null;
    var Z = function() {
        function RenderState() {
            _classCallCheck(this, RenderState), this.cull = RenderState.CULL_BACK, this.blend = RenderState.BLEND_DISABLE,
                this.srcBlend = RenderState.BLENDPARAM_ONE, this.dstBlend = RenderState.BLENDPARAM_ZERO,
                this.srcBlendRGB = RenderState.BLENDPARAM_ONE, this.dstBlendRGB = RenderState.BLENDPARAM_ZERO,
                this.srcBlendAlpha = RenderState.BLENDPARAM_ONE, this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO,
                this.blendConstColor = new i(1, 1, 1, 1), this.blendEquation = RenderState.BLENDEQUATION_ADD,
                this.blendEquationRGB = RenderState.BLENDEQUATION_ADD, this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD,
                this.depthTest = RenderState.DEPTHTEST_LEQUAL, this.depthWrite = !0;
        }
        return _createClass(RenderState, [{
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend,
                    t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha,
                    t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor),
                    t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB,
                    t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new RenderState();
                return this.cloneTo(e), e;
            }
        }]), RenderState;
    }();
    Z.CULL_NONE = 0, Z.CULL_FRONT = 1, Z.CULL_BACK = 2, Z.BLEND_DISABLE = 0, Z.BLEND_ENABLE_ALL = 1,
        Z.BLEND_ENABLE_SEPERATE = 2, Z.BLENDPARAM_ZERO = 0, Z.BLENDPARAM_ONE = 1, Z.BLENDPARAM_SRC_COLOR = 768,
        Z.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, Z.BLENDPARAM_DST_COLOR = 774, Z.BLENDPARAM_ONE_MINUS_DST_COLOR = 775,
        Z.BLENDPARAM_SRC_ALPHA = 770, Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, Z.BLENDPARAM_DST_ALPHA = 772,
        Z.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, Z.BLENDPARAM_SRC_ALPHA_SATURATE = 776, Z.BLENDEQUATION_ADD = 32774,
        Z.BLENDEQUATION_SUBTRACT = 32778, Z.BLENDEQUATION_REVERSE_SUBTRACT = 32779, Z.DEPTHTEST_OFF = 0,
        Z.DEPTHTEST_NEVER = 512, Z.DEPTHTEST_LESS = 513, Z.DEPTHTEST_EQUAL = 514, Z.DEPTHTEST_LEQUAL = 515,
        Z.DEPTHTEST_GREATER = 516, Z.DEPTHTEST_NOTEQUAL = 517, Z.DEPTHTEST_GEQUAL = 518,
        Z.DEPTHTEST_ALWAYS = 519;
    var q = function(e) {
        function BlinnPhongMaterial() {
            var e;
            _classCallCheck(this, BlinnPhongMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(BlinnPhongMaterial).call(this)))._enableVertexColor = !1,
                e.setShaderName("BLINNPHONG"), e._albedoIntensity = 1, e._albedoColor = new i(1, 1, 1, 1);
            var t = e._shaderValues;
            return t.setVector(BlinnPhongMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), t.setVector(BlinnPhongMaterial.MATERIALSPECULAR, new i(1, 1, 1, 1)),
                t.setNumber(BlinnPhongMaterial.SHININESS, .078125), t.setNumber(j.ALPHATESTVALUE, .5),
                t.setVector(BlinnPhongMaterial.TILINGOFFSET, new i(1, 1, 0, 0)), e._enableLighting = !0,
                e.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE, e;
        }
        return _inherits(BlinnPhongMaterial, j), _createClass(BlinnPhongMaterial, [{
            key: "clone",
            value: function() {
                var e = new BlinnPhongMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(BlinnPhongMaterial.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t._enableLighting = this._enableLighting, t._albedoIntensity = this._albedoIntensity,
                    t._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(t._albedoColor);
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_SpecColorR",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).x = e;
            }
        }, {
            key: "_SpecColorG",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).y = e;
            }
        }, {
            key: "_SpecColorB",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).z = e;
            }
        }, {
            key: "_SpecColorA",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w;
            },
            set: function(e) {
                this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR).w = e;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_Shininess",
            get: function() {
                return this._shaderValues.getNumber(BlinnPhongMaterial.SHININESS);
            },
            set: function(e) {
                e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(BlinnPhongMaterial.SHININESS, e);
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    default:
                        throw new Error("Material:renderMode value error.");
                }
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(BlinnPhongMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(BlinnPhongMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(BlinnPhongMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "specularColorR",
            get: function() {
                return this._SpecColorR;
            },
            set: function(e) {
                this._SpecColorR = e;
            }
        }, {
            key: "specularColorG",
            get: function() {
                return this._SpecColorG;
            },
            set: function(e) {
                this._SpecColorG = e;
            }
        }, {
            key: "specularColorB",
            get: function() {
                return this._SpecColorB;
            },
            set: function(e) {
                this._SpecColorB = e;
            }
        }, {
            key: "specularColorA",
            get: function() {
                return this._SpecColorA;
            },
            set: function(e) {
                this._SpecColorA = e;
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(BlinnPhongMaterial.MATERIALSPECULAR);
            },
            set: function(e) {
                this._shaderValues.setVector(BlinnPhongMaterial.MATERIALSPECULAR, e);
            }
        }, {
            key: "shininess",
            get: function() {
                return this._Shininess;
            },
            set: function(e) {
                this._Shininess = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP),
                    this._shaderValues.setTexture(BlinnPhongMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP),
                    this._shaderValues.setTexture(BlinnPhongMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(BlinnPhongMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP),
                    this._shaderValues.setTexture(BlinnPhongMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(BlinnPhongMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(BlinnPhongMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(BlinnPhongMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(BlinnPhongMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = G.getDefineByName("DIFFUSEMAP"), BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = G.getDefineByName("NORMALMAP"),
                    BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = G.getDefineByName("SPECULARMAP"),
                    BlinnPhongMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                    BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = G.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]), BlinnPhongMaterial;
    }();
    q.RENDERMODE_OPAQUE = 0, q.RENDERMODE_CUTOUT = 1, q.RENDERMODE_TRANSPARENT = 2,
        q.ALBEDOTEXTURE = G.propertyNameToID("u_DiffuseTexture"), q.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"),
        q.SPECULARTEXTURE = G.propertyNameToID("u_SpecularTexture"), q.ALBEDOCOLOR = G.propertyNameToID("u_DiffuseColor"),
        q.MATERIALSPECULAR = G.propertyNameToID("u_MaterialSpecular"), q.SHININESS = G.propertyNameToID("u_Shininess"),
        q.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"), q.CULL = G.propertyNameToID("s_Cull"),
        q.BLEND = G.propertyNameToID("s_Blend"), q.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
        q.BLEND_DST = G.propertyNameToID("s_BlendDst"), q.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
        q.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var K = function(e) {
        function EffectMaterial() {
            var e;
            return _classCallCheck(this, EffectMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(EffectMaterial).call(this))).setShaderName("Effect"),
                e._color = new i(1, 1, 1, 1), e._shaderValues.setVector(EffectMaterial.TINTCOLOR, new i(1, 1, 1, 1)),
                e.renderMode = EffectMaterial.RENDERMODE_ADDTIVE, e;
        }
        return _inherits(EffectMaterial, j), _createClass(EffectMaterial, [{
            key: "clone",
            value: function() {
                var e = new EffectMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case EffectMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_NONE, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE, this.depthTest = Z.DEPTHTEST_LESS, this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case EffectMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_NONE, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("MeshEffectMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(EffectMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(EffectMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(EffectMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(EffectMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(EffectMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(EffectMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(EffectMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(EffectMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(EffectMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(EffectMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                EffectMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"), EffectMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                    EffectMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG");
            }
        }]), EffectMaterial;
    }();
    K.RENDERMODE_ADDTIVE = 0, K.RENDERMODE_ALPHABLENDED = 1, K.MAINTEXTURE = G.propertyNameToID("u_AlbedoTexture"),
        K.TINTCOLOR = G.propertyNameToID("u_AlbedoColor"), K.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
        K.CULL = G.propertyNameToID("s_Cull"), K.BLEND = G.propertyNameToID("s_Blend"),
        K.BLEND_SRC = G.propertyNameToID("s_BlendSrc"), K.BLEND_DST = G.propertyNameToID("s_BlendDst"),
        K.DEPTH_TEST = G.propertyNameToID("s_DepthTest"), K.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var J, $ = function(e) {
        function ExtendTerrainMaterial() {
            var e;
            return _classCallCheck(this, ExtendTerrainMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(ExtendTerrainMaterial).call(this)))._enableLighting = !0,
                e.setShaderName("ExtendTerrain"), e.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE,
                e;
        }
        return _inherits(ExtendTerrainMaterial, j), _createClass(ExtendTerrainMaterial, [{
            key: "_setDetailNum",
            value: function(e) {
                switch (e) {
                    case 1:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 2:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 3:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 4:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                        break;

                    case 5:
                        this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3),
                            this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                }
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ExtendTerrainMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "splatAlphaTexture",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, e);
            }
        }, {
            key: "diffuseTexture1",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, e), this._setDetailNum(1);
            }
        }, {
            key: "diffuseTexture2",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, e), this._setDetailNum(2);
            }
        }, {
            key: "diffuseTexture3",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, e), this._setDetailNum(3);
            }
        }, {
            key: "diffuseTexture4",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, e), this._setDetailNum(4);
            }
        }, {
            key: "diffuseTexture5",
            get: function() {
                return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
            },
            set: function(e) {
                this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, e), this._setDetailNum(5);
            }
        }, {
            key: "diffuseScaleOffset1",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, e);
            }
        }, {
            key: "diffuseScaleOffset2",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, e);
            }
        }, {
            key: "diffuseScaleOffset3",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, e);
            }
        }, {
            key: "diffuseScaleOffset4",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, e);
            }
        }, {
            key: "diffuseScaleOffset5",
            set: function(e) {
                this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, e);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                        this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = Z.CULL_BACK,
                            this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = Z.CULL_BACK,
                            this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA, this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                            this.depthTest = Z.DEPTHTEST_LEQUAL;
                        break;

                    default:
                        throw new Error("ExtendTerrainMaterial:renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ExtendTerrainMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ExtendTerrainMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ExtendTerrainMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ExtendTerrainMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = G.getDefineByName("ExtendTerrain_DETAIL_NUM1"),
                    ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = G.getDefineByName("ExtendTerrain_DETAIL_NUM2"),
                    ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = G.getDefineByName("ExtendTerrain_DETAIL_NUM3"),
                    ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = G.getDefineByName("ExtendTerrain_DETAIL_NUM4"),
                    ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = G.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            }
        }]), ExtendTerrainMaterial;
    }();
    $.RENDERMODE_OPAQUE = 1, $.RENDERMODE_TRANSPARENT = 2, $.SPLATALPHATEXTURE = G.propertyNameToID("u_SplatAlphaTexture"),
        $.DIFFUSETEXTURE1 = G.propertyNameToID("u_DiffuseTexture1"), $.DIFFUSETEXTURE2 = G.propertyNameToID("u_DiffuseTexture2"),
        $.DIFFUSETEXTURE3 = G.propertyNameToID("u_DiffuseTexture3"), $.DIFFUSETEXTURE4 = G.propertyNameToID("u_DiffuseTexture4"),
        $.DIFFUSETEXTURE5 = G.propertyNameToID("u_DiffuseTexture5"), $.DIFFUSESCALEOFFSET1 = G.propertyNameToID("u_DiffuseScaleOffset1"),
        $.DIFFUSESCALEOFFSET2 = G.propertyNameToID("u_DiffuseScaleOffset2"), $.DIFFUSESCALEOFFSET3 = G.propertyNameToID("u_DiffuseScaleOffset3"),
        $.DIFFUSESCALEOFFSET4 = G.propertyNameToID("u_DiffuseScaleOffset4"), $.DIFFUSESCALEOFFSET5 = G.propertyNameToID("u_DiffuseScaleOffset5"),
        $.CULL = G.propertyNameToID("s_Cull"), $.BLEND = G.propertyNameToID("s_Blend"),
        $.BLEND_SRC = G.propertyNameToID("s_BlendSrc"), $.BLEND_DST = G.propertyNameToID("s_BlendDst"),
        $.DEPTH_TEST = G.propertyNameToID("s_DepthTest"), $.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite"),
        (J = e.PBRRenderMode || (e.PBRRenderMode = {}))[J.Opaque = 0] = "Opaque", J[J.Cutout = 1] = "Cutout",
        J[J.Fade = 2] = "Fade", J[J.Transparent = 3] = "Transparent";
    var ee = function(t) {
        function PBRMaterial() {
            var t;
            return _classCallCheck(this, PBRMaterial), (t = _possibleConstructorReturn(this, _getPrototypeOf(PBRMaterial).call(this)))._enableEmission = !1,
                t._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)), t._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, new i(1, 1, 1, 1)),
                t._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, .5), t._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, 1),
                t._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, 1), t._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1),
                t._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, .001), t._shaderValues.setNumber(j.ALPHATESTVALUE, .5),
                t.renderMode = e.PBRRenderMode.Opaque, t;
        }
        return _inherits(PBRMaterial, j), _createClass(PBRMaterial, [{
            key: "albedoColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.ALBEDOCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.ALBEDOCOLOR, e);
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                    this._shaderValues.setTexture(PBRMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE),
                    this._shaderValues.setTexture(PBRMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "normalTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, e);
            }
        }, {
            key: "parallaxTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE),
                    this._shaderValues.setTexture(PBRMaterial.PARALLAXTEXTURE, e);
            }
        }, {
            key: "parallaxTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(.005, Math.min(.08, e)));
            }
        }, {
            key: "occlusionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE),
                    this._shaderValues.setTexture(PBRMaterial.OCCLUSIONTEXTURE, e);
            }
        }, {
            key: "occlusionTextureStrength",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothness",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessTextureScale",
            get: function() {
                return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESSSCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRMaterial.SMOOTHNESSSCALE, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "enableEmission",
            get: function() {
                return this._enableEmission;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSION),
                    this._enableEmission = e;
            }
        }, {
            key: "emissionColor",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.EMISSIONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRMaterial.EMISSIONCOLOR, e);
            }
        }, {
            key: "emissionTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE),
                    this._shaderValues.setTexture(PBRMaterial.EMISSIONTEXTURE, e);
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(PBRMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(PBRMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(PBRMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(PBRMaterial.DEPTH_TEST, e);
            }
        }, {
            key: "renderMode",
            set: function(t) {
                switch (t) {
                    case e.PBRRenderMode.Opaque:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Cutout:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Fade:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    case e.PBRRenderMode.Transparent:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_ONE,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                        break;

                    default:
                        throw new Error("PBRMaterial:unknown renderMode value.");
                }
            }
        }, {
            key: "enableReflection",
            get: function() {
                return !0;
            },
            set: function(e) {}
        }], [{
            key: "__init__",
            value: function() {
                PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = G.getDefineByName("ALBEDOTEXTURE"), PBRMaterial.SHADERDEFINE_NORMALTEXTURE = G.getDefineByName("NORMALTEXTURE"),
                    PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = G.getDefineByName("PARALLAXTEXTURE"),
                    PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = G.getDefineByName("OCCLUSIONTEXTURE"),
                    PBRMaterial.SHADERDEFINE_EMISSION = G.getDefineByName("EMISSION"), PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = G.getDefineByName("EMISSIONTEXTURE"),
                    PBRMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"), PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND = G.getDefineByName("TRANSPARENTBLEND"),
                    PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = G.getDefineByName("LAYA_PBR_BRDF_HIGH"),
                    PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = G.getDefineByName("LAYA_PBR_BRDF_LOW");
            }
        }]), PBRMaterial;
    }();
    ee.ALBEDOTEXTURE = G.propertyNameToID("u_AlbedoTexture"), ee.ALBEDOCOLOR = G.propertyNameToID("u_AlbedoColor"),
        ee.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"), ee.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"),
        ee.NORMALSCALE = G.propertyNameToID("u_NormalScale"), ee.SMOOTHNESS = G.propertyNameToID("u_Smoothness"),
        ee.SMOOTHNESSSCALE = G.propertyNameToID("u_SmoothnessScale"), ee.OCCLUSIONTEXTURE = G.propertyNameToID("u_OcclusionTexture"),
        ee.OCCLUSIONSTRENGTH = G.propertyNameToID("u_occlusionStrength"), ee.PARALLAXTEXTURE = G.propertyNameToID("u_ParallaxTexture"),
        ee.PARALLAXSCALE = G.propertyNameToID("u_ParallaxScale"), ee.EMISSIONTEXTURE = G.propertyNameToID("u_EmissionTexture"),
        ee.EMISSIONCOLOR = G.propertyNameToID("u_EmissionColor"), ee.CULL = G.propertyNameToID("s_Cull"),
        ee.BLEND = G.propertyNameToID("s_Blend"), ee.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
        ee.BLEND_DST = G.propertyNameToID("s_BlendDst"), ee.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
        ee.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite"), ee.renderQuality = e.PBRRenderQuality.High;
    var te = function ShaderVariable() {
            _classCallCheck(this, ShaderVariable), this.textureID = -1;
        },
        re = function(e) {
            function ShaderInstance(e, t, r, n, i) {
                var a;
                return _classCallCheck(this, ShaderInstance), (a = _possibleConstructorReturn(this, _getPrototypeOf(ShaderInstance).call(this)))._stateParamsMap = [],
                    a._uploadMark = -1, a._uploadRenderType = -1, a._vs = e, a._ps = t, a._attributeMap = r,
                    a._uniformMap = n, a._shaderPass = i, a._create(), a.lock = !0, a;
            }
            return _inherits(ShaderInstance, t.Resource), _createClass(ShaderInstance, [{
                key: "_create",
                value: function() {
                    var e = t.LayaGL.instance;
                    for (var r in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER),
                            this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this._program, this._vshader),
                            e.attachShader(this._program, this._pshader), this._attributeMap) e.bindAttribLocation(this._program, this._attributeMap[r], r);
                    if (e.linkProgram(this._program), !t.Render.isConchApp && G.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS)) throw e.getProgramInfoLog(this._program);
                    var n = [],
                        i = [],
                        a = [],
                        o = [],
                        s = [];
                    this._customUniformParamsMap = [];
                    var l, u, c, h = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
                    for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, u = 0; u < h; u++) {
                        var _ = e.getActiveUniform(this._program, u),
                            d = _.name;
                        (l = new te()).location = e.getUniformLocation(this._program, d), d.indexOf("[0]") > 0 ? (l.name = d = d.substr(0, d.length - 3),
                            l.isArray = !0) : (l.name = d, l.isArray = !1), l.type = _.type, this._addShaderUnifiormFun(l);
                        var f = this._uniformMap[d];
                        if (null != f) switch (l.dataOffset = G.propertyNameToID(d), f) {
                            case G.PERIOD_CUSTOM:
                                s.push(l);
                                break;

                            case G.PERIOD_MATERIAL:
                                o.push(l);
                                break;

                            case G.PERIOD_SPRITE:
                                a.push(l);
                                break;

                            case G.PERIOD_CAMERA:
                                i.push(l);
                                break;

                            case G.PERIOD_SCENE:
                                n.push(l);
                                break;

                            default:
                                throw new Error("Shader3D: period is unkonw.");
                        }
                    }
                    for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0),
                        u = 0, c = n.length; u < c; u++) this._sceneUniformParamsMap.addShaderUniform(n[u]);
                    for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0),
                        u = 0, c = i.length; u < c; u++) this._cameraUniformParamsMap.addShaderUniform(i[u]);
                    for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0),
                        u = 0, c = a.length; u < c; u++) this._spriteUniformParamsMap.addShaderUniform(a[u]);
                    for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * o.length * 5 + 4, 64, !0),
                        u = 0, c = o.length; u < c; u++) this._materialUniformParamsMap.addShaderUniform(o[u]);
                    for (this._customUniformParamsMap.length = s.length, u = 0, c = s.length; u < c; u++) {
                        var m = s[u];
                        this._customUniformParamsMap[m.dataOffset] = m;
                    }
                    var T = this._shaderPass._stateMap;
                    for (var p in T) this._stateParamsMap[T[p]] = G.propertyNameToID(p);
                }
            }, {
                key: "_getRenderState",
                value: function(e, t) {
                    var r = this._stateParamsMap[t];
                    return null == r ? null : e[r];
                }
            }, {
                key: "_disposeResource",
                value: function() {
                    t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(this._pshader),
                        t.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null,
                        this._setGPUMemory(0), this._curActTexIndex = 0;
                }
            }, {
                key: "_addShaderUnifiormFun",
                value: function(e) {
                    var r = t.LayaGL.instance;
                    e.caller = this;
                    var n = e.isArray;
                    switch (e.type) {
                        case r.BOOL:
                            e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                            break;

                        case r.INT:
                            e.fun = n ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                            break;

                        case r.FLOAT:
                            e.fun = n ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                            break;

                        case r.FLOAT_VEC2:
                            e.fun = n ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                            break;

                        case r.FLOAT_VEC3:
                            e.fun = n ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                            break;

                        case r.FLOAT_VEC4:
                            e.fun = n ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                            break;

                        case r.FLOAT_MAT2:
                            e.fun = this._uniformMatrix2fv;
                            break;

                        case r.FLOAT_MAT3:
                            e.fun = this._uniformMatrix3fv;
                            break;

                        case r.FLOAT_MAT4:
                            e.fun = n ? this._uniformMatrix4fv : this._uniformMatrix4f;
                            break;

                        case r.SAMPLER_2D:
                        case r.SAMPLER_2D_SHADOW:
                            r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                                e.fun = this._uniform_sampler2D;
                            break;

                        case 35679:
                            r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                                e.fun = this._uniform_sampler3D;
                            break;

                        case r.SAMPLER_CUBE:
                            r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                                e.fun = this._uniform_samplerCube;
                            break;

                        default:
                            throw new Error("compile shader err!");
                    }
                }
            }, {
                key: "_createShader",
                value: function(e, t, r) {
                    var n = e.createShader(r);
                    if (e.shaderSource(n, t), e.compileShader(n), G.debugMode && !e.getShaderParameter(n, e.COMPILE_STATUS)) throw e.getShaderInfoLog(n);
                    return n;
                }
            }, {
                key: "_uniform1f",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, n[0] = r), 1) : 0;
                }
            }, {
                key: "_uniform1fv",
                value: function(e, r) {
                    if (r.length < 4) {
                        var n = e.uploadedValue;
                        return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform1fv(e.location, r),
                            n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], 1) : 0;
                    }
                    return t.LayaGL.instance.uniform1fv(e.location, r), 1;
                }
            }, {
                key: "_uniform_vec2",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r.x || n[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location, n[0] = r.x, n[1] = r.y),
                        1) : 0;
                }
            }, {
                key: "_uniform_vec2v",
                value: function(e, r) {
                    if (r.length < 2) {
                        var n = e.uploadedValue;
                        return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform2fv(e.location, r),
                            n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3], 1) : 0;
                    }
                    return t.LayaGL.instance.uniform2fv(e.location, r), 1;
                }
            }, {
                key: "_uniform_vec3",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z ? (t.LayaGL.instance.uniform3f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z),
                        1) : 0;
                }
            }, {
                key: "_uniform_vec3v",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform3fv(e.location, r), 1;
                }
            }, {
                key: "_uniform_vec4",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r.x || n[1] !== r.y || n[2] !== r.z || n[3] !== r.w ? (t.LayaGL.instance.uniform4f(e.location, n[0] = r.x, n[1] = r.y, n[2] = r.z, n[3] = r.w),
                        1) : 0;
                }
            }, {
                key: "_uniform_vec4v",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform4fv(e.location, r), 1;
                }
            }, {
                key: "_uniformMatrix2fv",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r), 1;
                }
            }, {
                key: "_uniformMatrix3fv",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r), 1;
                }
            }, {
                key: "_uniformMatrix4f",
                value: function(e, r) {
                    var n = r.elements;
                    return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, n), 1;
                }
            }, {
                key: "_uniformMatrix4fv",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1;
                }
            }, {
                key: "_uniform1i",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, n[0] = r), 1) : 0;
                }
            }, {
                key: "_uniform1iv",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform1iv(e.location, r), 1;
                }
            }, {
                key: "_uniform_ivec2",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r[0] || n[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location, n[0] = r[0], n[1] = r[1]),
                        1) : 0;
                }
            }, {
                key: "_uniform_ivec2v",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform2iv(e.location, r), 1;
                }
            }, {
                key: "_uniform_vec3i",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] ? (t.LayaGL.instance.uniform3i(e.location, n[0] = r[0], n[1] = r[1], n[2] = r[2]),
                        1) : 0;
                }
            }, {
                key: "_uniform_vec3vi",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform3iv(e.location, r), 1;
                }
            }, {
                key: "_uniform_vec4i",
                value: function(e, r) {
                    var n = e.uploadedValue;
                    return n[0] !== r[0] || n[1] !== r[1] || n[2] !== r[2] || n[3] !== r[3] ? (t.LayaGL.instance.uniform4i(e.location, n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = r[3]),
                        1) : 0;
                }
            }, {
                key: "_uniform_vec4vi",
                value: function(e, r) {
                    return t.LayaGL.instance.uniform4iv(e.location, r), 1;
                }
            }, {
                key: "_uniform_sampler2D",
                value: function(e, r) {
                    var n = r._getSource() || r.defaulteTexture._getSource(),
                        i = t.LayaGL.instance;
                    return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, i.TEXTURE_2D, n),
                        0;
                }
            }, {
                key: "_uniform_sampler3D",
                value: function(e, r) {
                    var n = r._getSource() || r.defaulteTexture._getSource(),
                        i = t.LayaGL.instance;
                    return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, WebGL2RenderingContext.TEXTURE_3D, n),
                        0;
                }
            }, {
                key: "_uniform_samplerCube",
                value: function(e, r) {
                    var n = r._getSource() || r.defaulteTexture._getSource(),
                        i = t.LayaGL.instance;
                    return t.WebGLContext.activeTexture(i, e.textureID), t.WebGLContext.bindTexture(i, i.TEXTURE_CUBE_MAP, n),
                        0;
                }
            }, {
                key: "bind",
                value: function() {
                    return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
                }
            }, {
                key: "uploadUniforms",
                value: function(e, r, n) {
                    t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, r, n);
                }
            }, {
                key: "uploadRenderStateBlendDepth",
                value: function(e) {
                    var r = t.LayaGL.instance,
                        n = this._shaderPass.renderState,
                        i = e.getData(),
                        a = this._getRenderState(i, G.RENDER_STATE_DEPTH_WRITE),
                        o = this._getRenderState(i, G.RENDER_STATE_DEPTH_TEST),
                        s = this._getRenderState(i, G.RENDER_STATE_BLEND);
                    switch (null == a && (a = n.depthWrite), null == o && (o = n.depthTest), null == s && (s = n.blend),
                        t.WebGLContext.setDepthMask(r, a), o === Z.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext.setDepthTest(r, !0),
                            t.WebGLContext.setDepthFunc(r, o)), s) {
                        case Z.BLEND_DISABLE:
                            t.WebGLContext.setBlend(r, !1);
                            break;

                        case Z.BLEND_ENABLE_ALL:
                            var l = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION),
                                u = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC),
                                c = this._getRenderState(i, G.RENDER_STATE_BLEND_DST);
                            null == l && (l = n.blendEquation), null == u && (u = n.srcBlend), null == c && (c = n.dstBlend),
                                t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquation(r, l), t.WebGLContext.setBlendFunc(r, u, c);
                            break;

                        case Z.BLEND_ENABLE_SEPERATE:
                            var h = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION_RGB),
                                _ = this._getRenderState(i, G.RENDER_STATE_BLEND_EQUATION_ALPHA),
                                d = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC_RGB),
                                f = this._getRenderState(i, G.RENDER_STATE_BLEND_DST_RGB),
                                m = this._getRenderState(i, G.RENDER_STATE_BLEND_SRC_ALPHA),
                                T = this._getRenderState(i, G.RENDER_STATE_BLEND_DST_ALPHA);
                            null == h && (h = n.blendEquationRGB), null == _ && (_ = n.blendEquationAlpha),
                                null == d && (d = n.srcBlendRGB), null == f && (f = n.dstBlendRGB), null == m && (m = n.srcBlendAlpha),
                                null == T && (T = n.dstBlendAlpha), t.WebGLContext.setBlend(r, !0), t.WebGLContext.setBlendEquationSeparate(r, h, _),
                                t.WebGLContext.setBlendFuncSeperate(r, d, f, m, T);
                    }
                }
            }, {
                key: "uploadRenderStateFrontFace",
                value: function(e, r, n) {
                    var i, a = t.LayaGL.instance,
                        o = this._shaderPass.renderState,
                        s = e.getData(),
                        l = this._getRenderState(s, G.RENDER_STATE_CULL);
                    switch (null == l && (l = o.cull), l) {
                        case Z.CULL_NONE:
                            t.WebGLContext.setCullFace(a, !1);
                            break;

                        case Z.CULL_FRONT:
                            t.WebGLContext.setCullFace(a, !0), i = r ? n ? a.CCW : a.CW : n ? a.CW : a.CCW,
                                t.WebGLContext.setFrontFace(a, i);
                            break;

                        case Z.CULL_BACK:
                            t.WebGLContext.setCullFace(a, !0), i = r ? n ? a.CW : a.CCW : n ? a.CCW : a.CW,
                                t.WebGLContext.setFrontFace(a, i);
                    }
                }
            }, {
                key: "uploadCustomUniform",
                value: function(e, r) {
                    t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, r);
                }
            }, {
                key: "_uniformMatrix2fvForNative",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r), 1;
                }
            }, {
                key: "_uniformMatrix3fvForNative",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r), 1;
                }
            }, {
                key: "_uniformMatrix4fvForNative",
                value: function(e, r) {
                    return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r), 1;
                }
            }]), ShaderInstance;
        }(),
        ne = function() {
            function SingletonList() {
                _classCallCheck(this, SingletonList), this.elements = [], this.length = 0;
            }
            return _createClass(SingletonList, [{
                key: "_add",
                value: function(e) {
                    this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
                }
            }, {
                key: "add",
                value: function(e) {
                    this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e,
                        this.length++;
                }
            }]), SingletonList;
        }(),
        ie = function(e) {
            function SimpleSingletonList() {
                return _classCallCheck(this, SimpleSingletonList), _possibleConstructorReturn(this, _getPrototypeOf(SimpleSingletonList).call(this));
            }
            return _inherits(SimpleSingletonList, ne), _createClass(SimpleSingletonList, [{
                key: "add",
                value: function(e) {
                    if (-1 !== e._getIndexInList()) throw "SimpleSingletonList:" + e + " has  in  SingletonList.";
                    this._add(e), e._setIndexInList(this.length++);
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._getIndexInList();
                    if (this.length--, t !== this.length) {
                        var r = this.elements[this.length];
                        this.elements[t] = r, r._setIndexInList(t);
                    }
                    e._setIndexInList(-1);
                }
            }, {
                key: "clear",
                value: function() {
                    for (var e = this.elements, t = 0, r = this.length; t < r; t++) e[t]._setIndexInList(-1);
                    this.length = 0;
                }
            }]), SimpleSingletonList;
        }(),
        ae = function() {
            function Color() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                _classCallCheck(this, Color), this.r = e, this.g = t, this.b = r, this.a = n;
            }
            return _createClass(Color, [{
                key: "toLinear",
                value: function(e) {
                    e.r = Color.gammaToLinearSpace(this.r), e.g = Color.gammaToLinearSpace(this.g),
                        e.b = Color.gammaToLinearSpace(this.b);
                }
            }, {
                key: "toGamma",
                value: function(e) {
                    e.r = Color.linearToGammaSpace(this.r), e.g = Color.linearToGammaSpace(this.g),
                        e.b = Color.linearToGammaSpace(this.b);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Color();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "forNativeElement",
                value: function() {}
            }], [{
                key: "gammaToLinearSpace",
                value: function(e) {
                    return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
                }
            }, {
                key: "linearToGammaSpace",
                value: function(e) {
                    return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
                }
            }]), Color;
        }();
    ae.RED = new ae(1, 0, 0, 1), ae.GREEN = new ae(0, 1, 0, 1), ae.BLUE = new ae(0, 0, 1, 1),
        ae.CYAN = new ae(0, 1, 1, 1), ae.YELLOW = new ae(1, .92, .016, 1), ae.MAGENTA = new ae(1, 0, 1, 1),
        ae.GRAY = new ae(.5, .5, .5, 1), ae.WHITE = new ae(1, 1, 1, 1), ae.BLACK = new ae(0, 0, 0, 1);
    var oe = function() {
        function DynamicBatchManager() {
            _classCallCheck(this, DynamicBatchManager), this._batchRenderElementPool = [];
        }
        return _createClass(DynamicBatchManager, [{
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "dispose",
            value: function() {}
        }], [{
            key: "_registerManager",
            value: function(e) {
                DynamicBatchManager._managers.push(e);
            }
        }]), DynamicBatchManager;
    }();
    oe._managers = [];
    var se = function(e) {
        function Transform3D(e) {
            var t;
            return _classCallCheck(this, Transform3D), (t = _possibleConstructorReturn(this, _getPrototypeOf(Transform3D).call(this)))._localPosition = new o(0, 0, 0),
                t._localRotation = new f(0, 0, 0, 1), t._localScale = new o(1, 1, 1), t._localRotationEuler = new o(0, 0, 0),
                t._localMatrix = new L(), t._position = new o(0, 0, 0), t._rotation = new f(0, 0, 0, 1),
                t._scale = new o(1, 1, 1), t._rotationEuler = new o(0, 0, 0), t._worldMatrix = new L(),
                t._children = null, t._parent = null, t._dummy = null, t._transformFlag = 0, t._owner = e,
                t._children = [], t._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !1),
                t._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, !0),
                t;
        }
        return _inherits(Transform3D, t.EventDispatcher), _createClass(Transform3D, [{
            key: "_getScaleMatrix",
            value: function() {
                var e = Transform3D._tempQuaternion0,
                    t = Transform3D._tempMatrix3x30,
                    r = Transform3D._tempMatrix3x31,
                    n = Transform3D._tempMatrix3x32;
                return d.createFromMatrix4x4(this.worldMatrix, r), this.rotation.invert(e), d.createRotationQuaternion(e, t),
                    d.multiply(t, r, n), n;
            }
        }, {
            key: "_setTransformFlag",
            value: function(e, t) {
                t ? this._transformFlag |= e : this._transformFlag &= ~e;
            }
        }, {
            key: "_getTransformFlag",
            value: function(e) {
                return 0 != (this._transformFlag & e);
            }
        }, {
            key: "_setParent",
            value: function(e) {
                if (this._parent !== e) {
                    if (this._parent) {
                        var t = this._parent._children,
                            r = t.indexOf(this);
                        t.splice(r, 1);
                    }
                    e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
                }
            }
        }, {
            key: "_onWorldPositionRotationTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldPositionScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldPositionTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionTransform();
                }
            }
        }, {
            key: "_onWorldRotationTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
                }
            }
        }, {
            key: "_onWorldScaleTransform",
            value: function() {
                if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
                }
            }
        }, {
            key: "_onWorldTransform",
            value: function() {
                if (!(this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) && this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE))) {
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, !0),
                        this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                    for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
                }
            }
        }, {
            key: "translate",
            value: function(e) {
                !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1] ? (L.createFromQuaternion(this.localRotation, Transform3D._tempMatrix0),
                    o.transformCoordinate(e, Transform3D._tempMatrix0, Transform3D._tempVector30), o.add(this.localPosition, Transform3D._tempVector30, this._localPosition),
                    this.localPosition = this._localPosition) : (o.add(this.position, e, this._position),
                    this.position = this._position);
            }
        }, {
            key: "rotate",
            value: function(e) {
                var t, r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? t = e : (o.scale(e, Math.PI / 180, Transform3D._tempVector30),
                        t = Transform3D._tempVector30), f.createFromYawPitchRoll(t.y, t.x, t.z, Transform3D._tempQuaternion0),
                    r ? (f.multiply(this._localRotation, Transform3D._tempQuaternion0, this._localRotation),
                        this.localRotation = this._localRotation) : (f.multiply(Transform3D._tempQuaternion0, this.rotation, this._rotation),
                        this.rotation = this._rotation);
            }
        }, {
            key: "getForward",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = -t[8], e.y = -t[9], e.z = -t[10];
            }
        }, {
            key: "getUp",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[4], e.y = t[5], e.z = t[6];
            }
        }, {
            key: "getRight",
            value: function(e) {
                var t = this.worldMatrix.elements;
                e.x = t[0], e.y = t[1], e.z = t[2];
            }
        }, {
            key: "lookAt",
            value: function(e, t) {
                var n;
                if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
                    if (n = this._localPosition, Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance) return;
                    f.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation),
                        this.localRotation = this._localRotation;
                } else {
                    var i = this.position;
                    if (n = i, Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance) return;
                    f.lookAt(i, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
                }
            }
        }, {
            key: "getWorldLossyScale",
            value: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                    if (null !== this._parent) {
                        var e = this._getScaleMatrix().elements;
                        this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8];
                    } else this._localScale.cloneTo(this._scale);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
                }
                return this._scale;
            }
        }, {
            key: "setWorldLossyScale",
            value: function(e) {
                if (null !== this._parent) {
                    var t = Transform3D._tempMatrix3x33,
                        r = Transform3D._tempMatrix3x33,
                        n = r.elements,
                        i = this._parent._getScaleMatrix();
                    i.invert(i), d.createFromScaling(e, t), d.multiply(i, t, r), this._localScale.x = n[0],
                        this._localScale.y = n[4], this._localScale.z = n[8];
                } else e.cloneTo(this._localScale);
                this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, !1);
            }
        }, {
            key: "_isFrontFaceInvert",
            get: function() {
                var e = this.getWorldLossyScale(),
                    t = e.x < 0;
                return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
            }
        }, {
            key: "owner",
            get: function() {
                return this._owner;
            }
        }, {
            key: "worldNeedUpdate",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
            }
        }, {
            key: "localPositionX",
            get: function() {
                return this._localPosition.x;
            },
            set: function(e) {
                this._localPosition.x = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionY",
            get: function() {
                return this._localPosition.y;
            },
            set: function(e) {
                this._localPosition.y = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPositionZ",
            get: function() {
                return this._localPosition.z;
            },
            set: function(e) {
                this._localPosition.z = e, this.localPosition = this._localPosition;
            }
        }, {
            key: "localPosition",
            get: function() {
                return this._localPosition;
            },
            set: function(e) {
                this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldPositionTransform();
            }
        }, {
            key: "localRotationX",
            get: function() {
                return this.localRotation.x;
            },
            set: function(e) {
                this._localRotation.x = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationY",
            get: function() {
                return this.localRotation.y;
            },
            set: function(e) {
                this._localRotation.y = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationZ",
            get: function() {
                return this.localRotation.z;
            },
            set: function(e) {
                this._localRotation.z = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotationW",
            get: function() {
                return this.localRotation.w;
            },
            set: function(e) {
                this._localRotation.w = e, this.localRotation = this._localRotation;
            }
        }, {
            key: "localRotation",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                    var e = this._localRotationEuler;
                    f.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._localRotation),
                        this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1);
                }
                return this._localRotation;
            },
            set: function(e) {
                this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, !0),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, !1), this._onWorldRotationTransform();
            }
        }, {
            key: "localScaleX",
            get: function() {
                return this._localScale.x;
            },
            set: function(e) {
                this._localScale.x = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleY",
            get: function() {
                return this._localScale.y;
            },
            set: function(e) {
                this._localScale.y = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScaleZ",
            get: function() {
                return this._localScale.z;
            },
            set: function(e) {
                this._localScale.z = e, this.localScale = this._localScale;
            }
        }, {
            key: "localScale",
            get: function() {
                return this._localScale;
            },
            set: function(e) {
                this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldScaleTransform();
            }
        }, {
            key: "localRotationEulerX",
            get: function() {
                return this.localRotationEuler.x;
            },
            set: function(e) {
                this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerY",
            get: function() {
                return this.localRotationEuler.y;
            },
            set: function(e) {
                this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEulerZ",
            get: function() {
                return this.localRotationEuler.z;
            },
            set: function(e) {
                this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
            }
        }, {
            key: "localRotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                    this._localRotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30,
                        t = this._localRotationEuler;
                    t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin,
                        t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1);
                }
                return this._localRotationEuler;
            },
            set: function(e) {
                this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !1),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, !0),
                    this._onWorldRotationTransform();
            }
        }, {
            key: "localMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX) && (L.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix;
            },
            set: function(e) {
                this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale),
                    this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, !1),
                    this._onWorldTransform();
            }
        }, {
            key: "position",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                    if (null != this._parent) {
                        var e = this.worldMatrix.elements;
                        this._position.x = e[12], this._position.y = e[13], this._position.z = e[14];
                    } else this._localPosition.cloneTo(this._position);
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
                }
                return this._position;
            },
            set: function(e) {
                if (null != this._parent) {
                    var t = Transform3D._tempMatrix0;
                    this._parent.worldMatrix.invert(t), o.transformCoordinate(e, t, this._localPosition);
                } else e.cloneTo(this._localPosition);
                this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, !1);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? f.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1)), this._rotation;
            },
            set: function(e) {
                null != this._parent ? (this._parent.rotation.invert(Transform3D._tempQuaternion0),
                        f.multiply(Transform3D._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation),
                    this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, !1);
            }
        }, {
            key: "rotationEuler",
            get: function() {
                if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                    this.rotation.getYawPitchRoll(Transform3D._tempVector30);
                    var e = Transform3D._tempVector30,
                        t = this._rotationEuler;
                    t.x = e.y * Transform3D._angleToRandin, t.y = e.x * Transform3D._angleToRandin,
                        t.z = e.z * Transform3D._angleToRandin, this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
                }
                return this._rotationEuler;
            },
            set: function(e) {
                f.createFromYawPitchRoll(e.y / Transform3D._angleToRandin, e.x / Transform3D._angleToRandin, e.z / Transform3D._angleToRandin, this._rotation),
                    this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, !1);
            }
        }, {
            key: "worldMatrix",
            get: function() {
                return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) && (null != this._parent ? L.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
                    this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix;
            },
            set: function(e) {
                null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix),
                        L.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix,
                    this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, !1);
            }
        }, {
            key: "scale",
            get: function() {
                return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."),
                    this.getWorldLossyScale();
            },
            set: function(e) {
                console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."),
                    this.setWorldLossyScale(e);
            }
        }]), Transform3D;
    }();
    se._tempVector30 = new o(), se._tempQuaternion0 = new f(), se._tempMatrix0 = new L(),
        se._tempMatrix3x30 = new d(), se._tempMatrix3x31 = new d(), se._tempMatrix3x32 = new d(),
        se._tempMatrix3x33 = new d(), se.TRANSFORM_LOCALQUATERNION = 1, se.TRANSFORM_LOCALEULER = 2,
        se.TRANSFORM_LOCALMATRIX = 4, se.TRANSFORM_WORLDPOSITION = 8, se.TRANSFORM_WORLDQUATERNION = 16,
        se.TRANSFORM_WORLDSCALE = 32, se.TRANSFORM_WORLDMATRIX = 64, se.TRANSFORM_WORLDEULER = 128,
        se._angleToRandin = 180 / Math.PI;
    var le = function(e) {
        function Sprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            return _classCallCheck(this, Sprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Sprite3D).call(this)))._needProcessCollisions = !1,
                e._needProcessTriggers = !1, e._id = ++Sprite3D._uniqueIDCounter, e._transform = new se(_assertThisInitialized(e)),
                e._isStatic = r, e.layer = 0, e.name = t || "New Sprite3D", e;
        }
        return _inherits(Sprite3D, t.Node), _createClass(Sprite3D, [{
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_changeAnimatorsToLinkSprite3D",
            value: function(e, t, r) {
                var n = this.getComponent(N);
                if (n && (n.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(n, t, r)), this._parent && this._parent instanceof Sprite3D) {
                    r.unshift(this._parent.name);
                    var i = this._parent;
                    i._hierarchyAnimator && i._changeAnimatorsToLinkSprite3D(e, t, r);
                }
            }
        }, {
            key: "_setHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == t && i._setHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_clearHierarchyAnimator",
            value: function(e, t) {
                this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == e && i._clearHierarchyAnimator(e, t);
                }
            }
        }, {
            key: "_changeHierarchyAnimatorAvatar",
            value: function(e, t) {
                this._changeAnimatorAvatar(t);
                for (var r = 0, n = this._children.length; r < n; r++) {
                    var i = this._children[r];
                    i._hierarchyAnimator == e && i._changeHierarchyAnimatorAvatar(e, t);
                }
            }
        }, {
            key: "_changeAnimatorToLinkSprite3DNoAvatar",
            value: function(e, t, r) {
                e._handleSpriteOwnersBySprite(t, r, this);
                for (var n = 0, i = this._children.length; n < i; n++) {
                    var a = this._children[n],
                        o = r.length;
                    r.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(e, t, r), r.splice(o, 1);
                }
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                this._hierarchyAnimator = e;
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {}
        }, {
            key: "_onAdded",
            value: function() {
                if (this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(e.transform), e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null),
                        e._changeAnimatorsToLinkSprite3D(this, !0, [this.name]));
                }
                _get(_getPrototypeOf(Sprite3D.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_onRemoved",
            value: function() {
                if (_get(_getPrototypeOf(Sprite3D.prototype), "_onRemoved", this).call(this), this._parent instanceof Sprite3D) {
                    var e = this._parent;
                    this.transform._setParent(null), e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null),
                        e._changeAnimatorsToLinkSprite3D(this, !1, [this.name]));
                }
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active),
                    null != e.name && (this.name = e.name), void 0 !== e.position) {
                    var r = this.transform.localPosition;
                    r.fromArray(e.position), this.transform.localPosition = r;
                }
                if (void 0 !== e.rotationEuler) {
                    var n = this.transform.localRotationEuler;
                    n.fromArray(e.rotationEuler), this.transform.localRotationEuler = n;
                }
                if (void 0 !== e.rotation) {
                    var i = this.transform.localRotation;
                    i.fromArray(e.rotation), this.transform.localRotation = i;
                }
                if (void 0 !== e.scale) {
                    var a = this.transform.localScale;
                    a.fromArray(e.scale), this.transform.localScale = a;
                }
                null != e.layer && (this.layer = e.layer);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
                var n = e,
                    i = this._transform,
                    a = n._transform;
                n.name = this.name, n.destroyed = this.destroyed, n.active = this.active, a.localPosition = i.localPosition,
                    a.localRotation = i.localRotation, a.localScale = i.localScale, n._isStatic = this._isStatic,
                    n.layer = this.layer, _get(_getPrototypeOf(Sprite3D.prototype), "_cloneTo", this).call(this, n, t, r);
            }
        }, {
            key: "clone",
            value: function() {
                var e = Sprite3D._createSprite3DInstance(this);
                return Sprite3D._parseSprite3DInstance(this, e, this, e), e;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Sprite3D.prototype), "destroy", this).call(this, e),
                    this._transform = null, this._scripts = null, this._url && t.Loader.clearRes(this._url));
            }
        }, {
            key: "_create",
            value: function() {
                return new Sprite3D();
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "layer",
            get: function() {
                return this._layer;
            },
            set: function(e) {
                if (this._layer !== e) {
                    if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                    this._layer = e;
                }
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "isStatic",
            get: function() {
                return this._isStatic;
            }
        }, {
            key: "transform",
            get: function() {
                return this._transform;
            }
        }], [{
            key: "__init__",
            value: function() {}
        }, {
            key: "instantiate",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    r = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                    a = e.clone();
                t && t.addChild(a);
                var o = a.transform;
                if (r) {
                    var s = o.worldMatrix;
                    e.transform.worldMatrix.cloneTo(s), o.worldMatrix = s;
                } else n && (o.position = n), i && (o.rotation = i);
                return a;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.Laya.loader.create(e, r, null, Sprite3D.HIERARCHY);
            }
        }, {
            key: "_createSprite3DInstance",
            value: function(e) {
                for (var t = e._create(), r = e._children, n = 0, i = r.length; n < i; n++) {
                    var a = Sprite3D._createSprite3DInstance(r[n]);
                    t.addChild(a);
                }
                return t;
            }
        }, {
            key: "_parseSprite3DInstance",
            value: function(e, t, r, n) {
                for (var i = r._children, a = n._children, o = 0, s = i.length; o < s; o++) Sprite3D._parseSprite3DInstance(e, t, i[o], a[o]);
                r._cloneTo(n, e, t);
            }
        }]), Sprite3D;
    }();
    le.HIERARCHY = "HIERARCHY", le.WORLDMATRIX = G.propertyNameToID("u_WorldMat"), le.MVPMATRIX = G.propertyNameToID("u_MvpMatrix"),
        le._uniqueIDCounter = 0;
    var ue = function(e) {
        function RenderableSprite3D(e) {
            return _classCallCheck(this, RenderableSprite3D), _possibleConstructorReturn(this, _getPrototypeOf(RenderableSprite3D).call(this, e));
        }
        return _inherits(RenderableSprite3D, le), _createClass(RenderableSprite3D, [{
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onInActive", this).call(this),
                    this._scene._removeRenderObject(this._render);
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActive", this).call(this),
                    this._scene._addRenderObject(this._render);
            }
        }, {
            key: "_onActiveInScene",
            value: function() {
                if (_get(_getPrototypeOf(RenderableSprite3D.prototype), "_onActiveInScene", this).call(this),
                    l.Laya3D._editerEnvironment) {
                    var e = this._scene,
                        t = new i();
                    e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(RenderableSprite3D.PICKCOLOR, t);
                }
            }
        }, {
            key: "_addToInitStaticBatchManager",
            value: function() {}
        }, {
            key: "_setBelongScene",
            value: function(e) {
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setBelongScene", this).call(this, e),
                    this._render._setBelongScene(e);
            }
        }, {
            key: "_setUnBelongScene",
            value: function() {
                this._render._shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP),
                    _get(_getPrototypeOf(RenderableSprite3D.prototype), "_setUnBelongScene", this).call(this);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                if (this._hierarchyAnimator) {
                    var t = this._hierarchyAnimator._renderableSprites;
                    t.splice(t.indexOf(this), 1);
                }
                e && e._renderableSprites.push(this), _get(_getPrototypeOf(RenderableSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                _get(_getPrototypeOf(RenderableSprite3D.prototype), "destroy", this).call(this, e),
                    this._render._destroy(), this._render = null;
            }
        }, {
            key: "_create",
            value: function() {
                return new RenderableSprite3D(this.name);
            }
        }], [{
            key: "__init__",
            value: function() {
                RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = G.getDefineByName("RECEIVESHADOW"),
                    RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = G.getDefineByName("LIGHTMAP"), RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = G.getDefineByName("LIGHTMAP_DIRECTIONAL");
            }
        }]), RenderableSprite3D;
    }();
    ue.LIGHTMAPSCALEOFFSET = G.propertyNameToID("u_LightmapScaleOffset"), ue.LIGHTMAP = G.propertyNameToID("u_LightMap"),
        ue.LIGHTMAP_DIRECTION = G.propertyNameToID("u_LightMapDirection"), ue.PICKCOLOR = G.propertyNameToID("u_PickColor");
    var ce = function() {
        function StaticBatchManager() {
            _classCallCheck(this, StaticBatchManager), this._initBatchSprites = [], this._staticBatches = {},
                this._batchRenderElementPoolIndex = 0, this._batchRenderElementPool = [];
        }
        return _createClass(StaticBatchManager, [{
            key: "_partition",
            value: function(e, t, r) {
                for (var n = e[Math.floor((r + t) / 2)]; t <= r;) {
                    for (; this._compare(e[t], n) < 0;) t++;
                    for (; this._compare(e[r], n) > 0;) r--;
                    if (t < r) {
                        var i = e[t];
                        e[t] = e[r], e[r] = i, t++, r--;
                    } else if (t === r) {
                        t++;
                        break;
                    }
                }
                return t;
            }
        }, {
            key: "_quickSort",
            value: function(e, t, r) {
                if (e.length > 1) {
                    var n = this._partition(e, t, r),
                        i = n - 1;
                    t < i && this._quickSort(e, t, i), n < r && this._quickSort(e, n, r);
                }
            }
        }, {
            key: "_compare",
            value: function(e, t) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                throw "StaticBatch:must override this function.";
            }
        }, {
            key: "_addBatchSprite",
            value: function(e) {
                this._initBatchSprites.push(e);
            }
        }, {
            key: "_clear",
            value: function() {
                this._batchRenderElementPoolIndex = 0;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                throw "StaticBatchManager: must override it.";
            }
        }, {
            key: "dispose",
            value: function() {
                this._staticBatches = null;
            }
        }], [{
            key: "_addToStaticBatchQueue",
            value: function(e, t) {
                e instanceof ue && t.push(e);
                for (var r = 0, n = e.numChildren; r < n; r++) StaticBatchManager._addToStaticBatchQueue(e._children[r], t);
            }
        }, {
            key: "_registerManager",
            value: function(e) {
                StaticBatchManager._managers.push(e);
            }
        }, {
            key: "combine",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                t || (t = [], e && StaticBatchManager._addToStaticBatchQueue(e, t));
                var r = t.length;
                if (r > 0) {
                    for (var n = 0; n < r; n++) {
                        var i = t[n];
                        i.destroyed || (i._render._isPartOfStaticBatch ? console.warn("StaticBatchManager: Sprite " + i.name + " has a part of Static Batch,it will be ignore.") : i._addToInitStaticBatchManager());
                    }
                    for (var a = 0, o = StaticBatchManager._managers.length; a < o; a++) {
                        StaticBatchManager._managers[a]._initStaticBatchs(e);
                    }
                }
            }
        }]), StaticBatchManager;
    }();
    ce._managers = [];
    var he = function CameraCullInfo() {
            _classCallCheck(this, CameraCullInfo);
        },
        _e = function ShadowCullInfo() {
            _classCallCheck(this, ShadowCullInfo);
        },
        de = function() {
            function FrustumCulling() {
                _classCallCheck(this, FrustumCulling);
            }
            return _createClass(FrustumCulling, null, [{
                key: "__init__",
                value: function() {
                    t.Render.supportWebGLPlusCulling && (FrustumCulling._cullingBufferLength = 0, FrustumCulling._cullingBuffer = new Float32Array(4096));
                }
            }, {
                key: "_drawTraversalCullingBound",
                value: function(e, t) {
                    for (var r = e.elements, n = 0, i = e.length; n < i; n++) {
                        var a = FrustumCulling._tempColor0;
                        a.r = 0, a.g = 1, a.b = 0, a.a = 1, R._drawBound(t, r[n].bounds._getBoundBox(), a);
                    }
                }
            }, {
                key: "_traversalCulling",
                value: function(e, r, n, i, a, s, l) {
                    for (var u = i.elements, c = e.boundFrustum, h = e.position, _ = e.cullingMask, d = t.Stat.loopCount, f = 0, m = i.length; f < m; f++) {
                        var T = u[f];
                        if ((l ? T._castShadow && T._enable : 0 != (Math.pow(2, T._owner._layer) & _) && T._enable) && (t.Stat.frustumCulling++, !e.useOcclusionCulling || T._needRender(c, n))) {
                            T._renderMark = d, T._distanceForSort = o.distance(T.bounds.getCenter(), h);
                            for (var p = T._renderElements, v = 0, E = p.length; v < E; v++) p[v]._update(r, n, a, s);
                        }
                    }
                }
            }, {
                key: "renderObjectCulling",
                value: function(e, t, r, n, i, a) {
                    var o, s, l = t._opaqueQueue,
                        u = t._transparentQueue,
                        c = t._renders;
                    l.clear(), u.clear();
                    var h = ce._managers;
                    for (o = 0, s = h.length; o < s; o++) h[o]._clear();
                    var _ = oe._managers;
                    for (o = 0, s = _.length; o < s; o++) _[o]._clear();
                    var d = t._octree;
                    if (d && (d.updateMotionObjects(), d.shrinkRootIfPossible(), d.getCollidingWithFrustum(e, r, n, i, a)),
                        FrustumCulling._traversalCulling(e, t, r, c, n, i, a), FrustumCulling.debugFrustumCulling) {
                        var f = t._debugTool;
                        f.clear(), d && (d.drawAllBounds(f), d.drawAllObjects(f)), FrustumCulling._drawTraversalCullingBound(c, f);
                    }
                    var m = l.elements.length;
                    m > 0 && l._quickSort(0, m - 1), (m = u.elements.length) > 0 && u._quickSort(0, m - 1);
                }
            }, {
                key: "cullingShadow",
                value: function(e, r, n) {
                    var i = r._opaqueQueue,
                        a = r._transparentQueue,
                        s = r._renders;
                    i.clear(), a.clear();
                    for (var l = ce._managers, u = 0, c = l.length; u < c; u++) l[u]._clear();
                    var h = oe._managers;
                    for (u = 0, c = h.length; u < c; u++) h[u]._clear();
                    s = r._renders;
                    var _ = e.position,
                        d = e.cullPlaneCount,
                        f = e.cullPlanes,
                        m = (e.cullSphere, e.direction,
                            s.elements),
                        T = t.Stat.loopCount;
                    for (u = 0, c = s.length; u < c; u++) {
                        var p = m[u];
                        if (p._castShadow && p._enable) {
                            t.Stat.frustumCulling++;
                            for (var v = p.bounds, E = v.getMin(), g = v.getMax(), y = E.x, S = E.y, R = E.z, C = g.x, M = g.y, x = g.z, D = !0, A = 0; A < d; A++) {
                                var L = f[A],
                                    I = L.normal;
                                if (L.distance + I.x * (I.x < 0 ? y : C) + I.y * (I.y < 0 ? S : M) + I.z * (I.z < 0 ? R : x) < 0) {
                                    D = !1;
                                    break;
                                }
                            }
                            if (D) {
                                p._renderMark = T, p._distanceForSort = o.distance(v.getCenter(), _);
                                for (var O = p._renderElements, P = (A = 0, O.length); A < P; A++) O[A]._update(r, n, null, null);
                            }
                        }
                    }
                    return i.elements.length > 0;
                }
            }, {
                key: "renderObjectCullingNative",
                value: function(e, r, n, i, a, s) {
                    var l, u, c, h, _ = r._opaqueQueue,
                        d = r._transparentQueue;
                    _.clear(), d.clear();
                    var f = ce._managers;
                    for (l = 0, u = f.length; l < u; l++) f[l]._clear();
                    var m = oe._managers;
                    for (l = 0, u = m.length; l < u; l++) m[l]._clear();
                    var T = i.length,
                        p = i.elements;
                    for (l = 0; l < T; l++) p[l].bounds, p[l]._updateForNative && p[l]._updateForNative(n);
                    e.boundFrustum;
                    FrustumCulling.cullingNative(e._boundFrustumBuffer, FrustumCulling._cullingBuffer, r._cullingBufferIndices, T, r._cullingBufferResult);
                    var v = t.Stat.loopCount,
                        E = n.camera._transform.position;
                    for (l = 0; l < T; l++) {
                        var g = p[l];
                        if (!e.useOcclusionCulling || e._isLayerVisible(g._owner._layer) && g._enable && r._cullingBufferResult[l]) {
                            g._renderMark = v, g._distanceForSort = o.distance(g.bounds.getCenter(), E);
                            var y = g._renderElements;
                            for (c = 0, h = y.length; c < h; c++) {
                                y[c]._update(r, n, a, s);
                            }
                        }
                    }
                    var S = _.elements.length;
                    S > 0 && _._quickSort(0, S - 1), (S = d.elements.length) > 0 && d._quickSort(0, S - 1);
                }
            }, {
                key: "cullingNative",
                value: function(e, r, n, i, a) {
                    return t.LayaGL.instance.culling(e, r, n, i, a);
                }
            }]), FrustumCulling;
        }();
    de._tempColor0 = new ae(), de._tempVector0 = new o(), de._cameraCullInfo = new he(),
        de._shadowCullInfo = new _e(), de.debugFrustumCulling = !1;
    var fe = function ClusterData() {
            _classCallCheck(this, ClusterData), this.updateMark = -1, this.pointLightCount = 0,
                this.spotLightCount = 0, this.indices = [];
        },
        me = function() {
            function Cluster(e, t, r, i) {
                _classCallCheck(this, Cluster), this._updateMark = 0, this._depthSliceParam = new n(),
                    this._xSlices = e, this._ySlices = t, this._zSlices = r;
                var a = e * t,
                    o = r * (1 + Math.ceil(i / 4));
                this._clusterTexture = R._createFloatTextureBuffer(a, o), this._clusterTexture.lock = !0,
                    this._clusterPixels = new Float32Array(a * o * 4);
                for (var s = new Array(this._zSlices), l = 0; l < this._zSlices; l++) {
                    s[l] = new Array(this._ySlices);
                    for (var u = 0; u < this._ySlices; u++) {
                        s[l][u] = new Array(this._xSlices);
                        for (var c = 0; c < this._xSlices; c++) s[l][u][c] = new fe();
                    }
                }
                this._clusterDatas = s;
            }
            return _createClass(Cluster, [{
                key: "_insertSpotLightSphere",
                value: function(e, t, r, n, i) {
                    var a = Cluster._tempVector35;
                    a.x = i.x - e.x, a.y = i.y - e.y, a.z = i.z - e.z;
                    var s = o.dot(a, a),
                        l = i.w;
                    if (!(s > l * l)) return !1;
                    var u = o.dot(a, t);
                    return !(Math.cos(n) * Math.sqrt(s - u * u) - u * Math.sin(n) > l || u > l + r || u < -l);
                }
            }, {
                key: "_placePointLightToClusters",
                value: function(e, t) {
                    for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++)
                        for (var o = t.yMin, s = t.yMax; o < s; o++)
                            for (var l = t.xMin, u = t.xMax; l < u; l++) {
                                var c = r[i][o][l];
                                c.updateMark != n && (c.pointLightCount = 0, c.spotLightCount = 0, c.updateMark = n);
                                var h = c.indices,
                                    _ = c.pointLightCount++;
                                _ < h.length ? h[_] = e : h.push(e);
                            }
                }
            }, {
                key: "_placeSpotLightToClusters",
                value: function(e, t) {
                    for (var r = this._clusterDatas, n = this._updateMark, i = t.zMin, a = t.zMax; i < a; i++)
                        for (var o = t.yMin, s = t.yMax; o < s; o++)
                            for (var l = t.xMin, u = t.xMax; l < u; l++) {
                                var c = r[i][o][l];
                                c.updateMark != n && (c.pointLightCount = 0, c.spotLightCount = 0, c.updateMark = n);
                                var h = c.indices,
                                    _ = c.pointLightCount + c.spotLightCount++;
                                _ < h.length ? h[_] = e : h.push(e);
                            }
                }
            }, {
                key: "_insertConePlane",
                value: function(e, t, r, n, i) {
                    var a = Cluster._tempVector36,
                        s = Cluster._tempVector37;
                    o.cross(i, t, a), o.cross(a, t, s), o.normalize(s, s);
                    var l = r * Math.tan(n),
                        u = e.x + r * t.x + l * s.x,
                        c = e.y + r * t.y + l * s.y,
                        h = e.z + r * t.z + l * s.z;
                    return u * i.x + c * i.y + h * i.z <= 0 || e.x * i.x + e.y * i.y + e.z * i.z <= 0;
                }
            }, {
                key: "_shrinkSphereLightZPerspective",
                value: function(e, t, r, n, i) {
                    var a = r.z,
                        o = a - n,
                        s = a + n;
                    if (o > t || s <= e) return !1;
                    var l = this._depthSliceParam;
                    return i.zMin = Math.floor(Math.log2(Math.max(o, e)) * l.x - l.y), i.zMax = Math.min(Math.ceil(Math.log2(s) * l.x - l.y), this._zSlices), !0;
                }
            }, {
                key: "_shrinkSpotLightZPerspective",
                value: function(e, t, r, n, i, a, o) {
                    var s = n.x,
                        l = n.y,
                        u = n.z,
                        c = Math.tan(a) * i,
                        h = r.x,
                        _ = r.y,
                        d = r.z,
                        f = s - h,
                        m = l - _,
                        T = u - d,
                        p = f * f + m * m + T * T,
                        v = Math.sqrt(1 - T * T / p),
                        E = Math.max(Math.min(d, u - v * c), r.z - i),
                        g = Math.min(Math.max(d, u + v * c), r.z + i);
                    if (E > t || g <= e) return !1;
                    var y = this._depthSliceParam;
                    return o.zMin = Math.floor(Math.log2(Math.max(E, e)) * y.x - y.y), o.zMax = Math.min(Math.ceil(Math.log2(g) * y.x - y.y), this._zSlices), !0;
                }
            }, {
                key: "_shrinkSphereLightByBoundOrth",
                value: function(e, t, r, n, i, a, o) {
                    var s = i.z,
                        l = s - a,
                        u = s + a;
                    if (l > n || u <= r) return !1;
                    var c = i.x,
                        h = c - a,
                        _ = c + a;
                    if (h > e || _ <= -e) return !1;
                    var d = i.y,
                        f = d - a,
                        m = d + a;
                    if (f > t || m <= -t) return !1;
                    var T = this._xSlices,
                        p = this._ySlices,
                        v = this._depthSliceParam,
                        E = 2 * e / T,
                        g = 2 * t / p;
                    return o.xMin = Math.max(Math.floor((h + e) / E), 0), o.xMax = Math.min(Math.ceil((_ + e) / E), T),
                        o.yMin = Math.max(Math.floor((t - m) / g), 0), o.yMax = Math.min(Math.ceil((t - f) / g), p),
                        o.zMin = Math.floor(Math.log2(Math.max(l, r)) * v.x - v.y), o.zMax = Math.min(Math.ceil(Math.log2(u) * v.x - v.y), this._zSlices), !0;
                }
            }, {
                key: "_shrinkSpotLightByBoundOrth",
                value: function(e, t, r, n, i, a, o, s, l) {
                    var u = a.x,
                        c = a.y,
                        h = a.z,
                        _ = Math.tan(s) * o,
                        d = i.x,
                        f = i.y,
                        m = i.z,
                        T = u - d,
                        p = c - f,
                        v = h - m,
                        E = T * T + p * p + v * v,
                        g = Math.sqrt(1 - v * v / E),
                        y = Math.max(Math.min(m, h - g * _), i.z - o),
                        S = Math.min(Math.max(m, h + g * _), i.z + o);
                    if (y > n || S <= r) return !1;
                    var R = Math.sqrt(1 - T * T / E),
                        C = Math.max(Math.min(d, u - R * _), i.x - o),
                        M = Math.min(Math.max(d, u + R * _), i.x + o);
                    if (C > e || M <= -e) return !1;
                    var x = Math.sqrt(1 - p * p / E),
                        D = Math.max(Math.min(f, c - x * _), i.y - o),
                        A = Math.min(Math.max(f, c + x * _), i.y + o);
                    if (D > t || A <= -t) return !1;
                    var L = this._xSlices,
                        I = this._ySlices,
                        O = this._depthSliceParam,
                        P = 2 * e / L,
                        N = 2 * t / I;
                    return l.xMin = Math.max(Math.floor((C + e) / P), 0), l.xMax = Math.min(Math.ceil((M + e) / P), L),
                        l.yMin = Math.max(Math.floor((t - A) / N), 0), l.yMax = Math.min(Math.ceil((t - D) / N), I),
                        l.zMin = Math.floor(Math.log2(Math.max(y, r)) * O.x - O.y), l.zMax = Math.min(Math.ceil(Math.log2(S) * O.x - O.y), this._zSlices), !0;
                }
            }, {
                key: "_shrinkXYByRadiusPerspective",
                value: function(e, t, r, n, i) {
                    var a, o, s, l, u, c = e.x,
                        h = e.y,
                        _ = e.z,
                        d = this._ySlices + 1;
                    for (u = 0; u < d; u++) {
                        if (h * (f = i[u]).y + _ * f.z < t) {
                            o = Math.max(0, u - 1);
                            break;
                        }
                    }
                    if (u == d) return !1;
                    for (l = this._ySlices, u = o + 1; u < d; u++) {
                        if (h * (f = i[u]).y + _ * f.z <= -t) {
                            l = Math.max(0, u);
                            break;
                        }
                    }
                    for (d = this._xSlices + 1, u = 0; u < d; u++) {
                        if (c * (f = n[u]).x + _ * f.z < t) {
                            a = Math.max(0, u - 1);
                            break;
                        }
                    }
                    for (s = this._xSlices, u = a + 1; u < d; u++) {
                        var f;
                        if (c * (f = n[u]).x + _ * f.z <= -t) {
                            s = Math.max(0, u);
                            break;
                        }
                    }
                    return r.xMin = a, r.xMax = s, r.yMin = o, r.yMax = l, !0;
                }
            }, {
                key: "_shrinkSpotXYByConePerspective",
                value: function(e, t, r, n, i, a, o) {
                    for (var s, l, u, c, h = Cluster._tempVector32, _ = i.yMax + 1, d = i.yMin + 1; d < _; d++)
                        if (this._insertConePlane(e, t, r, n, o[d])) {
                            l = Math.max(0, d - 1);
                            break;
                        }
                    c = i.yMax;
                    for (d = l + 1; d < _; d++) {
                        var f = o[d];
                        if (h.setValue(0, -f.y, -f.z), !this._insertConePlane(e, t, r, n, h)) {
                            c = Math.max(0, d);
                            break;
                        }
                    }
                    _ = i.xMax + 1;
                    for (d = i.xMin + 1; d < _; d++)
                        if (this._insertConePlane(e, t, r, n, a[d])) {
                            s = Math.max(0, d - 1);
                            break;
                        }
                    u = i.xMax;
                    for (d = s + 1; d < _; d++) {
                        f = a[d];
                        if (h.setValue(-f.x, 0, -f.z), !this._insertConePlane(e, t, r, n, h)) {
                            u = Math.max(0, d);
                            break;
                        }
                    }
                    i.xMin = s, i.xMax = u, i.yMin = l, i.yMax = c;
                }
            }, {
                key: "_updatePointLightPerspective",
                value: function(e, t, r, n, i, a, s) {
                    var l = Cluster._tempLightBound,
                        u = Cluster._tempVector30;
                    o.transformV3ToV3(n._transform.position, r, u), u.z *= -1, this._shrinkSphereLightZPerspective(e, t, u, n.range, l) && this._shrinkXYByRadiusPerspective(u, n.range, l, a, s) && this._placePointLightToClusters(i, l);
                }
            }, {
                key: "_updateSpotLightPerspective",
                value: function(e, t, r, n, i, a, s) {
                    var l = Cluster._tempLightBound,
                        u = Cluster._tempVector30,
                        c = Cluster._tempVector31,
                        h = Cluster._tempVector34,
                        _ = n._transform.position,
                        d = n.range;
                    n._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o.add(_, h, h),
                        o.transformV3ToV3(_, r, u), o.transformV3ToV3(h, r, h), u.z *= -1, h.z *= -1;
                    var f = n.spotAngle / 2 * Math.PI / 180;
                    if (this._shrinkSpotLightZPerspective(e, t, u, h, d, f, l) && this._shrinkXYByRadiusPerspective(u, d, l, a, s)) {
                        var m = Cluster._tempVector33;
                        m.x = h.x - u.x, m.y = h.y - u.y, m.z = h.z - u.z, o.normalize(m, m), this._shrinkSpotXYByConePerspective(u, m, d, f, l, a, s),
                            this._placeSpotLightToClusters(i, l);
                    }
                }
            }, {
                key: "_updatePointLightOrth",
                value: function(e, t, r, n, i, a, s) {
                    var l = Cluster._tempLightBound,
                        u = Cluster._tempVector30;
                    o.transformV3ToV3(a._transform.position, i, u), u.z *= -1, this._shrinkSphereLightByBoundOrth(e, t, r, n, u, a.range, l) && this._placePointLightToClusters(s, l);
                }
            }, {
                key: "_updateSpotLightOrth",
                value: function(e, t, r, n, i, a, s) {
                    var l = Cluster._tempLightBound,
                        u = Cluster._tempVector30,
                        c = Cluster._tempVector31,
                        h = Cluster._tempVector34,
                        _ = a._transform.position,
                        d = a.range;
                    a._transform.worldMatrix.getForward(c), o.normalize(c, c), o.scale(c, d, h), o.add(_, h, h),
                        o.transformV3ToV3(_, i, u), o.transformV3ToV3(h, i, h), u.z *= -1, h.z *= -1;
                    var f = a.spotAngle / 2 * Math.PI / 180;
                    this._shrinkSpotLightByBoundOrth(e, t, r, n, u, h, d, f, l) && this._placeSpotLightToClusters(s, l);
                }
            }, {
                key: "update",
                value: function(e, t) {
                    this._updateMark++;
                    var r = e.nearPlane;
                    this._depthSliceParam.x = s._config.lightClusterCount.z / Math.log2(e.farPlane / r),
                        this._depthSliceParam.y = Math.log2(r) * this._depthSliceParam.x;
                    var n = e.nearPlane,
                        i = e.farPlane,
                        a = e.viewMatrix,
                        o = t._directionLights._length,
                        l = t._pointLights,
                        u = l._length,
                        c = l._elements,
                        h = t._spotLights,
                        _ = h._length,
                        d = h._elements;
                    if (e.orthographic) {
                        for (var f = e.orthographicVerticalSize / 2, m = f * e.aspectRatio, T = 0; T < u; T++,
                            o++) this._updatePointLightOrth(m, f, n, i, a, c[T], o);
                        for (T = 0; T < _; T++, o++) this._updateSpotLightOrth(m, f, n, i, a, d[T], o);
                    } else {
                        e._updateClusterPlaneXY();
                        var p = e._clusterXPlanes,
                            v = e._clusterYPlanes;
                        for (T = 0; T < u; T++, o++) this._updatePointLightPerspective(n, i, a, c[T], o, p, v);
                        for (T = 0; T < _; T++, o++) this._updateSpotLightPerspective(n, i, a, d[T], o, p, v);
                    }
                    if (u + _ > 0) {
                        for (var E = this._xSlices, g = this._ySlices, y = this._zSlices, S = E * g * 4, R = S * y, C = this._clusterPixels, M = C.length, x = this._clusterDatas, D = this._updateMark, A = !0, L = 0; L < y; L++)
                            for (var I = 0; I < g; I++)
                                for (var O = 0; O < E; O++) {
                                    var P = x[L][I][O],
                                        N = 4 * (O + I * E + L * E * g);
                                    if (P.updateMark !== D) C[N] = 0, C[N + 1] = 0;
                                    else if (A) {
                                        var b = P.indices,
                                            k = P.pointLightCount,
                                            V = P.spotLightCount,
                                            B = k + V;
                                        if (R + B < M) {
                                            C[N] = k, C[N + 1] = V, C[N + 2] = Math.floor(R / S), C[N + 3] = R % S;
                                            for (T = 0; T < B; T++) C[R++] = b[T];
                                        } else {
                                            B = M - (R + B), k = Math.min(k, B), C[N] = k, C[N + 1] = Math.min(V, B - k), C[N + 2] = Math.floor(R / S),
                                                C[N + 3] = R % S;
                                            for (T = 0; T < B; T++) C[R++] = b[T];
                                            A = !1;
                                        }
                                    }
                                }
                        var w = this._clusterTexture.width;
                        this._clusterTexture.setSubPixels(0, 0, w, Math.ceil(R / (4 * w)), C);
                    }
                }
            }]), Cluster;
        }();
    me._tempVector30 = new o(), me._tempVector31 = new o(), me._tempVector32 = new o(),
        me._tempVector33 = new o(), me._tempVector34 = new o(), me._tempVector35 = new o(),
        me._tempVector36 = new o(), me._tempVector37 = new o(), me._tempLightBound = new function LightBound() {
            _classCallCheck(this, LightBound);
        }();
    var Te = function() {
        function SphericalHarmonicsL2() {
            _classCallCheck(this, SphericalHarmonicsL2), this._coefficients = new Float32Array(27);
        }
        return _createClass(SphericalHarmonicsL2, [{
            key: "getCoefficient",
            value: function(e, t) {
                return this._coefficients[9 * e + t];
            }
        }, {
            key: "setCoefficient",
            value: function(e, t, r) {
                this._coefficients[9 * e + t] = r;
            }
        }, {
            key: "setCoefficients",
            value: function(e, t, r, n, i, a, o, s, l, u) {
                var c = 9 * e;
                this._coefficients[c] = t, this._coefficients[++c] = r, this._coefficients[++c] = n,
                    this._coefficients[++c] = i, this._coefficients[++c] = a, this._coefficients[++c] = o,
                    this._coefficients[++c] = s, this._coefficients[++c] = l, this._coefficients[++c] = u;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                if (this !== e)
                    for (var t = this._coefficients, r = e._coefficients, n = 0; n < 27; n++) r[n] = t[n];
            }
        }]), SphericalHarmonicsL2;
    }();
    Te._default = new Te();
    var pe = function MouseTouch() {
            _classCallCheck(this, MouseTouch), this._pressedSprite = null, this._pressedLoopCount = -1,
                this.sprite = null, this.mousePositionX = 0, this.mousePositionY = 0;
        },
        ve = function() {
            function Touch() {
                _classCallCheck(this, Touch), this._indexInList = -1, this._identifier = -1, this._position = new n();
            }
            return _createClass(Touch, [{
                key: "_getIndexInList",
                value: function() {
                    return this._indexInList;
                }
            }, {
                key: "_setIndexInList",
                value: function(e) {
                    this._indexInList = e;
                }
            }, {
                key: "identifier",
                get: function() {
                    return this._identifier;
                }
            }, {
                key: "position",
                get: function() {
                    return this._position;
                }
            }]), Touch;
        }(),
        Ee = function() {
            function Plane(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                _classCallCheck(this, Plane), this.normal = e, this.distance = t;
            }
            return _createClass(Plane, [{
                key: "normalize",
                value: function() {
                    var e = this.normal.x,
                        t = this.normal.y,
                        r = this.normal.z,
                        n = 1 / Math.sqrt(e * e + t * t + r * r);
                    this.normal.x = e * n, this.normal.y = t * n, this.normal.z = r * n, this.distance *= n;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this.normal.cloneTo(t.normal), t.distance = this.distance;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Plane(new o());
                    return this.cloneTo(e), e;
                }
            }], [{
                key: "createPlaneBy3P",
                value: function(e, t, r, n) {
                    var i = t.x - e.x,
                        a = t.y - e.y,
                        o = t.z - e.z,
                        s = r.x - e.x,
                        l = r.y - e.y,
                        u = r.z - e.z,
                        c = a * u - o * l,
                        h = o * s - i * u,
                        _ = i * l - a * s,
                        d = 1 / Math.sqrt(c * c + h * h + _ * _),
                        f = c * d,
                        m = h * d,
                        T = _ * d,
                        p = n.normal;
                    p.x = f, p.y = m, p.z = T, n.distance = -(f * e.x + m * e.y + T * e.z);
                }
            }]), Plane;
        }();
    Ee.PlaneIntersectionType_Back = 0, Ee.PlaneIntersectionType_Front = 1, Ee.PlaneIntersectionType_Intersecting = 2;
    var ge = function Ray(e, t) {
            _classCallCheck(this, Ray), this.origin = e, this.direction = t;
        },
        ye = function ContainmentType() {
            _classCallCheck(this, ContainmentType);
        };
    ye.Disjoint = 0, ye.Contains = 1, ye.Intersects = 2;
    var Se, Re = function() {
        function CollisionUtils() {
            _classCallCheck(this, CollisionUtils);
        }
        return _createClass(CollisionUtils, null, [{
            key: "distancePlaneToPoint",
            value: function(e, t) {
                return o.dot(e.normal, t) - e.distance;
            }
        }, {
            key: "distanceBoxToPoint",
            value: function(e, t) {
                var r = e.min,
                    n = r.x,
                    i = r.y,
                    a = r.z,
                    o = e.max,
                    s = o.x,
                    l = o.y,
                    u = o.z,
                    c = t.x,
                    h = t.y,
                    _ = t.z,
                    d = 0;
                return c < n && (d += (n - c) * (n - c)), c > s && (d += (s - c) * (s - c)), h < i && (d += (i - h) * (i - h)),
                    h > l && (d += (l - h) * (l - h)), _ < a && (d += (a - _) * (a - _)), _ > u && (d += (u - _) * (u - _)),
                    Math.sqrt(d);
            }
        }, {
            key: "distanceBoxToBox",
            value: function(e, t) {
                var r, n = e.min,
                    i = n.x,
                    a = n.y,
                    o = n.z,
                    s = e.max,
                    l = s.x,
                    u = s.y,
                    c = s.z,
                    h = t.min,
                    _ = h.x,
                    d = h.y,
                    f = h.z,
                    m = t.max,
                    T = m.x,
                    p = m.y,
                    v = m.z,
                    E = 0;
                return i > T ? E += (r = i - T) * r : _ > l && (E += (r = _ - l) * r), a > p ? E += (r = a - p) * r : d > u && (E += (r = d - u) * r),
                    o > v ? E += (r = o - v) * r : f > c && (E += (r = f - c) * r), Math.sqrt(E);
            }
        }, {
            key: "distanceSphereToPoint",
            value: function(e, t) {
                var r = Math.sqrt(o.distanceSquared(e.center, t));
                return r -= e.radius, Math.max(r, 0);
            }
        }, {
            key: "distanceSphereToSphere",
            value: function(e, t) {
                var r = Math.sqrt(o.distanceSquared(e.center, t.center));
                return r -= e.radius + t.radius, Math.max(r, 0);
            }
        }, {
            key: "intersectsRayAndTriangleRD",
            value: function(e, t, n, i, a) {
                var o = e.origin,
                    s = o.x,
                    l = o.y,
                    u = o.z,
                    c = e.direction,
                    h = c.x,
                    _ = c.y,
                    d = c.z,
                    f = t.x,
                    m = t.y,
                    T = t.z,
                    p = n.x,
                    v = n.y,
                    E = n.z,
                    g = i.x,
                    y = i.y,
                    S = i.z,
                    R = CollisionUtils._tempV30.x,
                    C = CollisionUtils._tempV30.y,
                    M = CollisionUtils._tempV30.z;
                R = p - f, C = v - m, M = E - T;
                var x = CollisionUtils._tempV31.x,
                    D = CollisionUtils._tempV31.y,
                    A = CollisionUtils._tempV31.z;
                x = g - f, D = y - m, A = S - T;
                var L = CollisionUtils._tempV32.x,
                    I = CollisionUtils._tempV32.y,
                    O = CollisionUtils._tempV32.z,
                    P = R * (L = _ * A - d * D) + C * (I = d * x - h * A) + M * (O = h * D - _ * x);
                if (r.isZero(P)) return !1;
                var N = 1 / P,
                    b = CollisionUtils._tempV33.x,
                    k = CollisionUtils._tempV33.y,
                    V = CollisionUtils._tempV33.z,
                    B = (b = s - f) * L + (k = l - m) * I + (V = u - T) * O;
                if ((B *= N) < 0 || B > 1) return !1;
                var w = CollisionUtils._tempV34.x,
                    F = CollisionUtils._tempV34.y,
                    U = CollisionUtils._tempV34.z,
                    G = h * (w = k * M - V * C) + _ * (F = V * R - b * M) + d * (U = b * C - k * R);
                if ((G *= N) < 0 || B + G > 1) return !1;
                var z = x * w + D * F + A * U;
                return !((z *= N) < 0);
            }
        }, {
            key: "intersectsRayAndTriangleRP",
            value: function(e, t, r, n, i) {
                return CollisionUtils.intersectsRayAndTriangleRD(e, t, r, n, void 0) ? (o.scale(e.direction, void 0, CollisionUtils._tempV30),
                    o.add(e.origin, CollisionUtils._tempV30, i), !0) : (i = o._ZERO, !1);
            }
        }, {
            key: "intersectsRayAndPoint",
            value: function(e, t) {
                o.subtract(e.origin, t, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, e.direction),
                    i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r.zeroTolerance;
                return !(i > 0 && n > 0) && !(n * n - i < 0);
            }
        }, {
            key: "intersectsRayAndRay",
            value: function(e, t, n) {
                var i = e.origin,
                    a = i.x,
                    s = i.y,
                    l = i.z,
                    u = e.direction,
                    c = u.x,
                    h = u.y,
                    _ = u.z,
                    d = t.origin,
                    f = d.x,
                    m = d.y,
                    T = d.z,
                    p = t.direction,
                    v = p.x,
                    E = p.y,
                    g = p.z;
                o.cross(u, p, CollisionUtils._tempV30);
                var y = CollisionUtils._tempV30,
                    S = o.scalarLength(CollisionUtils._tempV30);
                if (r.isZero(S) && r.nearEqual(f, a) && r.nearEqual(m, s) && r.nearEqual(T, l)) return !0;
                S *= S;
                var R = f - a,
                    C = m - s,
                    M = T - l,
                    x = v,
                    D = E,
                    A = g,
                    L = y.x,
                    I = y.y,
                    O = y.z,
                    P = R * D * O + C * A * L + M * x * I - R * A * I - C * x * O - M * D * L;
                x = c, D = h, A = _;
                var N = P / S;
                o.scale(u, N, CollisionUtils._tempV30), o.scale(p, N, CollisionUtils._tempV31),
                    o.add(i, CollisionUtils._tempV30, CollisionUtils._tempV32), o.add(d, CollisionUtils._tempV31, CollisionUtils._tempV33);
                var b = CollisionUtils._tempV32,
                    k = CollisionUtils._tempV33;
                return !!(r.nearEqual(k.x, b.x) && r.nearEqual(k.y, b.y) && r.nearEqual(k.z, b.z));
            }
        }, {
            key: "intersectsPlaneAndTriangle",
            value: function(e, t, r, n) {
                var i = CollisionUtils.intersectsPlaneAndPoint(e, t),
                    a = CollisionUtils.intersectsPlaneAndPoint(e, r),
                    o = CollisionUtils.intersectsPlaneAndPoint(e, n);
                return i == Ee.PlaneIntersectionType_Front && a == Ee.PlaneIntersectionType_Front && o == Ee.PlaneIntersectionType_Front ? Ee.PlaneIntersectionType_Front : i == Ee.PlaneIntersectionType_Back && a == Ee.PlaneIntersectionType_Back && o == Ee.PlaneIntersectionType_Back ? Ee.PlaneIntersectionType_Back : Ee.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsRayAndPlaneRD",
            value: function(e, t) {
                var n = t.normal,
                    i = o.dot(n, e.direction);
                if (Math.abs(i) < r.zeroTolerance) return -1;
                var a = o.dot(n, e.origin),
                    s = (-t.distance - a) / i;
                if (s < 0) {
                    if (s < -r.zeroTolerance) return -1;
                    s = 0;
                }
                return s;
            }
        }, {
            key: "intersectsRayAndPlaneRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndPlaneRD(e, t);
                if (-1 == n) return r.setValue(0, 0, 0), !1;
                var i = CollisionUtils._tempV30;
                return o.scale(e.direction, n, i), o.add(e.origin, i, r), !0;
            }
        }, {
            key: "intersectsRayAndBoxRD",
            value: function(e, t) {
                var n = e.origin,
                    i = n.x,
                    a = n.y,
                    o = n.z,
                    s = e.direction,
                    l = s.x,
                    u = s.y,
                    c = s.z,
                    h = t.min,
                    _ = h.x,
                    d = h.y,
                    f = h.z,
                    m = t.max,
                    T = m.x,
                    p = m.y,
                    v = m.z,
                    E = 0,
                    g = r.MaxValue;
                if (r.isZero(l)) {
                    if (i < _ || i > T) return -1;
                } else {
                    var y = 1 / l,
                        S = (_ - i) * y,
                        R = (T - i) * y;
                    if (S > R) {
                        var C = S;
                        S = R, R = C;
                    }
                    if ((E = Math.max(S, E)) > (g = Math.min(R, g))) return -1;
                }
                if (r.isZero(u)) {
                    if (a < d || a > p) return -1;
                } else {
                    var M = 1 / u,
                        x = (d - a) * M,
                        D = (p - a) * M;
                    if (x > D) {
                        var A = x;
                        x = D, D = A;
                    }
                    if ((E = Math.max(x, E)) > (g = Math.min(D, g))) return -1;
                }
                if (r.isZero(c)) {
                    if (o < f || o > v) return -1;
                } else {
                    var L = 1 / c,
                        I = (f - o) * L,
                        O = (v - o) * L;
                    if (I > O) {
                        var P = I;
                        I = O, O = P;
                    }
                    if ((E = Math.max(I, E)) > (g = Math.min(O, g))) return -1;
                }
                return E;
            }
        }, {
            key: "intersectsRayAndBoxRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndBoxRD(e, t);
                return -1 === n ? (o._ZERO.cloneTo(r), n) : (o.scale(e.direction, n, CollisionUtils._tempV30),
                    o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(r),
                    n);
            }
        }, {
            key: "intersectsRayAndSphereRD",
            value: function(e, t) {
                var r = t.radius;
                o.subtract(e.origin, t.center, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, e.direction),
                    i = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30) - r * r;
                if (i > 0 && n > 0) return -1;
                var a = n * n - i;
                if (a < 0) return -1;
                var s = -n - Math.sqrt(a);
                return s < 0 && (s = 0), s;
            }
        }, {
            key: "intersectsRayAndSphereRP",
            value: function(e, t, r) {
                var n = CollisionUtils.intersectsRayAndSphereRD(e, t);
                return -1 === n ? (o._ZERO.cloneTo(r), n) : (o.scale(e.direction, n, CollisionUtils._tempV30),
                    o.add(e.origin, CollisionUtils._tempV30, CollisionUtils._tempV31), CollisionUtils._tempV31.cloneTo(r),
                    n);
            }
        }, {
            key: "intersectsSphereAndTriangle",
            value: function(e, t, r, n) {
                var i = e.center,
                    a = e.radius;
                return CollisionUtils.closestPointPointTriangle(i, t, r, n, CollisionUtils._tempV30),
                    o.subtract(CollisionUtils._tempV30, i, CollisionUtils._tempV31), o.dot(CollisionUtils._tempV31, CollisionUtils._tempV31) <= a * a;
            }
        }, {
            key: "intersectsPlaneAndPoint",
            value: function(e, t) {
                var r = o.dot(e.normal, t) + e.distance;
                return r > 0 ? Ee.PlaneIntersectionType_Front : r < 0 ? Ee.PlaneIntersectionType_Back : Ee.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndPlane",
            value: function(e, t) {
                o.cross(e.normal, t.normal, CollisionUtils._tempV30);
                var n = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV30);
                return !r.isZero(n);
            }
        }, {
            key: "intersectsPlaneAndPlaneRL",
            value: function(e, t, n) {
                var i = e.normal,
                    a = t.normal;
                o.cross(i, a, CollisionUtils._tempV34);
                var s = o.dot(CollisionUtils._tempV34, CollisionUtils._tempV34);
                return !r.isZero(s) && (o.scale(a, e.distance, CollisionUtils._tempV30), o.scale(i, t.distance, CollisionUtils._tempV31),
                    o.subtract(CollisionUtils._tempV30, CollisionUtils._tempV31, CollisionUtils._tempV32),
                    o.cross(CollisionUtils._tempV32, CollisionUtils._tempV34, CollisionUtils._tempV33),
                    o.normalize(CollisionUtils._tempV34, CollisionUtils._tempV34), !0);
            }
        }, {
            key: "intersectsPlaneAndBox",
            value: function(e, t) {
                var r = e.distance,
                    n = e.normal,
                    i = n.x,
                    a = n.y,
                    s = n.z,
                    l = t.min,
                    u = l.x,
                    c = l.y,
                    h = l.z,
                    _ = t.max,
                    d = _.x,
                    f = _.y,
                    m = _.z;
                CollisionUtils._tempV30.x = i > 0 ? u : d, CollisionUtils._tempV30.y = a > 0 ? c : f,
                    CollisionUtils._tempV30.z = s > 0 ? h : m, CollisionUtils._tempV31.x = i > 0 ? d : u,
                    CollisionUtils._tempV31.y = a > 0 ? f : c, CollisionUtils._tempV31.z = s > 0 ? m : h;
                var T = o.dot(n, CollisionUtils._tempV30);
                return T + r > 0 ? Ee.PlaneIntersectionType_Front : (T = o.dot(n, CollisionUtils._tempV31)) + r < 0 ? Ee.PlaneIntersectionType_Back : Ee.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsPlaneAndSphere",
            value: function(e, t) {
                var r = t.radius,
                    n = o.dot(e.normal, t.center) + e.distance;
                return n > r ? Ee.PlaneIntersectionType_Front : n < -r ? Ee.PlaneIntersectionType_Back : Ee.PlaneIntersectionType_Intersecting;
            }
        }, {
            key: "intersectsBoxAndBox",
            value: function(e, t) {
                var r = e.min,
                    n = e.max,
                    i = t.min,
                    a = t.max;
                return !(r.x > a.x || i.x > n.x) && (!(r.y > a.y || i.y > n.y) && !(r.z > a.z || i.z > n.z));
            }
        }, {
            key: "intersectsBoxAndSphere",
            value: function(e, t) {
                var r = t.center,
                    n = t.radius,
                    i = CollisionUtils._tempV30;
                return o.Clamp(r, e.min, e.max, i), o.distanceSquared(r, i) <= n * n;
            }
        }, {
            key: "intersectsSphereAndSphere",
            value: function(e, t) {
                var r = e.radius + t.radius;
                return o.distanceSquared(e.center, t.center) <= r * r;
            }
        }, {
            key: "boxContainsPoint",
            value: function(e, t) {
                var r = e.min,
                    n = e.max;
                return r.x <= t.x && n.x >= t.x && r.y <= t.y && n.y >= t.y && r.z <= t.z && n.z >= t.z ? ye.Contains : ye.Disjoint;
            }
        }, {
            key: "boxContainsBox",
            value: function(e, t) {
                var r = e.min,
                    n = r.x,
                    i = r.y,
                    a = r.z,
                    o = e.max,
                    s = o.x,
                    l = o.y,
                    u = o.z,
                    c = t.min,
                    h = c.x,
                    _ = c.y,
                    d = c.z,
                    f = t.max,
                    m = f.x,
                    T = f.y,
                    p = f.z;
                return s < h || n > m ? ye.Disjoint : l < _ || i > T ? ye.Disjoint : u < d || a > p ? ye.Disjoint : n <= h && m <= s && i <= _ && T <= l && a <= d && p <= u ? ye.Contains : ye.Intersects;
            }
        }, {
            key: "boxContainsSphere",
            value: function(e, t) {
                var r = e.min,
                    n = r.x,
                    i = r.y,
                    a = r.z,
                    s = e.max,
                    l = s.x,
                    u = s.y,
                    c = s.z,
                    h = t.center,
                    _ = h.x,
                    d = h.y,
                    f = h.z,
                    m = t.radius;
                return o.Clamp(h, r, s, CollisionUtils._tempV30), o.distanceSquared(h, CollisionUtils._tempV30) > m * m ? ye.Disjoint : n + m <= _ && _ <= l - m && l - n > m && i + m <= d && d <= u - m && u - i > m && a + m <= f && f <= c - m && c - a > m ? ye.Contains : ye.Intersects;
            }
        }, {
            key: "sphereContainsPoint",
            value: function(e, t) {
                return o.distanceSquared(t, e.center) <= e.radius * e.radius ? ye.Contains : ye.Disjoint;
            }
        }, {
            key: "sphereContainsTriangle",
            value: function(e, t, r, n) {
                var i = CollisionUtils.sphereContainsPoint(e, t),
                    a = CollisionUtils.sphereContainsPoint(e, r),
                    o = CollisionUtils.sphereContainsPoint(e, n);
                return i == ye.Contains && a == ye.Contains && o == ye.Contains ? ye.Contains : CollisionUtils.intersectsSphereAndTriangle(e, t, r, n) ? ye.Intersects : ye.Disjoint;
            }
        }, {
            key: "sphereContainsBox",
            value: function(e, t) {
                var r = e.center,
                    n = r.x,
                    i = r.y,
                    a = r.z,
                    s = e.radius,
                    l = t.min,
                    u = l.x,
                    c = l.y,
                    h = l.z,
                    _ = t.max,
                    d = _.x,
                    f = _.y,
                    m = _.z,
                    T = CollisionUtils._tempV30;
                T.x, T.y, T.z;
                if (!CollisionUtils.intersectsBoxAndSphere(t, e)) return ye.Disjoint;
                var p = s * s;
                return n - u, i - f, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - d,
                    i - f, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - d,
                        i - c, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - u,
                            i - c, a - m, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - u,
                                i - f, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - d,
                                    i - f, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - d,
                                        i - c, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : (n - u,
                                            i - c, a - h, o.scalarLengthSquared(CollisionUtils._tempV30) > p ? ye.Intersects : ye.Contains)))))));
            }
        }, {
            key: "sphereContainsSphere",
            value: function(e, t) {
                var r = e.radius,
                    n = t.radius,
                    i = o.distance(e.center, t.center);
                return r + n < i ? ye.Disjoint : r - n < i ? ye.Intersects : ye.Contains;
            }
        }, {
            key: "closestPointPointTriangle",
            value: function(e, t, r, n, i) {
                o.subtract(r, t, CollisionUtils._tempV30), o.subtract(n, t, CollisionUtils._tempV31),
                    o.subtract(e, t, CollisionUtils._tempV32), o.subtract(e, r, CollisionUtils._tempV33),
                    o.subtract(e, n, CollisionUtils._tempV34);
                var a = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV32),
                    s = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV32),
                    l = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV33),
                    u = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV33),
                    c = o.dot(CollisionUtils._tempV30, CollisionUtils._tempV34),
                    h = o.dot(CollisionUtils._tempV31, CollisionUtils._tempV34);
                if (a <= 0 && s <= 0) t.cloneTo(i);
                else if (l >= 0 && u <= l) r.cloneTo(i);
                else {
                    var _ = a * u - l * s;
                    if (_ <= 0 && a >= 0 && l <= 0) {
                        var d = a / (a - l);
                        return o.scale(CollisionUtils._tempV30, d, i), void o.add(t, i, i);
                    }
                    if (h >= 0 && c <= h) n.cloneTo(i);
                    else {
                        var f = c * s - a * h;
                        if (f <= 0 && s >= 0 && h <= 0) {
                            var m = s / (s - h);
                            return o.scale(CollisionUtils._tempV31, m, i), void o.add(t, i, i);
                        }
                        var T = l * h - c * u;
                        if (T <= 0 && u - l >= 0 && c - h >= 0) {
                            var p = (u - l) / (u - l + (c - h));
                            return o.subtract(n, r, i), o.scale(i, p, i), void o.add(r, i, i);
                        }
                        var v = 1 / (T + f + _),
                            E = f * v,
                            g = _ * v;
                        o.scale(CollisionUtils._tempV30, E, CollisionUtils._tempV35), o.scale(CollisionUtils._tempV31, g, CollisionUtils._tempV36),
                            o.add(CollisionUtils._tempV35, CollisionUtils._tempV36, i), o.add(t, i, i);
                    }
                }
            }
        }, {
            key: "closestPointPlanePoint",
            value: function(e, t, r) {
                var n = e.normal,
                    i = o.dot(n, t) - e.distance;
                o.scale(n, i, CollisionUtils._tempV30), o.subtract(t, CollisionUtils._tempV30, r);
            }
        }, {
            key: "closestPointBoxPoint",
            value: function(e, t, r) {
                o.max(t, e.min, CollisionUtils._tempV30), o.min(CollisionUtils._tempV30, e.max, r);
            }
        }, {
            key: "closestPointSpherePoint",
            value: function(e, t, r) {
                var n = e.center;
                o.subtract(t, n, r), o.normalize(r, r), o.scale(r, e.radius, r), o.add(r, n, r);
            }
        }, {
            key: "closestPointSphereSphere",
            value: function(e, t, r) {
                var n = e.center;
                o.subtract(t.center, n, r), o.normalize(r, r), o.scale(r, e.radius, r), o.add(r, n, r);
            }
        }]), CollisionUtils;
    }();
    Re._tempV30 = new o(), Re._tempV31 = new o(), Re._tempV32 = new o(), Re._tempV33 = new o(),
        Re._tempV34 = new o(), Re._tempV35 = new o(), Re._tempV36 = new o(), (Se = e.FrustumCorner || (e.FrustumCorner = {}))[Se.FarBottomLeft = 0] = "FarBottomLeft",
        Se[Se.FarTopLeft = 1] = "FarTopLeft", Se[Se.FarTopRight = 2] = "FarTopRight", Se[Se.FarBottomRight = 3] = "FarBottomRight",
        Se[Se.nearBottomLeft = 4] = "nearBottomLeft", Se[Se.nearTopLeft = 5] = "nearTopLeft",
        Se[Se.nearTopRight = 6] = "nearTopRight", Se[Se.nearBottomRight = 7] = "nearBottomRight",
        Se[Se.unknown = 8] = "unknown";
    var Ce = function() {
        function BoundFrustum(e) {
            _classCallCheck(this, BoundFrustum), this._matrix = e, this._near = new Ee(new o()),
                this._far = new Ee(new o()), this._left = new Ee(new o()), this._right = new Ee(new o()),
                this._top = new Ee(new o()), this._bottom = new Ee(new o()), BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        return _createClass(BoundFrustum, [{
            key: "equalsBoundFrustum",
            value: function(e) {
                return this._matrix.equalsOtherMatrix(e.matrix);
            }
        }, {
            key: "equalsObj",
            value: function(e) {
                if (e instanceof BoundFrustum) {
                    var t = e;
                    return this.equalsBoundFrustum(t);
                }
                return !1;
            }
        }, {
            key: "getPlane",
            value: function(e) {
                switch (e) {
                    case 0:
                        return this._near;

                    case 1:
                        return this._far;

                    case 2:
                        return this._left;

                    case 3:
                        return this._right;

                    case 4:
                        return this._top;

                    case 5:
                        return this._bottom;

                    default:
                        return null;
                }
            }
        }, {
            key: "getCorners",
            value: function(t) {
                BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._right, t[e.FrustumCorner.nearBottomRight]),
                    BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._right, t[e.FrustumCorner.nearTopRight]),
                    BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._left, t[e.FrustumCorner.nearTopLeft]),
                    BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._left, t[e.FrustumCorner.nearBottomLeft]),
                    BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._right, t[e.FrustumCorner.FarBottomRight]),
                    BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._right, t[e.FrustumCorner.FarTopRight]),
                    BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._left, t[e.FrustumCorner.FarTopLeft]),
                    BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._left, t[e.FrustumCorner.FarBottomLeft]);
            }
        }, {
            key: "containsPoint",
            value: function(e) {
                for (var t = Ee.PlaneIntersectionType_Front, r = Ee.PlaneIntersectionType_Front, n = 0; n < 6; n++) {
                    switch (n) {
                        case 0:
                            r = Re.intersectsPlaneAndPoint(this._near, e);
                            break;

                        case 1:
                            r = Re.intersectsPlaneAndPoint(this._far, e);
                            break;

                        case 2:
                            r = Re.intersectsPlaneAndPoint(this._left, e);
                            break;

                        case 3:
                            r = Re.intersectsPlaneAndPoint(this._right, e);
                            break;

                        case 4:
                            r = Re.intersectsPlaneAndPoint(this._top, e);
                            break;

                        case 5:
                            r = Re.intersectsPlaneAndPoint(this._bottom, e);
                    }
                    switch (r) {
                        case Ee.PlaneIntersectionType_Back:
                            return ye.Disjoint;

                        case Ee.PlaneIntersectionType_Intersecting:
                            t = Ee.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                    case Ee.PlaneIntersectionType_Intersecting:
                        return ye.Intersects;

                    default:
                        return ye.Contains;
                }
            }
        }, {
            key: "intersects",
            value: function(e) {
                var t = e.min,
                    r = e.max,
                    n = t.x,
                    i = t.y,
                    a = t.z,
                    o = r.x,
                    s = r.y,
                    l = r.z,
                    u = this._near.normal;
                if (this._near.distance + u.x * (u.x < 0 ? n : o) + u.y * (u.y < 0 ? i : s) + u.z * (u.z < 0 ? a : l) < 0) return !1;
                var c = this._left.normal;
                if (this._left.distance + c.x * (c.x < 0 ? n : o) + c.y * (c.y < 0 ? i : s) + c.z * (c.z < 0 ? a : l) < 0) return !1;
                var h = this._right.normal;
                if (this._right.distance + h.x * (h.x < 0 ? n : o) + h.y * (h.y < 0 ? i : s) + h.z * (h.z < 0 ? a : l) < 0) return !1;
                var _ = this._bottom.normal;
                if (this._bottom.distance + _.x * (_.x < 0 ? n : o) + _.y * (_.y < 0 ? i : s) + _.z * (_.z < 0 ? a : l) < 0) return !1;
                var d = this._top.normal;
                if (this._top.distance + d.x * (d.x < 0 ? n : o) + d.y * (d.y < 0 ? i : s) + d.z * (d.z < 0 ? a : l) < 0) return !1;
                var f = this._far.normal;
                return !(this._far.distance + f.x * (f.x < 0 ? n : o) + f.y * (f.y < 0 ? i : s) + f.z * (f.z < 0 ? a : l) < 0);
            }
        }, {
            key: "containsBoundBox",
            value: function(e) {
                for (var t = BoundFrustum._tempV30, r = BoundFrustum._tempV31, n = e.min, i = e.max, a = ye.Contains, o = 0; o < 6; o++) {
                    var s = this.getPlane(o),
                        l = s.normal;
                    if (l.x >= 0 ? (t.x = i.x, r.x = n.x) : (t.x = n.x, r.x = i.x), l.y >= 0 ? (t.y = i.y,
                            r.y = n.y) : (t.y = n.y, r.y = i.y), l.z >= 0 ? (t.z = i.z, r.z = n.z) : (t.z = n.z,
                            r.z = i.z), Re.intersectsPlaneAndPoint(s, t) === Ee.PlaneIntersectionType_Back) return ye.Disjoint;
                    Re.intersectsPlaneAndPoint(s, r) === Ee.PlaneIntersectionType_Back && (a = ye.Intersects);
                }
                return a;
            }
        }, {
            key: "containsBoundSphere",
            value: function(e) {
                for (var t = Ee.PlaneIntersectionType_Front, r = Ee.PlaneIntersectionType_Front, n = 0; n < 6; n++) {
                    switch (n) {
                        case 0:
                            r = Re.intersectsPlaneAndSphere(this._near, e);
                            break;

                        case 1:
                            r = Re.intersectsPlaneAndSphere(this._far, e);
                            break;

                        case 2:
                            r = Re.intersectsPlaneAndSphere(this._left, e);
                            break;

                        case 3:
                            r = Re.intersectsPlaneAndSphere(this._right, e);
                            break;

                        case 4:
                            r = Re.intersectsPlaneAndSphere(this._top, e);
                            break;

                        case 5:
                            r = Re.intersectsPlaneAndSphere(this._bottom, e);
                    }
                    switch (r) {
                        case Ee.PlaneIntersectionType_Back:
                            return ye.Disjoint;

                        case Ee.PlaneIntersectionType_Intersecting:
                            t = Ee.PlaneIntersectionType_Intersecting;
                    }
                }
                switch (t) {
                    case Ee.PlaneIntersectionType_Intersecting:
                        return ye.Intersects;

                    default:
                        return ye.Contains;
                }
            }
        }, {
            key: "matrix",
            get: function() {
                return this._matrix;
            },
            set: function(e) {
                e.cloneTo(this._matrix), BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
            }
        }, {
            key: "near",
            get: function() {
                return this._near;
            }
        }, {
            key: "far",
            get: function() {
                return this._far;
            }
        }, {
            key: "left",
            get: function() {
                return this._left;
            }
        }, {
            key: "right",
            get: function() {
                return this._right;
            }
        }, {
            key: "top",
            get: function() {
                return this._top;
            }
        }, {
            key: "bottom",
            get: function() {
                return this._bottom;
            }
        }], [{
            key: "getPlanesFromMatrix",
            value: function(e, t, r, n, i, a, o) {
                var s = e.elements,
                    l = s[0],
                    u = s[1],
                    c = s[2],
                    h = s[3],
                    _ = s[4],
                    d = s[5],
                    f = s[6],
                    m = s[7],
                    T = s[8],
                    p = s[9],
                    v = s[10],
                    E = s[11],
                    g = s[12],
                    y = s[13],
                    S = s[14],
                    R = s[15],
                    C = t.normal;
                C.x = c, C.y = f, C.z = v, t.distance = S, t.normalize();
                var M = r.normal;
                M.x = h - c, M.y = m - f, M.z = E - v, r.distance = R - S, r.normalize();
                var x = n.normal;
                x.x = h + l, x.y = m + _, x.z = E + T, n.distance = R + g, n.normalize();
                var D = i.normal;
                D.x = h - l, D.y = m - _, D.z = E - T, i.distance = R - g, i.normalize();
                var A = a.normal;
                A.x = h - u, A.y = m - d, A.z = E - p, a.distance = R - y, a.normalize();
                var L = o.normal;
                L.x = h + u, L.y = m + d, L.z = E + p, o.distance = R + y, o.normalize();
            }
        }, {
            key: "get3PlaneInterPoint",
            value: function(e, t, r, n) {
                var i = e.normal,
                    a = t.normal,
                    s = r.normal;
                o.cross(a, s, BoundFrustum._tempV30), o.cross(s, i, BoundFrustum._tempV31), o.cross(i, a, BoundFrustum._tempV32);
                var l = o.dot(i, BoundFrustum._tempV30),
                    u = o.dot(a, BoundFrustum._tempV31),
                    c = o.dot(s, BoundFrustum._tempV32);
                o.scale(BoundFrustum._tempV30, -e.distance / l, BoundFrustum._tempV33), o.scale(BoundFrustum._tempV31, -t.distance / u, BoundFrustum._tempV34),
                    o.scale(BoundFrustum._tempV32, -r.distance / c, BoundFrustum._tempV35), o.add(BoundFrustum._tempV33, BoundFrustum._tempV34, BoundFrustum._tempV36),
                    o.add(BoundFrustum._tempV35, BoundFrustum._tempV36, n);
            }
        }]), BoundFrustum;
    }();
    Ce._tempV30 = new o(), Ce._tempV31 = new o(), Ce._tempV32 = new o(), Ce._tempV33 = new o(),
        Ce._tempV34 = new o(), Ce._tempV35 = new o(), Ce._tempV36 = new o();
    var Me = function() {
        function Viewport(e, t, r, n) {
            _classCallCheck(this, Viewport), this.minDepth = 0, this.maxDepth = 1, this.x = e,
                this.y = t, this.width = r, this.height = n;
        }
        return _createClass(Viewport, [{
            key: "project",
            value: function(e, t, r) {
                o.transformV3ToV4(e, t, r);
                var n = r.x,
                    i = r.y,
                    a = r.z,
                    s = r.w;
                1 !== s && (n /= s, i /= s, a /= s), r.x = .5 * (n + 1) * this.width + this.x, r.y = .5 * (1 - i) * this.height + this.y,
                    r.z = a * (this.maxDepth - this.minDepth) + this.minDepth;
            }
        }, {
            key: "unprojectFromMat",
            value: function(e, t, r) {
                var n = t.elements;
                r.x = (e.x - this.x) / this.width * 2 - 1, r.y = -((e.y - this.y) / this.height * 2 - 1),
                    r.z = (e.z - this.minDepth) / (this.maxDepth - this.minDepth);
                var i = r.x * n[3] + r.y * n[7] + r.z * n[11] + n[15];
                o.transformV3ToV3(r, t, r), 1 !== i && (r.x = r.x / i, r.y = r.y / i, r.z = r.z / i);
            }
        }, {
            key: "unprojectFromWVP",
            value: function(e, t, r, n, i) {
                L.multiply(t, r, Viewport._tempMatrix4x4), n && L.multiply(Viewport._tempMatrix4x4, n, Viewport._tempMatrix4x4),
                    Viewport._tempMatrix4x4.invert(Viewport._tempMatrix4x4), this.unprojectFromMat(e, Viewport._tempMatrix4x4, i);
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth,
                    e.maxDepth = this.maxDepth;
            }
        }]), Viewport;
    }();
    Me._tempMatrix4x4 = new L();
    var xe = function() {
        function Picker() {
            _classCallCheck(this, Picker);
        }
        return _createClass(Picker, null, [{
            key: "calculateCursorRay",
            value: function(e, t, r, n, i, a) {
                var s = e.x,
                    l = e.y,
                    u = Picker._tempVector30,
                    c = u;
                c.x = s, c.y = l, c.z = t.minDepth;
                var h = Picker._tempVector31,
                    _ = h;
                _.x = s, _.y = l, _.z = t.maxDepth;
                var d = a.origin,
                    f = Picker._tempVector32;
                t.unprojectFromWVP(u, r, n, i, d), t.unprojectFromWVP(h, r, n, i, f);
                var m = a.direction;
                m.x = f.x - d.x, m.y = f.y - d.y, m.z = f.z - d.z, o.normalize(a.direction, a.direction);
            }
        }, {
            key: "rayIntersectsTriangle",
            value: function(e, t, r, n) {
                var i = Picker._tempVector30,
                    a = Picker._tempVector31;
                o.subtract(r, t, i), o.subtract(n, t, a);
                var s, l = Picker._tempVector32;
                if (o.cross(e.direction, a, l), (s = o.dot(i, l)) > -Number.MIN_VALUE && s < Number.MIN_VALUE) return Number.NaN;
                var u, c = 1 / s,
                    h = Picker._tempVector33;
                if (o.subtract(e.origin, t, h), u = o.dot(h, l), (u *= c) < 0 || u > 1) return Number.NaN;
                var _, d, f = Picker._tempVector34;
                return o.cross(h, i, f), _ = o.dot(e.direction, f), (_ *= c) < 0 || u + _ > 1 ? Number.NaN : (d = o.dot(a, f),
                    (d *= c) < 0 ? Number.NaN : d);
            }
        }]), Picker;
    }();
    xe._tempVector30 = new o(), xe._tempVector31 = new o(), xe._tempVector32 = new o(),
        xe._tempVector33 = new o(), xe._tempVector34 = new o();
    var De, Ae = function(e) {
        function BufferState() {
            return _classCallCheck(this, BufferState), _possibleConstructorReturn(this, _getPrototypeOf(BufferState).call(this));
        }
        return _inherits(BufferState, t.BufferStateBase), _createClass(BufferState, [{
            key: "applyVertexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var r = t.LayaGL.instance,
                    n = e.vertexDeclaration,
                    i = n._shaderValues.getData();
                for (var a in this.vertexDeclaration = n, e.bind(), i) {
                    var o = parseInt(a),
                        s = i[a];
                    r.enableVertexAttribArray(o), r.vertexAttribPointer(o, s[0], s[1], !!s[2], s[3], s[4]);
                }
            }
        }, {
            key: "applyVertexBuffers",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                for (var r = t.LayaGL.instance, n = 0, i = e.length; n < i; n++) {
                    var a = e[n],
                        o = a.vertexDeclaration._shaderValues.getData();
                    for (var s in a.bind(), o) {
                        var l = parseInt(s),
                            u = o[s];
                        r.enableVertexAttribArray(l), r.vertexAttribPointer(l, u[0], u[1], !!u[2], u[3], u[4]);
                    }
                }
            }
        }, {
            key: "applyInstanceVertexBuffer",
            value: function(e) {
                if (t.LayaGL.layaGPUInstance.supportInstance()) {
                    if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                    var r = t.LayaGL.instance,
                        n = e.vertexDeclaration._shaderValues.getData();
                    for (var i in e.bind(), n) {
                        var a = parseInt(i),
                            o = n[i];
                        r.enableVertexAttribArray(a), r.vertexAttribPointer(a, o[0], o[1], !!o[2], o[3], o[4]),
                            t.LayaGL.layaGPUInstance.vertexAttribDivisor(a, 1);
                    }
                }
            }
        }, {
            key: "applyIndexBuffer",
            value: function(e) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
            }
        }]), BufferState;
    }();
    (De = e.IndexFormat || (e.IndexFormat = {}))[De.UInt8 = 0] = "UInt8", De[De.UInt16 = 1] = "UInt16",
        De[De.UInt32 = 2] = "UInt32";
    var Le = function(r) {
            function IndexBuffer3D(r, n) {
                var i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 35044,
                    o = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                switch (_classCallCheck(this, IndexBuffer3D), (i = _possibleConstructorReturn(this, _getPrototypeOf(IndexBuffer3D).call(this)))._indexType = r,
                    i._indexCount = n, i._bufferUsage = a, i._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER,
                    i._canRead = o, r) {
                    case e.IndexFormat.UInt32:
                        i._indexTypeByteCount = 4;
                        break;

                    case e.IndexFormat.UInt16:
                        i._indexTypeByteCount = 2;
                        break;

                    case e.IndexFormat.UInt8:
                        i._indexTypeByteCount = 1;
                        break;

                    default:
                        throw new Error("unidentification index type.");
                }
                var s = i._indexTypeByteCount * n,
                    l = t.BufferStateBase._curBindedBufferState;
                if (i._byteLength = s, l ? l._bindedIndexBuffer === _assertThisInitialized(i) ? t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage) : (l.unBind(),
                        i.bind(), t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage), l.bind()) : (i.bind(),
                        t.LayaGL.instance.bufferData(i._bufferType, s, i._bufferUsage)), o) switch (r) {
                    case e.IndexFormat.UInt32:
                        i._buffer = new Uint32Array(n);
                        break;

                    case e.IndexFormat.UInt16:
                        i._buffer = new Uint16Array(n);
                        break;

                    case e.IndexFormat.UInt8:
                        i._buffer = new Uint8Array(n);
                }
                return i;
            }
            return _inherits(IndexBuffer3D, t.Buffer), _createClass(IndexBuffer3D, [{
                key: "indexType",
                get: function() {
                    return this._indexType;
                }
            }, {
                key: "indexTypeByteCount",
                get: function() {
                    return this._indexTypeByteCount;
                }
            }, {
                key: "indexCount",
                get: function() {
                    return this._indexCount;
                }
            }, {
                key: "canRead",
                get: function() {
                    return this._canRead;
                }
            }]), _createClass(IndexBuffer3D, [{
                key: "_bindForVAO",
                value: function() {
                    if (!t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
                    var e = t.LayaGL.instance;
                    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
                }
            }, {
                key: "bind",
                value: function() {
                    if (t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
                    if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                        var e = t.LayaGL.instance;
                        return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedIndexBuffer = this._glBuffer, !0;
                    }
                    return !1;
                }
            }, {
                key: "setData",
                value: function(r) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 4294967295,
                        o = this._indexTypeByteCount;
                    if (0 !== i || 4294967295 !== a) switch (this._indexType) {
                        case e.IndexFormat.UInt32:
                            r = new Uint32Array(r.buffer, i * o, a);
                            break;

                        case e.IndexFormat.UInt16:
                            r = new Uint16Array(r.buffer, i * o, a);
                            break;

                        case e.IndexFormat.UInt8:
                            r = new Uint8Array(r.buffer, i * o, a);
                    }
                    var s = t.BufferStateBase._curBindedBufferState;
                    if (s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r) : (s.unBind(),
                            this.bind(), t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r), s.bind()) : (this.bind(),
                            t.LayaGL.instance.bufferSubData(this._bufferType, n * o, r)), this._canRead)
                        if (0 !== n || 0 !== i || 4294967295 !== a) {
                            var l = this._buffer.length - n;
                            a > l && (a = l);
                            for (var u = 0; u < a; u++) this._buffer[n + u] = r[u];
                        } else this._buffer = r;
                }
            }, {
                key: "getData",
                value: function() {
                    if (this._canRead) return this._buffer;
                    throw new Error("Can't read data from VertexBuffer with only write flag!");
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(IndexBuffer3D.prototype), "destroy", this).call(this), this._buffer = null;
                }
            }]), IndexBuffer3D;
        }(),
        Ie = function() {
            function VertexElementFormat() {
                _classCallCheck(this, VertexElementFormat);
            }
            return _createClass(VertexElementFormat, null, [{
                key: "__init__",
                value: function() {
                    var e = t.LayaGL.instance;
                    VertexElementFormat._elementInfos = {
                        single: [1, e.FLOAT, 0],
                        vector2: [2, e.FLOAT, 0],
                        vector3: [3, e.FLOAT, 0],
                        vector4: [4, e.FLOAT, 0],
                        color: [4, e.FLOAT, 0],
                        byte4: [4, e.UNSIGNED_BYTE, 0],
                        short2: [2, e.FLOAT, 0],
                        short4: [4, e.FLOAT, 0],
                        normalizedshort2: [2, e.FLOAT, 0],
                        normalizedshort4: [4, e.FLOAT, 0],
                        halfvector2: [2, e.FLOAT, 0],
                        halfvector4: [4, e.FLOAT, 0]
                    };
                }
            }, {
                key: "getElementInfos",
                value: function(e) {
                    var t = VertexElementFormat._elementInfos[e];
                    if (t) return t;
                    throw "VertexElementFormat: this vertexElementFormat is not implement.";
                }
            }]), VertexElementFormat;
        }();
    Ie.Single = "single", Ie.Vector2 = "vector2", Ie.Vector3 = "vector3", Ie.Vector4 = "vector4",
        Ie.Color = "color", Ie.Byte4 = "byte4", Ie.Short2 = "short2", Ie.Short4 = "short4",
        Ie.NormalizedShort2 = "normalizedshort2", Ie.NormalizedShort4 = "normalizedshort4",
        Ie.HalfVector2 = "halfvector2", Ie.HalfVector4 = "halfvector4";
    var Oe = function() {
        function VertexDeclaration(e, t) {
            _classCallCheck(this, VertexDeclaration), this._id = ++VertexDeclaration._uniqueIDCounter,
                this._vertexElementsDic = {}, this._vertexStride = e, this._vertexElements = t;
            var r = t.length;
            this._shaderValues = new z(null);
            for (var n = 0; n < r; n++) {
                var i = t[n],
                    a = i._elementUsage;
                this._vertexElementsDic[a] = i;
                var o = new Int32Array(5),
                    s = Ie.getElementInfos(i._elementFormat);
                o[0] = s[0], o[1] = s[1], o[2] = s[2], o[3] = this._vertexStride, o[4] = i._offset,
                    this._shaderValues.setAttribute(a, o);
            }
        }
        return _createClass(VertexDeclaration, [{
            key: "getVertexElementByIndex",
            value: function(e) {
                return this._vertexElements[e];
            }
        }, {
            key: "getVertexElementByUsage",
            value: function(e) {
                return this._vertexElementsDic[e];
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "vertexStride",
            get: function() {
                return this._vertexStride;
            }
        }, {
            key: "vertexElementCount",
            get: function() {
                return this._vertexElements.length;
            }
        }]), VertexDeclaration;
    }();
    Oe._uniqueIDCounter = 1;
    var Pe = function() {
            function VertexElement(e, t, r) {
                _classCallCheck(this, VertexElement), this._offset = e, this._elementFormat = t,
                    this._elementUsage = r;
            }
            return _createClass(VertexElement, [{
                key: "offset",
                get: function() {
                    return this._offset;
                }
            }, {
                key: "elementFormat",
                get: function() {
                    return this._elementFormat;
                }
            }, {
                key: "elementUsage",
                get: function() {
                    return this._elementUsage;
                }
            }]), VertexElement;
        }(),
        Ne = function() {
            function VertexMesh() {
                _classCallCheck(this, VertexMesh);
            }
            return _createClass(VertexMesh, null, [{
                key: "__init__",
                value: function() {
                    VertexMesh.instanceWorldMatrixDeclaration = new Oe(64, [new Pe(0, Ie.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0), new Pe(16, Ie.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1), new Pe(32, Ie.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2), new Pe(48, Ie.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3)]),
                        VertexMesh.instanceMVPMatrixDeclaration = new Oe(64, [new Pe(0, Ie.Vector4, VertexMesh.MESH_MVPMATRIX_ROW0), new Pe(16, Ie.Vector4, VertexMesh.MESH_MVPMATRIX_ROW1), new Pe(32, Ie.Vector4, VertexMesh.MESH_MVPMATRIX_ROW2), new Pe(48, Ie.Vector4, VertexMesh.MESH_MVPMATRIX_ROW3)]);
                }
            }, {
                key: "getVertexDeclaration",
                value: function(e) {
                    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        r = VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")];
                    if (!r) {
                        for (var n = e.split(","), i = 0, a = [], o = 0, s = n.length; o < s; o++) {
                            var l;
                            switch (n[o]) {
                                case "POSITION":
                                    l = new Pe(i, Ie.Vector3, VertexMesh.MESH_POSITION0), i += 12;
                                    break;

                                case "NORMAL":
                                    l = new Pe(i, Ie.Vector3, VertexMesh.MESH_NORMAL0), i += 12;
                                    break;

                                case "COLOR":
                                    l = new Pe(i, Ie.Vector4, VertexMesh.MESH_COLOR0), i += 16;
                                    break;

                                case "UV":
                                    l = new Pe(i, Ie.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0), i += 8;
                                    break;

                                case "UV1":
                                    l = new Pe(i, Ie.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1), i += 8;
                                    break;

                                case "BLENDWEIGHT":
                                    l = new Pe(i, Ie.Vector4, VertexMesh.MESH_BLENDWEIGHT0), i += 16;
                                    break;

                                case "BLENDINDICES":
                                    t ? (l = new Pe(i, Ie.Vector4, VertexMesh.MESH_BLENDINDICES0), i += 16) : (l = new Pe(i, Ie.Byte4, VertexMesh.MESH_BLENDINDICES0),
                                        i += 4);
                                    break;

                                case "TANGENT":
                                    l = new Pe(i, Ie.Vector4, VertexMesh.MESH_TANGENT0), i += 16;
                                    break;

                                default:
                                    throw "VertexMesh: unknown vertex flag.";
                            }
                            a.push(l);
                        }
                        r = new Oe(i, a), VertexMesh._vertexDeclarationMap[e + (t ? "_0" : "_1")] = r;
                    }
                    return r;
                }
            }]), VertexMesh;
        }();
    Ne.MESH_POSITION0 = 0, Ne.MESH_COLOR0 = 1, Ne.MESH_TEXTURECOORDINATE0 = 2, Ne.MESH_NORMAL0 = 3,
        Ne.MESH_TANGENT0 = 4, Ne.MESH_BLENDINDICES0 = 5, Ne.MESH_BLENDWEIGHT0 = 6, Ne.MESH_TEXTURECOORDINATE1 = 7,
        Ne.MESH_WORLDMATRIX_ROW0 = 8, Ne.MESH_WORLDMATRIX_ROW1 = 9, Ne.MESH_WORLDMATRIX_ROW2 = 10,
        Ne.MESH_WORLDMATRIX_ROW3 = 11, Ne.MESH_MVPMATRIX_ROW0 = 12, Ne.MESH_MVPMATRIX_ROW1 = 13,
        Ne.MESH_MVPMATRIX_ROW2 = 14, Ne.MESH_MVPMATRIX_ROW3 = 15, Ne._vertexDeclarationMap = {};
    var be = function(e) {
        function VertexBuffer3D(e, r) {
            var n, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, VertexBuffer3D), (n = _possibleConstructorReturn(this, _getPrototypeOf(VertexBuffer3D).call(this)))._vertexDeclaration = null,
                n._float32Reader = null;
            var a = t.LayaGL.instance;
            return n._bufferUsage = r, n._bufferType = a.ARRAY_BUFFER, n._canRead = i, n._byteLength = e,
                n.bind(), a.bufferData(n._bufferType, n._byteLength, n._bufferUsage), i && (n._buffer = new Uint8Array(e),
                    n._float32Reader = new Float32Array(n._buffer.buffer)), n;
        }
        return _inherits(VertexBuffer3D, t.Buffer), _createClass(VertexBuffer3D, [{
            key: "bind",
            value: function() {
                if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                    var e = t.LayaGL.instance;
                    return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedVertexBuffer = this._glBuffer, !0;
                }
                return !1;
            }
        }, {
            key: "orphanStorage",
            value: function() {
                this.bind(), t.LayaGL.instance.bufferData(this._bufferType, this._byteLength, this._bufferUsage);
            }
        }, {
            key: "setData",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Number.MAX_SAFE_INTEGER;
                if (this.bind(), 0 !== n || i !== Number.MAX_SAFE_INTEGER) {
                    var a = new Uint8Array(e, n, i);
                    t.LayaGL.instance.bufferSubData(this._bufferType, r, a), this._canRead && this._buffer.set(a, r);
                } else t.LayaGL.instance.bufferSubData(this._bufferType, r, e), this._canRead && this._buffer.set(new Uint8Array(e), r);
            }
        }, {
            key: "getUint8Data",
            value: function() {
                if (this._canRead) return this._buffer;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "getFloat32Data",
            value: function() {
                if (this._canRead) return this._float32Reader;
                throw new Error("Can't read data from VertexBuffer with only write flag!");
            }
        }, {
            key: "markAsUnreadbale",
            value: function() {
                this._canRead = !1, this._buffer = null, this._float32Reader = null;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(VertexBuffer3D.prototype), "destroy", this).call(this), this._buffer = null,
                    this._float32Reader = null, this._vertexDeclaration = null;
            }
        }, {
            key: "vertexDeclaration",
            get: function() {
                return this._vertexDeclaration;
            },
            set: function(e) {
                this._vertexDeclaration = e;
            }
        }, {
            key: "canRead",
            get: function() {
                return this._canRead;
            }
        }]), VertexBuffer3D;
    }();
    be.DATATYPE_FLOAT32ARRAY = 0, be.DATATYPE_UINT8ARRAY = 1;
    var ke = function() {
            function SkyMesh() {
                _classCallCheck(this, SkyMesh);
            }
            return _createClass(SkyMesh, [{
                key: "_render",
                value: function(e) {}
            }]), SkyMesh;
        }(),
        Ve = function(r) {
            function SkyBox() {
                var r;
                _classCallCheck(this, SkyBox), r = _possibleConstructorReturn(this, _getPrototypeOf(SkyBox).call(this));
                var n = t.LayaGL.instance,
                    i = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1]),
                    a = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0]),
                    o = Ne.getVertexDeclaration("POSITION");
                r._vertexBuffer = new be(8 * o.vertexStride, n.STATIC_DRAW, !1), r._vertexBuffer.vertexDeclaration = o,
                    r._indexBuffer = new Le(e.IndexFormat.UInt8, 36, n.STATIC_DRAW, !1), r._vertexBuffer.setData(i.buffer),
                    r._indexBuffer.setData(a);
                var s = new Ae();
                return s.bind(), s.applyVertexBuffer(r._vertexBuffer), s.applyIndexBuffer(r._indexBuffer),
                    s.unBind(), r._bufferState = s, r;
            }
            return _inherits(SkyBox, ke), _createClass(SkyBox, null, [{
                key: "__init__",
                value: function() {
                    SkyBox.instance = new SkyBox();
                }
            }]), _createClass(SkyBox, [{
                key: "_render",
                value: function(e) {
                    var r = t.LayaGL.instance;
                    r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces += 12,
                        t.Stat.renderBatches++;
                }
            }]), SkyBox;
        }(),
        Be = function() {
            function SkyRenderer() {
                _classCallCheck(this, SkyRenderer), this._mesh = Ve.instance;
            }
            return _createClass(SkyRenderer, [{
                key: "_isAvailable",
                value: function() {
                    return !(!this._material || !this._mesh);
                }
            }, {
                key: "_render",
                value: function(e) {
                    if (this._material && this._mesh) {
                        var r = t.LayaGL.instance,
                            n = e.scene,
                            i = e.cameraShaderValue,
                            a = e.camera,
                            s = z._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                        t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(!1), t.WebGLContext.setCullFace(r, !1),
                            t.WebGLContext.setDepthFunc(r, r.LEQUAL), t.WebGLContext.setDepthMask(r, !1);
                        var l = SkyRenderer._compileDefine;
                        this._material._shaderValues._defineDatas.cloneTo(l);
                        var u = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(l),
                            c = u.bind(),
                            h = t.Stat.loopCount !== u._uploadMark,
                            _ = u._uploadScene !== n || h;
                        (_ || c) && (u.uploadUniforms(u._sceneUniformParamsMap, n._shaderValues, _), u._uploadScene = n);
                        a._getRenderTexture();
                        var d = u._uploadCameraShaderValue !== i || h;
                        if (d || c) {
                            var f = SkyRenderer._tempMatrix0,
                                m = SkyRenderer._tempMatrix1;
                            a.viewMatrix.cloneTo(f), a.projectionMatrix.cloneTo(m), f.setTranslationVector(o._ZERO),
                                a.orthographic && L.createPerspective(a.fieldOfView, a.aspectRatio, a.nearPlane, a.farPlane, m);
                            var T = 1 / Math.tan(3.1416 * a.fieldOfView / 180 * .5);
                            m.elements[0] = T / a.aspectRatio, m.elements[5] = T, m.elements[10] = 1e-6 - 1,
                                m.elements[11] = -1, m.elements[14] = -0, a._applyViewProject(e, f, m), u.uploadUniforms(u._cameraUniformParamsMap, i, d),
                                u._uploadCameraShaderValue = i;
                        }
                        var p = u._uploadMaterial !== this._material || h;
                        (p || c) && (u.uploadUniforms(u._materialUniformParamsMap, this._material._shaderValues, p),
                            u._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e),
                            t.ILaya.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(s), t.WebGLContext.setDepthFunc(r, r.LESS),
                            t.WebGLContext.setDepthMask(r, !0), a._applyViewProject(e, a.viewMatrix, a.projectionMatrix);
                    }
                }
            }, {
                key: "destroy",
                value: function() {
                    this._material && (this._material._removeReference(), this._material = null);
                }
            }, {
                key: "material",
                get: function() {
                    return this._material;
                },
                set: function(e) {
                    this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(),
                        this._material = e);
                }
            }, {
                key: "mesh",
                get: function() {
                    return this._mesh;
                },
                set: function(e) {
                    this._mesh !== e && (this._mesh = e);
                }
            }]), SkyRenderer;
        }();
    Be._tempMatrix0 = new L(), Be._tempMatrix1 = new L(), Be._compileDefine = new B();
    var we, Fe = function(e) {
        function BaseCamera() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .3,
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1e3;
            return _classCallCheck(this, BaseCamera), (e = _possibleConstructorReturn(this, _getPrototypeOf(BaseCamera).call(this)))._skyRenderer = new Be(),
                e._forward = new o(), e._up = new o(), e.clearColor = new i(100 / 255, 149 / 255, 237 / 255, 1),
                e._shaderValues = new z(null), e._fieldOfView = 60, e._useUserProjectionMatrix = !1,
                e._orthographic = !1, e._orthographicVerticalSize = 10, e.renderingOrder = 0, e._nearPlane = t,
                e._farPlane = r, e.cullingMask = 2147483647, e.useOcclusionCulling = !0, e;
        }
        return _inherits(BaseCamera, le), _createClass(BaseCamera, [{
            key: "_sortCamerasByRenderingOrder",
            value: function() {
                if (this.displayedInStage)
                    for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++)
                        if (e[r].renderingOrder > e[t].renderingOrder) {
                            var n = e[r];
                            e[r] = e[t], e[t] = n;
                        }
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {}
        }, {
            key: "_onScreenSizeChanged",
            value: function() {
                this._calculateProjectionMatrix();
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                var e = this._shaderValues;
                this.transform.getForward(this._forward), this.transform.getUp(this._up), e.setVector3(BaseCamera.CAMERAPOS, this.transform.position),
                    e.setVector3(BaseCamera.CAMERADIRECTION, this._forward), e.setVector3(BaseCamera.CAMERAUP, this._up);
            }
        }, {
            key: "render",
            value: function() {
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            }
        }, {
            key: "addLayer",
            value: function(e) {
                this.cullingMask |= Math.pow(2, e);
            }
        }, {
            key: "removeLayer",
            value: function(e) {
                this.cullingMask &= ~Math.pow(2, e);
            }
        }, {
            key: "addAllLayers",
            value: function() {
                this.cullingMask = 2147483647;
            }
        }, {
            key: "removeAllLayers",
            value: function() {
                this.cullingMask = 0;
            }
        }, {
            key: "resetProjectionMatrix",
            value: function() {
                this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
            }
        }, {
            key: "_onActive",
            value: function() {
                this._scene._addCamera(this), _get(_getPrototypeOf(BaseCamera.prototype), "_onActive", this).call(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                this._scene._removeCamera(this), _get(_getPrototypeOf(BaseCamera.prototype), "_onInActive", this).call(this);
            }
        }, {
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(BaseCamera.prototype), "_parse", this).call(this, e, r), this.orthographic = e.orthographic,
                    void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize),
                    void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e.nearPlane,
                    this.farPlane = e.farPlane;
                var n = e.clearColor;
                this.clearColor = new i(n[0], n[1], n[2], n[3]);
                var a = e.skyboxMaterial;
                a && (this._skyRenderer.material = t.Loader.getRes(a.path));
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged),
                    _get(_getPrototypeOf(BaseCamera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "_create",
            value: function() {
                return new BaseCamera();
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "fieldOfView",
            get: function() {
                return this._fieldOfView;
            },
            set: function(e) {
                this._fieldOfView = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "nearPlane",
            get: function() {
                return this._nearPlane;
            },
            set: function(e) {
                this._nearPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "farPlane",
            get: function() {
                return this._farPlane;
            },
            set: function(e) {
                this._farPlane = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographic",
            get: function() {
                return this._orthographic;
            },
            set: function(e) {
                this._orthographic = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "orthographicVerticalSize",
            get: function() {
                return this._orthographicVerticalSize;
            },
            set: function(e) {
                this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "renderingOrder",
            get: function() {
                return this._renderingOrder;
            },
            set: function(e) {
                this._renderingOrder = e, this._sortCamerasByRenderingOrder();
            }
        }]), BaseCamera;
    }();
    Fe._tempMatrix4x40 = new L(), Fe.CAMERAPOS = G.propertyNameToID("u_CameraPos"),
        Fe.VIEWMATRIX = G.propertyNameToID("u_View"), Fe.PROJECTMATRIX = G.propertyNameToID("u_Projection"),
        Fe.VIEWPROJECTMATRIX = G.propertyNameToID("u_ViewProjection"), Fe.CAMERADIRECTION = G.propertyNameToID("u_CameraDirection"),
        Fe.CAMERAUP = G.propertyNameToID("u_CameraUp"), Fe.VIEWPORT = G.propertyNameToID("u_Viewport"),
        Fe.PROJECTION_PARAMS = G.propertyNameToID("u_ProjectionParams"), Fe.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING",
        Fe.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING", Fe._invertYScaleMatrix = new L(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        Fe._invertYProjectionMatrix = new L(), Fe._invertYProjectionViewMatrix = new L(),
        Fe.CLEARFLAG_SOLIDCOLOR = 0, Fe.CLEARFLAG_SKY = 1, Fe.CLEARFLAG_DEPTHONLY = 2, Fe.CLEARFLAG_NONE = 3,
        (we = e.ShadowMode || (e.ShadowMode = {}))[we.None = 0] = "None", we[we.Hard = 1] = "Hard",
        we[we.SoftLow = 2] = "SoftLow", we[we.SoftHigh = 3] = "SoftHigh";
    var Ue = function(e) {
        function ScreenQuad() {
            var e;
            _classCallCheck(this, ScreenQuad), (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenQuad).call(this)))._bufferState = new Ae(),
                e._bufferStateInvertUV = new Ae();
            var r = t.LayaGL.instance;
            return e._vertexBuffer = new be(64, r.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration,
                e._vertexBuffer.setData(ScreenQuad._vertices.buffer), e._bufferState.bind(), e._bufferState.applyVertexBuffer(e._vertexBuffer),
                e._bufferState.unBind(), e._vertexBufferInvertUV = new be(64, r.STATIC_DRAW, !1),
                e._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration, e._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer),
                e._bufferStateInvertUV.bind(), e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV),
                e._bufferStateInvertUV.unBind(), e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength),
                e;
        }
        return _inherits(ScreenQuad, t.Resource), _createClass(ScreenQuad, [{
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenQuad.prototype), "destroy", this).call(this), this._bufferState.destroy(),
                    this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(),
                    this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function() {
                ScreenQuad._vertexDeclaration = new Oe(16, [new Pe(0, Ie.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV)]),
                    ScreenQuad.instance = new ScreenQuad(), ScreenQuad.instance.lock = !0;
            }
        }]), ScreenQuad;
    }();
    Ue.SCREENQUAD_POSITION_UV = 0, Ue._vertices = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]),
        Ue._verticesInvertUV = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]);
    var Ge = function(e) {
        function ScreenTriangle() {
            var e;
            _classCallCheck(this, ScreenTriangle), (e = _possibleConstructorReturn(this, _getPrototypeOf(ScreenTriangle).call(this)))._bufferState = new Ae(),
                e._bufferStateInvertUV = new Ae();
            var r = t.LayaGL.instance;
            return e._vertexBuffer = new be(48, r.STATIC_DRAW, !1), e._vertexBuffer.vertexDeclaration = ScreenTriangle._vertexDeclaration,
                e._vertexBuffer.setData(ScreenTriangle._vertices.buffer), e._bufferState.bind(),
                e._bufferState.applyVertexBuffer(e._vertexBuffer), e._bufferState.unBind(), e._vertexBufferInvertUV = new be(48, r.STATIC_DRAW, !1),
                e._vertexBufferInvertUV.vertexDeclaration = ScreenTriangle._vertexDeclaration, e._vertexBufferInvertUV.setData(ScreenTriangle._verticesInvertUV.buffer),
                e._bufferStateInvertUV.bind(), e._bufferStateInvertUV.applyVertexBuffer(e._vertexBufferInvertUV),
                e._bufferStateInvertUV.unBind(), e._setGPUMemory(e._vertexBuffer._byteLength + e._vertexBufferInvertUV._byteLength),
                e;
        }
        return _inherits(ScreenTriangle, t.Resource), _createClass(ScreenTriangle, [{
            key: "render",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "renderInvertUV",
            value: function() {
                var e = t.LayaGL.instance;
                this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ScreenTriangle.prototype), "destroy", this).call(this), this._bufferState.destroy(),
                    this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(), this._vertexBufferInvertUV.destroy(),
                    this._setGPUMemory(0);
            }
        }], [{
            key: "__init__",
            value: function() {
                ScreenTriangle._vertexDeclaration = new Oe(16, [new Pe(0, Ie.Vector4, ScreenTriangle.SCREENTRIANGLE_POSITION_UV)]),
                    ScreenTriangle.instance = new ScreenTriangle(), ScreenTriangle.instance.lock = !0;
            }
        }]), ScreenTriangle;
    }();
    Ge.SCREENTRIANGLE_POSITION_UV = 0, Ge._vertices = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]),
        Ge._verticesInvertUV = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]);
    var ze = function() {
        function Command() {
            _classCallCheck(this, Command), this._commandBuffer = null;
        }
        return _createClass(Command, [{
            key: "run",
            value: function() {}
        }, {
            key: "recover",
            value: function() {
                this._commandBuffer = null;
            }
        }], [{
            key: "__init__",
            value: function() {
                Command._screenShaderData = new z(), Command._screenShader = G.find("BlitScreen");
            }
        }]), Command;
    }();
    ze.SCREENTEXTURE_NAME = "u_MainTex", ze.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale",
        ze.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize", ze.SCREENTEXTURE_ID = G.propertyNameToID(ze.SCREENTEXTURE_NAME),
        ze.SCREENTEXTUREOFFSETSCALE_ID = G.propertyNameToID(ze.SCREENTEXTUREOFFSETSCALE_NAME),
        ze.MAINTEXTURE_TEXELSIZE_ID = G.propertyNameToID(ze.MAINTEXTURE_TEXELSIZE_NAME);
    var He = function(e) {
        function BlitScreenQuadCMD() {
            var e;
            return _classCallCheck(this, BlitScreenQuadCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(BlitScreenQuadCMD).apply(this, arguments)))._source = null,
                e._dest = null, e._offsetScale = null, e._shader = null, e._shaderData = null, e._subShader = 0,
                e._sourceTexelSize = new i(), e._screenType = 0, e;
        }
        return _inherits(BlitScreenQuadCMD, ze), _createClass(BlitScreenQuadCMD, [{
            key: "run",
            value: function() {
                var e = this._shader || ze._screenShader,
                    r = this._shaderData || ze._screenShaderData,
                    n = this._dest;
                t.LayaGL.instance.viewport(0, 0, n ? n.width : k.clientWidth, n ? n.height : k.clientHeight),
                    r.setTexture(ze.SCREENTEXTURE_ID, this._source), r.setVector(ze.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitScreenQuadCMD._defaultOffsetScale),
                    this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height),
                    r.setVector(ze.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), n && n._start();
                for (var i = e.getSubShaderAt(this._subShader)._passes, a = 0, o = i.length; a < o; a++) {
                    var s = BlitScreenQuadCMD._compileDefine;
                    r._defineDatas.cloneTo(s);
                    var l = i[a].withCompile(s);
                    switch (l.bind(), l.uploadUniforms(l._materialUniformParamsMap, r, !0), l.uploadRenderStateBlendDepth(r),
                        l.uploadRenderStateFrontFace(r, !1, null), this._screenType) {
                        case BlitScreenQuadCMD._SCREENTYPE_QUAD:
                            k._instance.invertY ? Ue.instance.renderInvertUV() : Ue.instance.render();
                            break;

                        case BlitScreenQuadCMD._SCREENTYPE_TRIANGLE:
                            k._instance.invertY ? Ge.instance.renderInvertUV() : Ge.instance.render();
                            break;

                        default:
                            throw "BlitScreenQuadCMD:unknown screen Type.";
                    }
                }
                n && n._end();
            }
        }, {
            key: "recover",
            value: function() {
                BlitScreenQuadCMD._pool.push(this), this._source = null, this._dest = null, this._offsetScale = null,
                    this._shader = null, this._shaderData = null, _get(_getPrototypeOf(BlitScreenQuadCMD.prototype), "recover", this).call(this);
            }
        }], [{
            key: "create",
            value: function(e, t) {
                var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                    o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                    s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : BlitScreenQuadCMD._SCREENTYPE_QUAD;
                return (r = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD())._source = e,
                    r._dest = t, r._offsetScale = n, r._shader = i, r._shaderData = a, r._subShader = o,
                    r._screenType = s, r;
            }
        }]), BlitScreenQuadCMD;
    }();
    He._SCREENTYPE_QUAD = 0, He._SCREENTYPE_TRIANGLE = 1, He._compileDefine = new B(),
        He._pool = [], He._defaultOffsetScale = new i(0, 0, 1, 1);
    var We = function(e) {
        function SetRenderTargetCMD() {
            var e;
            return _classCallCheck(this, SetRenderTargetCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(SetRenderTargetCMD).apply(this, arguments)))._renderTexture = null,
                e;
        }
        return _inherits(SetRenderTargetCMD, ze), _createClass(SetRenderTargetCMD, [{
            key: "run",
            value: function() {
                this._renderTexture._start();
            }
        }, {
            key: "recover",
            value: function() {
                SetRenderTargetCMD._pool.push(this), this._renderTexture = null;
            }
        }], [{
            key: "create",
            value: function(e) {
                var t;
                return (t = SetRenderTargetCMD._pool.length > 0 ? SetRenderTargetCMD._pool.pop() : new SetRenderTargetCMD())._renderTexture = e,
                    t;
            }
        }]), SetRenderTargetCMD;
    }();
    We._pool = [];
    var Xe = function(e) {
        function SetShaderDataTextureCMD() {
            var e;
            return _classCallCheck(this, SetShaderDataTextureCMD), (e = _possibleConstructorReturn(this, _getPrototypeOf(SetShaderDataTextureCMD).apply(this, arguments)))._shaderData = null,
                e._nameID = 0, e._texture = null, e;
        }
        return _inherits(SetShaderDataTextureCMD, ze), _createClass(SetShaderDataTextureCMD, [{
            key: "run",
            value: function() {
                this._shaderData.setTexture(this._nameID, this._texture);
            }
        }, {
            key: "recover",
            value: function() {
                SetShaderDataTextureCMD._pool.push(this), this._shaderData = null, this._nameID = 0,
                    this._texture = null;
            }
        }], [{
            key: "create",
            value: function(e, t, r) {
                var n;
                return (n = SetShaderDataTextureCMD._pool.length > 0 ? SetShaderDataTextureCMD._pool.pop() : new SetShaderDataTextureCMD())._shaderData = e,
                    n._nameID = t, n._texture = r, n;
            }
        }]), SetShaderDataTextureCMD;
    }();
    Xe._pool = [];
    var Ye, je = function() {
            function CommandBuffer() {
                _classCallCheck(this, CommandBuffer), this._camera = null, this._commands = [];
            }
            return _createClass(CommandBuffer, [{
                key: "_apply",
                value: function() {
                    for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run();
                }
            }, {
                key: "setShaderDataTexture",
                value: function(e, t, r) {
                    this._commands.push(Xe.create(e, t, r));
                }
            }, {
                key: "blitScreenQuad",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                        a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                    this._commands.push(He.create(e, t, r, n, i, a, He._SCREENTYPE_QUAD));
                }
            }, {
                key: "blitScreenTriangle",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                        a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
                    this._commands.push(He.create(e, t, r, n, i, a, He._SCREENTYPE_TRIANGLE));
                }
            }, {
                key: "setRenderTarget",
                value: function(e) {
                    this._commands.push(We.create(e));
                }
            }, {
                key: "clear",
                value: function() {
                    for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].recover();
                    this._commands.length = 0;
                }
            }]), CommandBuffer;
        }(),
        Qe = function Scene3DShaderDeclaration() {
            _classCallCheck(this, Scene3DShaderDeclaration);
        };
    (Ye = e.LightType || (e.LightType = {}))[Ye.Directional = 0] = "Directional", Ye[Ye.Spot = 1] = "Spot",
        Ye[Ye.Point = 2] = "Point";
    var Ze, qe, Ke = function(t) {
        function LightSprite() {
            var t;
            return _classCallCheck(this, LightSprite), (t = _possibleConstructorReturn(this, _getPrototypeOf(LightSprite).call(this)))._shadowMode = e.ShadowMode.None,
                t._isAlternate = !1, t._shadowResolution = 2048, t._shadowDistance = 50, t._shadowDepthBias = 1,
                t._shadowNormalBias = 1, t._shadowNearPlane = .1, t._shadowStrength = 1, t._intensity = 1,
                t._intensityColor = new o(), t.color = new o(1, 1, 1), t._lightmapBakedType = LightSprite.LIGHTMAPBAKEDTYPE_REALTIME,
                t;
        }
        return _inherits(LightSprite, le), _createClass(LightSprite, [{
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(LightSprite.prototype), "_parse", this).call(this, e, t);
                var r = e.color;
                this.color.fromArray(r), this.intensity = e.intensity, this.lightmapBakedType = e.lightmapBakedType;
            }
        }, {
            key: "_addToScene",
            value: function() {
                var e = this._scene,
                    t = s._config.maxLightCount;
                e._lightCount < t ? (e._lightCount++, this._addToLightQueue(), this._isAlternate = !1) : (e._alternateLights.add(this),
                    this._isAlternate = !0, console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore."));
            }
        }, {
            key: "_removeFromScene",
            value: function() {
                var e = this._scene;
                if (this._isAlternate) e._alternateLights.remove(this);
                else if (e._lightCount--,
                    this._removeFromLightQueue(), e._alternateLights._length > 0) {
                    var t = e._alternateLights.shift();
                    t._addToLightQueue(), t._isAlternate = !1, e._lightCount++;
                }
            }
        }, {
            key: "_addToLightQueue",
            value: function() {}
        }, {
            key: "_removeFromLightQueue",
            value: function() {}
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onActive", this).call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._addToScene();
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(LightSprite.prototype), "_onInActive", this).call(this), this.lightmapBakedType !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED && this._removeFromScene();
            }
        }, {
            key: "_create",
            value: function() {
                return new LightSprite();
            }
        }, {
            key: "intensity",
            get: function() {
                return this._intensity;
            },
            set: function(e) {
                this._intensity = e;
            }
        }, {
            key: "shadowMode",
            get: function() {
                return this._shadowMode;
            },
            set: function(e) {
                this._shadowMode = e;
            }
        }, {
            key: "shadowDistance",
            get: function() {
                return this._shadowDistance;
            },
            set: function(e) {
                this._shadowDistance = e;
            }
        }, {
            key: "shadowResolution",
            get: function() {
                return this._shadowResolution;
            },
            set: function(e) {
                this._shadowResolution = e;
            }
        }, {
            key: "shadowDepthBias",
            get: function() {
                return this._shadowDepthBias;
            },
            set: function(e) {
                this._shadowDepthBias = e;
            }
        }, {
            key: "shadowNormalBias",
            get: function() {
                return this._shadowNormalBias;
            },
            set: function(e) {
                this._shadowNormalBias = e;
            }
        }, {
            key: "shadowStrength",
            get: function() {
                return this._shadowStrength;
            },
            set: function(e) {
                this._shadowStrength = e;
            }
        }, {
            key: "shadowNearPlane",
            get: function() {
                return this._shadowNearPlane;
            },
            set: function(e) {
                this._shadowNearPlane = e;
            }
        }, {
            key: "lightmapBakedType",
            get: function() {
                return this._lightmapBakedType;
            },
            set: function(e) {
                this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== LightSprite.LIGHTMAPBAKEDTYPE_BAKED ? this._addToScene() : this._removeFromScene()));
            }
        }, {
            key: "diffuseColor",
            get: function() {
                return console.log("LightSprite: discard property,please use color property instead."),
                    this.color;
            },
            set: function(e) {
                console.log("LightSprite: discard property,please use color property instead."),
                    this.color = e;
            }
        }]), LightSprite;
    }();
    Ke.LIGHTMAPBAKEDTYPE_REALTIME = 0, Ke.LIGHTMAPBAKEDTYPE_MIXED = 1, Ke.LIGHTMAPBAKEDTYPE_BAKED = 2,
        (Ze = e.ShadowCascadesMode || (e.ShadowCascadesMode = {}))[Ze.NoCascades = 0] = "NoCascades",
        Ze[Ze.TwoCascades = 1] = "TwoCascades", Ze[Ze.FourCascades = 2] = "FourCascades",
        function(e) {
            e[e.Near = 0] = "Near", e[e.Far = 1] = "Far", e[e.Left = 2] = "Left", e[e.Right = 3] = "Right",
                e[e.Bottom = 4] = "Bottom", e[e.Top = 5] = "Top";
        }(qe || (qe = {}));
    var Je, $e = function() {
        function ShadowUtils() {
            _classCallCheck(this, ShadowUtils);
        }
        return _createClass(ShadowUtils, null, [{
            key: "supportShadow",
            value: function() {
                return t.LayaGL.layaGPUInstance._isWebGL2 || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.Depth);
            }
        }, {
            key: "init",
            value: function() {
                t.LayaGL.layaGPUInstance._isWebGL2 ? ShadowUtils._shadowTextureFormat = t.RenderTextureFormat.ShadowMap : ShadowUtils._shadowTextureFormat = t.RenderTextureFormat.Depth;
            }
        }, {
            key: "getTemporaryShadowTexture",
            value: function(e, r, n) {
                var i = V.createFromPool(e, r, ShadowUtils._shadowTextureFormat, n);
                return i.filterMode = t.FilterMode.Bilinear, i.wrapModeU = t.WarpMode.Clamp, i.wrapModeV = t.WarpMode.Clamp,
                    i;
            }
        }, {
            key: "getShadowBias",
            value: function(t, n, i, a) {
                var o;
                t._lightType == e.LightType.Directional ? o = 2 / n.elements[0] : t._lightType == e.LightType.Spot ? o = Math.tan(.5 * t.spotAngle * r.Deg2Rad) * t.range : (console.warn("ShadowUtils:Only spot and directional shadow casters are supported now."),
                    o = 0);
                var s = o / i,
                    l = -t._shadowDepthBias * s,
                    u = -t._shadowNormalBias * s;
                if (t.shadowMode == e.ShadowMode.SoftHigh) {
                    l *= 2.5, u *= 2.5;
                }
                a.setValue(l, u, 0, 0);
            }
        }, {
            key: "getCameraFrustumPlanes",
            value: function(e, t) {
                Ce.getPlanesFromMatrix(e, t[qe.Near], t[qe.Far], t[qe.Left], t[qe.Right], t[qe.Top], t[qe.Bottom]);
            }
        }, {
            key: "getFarWithRadius",
            value: function(e, t) {
                return Math.sqrt(e * e / t);
            }
        }, {
            key: "getCascadesSplitDistance",
            value: function(t, r, n, i, a, o, s, l) {
                l[0] = n;
                var u = i - n,
                    c = Math.tan(.5 * a),
                    h = 1 + c * c * (o * o + 1);
                switch (s) {
                    case e.ShadowCascadesMode.NoCascades:
                        l[1] = ShadowUtils.getFarWithRadius(i, h);
                        break;

                    case e.ShadowCascadesMode.TwoCascades:
                        l[1] = ShadowUtils.getFarWithRadius(n + u * t, h), l[2] = ShadowUtils.getFarWithRadius(i, h);
                        break;

                    case e.ShadowCascadesMode.FourCascades:
                        l[1] = ShadowUtils.getFarWithRadius(n + u * r.x, h), l[2] = ShadowUtils.getFarWithRadius(n + u * r.y, h),
                            l[3] = ShadowUtils.getFarWithRadius(n + u * r.z, h), l[4] = ShadowUtils.getFarWithRadius(i, h);
                }
            }
        }, {
            key: "applySliceTransform",
            value: function(e, t, r, n, i) {
                var a = ShadowUtils._tempMatrix0.elements,
                    o = 1 / t,
                    s = 1 / r;
                a[0] = e.resolution * o, a[5] = e.resolution * s, a[12] = e.offsetX * o, a[13] = e.offsetY * s,
                    a[1] = a[2] = a[2] = a[4] = a[6] = a[7] = a[8] = a[9] = a[11] = a[14] = 0, a[10] = a[15] = 1;
                var l = 16 * n;
                R._mulMatrixArray(a, i, l, i, l);
            }
        }, {
            key: "getDirectionLightShadowCullPlanes",
            value: function(t, r, n, i, a, s) {
                var l = ShadowUtils._frustumCorners,
                    u = ShadowUtils._backPlaneFaces,
                    c = ShadowUtils._frustumPlaneNeighbors,
                    h = ShadowUtils._frustumTwoPlaneCorners,
                    _ = ShadowUtils._edgePlanePoint2,
                    d = s.cullPlanes,
                    f = t[qe.Near],
                    m = t[qe.Far],
                    T = t[qe.Left],
                    p = t[qe.Right],
                    v = t[qe.Bottom],
                    E = t[qe.Top],
                    g = n[r] - i,
                    y = ShadowUtils._adjustNearPlane,
                    S = ShadowUtils._adjustFarPlane;
                f.normal.cloneTo(y.normal), m.normal.cloneTo(S.normal), y.distance = f.distance - g,
                    S.distance = Math.min(-f.distance + s.sphereCenterZ + s.splitBoundSphere.radius, m.distance),
                    Ce.get3PlaneInterPoint(y, v, p, l[e.FrustumCorner.nearBottomRight]), Ce.get3PlaneInterPoint(y, E, p, l[e.FrustumCorner.nearTopRight]),
                    Ce.get3PlaneInterPoint(y, E, T, l[e.FrustumCorner.nearTopLeft]), Ce.get3PlaneInterPoint(y, v, T, l[e.FrustumCorner.nearBottomLeft]),
                    Ce.get3PlaneInterPoint(S, v, p, l[e.FrustumCorner.FarBottomRight]), Ce.get3PlaneInterPoint(S, E, p, l[e.FrustumCorner.FarTopRight]),
                    Ce.get3PlaneInterPoint(S, E, T, l[e.FrustumCorner.FarTopLeft]), Ce.get3PlaneInterPoint(S, v, T, l[e.FrustumCorner.FarBottomLeft]);
                for (var R = 0, C = 0; C < 6; C++) {
                    var M;
                    switch (C) {
                        case qe.Near:
                            M = y;
                            break;

                        case qe.Far:
                            M = S;
                            break;

                        default:
                            M = t[C];
                    }
                    o.dot(M.normal, a) < 0 && (M.cloneTo(d[R]), u[R] = C, R++);
                }
                var x = R;
                for (C = 0; C < R; C++)
                    for (var D = u[C], A = c[D], L = 0; L < 4; L++) {
                        for (var I = A[L], O = !0, P = 0; P < R; P++)
                            if (I == u[P]) {
                                O = !1;
                                break;
                            }
                        if (O) {
                            var N = h[D][I],
                                b = l[N[0]],
                                k = l[N[1]];
                            o.add(b, a, _), Ee.createPlaneBy3P(b, k, _, d[x++]);
                        }
                    }
                s.cullPlaneCount = x;
            }
        }, {
            key: "getBoundSphereByFrustum",
            value: function(e, t, r, n, i, a, s) {
                var l, u, c = Math.sqrt(1 + n * n) * Math.tan(r / 2),
                    h = c * c,
                    _ = t - e,
                    d = t + e;
                h > _ / d ? (l = t, u = t * c) : (l = .5 * d * (1 + h), u = .5 * Math.sqrt(_ * _ + 2 * (t * t + e * e) * h + d * d * h * h));
                var f = s.center;
                return s.radius = u, o.scale(a, l, f), o.add(i, f, f), l;
            }
        }, {
            key: "getMaxTileResolutionInAtlas",
            value: function(e, t, r) {
                for (var n = Math.min(e, t), i = Math.floor(e / n) * Math.floor(t / n); i < r;) n = Math.floor(n >> 1),
                    i = Math.floor(e / n) * Math.floor(t / n);
                return n;
            }
        }, {
            key: "getDirectionalLightMatrices",
            value: function(e, t, r, n, i, a, s, l) {
                var u = s.splitBoundSphere,
                    c = u.center,
                    h = u.radius,
                    _ = a / 2,
                    d = h * _ / (_ - ShadowUtils.atlasBorderSize),
                    f = 2 * d,
                    m = a / f,
                    T = f / a,
                    p = Math.ceil(o.dot(c, e) * m) * T,
                    v = Math.ceil(o.dot(c, t) * m) * T,
                    E = o.dot(c, r);
                c.x = e.x * p + t.x * v + r.x * E, c.y = e.y * p + t.y * v + r.y * E, c.z = e.z * p + t.z * v + r.z * E;
                var g = s.position,
                    y = s.viewMatrix,
                    S = s.projectionMatrix,
                    C = s.viewProjectMatrix;
                s.resolution = a, s.offsetX = n % 2 * a, s.offsetY = Math.floor(n / 2) * a, o.scale(r, h + i, g),
                    o.subtract(c, g, g), L.createLookAt(g, c, e, y), L.createOrthoOffCenter(-d, d, -d, d, 0, 2 * h + i, S),
                    L.multiply(S, y, C), R._mulMatrixArray(ShadowUtils._shadowMapScaleOffsetMatrix.elements, C.elements, 0, l, 16 * n);
            }
        }, {
            key: "prepareShadowReceiverShaderValues",
            value: function(e, t, r, n, i, a, o, s, l) {
                if (a.setValue(1 / t, 1 / r, t, r), o.setValue(e._shadowStrength, 0, 0, 0), i > 1) {
                    for (var u = 16 * i, c = 64; u < c; u++) s[u] = 0;
                    for (u = 0; u < i; u++) {
                        var h = n[u].splitBoundSphere,
                            _ = h.center,
                            d = h.radius,
                            f = 4 * u;
                        l[f] = _.x, l[f + 1] = _.y, l[f + 2] = _.z, l[f + 3] = d * d;
                    }
                    for (u = 4 * i, c = 16; u < c; u++) l[u] = 0;
                }
            }
        }]), ShadowUtils;
    }();
    $e._tempMatrix0 = new L(), $e._shadowMapScaleOffsetMatrix = new L(.5, 0, 0, 0, 0, .5, 0, 0, 0, 0, 1, 0, .5, .5, 0, 1),
        $e._frustumCorners = [new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o()],
        $e._adjustNearPlane = new Ee(new o()), $e._adjustFarPlane = new Ee(new o()), $e._backPlaneFaces = new Array(5),
        $e._edgePlanePoint2 = new o(), $e._frustumPlaneNeighbors = [
            [qe.Left, qe.Right, qe.Top, qe.Bottom],
            [qe.Left, qe.Right, qe.Top, qe.Bottom],
            [qe.Near, qe.Far, qe.Top, qe.Bottom],
            [qe.Near, qe.Far, qe.Top, qe.Bottom],
            [qe.Near, qe.Far, qe.Left, qe.Right],
            [qe.Near, qe.Far, qe.Left, qe.Right]
        ],
        $e._frustumTwoPlaneCorners = [
            [
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearTopLeft],
                [e.FrustumCorner.nearTopRight, e.FrustumCorner.nearBottomRight],
                [e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearBottomLeft],
                [e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearTopRight]
            ],
            [
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarBottomLeft],
                [e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarTopRight],
                [e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarBottomRight],
                [e.FrustumCorner.FarTopRight, e.FrustumCorner.FarTopLeft]
            ],
            [
                [e.FrustumCorner.nearTopLeft, e.FrustumCorner.nearBottomLeft],
                [e.FrustumCorner.FarBottomLeft, e.FrustumCorner.FarTopLeft],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.nearBottomLeft, e.FrustumCorner.FarBottomLeft],
                [e.FrustumCorner.FarTopLeft, e.FrustumCorner.nearTopLeft]
            ],
            [
                [e.FrustumCorner.nearBottomRight, e.FrustumCorner.nearTopRight],
                [e.FrustumCorner.FarTopRight, e.FrustumCorner.FarBottomRight],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.FarBottomRight, e.FrustumCorner.nearBottomRight],
                [e.FrustumCorner.nearTopRight, e.FrustumCorner.FarTopRight]
            ],
            [
                [e.FrustumCorner.nearBottomLeft, e.FrustumCorner.nearBottomRight],
                [e.FrustumCorner.FarBottomRight, e.FrustumCorner.FarBottomLeft],
                [e.FrustumCorner.FarBottomLeft, e.FrustumCorner.nearBottomLeft],
                [e.FrustumCorner.nearBottomRight, e.FrustumCorner.FarBottomRight],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown]
            ],
            [
                [e.FrustumCorner.nearTopRight, e.FrustumCorner.nearTopLeft],
                [e.FrustumCorner.FarTopLeft, e.FrustumCorner.FarTopRight],
                [e.FrustumCorner.nearTopLeft, e.FrustumCorner.FarTopLeft],
                [e.FrustumCorner.FarTopRight, e.FrustumCorner.nearTopRight],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown],
                [e.FrustumCorner.unknown, e.FrustumCorner.unknown]
            ]
        ],
        $e.atlasBorderSize = 4, (Je = e.CameraClearFlags || (e.CameraClearFlags = {}))[Je.SolidColor = 0] = "SolidColor",
        Je[Je.Sky = 1] = "Sky", Je[Je.DepthOnly = 2] = "DepthOnly", Je[Je.Nothing = 3] = "Nothing";
    var et = function(r) {
        function Camera() {
            var r, a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .3,
                s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3;
            return _classCallCheck(this, Camera), (r = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this, o, s)))._updateViewMatrix = !0,
                r._postProcess = null, r._enableHDR = !1, r._viewportParams = new i(), r._projectionParams = new i(),
                r._offScreenRenderTexture = null, r._internalRenderTexture = null, r._postProcessCommandBuffers = [],
                r._clusterPlaneCacheFlag = new n(-1, -1), r._screenOffsetScale = new i(), r.enableRender = !0,
                r.clearFlag = e.CameraClearFlags.SolidColor, r._viewMatrix = new L(), r._projectionMatrix = new L(),
                r._projectionViewMatrix = new L(), r._viewport = new Me(0, 0, 0, 0), r._normalizedViewport = new Me(0, 0, 1, 1),
                r._aspectRatio = a, r._boundFrustum = new Ce(new L()), t.Render.supportWebGLPlusCulling && (r._boundFrustumBuffer = new Float32Array(24)),
                r._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE, _assertThisInitialized(r), r._onScreenSizeChanged),
                r.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(r), r._onTransformChanged),
                r;
        }
        return _inherits(Camera, Fe), _createClass(Camera, [{
            key: "_calculationViewport",
            value: function(e, t, r) {
                var n = e.x * t,
                    i = e.y * r,
                    a = n + Math.max(e.width * t, 0),
                    o = i + Math.max(e.height * r, 0),
                    s = Math.ceil(n),
                    l = Math.ceil(i),
                    u = Math.floor(a),
                    c = Math.floor(o),
                    h = s - n >= .5 ? Math.floor(n) : s,
                    _ = l - i >= .5 ? Math.floor(i) : l,
                    d = a - u >= .5 ? Math.ceil(a) : u,
                    f = o - c >= .5 ? Math.ceil(o) : c;
                this._viewport.x = h, this._viewport.y = _, this._viewport.width = d - h, this._viewport.height = f - _;
            }
        }, {
            key: "_calculateProjectionMatrix",
            value: function() {
                if (!this._useUserProjectionMatrix)
                    if (this._orthographic) {
                        var e = .5 * this.orthographicVerticalSize,
                            t = e * this.aspectRatio;
                        L.createOrthoOffCenter(-t, t, -e, e, this.nearPlane, this.farPlane, this._projectionMatrix);
                    } else L.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
            }
        }, {
            key: "_isLayerVisible",
            value: function(e) {
                return 0 != (Math.pow(2, e) & this.cullingMask);
            }
        }, {
            key: "_onTransformChanged",
            value: function(e) {
                (e &= se.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
            }
        }, {
            key: "_parse",
            value: function(e, t) {
                _get(_getPrototypeOf(Camera.prototype), "_parse", this).call(this, e, t);
                var r = e.clearFlag;
                void 0 !== r && (this.clearFlag = r);
                var n = e.viewport;
                this.normalizedViewport = new Me(n[0], n[1], n[2], n[3]);
                var i = e.enableHDR;
                void 0 !== i && (this.enableHDR = i);
            }
        }, {
            key: "_getCanvasWidth",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.width : k.clientWidth;
            }
        }, {
            key: "_getCanvasHeight",
            value: function() {
                return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : k.clientHeight;
            }
        }, {
            key: "_getRenderTexture",
            value: function() {
                return this._internalRenderTexture || this._offScreenRenderTexture;
            }
        }, {
            key: "_needInternalRenderTexture",
            value: function() {
                return !(!this._postProcess && !this._enableHDR);
            }
        }, {
            key: "_applyPostProcessCommandBuffers",
            value: function() {
                for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) this._postProcessCommandBuffers[e]._apply();
            }
        }, {
            key: "_getRenderTextureFormat",
            value: function() {
                return this._enableHDR ? t.RenderTextureFormat.R16G16B16A16 : t.RenderTextureFormat.R8G8B8;
            }
        }, {
            key: "_prepareCameraToRender",
            value: function() {
                _get(_getPrototypeOf(Camera.prototype), "_prepareCameraToRender", this).call(this);
                var e = this.viewport;
                this._viewportParams.setValue(e.x, e.y, e.width, e.height), this._projectionParams.setValue(this._nearPlane, this._farPlane, k._instance.invertY ? -1 : 1, 0),
                    this._shaderValues.setVector(Fe.VIEWPORT, this._viewportParams), this._shaderValues.setVector(Fe.PROJECTION_PARAMS, this._projectionParams);
            }
        }, {
            key: "_applyViewProject",
            value: function(e, t, r) {
                var n, i = this._shaderValues;
                e.invertY ? (L.multiply(Fe._invertYScaleMatrix, r, Fe._invertYProjectionMatrix),
                        L.multiply(Fe._invertYProjectionMatrix, t, Fe._invertYProjectionViewMatrix), r = Fe._invertYProjectionMatrix,
                        n = Fe._invertYProjectionViewMatrix) : (L.multiply(r, t, this._projectionViewMatrix),
                        n = this._projectionViewMatrix), e.viewMatrix = t, e.projectionMatrix = r, e.projectionViewMatrix = n,
                    i.setMatrix4x4(Fe.VIEWMATRIX, t), i.setMatrix4x4(Fe.PROJECTMATRIX, r), i.setMatrix4x4(Fe.VIEWPROJECTMATRIX, n);
            }
        }, {
            key: "_updateClusterPlaneXY",
            value: function() {
                var e = this.fieldOfView,
                    t = this.aspectRatio;
                if (this._clusterPlaneCacheFlag.x !== e || this._clusterPlaneCacheFlag.y !== t) {
                    var r = s._config.lightClusterCount,
                        n = r.x,
                        i = r.y,
                        a = n + 1,
                        l = i + 1,
                        u = this._clusterXPlanes,
                        c = this._clusterYPlanes;
                    if (!u) {
                        u = this._clusterXPlanes = new Array(a), c = this._clusterYPlanes = new Array(l);
                        for (var h = 0; h < a; h++) u[h] = new o();
                        for (h = 0; h < l; h++) c[h] = new o();
                    }
                    var _ = Math.tan(this.fieldOfView / 2 * Math.PI / 180),
                        d = this.aspectRatio * _,
                        f = 2 * _ / n,
                        m = 2 * d / i;
                    for (h = 0; h < a; h++) {
                        var T = m * h - d,
                            p = 1 / Math.sqrt(1 + T * T);
                        u[h].setValue(p, 0, -T * p);
                    }
                    for (h = 0; h < l; h++) {
                        T = _ - f * h;
                        var v = -1 / Math.sqrt(1 + T * T);
                        c[h].setValue(0, v, -T * v);
                    }
                    this._clusterPlaneCacheFlag.x = e, this._clusterPlaneCacheFlag.y = t;
                }
            }
        }, {
            key: "render",
            value: function() {
                var r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                if (this.activeInHierarchy) {
                    var i, a = this.viewport,
                        o = this._needInternalRenderTexture(),
                        u = t.LayaGL.instance,
                        c = k._instance,
                        h = c.scene = this._scene;
                    c.pipelineMode = "Forward", o ? (this._internalRenderTexture = V.createFromPool(a.width, a.height, this._getRenderTextureFormat(), t.RenderTextureDepthFormat.DEPTH_16),
                        this._internalRenderTexture.filterMode = t.FilterMode.Bilinear) : this._internalRenderTexture = null;
                    var _ = h._mainLight,
                        d = _ && _.shadowMode !== e.ShadowMode.None && $e.supportShadow();
                    if (d ? (h._shaderValues.addDefine(Qe.SHADERDEFINE_SHADOW), (i = l.Scene3D._shadowCasterPass).update(this, _),
                            i.render(c, h)) : h._shaderValues.removeDefine(Qe.SHADERDEFINE_SHADOW), c.camera = this,
                        c.cameraShaderValue = this._shaderValues, Camera._updateMark++, h._preRenderScript(),
                        o && !this._offScreenRenderTexture && (this.clearFlag == e.CameraClearFlags.DepthOnly || this.clearFlag == e.CameraClearFlags.Nothing))
                        if (this._enableHDR) {
                            var f = V.createFromPool(a.width, a.height, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTH_16);
                            f.filterMode = t.FilterMode.Bilinear, t.WebGLContext.bindTexture(u, u.TEXTURE_2D, f._getSource()),
                                u.copyTexSubImage2D(u.TEXTURE_2D, 0, 0, 0, a.x, k.clientHeight - (a.y + a.height), a.width, a.height),
                                (T = He.create(f, this._internalRenderTexture)).run(), T.recover(), V.recoverToPool(f);
                        } else t.WebGLContext.bindTexture(u, u.TEXTURE_2D, this._internalRenderTexture._getSource()),
                            u.copyTexSubImage2D(u.TEXTURE_2D, 0, 0, 0, a.x, k.clientHeight - (a.y + a.height), a.width, a.height);
                    var m = this._getRenderTexture();
                    if (m && m._start(), c.viewport = a, this._prepareCameraToRender(), s._config._multiLighting && me.instance.update(this, this._scene),
                        this._applyViewProject(c, this.viewMatrix, this._projectionMatrix), h._preCulling(c, this, r, n),
                        h._clear(u, c), h._renderScene(c), h._postRenderScript(), m && m._end(), o) {
                        if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers();
                        else if (this._enableHDR) {
                            var T, p = this._getCanvasWidth(),
                                v = this._getCanvasHeight();
                            this._screenOffsetScale.setValue(a.x / p, a.y / v, a.width / p, a.height / v), (T = He.create(this._internalRenderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null, this._screenOffsetScale)).run(),
                                T.recover();
                        }
                        V.recoverToPool(this._internalRenderTexture);
                    }
                    d && i.cleanUp();
                }
            }
        }, {
            key: "viewportPointToRay",
            value: function(e, t) {
                xe.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "normalizedViewportPointToRay",
            value: function(e, t) {
                var r = Camera._tempVector20,
                    n = this.viewport;
                r.x = e.x * n.width, r.y = e.y * n.height, xe.calculateCursorRay(r, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
            }
        }, {
            key: "worldToViewportPoint",
            value: function(e, r) {
                L.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.viewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                    r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "worldToNormalizedViewportPoint",
            value: function(e, r) {
                L.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                    this.normalizedViewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                    r.y = r.y / t.Laya.stage.clientScaleY;
            }
        }, {
            key: "convertScreenCoordToOrthographicCoord",
            value: function(e, r) {
                if (this._orthographic) {
                    var n = k.clientWidth,
                        i = k.clientHeight,
                        a = this.orthographicVerticalSize * this.aspectRatio / n,
                        s = this.orthographicVerticalSize / i;
                    return r.x = (-n / 2 + e.x * t.Laya.stage.clientScaleX) * a, r.y = (i / 2 - e.y * t.Laya.stage.clientScaleY) * s,
                        r.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane, o.transformCoordinate(r, this.transform.worldMatrix, r), !0;
                }
                return !1;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this._offScreenRenderTexture = null, this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged),
                    _get(_getPrototypeOf(Camera.prototype), "destroy", this).call(this, e);
            }
        }, {
            key: "addCommandBuffer",
            value: function(e, t) {
                switch (e) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.push(t), t._camera = this;
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffer",
            value: function(e, t) {
                switch (e) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        var r = this._postProcessCommandBuffers.indexOf(t); -
                        1 !== r && this._postProcessCommandBuffers.splice(r, 1);
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "removeCommandBuffers",
            value: function(e) {
                switch (e) {
                    case Camera.CAMERAEVENT_POSTPROCESS:
                        this._postProcessCommandBuffers.length = 0;
                        break;

                    default:
                        throw "Camera:unknown event.";
                }
            }
        }, {
            key: "_create",
            value: function() {
                return new Camera();
            }
        }, {
            key: "aspectRatio",
            get: function() {
                if (0 === this._aspectRatio) {
                    var e = this.viewport;
                    return e.width / e.height;
                }
                return this._aspectRatio;
            },
            set: function(e) {
                if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
                this._aspectRatio = e, this._calculateProjectionMatrix();
            }
        }, {
            key: "viewport",
            get: function() {
                return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, k.clientWidth, k.clientHeight),
                    this._viewport;
            },
            set: function(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = k.clientWidth,
                        r = k.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / r,
                    this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / r,
                    this._calculationViewport(this._normalizedViewport, t, r), this._calculateProjectionMatrix();
            }
        }, {
            key: "normalizedViewport",
            get: function() {
                return this._normalizedViewport;
            },
            set: function(e) {
                var t, r;
                this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = k.clientWidth,
                        r = k.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport),
                    this._calculationViewport(e, t, r), this._calculateProjectionMatrix();
            }
        }, {
            key: "viewMatrix",
            get: function() {
                if (this._updateViewMatrix) {
                    var e = this.transform.getWorldLossyScale(),
                        t = e.x,
                        r = e.y,
                        n = e.z,
                        i = this._viewMatrix.elements;
                    this.transform.worldMatrix.cloneTo(this._viewMatrix), i[0] /= t, i[1] /= t, i[2] /= t,
                        i[4] /= r, i[5] /= r, i[6] /= r, i[8] /= n, i[9] /= n, i[10] /= n, this._viewMatrix.invert(this._viewMatrix),
                        this._updateViewMatrix = !1;
                }
                return this._viewMatrix;
            }
        }, {
            key: "projectionMatrix",
            get: function() {
                return this._projectionMatrix;
            },
            set: function(e) {
                this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
            }
        }, {
            key: "projectionViewMatrix",
            get: function() {
                return L.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix),
                    this._projectionViewMatrix;
            }
        }, {
            key: "boundFrustum",
            get: function() {
                if (this._boundFrustum.matrix = this.projectionViewMatrix, t.Render.supportWebGLPlusCulling) {
                    var e = this._boundFrustum.near,
                        r = this._boundFrustum.far,
                        n = this._boundFrustum.left,
                        i = this._boundFrustum.right,
                        a = this._boundFrustum.top,
                        o = this._boundFrustum.bottom,
                        s = e.normal,
                        l = r.normal,
                        u = n.normal,
                        c = i.normal,
                        h = a.normal,
                        _ = o.normal,
                        d = this._boundFrustumBuffer;
                    d[0] = s.x, d[1] = s.y, d[2] = s.z, d[3] = e.distance, d[4] = l.x, d[5] = l.y, d[6] = l.z,
                        d[7] = r.distance, d[8] = u.x, d[9] = u.y, d[10] = u.z, d[11] = n.distance, d[12] = c.x,
                        d[13] = c.y, d[14] = c.z, d[15] = i.distance, d[16] = h.x, d[17] = h.y, d[18] = h.z,
                        d[19] = a.distance, d[20] = _.x, d[21] = _.y, d[22] = _.z, d[23] = o.distance;
                }
                return this._boundFrustum;
            }
        }, {
            key: "renderTarget",
            get: function() {
                return this._offScreenRenderTexture;
            },
            set: function(e) {
                var t = this._offScreenRenderTexture;
                t !== e && (t && (t._isCameraTarget = !1), e && (e._isCameraTarget = !0), this._offScreenRenderTexture = e,
                    this._calculateProjectionMatrix());
            }
        }, {
            key: "postProcess",
            get: function() {
                return this._postProcess;
            },
            set: function(e) {
                this._postProcess = e;
                var t = new je();
                this.addCommandBuffer(Camera.CAMERAEVENT_POSTPROCESS, t), e._init(this, t);
            }
        }, {
            key: "enableHDR",
            get: function() {
                return this._enableHDR;
            },
            set: function(e) {
                !e || t.SystemUtils.supportRenderTextureFormat(t.RenderTextureFormat.R16G16B16A16) ? this._enableHDR = e : console.warn("Camera:can't enable HDR in this device.");
            }
        }]), Camera;
    }();
    et.CAMERAEVENT_POSTPROCESS = 0, et._tempVector20 = new n(), et._updateMark = 0;
    var tt = function HitResult() {
            _classCallCheck(this, HitResult), this.succeeded = !1, this.collider = null, this.point = new o(),
                this.normal = new o(), this.hitFraction = 0;
        },
        rt = function() {
            function Physics3DUtils() {
                _classCallCheck(this, Physics3DUtils);
            }
            return _createClass(Physics3DUtils, null, [{
                key: "setColliderCollision",
                value: function(e, t, r) {}
            }, {
                key: "getIColliderCollision",
                value: function(e, t) {
                    return !1;
                }
            }]), Physics3DUtils;
        }();
    rt.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, rt.COLLISIONFILTERGROUP_STATICFILTER = 2,
        rt.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, rt.COLLISIONFILTERGROUP_DEBRISFILTER = 8,
        rt.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, rt.COLLISIONFILTERGROUP_CHARACTERFILTER = 32,
        rt.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, rt.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128,
        rt.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, rt.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512,
        rt.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, rt.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048,
        rt.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, rt.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192,
        rt.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, rt.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768,
        rt.COLLISIONFILTERGROUP_ALLFILTER = -1, rt.gravity = new o(0, -9.81, 0);
    var nt = function(e) {
            function PhysicsUpdateList() {
                return _classCallCheck(this, PhysicsUpdateList), _possibleConstructorReturn(this, _getPrototypeOf(PhysicsUpdateList).call(this));
            }
            return _inherits(PhysicsUpdateList, ne), _createClass(PhysicsUpdateList, [{
                key: "add",
                value: function(e) {
                    if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
                    this._add(e), e._inPhysicUpdateListIndex = this.length++;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._inPhysicUpdateListIndex;
                    if (this.length--, t !== this.length) {
                        var r = this.elements[this.length];
                        this.elements[t] = r, r._inPhysicUpdateListIndex = t;
                    }
                    e._inPhysicUpdateListIndex = -1;
                }
            }]), PhysicsUpdateList;
        }(),
        it = function ContactPoint() {
            _classCallCheck(this, ContactPoint), this._idCounter = 0, this.colliderA = null,
                this.colliderB = null, this.distance = 0, this.normal = new o(), this.positionOnA = new o(),
                this.positionOnB = new o(), this._id = ++this._idCounter;
        },
        at = function() {
            function Collision() {
                _classCallCheck(this, Collision), this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648,
                    this._isTrigger = !1, this.contacts = [];
            }
            return _createClass(Collision, [{
                key: "_setUpdateFrame",
                value: function(e) {
                    this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
                }
            }]), Collision;
        }(),
        ot = function() {
            function CollisionTool() {
                _classCallCheck(this, CollisionTool), this._hitResultsPoolIndex = 0, this._hitResultsPool = [],
                    this._contactPonintsPoolIndex = 0, this._contactPointsPool = [], this._collisionsPool = [],
                    this._collisions = {};
            }
            return _createClass(CollisionTool, [{
                key: "getHitResult",
                value: function() {
                    var e = this._hitResultsPool[this._hitResultsPoolIndex++];
                    return e || (e = new tt(), this._hitResultsPool.push(e)), e;
                }
            }, {
                key: "recoverAllHitResultsPool",
                value: function() {
                    this._hitResultsPoolIndex = 0;
                }
            }, {
                key: "getContactPoints",
                value: function() {
                    var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
                    return e || (e = new it(), this._contactPointsPool.push(e)), e;
                }
            }, {
                key: "recoverAllContactPointsPool",
                value: function() {
                    this._contactPonintsPoolIndex = 0;
                }
            }, {
                key: "getCollision",
                value: function(e, t) {
                    var r, n = e.id,
                        i = t.id,
                        a = this._collisions[n];
                    return a && (r = a[i]), r || (a || (a = {}, this._collisions[n] = a), (r = 0 === this._collisionsPool.length ? new at() : this._collisionsPool.pop())._colliderA = e,
                        r._colliderB = t, a[i] = r), r;
                }
            }, {
                key: "recoverCollision",
                value: function(e) {
                    var t = e._colliderA.id,
                        r = e._colliderB.id;
                    this._collisions[t][r] = null, this._collisionsPool.push(e);
                }
            }, {
                key: "garbageCollection",
                value: function() {
                    for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0,
                            this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                        var t = this._collisionsPool[e],
                            r = !0;
                        for (var n in t) t[n] ? r = !1 : delete t[n];
                        r && delete this._collisionsPool[e];
                    }
                }
            }]), CollisionTool;
        }(),
        st = function() {
            function ColliderShape() {
                _classCallCheck(this, ColliderShape), this._scale = new o(1, 1, 1), this._centerMatrix = new L(),
                    this._attatched = !1, this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null,
                    this._referenceCount = 0, this._localOffset = new o(0, 0, 0), this._localRotation = new f(0, 0, 0, 1),
                    this.needsCustomCollisionCallback = !1;
            }
            return _createClass(ColliderShape, [{
                key: "_setScale",
                value: function(e) {
                    if (this._compoundParent) this.updateLocalTransformations();
                    else {
                        var t = y._bullet;
                        t.btVector3_setValue(ColliderShape._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, ColliderShape._btScale);
                    }
                }
            }, {
                key: "_addReference",
                value: function() {
                    this._referenceCount++;
                }
            }, {
                key: "_removeReference",
                value: function() {
                    this._referenceCount--;
                }
            }, {
                key: "updateLocalTransformations",
                value: function() {
                    if (this._compoundParent) {
                        var e = ColliderShape._tempVector30;
                        o.multiply(this.localOffset, this._scale, e), ColliderShape._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
                    } else ColliderShape._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation),
                        t.localOffset = t.localOffset, t.localRotation = t.localRotation;
                }
            }, {
                key: "clone",
                value: function() {
                    return null;
                }
            }, {
                key: "destroy",
                value: function() {
                    this._btShape && (y._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "localOffset",
                get: function() {
                    return this._localOffset;
                },
                set: function(e) {
                    this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
                }
            }, {
                key: "localRotation",
                get: function() {
                    return this._localRotation;
                },
                set: function(e) {
                    this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = y._bullet;
                    ColliderShape._btScale = e.btVector3_create(1, 1, 1), ColliderShape._btVector30 = e.btVector3_create(0, 0, 0),
                        ColliderShape._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), ColliderShape._btTransform0 = e.btTransform_create();
                }
            }, {
                key: "_createAffineTransformation",
                value: function(e, t, r) {
                    var n = t.x,
                        i = t.y,
                        a = t.z,
                        o = t.w,
                        s = n + n,
                        l = i + i,
                        u = a + a,
                        c = n * s,
                        h = n * l,
                        _ = n * u,
                        d = i * l,
                        f = i * u,
                        m = a * u,
                        T = o * s,
                        p = o * l,
                        v = o * u;
                    r[0] = 1 - (d + m), r[1] = h + v, r[2] = _ - p, r[3] = 0, r[4] = h - v, r[5] = 1 - (c + m),
                        r[6] = f + T, r[7] = 0, r[8] = _ + p, r[9] = f - T, r[10] = 1 - (c + d), r[11] = 0,
                        r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
                }
            }]), ColliderShape;
        }();
    st.SHAPEORIENTATION_UPX = 0, st.SHAPEORIENTATION_UPY = 1, st.SHAPEORIENTATION_UPZ = 2,
        st.SHAPETYPES_BOX = 0, st.SHAPETYPES_SPHERE = 1, st.SHAPETYPES_CYLINDER = 2, st.SHAPETYPES_CAPSULE = 3,
        st.SHAPETYPES_CONVEXHULL = 4, st.SHAPETYPES_COMPOUND = 5, st.SHAPETYPES_STATICPLANE = 6,
        st.SHAPETYPES_CONE = 7, st._tempVector30 = new o();
    var lt = function(e) {
            function BoxColliderShape() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                _classCallCheck(this, BoxColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxColliderShape).call(this)))._sizeX = t,
                    e._sizeY = r, e._sizeZ = n, e._type = st.SHAPETYPES_BOX;
                var i = y._bullet;
                return i.btVector3_setValue(BoxColliderShape._btSize, t / 2, r / 2, n / 2), e._btShape = i.btBoxShape_create(BoxColliderShape._btSize),
                    e;
            }
            return _inherits(BoxColliderShape, st), _createClass(BoxColliderShape, [{
                key: "sizeX",
                get: function() {
                    return this._sizeX;
                }
            }, {
                key: "sizeY",
                get: function() {
                    return this._sizeY;
                }
            }, {
                key: "sizeZ",
                get: function() {
                    return this._sizeZ;
                }
            }], [{
                key: "__init__",
                value: function() {
                    BoxColliderShape._btSize = y._bullet.btVector3_create(0, 0, 0);
                }
            }]), _createClass(BoxColliderShape, [{
                key: "clone",
                value: function() {
                    var e = new BoxColliderShape(this._sizeX, this._sizeY, this._sizeZ);
                    return this.cloneTo(e), e;
                }
            }]), BoxColliderShape;
        }(),
        ut = function(e) {
            function CapsuleColliderShape() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1.25,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : st.SHAPEORIENTATION_UPY;
                _classCallCheck(this, CapsuleColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CapsuleColliderShape).call(this)))._radius = t,
                    e._length = r, e._orientation = n, e._type = st.SHAPETYPES_CAPSULE;
                var i = y._bullet;
                switch (n) {
                    case st.SHAPEORIENTATION_UPX:
                        e._btShape = i.btCapsuleShapeX_create(t, r - 2 * t);
                        break;

                    case st.SHAPEORIENTATION_UPY:
                        e._btShape = i.btCapsuleShape_create(t, r - 2 * t);
                        break;

                    case st.SHAPEORIENTATION_UPZ:
                        e._btShape = i.btCapsuleShapeZ_create(t, r - 2 * t);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
                return e;
            }
            return _inherits(CapsuleColliderShape, st), _createClass(CapsuleColliderShape, [{
                key: "_setScale",
                value: function(e) {
                    var t = CapsuleColliderShape._tempVector30;
                    switch (this.orientation) {
                        case st.SHAPEORIENTATION_UPX:
                            t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
                            break;

                        case st.SHAPEORIENTATION_UPY:
                            t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
                            break;

                        case st.SHAPEORIENTATION_UPZ:
                            t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
                            break;

                        default:
                            throw "CapsuleColliderShape:unknown orientation.";
                    }
                    _get(_getPrototypeOf(CapsuleColliderShape.prototype), "_setScale", this).call(this, t);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new CapsuleColliderShape(this._radius, this._length, this._orientation);
                    return this.cloneTo(e), e;
                }
            }, {
                key: "radius",
                get: function() {
                    return this._radius;
                }
            }, {
                key: "length",
                get: function() {
                    return this._length;
                }
            }, {
                key: "orientation",
                get: function() {
                    return this._orientation;
                }
            }]), CapsuleColliderShape;
        }();
    ut._tempVector30 = new o();
    var ct = function(e) {
            function CompoundColliderShape() {
                var e;
                return _classCallCheck(this, CompoundColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CompoundColliderShape).call(this)))._childColliderShapes = [],
                    e._type = st.SHAPETYPES_COMPOUND, e._btShape = y._bullet.btCompoundShape_create(),
                    e;
            }
            return _inherits(CompoundColliderShape, st), _createClass(CompoundColliderShape, [{
                key: "_clearChildShape",
                value: function(e) {
                    e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
                }
            }, {
                key: "_addReference",
                value: function() {}
            }, {
                key: "_removeReference",
                value: function() {}
            }, {
                key: "_updateChildTransform",
                value: function(e) {
                    var t = y._bullet,
                        r = e.localOffset,
                        n = e.localRotation,
                        i = st._btVector30,
                        a = st._btQuaternion0,
                        o = st._btTransform0;
                    t.btVector3_setValue(i, -r.x, r.y, r.z), t.btQuaternion_setValue(a, -n.x, n.y, n.z, -n.w),
                        t.btTransform_setOrigin(o, i), t.btTransform_setRotation(o, a), t.btCompoundShape_updateChildTransform(this._btShape, e._indexInCompound, o, !0);
                }
            }, {
                key: "addChildShape",
                value: function(e) {
                    if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
                    e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length,
                        this._childColliderShapes.push(e);
                    var t = e.localOffset,
                        r = e.localRotation,
                        n = y._bullet;
                    n.btVector3_setValue(CompoundColliderShape._btOffset, -t.x, t.y, t.z), n.btQuaternion_setValue(CompoundColliderShape._btRotation, -r.x, r.y, r.z, -r.w),
                        n.btTransform_setOrigin(CompoundColliderShape._btTransform, CompoundColliderShape._btOffset),
                        n.btTransform_setRotation(CompoundColliderShape._btTransform, CompoundColliderShape._btRotation);
                    var i = n.btCollisionShape_getLocalScaling(this._btShape);
                    n.btCollisionShape_setLocalScaling(this._btShape, CompoundColliderShape._btVector3One),
                        n.btCompoundShape_addChildShape(this._btShape, CompoundColliderShape._btTransform, e._btShape),
                        n.btCollisionShape_setLocalScaling(this._btShape, i), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
                }
            }, {
                key: "removeChildShape",
                value: function(e) {
                    if (e._compoundParent === this) {
                        var t = e._indexInCompound;
                        this._clearChildShape(e);
                        var r = this._childColliderShapes[this._childColliderShapes.length - 1];
                        r._indexInCompound = t, this._childColliderShapes[t] = r, this._childColliderShapes.pop(),
                            y._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, t);
                    }
                }
            }, {
                key: "clearChildShape",
                value: function() {
                    for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this._clearChildShape(this._childColliderShapes[e]),
                        y._bullet.btCompoundShape_removeChildShapeByIndex(this._btShape, 0);
                    this._childColliderShapes.length = 0;
                }
            }, {
                key: "getChildShapeCount",
                value: function() {
                    return this._childColliderShapes.length;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.clearChildShape();
                    for (var r = 0, n = this._childColliderShapes.length; r < n; r++) t.addChildShape(this._childColliderShapes[r].clone());
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new CompoundColliderShape();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(CompoundColliderShape.prototype), "destroy", this).call(this);
                    for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                        var r = this._childColliderShapes[e];
                        0 === r._referenceCount && r.destroy();
                    }
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = y._bullet;
                    CompoundColliderShape._btVector3One = e.btVector3_create(1, 1, 1), CompoundColliderShape._btTransform = e.btTransform_create(),
                        CompoundColliderShape._btOffset = e.btVector3_create(0, 0, 0), CompoundColliderShape._btRotation = e.btQuaternion_create(0, 0, 0, 1);
                }
            }]), CompoundColliderShape;
        }(),
        ht = function(e) {
            function ConeColliderShape() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : st.SHAPEORIENTATION_UPY;
                _classCallCheck(this, ConeColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeColliderShape).call(this)))._radius = 1,
                    e._height = .5, e._radius = t, e._height = r, e._orientation = n, e._type = st.SHAPETYPES_CYLINDER;
                var i = y._bullet;
                switch (n) {
                    case st.SHAPEORIENTATION_UPX:
                        e._btShape = i.btConeShapeX_create(t, r);
                        break;

                    case st.SHAPEORIENTATION_UPY:
                        e._btShape = i.btConeShape_create(t, r);
                        break;

                    case st.SHAPEORIENTATION_UPZ:
                        e._btShape = i.btConeShapeZ_create(t, r);
                        break;

                    default:
                        throw "ConeColliderShape:unknown orientation.";
                }
                return e;
            }
            return _inherits(ConeColliderShape, st), _createClass(ConeColliderShape, [{
                key: "clone",
                value: function() {
                    var e = new ConeColliderShape(this._radius, this._height, this._orientation);
                    return this.cloneTo(e), e;
                }
            }, {
                key: "radius",
                get: function() {
                    return this._radius;
                }
            }, {
                key: "height",
                get: function() {
                    return this._height;
                }
            }, {
                key: "orientation",
                get: function() {
                    return this._orientation;
                }
            }]), ConeColliderShape;
        }(),
        _t = function(e) {
            function CylinderColliderShape() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : st.SHAPEORIENTATION_UPY;
                _classCallCheck(this, CylinderColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CylinderColliderShape).call(this)))._radius = 1,
                    e._height = .5, e._radius = t, e._height = r, e._orientation = n, e._type = st.SHAPETYPES_CYLINDER;
                var i = y._bullet;
                switch (n) {
                    case st.SHAPEORIENTATION_UPX:
                        i.btVector3_setValue(CylinderColliderShape._btSize, r / 2, t, t), e._btShape = i.btCylinderShapeX_create(CylinderColliderShape._btSize);
                        break;

                    case st.SHAPEORIENTATION_UPY:
                        i.btVector3_setValue(CylinderColliderShape._btSize, t, r / 2, t), e._btShape = i.btCylinderShape_create(CylinderColliderShape._btSize);
                        break;

                    case st.SHAPEORIENTATION_UPZ:
                        i.btVector3_setValue(CylinderColliderShape._btSize, t, t, r / 2), e._btShape = i.btCylinderShapeZ_create(CylinderColliderShape._btSize);
                        break;

                    default:
                        throw "CapsuleColliderShape:unknown orientation.";
                }
                return e;
            }
            return _inherits(CylinderColliderShape, st), _createClass(CylinderColliderShape, [{
                key: "clone",
                value: function() {
                    var e = new CylinderColliderShape(this._radius, this._height, this._orientation);
                    return this.cloneTo(e), e;
                }
            }, {
                key: "radius",
                get: function() {
                    return this._radius;
                }
            }, {
                key: "height",
                get: function() {
                    return this._height;
                }
            }, {
                key: "orientation",
                get: function() {
                    return this._orientation;
                }
            }], [{
                key: "__init__",
                value: function() {
                    CylinderColliderShape._btSize = y._bullet.btVector3_create(0, 0, 0);
                }
            }]), CylinderColliderShape;
        }(),
        dt = function(e) {
            function MeshColliderShape() {
                var e;
                return _classCallCheck(this, MeshColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshColliderShape).call(this)))._mesh = null,
                    e._convex = !1, e;
            }
            return _inherits(MeshColliderShape, st), _createClass(MeshColliderShape, [{
                key: "_setScale",
                value: function(e) {
                    if (this._compoundParent) this.updateLocalTransformations();
                    else {
                        var t = y._bullet;
                        t.btVector3_setValue(st._btScale, e.x, e.y, e.z), t.btCollisionShape_setLocalScaling(this._btShape, st._btScale),
                            t.btGImpactShapeInterface_updateBound(this._btShape);
                    }
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t.convex = this._convex, t.mesh = this._mesh, _get(_getPrototypeOf(MeshColliderShape.prototype), "cloneTo", this).call(this, e);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new MeshColliderShape();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "destroy",
                value: function() {
                    this._btShape && (y._bullet.btCollisionShape_destroy(this._btShape), this._btShape = null);
                }
            }, {
                key: "mesh",
                get: function() {
                    return this._mesh;
                },
                set: function(e) {
                    if (this._mesh !== e) {
                        var t = y._bullet;
                        this._mesh && t.destroy(this._btShape), e && (this._btShape = t.btGImpactMeshShape_create(e._getPhysicMesh()),
                            t.btGImpactShapeInterface_updateBound(this._btShape)), this._mesh = e;
                    }
                }
            }, {
                key: "convex",
                get: function() {
                    return this._convex;
                },
                set: function(e) {
                    this._convex = e;
                }
            }]), MeshColliderShape;
        }(),
        ft = function(e) {
            function SphereColliderShape() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5;
                return _classCallCheck(this, SphereColliderShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereColliderShape).call(this)))._radius = t,
                    e._type = st.SHAPETYPES_SPHERE, e._btShape = y._bullet.btSphereShape_create(t),
                    e;
            }
            return _inherits(SphereColliderShape, st), _createClass(SphereColliderShape, [{
                key: "radius",
                get: function() {
                    return this._radius;
                }
            }]), _createClass(SphereColliderShape, [{
                key: "clone",
                value: function() {
                    var e = new SphereColliderShape(this._radius);
                    return this.cloneTo(e), e;
                }
            }]), SphereColliderShape;
        }(),
        mt = function(e) {
            function PhysicsComponent(e, t) {
                var r;
                return _classCallCheck(this, PhysicsComponent), (r = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsComponent).call(this)))._restitution = 0,
                    r._friction = .5, r._rollingFriction = 0, r._ccdMotionThreshold = 0, r._ccdSweptSphereRadius = 0,
                    r._collisionGroup = rt.COLLISIONFILTERGROUP_DEFAULTFILTER, r._canCollideWith = rt.COLLISIONFILTERGROUP_ALLFILTER,
                    r._colliderShape = null, r._transformFlag = 2147483647, r._controlBySimulation = !1,
                    r._enableProcessCollisions = !0, r._inPhysicUpdateListIndex = -1, r.canScaleShape = !0,
                    r._collisionGroup = e, r._canCollideWith = t, PhysicsComponent._physicObjectsMap[r.id] = _assertThisInitialized(r),
                    r;
            }
            return _inherits(PhysicsComponent, t.Component), _createClass(PhysicsComponent, [{
                key: "_parseShape",
                value: function(e) {
                    var t = e.length;
                    if (1 === t) {
                        var r = PhysicsComponent._creatShape(e[0]);
                        this.colliderShape = r;
                    } else {
                        for (var n = new ct(), i = 0; i < t; i++) r = PhysicsComponent._creatShape(e[i]),
                            n.addChildShape(r);
                        this.colliderShape = n;
                    }
                }
            }, {
                key: "_onScaleChange",
                value: function(e) {
                    this._colliderShape._setScale(e);
                }
            }, {
                key: "_onEnable",
                value: function() {
                    this._simulation = this.owner._scene.physicsSimulation, y._bullet.btCollisionObject_setContactProcessingThreshold(this._btColliderObject, 1e30),
                        this._colliderShape && (this._derivePhysicsTransformation(!0), this._addToSimulation());
                }
            }, {
                key: "_onDisable",
                value: function() {
                    this._colliderShape && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)),
                        this._simulation = null;
                }
            }, {
                key: "_onDestroy",
                value: function() {
                    delete PhysicsComponent._physicObjectsMap[this.id], y._bullet.btCollisionObject_destroy(this._btColliderObject),
                        this._colliderShape.destroy(), _get(_getPrototypeOf(PhysicsComponent.prototype), "_onDestroy", this).call(this),
                        this._btColliderObject = null, this._colliderShape = null, this._simulation = null,
                        this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
                }
            }, {
                key: "_isValid",
                value: function() {
                    return this._simulation && this._colliderShape && this._enabled;
                }
            }, {
                key: "_parse",
                value: function(e) {
                    null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith),
                        null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold),
                        null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
                }
            }, {
                key: "_setTransformFlag",
                value: function(e, t) {
                    t ? this._transformFlag |= e : this._transformFlag &= ~e;
                }
            }, {
                key: "_getTransformFlag",
                value: function(e) {
                    return 0 != (this._transformFlag & e);
                }
            }, {
                key: "_addToSimulation",
                value: function() {}
            }, {
                key: "_removeFromSimulation",
                value: function() {}
            }, {
                key: "_derivePhysicsTransformation",
                value: function(e) {
                    var t = y._bullet,
                        r = this._btColliderObject,
                        n = t.btCollisionObject_getWorldTransform(r);
                    this._innerDerivePhysicsTransformation(n, e), t.btCollisionObject_setWorldTransform(r, n);
                }
            }, {
                key: "_innerDerivePhysicsTransformation",
                value: function(e, t) {
                    var r = y._bullet,
                        n = this.owner._transform;
                    if (t || this._getTransformFlag(se.TRANSFORM_WORLDPOSITION)) {
                        var i = this._colliderShape.localOffset,
                            a = n.position,
                            s = PhysicsComponent._btVector30;
                        if (0 !== i.x || 0 !== i.y || 0 !== i.z) {
                            var l = PhysicsComponent._tempVector30,
                                u = n.worldMatrix;
                            o.transformCoordinate(i, u, l), r.btVector3_setValue(s, -l.x, l.y, l.z);
                        } else r.btVector3_setValue(s, -a.x, a.y, a.z);
                        r.btTransform_setOrigin(e, s), this._setTransformFlag(se.TRANSFORM_WORLDPOSITION, !1);
                    }
                    if (t || this._getTransformFlag(se.TRANSFORM_WORLDQUATERNION)) {
                        var c = this._colliderShape.localRotation,
                            h = PhysicsComponent._btQuaternion0,
                            _ = n.rotation;
                        if (0 !== c.x || 0 !== c.y || 0 !== c.z || 1 !== c.w) {
                            var d = PhysicsComponent._tempQuaternion0;
                            PhysicsComponent.physicQuaternionMultiply(_.x, _.y, _.z, _.w, c, d), r.btQuaternion_setValue(h, -d.x, d.y, d.z, -d.w);
                        } else r.btQuaternion_setValue(h, -_.x, _.y, _.z, -_.w);
                        r.btTransform_setRotation(e, h), this._setTransformFlag(se.TRANSFORM_WORLDQUATERNION, !1);
                    }
                    (t || this._getTransformFlag(se.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(n.getWorldLossyScale()),
                        this._setTransformFlag(se.TRANSFORM_WORLDSCALE, !1));
                }
            }, {
                key: "_updateTransformComponent",
                value: function(e) {
                    var t = y._bullet,
                        r = this._colliderShape,
                        n = r.localOffset,
                        i = r.localRotation,
                        a = this.owner._transform,
                        s = a.position,
                        l = a.rotation,
                        u = t.btTransform_getOrigin(e),
                        c = t.btTransform_getRotation(e),
                        h = -t.btQuaternion_x(c),
                        _ = t.btQuaternion_y(c),
                        d = t.btQuaternion_z(c),
                        f = -t.btQuaternion_w(c);
                    if (0 !== i.x || 0 !== i.y || 0 !== i.z || 1 !== i.w) {
                        var m = PhysicsComponent._tempQuaternion0;
                        i.invert(m), PhysicsComponent.physicQuaternionMultiply(h, _, d, f, m, l);
                    } else l.x = h, l.y = _, l.z = d, l.w = f;
                    if (a.rotation = l, 0 !== n.x || 0 !== n.y || 0 !== n.z) {
                        var T = t.btCollisionShape_getLocalScaling(r._btShape),
                            p = PhysicsComponent._tempVector30;
                        p.x = n.x * t.btVector3_x(T), p.y = n.y * t.btVector3_y(T), p.z = n.z * t.btVector3_z(T),
                            o.transformQuat(p, l, p), s.x = -t.btVector3_x(u) - p.x, s.y = t.btVector3_y(u) - p.y,
                            s.z = t.btVector3_z(u) - p.z;
                    } else s.x = -t.btVector3_x(u), s.y = t.btVector3_y(u), s.z = t.btVector3_z(u);
                    a.position = s;
                }
            }, {
                key: "_onShapeChange",
                value: function(e) {
                    var t = this._btColliderObject,
                        r = y._bullet,
                        n = r.btCollisionObject_getCollisionFlags(t);
                    e.needsCustomCollisionCallback ? 0 == (n & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && r.btCollisionObject_setCollisionFlags(t, n | PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (n & PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && r.btCollisionObject_setCollisionFlags(t, n ^ PhysicsComponent.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
                }
            }, {
                key: "_onAdded",
                value: function() {
                    this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction,
                        this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold,
                        this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
                }
            }, {
                key: "_onTransformChanged",
                value: function(e) {
                    !PhysicsComponent._addUpdateList && this._controlBySimulation || (e &= se.TRANSFORM_WORLDPOSITION | se.TRANSFORM_WORLDQUATERNION | se.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                        this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
                }
            }, {
                key: "_cloneTo",
                value: function(e) {
                    var t = e;
                    t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction,
                        t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                        t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith,
                        t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
                }
            }, {
                key: "restitution",
                get: function() {
                    return this._restitution;
                },
                set: function(e) {
                    this._restitution = e, this._btColliderObject && y._bullet.btCollisionObject_setRestitution(this._btColliderObject, e);
                }
            }, {
                key: "friction",
                get: function() {
                    return this._friction;
                },
                set: function(e) {
                    this._friction = e, this._btColliderObject && y._bullet.btCollisionObject_setFriction(this._btColliderObject, e);
                }
            }, {
                key: "rollingFriction",
                get: function() {
                    return this._rollingFriction;
                },
                set: function(e) {
                    this._rollingFriction = e, this._btColliderObject && y._bullet.btCollisionObject_setRollingFriction(this._btColliderObject, e);
                }
            }, {
                key: "ccdMotionThreshold",
                get: function() {
                    return this._ccdMotionThreshold;
                },
                set: function(e) {
                    this._ccdMotionThreshold = e, this._btColliderObject && y._bullet.btCollisionObject_setCcdMotionThreshold(this._btColliderObject, e);
                }
            }, {
                key: "ccdSweptSphereRadius",
                get: function() {
                    return this._ccdSweptSphereRadius;
                },
                set: function(e) {
                    this._ccdSweptSphereRadius = e, this._btColliderObject && y._bullet.btCollisionObject_setCcdSweptSphereRadius(this._btColliderObject, e);
                }
            }, {
                key: "isActive",
                get: function() {
                    return !!this._btColliderObject && y._bullet.btCollisionObject_isActive(this._btColliderObject);
                }
            }, {
                key: "colliderShape",
                get: function() {
                    return this._colliderShape;
                },
                set: function(e) {
                    var t = this._colliderShape;
                    if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e,
                        e) {
                        if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                        if (e._attatched = !0, e._attatchedCollisionObject = this, this._btColliderObject) {
                            y._bullet.btCollisionObject_setCollisionShape(this._btColliderObject, e._btShape);
                            var r = this._simulation && this._enabled;
                            r && t && this._removeFromSimulation(), this._onShapeChange(e), r && (this._derivePhysicsTransformation(!0),
                                this._addToSimulation());
                        }
                    } else this._simulation && this._enabled && t && this._removeFromSimulation();
                }
            }, {
                key: "simulation",
                get: function() {
                    return this._simulation;
                }
            }, {
                key: "collisionGroup",
                get: function() {
                    return this._collisionGroup;
                },
                set: function(e) {
                    this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                        this._addToSimulation()));
                }
            }, {
                key: "canCollideWith",
                get: function() {
                    return this._canCollideWith;
                },
                set: function(e) {
                    this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                        this._addToSimulation()));
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = y._bullet;
                    PhysicsComponent._btVector30 = e.btVector3_create(0, 0, 0), PhysicsComponent._btQuaternion0 = e.btQuaternion_create(0, 0, 0, 1);
                }
            }, {
                key: "_createAffineTransformationArray",
                value: function(e, t, r, n, i, a, o, s, l) {
                    var u = n + n,
                        c = i + i,
                        h = a + a,
                        _ = n * u,
                        d = n * c,
                        f = n * h,
                        m = i * c,
                        T = i * h,
                        p = a * h,
                        v = o * u,
                        E = o * c,
                        g = o * h,
                        y = s[0],
                        S = s[1],
                        R = s[2];
                    l[0] = (1 - (m + p)) * y, l[1] = (d + g) * y, l[2] = (f - E) * y, l[3] = 0, l[4] = (d - g) * S,
                        l[5] = (1 - (_ + p)) * S, l[6] = (T + v) * S, l[7] = 0, l[8] = (f + E) * R, l[9] = (T - v) * R,
                        l[10] = (1 - (_ + m)) * R, l[11] = 0, l[12] = e, l[13] = t, l[14] = r, l[15] = 1;
                }
            }, {
                key: "_creatShape",
                value: function(e) {
                    var r;
                    switch (e.type) {
                        case "BoxColliderShape":
                            var n = e.size;
                            r = n ? new lt(n[0], n[1], n[2]) : new lt();
                            break;

                        case "SphereColliderShape":
                            r = new ft(e.radius);
                            break;

                        case "CapsuleColliderShape":
                            r = new ut(e.radius, e.height, e.orientation);
                            break;

                        case "MeshColliderShape":
                            var i = new dt();
                            e.mesh && (i.mesh = t.Loader.getRes(e.mesh)), r = i;
                            break;

                        case "ConeColliderShape":
                            r = new ht(e.radius, e.height, e.orientation);
                            break;

                        case "CylinderColliderShape":
                            r = new _t(e.radius, e.height, e.orientation);
                            break;

                        default:
                            throw "unknown shape type.";
                    }
                    if (e.center) {
                        var a = r.localOffset;
                        a.fromArray(e.center), r.localOffset = a;
                    }
                    return r;
                }
            }, {
                key: "physicVector3TransformQuat",
                value: function(e, t, r, n, i, a) {
                    var o = e.x,
                        s = e.y,
                        l = e.z,
                        u = i * o + r * l - n * s,
                        c = i * s + n * o - t * l,
                        h = i * l + t * s - r * o,
                        _ = -t * o - r * s - n * l;
                    a.x = u * i + _ * -t + c * -n - h * -r, a.y = c * i + _ * -r + h * -t - u * -n,
                        a.z = h * i + _ * -n + u * -r - c * -t;
                }
            }, {
                key: "physicQuaternionMultiply",
                value: function(e, t, r, n, i, a) {
                    var o = i.x,
                        s = i.y,
                        l = i.z,
                        u = i.w,
                        c = t * l - r * s,
                        h = r * o - e * l,
                        _ = e * s - t * o,
                        d = e * o + t * s + r * l;
                    a.x = e * u + o * n + c, a.y = t * u + s * n + h, a.z = r * u + l * n + _, a.w = n * u - d;
                }
            }]), PhysicsComponent;
        }();
    mt.ACTIVATIONSTATE_ACTIVE_TAG = 1, mt.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, mt.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3,
        mt.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, mt.ACTIVATIONSTATE_DISABLE_SIMULATION = 5,
        mt.COLLISIONFLAGS_STATIC_OBJECT = 1, mt.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, mt.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4,
        mt.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, mt.COLLISIONFLAGS_CHARACTER_OBJECT = 16,
        mt.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, mt.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64,
        mt._tempVector30 = new o(), mt._tempQuaternion0 = new f(), mt._tempQuaternion1 = new f(),
        mt._tempMatrix4x40 = new L(), mt._physicObjectsMap = {}, mt._addUpdateList = !0;
    var Tt = function() {
        function PhysicsSimulation(e) {
            arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            _classCallCheck(this, PhysicsSimulation), this._gravity = new o(0, -10, 0), this._btVector3Zero = y._bullet.btVector3_create(0, 0, 0),
                this._btDefaultQuaternion = y._bullet.btQuaternion_create(0, 0, 0, -1), this._collisionsUtils = new ot(),
                this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new nt(),
                this._characters = [], this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60,
                this.maxSubSteps = e.maxSubSteps, this.fixedTimeStep = e.fixedTimeStep;
            var t = y._bullet;
            this._btCollisionConfiguration = t.btDefaultCollisionConfiguration_create(), this._btDispatcher = t.btCollisionDispatcher_create(this._btCollisionConfiguration),
                this._btBroadphase = t.btDbvtBroadphase_create(), t.btOverlappingPairCache_setInternalGhostPairCallback(t.btDbvtBroadphase_getOverlappingPairCache(this._btBroadphase), t.btGhostPairCallback_create());
            var r = e.flags;
            if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._btCollisionWorld = new t.btCollisionWorld(this._btDispatcher, this._btBroadphase, this._btCollisionConfiguration);
            else {
                if (r & PhysicsSimulation.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var n = t.btSequentialImpulseConstraintSolver_create();
                this._btDiscreteDynamicsWorld = t.btDiscreteDynamicsWorld_create(this._btDispatcher, this._btBroadphase, n, this._btCollisionConfiguration),
                    this._btCollisionWorld = this._btDiscreteDynamicsWorld;
            }
            this._btDiscreteDynamicsWorld && (this._btSolverInfo = t.btDynamicsWorld_getSolverInfo(this._btDiscreteDynamicsWorld),
                    this._btDispatchInfo = t.btCollisionWorld_getDispatchInfo(this._btDiscreteDynamicsWorld)),
                this._btClosestRayResultCallback = t.ClosestRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btAllHitsRayResultCallback = t.AllHitsRayResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btClosestConvexResultCallback = t.ClosestConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                this._btAllConvexResultCallback = t.AllConvexResultCallback_create(this._btVector3Zero, this._btVector3Zero),
                t.btGImpactCollisionAlgorithm_RegisterAlgorithm(this._btDispatcher);
        }
        return _createClass(PhysicsSimulation, [{
            key: "_simulate",
            value: function(e) {
                this._updatedRigidbodies = 0;
                var t = y._bullet;
                this._btDiscreteDynamicsWorld ? t.btDiscreteDynamicsWorld_stepSimulation(this._btDiscreteDynamicsWorld, e, this.maxSubSteps, this.fixedTimeStep) : t.PerformDiscreteCollisionDetection(this._btCollisionWorld);
            }
        }, {
            key: "_destroy",
            value: function() {
                var e = y._bullet;
                this._btDiscreteDynamicsWorld ? (e.btCollisionWorld_destroy(this._btDiscreteDynamicsWorld),
                        this._btDiscreteDynamicsWorld = null) : (e.btCollisionWorld_destroy(this._btCollisionWorld),
                        this._btCollisionWorld = null), e.btDbvtBroadphase_destroy(this._btBroadphase),
                    this._btBroadphase = null, e.btCollisionDispatcher_destroy(this._btDispatcher),
                    this._btDispatcher = null, e.btDefaultCollisionConfiguration_destroy(this._btCollisionConfiguration),
                    this._btCollisionConfiguration = null;
            }
        }, {
            key: "_addPhysicsCollider",
            value: function(e, t, r) {
                y._bullet.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removePhysicsCollider",
            value: function(e) {
                y._bullet.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addRigidBody",
            value: function(e, t, r) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                y._bullet.btDiscreteDynamicsWorld_addRigidBody(this._btCollisionWorld, e._btColliderObject, t, r);
            }
        }, {
            key: "_removeRigidBody",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                y._bullet.btDiscreteDynamicsWorld_removeRigidBody(this._btCollisionWorld, e._btColliderObject);
            }
        }, {
            key: "_addCharacter",
            value: function(e, t, r) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var n = y._bullet;
                n.btCollisionWorld_addCollisionObject(this._btCollisionWorld, e._btColliderObject, t, r),
                    n.btDynamicsWorld_addAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "_removeCharacter",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                var t = y._bullet;
                t.btCollisionWorld_removeCollisionObject(this._btCollisionWorld, e._btColliderObject),
                    t.btDynamicsWorld_removeAction(this._btCollisionWorld, e._btKinematicCharacter);
            }
        }, {
            key: "raycastFromTo",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    a = y._bullet,
                    o = this._btClosestRayResultCallback,
                    s = PhysicsSimulation._btTempVector30,
                    l = PhysicsSimulation._btTempVector31;
                if (a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(l, -t.x, t.y, t.z),
                    a.ClosestRayResultCallback_set_m_rayFromWorld(o, s), a.ClosestRayResultCallback_set_m_rayToWorld(o, l),
                    a.RayResultCallback_set_m_collisionFilterGroup(o, n), a.RayResultCallback_set_m_collisionFilterMask(o, i),
                    a.RayResultCallback_set_m_collisionObject(o, null), a.RayResultCallback_set_m_closestHitFraction(o, 1),
                    a.btCollisionWorld_rayTest(this._btCollisionWorld, s, l, o), a.RayResultCallback_hasHit(o)) {
                    if (r) {
                        r.succeeded = !0, r.collider = mt._physicObjectsMap[a.btCollisionObject_getUserIndex(a.RayResultCallback_get_m_collisionObject(o))],
                            r.hitFraction = a.RayResultCallback_get_m_closestHitFraction(o);
                        var u = a.ClosestRayResultCallback_get_m_hitPointWorld(o),
                            c = r.point;
                        c.x = -a.btVector3_x(u), c.y = a.btVector3_y(u), c.z = a.btVector3_z(u);
                        var h = a.ClosestRayResultCallback_get_m_hitNormalWorld(o),
                            _ = r.normal;
                        _.x = -a.btVector3_x(h), _.y = a.btVector3_y(h), _.z = a.btVector3_z(h);
                    }
                    return !0;
                }
                return r && (r.succeeded = !1), !1;
            }
        }, {
            key: "raycastAllFromTo",
            value: function(e, t, r) {
                var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    a = y._bullet,
                    o = this._btAllHitsRayResultCallback,
                    s = PhysicsSimulation._btTempVector30,
                    l = PhysicsSimulation._btTempVector31;
                r.length = 0, a.btVector3_setValue(s, -e.x, e.y, e.z), a.btVector3_setValue(l, -t.x, t.y, t.z),
                    a.AllHitsRayResultCallback_set_m_rayFromWorld(o, s), a.AllHitsRayResultCallback_set_m_rayToWorld(o, l),
                    a.RayResultCallback_set_m_collisionFilterGroup(o, n), a.RayResultCallback_set_m_collisionFilterMask(o, i);
                var u = a.AllHitsRayResultCallback_get_m_collisionObjects(o),
                    c = a.AllHitsRayResultCallback_get_m_hitPointWorld(o),
                    h = a.AllHitsRayResultCallback_get_m_hitNormalWorld(o),
                    _ = a.AllHitsRayResultCallback_get_m_hitFractions(o);
                a.tBtCollisionObjectArray_clear(u), a.tVector3Array_clear(c), a.tVector3Array_clear(h),
                    a.tScalarArray_clear(_), a.btCollisionWorld_rayTest(this._btCollisionWorld, s, l, o);
                var d = a.tBtCollisionObjectArray_size(u);
                if (d > 0) {
                    this._collisionsUtils.recoverAllHitResultsPool();
                    for (var f = 0; f < d; f++) {
                        var m = this._collisionsUtils.getHitResult();
                        r.push(m), m.succeeded = !0, m.collider = mt._physicObjectsMap[a.btCollisionObject_getUserIndex(a.tBtCollisionObjectArray_at(u, f))],
                            m.hitFraction = a.tScalarArray_at(_, f);
                        var T = a.tVector3Array_at(c, f),
                            p = m.point;
                        p.x = -a.btVector3_x(T), p.y = a.btVector3_y(T), p.z = a.btVector3_z(T);
                        var v = a.tVector3Array_at(h, f),
                            E = m.normal;
                        E.x = -a.btVector3_x(v), E.y = a.btVector3_y(v), E.z = a.btVector3_z(v);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "rayCast",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    a = e.origin,
                    s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s), o.scale(s, r, s), o.add(a, s, s), this.raycastFromTo(a, s, t, n, i);
            }
        }, {
            key: "rayCastAll",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 2147483647,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    a = e.origin,
                    s = PhysicsSimulation._tempVector30;
                return o.normalize(e.direction, s), o.scale(s, r, s), o.add(a, s, s), this.raycastAllFromTo(a, s, t, n, i);
            }
        }, {
            key: "shapeCast",
            value: function(e, t, r) {
                var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                    a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                    u = y._bullet,
                    c = this._btClosestConvexResultCallback,
                    h = PhysicsSimulation._btTempVector30,
                    _ = PhysicsSimulation._btTempVector31,
                    d = PhysicsSimulation._btTempQuaternion0,
                    f = PhysicsSimulation._btTempQuaternion1,
                    m = PhysicsSimulation._btTempTransform0,
                    T = PhysicsSimulation._btTempTransform1,
                    p = e._btShape;
                if (u.btVector3_setValue(h, -t.x, t.y, t.z), u.btVector3_setValue(_, -r.x, r.y, r.z),
                    u.ConvexResultCallback_set_m_collisionFilterGroup(c, o), u.ConvexResultCallback_set_m_collisionFilterMask(c, s),
                    u.btTransform_setOrigin(m, h), u.btTransform_setOrigin(T, _), i ? (u.btQuaternion_setValue(d, -i.x, i.y, i.z, -i.w),
                        u.btTransform_setRotation(m, d)) : u.btTransform_setRotation(m, this._btDefaultQuaternion),
                    a ? (u.btQuaternion_setValue(f, -a.x, a.y, a.z, -a.w), u.btTransform_setRotation(T, f)) : u.btTransform_setRotation(T, this._btDefaultQuaternion),
                    u.ClosestConvexResultCallback_set_m_hitCollisionObject(c, null), u.ConvexResultCallback_set_m_closestHitFraction(c, 1),
                    u.btCollisionWorld_convexSweepTest(this._btCollisionWorld, p, m, T, c, l), u.ConvexResultCallback_hasHit(c)) {
                    if (n) {
                        n.succeeded = !0, n.collider = mt._physicObjectsMap[u.btCollisionObject_getUserIndex(u.ClosestConvexResultCallback_get_m_hitCollisionObject(c))],
                            n.hitFraction = u.ConvexResultCallback_get_m_closestHitFraction(c);
                        var v = u.ClosestConvexResultCallback_get_m_hitPointWorld(c),
                            E = u.ClosestConvexResultCallback_get_m_hitNormalWorld(c),
                            g = n.point,
                            S = n.normal;
                        g.x = -u.btVector3_x(v), g.y = u.btVector3_y(v), g.z = u.btVector3_z(v), S.x = -u.btVector3_x(E),
                            S.y = u.btVector3_y(E), S.z = u.btVector3_z(E);
                    }
                    return !0;
                }
                return n && (n.succeeded = !1), !1;
            }
        }, {
            key: "shapeCastAll",
            value: function(e, t, r, n) {
                var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                    a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : rt.COLLISIONFILTERGROUP_ALLFILTER,
                    l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                    u = y._bullet,
                    c = this._btAllConvexResultCallback,
                    h = PhysicsSimulation._btTempVector30,
                    _ = PhysicsSimulation._btTempVector31,
                    d = PhysicsSimulation._btTempQuaternion0,
                    f = PhysicsSimulation._btTempQuaternion1,
                    m = PhysicsSimulation._btTempTransform0,
                    T = PhysicsSimulation._btTempTransform1,
                    p = e._btShape;
                n.length = 0, u.btVector3_setValue(h, -t.x, t.y, t.z), u.btVector3_setValue(_, -r.x, r.y, r.z),
                    u.ConvexResultCallback_set_m_collisionFilterGroup(c, o), u.ConvexResultCallback_set_m_collisionFilterMask(c, s),
                    u.btTransform_setOrigin(m, h), u.btTransform_setOrigin(T, _), i ? (u.btQuaternion_setValue(d, -i.x, i.y, i.z, -i.w),
                        u.btTransform_setRotation(m, d)) : u.btTransform_setRotation(m, this._btDefaultQuaternion),
                    a ? (u.btQuaternion_setValue(f, -a.x, a.y, a.z, -a.w), u.btTransform_setRotation(T, f)) : u.btTransform_setRotation(T, this._btDefaultQuaternion);
                var v = u.AllConvexResultCallback_get_m_collisionObjects(c);
                u.tBtCollisionObjectArray_clear(v), u.btCollisionWorld_convexSweepTest(this._btCollisionWorld, p, m, T, c, l);
                var E = u.tBtCollisionObjectArray_size(v);
                if (E > 0) {
                    for (var g = u.AllConvexResultCallback_get_m_hitPointWorld(c), S = u.AllConvexResultCallback_get_m_hitNormalWorld(c), R = u.AllConvexResultCallback_get_m_hitFractions(c), C = 0; C < E; C++) {
                        var M = this._collisionsUtils.getHitResult();
                        n.push(M), M.succeeded = !0, M.collider = mt._physicObjectsMap[u.btCollisionObject_getUserIndex(u.tBtCollisionObjectArray_at(v, C))],
                            M.hitFraction = u.tScalarArray_at(R, C);
                        var x = u.tVector3Array_at(g, C),
                            D = M.point;
                        D.x = -u.btVector3_x(x), D.y = u.btVector3_y(x), D.z = u.btVector3_z(x);
                        var A = u.tVector3Array_at(S, C),
                            L = M.normal;
                        L.x = -u.btVector3_x(A), L.y = u.btVector3_y(A), L.z = u.btVector3_z(A);
                    }
                    return !0;
                }
                return !1;
            }
        }, {
            key: "addConstraint",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                e._simulation = this;
            }
        }, {
            key: "removeConstraint",
            value: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            }
        }, {
            key: "_updatePhysicsTransformFromRender",
            value: function() {
                for (var e = this._physicsUpdateList.elements, t = 0, r = this._physicsUpdateList.length; t < r; t++) {
                    var n = e[t];
                    n._derivePhysicsTransformation(!1), n._inPhysicUpdateListIndex = -1;
                }
                this._physicsUpdateList.length = 0;
            }
        }, {
            key: "_updateCharacters",
            value: function() {
                for (var e = 0, t = this._characters.length; e < t; e++) {
                    var r = this._characters[e];
                    r._updateTransformComponent(y._bullet.btCollisionObject_getWorldTransform(r._btColliderObject));
                }
            }
        }, {
            key: "_updateCollisions",
            value: function() {
                this._collisionsUtils.recoverAllContactPointsPool();
                var e = this._currentFrameCollisions;
                this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0,
                    this._previousFrameCollisions = e;
                for (var r = t.Stat.loopCount, n = y._bullet, i = n.btDispatcher_getNumManifolds(this._btDispatcher), a = 0; a < i; a++) {
                    var o, s = n.btDispatcher_getManifoldByIndexInternal(this._btDispatcher, a),
                        l = mt._physicObjectsMap[n.btCollisionObject_getUserIndex(n.btPersistentManifold_getBody0(s))],
                        u = mt._physicObjectsMap[n.btCollisionObject_getUserIndex(n.btPersistentManifold_getBody1(s))],
                        c = null,
                        h = null;
                    if ((l.isTrigger || u.isTrigger) && (l.owner._needProcessTriggers || u.owner._needProcessTriggers))
                        for (var _ = n.btPersistentManifold_getNumContacts(s), d = 0; d < _; d++) {
                            var f = n.btPersistentManifold_getContactPoint(s, d),
                                m = n.btManifoldPoint_getDistance(f);
                            if (m <= 0) {
                                h = (c = this._collisionsUtils.getCollision(l, u)).contacts, (o = c._updateFrame !== r) && (c._isTrigger = !0,
                                    h.length = 0);
                                break;
                            }
                        } else if ((l.owner._needProcessCollisions || u.owner._needProcessCollisions) && (l._enableProcessCollisions || u._enableProcessCollisions))
                            for (_ = n.btPersistentManifold_getNumContacts(s),
                                d = 0; d < _; d++)
                                if (f = n.btPersistentManifold_getContactPoint(s, d), (m = n.btManifoldPoint_getDistance(f)) <= 0) {
                                    var T = this._collisionsUtils.getContactPoints();
                                    T.colliderA = l, T.colliderB = u, T.distance = m;
                                    var p = n.btManifoldPoint_get_m_normalWorldOnB(f),
                                        v = T.normal;
                                    v.x = -n.btVector3_x(p), v.y = n.btVector3_y(p), v.z = n.btVector3_z(p);
                                    var E = n.btManifoldPoint_get_m_positionWorldOnA(f),
                                        g = T.positionOnA;
                                    g.x = -n.btVector3_x(E), g.y = n.btVector3_y(E), g.z = n.btVector3_z(E);
                                    var S = n.btManifoldPoint_get_m_positionWorldOnB(f),
                                        R = T.positionOnB;
                                    R.x = -n.btVector3_x(S), R.y = n.btVector3_y(S), R.z = n.btVector3_z(S), c || (h = (c = this._collisionsUtils.getCollision(l, u)).contacts,
                                        (o = c._updateFrame !== r) && (c._isTrigger = !1, h.length = 0)), h.push(T);
                                }
                    c && o && (this._currentFrameCollisions.push(c), c._setUpdateFrame(r));
                }
            }
        }, {
            key: "_eventScripts",
            value: function() {
                for (var e = t.Stat.loopCount, r = 0, n = this._currentFrameCollisions.length; r < n; r++) {
                    var i = this._currentFrameCollisions[r],
                        a = i._colliderA,
                        o = i._colliderB;
                    if (!a.destroyed && !o.destroyed)
                        if (e - i._lastUpdateFrame == 1) {
                            var s = a.owner,
                                l = s._scripts;
                            if (l)
                                if (i._isTrigger) {
                                    if (s._needProcessTriggers)
                                        for (var u = 0, c = l.length; u < c; u++) l[u].onTriggerStay(o);
                                } else if (s._needProcessCollisions)
                                for (u = 0, c = l.length; u < c; u++) i.other = o,
                                    l[u].onCollisionStay(i);
                            var h = o.owner,
                                _ = h._scripts;
                            if (_)
                                if (i._isTrigger) {
                                    if (h._needProcessTriggers)
                                        for (u = 0, c = _.length; u < c; u++) _[u].onTriggerStay(a);
                                } else if (h._needProcessCollisions)
                                for (u = 0, c = _.length; u < c; u++) i.other = a,
                                    _[u].onCollisionStay(i);
                        } else {
                            if (l = (s = a.owner)._scripts)
                                if (i._isTrigger) {
                                    if (s._needProcessTriggers)
                                        for (u = 0, c = l.length; u < c; u++) l[u].onTriggerEnter(o);
                                } else if (s._needProcessCollisions)
                                for (u = 0, c = l.length; u < c; u++) i.other = o,
                                    l[u].onCollisionEnter(i);
                            if (_ = (h = o.owner)._scripts)
                                if (i._isTrigger) {
                                    if (h._needProcessTriggers)
                                        for (u = 0, c = _.length; u < c; u++) _[u].onTriggerEnter(a);
                                } else if (h._needProcessCollisions)
                                for (u = 0, c = _.length; u < c; u++) i.other = a,
                                    _[u].onCollisionEnter(i);
                        }
                }
                for (r = 0, n = this._previousFrameCollisions.length; r < n; r++) {
                    var d = this._previousFrameCollisions[r],
                        f = d._colliderA,
                        m = d._colliderB;
                    if (!f.destroyed && !m.destroyed && e - d._updateFrame == 1) {
                        if (this._collisionsUtils.recoverCollision(d), l = (s = f.owner)._scripts)
                            if (d._isTrigger) {
                                if (s._needProcessTriggers)
                                    for (u = 0, c = l.length; u < c; u++) l[u].onTriggerExit(m);
                            } else if (s._needProcessCollisions)
                            for (u = 0, c = l.length; u < c; u++) d.other = m,
                                l[u].onCollisionExit(d);
                        if (_ = (h = m.owner)._scripts)
                            if (d._isTrigger) {
                                if (h._needProcessTriggers)
                                    for (u = 0, c = _.length; u < c; u++) _[u].onTriggerExit(f);
                            } else if (h._needProcessCollisions)
                            for (u = 0, c = _.length; u < c; u++) d.other = f,
                                _[u].onCollisionExit(d);
                    }
                }
            }
        }, {
            key: "clearForces",
            value: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
                y._bullet.btDiscreteDynamicsWorld_clearForces(this._btDiscreteDynamicsWorld);
            }
        }, {
            key: "continuousCollisionDetection",
            get: function() {
                return y._bullet.btCollisionWorld_get_m_useContinuous(this._btDispatchInfo);
            },
            set: function(e) {
                y._bullet.btCollisionWorld_set_m_useContinuous(this._btDispatchInfo, e);
            }
        }, {
            key: "gravity",
            get: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                return this._gravity;
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
                this._gravity = e;
                var t = y._bullet,
                    r = PhysicsSimulation._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btDiscreteDynamicsWorld_setGravity(this._btDiscreteDynamicsWorld, r);
            }
        }, {
            key: "speculativeContactRestitution",
            get: function() {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                return y._bullet.btDiscreteDynamicsWorld_getApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld);
            },
            set: function(e) {
                if (!this._btDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
                y._bullet.btDiscreteDynamicsWorld_setApplySpeculativeContactRestitution(this._btDiscreteDynamicsWorld, e);
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = y._bullet;
                PhysicsSimulation._btTempVector30 = e.btVector3_create(0, 0, 0), PhysicsSimulation._btTempVector31 = e.btVector3_create(0, 0, 0),
                    PhysicsSimulation._btTempQuaternion0 = e.btQuaternion_create(0, 0, 0, 1), PhysicsSimulation._btTempQuaternion1 = e.btQuaternion_create(0, 0, 0, 1),
                    PhysicsSimulation._btTempTransform0 = e.btTransform_create(), PhysicsSimulation._btTempTransform1 = e.btTransform_create();
            }
        }, {
            key: "createConstraint",
            value: function() {}
        }]), PhysicsSimulation;
    }();
    Tt.PHYSICSENGINEFLAGS_NONE = 0, Tt.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, Tt.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2,
        Tt.PHYSICSENGINEFLAGS_MULTITHREADED = 4, Tt.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8,
        Tt.SOLVERMODE_RANDMIZE_ORDER = 1, Tt.SOLVERMODE_FRICTION_SEPARATE = 2, Tt.SOLVERMODE_USE_WARMSTARTING = 4,
        Tt.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, Tt.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32,
        Tt.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, Tt.SOLVERMODE_CACHE_FRIENDLY = 128,
        Tt.SOLVERMODE_SIMD = 256, Tt.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
        Tt.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, Tt._tempVector30 = new o(),
        Tt.disableSimulation = !1;
    var pt = function() {
        function Input3D() {
            var e = this;
            _classCallCheck(this, Input3D), this._eventList = [], this._mouseTouch = new pe(),
                this._touchPool = [], this._touches = new ie(), this._multiTouchEnabled = !0, this._pushEventList = function(t) {
                    t.cancelable && t.preventDefault(), e._eventList.push(t);
                }.bind(this);
        }
        return _createClass(Input3D, [{
            key: "__init__",
            value: function(e, t) {
                this._scene = t, e.oncontextmenu = function(e) {
                    return !1;
                };
            }
        }, {
            key: "_onCanvasEvent",
            value: function(e) {
                e.addEventListener("mousedown", this._pushEventList), e.addEventListener("mouseup", this._pushEventList, !0),
                    e.addEventListener("mousemove", this._pushEventList, !0), e.addEventListener("touchstart", this._pushEventList),
                    e.addEventListener("touchend", this._pushEventList, !0), e.addEventListener("touchmove", this._pushEventList, !0),
                    e.addEventListener("touchcancel", this._pushEventList, !0);
            }
        }, {
            key: "_offCanvasEvent",
            value: function(e) {
                e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener("mouseup", this._pushEventList, !0),
                    e.removeEventListener("mousemove", this._pushEventList, !0), e.removeEventListener("touchstart", this._pushEventList),
                    e.removeEventListener("touchend", this._pushEventList, !0), e.removeEventListener("touchmove", this._pushEventList, !0),
                    e.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0,
                    this._touches.clear();
            }
        }, {
            key: "touchCount",
            value: function() {
                return this._touches.length;
            }
        }, {
            key: "_getTouch",
            value: function(e) {
                var t = this._touchPool[e];
                return t || (t = new ve(), this._touchPool[e] = t, t._identifier = e), t;
            }
        }, {
            key: "_mouseTouchDown",
            value: function() {
                var e = this._mouseTouch,
                    r = e.sprite;
                if (e._pressedSprite = r, e._pressedLoopCount = t.Stat.loopCount, r) {
                    var n = r._scripts;
                    if (n)
                        for (var i = 0, a = n.length; i < a; i++) n[i].onMouseDown();
                }
            }
        }, {
            key: "_mouseTouchUp",
            value: function() {
                var e, t, r = this._mouseTouch,
                    n = r._pressedSprite;
                r._pressedSprite = null, r._pressedLoopCount = -1;
                var i = r.sprite;
                if (i && i === n) {
                    var a = i._scripts;
                    if (a)
                        for (e = 0, t = a.length; e < t; e++) a[e].onMouseClick();
                }
                if (n) {
                    var o = n._scripts;
                    if (o)
                        for (e = 0, t = o.length; e < t; e++) o[e].onMouseUp();
                }
            }
        }, {
            key: "_mouseTouchRayCast",
            value: function(t) {
                var r = Input3D._tempHitResult0,
                    n = Input3D._tempVector20,
                    i = Input3D._tempRay0;
                r.succeeded = !1;
                var a = this._mouseTouch.mousePositionX,
                    o = this._mouseTouch.mousePositionY;
                n.x = a, n.y = o;
                for (var s = t.length - 1; s >= 0; s--) {
                    var l = t[s],
                        u = l.viewport;
                    if (n.x >= u.x && n.y >= u.y && n.x <= u.width && n.y <= u.height)
                        if (l.viewportPointToRay(n, i),
                            this._scene._physicsSimulation.rayCast(i, r) || l.clearFlag === e.CameraClearFlags.SolidColor || l.clearFlag === e.CameraClearFlags.Sky) break;
                }
                var c = this._mouseTouch,
                    h = c.sprite;
                if (r.succeeded) {
                    var _ = r.collider.owner;
                    c.sprite = _;
                    var d = _._scripts;
                    if (h !== _ && d)
                        for (var f = 0, m = d.length; f < m; f++) d[f].onMouseEnter();
                } else c.sprite = null;
                if (h && h !== _) {
                    var T = h._scripts;
                    if (T)
                        for (f = 0, m = T.length; f < m; f++) T[f].onMouseOut();
                }
            }
        }, {
            key: "_changeTouches",
            value: function(e, r) {
                for (var n = 0, i = 0, a = this._touches.length, o = 0, s = e.length; o < s; o++) {
                    var l = e[o],
                        u = l.identifier;
                    if (this._multiTouchEnabled || 0 === u) {
                        var c = this._getTouch(u),
                            h = c._position,
                            _ = Input3D._tempPoint;
                        _.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(_);
                        var d = _.x,
                            f = _.y;
                        switch (r) {
                            case 0:
                                this._touches.add(c), n += d, i += f;
                                break;

                            case 1:
                                this._touches.remove(c), n -= d, i -= f;
                                break;

                            case 2:
                                n = d - h.x, i = f - h.y;
                        }
                        h.x = d, h.y = f;
                    }
                }
                var m = this._touches.length;
                0 === m ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * a + n) / m,
                    this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * a + i) / m);
            }
        }, {
            key: "_update",
            value: function() {
                var e, r, n, i, a = y._enablePhysics && !Tt.disableSimulation;
                r = this._eventList.length;
                var o = this._scene._cameraPool;
                if (r > 0) {
                    var s = !1;
                    for (e = 0; e < r; e++) {
                        var l = this._eventList[e];
                        switch (l.type) {
                            case "mousedown":
                                a && this._mouseTouchDown();
                                break;

                            case "mouseup":
                                a && this._mouseTouchUp();
                                break;

                            case "mousemove":
                                var u = Input3D._tempPoint;
                                u.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(u),
                                    this._mouseTouch.mousePositionX = u.x, this._mouseTouch.mousePositionY = u.y, a && (s = !0);
                                break;

                            case "touchstart":
                                var c = this._touches.length;
                                this._changeTouches(l.changedTouches, 0), a && (s = !0, 0 === c && this._mouseTouchDown());
                                break;

                            case "touchend":
                            case "touchcancel":
                                this._changeTouches(l.changedTouches, 1), a && 0 === this._touches.length && this._mouseTouchUp();
                                break;

                            case "touchmove":
                                this._changeTouches(l.changedTouches, 2), a && (s = !0);
                                break;

                            default:
                                throw "Input3D:unkonwn event type.";
                        }
                    }
                    s && this._mouseTouchRayCast(o), this._eventList.length = 0;
                }
                if (a) {
                    var h = this._mouseTouch,
                        _ = h._pressedSprite;
                    if (_ && t.Stat.loopCount > h._pressedLoopCount) {
                        var d = _._scripts;
                        if (d)
                            for (n = 0, i = d.length; n < i; n++) d[n].onMouseDrag();
                    }
                    var f = h.sprite;
                    if (f) {
                        var m = f._scripts;
                        if (m)
                            for (n = 0, i = m.length; n < i; n++) m[n].onMouseOver();
                    }
                }
            }
        }, {
            key: "getTouch",
            value: function(e) {
                return e < this._touches.length ? this._touches.elements[e] : null;
            }
        }, {
            key: "multiTouchEnabled",
            get: function() {
                return this._multiTouchEnabled;
            },
            set: function(e) {
                this._multiTouchEnabled = e;
            }
        }]), Input3D;
    }();
    pt._tempPoint = new t.Point(), pt._tempVector20 = new n(), pt._tempRay0 = new ge(new o(), new o()),
        pt._tempHitResult0 = new tt();
    var vt, Et = function PhysicsSettings() {
            _classCallCheck(this, PhysicsSettings), this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
        },
        gt = function() {
            function VertexPositionTexture0(e, t) {
                _classCallCheck(this, VertexPositionTexture0), this._position = e, this._textureCoordinate0 = t;
            }
            return _createClass(VertexPositionTexture0, [{
                key: "position",
                get: function() {
                    return this._position;
                }
            }, {
                key: "textureCoordinate0",
                get: function() {
                    return this._textureCoordinate0;
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexPositionTexture0._vertexDeclaration;
                }
            }], [{
                key: "__init__",
                value: function() {
                    VertexPositionTexture0._vertexDeclaration = new Oe(20, [new Pe(0, Ie.Vector3, Ne.MESH_POSITION0), new Pe(12, Ie.Vector2, Ne.MESH_TEXTURECOORDINATE0)]);
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexPositionTexture0._vertexDeclaration;
                }
            }]), VertexPositionTexture0;
        }(),
        yt = function(r) {
            function SkyDome() {
                var r, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 48,
                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 48;
                _classCallCheck(this, SkyDome), r = _possibleConstructorReturn(this, _getPrototypeOf(SkyDome).call(this));
                var a = t.LayaGL.instance;
                r._stacks = n, r._slices = i;
                for (var o = gt.vertexDeclaration, s = o.vertexStride / 4, l = (r._stacks + 1) * (r._slices + 1), u = 3 * r._stacks * (r._slices + 1) * 2, c = new Float32Array(l * s), h = new Uint16Array(u), _ = Math.PI / r._stacks, d = 2 * Math.PI / r._slices, f = 0, m = 0, T = 0, p = 0; p < r._stacks + 1; p++)
                    for (var v = Math.sin(p * _), E = Math.cos(p * _), g = 0; g < r._slices + 1; g++) {
                        var y = v * Math.sin(g * d),
                            S = v * Math.cos(g * d);
                        c[m + 0] = y * SkyDome._radius, c[m + 1] = E * SkyDome._radius, c[m + 2] = S * SkyDome._radius,
                            c[m + 3] = -g / r._slices + .75, c[m + 4] = p / r._stacks, m += s, p != r._stacks - 1 && (h[T++] = f + 1,
                                h[T++] = f, h[T++] = f + (r._slices + 1), h[T++] = f + (r._slices + 1), h[T++] = f,
                                h[T++] = f + r._slices, f++);
                    }
                r._vertexBuffer = new be(4 * c.length, a.STATIC_DRAW, !1), r._vertexBuffer.vertexDeclaration = o,
                    r._indexBuffer = new Le(e.IndexFormat.UInt16, h.length, a.STATIC_DRAW, !1), r._vertexBuffer.setData(c.buffer),
                    r._indexBuffer.setData(h);
                var R = new Ae();
                return R.bind(), R.applyVertexBuffer(r._vertexBuffer), R.applyIndexBuffer(r._indexBuffer),
                    R.unBind(), r._bufferState = R, r;
            }
            return _inherits(SkyDome, ke), _createClass(SkyDome, [{
                key: "_render",
                value: function(e) {
                    var r = t.LayaGL.instance,
                        n = this._indexBuffer.indexCount;
                    r.drawElements(r.TRIANGLES, n, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += n / 3,
                        t.Stat.renderBatches++;
                }
            }, {
                key: "stacks",
                get: function() {
                    return this._stacks;
                }
            }, {
                key: "slices",
                get: function() {
                    return this._slices;
                }
            }], [{
                key: "__init__",
                value: function() {
                    SkyDome.instance = new SkyDome();
                }
            }]), SkyDome;
        }();
    yt._radius = 1, (vt = e.TextureCubeFace || (e.TextureCubeFace = {}))[vt.PositiveX = 0] = "PositiveX",
        vt[vt.NegativeX = 1] = "NegativeX", vt[vt.PositiveY = 2] = "PositiveY", vt[vt.NegativeY = 3] = "NegativeY",
        vt[vt.PositiveZ = 4] = "PositiveZ", vt[vt.NegativeZ = 5] = "NegativeZ";
    var St = function(r) {
        function TextureCube(e) {
            var r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : t.TextureFormat.R8G8B8,
                i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            _classCallCheck(this, TextureCube), (r = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this, n, i)))._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP,
                r._width = e, r._height = e;
            var a = t.LayaGL.instance;
            if (r._setWarpMode(a.TEXTURE_WRAP_S, r._wrapModeU), r._setWarpMode(a.TEXTURE_WRAP_T, r._wrapModeV),
                r._setFilterMode(r._filterMode), r._setAnisotropy(r._anisoLevel), r._mipmap) {
                r._mipmapCount = Math.ceil(Math.log2(e)) + 1;
                for (var o = 0; o < r._mipmapCount; o++) r._setPixels([], o, Math.max(e >> o, 1), Math.max(e >> o, 1));
                r._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else r._mipmapCount = 1, r._setGPUMemory(e * e * 4 * 6);
            return r;
        }
        return _inherits(TextureCube, t.BaseTexture), _createClass(TextureCube, [{
            key: "_setPixels",
            value: function(e, r, n, i) {
                var a = t.LayaGL.instance,
                    o = this._getGLFormat();
                t.WebGLContext.bindTexture(a, this._glTextureType, this._glTexture), this.format === t.TextureFormat.R8G8B8 ? (a.pixelStorei(a.UNPACK_ALIGNMENT, 1),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[0]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[2]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[3]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[4]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[5]),
                    a.pixelStorei(a.UNPACK_ALIGNMENT, 4)) : (a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[0]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[1]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[2]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[3]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[4]),
                    a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, o, n, i, 0, o, a.UNSIGNED_BYTE, e[5]));
            }
        }, {
            key: "setSixSideImageSources",
            value: function(e) {
                for (var r, n, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a = 0; a < 6; a++) {
                    var o = e[a];
                    if (!o) return void console.log("TextureCube: image Source can't be null.");
                    var s = o.width,
                        l = o.height;
                    if (a > 0 && r !== s) return void console.log("TextureCube: each side image's width and height must same.");
                    if ((r = s) !== (n = l)) return void console.log("TextureCube: each side image's width and height must same.");
                }
                this._width = r, this._height = n;
                var u = t.LayaGL.instance;
                t.WebGLContext.bindTexture(u, this._glTextureType, this._glTexture);
                var c = this._getGLFormat();
                if (t.Render.isConchApp) {
                    if (1 == i)
                        for (var h = 0; h < 6; h++) e[h].setPremultiplyAlpha(i);
                    u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[0]),
                        u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[1]),
                        u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[2]),
                        u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[3]),
                        u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[4]),
                        u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, e[5]);
                } else i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[0]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c, c, u.UNSIGNED_BYTE, e[1]), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[2]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c, c, u.UNSIGNED_BYTE, e[3]), u.texImage2D(u.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[4]),
                    u.texImage2D(u.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c, c, u.UNSIGNED_BYTE, e[5]), i && u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
                this._mipmap && this._isPot(r) && this._isPot(n) ? (u.generateMipmap(this._glTextureType),
                        this._setGPUMemory(r * n * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(r * n * 4 * 6),
                    this._setWarpMode(u.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(u.TEXTURE_WRAP_T, this._wrapModeV),
                    this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
            }
        }, {
            key: "setSixSidePixels",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!e) throw new Error("TextureCube:pixels can't be null.");
                var n = Math.max(this._width >> r, 1),
                    i = Math.max(this._height >> r, 1),
                    a = n * i * this._getFormatByteCount();
                if (e[0].length < a) throw "TextureCube:pixels length should at least " + a + ".";
                if (this._setPixels(e, r, n, i), 0 === r) {
                    var o = t.LayaGL.instance;
                    this._setWarpMode(o.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(o.TEXTURE_WRAP_T, this._wrapModeV);
                }
                this._readyed = !0, this._activeResource();
            }
        }, {
            key: "setImageSource",
            value: function(r, n) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    a = this._width,
                    o = this._height;
                if (!n || a === n.width && o === n.height) {
                    var s = t.LayaGL.instance;
                    t.WebGLContext.bindTexture(s, this._glTextureType, this._glTexture);
                    var l = this._getGLFormat();
                    switch (r) {
                        case e.TextureCubeFace.NegativeX:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_X, i, l, l, s.UNSIGNED_BYTE, n);
                            break;

                        case e.TextureCubeFace.PositiveX:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X, i, l, l, s.UNSIGNED_BYTE, n);
                            break;

                        case e.TextureCubeFace.NegativeY:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Y, i, l, l, s.UNSIGNED_BYTE, n);
                            break;

                        case e.TextureCubeFace.PositiveY:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Y, i, l, l, s.UNSIGNED_BYTE, n);
                            break;

                        case e.TextureCubeFace.NegativeZ:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_NEGATIVE_Z, i, l, l, s.UNSIGNED_BYTE, n);
                            break;

                        case e.TextureCubeFace.PositiveZ:
                            s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_Z, i, l, l, s.UNSIGNED_BYTE, n);
                    }
                    this._mipmap && this._isPot(a) && this._isPot(o) ? (s.generateMipmap(this._glTextureType),
                            this._setGPUMemory(a * o * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(a * o * 4 * 6),
                        this._setWarpMode(s.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s.TEXTURE_WRAP_T, this._wrapModeV),
                        this._setFilterMode(this._filterMode), this._readyed = !0;
                } else console.log("TextureCube: imageSource's width and height must same.");
            }
        }, {
            key: "defaulteTexture",
            get: function() {
                return TextureCube.grayTexture;
            }
        }], [{
            key: "__init__",
            value: function() {
                var e = new TextureCube(1, t.TextureFormat.R8G8B8, !1),
                    r = new TextureCube(1, t.TextureFormat.R8G8B8, !1),
                    n = new Uint8Array(3);
                n[0] = 0, n[1] = 0, n[2] = 0, e.setSixSidePixels([n, n, n, n, n, n]), e.lock = !0,
                    n[0] = 128, n[1] = 128, n[2] = 128, r.setSixSidePixels([n, n, n, n, n, n]), r.lock = !0,
                    TextureCube._grayTexture = r, TextureCube._blackTexture = e;
            }
        }, {
            key: "_parse",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    r = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
                return r.setSixSideImageSources(e), r;
            }
        }, {
            key: "_parseBin",
            value: function(e) {
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    r = t ? new TextureCube(0, t[0], t[1]) : new TextureCube(0);
                return r.setSixSideImageSources(e), r;
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, TextureCube.TEXTURECUBE);
            }
        }, {
            key: "blackTexture",
            get: function() {
                return TextureCube._blackTexture;
            }
        }, {
            key: "grayTexture",
            get: function() {
                return TextureCube._grayTexture;
            }
        }]), TextureCube;
    }();
    St.TEXTURECUBE = "TEXTURECUBE";
    var Rt = function() {
            function LightQueue() {
                _classCallCheck(this, LightQueue), this._length = 0, this._elements = [];
            }
            return _createClass(LightQueue, [{
                key: "add",
                value: function(e) {
                    this._length === this._elements.length ? this._elements.push(e) : this._elements[this._length] = e,
                        this._length++;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = this._elements.indexOf(e);
                    if (this._length--, t !== this._length) {
                        var r = this._elements[this._length];
                        this._elements[t] = r;
                    }
                }
            }, {
                key: "shift",
                value: function() {
                    return this._length--, this._elements.shift();
                }
            }]), LightQueue;
        }(),
        Ct = function(e) {
            function DirectionLightQueue() {
                return _classCallCheck(this, DirectionLightQueue), _possibleConstructorReturn(this, _getPrototypeOf(DirectionLightQueue).apply(this, arguments));
            }
            return _inherits(DirectionLightQueue, Rt), _createClass(DirectionLightQueue, [{
                key: "getSunLight",
                value: function() {
                    for (var e, t = -1, r = this._elements, n = 0; n < this._length; n++) {
                        var i = r[n]._intensity;
                        t < i && (t = i, e = n);
                    }
                    return e;
                }
            }]), DirectionLightQueue;
        }(),
        Mt = function(e) {
            function AlternateLightQueue() {
                return _classCallCheck(this, AlternateLightQueue), _possibleConstructorReturn(this, _getPrototypeOf(AlternateLightQueue).apply(this, arguments));
            }
            return _inherits(AlternateLightQueue, Rt), _createClass(AlternateLightQueue, [{
                key: "remove",
                value: function(e) {
                    var t = this._elements.indexOf(e);
                    this._elements.splice(t, 1), this._length--;
                }
            }]), AlternateLightQueue;
        }(),
        xt = function(e) {
            function PixelLineMaterial() {
                var e;
                return _classCallCheck(this, PixelLineMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineMaterial).call(this))).setShaderName("LineShader"),
                    e._shaderValues.setVector(PixelLineMaterial.COLOR, new i(1, 1, 1, 1)), e;
            }
            return _inherits(PixelLineMaterial, j), _createClass(PixelLineMaterial, [{
                key: "clone",
                value: function() {
                    var e = new PixelLineMaterial();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "color",
                get: function() {
                    return this._shaderValues.getVector(PixelLineMaterial.COLOR);
                },
                set: function(e) {
                    this._shaderValues.setVector(PixelLineMaterial.COLOR, e);
                }
            }, {
                key: "depthWrite",
                set: function(e) {
                    this._shaderValues.setBool(PixelLineMaterial.DEPTH_WRITE, e);
                },
                get: function() {
                    return this._shaderValues.getBool(PixelLineMaterial.DEPTH_WRITE);
                }
            }, {
                key: "cull",
                set: function(e) {
                    this._shaderValues.setInt(PixelLineMaterial.CULL, e);
                },
                get: function() {
                    return this._shaderValues.getInt(PixelLineMaterial.CULL);
                }
            }, {
                key: "blend",
                set: function(e) {
                    this._shaderValues.setInt(PixelLineMaterial.BLEND, e);
                },
                get: function() {
                    return this._shaderValues.getInt(PixelLineMaterial.BLEND);
                }
            }, {
                key: "blendSrc",
                set: function(e) {
                    this._shaderValues.setInt(PixelLineMaterial.BLEND_SRC, e);
                },
                get: function() {
                    return this._shaderValues.getInt(PixelLineMaterial.BLEND_SRC);
                }
            }, {
                key: "blendDst",
                set: function(e) {
                    this._shaderValues.setInt(PixelLineMaterial.BLEND_DST, e);
                },
                get: function() {
                    return this._shaderValues.getInt(PixelLineMaterial.BLEND_DST);
                }
            }, {
                key: "depthTest",
                set: function(e) {
                    this._shaderValues.setInt(PixelLineMaterial.DEPTH_TEST, e);
                },
                get: function() {
                    return this._shaderValues.getInt(PixelLineMaterial.DEPTH_TEST);
                }
            }], [{
                key: "__initDefine__",
                value: function() {}
            }]), PixelLineMaterial;
        }();
    xt.COLOR = G.propertyNameToID("u_Color"), xt.CULL = G.propertyNameToID("s_Cull"),
        xt.BLEND = G.propertyNameToID("s_Blend"), xt.BLEND_SRC = G.propertyNameToID("s_BlendSrc"),
        xt.BLEND_DST = G.propertyNameToID("s_BlendDst"), xt.DEPTH_TEST = G.propertyNameToID("s_DepthTest"),
        xt.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var Dt = function() {
        function BoundBox(e, t) {
            _classCallCheck(this, BoundBox), this.min = e, this.max = t;
        }
        return _createClass(BoundBox, [{
            key: "_rotateExtents",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.elements;
                r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a), r.y = Math.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a),
                    r.z = Math.abs(o[2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "getCorners",
            value: function(e) {
                e.length = 8;
                var t = this.min.x,
                    r = this.min.y,
                    n = this.min.z,
                    i = this.max.x,
                    a = this.max.y,
                    s = this.max.z;
                e[0] = new o(t, a, s), e[1] = new o(i, a, s), e[2] = new o(i, r, s), e[3] = new o(t, r, s),
                    e[4] = new o(t, a, n), e[5] = new o(i, a, n), e[6] = new o(i, r, n), e[7] = new o(t, r, n);
            }
        }, {
            key: "getCenter",
            value: function(e) {
                o.add(this.min, this.max, e), o.scale(e, .5, e);
            }
        }, {
            key: "getExtent",
            value: function(e) {
                o.subtract(this.max, this.min, e), o.scale(e, .5, e);
            }
        }, {
            key: "setCenterAndExtent",
            value: function(e, t) {
                o.subtract(e, t, this.min), o.add(e, t, this.max);
            }
        }, {
            key: "tranform",
            value: function(e, t) {
                var r = BoundBox._tempVector30,
                    n = BoundBox._tempVector31;
                this.getCenter(r), this.getExtent(n), o.transformCoordinate(r, e, r), this._rotateExtents(n, e, n),
                    t.setCenterAndExtent(r, n);
            }
        }, {
            key: "toDefault",
            value: function() {
                this.min.toDefault(), this.max.toDefault();
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.min.cloneTo(t.min), this.max.cloneTo(t.max);
            }
        }, {
            key: "clone",
            value: function() {
                var e = new BoundBox(new o(), new o());
                return this.cloneTo(e), e;
            }
        }], [{
            key: "createfromPoints",
            value: function(e, t) {
                if (null == e) throw new Error("points");
                var r = t.min,
                    n = t.max;
                r.x = Number.MAX_VALUE, r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, n.x = -Number.MAX_VALUE,
                    n.y = -Number.MAX_VALUE, n.z = -Number.MAX_VALUE;
                for (var i = 0, a = e.length; i < a; ++i) o.min(r, e[i], r), o.max(n, e[i], n);
            }
        }, {
            key: "merge",
            value: function(e, t, r) {
                o.min(e.min, t.min, r.min), o.max(e.max, t.max, r.max);
            }
        }]), BoundBox;
    }();
    Dt._tempVector30 = new o(), Dt._tempVector31 = new o();
    var At = function() {
        function Bounds(e, t) {
            _classCallCheck(this, Bounds), this._updateFlag = 0, this._center = new o(), this._extent = new o(),
                this._boundBox = new Dt(new o(), new o()), e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max),
                this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0);
        }
        return _createClass(Bounds, [{
            key: "setMin",
            value: function(e) {
                var t = this._boundBox.min;
                e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0),
                    this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
            }
        }, {
            key: "getMin",
            value: function() {
                var e = this._boundBox.min;
                return this._getUpdateFlag(Bounds._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e),
                    this._setUpdateFlag(Bounds._UPDATE_MIN, !1)), e;
            }
        }, {
            key: "setMax",
            value: function(e) {
                var t = this._boundBox.max;
                e !== t && e.cloneTo(t), this._setUpdateFlag(Bounds._UPDATE_CENTER | Bounds._UPDATE_EXTENT, !0),
                    this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
            }
        }, {
            key: "getMax",
            value: function() {
                var e = this._boundBox.max;
                return this._getUpdateFlag(Bounds._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e),
                    this._setUpdateFlag(Bounds._UPDATE_MAX, !1)), e;
            }
        }, {
            key: "setCenter",
            value: function(e) {
                e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0),
                    this._setUpdateFlag(Bounds._UPDATE_CENTER, !1);
            }
        }, {
            key: "getCenter",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center),
                    this._setUpdateFlag(Bounds._UPDATE_CENTER, !1)), this._center;
            }
        }, {
            key: "setExtent",
            value: function(e) {
                e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(Bounds._UPDATE_MIN | Bounds._UPDATE_MAX, !0),
                    this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1);
            }
        }, {
            key: "getExtent",
            value: function() {
                return this._getUpdateFlag(Bounds._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent),
                    this._setUpdateFlag(Bounds._UPDATE_EXTENT, !1)), this._extent;
            }
        }, {
            key: "_getUpdateFlag",
            value: function(e) {
                return 0 != (this._updateFlag & e);
            }
        }, {
            key: "_setUpdateFlag",
            value: function(e, t) {
                t ? this._updateFlag |= e : this._updateFlag &= ~e;
            }
        }, {
            key: "_getCenter",
            value: function(e, t, r) {
                o.add(e, t, r), o.scale(r, .5, r);
            }
        }, {
            key: "_getExtent",
            value: function(e, t, r) {
                o.subtract(t, e, r), o.scale(r, .5, r);
            }
        }, {
            key: "_getMin",
            value: function(e, t, r) {
                o.subtract(e, t, r);
            }
        }, {
            key: "_getMax",
            value: function(e, t, r) {
                o.add(e, t, r);
            }
        }, {
            key: "_rotateExtents",
            value: function(e, t, r) {
                var n = e.x,
                    i = e.y,
                    a = e.z,
                    o = t.elements;
                r.x = Math.abs(o[0] * n) + Math.abs(o[4] * i) + Math.abs(o[8] * a), r.y = Math.abs(o[1] * n) + Math.abs(o[5] * i) + Math.abs(o[9] * a),
                    r.z = Math.abs(o[2] * n) + Math.abs(o[6] * i) + Math.abs(o[10] * a);
            }
        }, {
            key: "_tranform",
            value: function(e, t) {
                var r = t._center,
                    n = t._extent;
                o.transformCoordinate(this.getCenter(), e, r), this._rotateExtents(this.getExtent(), e, n),
                    t._boundBox.setCenterAndExtent(r, n), t._updateFlag = 0;
            }
        }, {
            key: "_getBoundBox",
            value: function() {
                if (this._updateFlag & Bounds._UPDATE_MIN) {
                    var e = this._boundBox.min;
                    this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(Bounds._UPDATE_MIN, !1);
                }
                if (this._updateFlag & Bounds._UPDATE_MAX) {
                    var t = this._boundBox.max;
                    this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(Bounds._UPDATE_MAX, !1);
                }
                return this._boundBox;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max),
                    this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new Bounds(new o(), new o());
                return this.cloneTo(e), e;
            }
        }]), Bounds;
    }();
    At._UPDATE_MIN = 1, At._UPDATE_MAX = 2, At._UPDATE_CENTER = 4, At._UPDATE_EXTENT = 8;
    var Lt = function() {
        function GeometryElement() {
            _classCallCheck(this, GeometryElement), this._destroyed = !1;
        }
        return _createClass(GeometryElement, [{
            key: "_getType",
            value: function() {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                throw "GeometryElement:must override it.";
            }
        }, {
            key: "destroy",
            value: function() {
                this._destroyed || (this._destroyed = !0);
            }
        }, {
            key: "destroyed",
            get: function() {
                return this._destroyed;
            }
        }]), GeometryElement;
    }();
    Lt._typeCounter = 0;
    var It = function() {
            function PixelLineVertex() {
                _classCallCheck(this, PixelLineVertex);
            }
            return _createClass(PixelLineVertex, [{
                key: "vertexDeclaration",
                get: function() {
                    return PixelLineVertex._vertexDeclaration;
                }
            }], [{
                key: "__init__",
                value: function() {
                    PixelLineVertex._vertexDeclaration = new Oe(28, [new Pe(0, Ie.Vector3, Ne.MESH_POSITION0), new Pe(12, Ie.Vector4, Ne.MESH_COLOR0)]);
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return PixelLineVertex._vertexDeclaration;
                }
            }]), PixelLineVertex;
        }(),
        Ot = function(e) {
            function PixelLineFilter(e, r) {
                var n;
                _classCallCheck(this, PixelLineFilter), (n = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineFilter).call(this)))._floatCountPerVertices = 7,
                    n._minUpdate = Number.MAX_VALUE, n._maxUpdate = Number.MIN_VALUE, n._bufferState = new Ae(),
                    n._floatBound = new Float32Array(6), n._calculateBound = !1, n._maxLineCount = 0,
                    n._lineCount = 0;
                var i = 2 * r;
                n._owner = e, n._maxLineCount = r, n._vertices = new Float32Array(i * n._floatCountPerVertices),
                    n._vertexBuffer = new be(It.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !1),
                    n._vertexBuffer.vertexDeclaration = It.vertexDeclaration, n._bufferState.bind(),
                    n._bufferState.applyVertexBuffer(n._vertexBuffer), n._bufferState.unBind();
                var a = PixelLineFilter._tempVector0,
                    o = PixelLineFilter._tempVector1;
                return a.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), o.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
                    n._bounds = new At(a, o), n;
            }
            return _inherits(PixelLineFilter, Lt), _createClass(PixelLineFilter, [{
                key: "_getType",
                value: function() {
                    return PixelLineFilter._type;
                }
            }, {
                key: "_resizeLineData",
                value: function(e) {
                    var r = 2 * e,
                        n = this._vertices;
                    this._vertexBuffer.destroy(), this._maxLineCount = e;
                    var i = r * this._floatCountPerVertices;
                    this._vertices = new Float32Array(i), this._vertexBuffer = new be(It.vertexDeclaration.vertexStride * r, t.LayaGL.instance.STATIC_DRAW, !1),
                        this._vertexBuffer.vertexDeclaration = It.vertexDeclaration, i < n.length ? (this._vertices.set(new Float32Array(n.buffer, 0, i)),
                            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i)) : (this._vertices.set(n),
                            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * n.length)), this._bufferState.bind(),
                        this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
                }
            }, {
                key: "_updateLineVertices",
                value: function(e, t, r, n, i) {
                    t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z),
                        n && (this._vertices[e + 3] = n.r, this._vertices[e + 4] = n.g, this._vertices[e + 5] = n.b,
                            this._vertices[e + 6] = n.a), r && (this._vertices[e + 7] = r.x, this._vertices[e + 8] = r.y,
                            this._vertices[e + 9] = r.z), i && (this._vertices[e + 10] = i.r, this._vertices[e + 11] = i.g,
                            this._vertices[e + 12] = i.b, this._vertices[e + 13] = i.a), this._minUpdate = Math.min(this._minUpdate, e),
                        this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
                    var a = this._bounds,
                        s = this._floatBound,
                        l = a.getMin(),
                        u = a.getMax();
                    o.min(l, t, l), o.min(l, r, l), o.max(u, t, u), o.max(u, r, u), a.setMin(l), a.setMax(u),
                        s[0] = l.x, s[1] = l.y, s[2] = l.z, s[3] = u.x, s[4] = u.y, s[5] = u.z;
                }
            }, {
                key: "_reCalculateBound",
                value: function() {
                    if (this._calculateBound) {
                        var e = this._vertices,
                            t = PixelLineFilter._tempVector0,
                            r = PixelLineFilter._tempVector1;
                        t.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), r.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                        for (var n = 0; n < 2 * this._lineCount; ++n) {
                            var i = this._floatCountPerVertices * n,
                                a = e[i + 0],
                                o = e[i + 1],
                                s = e[i + 2];
                            t.x = Math.min(a, t.x), t.y = Math.min(o, t.y), t.z = Math.min(s, t.z), r.x = Math.max(a, r.x),
                                r.y = Math.max(o, r.y), r.z = Math.max(s, r.z);
                        }
                        this._bounds.setMin(t), this._bounds.setMax(r);
                        var l = this._floatBound;
                        l[0] = t.x, l[1] = t.y, l[2] = t.z, l[3] = r.x, l[4] = r.y, l[5] = r.z, this._calculateBound = !1;
                    }
                }
            }, {
                key: "_removeLineData",
                value: function(e) {
                    var t = 2 * this._floatCountPerVertices,
                        r = e + 1,
                        n = e * t,
                        i = this._vertices,
                        a = new Float32Array(i.buffer, r * t * 4, (this._lineCount - r) * t);
                    i.set(a, n), this._minUpdate = Math.min(this._minUpdate, n), this._maxUpdate = Math.max(this._maxUpdate, n + a.length),
                        this._lineCount--;
                    var o = this._floatBound,
                        s = i[n],
                        l = i[n + 1],
                        u = i[n + 2],
                        c = i[n + 7],
                        h = i[n + 8],
                        _ = i[n + 9],
                        d = o[0],
                        f = o[1],
                        m = o[2],
                        T = o[3],
                        p = o[4],
                        v = o[5];
                    s !== d && s !== T && l !== f && l !== p && u !== m && u !== v && c !== d && c !== T && h !== f && h !== p && _ !== m && _ !== v || (this._calculateBound = !0);
                }
            }, {
                key: "_updateLineData",
                value: function(e, t, r, n, i) {
                    var a = 2 * this._floatCountPerVertices;
                    this._updateLineVertices(e * a, t, r, n, i);
                }
            }, {
                key: "_updateLineDatas",
                value: function(e, t) {
                    for (var r = 2 * this._floatCountPerVertices, n = t.length, i = 0; i < n; i++) {
                        var a = t[i];
                        this._updateLineVertices((e + i) * r, a.startPosition, a.endPosition, a.startColor, a.endColor);
                    }
                }
            }, {
                key: "_getLineData",
                value: function(e, t) {
                    var r = t.startPosition,
                        n = t.startColor,
                        i = t.endPosition,
                        a = t.endColor,
                        o = this._vertices,
                        s = e * this._floatCountPerVertices * 2;
                    r.x = o[s + 0], r.y = o[s + 1], r.z = o[s + 2], n.r = o[s + 3], n.g = o[s + 4],
                        n.b = o[s + 5], n.a = o[s + 6], i.x = o[s + 7], i.y = o[s + 8], i.z = o[s + 9],
                        a.r = o[s + 10], a.g = o[s + 11], a.b = o[s + 12], a.a = o[s + 13];
                }
            }, {
                key: "_prepareRender",
                value: function(e) {
                    return !0;
                }
            }, {
                key: "_render",
                value: function(e) {
                    if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)),
                            this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                        this._bufferState.bind();
                        var r = t.LayaGL.instance;
                        r.drawArrays(r.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++;
                    }
                }
            }, {
                key: "destroy",
                value: function() {
                    this._destroyed || (_get(_getPrototypeOf(PixelLineFilter.prototype), "destroy", this).call(this),
                        this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferState = null,
                        this._vertexBuffer = null, this._vertices = null);
                }
            }]), PixelLineFilter;
        }();
    Ot._tempVector0 = new o(), Ot._tempVector1 = new o(), Ot._type = Lt._typeCounter++;
    var Pt = function BatchMark() {
            _classCallCheck(this, BatchMark), this.updateMark = -1, this.indexInList = -1, this.batched = !1;
        },
        Nt = function(e) {
            function SubMeshInstanceBatch() {
                var e;
                _classCallCheck(this, SubMeshInstanceBatch), (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshInstanceBatch).call(this))).maxInstanceCount = 1024,
                    e.instanceWorldMatrixData = new Float32Array(16 * e.maxInstanceCount), e.instanceMVPMatrixData = new Float32Array(16 * e.maxInstanceCount);
                var r = t.LayaGL.instance;
                return e.instanceWorldMatrixBuffer = new be(4 * e.instanceWorldMatrixData.length, r.DYNAMIC_DRAW),
                    e.instanceMVPMatrixBuffer = new be(4 * e.instanceMVPMatrixData.length, r.DYNAMIC_DRAW),
                    e.instanceWorldMatrixBuffer.vertexDeclaration = Ne.instanceWorldMatrixDeclaration,
                    e.instanceMVPMatrixBuffer.vertexDeclaration = Ne.instanceMVPMatrixDeclaration, e;
            }
            return _inherits(SubMeshInstanceBatch, Lt), _createClass(SubMeshInstanceBatch, [{
                key: "_render",
                value: function(e) {
                    var r = t.LayaGL.instance,
                        n = e.renderElement,
                        i = n.instanceSubMesh,
                        a = n.instanceBatchElementList.length,
                        o = i._indexCount;
                    i._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance.drawElementsInstanced(r.TRIANGLES, o, r.UNSIGNED_SHORT, 2 * i._indexStart, a),
                        t.Stat.renderBatches++, t.Stat.savedRenderBatches += a - 1, t.Stat.trianglesFaces += o * a / 3;
                }
            }], [{
                key: "__init__",
                value: function() {
                    SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
                }
            }]), SubMeshInstanceBatch;
        }(),
        bt = function() {
            function RenderElement() {
                _classCallCheck(this, RenderElement), this.renderSubShader = null, this.renderType = RenderElement.RENDERTYPE_NORMAL;
            }
            return _createClass(RenderElement, [{
                key: "getInvertFront",
                value: function() {
                    return this._transform._isFrontFaceInvert;
                }
            }, {
                key: "setTransform",
                value: function(e) {
                    this._transform = e;
                }
            }, {
                key: "setGeometry",
                value: function(e) {
                    this._geometry = e;
                }
            }, {
                key: "addToOpaqueRenderQueue",
                value: function(e, t) {
                    t.elements.add(this);
                }
            }, {
                key: "addToTransparentRenderQueue",
                value: function(e, t) {
                    t.elements.add(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
                }
            }, {
                key: "_update",
                value: function(e, t, r, n) {
                    if (this.material) {
                        var i = this.material._shader.getSubShaderAt(0);
                        if (this.renderSubShader = null, r)
                            if (n) {
                                var a = i.getFlag(n);
                                if (!a) return;
                                for (var o = r._subShaders, s = 0, l = o.length; s < l; s++) {
                                    var u = o[s];
                                    if (a === u.getFlag(n)) {
                                        this.renderSubShader = u;
                                        break;
                                    }
                                }
                                if (!this.renderSubShader) return;
                            } else this.renderSubShader = r.getSubShaderAt(0);
                        else this.renderSubShader = i;
                        var c = e._getRenderQueue(this.material.renderQueue);
                        c.isTransparent ? this.addToTransparentRenderQueue(t, c) : this.addToOpaqueRenderQueue(t, c);
                    }
                }
            }, {
                key: "_render",
                value: function(e) {
                    var t, r, n, i = e.invertY,
                        a = et._updateMark,
                        o = e.scene,
                        s = e.cameraShaderValue,
                        l = this._transform,
                        u = this._geometry;
                    e.renderElement = this;
                    var c = a !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
                    c ? (this.render._renderUpdate(e, l), this.render._renderUpdateWithCamera(e, l),
                        this.render._updateMark = a, this.render._updateRenderType = this.renderType) : this.renderType == RenderElement.RENDERTYPE_INSTANCEBATCH && (this.render._renderUpdate(e, l),
                        this.render._renderUpdateWithCamera(e, l));
                    var h = e.pipelineMode;
                    if (u._prepareRender(e))
                        for (var _ = this.renderSubShader._passes, d = 0, f = _.length; d < f; d++) {
                            var m = _[d];
                            if (m._pipelineMode === h) {
                                var T = RenderElement._compileDefine;
                                o._shaderValues._defineDatas.cloneTo(T), T.addDefineDatas(this.render._shaderValues._defineDatas),
                                    T.addDefineDatas(this.material._shaderValues._defineDatas);
                                var p = e.shader = m.withCompile(T),
                                    v = p.bind(),
                                    E = a !== p._uploadMark,
                                    g = p._uploadScene !== o || E;
                                (g || v) && (p.uploadUniforms(p._sceneUniformParamsMap, o._shaderValues, g), p._uploadScene = o);
                                var y = p._uploadRender !== this.render || p._uploadRenderType !== this.renderType || E;
                                (y || v) && (p.uploadUniforms(p._spriteUniformParamsMap, this.render._shaderValues, y),
                                    p._uploadRender = this.render, p._uploadRenderType = this.renderType);
                                var S = p._uploadCameraShaderValue !== s || E;
                                (S || v) && (p.uploadUniforms(p._cameraUniformParamsMap, s, S), p._uploadCameraShaderValue = s);
                                var R = p._uploadMaterial !== this.material || E;
                                (R || v) && (p.uploadUniforms(p._materialUniformParamsMap, this.material._shaderValues, R),
                                    p._uploadMaterial = this.material);
                                var C = this.material._shaderValues;
                                t !== this.material || r !== p ? (p.uploadRenderStateBlendDepth(C), p.uploadRenderStateFrontFace(C, i, this.getInvertFront()),
                                    t = this.material, r = p, n = this.render) : n !== this.render && (p.uploadRenderStateFrontFace(C, i, this.getInvertFront()),
                                    n = this.render), u._render(e), p._uploadMark = a;
                            }
                        }
                    c && this.renderType !== RenderElement.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e);
                }
            }, {
                key: "destroy",
                value: function() {
                    this._transform = null, this._geometry = null, this.material = null, this.render = null;
                }
            }]), RenderElement;
        }();
    bt.RENDERTYPE_NORMAL = 0, bt.RENDERTYPE_STATICBATCH = 1, bt.RENDERTYPE_INSTANCEBATCH = 2,
        bt.RENDERTYPE_VERTEXBATCH = 3, bt._compileDefine = new B();
    var kt = function(e) {
            function SubMeshRenderElement() {
                var e;
                return _classCallCheck(this, SubMeshRenderElement), (e = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshRenderElement).call(this)))._dynamicWorldPositionNormalNeedUpdate = !0,
                    e;
            }
            return _inherits(SubMeshRenderElement, bt), _createClass(SubMeshRenderElement, [{
                key: "_onWorldMatrixChanged",
                value: function() {
                    this._dynamicWorldPositionNormalNeedUpdate = !0;
                }
            }, {
                key: "_computeWorldPositionsAndNormals",
                value: function(e, t, r, n) {
                    if (this._dynamicWorldPositionNormalNeedUpdate) {
                        for (var i = this._geometry, a = i._vertexBuffer, o = a.vertexDeclaration.vertexStride / 4, s = a.getFloat32Data(), l = this._transform.worldMatrix, u = this._transform.rotation, c = i._indices, h = 0; h < n; h++) {
                            var _ = (r ? c[h] : h) * o,
                                d = 3 * h;
                            R.transformVector3ArrayToVector3ArrayCoordinate(s, _ + e, l, this._dynamicWorldPositions, d), -1 !== t && R.transformVector3ArrayByQuat(s, _ + t, u, this._dynamicWorldNormals, d);
                        }
                        this._dynamicWorldPositionNormalNeedUpdate = !1;
                    }
                }
            }, {
                key: "setTransform",
                value: function(e) {
                    this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged),
                        e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0,
                        this._transform = e);
                }
            }, {
                key: "setGeometry",
                value: function(e) {
                    if (this._geometry !== e) {
                        var t = e,
                            r = t._mesh;
                        if (r) {
                            var n = r._subMeshes.length > 1,
                                i = n ? t._indexCount : r._vertexCount;
                            if (i <= l.SubMeshDynamicBatch.maxAllowVertexCount) {
                                var a = 3 * i;
                                this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(a),
                                    this._dynamicWorldNormals = new Float32Array(a), this._dynamicVertexCount = i, this._dynamicMultiSubMesh = n;
                            } else this._dynamicVertexBatch = !1;
                        }
                        this._geometry = e;
                    }
                }
            }, {
                key: "addToOpaqueRenderQueue",
                value: function(e, r) {
                    var n = this.staticBatch,
                        i = r.elements,
                        a = i.elements;
                    if (n) {
                        var o = l.MeshRenderStaticBatchManager.instance,
                            s = o.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, n._batchID);
                        if (o._updateCountMark === s.updateMark) {
                            var u = s.indexInList;
                            if (s.batched) a[u].staticBatchElementList.add(this);
                            else {
                                var c = a[u],
                                    h = c.render,
                                    _ = o._getBatchRenderElementFromPool();
                                _.renderType = bt.RENDERTYPE_STATICBATCH, _.setGeometry(n), _.material = c.material;
                                var d = n.batchOwner,
                                    f = d ? d._transform : null;
                                _.setTransform(f), _.render = h, _.renderSubShader = c.renderSubShader;
                                var m = _.staticBatchElementList;
                                m.length = 0, m.add(c), m.add(this), a[u] = _, s.batched = !0;
                            }
                        } else s.updateMark = o._updateCountMark, s.indexInList = i.length, s.batched = !1,
                            i.add(this);
                    } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                        var T = this._geometry,
                            p = l.MeshRenderDynamicBatchManager.instance,
                            v = p.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, T._id, this._transform._isFrontFaceInvert);
                        if (p._updateCountMark === v.updateMark) {
                            var E = v.indexInList;
                            if (v.batched) {
                                var g = a[E].instanceBatchElementList;
                                g.length === Nt.instance.maxInstanceCount ? (v.updateMark = p._updateCountMark,
                                    v.indexInList = i.length, v.batched = !1, i.add(this)) : g.add(this);
                            } else {
                                var y = a[E],
                                    S = y.render,
                                    R = p._getBatchRenderElementFromPool();
                                R.renderType = bt.RENDERTYPE_INSTANCEBATCH, R.setGeometry(Nt.instance), R.material = y.material,
                                    R.setTransform(null), R.render = S, R.instanceSubMesh = T, R.renderSubShader = y.renderSubShader;
                                var C = R.instanceBatchElementList;
                                C.length = 0, C.add(y), C.add(this), a[E] = R, v.batched = !0;
                            }
                        } else v.updateMark = p._updateCountMark, v.indexInList = i.length, v.batched = !1,
                            i.add(this);
                    } else if (this._dynamicVertexBatch) {
                        var M = this._geometry._vertexBuffer.vertexDeclaration,
                            x = l.MeshRenderDynamicBatchManager.instance,
                            D = x.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, M.id);
                        if (x._updateCountMark === D.updateMark) {
                            var A = D.indexInList;
                            if (D.batched) a[A].vertexBatchElementList.add(this);
                            else {
                                var L = a[A],
                                    I = L.render,
                                    O = x._getBatchRenderElementFromPool();
                                O.renderType = bt.RENDERTYPE_VERTEXBATCH, O.setGeometry(l.SubMeshDynamicBatch.instance),
                                    O.material = L.material, O.setTransform(null), O.render = I, O.vertexBatchVertexDeclaration = M,
                                    O.renderSubShader = L.renderSubShader;
                                var P = O.vertexBatchElementList;
                                P.length = 0, P.add(L), P.add(this), a[A] = O, D.batched = !0;
                            }
                        } else D.updateMark = x._updateCountMark, D.indexInList = i.length, D.batched = !1,
                            i.add(this);
                    } else i.add(this);
                }
            }, {
                key: "addToTransparentRenderQueue",
                value: function(e, r) {
                    var n = this.staticBatch,
                        i = r.elements,
                        a = i.elements;
                    if (n) {
                        var o = l.MeshRenderStaticBatchManager.instance,
                            s = r.lastTransparentRenderElement;
                        if (s) {
                            var u = s.render;
                            if (s._geometry._getType() !== this._geometry._getType() || s.staticBatch !== n || s.material !== this.material || u.receiveShadow !== this.render.receiveShadow || u.lightmapIndex !== this.render.lightmapIndex) i.add(this),
                                r.lastTransparentBatched = !1;
                            else {
                                if (r.lastTransparentBatched) a[i.length - 1].staticBatchElementList.add(this);
                                else {
                                    var c = o._getBatchRenderElementFromPool();
                                    c.renderType = bt.RENDERTYPE_STATICBATCH, c.setGeometry(n), c.material = s.material;
                                    var h = n.batchOwner,
                                        _ = h ? h._transform : null;
                                    c.setTransform(_), c.render = this.render, c.renderSubShader = s.renderSubShader;
                                    var d = c.staticBatchElementList;
                                    d.length = 0, d.add(s), d.add(this), a[i.length - 1] = c;
                                }
                                r.lastTransparentBatched = !0;
                            }
                        } else i.add(this), r.lastTransparentBatched = !1;
                    } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                        var f = this._geometry,
                            m = l.MeshRenderDynamicBatchManager.instance,
                            T = r.lastTransparentRenderElement;
                        if (T) {
                            var p = T.render;
                            if (T._geometry._getType() !== this._geometry._getType() || T._geometry !== f || T.material !== this.material || p.receiveShadow !== this.render.receiveShadow) i.add(this),
                                r.lastTransparentBatched = !1;
                            else if (r.lastTransparentBatched) {
                                var v = a[i.length - 1].instanceBatchElementList;
                                v.length === Nt.instance.maxInstanceCount ? (i.add(this), r.lastTransparentBatched = !1) : (v.add(this),
                                    r.lastTransparentBatched = !0);
                            } else {
                                var E = m._getBatchRenderElementFromPool();
                                E.renderType = bt.RENDERTYPE_INSTANCEBATCH, E.setGeometry(Nt.instance), E.material = T.material,
                                    E.setTransform(null), E.render = this.render, E.instanceSubMesh = f, E.renderSubShader = T.renderSubShader;
                                var g = E.instanceBatchElementList;
                                g.length = 0, g.add(T), g.add(this), a[i.length - 1] = E, r.lastTransparentBatched = !0;
                            }
                        } else i.add(this), r.lastTransparentBatched = !1;
                    } else if (this._dynamicVertexBatch) {
                        var y = this._geometry._vertexBuffer.vertexDeclaration,
                            S = l.MeshRenderDynamicBatchManager.instance,
                            R = r.lastTransparentRenderElement;
                        if (R) {
                            var C = R.render;
                            if (R._geometry._getType() !== this._geometry._getType() || R._geometry._vertexBuffer._vertexDeclaration !== y || R.material !== this.material || C.receiveShadow !== this.render.receiveShadow || C.lightmapIndex !== this.render.lightmapIndex) i.add(this),
                                r.lastTransparentBatched = !1;
                            else {
                                if (r.lastTransparentBatched) a[i.length - 1].vertexBatchElementList.add(this);
                                else {
                                    var M = S._getBatchRenderElementFromPool();
                                    M.renderType = bt.RENDERTYPE_VERTEXBATCH, M.setGeometry(l.SubMeshDynamicBatch.instance),
                                        M.material = R.material, M.setTransform(null), M.render = this.render, M.vertexBatchVertexDeclaration = y,
                                        M.renderSubShader = R.renderSubShader;
                                    var x = M.vertexBatchElementList;
                                    x.length = 0, x.add(R), x.add(this), a[i.length - 1] = M;
                                }
                                r.lastTransparentBatched = !0;
                            }
                        } else i.add(this), r.lastTransparentBatched = !1;
                    } else i.add(this);
                    r.lastTransparentRenderElement = this;
                }
            }, {
                key: "getInvertFront",
                value: function() {
                    switch (this.renderType) {
                        case bt.RENDERTYPE_NORMAL:
                            return this._transform._isFrontFaceInvert;

                        case bt.RENDERTYPE_STATICBATCH:
                        case bt.RENDERTYPE_VERTEXBATCH:
                            return !1;

                        case bt.RENDERTYPE_INSTANCEBATCH:
                            return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;

                        default:
                            throw "SubMeshRenderElement: unknown renderType";
                    }
                }
            }, {
                key: "destroy",
                value: function() {
                    _get(_getPrototypeOf(SubMeshRenderElement.prototype), "destroy", this).call(this),
                        this._dynamicWorldPositions = null, this._dynamicWorldNormals = null, this.staticBatch = null,
                        this.staticBatchElementList = null, this.vertexBatchElementList = null, this.vertexBatchVertexDeclaration = null;
                }
            }]), SubMeshRenderElement;
        }(),
        Vt = function(r) {
            function SubMeshStaticBatch(e, t) {
                var r;
                return _classCallCheck(this, SubMeshStaticBatch), (r = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshStaticBatch).call(this)))._bufferState = new Ae(),
                    r._batchID = SubMeshStaticBatch._batchIDCounter++, r._batchElements = [], r._currentBatchVertexCount = 0,
                    r._currentBatchIndexCount = 0, r._vertexDeclaration = t, r.batchOwner = e, r;
            }
            return _inherits(SubMeshStaticBatch, Lt), _createClass(SubMeshStaticBatch, [{
                key: "_getStaticBatchBakedVertexs",
                value: function(e, t, r, n, i, a) {
                    var o, s = a._vertexBuffer,
                        l = s.vertexDeclaration,
                        u = l.getVertexElementByUsage(Ne.MESH_POSITION0)._offset / 4,
                        c = l.getVertexElementByUsage(Ne.MESH_NORMAL0),
                        h = c ? c._offset / 4 : -1,
                        _ = l.getVertexElementByUsage(Ne.MESH_COLOR0),
                        d = _ ? _._offset / 4 : -1,
                        f = l.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0),
                        m = f ? f._offset / 4 : -1,
                        T = l.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE1),
                        p = T ? T._offset / 4 : -1,
                        v = l.getVertexElementByUsage(Ne.MESH_TANGENT0),
                        E = v ? v._offset / 4 : -1,
                        g = l.vertexStride / 4,
                        y = s.getFloat32Data();
                    r ? (r.worldMatrix.invert(SubMeshStaticBatch._tempMatrix4x40), o = SubMeshStaticBatch._tempMatrix4x41,
                        L.multiply(SubMeshStaticBatch._tempMatrix4x40, n.worldMatrix, o)) : o = n.worldMatrix;
                    var S = SubMeshStaticBatch._tempMatrix4x42;
                    o.invert(S), S.transpose();
                    var C = SubMeshStaticBatch._tempQuaternion0;
                    o.decomposeTransRotScale(SubMeshStaticBatch._tempVector30, C, SubMeshStaticBatch._tempVector31);
                    for (var M = i.lightmapScaleOffset, x = a.vertexCount, D = 0; D < x; D++) {
                        var A, I, O = D * g,
                            P = 18 * (D + t);
                        R.transformVector3ArrayToVector3ArrayCoordinate(y, O + u, o, e, P + 0), -1 !== h && R.transformVector3ArrayToVector3ArrayNormal(y, O + h, S, e, P + 3);
                        var N = P + 6;
                        if (-1 !== d) {
                            var b = O + d;
                            for (A = 0, I = 4; A < I; A++) e[N + A] = y[b + A];
                        } else
                            for (A = 0, I = 4; A < I; A++) e[N + A] = 1;
                        if (-1 !== m) {
                            var k = O + m;
                            e[P + 10] = y[k], e[P + 11] = y[k + 1];
                        }
                        if (M && (-1 !== p ? R.transformLightingMapTexcoordArray(y, O + p, M, e, P + 12) : R.transformLightingMapTexcoordArray(y, O + m, M, e, P + 12)), -1 !== E) {
                            var V = O + E;
                            e[P + 14] = y[V], e[P + 15] = y[V + 1], e[P + 16] = y[V + 2], e[P + 17] = y[V + 3];
                        }
                    }
                    return x;
                }
            }, {
                key: "addTest",
                value: function(e) {
                    var t = e.meshFilter.sharedMesh.vertexCount;
                    return !(this._currentBatchVertexCount + t > SubMeshStaticBatch.maxBatchVertexCount);
                }
            }, {
                key: "add",
                value: function(e) {
                    var t = e.meshFilter.sharedMesh,
                        r = t.vertexCount;
                    this._batchElements.push(e);
                    var n = e._render;
                    n._isPartOfStaticBatch = !0, n._staticBatch = this;
                    for (var i = n._renderElements, a = 0, o = i.length; a < o; a++) i[a].staticBatch = this;
                    this._currentBatchIndexCount += t._indexBuffer.indexCount, this._currentBatchVertexCount += r;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e.meshFilter.sharedMesh,
                        r = this._batchElements.indexOf(e);
                    if (-1 !== r) {
                        this._batchElements.splice(r, 1);
                        for (var n = e._render._renderElements, i = 0, a = n.length; i < a; i++) n[i].staticBatch = null;
                        this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount,
                            this._currentBatchVertexCount = this._currentBatchVertexCount - t.vertexCount, e._render._isPartOfStaticBatch = !1;
                    }
                }
            }, {
                key: "finishInit",
                value: function() {
                    this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(),
                        t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
                    var r = t.LayaGL.instance,
                        n = 0,
                        i = 0,
                        a = this.batchOwner,
                        o = this._vertexDeclaration.vertexStride / 4,
                        s = new Float32Array(o * this._currentBatchVertexCount),
                        l = new Uint16Array(this._currentBatchIndexCount);
                    this._vertexBuffer = new be(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, r.STATIC_DRAW),
                        this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new Le(e.IndexFormat.UInt16, this._currentBatchIndexCount, r.STATIC_DRAW);
                    for (var u = 0, c = this._batchElements.length; u < c; u++) {
                        for (var h, _ = this._batchElements[u], d = _.meshFilter.sharedMesh, f = this._getStaticBatchBakedVertexs(s, n, a ? a._transform : null, _._transform, _._render, d), m = d._indexBuffer.getData(), T = n, p = i + m.length, v = _._render._renderElements, E = 0, g = d.subMeshCount; E < g; E++) {
                            var y = d._subMeshes[E],
                                S = i + y._indexStart,
                                R = v[E];
                            R.staticBatchIndexStart = S, R.staticBatchIndexEnd = S + y._indexCount;
                        }
                        if (l.set(m, i), a ? _._transform._isFrontFaceInvert !== a.transform._isFrontFaceInvert : _._transform._isFrontFaceInvert)
                            for (h = i; h < p; h += 3) {
                                l[h] = T + l[h];
                                var C = l[h + 1],
                                    M = l[h + 2];
                                l[h + 1] = T + M, l[h + 2] = T + C;
                            } else
                                for (h = i; h < p; h += 3) l[h] = T + l[h], l[h + 1] = T + l[h + 1], l[h + 2] = T + l[h + 2];
                        i += m.length, n += f;
                    }
                    this._vertexBuffer.setData(s.buffer), this._indexBuffer.setData(l);
                    var x = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                    t.Resource._addGPUMemory(x), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                        this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                }
            }, {
                key: "_render",
                value: function(e) {
                    this._bufferState.bind();
                    for (var r = t.LayaGL.instance, n = e.renderElement.staticBatchElementList, i = n.elements, a = 0, o = 0, s = n.length, l = 1; l < s; l++) {
                        if (i[l - 1].staticBatchIndexEnd !== i[l].staticBatchIndexStart) {
                            var u = i[a].staticBatchIndexStart,
                                c = i[o].staticBatchIndexEnd - u;
                            r.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u), a = ++o, t.Stat.trianglesFaces += c / 3;
                        } else o++;
                    }
                    u = i[a].staticBatchIndexStart, c = i[o].staticBatchIndexEnd - u, r.drawElements(r.TRIANGLES, c, r.UNSIGNED_SHORT, 2 * u),
                        t.Stat.renderBatches++, t.Stat.savedRenderBatches += s - 1, t.Stat.trianglesFaces += c / 3;
                }
            }, {
                key: "dispose",
                value: function() {
                    var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
                    t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null,
                        this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(),
                        this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null,
                        this._bufferState = null;
                }
            }]), SubMeshStaticBatch;
        }();
    Vt._tempVector30 = new o(), Vt._tempVector31 = new o(), Vt._tempQuaternion0 = new f(),
        Vt._tempMatrix4x40 = new L(), Vt._tempMatrix4x41 = new L(), Vt._tempMatrix4x42 = new L(),
        Vt.maxBatchVertexCount = 65535, Vt._batchIDCounter = 0;
    var Bt = function(e) {
        function MeshRenderStaticBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderStaticBatchManager), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderStaticBatchManager).call(this)))._opaqueBatchMarks = [],
                e._updateCountMark = 0, e;
        }
        return _inherits(MeshRenderStaticBatchManager, ce), _createClass(MeshRenderStaticBatchManager, [{
            key: "_compare",
            value: function(e, t) {
                var r = e._render,
                    n = t._render,
                    i = e.meshFilter.sharedMesh,
                    a = t.meshFilter.sharedMesh,
                    o = r.lightmapIndex - n.lightmapIndex;
                if (0 === o) {
                    var s = (r.receiveShadow ? 1 : 0) - (n.receiveShadow ? 1 : 0);
                    if (0 === s) {
                        var l = r.sharedMaterial && n.sharedMaterial ? r.sharedMaterial.id - n.sharedMaterial.id : 0;
                        if (0 === l) {
                            var u = i._vertexBuffer.vertexDeclaration.id - a._vertexBuffer.vertexDeclaration.id;
                            return 0 === u ? a._indexBuffer.indexCount - i._indexBuffer.indexCount : u;
                        }
                        return l;
                    }
                    return s;
                }
                return o;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new kt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                    e.staticBatchElementList = new ne()), e;
            }
        }, {
            key: "_getStaticBatch",
            value: function(e, t, r) {
                var n = e[r];
                return n || (n = e[r] = new Vt(t, MeshRenderStaticBatchManager._verDec), this._staticBatches[n._batchID] = n),
                    n;
            }
        }, {
            key: "_initStaticBatchs",
            value: function(e) {
                var t = this._initBatchSprites;
                this._quickSort(t, 0, t.length - 1);
                for (var r, n = [], i = !1, a = 0, o = 0, s = t.length; o < s; o++) {
                    var l = t[o];
                    if (i) r.addTest(l) ? r.add(l) : (i = !1, a++);
                    else o !== s - 1 && ((r = this._getStaticBatch(n, e, a)).add(l),
                        i = !0);
                }
                for (o = 0, s = n.length; o < s; o++) {
                    var u = n[o];
                    u && u.finishInit();
                }
                this._initBatchSprites.length = 0;
            }
        }, {
            key: "_removeRenderSprite",
            value: function(e) {
                var t = e._render,
                    r = t._staticBatch,
                    n = r._batchElements,
                    i = n.indexOf(e);
                if (-1 !== i) {
                    n.splice(i, 1), t._staticBatch = null;
                    for (var a = t._renderElements, o = 0, s = a.length; o < s; o++) a[o].staticBatch = null;
                }
                0 === n.length && (delete this._staticBatches[r._batchID], r.dispose());
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderStaticBatchManager.prototype), "_clear", this).call(this),
                    this._updateCountMark++;
            }
        }, {
            key: "_garbageCollection",
            value: function() {
                for (var e in this._staticBatches) {
                    var t = this._staticBatches[e];
                    0 === t._batchElements.length && (t.dispose(), delete this._staticBatches[e]);
                }
            }
        }, {
            key: "getBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = t ? 1 : 0,
                    a = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []),
                    o = a[i] || (a[i] = []),
                    s = o[r] || (o[r] = []);
                return s[n] || (s[n] = new Pt());
            }
        }], [{
            key: "__init__",
            value: function() {
                MeshRenderStaticBatchManager._verDec = Ne.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
            }
        }]), MeshRenderStaticBatchManager;
    }();
    Bt.instance = new Bt();
    var wt = function(e) {
        function BaseRender(e) {
            var r;
            if (_classCallCheck(this, BaseRender), (r = _possibleConstructorReturn(this, _getPrototypeOf(BaseRender).call(this)))._lightmapScaleOffset = new i(1, 1, 0, 0),
                r._indexInList = -1, r._indexInCastShadowList = -1, r._boundsChange = !0, r._castShadow = !1,
                r._supportOctree = !0, r._sharedMaterials = [], r._renderMark = -1, r._indexInOctreeMotionList = -1,
                r._updateMark = -1, r._updateRenderType = -1, r._isPartOfStaticBatch = !1, r._staticBatch = null,
                r._id = ++BaseRender._uniqueIDCounter, r._indexInCastShadowList = -1, r._bounds = new At(o._ZERO, o._ZERO),
                t.Render.supportWebGLPlusCulling) {
                var n = de._cullingBufferLength;
                r._cullingBufferIndex = n;
                var a = de._cullingBuffer,
                    s = n + 7;
                if (s >= a.length) {
                    var l = a;
                    (a = de._cullingBuffer = new Float32Array(a.length + 4096)).set(l, 0);
                }
                a[n] = 2, de._cullingBufferLength = s;
            }
            return r._renderElements = [], r._owner = e, r._enable = !0, r._materialsInstance = [],
                r._shaderValues = new z(null), r.lightmapIndex = -1, r.receiveShadow = !1, r.sortingFudge = 0,
                e && r._owner.transform.on(t.Event.TRANSFORM_CHANGED, _assertThisInitialized(r), r._onWorldMatNeedChange),
                r;
        }
        return _inherits(BaseRender, t.EventDispatcher), _createClass(BaseRender, [{
            key: "_getOctreeNode",
            value: function() {
                return this._octreeNode;
            }
        }, {
            key: "_setOctreeNode",
            value: function(e) {
                this._octreeNode = e;
            }
        }, {
            key: "_getIndexInMotionList",
            value: function() {
                return this._indexInOctreeMotionList;
            }
        }, {
            key: "_setIndexInMotionList",
            value: function(e) {
                this._indexInOctreeMotionList = e;
            }
        }, {
            key: "_changeMaterialReference",
            value: function(e, t) {
                e && e._removeReference(), t._addReference();
            }
        }, {
            key: "_getInstanceMaterial",
            value: function(e, t) {
                var r = e.clone();
                return r.name = r.name + "(Instance)", this._materialsInstance[t] = !0, this._changeMaterialReference(this._sharedMaterials[t], r),
                    this._sharedMaterials[t] = r, r;
            }
        }, {
            key: "_applyLightMapParams",
            value: function() {
                var e = this._scene.lightmaps,
                    t = this._shaderValues,
                    r = this._lightmapIndex;
                if (r >= 0 && r < e.length) {
                    var n = e[r];
                    t.setTexture(ue.LIGHTMAP, n.lightmapColor), t.addDefine(ue.SAHDERDEFINE_LIGHTMAP),
                        n.lightmapDirection ? (t.setTexture(ue.LIGHTMAP_DIRECTION, n.lightmapDirection),
                            t.addDefine(ue.SHADERDEFINE_LIGHTMAP_DIRECTIONAL)) : t.removeDefine(ue.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                } else t.removeDefine(ue.SAHDERDEFINE_LIGHTMAP), t.removeDefine(ue.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
            }
        }, {
            key: "_onWorldMatNeedChange",
            value: function(e) {
                this._boundsChange = !0, this._octreeNode && (e &= se.TRANSFORM_WORLDPOSITION | se.TRANSFORM_WORLDQUATERNION | se.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
            }
        }, {
            key: "_calculateBoundingBox",
            value: function() {
                throw "BaseRender: must override it.";
            }
        }, {
            key: "_getIndexInList",
            value: function() {
                return this._indexInList;
            }
        }, {
            key: "_setIndexInList",
            value: function(e) {
                this._indexInList = e;
            }
        }, {
            key: "_setBelongScene",
            value: function(e) {
                this._scene = e;
            }
        }, {
            key: "_needRender",
            value: function(e, t) {
                return !0;
            }
        }, {
            key: "_renderUpdate",
            value: function(e, t) {}
        }, {
            key: "_renderUpdateWithCamera",
            value: function(e, t) {}
        }, {
            key: "_revertBatchRenderUpdate",
            value: function(e) {}
        }, {
            key: "_destroy",
            value: function() {
                -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this),
                    this.offAll();
                var e = 0,
                    t = 0;
                for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e].destroy();
                for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
                this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null,
                    this._lightmapScaleOffset = null;
            }
        }, {
            key: "markAsUnStatic",
            value: function() {
                this._isPartOfStaticBatch && (Bt.instance._removeRenderSprite(this._owner), this._isPartOfStaticBatch = !1);
            }
        }, {
            key: "id",
            get: function() {
                return this._id;
            }
        }, {
            key: "lightmapIndex",
            get: function() {
                return this._lightmapIndex;
            },
            set: function(e) {
                this._lightmapIndex = e;
            }
        }, {
            key: "lightmapScaleOffset",
            get: function() {
                return this._lightmapScaleOffset;
            },
            set: function(e) {
                if (!e) throw "BaseRender: lightmapScaleOffset can't be null.";
                this._lightmapScaleOffset = e, this._shaderValues.setVector(ue.LIGHTMAPSCALEOFFSET, e);
            }
        }, {
            key: "enable",
            get: function() {
                return this._enable;
            },
            set: function(e) {
                this._enable = !!e;
            }
        }, {
            key: "material",
            get: function() {
                var e = this._sharedMaterials[0];
                if (e && !this._materialsInstance[0]) {
                    var t = this._getInstanceMaterial(e, 0),
                        r = this._renderElements[0];
                    r && (r.material = t);
                }
                return this._sharedMaterials[0];
            },
            set: function(e) {
                this.sharedMaterial = e;
            }
        }, {
            key: "materials",
            get: function() {
                for (var e = 0, t = this._sharedMaterials.length; e < t; e++)
                    if (!this._materialsInstance[e]) {
                        var r = this._getInstanceMaterial(this._sharedMaterials[e], e),
                            n = this._renderElements[e];
                        n && (n.material = r);
                    }
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                this.sharedMaterials = e;
            }
        }, {
            key: "sharedMaterial",
            get: function() {
                return this._sharedMaterials[0];
            },
            set: function(e) {
                var t = this._sharedMaterials[0];
                if (t !== e) {
                    this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                    var r = this._renderElements[0];
                    r && (r.material = e);
                }
            }
        }, {
            key: "sharedMaterials",
            get: function() {
                return this._sharedMaterials.slice();
            },
            set: function(e) {
                for (var t = this._materialsInstance, r = this._sharedMaterials, n = 0, i = r.length; n < i; n++) {
                    var a = r[n];
                    a && a._removeReference();
                }
                if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
                var o = e.length;
                for (t.length = o, r.length = o, n = 0; n < o; n++) {
                    a = r[n];
                    var s = e[n];
                    if (a !== s) {
                        t[n] = !1;
                        var l = this._renderElements[n];
                        l && (l.material = s);
                    }
                    s && s._addReference(), r[n] = s;
                }
            }
        }, {
            key: "bounds",
            get: function() {
                return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                    this._bounds;
            }
        }, {
            key: "receiveShadow",
            set: function(e) {
                this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues.addDefine(ue.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(ue.SHADERDEFINE_RECEIVE_SHADOW));
            },
            get: function() {
                return this._receiveShadow;
            }
        }, {
            key: "castShadow",
            get: function() {
                return this._castShadow;
            },
            set: function(e) {
                this._castShadow = e;
            }
        }, {
            key: "isPartOfStaticBatch",
            get: function() {
                return this._isPartOfStaticBatch;
            }
        }, {
            key: "isRender",
            get: function() {
                return -1 == this._renderMark || this._renderMark == t.Stat.loopCount - 1;
            }
        }]), BaseRender;
    }();
    wt._tempBoundBoxCorners = [new o(), new o(), new o(), new o(), new o(), new o(), new o(), new o()],
        wt._uniqueIDCounter = 0, wt._defaultLightmapScaleOffset = new i(1, 1, 0, 0);
    var Ft = function(e) {
            function PixelLineRenderer(e) {
                var t;
                return _classCallCheck(this, PixelLineRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineRenderer).call(this, e)))._projectionViewWorldMatrix = new L(),
                    t;
            }
            return _inherits(PixelLineRenderer, wt), _createClass(PixelLineRenderer, [{
                key: "_calculateBoundingBox",
                value: function() {
                    var e = this._owner.transform.worldMatrix,
                        r = this._owner._geometryFilter;
                    if (r._reCalculateBound(), r._bounds._tranform(e, this._bounds), t.Render.supportWebGLPlusCulling) {
                        var n = this._bounds.getMin(),
                            i = this._bounds.getMax(),
                            a = de._cullingBuffer;
                        a[this._cullingBufferIndex + 1] = n.x, a[this._cullingBufferIndex + 2] = n.y, a[this._cullingBufferIndex + 3] = n.z,
                            a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
                    }
                }
            }, {
                key: "_renderUpdateWithCamera",
                value: function(e, t) {
                    var r = e.projectionViewMatrix,
                        n = this._shaderValues;
                    if (t) {
                        var i = t.worldMatrix;
                        n.setMatrix4x4(le.WORLDMATRIX, i), L.multiply(r, i, this._projectionViewWorldMatrix),
                            n.setMatrix4x4(le.MVPMATRIX, this._projectionViewWorldMatrix);
                    } else n.setMatrix4x4(le.WORLDMATRIX, L.DEFAULT), n.setMatrix4x4(le.MVPMATRIX, r);
                }
            }]), PixelLineRenderer;
        }(),
        Ut = function(e) {
            function PixelLineSprite3D() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 2,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return _classCallCheck(this, PixelLineSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(PixelLineSprite3D).call(this, r)))._geometryFilter = new Ot(_assertThisInitialized(e), t),
                    e._render = new Ft(_assertThisInitialized(e)), e._changeRenderObjects(e._render, 0, xt.defaultMaterial),
                    e;
            }
            return _inherits(PixelLineSprite3D, ue), _createClass(PixelLineSprite3D, [{
                key: "maxLineCount",
                get: function() {
                    return this._geometryFilter._maxLineCount;
                },
                set: function(e) {
                    this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
                }
            }, {
                key: "lineCount",
                get: function() {
                    return this._geometryFilter._lineCount;
                },
                set: function(e) {
                    if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
                    this._geometryFilter._lineCount = e;
                }
            }, {
                key: "pixelLineRenderer",
                get: function() {
                    return this._render;
                }
            }]), _createClass(PixelLineSprite3D, [{
                key: "_changeRenderObjects",
                value: function(e, t, r) {
                    var n = this._render._renderElements;
                    r || (r = xt.defaultMaterial);
                    var i = n[t];
                    i || (i = n[t] = new bt()), i.setTransform(this._transform), i.setGeometry(this._geometryFilter),
                        i.render = this._render, i.material = r;
                }
            }, {
                key: "addLine",
                value: function(e, t, r, n) {
                    if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
                    this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r, n);
                }
            }, {
                key: "addLines",
                value: function(e) {
                    var t = this._geometryFilter._lineCount,
                        r = e.length;
                    if (t + r > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
                    this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += r;
                }
            }, {
                key: "removeLine",
                value: function(e) {
                    if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                    this._geometryFilter._removeLineData(e);
                }
            }, {
                key: "setLine",
                value: function(e, t, r, n, i) {
                    if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                    this._geometryFilter._updateLineData(e, t, r, n, i);
                }
            }, {
                key: "getLine",
                value: function(e, t) {
                    if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
                    this._geometryFilter._getLineData(e, t);
                }
            }, {
                key: "clear",
                value: function() {
                    this._geometryFilter._lineCount = 0;
                }
            }, {
                key: "_create",
                value: function() {
                    return new PixelLineSprite3D();
                }
            }]), PixelLineSprite3D;
        }(),
        Gt = function() {
            function RenderQueue() {
                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                _classCallCheck(this, RenderQueue), this.isTransparent = !1, this.elements = new ne(),
                    this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1, this.isTransparent = e;
            }
            return _createClass(RenderQueue, [{
                key: "_compare",
                value: function(e, t) {
                    var r = e.material.renderQueue - t.material.renderQueue;
                    return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r;
                }
            }, {
                key: "_partitionRenderObject",
                value: function(e, t) {
                    for (var r = this.elements.elements, n = r[Math.floor((t + e) / 2)]; e <= t;) {
                        for (; this._compare(r[e], n) < 0;) e++;
                        for (; this._compare(r[t], n) > 0;) t--;
                        if (e < t) {
                            var i = r[e];
                            r[e] = r[t], r[t] = i, e++, t--;
                        } else if (e === t) {
                            e++;
                            break;
                        }
                    }
                    return e;
                }
            }, {
                key: "_quickSort",
                value: function(e, t) {
                    if (this.elements.length > 1) {
                        var r = this._partitionRenderObject(e, t),
                            n = r - 1;
                        e < n && this._quickSort(e, n), r < t && this._quickSort(r, t);
                    }
                }
            }, {
                key: "_render",
                value: function(e) {
                    for (var t = this.elements.elements, r = 0, n = this.elements.length; r < n; r++) t[r]._render(e);
                }
            }, {
                key: "clear",
                value: function() {
                    this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
                }
            }]), RenderQueue;
        }(),
        zt = function() {
            function BoundsOctreeNode(e, t, r, n) {
                _classCallCheck(this, BoundsOctreeNode), this._bounds = new Dt(new o(), new o()),
                    this._objects = [], this._isContaion = !1, this.center = new o(), this.baseLength = 0,
                    this._setValues(e, t, r, n);
            }
            return _createClass(BoundsOctreeNode, [{
                key: "_setValues",
                value: function(e, t, r, n) {
                    this._octree = e, this._parent = t, this.baseLength = r, n.cloneTo(this.center);
                    var i = this._bounds.min,
                        a = this._bounds.max,
                        o = e._looseness * r / 2;
                    i.setValue(n.x - o, n.y - o, n.z - o), a.setValue(n.x + o, n.y + o, n.z + o);
                }
            }, {
                key: "_getChildBound",
                value: function(e) {
                    if (null != this._children && this._children[e]) return this._children[e]._bounds;
                    var t = this.baseLength / 4,
                        r = this.baseLength / 2 * this._octree._looseness / 2,
                        n = BoundsOctreeNode._tempBoundBox,
                        i = n.min,
                        a = n.max;
                    switch (e) {
                        case 0:
                            i.x = this.center.x - t - r, i.y = this.center.y + t - r, i.z = this.center.z - t - r,
                                a.x = this.center.x - t + r, a.y = this.center.y + t + r, a.z = this.center.z - t + r;
                            break;

                        case 1:
                            i.x = this.center.x + t - r, i.y = this.center.y + t - r, i.z = this.center.z - t - r,
                                a.x = this.center.x + t + r, a.y = this.center.y + t + r, a.z = this.center.z - t + r;
                            break;

                        case 2:
                            i.x = this.center.x - t - r, i.y = this.center.y + t - r, i.z = this.center.z + t - r,
                                a.x = this.center.x - t + r, a.y = this.center.y + t + r, a.z = this.center.z + t + r;
                            break;

                        case 3:
                            i.x = this.center.x + t - r, i.y = this.center.y + t - r, i.z = this.center.z + t - r,
                                a.x = this.center.x + t + r, a.y = this.center.y + t + r, a.z = this.center.z + t + r;
                            break;

                        case 4:
                            i.x = this.center.x - t - r, i.y = this.center.y - t - r, i.z = this.center.z - t - r,
                                a.x = this.center.x - t + r, a.y = this.center.y - t + r, a.z = this.center.z - t + r;
                            break;

                        case 5:
                            i.x = this.center.x + t - r, i.y = this.center.y - t - r, i.z = this.center.z - t - r,
                                a.x = this.center.x + t + r, a.y = this.center.y - t + r, a.z = this.center.z - t + r;
                            break;

                        case 6:
                            i.x = this.center.x - t - r, i.y = this.center.y - t - r, i.z = this.center.z + t - r,
                                a.x = this.center.x - t + r, a.y = this.center.y - t + r, a.z = this.center.z + t + r;
                            break;

                        case 7:
                            i.x = this.center.x + t - r, i.y = this.center.y - t - r, i.z = this.center.z + t - r,
                                a.x = this.center.x + t + r, a.y = this.center.y - t + r, a.z = this.center.z + t + r;
                    }
                    return n;
                }
            }, {
                key: "_getChildCenter",
                value: function(e) {
                    if (null != this._children) return this._children[e].center;
                    var t = this.baseLength / 4,
                        r = BoundsOctreeNode._tempVector30;
                    switch (e) {
                        case 0:
                            r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z - t;
                            break;

                        case 1:
                            r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z - t;
                            break;

                        case 2:
                            r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z + t;
                            break;

                        case 3:
                            r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z + t;
                            break;

                        case 4:
                            r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z - t;
                            break;

                        case 5:
                            r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z - t;
                            break;

                        case 6:
                            r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z + t;
                            break;

                        case 7:
                            r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z + t;
                    }
                    return r;
                }
            }, {
                key: "_getChild",
                value: function(e) {
                    var t = this.baseLength / 4;
                    switch (this._children || (this._children = []), e) {
                        case 0:
                            return this._children[0] || (this._children[0] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + -t, this.center.y + t, this.center.z - t)));

                        case 1:
                            return this._children[1] || (this._children[1] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y + t, this.center.z - t)));

                        case 2:
                            return this._children[2] || (this._children[2] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y + t, this.center.z + t)));

                        case 3:
                            return this._children[3] || (this._children[3] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y + t, this.center.z + t)));

                        case 4:
                            return this._children[4] || (this._children[4] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y - t, this.center.z - t)));

                        case 5:
                            return this._children[5] || (this._children[5] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y - t, this.center.z - t)));

                        case 6:
                            return this._children[6] || (this._children[6] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x - t, this.center.y - t, this.center.z + t)));

                        case 7:
                            return this._children[7] || (this._children[7] = new BoundsOctreeNode(this._octree, this, this.baseLength / 2, new o(this.center.x + t, this.center.y - t, this.center.z + t)));

                        default:
                            throw "BoundsOctreeNode: unknown index.";
                    }
                }
            }, {
                key: "_shouldMerge",
                value: function() {
                    for (var e = this._objects.length, t = 0; t < 8; t++) {
                        var r = this._children[t];
                        if (r) {
                            if (null != r._children) return !1;
                            e += r._objects.length;
                        }
                    }
                    return e <= BoundsOctreeNode._NUM_OBJECTS_ALLOWED;
                }
            }, {
                key: "_mergeChildren",
                value: function() {
                    for (var e = 0; e < 8; e++) {
                        var t = this._children[e];
                        if (t) {
                            t._parent = null;
                            for (var r = t._objects, n = r.length - 1; n >= 0; n--) {
                                var i = r[n];
                                this._objects.push(i), i._setOctreeNode(this);
                            }
                        }
                    }
                    this._children = null;
                }
            }, {
                key: "_merge",
                value: function() {
                    if (null === this._children) {
                        var e = this._parent;
                        e && e._shouldMerge() && (e._mergeChildren(), e._merge());
                    }
                }
            }, {
                key: "_checkAddNode",
                value: function(e) {
                    if (null == this._children) {
                        if (this._objects.length < BoundsOctreeNode._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                        for (var t = this._objects.length - 1; t >= 0; t--) {
                            var r = this._objects[t],
                                n = this._bestFitChild(r.bounds.getCenter());
                            BoundsOctreeNode._encapsulates(this._getChildBound(n), r.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(r), 1),
                                this._getChild(n)._add(r));
                        }
                    }
                    var i = this._bestFitChild(e.bounds.getCenter());
                    return BoundsOctreeNode._encapsulates(this._getChildBound(i), e.bounds._getBoundBox()) ? this._getChild(i)._checkAddNode(e) : this;
                }
            }, {
                key: "_add",
                value: function(e) {
                    var t = this._checkAddNode(e);
                    t._objects.push(e), e._setOctreeNode(t);
                }
            }, {
                key: "_remove",
                value: function(e) {
                    var t = this._objects.indexOf(e);
                    this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
                }
            }, {
                key: "_addUp",
                value: function(e) {
                    return Re.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === ye.Contains ? (this._add(e), !0) : !!this._parent && this._parent._addUp(e);
                }
            }, {
                key: "_getCollidingWithFrustum",
                value: function(e, r, n, i, a, s) {
                    var l = e.boundFrustum,
                        u = e.position,
                        c = e.cullingMask;
                    if (n) {
                        var h = l.containsBoundBox(this._bounds);
                        if (t.Stat.octreeNodeCulling++, h === ye.Disjoint) return;
                        n = h === ye.Intersects;
                    }
                    this._isContaion = !n;
                    for (var _ = r.scene, d = t.Stat.loopCount, f = 0, m = this._objects.length; f < m; f++) {
                        var T = this._objects[f];
                        if (s ? T._castShadow && T._enable : 0 != (Math.pow(2, T._owner._layer) & c) && T._enable) {
                            if (n && (t.Stat.frustumCulling++, !T._needRender(l, r))) continue;
                            T._renderMark = d, T._distanceForSort = o.distance(T.bounds.getCenter(), u);
                            for (var p = T._renderElements, v = 0, E = p.length; v < E; v++) {
                                p[v]._update(_, r, i, a);
                            }
                        }
                    }
                    if (null != this._children)
                        for (f = 0; f < 8; f++) {
                            var g = this._children[f];
                            g && g._getCollidingWithFrustum(e, r, n, i, a, s);
                        }
                }
            }, {
                key: "_getCollidingWithBoundBox",
                value: function(e, t, r) {
                    if (t) {
                        var n = Re.boxContainsBox(this._bounds, e);
                        if (n === ye.Disjoint) return;
                        t = n === ye.Intersects;
                    }
                    if (t)
                        for (var i = 0, a = this._objects.length; i < a; i++) {
                            var o = this._objects[i];
                            Re.intersectsBoxAndBox(o.bounds._getBoundBox(), e) && r.push(o);
                        }
                    if (null != this._children)
                        for (i = 0; i < 8; i++) {
                            this._children[i]._getCollidingWithBoundBox(e, t, r);
                        }
                }
            }, {
                key: "_bestFitChild",
                value: function(e) {
                    return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
                }
            }, {
                key: "_update",
                value: function(e) {
                    if (Re.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === ye.Contains) {
                        var t = this._checkAddNode(e);
                        if (t !== e._getOctreeNode()) {
                            t._objects.push(e), e._setOctreeNode(t);
                            var r = this._objects.indexOf(e);
                            this._objects.splice(r, 1), this._merge();
                        }
                        return !0;
                    }
                    if (this._parent) {
                        var n = this._parent._addUp(e);
                        return n && (r = this._objects.indexOf(e), this._objects.splice(r, 1), this._merge()),
                            n;
                    }
                    return !1;
                }
            }, {
                key: "add",
                value: function(e) {
                    return !!BoundsOctreeNode._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), !0);
                }
            }, {
                key: "remove",
                value: function(e) {
                    return e._getOctreeNode() === this && (this._remove(e), !0);
                }
            }, {
                key: "update",
                value: function(e) {
                    return e._getOctreeNode() === this && this._update(e);
                }
            }, {
                key: "shrinkIfPossible",
                value: function(e) {
                    if (this.baseLength < 2 * e) return this;
                    for (var t = -1, r = 0, n = this._objects.length; r < n; r++) {
                        var i = this._objects[r],
                            a = this._bestFitChild(i.bounds.getCenter());
                        if (0 != r && a != t) return this;
                        var o = this._getChildBound(a);
                        if (!BoundsOctreeNode._encapsulates(o, i.bounds._getBoundBox())) return this;
                        0 == r && (t = a);
                    }
                    if (null == this._children) {
                        if (-1 != t) {
                            var s = this._getChildCenter(t);
                            this._setValues(this._octree, null, this.baseLength / 2, s);
                        }
                        return this;
                    }
                    var l = !1;
                    for (r = 0, n = this._children.length; r < n; r++) {
                        var u = this._children[r];
                        if (u && u.hasAnyObjects()) {
                            if (l) return this;
                            if (t >= 0 && t != r) return this;
                            l = !0, t = r;
                        }
                    }
                    if (-1 != t) {
                        var c = this._children[t];
                        return c._parent = null, c;
                    }
                    return this;
                }
            }, {
                key: "hasAnyObjects",
                value: function() {
                    if (this._objects.length > 0) return !0;
                    if (null != this._children)
                        for (var e = 0; e < 8; e++) {
                            var t = this._children[e];
                            if (t && t.hasAnyObjects()) return !0;
                        }
                    return !1;
                }
            }, {
                key: "getCollidingWithBoundBox",
                value: function(e, t) {
                    this._getCollidingWithBoundBox(e, !0, t);
                }
            }, {
                key: "getCollidingWithRay",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE,
                        n = Re.intersectsRayAndBoxRD(e, this._bounds);
                    if (!(-1 == n || n > r)) {
                        for (var i = 0, a = this._objects.length; i < a; i++) {
                            var o = this._objects[i]; -
                            1 !== (n = Re.intersectsRayAndBoxRD(e, o.bounds._getBoundBox())) && n <= r && t.push(o);
                        }
                        if (null != this._children)
                            for (i = 0; i < 8; i++) {
                                this._children[i].getCollidingWithRay(e, t, r);
                            }
                    }
                }
            }, {
                key: "getCollidingWithFrustum",
                value: function(e, t, r, n, i) {
                    this._getCollidingWithFrustum(e, t, !0, r, n, i);
                }
            }, {
                key: "isCollidingWithBoundBox",
                value: function(e) {
                    if (!Re.intersectsBoxAndBox(this._bounds, e)) return !1;
                    for (var t = 0, r = this._objects.length; t < r; t++) {
                        var n = this._objects[t];
                        if (Re.intersectsBoxAndBox(n.bounds._getBoundBox(), e)) return !0;
                    }
                    if (null != this._children)
                        for (t = 0; t < 8; t++) {
                            if (this._children[t].isCollidingWithBoundBox(e)) return !0;
                        }
                    return !1;
                }
            }, {
                key: "isCollidingWithRay",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                        r = Re.intersectsRayAndBoxRD(e, this._bounds);
                    if (-1 == r || r > t) return !1;
                    for (var n = 0, i = this._objects.length; n < i; n++) {
                        var a = this._objects[n];
                        if (-1 !== (r = Re.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) && r <= t) return !0;
                    }
                    if (null != this._children)
                        for (n = 0; n < 8; n++) {
                            if (this._children[n].isCollidingWithRay(e, t)) return !0;
                        }
                    return !1;
                }
            }, {
                key: "getBound",
                value: function() {
                    return this._bounds;
                }
            }, {
                key: "drawAllBounds",
                value: function(e, t, r) {
                    if (null !== this._children || 0 != this._objects.length) {
                        t++;
                        var n = BoundsOctreeNode._tempColor0;
                        if (this._isContaion) n.r = 0, n.g = 0, n.b = 1;
                        else {
                            var i = r ? t / r : 0;
                            n.r = 1 - i, n.g = i, n.b = 0;
                        }
                        if (n.a = .3, R._drawBound(e, this._bounds, n), null != this._children)
                            for (var a = 0; a < 8; a++) {
                                var o = this._children[a];
                                o && o.drawAllBounds(e, t, r);
                            }
                    }
                }
            }, {
                key: "drawAllObjects",
                value: function(e, t, r) {
                    t++;
                    var n = BoundsOctreeNode._tempColor0;
                    if (this._isContaion) n.r = 0, n.g = 0, n.b = 1;
                    else {
                        var i = r ? t / r : 0;
                        n.r = 1 - i, n.g = i, n.b = 0;
                    }
                    n.a = 1;
                    for (var a = 0, o = this._objects.length; a < o; a++) R._drawBound(e, this._objects[a].bounds._getBoundBox(), n);
                    if (null != this._children)
                        for (a = 0; a < 8; a++) {
                            var s = this._children[a];
                            s && s.drawAllObjects(e, t, r);
                        }
                }
            }], [{
                key: "_encapsulates",
                value: function(e, t) {
                    return Re.boxContainsBox(e, t) == ye.Contains;
                }
            }]), BoundsOctreeNode;
        }();
    zt._tempVector3 = new o(), zt._tempVector30 = new o(), zt._tempVector31 = new o(),
        zt._tempColor0 = new ae(), zt._tempBoundBox = new Dt(new o(), new o()), zt._NUM_OBJECTS_ALLOWED = 8;
    var Ht = function(e) {
            function OctreeMotionList() {
                return _classCallCheck(this, OctreeMotionList), _possibleConstructorReturn(this, _getPrototypeOf(OctreeMotionList).call(this));
            }
            return _inherits(OctreeMotionList, ne), _createClass(OctreeMotionList, [{
                key: "add",
                value: function(e) {
                    if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
                    this._add(e), e._setIndexInMotionList(this.length++);
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._getIndexInMotionList();
                    if (this.length--, t !== this.length) {
                        var r = this.elements[this.length];
                        this.elements[t] = r, r._setIndexInMotionList(t);
                    }
                    e._setIndexInMotionList(-1);
                }
            }]), OctreeMotionList;
        }(),
        Wt = function() {
            function BoundsOctree(e, t, r, n) {
                _classCallCheck(this, BoundsOctree), this._motionObjects = new Ht(), this.count = 0,
                    r > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + r + " Adjusted to: " + e),
                        r = e), this._initialSize = e, this._minSize = r, this._looseness = Math.min(Math.max(n, 1), 2),
                    this._rootNode = new zt(this, null, e, t);
            }
            return _createClass(BoundsOctree, [{
                key: "_getMaxDepth",
                value: function(e, t) {
                    t++;
                    var r = e._children;
                    if (null != r)
                        for (var n = t, i = 0, a = r.length; i < a; i++) {
                            var o = r[i];
                            o && (t = Math.max(this._getMaxDepth(o, n), t));
                        }
                    return t;
                }
            }, {
                key: "_grow",
                value: function(e) {
                    var t = e.x >= 0 ? 1 : -1,
                        r = e.y >= 0 ? 1 : -1,
                        n = e.z >= 0 ? 1 : -1,
                        i = this._rootNode,
                        a = this._rootNode.baseLength / 2,
                        s = 2 * this._rootNode.baseLength,
                        l = this._rootNode.center,
                        u = new o(l.x + t * a, l.y + r * a, l.z + n * a);
                    if (this._rootNode = new zt(this, null, s, u), i.hasAnyObjects()) {
                        for (var c = this._rootNode._bestFitChild(i.center), h = [], _ = 0; _ < 8; _++) _ == c && (i._parent = this._rootNode,
                            h[_] = i);
                        this._rootNode._children = h;
                    }
                }
            }, {
                key: "add",
                value: function(e) {
                    for (var t = 0; !this._rootNode.add(e);) {
                        var r = BoundsOctree._tempVector30;
                        if (o.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(r), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                    }
                    this.count++;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._getOctreeNode().remove(e);
                    return t && this.count--, t;
                }
            }, {
                key: "update",
                value: function(e) {
                    var t = 0,
                        r = e._getOctreeNode();
                    if (r) {
                        for (; !r._update(e);) {
                            var n = BoundsOctree._tempVector30;
                            if (o.subtract(e.bounds.getCenter(), this._rootNode.center, n), this._grow(n), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                        }
                        return !0;
                    }
                    return !1;
                }
            }, {
                key: "shrinkRootIfPossible",
                value: function() {
                    this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
                }
            }, {
                key: "addMotionObject",
                value: function(e) {
                    this._motionObjects.add(e);
                }
            }, {
                key: "removeMotionObject",
                value: function(e) {
                    this._motionObjects.remove(e);
                }
            }, {
                key: "updateMotionObjects",
                value: function() {
                    for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects.length; t < r; t++) {
                        var n = e[t];
                        this.update(n), n._setIndexInMotionList(-1);
                    }
                    this._motionObjects.length = 0;
                }
            }, {
                key: "isCollidingWithBoundBox",
                value: function(e) {
                    return this._rootNode.isCollidingWithBoundBox(e);
                }
            }, {
                key: "isCollidingWithRay",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
                    return this._rootNode.isCollidingWithRay(e, t);
                }
            }, {
                key: "getCollidingWithBoundBox",
                value: function(e, t) {
                    this._rootNode.getCollidingWithBoundBox(e, t);
                }
            }, {
                key: "getCollidingWithRay",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Number.MAX_VALUE;
                    this._rootNode.getCollidingWithRay(e, t, r);
                }
            }, {
                key: "getCollidingWithFrustum",
                value: function(e, t, r, n, i) {
                    this._rootNode.getCollidingWithFrustum(e, t, r, n, i);
                }
            }, {
                key: "getMaxBounds",
                value: function() {
                    return this._rootNode.getBound();
                }
            }, {
                key: "drawAllBounds",
                value: function(e) {
                    var t = this._getMaxDepth(this._rootNode, -1);
                    this._rootNode.drawAllBounds(e, -1, t);
                }
            }, {
                key: "drawAllObjects",
                value: function(e) {
                    var t = this._getMaxDepth(this._rootNode, -1);
                    this._rootNode.drawAllObjects(e, -1, t);
                }
            }]), BoundsOctree;
        }();
    Wt._tempVector30 = new o();
    var Xt = function Lightmap() {
            _classCallCheck(this, Lightmap);
        },
        Yt = function() {
            function BoundSphere(e, t) {
                _classCallCheck(this, BoundSphere), this.center = e, this.radius = t;
            }
            return _createClass(BoundSphere, [{
                key: "toDefault",
                value: function() {
                    this.center.toDefault(), this.radius = 0;
                }
            }, {
                key: "intersectsRayDistance",
                value: function(e) {
                    return Re.intersectsRayAndSphereRD(e, this);
                }
            }, {
                key: "intersectsRayPoint",
                value: function(e, t) {
                    return Re.intersectsRayAndSphereRP(e, this, t);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this.center.cloneTo(t.center), t.radius = this.radius;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new BoundSphere(new o(), 0);
                    return this.cloneTo(e), e;
                }
            }], [{
                key: "createFromSubPoints",
                value: function(e, t, r, n) {
                    if (null == e) throw new Error("points");
                    if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
                    if (r < 0 || t + r > e.length) throw new Error("count" + r + "Must be in the range <= " + e.length + "}");
                    var i = t + r,
                        a = BoundSphere._tempVector3;
                    a.x = 0, a.y = 0, a.z = 0;
                    for (var s = t; s < i; ++s) o.add(e[s], a, a);
                    var l = n.center;
                    o.scale(a, 1 / r, l);
                    var u = 0;
                    for (s = t; s < i; ++s) {
                        var c = o.distanceSquared(l, e[s]);
                        c > u && (u = c);
                    }
                    n.radius = Math.sqrt(u);
                }
            }, {
                key: "createfromPoints",
                value: function(e, t) {
                    if (null == e) throw new Error("points");
                    BoundSphere.createFromSubPoints(e, 0, e.length, t);
                }
            }]), BoundSphere;
        }();
    Yt._tempVector3 = new o();
    var jt, Qt = function ShadowSliceData() {
            _classCallCheck(this, ShadowSliceData), this.cameraShaderValue = new z(), this.position = new o(),
                this.viewMatrix = new L(), this.projectionMatrix = new L(), this.viewProjectMatrix = new L(),
                this.cullPlanes = [new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o())],
                this.splitBoundSphere = new Yt(new o(), 0);
        },
        Zt = function() {
            function ShadowCasterPass() {
                _classCallCheck(this, ShadowCasterPass), this._shadowBias = new i(), this._shadowParams = new i(),
                    this._shadowMapSize = new i(), this._shadowMatrices = new Float32Array(16 * ShadowCasterPass._maxCascades),
                    this._splitBoundSpheres = new Float32Array(4 * ShadowCasterPass._maxCascades), this._cascadeCount = 0,
                    this._shadowMapWidth = 0, this._shadowMapHeight = 0, this._shadowSliceDatas = [new Qt(), new Qt(), new Qt(), new Qt()],
                    this._lightUp = new o(), this._lightSide = new o(), this._lightForward = new o();
            }
            return _createClass(ShadowCasterPass, [{
                key: "_setupShadowCasterShaderValues",
                value: function(e, t, r, n, i) {
                    t.setVector(ShadowCasterPass.SHADOW_BIAS, i), t.setVector3(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, n);
                    var a = r.cameraShaderValue;
                    a.setMatrix4x4(Fe.VIEWMATRIX, r.viewMatrix), a.setMatrix4x4(Fe.PROJECTMATRIX, r.projectionMatrix),
                        a.setMatrix4x4(Fe.VIEWPROJECTMATRIX, r.viewProjectMatrix), e.viewMatrix = r.viewMatrix,
                        e.projectionMatrix = r.projectionMatrix, e.projectionViewMatrix = r.viewProjectMatrix;
                }
            }, {
                key: "_setupShadowReceiverShaderValues",
                value: function(t) {
                    var r = this._light;
                    switch (r.shadowCascadesMode !== e.ShadowCascadesMode.NoCascades ? t.addDefine(Qe.SHADERDEFINE_SHADOW_CASCADE) : t.removeDefine(Qe.SHADERDEFINE_SHADOW_CASCADE),
                        r.shadowMode) {
                        case e.ShadowMode.Hard:
                            t.removeDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                            break;

                        case e.ShadowMode.SoftLow:
                            t.addDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW), t.removeDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH);
                            break;

                        case e.ShadowMode.SoftHigh:
                            t.addDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH), t.removeDefine(Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW);
                    }
                    t.setTexture(ShadowCasterPass.SHADOW_MAP, this._shadowMap), t.setBuffer(ShadowCasterPass.SHADOW_MATRICES, this._shadowMatrices),
                        t.setVector(ShadowCasterPass.SHADOW_MAP_SIZE, this._shadowMapSize), t.setVector(ShadowCasterPass.SHADOW_PARAMS, this._shadowParams),
                        t.setBuffer(ShadowCasterPass.SHADOW_SPLIT_SPHERES, this._splitBoundSpheres);
                }
            }, {
                key: "update",
                value: function(t, n) {
                    this._light = n;
                    var i = ShadowCasterPass._tempMatrix0,
                        a = i.elements,
                        s = this._lightUp,
                        l = this._lightSide,
                        u = this._lightForward;
                    L.createFromQuaternion(n._transform.rotation, i), l.setValue(a[0], a[1], a[2]),
                        s.setValue(a[4], a[5], a[6]), u.setValue(-a[8], -a[9], -a[10]);
                    var c, h, _, d, f = n._shadowResolution,
                        m = n._shadowCascadesMode;
                    m == e.ShadowCascadesMode.NoCascades ? (c = 1, h = f, _ = f, d = f) : (c = m == e.ShadowCascadesMode.TwoCascades ? 2 : 4,
                            _ = 2 * (h = $e.getMaxTileResolutionInAtlas(f, f, c)), d = m == e.ShadowCascadesMode.TwoCascades ? h : 2 * h),
                        this._cascadeCount = c, this._shadowMapWidth = _, this._shadowMapHeight = d;
                    var T = ShadowCasterPass._cascadesSplitDistance,
                        p = ShadowCasterPass._frustumPlanes,
                        v = t.nearPlane,
                        E = Math.min(t.farPlane, n._shadowDistance),
                        g = this._shadowMatrices,
                        y = this._splitBoundSpheres;
                    $e.getCascadesSplitDistance(n._shadowTwoCascadeSplits, n._shadowFourCascadeSplits, v, E, t.fieldOfView * r.Deg2Rad, t.aspectRatio, m, T),
                        $e.getCameraFrustumPlanes(t.projectionViewMatrix, p);
                    var S = ShadowCasterPass._tempVector30;
                    t._transform.getForward(S), o.normalize(S, S);
                    for (var R = 0; R < c; R++) {
                        var C = this._shadowSliceDatas[R];
                        C.sphereCenterZ = $e.getBoundSphereByFrustum(T[R], T[R + 1], t.fieldOfView * r.Deg2Rad, t.aspectRatio, t._transform.position, S, C.splitBoundSphere),
                            $e.getDirectionLightShadowCullPlanes(p, R, T, v, u, C), $e.getDirectionalLightMatrices(s, l, u, R, n._shadowNearPlane, h, C, g),
                            c > 1 && $e.applySliceTransform(C, _, d, R, g);
                    }
                    $e.prepareShadowReceiverShaderValues(n, _, d, this._shadowSliceDatas, c, this._shadowMapSize, this._shadowParams, g, y);
                }
            }, {
                key: "render",
                value: function(e, r) {
                    var n = r._shaderValues;
                    e.pipelineMode = "ShadowCaster", z.setRuntimeValueMode(!1);
                    var i = this._shadowMap = $e.getTemporaryShadowTexture(this._shadowMapWidth, this._shadowMapHeight, t.RenderTextureDepthFormat.DEPTH_16);
                    i._start();
                    for (var a = this._light, o = 0, s = this._cascadeCount; o < s; o++) {
                        var l = this._shadowSliceDatas[o];
                        $e.getShadowBias(a, l.projectionMatrix, l.resolution, this._shadowBias), this._setupShadowCasterShaderValues(e, n, l, this._lightForward, this._shadowBias);
                        var u = de._shadowCullInfo;
                        u.position = l.position, u.cullPlanes = l.cullPlanes, u.cullPlaneCount = l.cullPlaneCount,
                            u.cullSphere = l.splitBoundSphere, u.direction = this._lightForward;
                        var c = de.cullingShadow(u, r, e);
                        e.cameraShaderValue = l.cameraShaderValue, et._updateMark++;
                        var h = t.LayaGL.instance,
                            _ = l.resolution,
                            d = l.offsetX,
                            f = l.offsetY;
                        h.enable(h.SCISSOR_TEST), h.viewport(d, f, _, _), h.scissor(d, f, _, _), h.clear(h.DEPTH_BUFFER_BIT),
                            c && (h.scissor(d + 1, f + 1, _ - 2, _ - 2), r._opaqueQueue._render(e));
                    }
                    i._end(), this._setupShadowReceiverShaderValues(n), z.setRuntimeValueMode(!0), e.pipelineMode = "Forward";
                }
            }, {
                key: "cleanUp",
                value: function() {
                    V.recoverToPool(this._shadowMap), this._shadowMap = null, this._light = null;
                }
            }]), ShadowCasterPass;
        }();
    Zt._tempVector30 = new o(), Zt._tempMatrix0 = new L(), Zt.SHADOW_BIAS = G.propertyNameToID("u_ShadowBias"),
        Zt.SHADOW_LIGHT_DIRECTION = G.propertyNameToID("u_ShadowLightDirection"), Zt.SHADOW_SPLIT_SPHERES = G.propertyNameToID("u_ShadowSplitSpheres"),
        Zt.SHADOW_MATRICES = G.propertyNameToID("u_ShadowMatrices"), Zt.SHADOW_MAP_SIZE = G.propertyNameToID("u_ShadowMapSize"),
        Zt.SHADOW_MAP = G.propertyNameToID("u_ShadowMap"), Zt.SHADOW_PARAMS = G.propertyNameToID("u_ShadowParams"),
        Zt._maxCascades = 4, Zt._cascadesSplitDistance = new Array(Zt._maxCascades + 1),
        Zt._frustumPlanes = new Array(new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o()), new Ee(new o())),
        (jt = e.AmbientMode || (e.AmbientMode = {}))[jt.SolidColor = 0] = "SolidColor",
        jt[jt.SphericalHarmonics = 1] = "SphericalHarmonics";
    var qt = function(r) {
        function Scene3D() {
            var r;
            _classCallCheck(this, Scene3D), (r = _possibleConstructorReturn(this, _getPrototypeOf(Scene3D).call(this)))._lightCount = 0,
                r._pointLights = new Rt(), r._spotLights = new Rt(), r._directionLights = new Ct(),
                r._alternateLights = new Mt(), r._lightmaps = [], r._skyRenderer = new Be(), r._input = new pt(),
                r._timer = t.ILaya.timer, r._time = 0, r._shCoefficients = new Array(7), r._ambientMode = e.AmbientMode.SolidColor,
                r._ambientSphericalHarmonics = new Te(), r._ambientSphericalHarmonicsIntensity = 1,
                r._reflectionDecodeFormat = t.TextureDecodeFormat.Normal, r._reflectionIntensity = 1,
                r._collsionTestList = [], r._renders = new ie(), r._opaqueQueue = new Gt(!1), r._transparentQueue = new Gt(!0),
                r._cameraPool = [], r._animatorPool = new ie(), r._scriptPool = new Array(), r._tempScriptPool = new Array(),
                r._needClearScriptPool = !1, r._reflectionCubeHDRParams = new i(), r.currentCreationLayer = Math.pow(2, 0),
                r.enableLight = !0, r._key = new t.SubmitKey(), r._pickIdToSprite = new Object(),
                r._reflectionMode = 0, y._enablePhysics && (r._physicsSimulation = new Tt(Scene3D.physicsSettings)),
                r._shaderValues = new z(null), r.enableFog = !1, r.fogStart = 300, r.fogRange = 1e3,
                r.fogColor = new o(.7, .7, .7), r.ambientColor = new o(.212, .227, .259), r.reflectionIntensity = 1,
                r.reflection = St.blackTexture;
            for (var n = 0; n < 7; n++) r._shCoefficients[n] = new i();
            if (r._shaderValues.setVector(Scene3D.REFLECTIONCUBE_HDR_PARAMS, r._reflectionCubeHDRParams),
                t.Render.supportWebGLPlusCulling && (r._cullingBufferIndices = new Int32Array(1024),
                    r._cullingBufferResult = new Int32Array(1024)), r._scene = _assertThisInitialized(r),
                r._input.__init__(t.Render.canvas, _assertThisInitialized(r)), Scene3D.octreeCulling && (r._octree = new Wt(Scene3D.octreeInitialSize, Scene3D.octreeInitialCenter, Scene3D.octreeMinNodeSize, Scene3D.octreeLooseness)),
                de.debugFrustumCulling) {
                r._debugTool = new Ut();
                var a = new xt();
                a.renderQueue = j.RENDERQUEUE_TRANSPARENT, a.alphaTest = !1, a.depthWrite = !1,
                    a.cull = Z.CULL_BACK, a.blend = Z.BLEND_ENABLE_ALL, a.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                    a.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, a.depthTest = Z.DEPTHTEST_LESS, r._debugTool.pixelLineRenderer.sharedMaterial = a;
            }
            return r;
        }
        return _inherits(Scene3D, t.Sprite), _createClass(Scene3D, [{
            key: "_applySHCoefficients",
            value: function(e, t) {
                for (var r = this._shCoefficients, n = 0; n < 3; n++) {
                    var i = r[n],
                        a = r[n + 3];
                    i.setValue(e.getCoefficient(n, 3) * t, e.getCoefficient(n, 1) * t, e.getCoefficient(n, 2) * t, (e.getCoefficient(n, 0) - e.getCoefficient(n, 6)) * t),
                        a.setValue(e.getCoefficient(n, 4) * t, e.getCoefficient(n, 5) * t, 3 * e.getCoefficient(n, 6) * t, e.getCoefficient(n, 7) * t);
                }
                r[6].setValue(e.getCoefficient(0, 8) * t, e.getCoefficient(1, 8) * t, e.getCoefficient(2, 8) * t, 1);
                var o = this._shaderValues;
                o.setVector(Scene3D.AMBIENTSHAR, r[0]), o.setVector(Scene3D.AMBIENTSHAG, r[1]),
                    o.setVector(Scene3D.AMBIENTSHAB, r[2]), o.setVector(Scene3D.AMBIENTSHBR, r[3]),
                    o.setVector(Scene3D.AMBIENTSHBG, r[4]), o.setVector(Scene3D.AMBIENTSHBB, r[5]),
                    o.setVector(Scene3D.AMBIENTSHC, r[6]);
            }
        }, {
            key: "_update",
            value: function() {
                var e = this.timer._delta / 1e3;
                this._time += e, this._shaderValues.setNumber(Scene3D.TIME, this._time);
                var t = this._physicsSimulation;
                y._enablePhysics && !Tt.disableSimulation && (t._updatePhysicsTransformFromRender(),
                        mt._addUpdateList = !1, t._simulate(e), t._updateCharacters(), mt._addUpdateList = !0,
                        t._updateCollisions(), t._eventScripts()), this._input._update(), this._clearScript(),
                    this._updateScript(), N._update(this), this._lateUpdateScript();
            }
        }, {
            key: "_binarySearchIndexInCameraPool",
            value: function(e) {
                for (var t, r = 0, n = this._cameraPool.length - 1; r <= n;) {
                    t = Math.floor((r + n) / 2);
                    var i = this._cameraPool[t]._renderingOrder;
                    if (i == e._renderingOrder) return t;
                    i > e._renderingOrder ? n = t - 1 : r = t + 1;
                }
                return r;
            }
        }, {
            key: "_allotPickColorByID",
            value: function(e, t) {
                var r = Math.floor(e / 65025);
                e -= 255 * r * 255;
                var n = Math.floor(e / 255),
                    i = e -= 255 * n;
                t.x = r / 255, t.y = n / 255, t.z = i / 255, t.w = 1;
            }
        }, {
            key: "_searchIDByPickColor",
            value: function(e) {
                return 255 * e.x * 255 + 255 * e.y + e.z;
            }
        }, {
            key: "onEnable",
            value: function() {
                this._input._onCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "onDisable",
            value: function() {
                this._input._offCanvasEvent(t.Render.canvas);
            }
        }, {
            key: "_setCreateURL",
            value: function(e) {
                this._url = t.URL.formatURL(e);
            }
        }, {
            key: "_getGroup",
            value: function() {
                return this._group;
            }
        }, {
            key: "_setGroup",
            value: function(e) {
                this._group = e;
            }
        }, {
            key: "_clearScript",
            value: function() {
                if (this._needClearScriptPool) {
                    for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                        var n = e[t];
                        n && (n._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(n));
                    }
                    this._scriptPool = this._tempScriptPool, e.length = 0, this._tempScriptPool = e,
                        this._needClearScriptPool = !1;
                }
            }
        }, {
            key: "_updateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onUpdate();
                }
            }
        }, {
            key: "_lateUpdateScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onLateUpdate();
                }
            }
        }, {
            key: "_onActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onActive", this).call(this), t.ILaya.stage._scene3Ds.push(this);
            }
        }, {
            key: "_onInActive",
            value: function() {
                _get(_getPrototypeOf(Scene3D.prototype), "_onInActive", this).call(this);
                var e = t.ILaya.stage._scene3Ds;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_prepareSceneToRender",
            value: function() {
                var e = this._shaderValues;
                if (s._config._multiLighting) {
                    var t = Scene3D._lightTexture,
                        r = Scene3D._lightPixles,
                        n = t.width,
                        i = 4 * n,
                        a = 0,
                        l = this._directionLights._length,
                        u = this._directionLights._elements;
                    if (l > 0) {
                        var c = this._directionLights.getSunLight();
                        this._mainLight = u[c];
                        for (var h = 0; h < l; h++, a++) {
                            var _ = (y = u[h])._direction,
                                d = y._intensityColor,
                                f = i * a;
                            o.scale(y.color, y._intensity, d), y.transform.worldMatrix.getForward(_), o.normalize(_, _),
                                r[f] = d.x, r[f + 1] = d.y, r[f + 2] = d.z, r[f + 4] = _.x, r[f + 5] = _.y, r[f + 6] = _.z,
                                h == c && (e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, d), e.setVector3(Scene3D.SUNLIGHTDIRECTION, _));
                        }
                        e.addDefine(Qe.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_DIRECTIONLIGHT);
                    var m = this._pointLights._length;
                    if (m > 0) {
                        var T = this._pointLights._elements;
                        for (h = 0; h < m; h++, a++) {
                            var p = (S = T[h]).transform.position;
                            d = S._intensityColor, f = i * a;
                            o.scale(S.color, S._intensity, d), r[f] = d.x, r[f + 1] = d.y, r[f + 2] = d.z, r[f + 3] = S.range,
                                r[f + 4] = p.x, r[f + 5] = p.y, r[f + 6] = p.z;
                        }
                        e.addDefine(Qe.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_POINTLIGHT);
                    var v = this._spotLights._length;
                    if (v > 0) {
                        var E = this._spotLights._elements;
                        for (h = 0; h < v; h++, a++) {
                            var g = E[h];
                            _ = g._direction, p = g.transform.position, d = g._intensityColor, f = i * a;
                            o.scale(g.color, g._intensity, d), g.transform.worldMatrix.getForward(_), o.normalize(_, _),
                                r[f] = d.x, r[f + 1] = d.y, r[f + 2] = d.z, r[f + 3] = g.range, r[f + 4] = p.x,
                                r[f + 5] = p.y, r[f + 6] = p.z, r[f + 7] = g.spotAngle * Math.PI / 180, r[f + 8] = _.x,
                                r[f + 9] = _.y, r[f + 10] = _.z;
                        }
                        e.addDefine(Qe.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_SPOTLIGHT);
                    a > 0 && t.setSubPixels(0, 0, n, a, r, 0), e.setTexture(Scene3D.LIGHTBUFFER, t),
                        e.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights._length), e.setTexture(Scene3D.CLUSTERBUFFER, me.instance._clusterTexture);
                } else {
                    if (this._directionLights._length > 0) {
                        var y = this._directionLights._elements[0];
                        this._mainLight = y, o.scale(y.color, y._intensity, y._intensityColor), y.transform.worldMatrix.getForward(y._direction),
                            o.normalize(y._direction, y._direction), e.setVector3(Scene3D.LIGHTDIRCOLOR, y._intensityColor),
                            e.setVector3(Scene3D.LIGHTDIRECTION, y._direction), e.setVector3(Scene3D.SUNLIGHTDIRCOLOR, y._intensityColor),
                            e.setVector3(Scene3D.SUNLIGHTDIRECTION, y._direction), e.addDefine(Qe.SHADERDEFINE_DIRECTIONLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_DIRECTIONLIGHT);
                    if (this._pointLights._length > 0) {
                        var S = this._pointLights._elements[0];
                        o.scale(S.color, S._intensity, S._intensityColor), e.setVector3(Scene3D.POINTLIGHTCOLOR, S._intensityColor),
                            e.setVector3(Scene3D.POINTLIGHTPOS, S.transform.position), e.setNumber(Scene3D.POINTLIGHTRANGE, S.range),
                            e.addDefine(Qe.SHADERDEFINE_POINTLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_POINTLIGHT);
                    if (this._spotLights._length > 0) {
                        var R = this._spotLights._elements[0];
                        o.scale(R.color, R._intensity, R._intensityColor), e.setVector3(Scene3D.SPOTLIGHTCOLOR, R._intensityColor),
                            e.setVector3(Scene3D.SPOTLIGHTPOS, R.transform.position), R.transform.worldMatrix.getForward(R._direction),
                            o.normalize(R._direction, R._direction), e.setVector3(Scene3D.SPOTLIGHTDIRECTION, R._direction),
                            e.setNumber(Scene3D.SPOTLIGHTRANGE, R.range), e.setNumber(Scene3D.SPOTLIGHTSPOTANGLE, R.spotAngle * Math.PI / 180),
                            e.addDefine(Qe.SHADERDEFINE_SPOTLIGHT);
                    } else e.removeDefine(Qe.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }, {
            key: "_addScript",
            value: function(e) {
                var t = this._scriptPool;
                e._indexInPool = t.length, t.push(e);
            }
        }, {
            key: "_removeScript",
            value: function(e) {
                this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this._needClearScriptPool = !0;
            }
        }, {
            key: "_preRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onPreRender();
                }
            }
        }, {
            key: "_postRenderScript",
            value: function() {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var n = e[t];
                    n && n.enabled && n.onPostRender();
                }
            }
        }, {
            key: "_addCamera",
            value: function(e) {
                for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, n = this._cameraPool.length; t < n && this._cameraPool[t]._renderingOrder <= r;) t++;
                this._cameraPool.splice(t, 0, e);
            }
        }, {
            key: "_removeCamera",
            value: function(e) {
                this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
            }
        }, {
            key: "_preCulling",
            value: function(e, t, r, n) {
                var i = de._cameraCullInfo;
                i.position = t._transform.position, i.cullingMask = t.cullingMask, i.boundFrustum = t.boundFrustum,
                    i.useOcclusionCulling = t.useOcclusionCulling, de.renderObjectCulling(i, this, e, r, n, !1);
            }
        }, {
            key: "_clear",
            value: function(r, n) {
                var i, a, o, s = n.viewport,
                    l = n.camera,
                    u = l._getRenderTexture(),
                    c = s.width,
                    h = s.height;
                l._needInternalRenderTexture() ? (i = 0, a = 0) : (i = s.x, a = l._getCanvasHeight() - s.y - h),
                    r.viewport(i, a, c, h);
                var _ = l.clearFlag;
                switch (_ !== e.CameraClearFlags.Sky || l.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (_ = e.CameraClearFlags.SolidColor),
                    _) {
                    case e.CameraClearFlags.SolidColor:
                        var d = l.clearColor;
                        if (r.enable(r.SCISSOR_TEST), r.scissor(i, a, c, h), d ? r.clearColor(d.x, d.y, d.z, d.w) : r.clearColor(0, 0, 0, 0),
                            u) switch (o = r.COLOR_BUFFER_BIT, u.depthStencilFormat) {
                            case t.RenderTextureDepthFormat.DEPTH_16:
                                o |= r.DEPTH_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.STENCIL_8:
                                o |= r.STENCIL_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                                o |= r.DEPTH_BUFFER_BIT, o |= r.STENCIL_BUFFER_BIT;
                        } else o = r.COLOR_BUFFER_BIT | r.DEPTH_BUFFER_BIT;
                        t.WebGLContext.setDepthMask(r, !0), r.clear(o), r.disable(r.SCISSOR_TEST);
                        break;

                    case e.CameraClearFlags.Sky:
                    case e.CameraClearFlags.DepthOnly:
                        if (r.enable(r.SCISSOR_TEST), r.scissor(i, a, c, h), u) switch (u.depthStencilFormat) {
                            case t.RenderTextureDepthFormat.DEPTH_16:
                                o = r.DEPTH_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.STENCIL_8:
                                o = r.STENCIL_BUFFER_BIT;
                                break;

                            case t.RenderTextureDepthFormat.DEPTHSTENCIL_24_8:
                                o = r.DEPTH_BUFFER_BIT | r.STENCIL_BUFFER_BIT;
                        } else o = r.DEPTH_BUFFER_BIT;
                        t.WebGLContext.setDepthMask(r, !0), r.clear(o), r.disable(r.SCISSOR_TEST);
                        break;

                    case e.CameraClearFlags.Nothing:
                        break;

                    default:
                        throw new Error("Scene3D:camera clearFlag invalid.");
                }
            }
        }, {
            key: "_renderScene",
            value: function(t) {
                var r = t.camera;
                if (this._opaqueQueue._render(t), r.clearFlag === e.CameraClearFlags.Sky && (r.skyRenderer._isAvailable() ? r.skyRenderer._render(t) : this._skyRenderer._isAvailable() && this._skyRenderer._render(t)),
                    this._transparentQueue._render(t), de.debugFrustumCulling)
                    for (var n = this._debugTool._render._renderElements, i = 0, a = n.length; i < a; i++) n[i]._update(this, t, null, null),
                        n[i]._render(t);
            }
        }, {
            key: "_parse",
            value: function(e, r) {
                var n = e.lightmaps;
                if (n) {
                    for (var i = n.length, a = new Array(i), o = 0; o < i; o++) {
                        var s = new Xt(),
                            l = n[o];
                        l.path ? s.lightmapColor = t.Loader.getRes(l.path) : (s.lightmapColor = t.Loader.getRes(l.color.path),
                            l.direction && (s.lightmapDirection = t.Loader.getRes(l.direction.path))), a[o] = s;
                    }
                    this.lightmaps = a;
                }
                var u = e.ambientColor;
                if (u) {
                    var c = this.ambientColor;
                    c.fromArray(u), this.ambientColor = c;
                }
                var h = e.sky;
                if (h) switch (this._skyRenderer.material = t.Loader.getRes(h.material.path), h.mesh) {
                    case "SkyBox":
                        this._skyRenderer.mesh = Ve.instance;
                        break;

                    case "SkyDome":
                        this._skyRenderer.mesh = yt.instance;
                        break;

                    default:
                        this.skyRenderer.mesh = Ve.instance;
                }
                this.enableFog = e.enableFog, this.fogStart = e.fogStart, this.fogRange = e.fogRange;
                var _ = e.fogColor;
                if (_) {
                    var d = this.fogColor;
                    d.fromArray(_), this.fogColor = d;
                }
                var f = e.ambientSphericalHarmonics;
                if (f) {
                    var m = this.ambientSphericalHarmonics;
                    for (o = 0; o < 3; o++) {
                        var T = 9 * o;
                        m.setCoefficients(o, f[T], f[T + 1], f[T + 2], f[T + 3], f[T + 4], f[T + 5], f[T + 6], f[T + 7], f[T + 8]);
                    }
                    this.ambientSphericalHarmonics = m;
                }
                var p = e.reflection;
                null != p && (this.reflection = t.Loader.getRes(p));
                var v = e.reflectionDecodingFormat;
                null != v && (this.reflectionDecodingFormat = v);
                var E = e.ambientMode;
                null != E && (this.ambientMode = E);
                var g = e.ambientSphericalHarmonicsIntensity;
                null != g && (this.ambientSphericalHarmonicsIntensity = g);
                var y = e.reflectionIntensity;
                null != y && (this.reflectionIntensity = y);
            }
        }, {
            key: "_addRenderObject",
            value: function(e) {
                if (this._octree && e._supportOctree) this._octree.add(e);
                else if (this._renders.add(e),
                    t.Render.supportWebGLPlusCulling) {
                    var r = e._getIndexInList(),
                        n = this._cullingBufferIndices.length;
                    if (r >= n) {
                        var i = this._cullingBufferIndices,
                            a = this._cullingBufferResult;
                        this._cullingBufferIndices = new Int32Array(n + 1024), this._cullingBufferResult = new Int32Array(n + 1024),
                            this._cullingBufferIndices.set(i, 0), this._cullingBufferResult.set(a, 0);
                    }
                    this._cullingBufferIndices[r] = e._cullingBufferIndex;
                }
            }
        }, {
            key: "_removeRenderObject",
            value: function(e) {
                var r;
                this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (r = this._renders.elements[this._renders.length - 1]),
                    this._renders.remove(e), t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[r._getIndexInList()] = r._cullingBufferIndex));
            }
        }, {
            key: "_getRenderQueue",
            value: function(e) {
                return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(Scene3D.prototype), "destroy", this).call(this, e),
                    this._skyRenderer.destroy(), this._skyRenderer = null, this._directionLights = null,
                    this._pointLights = null, this._spotLights = null, this._alternateLights = null,
                    this._lightmaps = null, this._shaderValues = null, this._renders = null, this._cameraPool = null,
                    this._octree = null, this._physicsSimulation && this._physicsSimulation._destroy(),
                    t.Loader.clearRes(this.url));
            }
        }, {
            key: "render",
            value: function(e, r, n) {
                e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
            }
        }, {
            key: "renderSubmit",
            value: function() {
                var e, r, n;
                t.LayaGL.instance;
                for (this._prepareSceneToRender(), e = 0, n = (r = this._cameraPool.length) - 1; e < r; e++) {
                    t.Render.supportWebGLPlusRendering && z.setRuntimeValueMode(e == n);
                    var i = this._cameraPool[e];
                    i.enableRender && i.render();
                }
                return t.Context.set2DRenderConfig(), 1;
            }
        }, {
            key: "getRenderType",
            value: function() {
                return 0;
            }
        }, {
            key: "releaseRender",
            value: function() {}
        }, {
            key: "reUse",
            value: function(e, t) {
                return 0;
            }
        }, {
            key: "setlightmaps",
            value: function(e) {
                for (var t = this._lightmaps, r = 0, n = t.length; r < n; r++) t[r].lightmapColor._removeReference();
                if (!e) throw new Error("Scene3D: value value can't be null.");
                var i = e.length;
                for (t.length = i, r = 0; r < i; r++) {
                    var a = e[r];
                    a._addReference(), t[r] || (t[r] = new Xt()), t[r].lightmapColor = a;
                }
            }
        }, {
            key: "getlightmaps",
            value: function() {
                for (var e = new Array(this._lightmaps.length), t = 0; t < this._lightmaps.length; t++) e[t] = this._lightmaps[t].lightmapColor;
                return e;
            }
        }, {
            key: "url",
            get: function() {
                return this._url;
            }
        }, {
            key: "enableFog",
            get: function() {
                return this._enableFog;
            },
            set: function(e) {
                this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(Qe.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(Qe.SHADERDEFINE_FOG));
            }
        }, {
            key: "fogColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.FOGCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.FOGCOLOR, e);
            }
        }, {
            key: "fogStart",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGSTART);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGSTART, e);
            }
        }, {
            key: "fogRange",
            get: function() {
                return this._shaderValues.getNumber(Scene3D.FOGRANGE);
            },
            set: function(e) {
                this._shaderValues.setNumber(Scene3D.FOGRANGE, e);
            }
        }, {
            key: "ambientMode",
            get: function() {
                return this._ambientMode;
            },
            set: function(t) {
                if (this._ambientMode !== t) {
                    switch (t) {
                        case e.AmbientMode.SolidColor:
                            this._shaderValues.removeDefine(Qe.SHADERDEFINE_GI_AMBIENT_SH);
                            break;

                        case e.AmbientMode.SphericalHarmonics:
                            this._shaderValues.addDefine(Qe.SHADERDEFINE_GI_AMBIENT_SH);
                            break;

                        default:
                            throw "Scene3D: unknown ambientMode.";
                    }
                    this._ambientMode = t;
                }
            }
        }, {
            key: "ambientColor",
            get: function() {
                return this._shaderValues.getVector3(Scene3D.AMBIENTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector3(Scene3D.AMBIENTCOLOR, e);
            }
        }, {
            key: "ambientSphericalHarmonics",
            get: function() {
                return this._ambientSphericalHarmonics;
            },
            set: function(e) {
                var t = e || Te._default;
                this._applySHCoefficients(t, Math.pow(this._ambientSphericalHarmonicsIntensity, 2.2)),
                    this._ambientSphericalHarmonics != e && e.cloneTo(this._ambientSphericalHarmonics);
            }
        }, {
            key: "ambientSphericalHarmonicsIntensity",
            get: function() {
                return this._ambientSphericalHarmonicsIntensity;
            },
            set: function(e) {
                if (e = Math.max(Math.min(e, 8), 0), this._ambientSphericalHarmonicsIntensity !== e) {
                    var t = this._ambientSphericalHarmonics || Te._default;
                    this._applySHCoefficients(t, Math.pow(e, 2.2)), this._ambientSphericalHarmonicsIntensity = e;
                }
            }
        }, {
            key: "reflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || St.blackTexture),
                    this._reflection = e);
            }
        }, {
            key: "reflectionDecodingFormat",
            get: function() {
                return this._reflectionDecodeFormat;
            },
            set: function(e) {
                this._reflectionDecodeFormat != e && (this._reflectionCubeHDRParams.x = this._reflectionIntensity,
                    this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                    this._reflectionDecodeFormat = e);
            }
        }, {
            key: "reflectionIntensity",
            get: function() {
                return this._reflectionIntensity;
            },
            set: function(e) {
                e = Math.max(Math.min(e, 1), 0), this._reflectionCubeHDRParams.x = e, this._reflectionDecodeFormat == t.TextureDecodeFormat.RGBM && (this._reflectionCubeHDRParams.x *= 5),
                    this._reflectionIntensity = e;
            }
        }, {
            key: "skyRenderer",
            get: function() {
                return this._skyRenderer;
            }
        }, {
            key: "physicsSimulation",
            get: function() {
                return this._physicsSimulation;
            }
        }, {
            key: "timer",
            get: function() {
                return this._timer;
            },
            set: function(e) {
                this._timer = e;
            }
        }, {
            key: "input",
            get: function() {
                return this._input;
            }
        }, {
            key: "lightmaps",
            get: function() {
                return this._lightmaps.slice();
            },
            set: function(e) {
                var t = this._lightmaps;
                if (t)
                    for (var r = 0, n = t.length; r < n; r++) {
                        (a = t[r]).lightmapColor._removeReference(), a.lightmapDirection._removeReference();
                    }
                if (e) {
                    var i = e.length;
                    for (t.length = i, r = 0; r < i; r++) {
                        var a;
                        (a = e[r]).lightmapColor && a.lightmapColor._addReference(), a.lightmapDirection && a.lightmapDirection._addReference(),
                            t[r] = a;
                    }
                } else t.length = 0;
            }
        }, {
            key: "customReflection",
            get: function() {
                return this._reflection;
            },
            set: function(e) {
                this._reflection != e && (this._shaderValues.setTexture(Scene3D.REFLECTIONTEXTURE, e || St.blackTexture),
                    this._reflection = e);
            }
        }, {
            key: "reflectionMode",
            get: function() {
                return this._reflectionMode;
            },
            set: function(e) {
                this._reflectionMode = e;
            }
        }], [{
            key: "__init__",
            value: function() {
                var r = s._config;
                if (r._multiLighting) {
                    var n = r.maxLightCount,
                        i = r.lightClusterCount;
                    me.instance = new me(i.x, i.y, i.z, Math.min(r.maxLightCount, r._maxAreaLightCountPerClusterAverage)),
                        Scene3D._lightTexture = R._createFloatTextureBuffer(4, n), Scene3D._lightTexture.lock = !0,
                        Scene3D._lightPixles = new Float32Array(4 * n * 4);
                }
                Qe.SHADERDEFINE_FOG = G.getDefineByName("FOG"), Qe.SHADERDEFINE_DIRECTIONLIGHT = G.getDefineByName("DIRECTIONLIGHT"),
                    Qe.SHADERDEFINE_POINTLIGHT = G.getDefineByName("POINTLIGHT"), Qe.SHADERDEFINE_SPOTLIGHT = G.getDefineByName("SPOTLIGHT"),
                    Qe.SHADERDEFINE_SHADOW = G.getDefineByName("SHADOW"), Qe.SHADERDEFINE_SHADOW_CASCADE = G.getDefineByName("SHADOW_CASCADE"),
                    Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = G.getDefineByName("SHADOW_SOFT_SHADOW_LOW"),
                    Qe.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = G.getDefineByName("SHADOW_SOFT_SHADOW_HIGH"),
                    Qe.SHADERDEFINE_GI_AMBIENT_SH = G.getDefineByName("GI_AMBIENT_SH");
                var a = s._config,
                    o = Scene3D._configDefineValues;
                switch (a._multiLighting || o.add(G.SHADERDEFINE_LEGACYSINGALLIGHTING), t.LayaGL.layaGPUInstance._isWebGL2 ? o.add(G.SHADERDEFINE_GRAPHICS_API_GLES3) : o.add(G.SHADERDEFINE_GRAPHICS_API_GLES2),
                    a.pbrRenderQuality) {
                    case e.PBRRenderQuality.High:
                        o.add(ee.SHADERDEFINE_LAYA_PBR_BRDF_HIGH);
                        break;

                    case e.PBRRenderQuality.Low:
                        o.add(ee.SHADERDEFINE_LAYA_PBR_BRDF_LOW);
                        break;

                    default:
                        throw "Scene3D:unknown shader quality.";
                }
            }
        }, {
            key: "load",
            value: function(e, r) {
                t.ILaya.loader.create(e, r, null, Scene3D.HIERARCHY);
            }
        }]), Scene3D;
    }();
    qt._shadowCasterPass = new Zt(), qt.HIERARCHY = "HIERARCHY", qt.physicsSettings = new Et(),
        qt.octreeCulling = !1, qt.octreeInitialSize = 64, qt.octreeInitialCenter = new o(0, 0, 0),
        qt.octreeMinNodeSize = 2, qt.octreeLooseness = 1.25, qt.REFLECTIONMODE_SKYBOX = 0,
        qt.REFLECTIONMODE_CUSTOM = 1, qt.FOGCOLOR = G.propertyNameToID("u_FogColor"), qt.FOGSTART = G.propertyNameToID("u_FogStart"),
        qt.FOGRANGE = G.propertyNameToID("u_FogRange"), qt.DIRECTIONLIGHTCOUNT = G.propertyNameToID("u_DirationLightCount"),
        qt.LIGHTBUFFER = G.propertyNameToID("u_LightBuffer"), qt.CLUSTERBUFFER = G.propertyNameToID("u_LightClusterBuffer"),
        qt.SUNLIGHTDIRECTION = G.propertyNameToID("u_SunLight.direction"), qt.SUNLIGHTDIRCOLOR = G.propertyNameToID("u_SunLight.color"),
        qt.AMBIENTSHAR = G.propertyNameToID("u_AmbientSHAr"), qt.AMBIENTSHAG = G.propertyNameToID("u_AmbientSHAg"),
        qt.AMBIENTSHAB = G.propertyNameToID("u_AmbientSHAb"), qt.AMBIENTSHBR = G.propertyNameToID("u_AmbientSHBr"),
        qt.AMBIENTSHBG = G.propertyNameToID("u_AmbientSHBg"), qt.AMBIENTSHBB = G.propertyNameToID("u_AmbientSHBb"),
        qt.AMBIENTSHC = G.propertyNameToID("u_AmbientSHC"), qt.REFLECTIONPROBE = G.propertyNameToID("u_ReflectionProbe"),
        qt.REFLECTIONCUBE_HDR_PARAMS = G.propertyNameToID("u_ReflectCubeHDRParams"), qt.LIGHTDIRECTION = G.propertyNameToID("u_DirectionLight.direction"),
        qt.LIGHTDIRCOLOR = G.propertyNameToID("u_DirectionLight.color"), qt.POINTLIGHTPOS = G.propertyNameToID("u_PointLight.position"),
        qt.POINTLIGHTRANGE = G.propertyNameToID("u_PointLight.range"), qt.POINTLIGHTATTENUATION = G.propertyNameToID("u_PointLight.attenuation"),
        qt.POINTLIGHTCOLOR = G.propertyNameToID("u_PointLight.color"), qt.SPOTLIGHTPOS = G.propertyNameToID("u_SpotLight.position"),
        qt.SPOTLIGHTDIRECTION = G.propertyNameToID("u_SpotLight.direction"), qt.SPOTLIGHTSPOTANGLE = G.propertyNameToID("u_SpotLight.spot"),
        qt.SPOTLIGHTRANGE = G.propertyNameToID("u_SpotLight.range"), qt.SPOTLIGHTCOLOR = G.propertyNameToID("u_SpotLight.color"),
        qt.AMBIENTCOLOR = G.propertyNameToID("u_AmbientColor"), qt.REFLECTIONTEXTURE = G.propertyNameToID("u_ReflectTexture"),
        qt.TIME = G.propertyNameToID("u_Time"), qt._configDefineValues = new B();
    var Kt = function(e) {
        function ShaderPass(e, t, r, n) {
            var i;
            for (var a in _classCallCheck(this, ShaderPass), (i = _possibleConstructorReturn(this, _getPrototypeOf(ShaderPass).call(this, t, r, null)))._cacheSharders = {},
                    i._cacheShaderHierarchy = 1, i._renderState = new Z(), i._validDefine = new B(),
                    i._tags = {}, i._owner = e, i._stateMap = n, i.defs) i._validDefine.add(G.getDefineByName(a));
            return i;
        }
        return _inherits(ShaderPass, t.ShaderCompile), _createClass(ShaderPass, [{
            key: "_compileToTree",
            value: function(e, r, n, i, a) {
                var o, s, l, u, c, h, _, d, f, m, T;
                for (f = n; f < r.length; f++)
                    if (!((l = r[f]).length < 1) && 0 !== (h = l.indexOf("//"))) {
                        if (h >= 0 && (l = l.substr(0, h)), o = d || new t.ShaderNode(i), d = null, o.text = l,
                            (h = l.indexOf("#")) >= 0) {
                            for (u = "#", T = h + 1, m = l.length; T < m; T++) {
                                var p = l.charAt(T);
                                if (" " === p || "\t" === p || "?" === p) break;
                                u += p;
                            }
                            switch (o.name = u, u) {
                                case "#ifdef":
                                case "#ifndef":
                                    if (o.setParent(e), e = o, a)
                                        for (_ = l.substr(T).split(t.ShaderCompile._splitToWordExps3),
                                            T = 0; T < _.length; T++)(l = _[T]).length && (a[l] = !0);
                                    continue;

                                case "#if":
                                case "#elif":
                                    if (o.setParent(e), e = o, a)
                                        for (_ = l.substr(T).split(t.ShaderCompile._splitToWordExps3),
                                            T = 0; T < _.length; T++)(l = _[T]).length && "defined" != l && (a[l] = !0);
                                    continue;

                                case "#else":
                                    s = (e = e.parent).childs[e.childs.length - 1], o.setParent(e), e = o;
                                    continue;

                                case "#endif":
                                    s = (e = e.parent).childs[e.childs.length - 1], o.setParent(e);
                                    continue;

                                case "#include":
                                    _ = t.ShaderCompile.splitToWords(l, null);
                                    var v = t.ShaderCompile.includes[_[1]];
                                    if (!v) throw "ShaderCompile error no this include file:" + _[1];
                                    if ((h = _[0].indexOf("?")) < 0) {
                                        o.setParent(e), l = v.getWith("with" == _[2] ? _[3] : null), this._compileToTree(o, l.split("\n"), 0, i, a),
                                            o.text = "";
                                        continue;
                                    }
                                    o.setCondition(_[0].substr(h + 1), t.ShaderCompile.IFDEF_YES), o.text = v.getWith("with" == _[2] ? _[3] : null);
                                    break;

                                case "#import":
                                    c = (_ = t.ShaderCompile.splitToWords(l, null))[1], i.push({
                                        node: o,
                                        file: t.ShaderCompile.includes[c],
                                        ofs: o.text.length
                                    });
                                    continue;
                            }
                        } else {
                            if ((s = e.childs[e.childs.length - 1]) && !s.name) {
                                i.length > 0 && t.ShaderCompile.splitToWords(l, s), d = o, s.text += "\n" + l;
                                continue;
                            }
                            i.length > 0 && t.ShaderCompile.splitToWords(l, o);
                        }
                        o.setParent(e);
                    }
            }
        }, {
            key: "_resizeCacheShaderMap",
            value: function(e, t, r) {
                var n = this._cacheShaderHierarchy - 1;
                if (t == n) {
                    for (var i in e)
                        for (var a = e[i], o = 0, s = r - n; o < s; o++) o == s - 1 ? e[0] = a : e = e[0 == o ? i : 0] = {};
                    this._cacheShaderHierarchy = r;
                } else
                    for (var i in e) this._resizeCacheShaderMap(e[i], ++t, r);
            }
        }, {
            key: "_addDebugShaderVariantCollection",
            value: function(e, t, r) {
                var n = G._debugShaderVariantInfo,
                    i = this._owner,
                    a = i._owner,
                    o = e._mask;
                G._getNamesByDefineData(e, t), r.length = o.length;
                for (var s = 0, l = o.length; s < l; s++) r[s] = o[s];
                n ? n.setValue(a, a._subShaders.indexOf(i), i._passes.indexOf(this), t) : G._debugShaderVariantInfo = n = new F(a, a._subShaders.indexOf(i), i._passes.indexOf(this), t),
                    G.debugShaderVariantCollection.add(n);
            }
        }, {
            key: "withCompile",
            value: function(e) {
                var r, n = ShaderPass._debugDefineString,
                    i = ShaderPass._debugDefineMask;
                e._intersectionDefineDatas(this._validDefine), G.debugMode && (r = e._length, this._addDebugShaderVariantCollection(e, n, i)),
                    e.addDefineDatas(qt._configDefineValues);
                var a = this._cacheSharders,
                    o = e._length;
                o > this._cacheShaderHierarchy && (this._resizeCacheShaderMap(a, 0, o), this._cacheShaderHierarchy = o);
                for (var l = e._mask, u = e._length - 1, c = this._cacheShaderHierarchy - 1, h = 0; h < c; h++) {
                    var _ = u < h ? 0 : l[h],
                        d = a[_];
                    d || (a[_] = d = {}), a = d;
                }
                var f = u < c ? 0 : l[c],
                    m = a[f];
                if (m) return m;
                var T = ShaderPass._defineString;
                G._getNamesByDefineData(e, T);
                var p, v, E = s._config,
                    g = E.lightClusterCount,
                    y = {},
                    S = "";
                t.WebGL._isWebGL2 ? (p = "#version 300 es\n\n\t\t\t\t#define attribute in\n\t\t\t\t#define varying out\n\t\t\t\t#define texture2D texture\n",
                        v = "#version 300 es\n\n\t\t\t\t#define varying in\n\t\t\t\tout highp vec4 pc_fragColor;\n\t\t\t\t#define gl_FragColor pc_fragColor\n\t\t\t\t#define gl_FragDepthEXT gl_FragDepth\n\t\t\t\t#define texture2D texture\n\t\t\t\t#define textureCube texture\n\t\t\t\t#define texture2DProj textureProj\n\t\t\t\t#define texture2DLodEXT textureLod\n\t\t\t\t#define texture2DProjLodEXT textureProjLod\n\t\t\t\t#define textureCubeLodEXT textureLod\n\t\t\t\t#define texture2DGradEXT textureGrad\n\t\t\t\t#define texture2DProjGradEXT textureProjGrad\n\t\t\t\t#define textureCubeGradEXT textureGrad\n") : (p = "",
                        v = "#ifdef GL_EXT_shader_texture_lod\n\t\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\n\t\t\t\t#endif\n\t\t\t\t#if !defined(GL_EXT_shader_texture_lod)\n\t\t\t\t\t#define texture1DLodEXT texture1D\n\t\t\t\t\t#define texture2DLodEXT texture2D\n\t\t\t\t\t#define texture2DProjLodEXT texture2DProj\n\t\t\t\t\t#define texture3DLodEXT texture3D\n\t\t\t\t\t#define textureCubeLodEXT textureCube\n\t\t\t\t#endif\n"),
                    S += "#define MAX_LIGHT_COUNT " + E.maxLightCount + "\n", S += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + E._maxAreaLightCountPerClusterAverage + "\n",
                    S += "#define CLUSTER_X_COUNT " + g.x + "\n", S += "#define CLUSTER_Y_COUNT " + g.y + "\n",
                    S += "#define CLUSTER_Z_COUNT " + g.z + "\n", S += "#define SHADER_CAPAILITY_LEVEL " + t.SystemUtils._shaderCapailityLevel + "\n";
                h = 0;
                for (var R = T.length; h < R; h++) {
                    var C = T[h];
                    S += "#define " + C + "\n", y[C] = !0;
                }
                var M = this._VS.toscript(y, []),
                    x = "";
                0 == M[0].indexOf("#version") && (x = M[0] + "\n", M.shift());
                var D = this._PS.toscript(y, []),
                    A = "";
                if (0 == D[0].indexOf("#version") && (A = D[0] + "\n", D.shift()), m = new re(x + p + S + M.join("\n"), A + v + S + D.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this),
                    a[f] = m, G.debugMode) {
                    var L = "",
                        I = "";
                    for (h = 0, R = r; h < R; h++) I += h == R - 1 ? i[h] : i[h] + ",";
                    for (h = 0, R = n.length; h < R; h++) L += h == R - 1 ? n[h] : n[h] + ",";
                    console.log("%cLayaAir: Shader Compile Information---ShaderName:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " DefineMask:[" + I + "] DefineNames:[" + L + "]", "color:green");
                }
                return m;
            }
        }, {
            key: "setTag",
            value: function(e, t) {
                t ? this._tags[e] = t : delete this._tags[e];
            }
        }, {
            key: "getTag",
            value: function(e) {
                return this._tags[e];
            }
        }, {
            key: "renderState",
            get: function() {
                return this._renderState;
            }
        }]), ShaderPass;
    }();
    Kt._defineString = [], Kt._debugDefineString = [], Kt._debugDefineMask = [];
    var Jt, $t = function() {
        function SubShader(e, t) {
            _classCallCheck(this, SubShader), this._flags = {}, this._passes = [], this._attributeMap = e,
                this._uniformMap = t;
        }
        return _createClass(SubShader, [{
            key: "setFlag",
            value: function(e, t) {
                t ? this._flags[e] = t : delete this._flags[e];
            }
        }, {
            key: "getFlag",
            value: function(e) {
                return this._flags[e];
            }
        }, {
            key: "addShaderPass",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "Forward",
                    i = new Kt(this, e, t, r);
                return i._pipelineMode = n, this._passes.push(i), i;
            }
        }]), SubShader;
    }();
    (Jt = e.PBRSpecularSmoothnessSource || (e.PBRSpecularSmoothnessSource = {}))[Jt.SpecularTextureAlpha = 0] = "SpecularTextureAlpha",
    Jt[Jt.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var er = function(e) {
        function PBRSpecularMaterial() {
            var e;
            return _classCallCheck(this, PBRSpecularMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRSpecularMaterial).call(this))).setShaderName("PBRSpecular"),
                e._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, new i(.2, .2, .2, 1)),
                e;
        }
        return _inherits(PBRSpecularMaterial, ee), _createClass(PBRSpecularMaterial, [{
            key: "clone",
            value: function() {
                var e = new PBRSpecularMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "specularTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRSpecularMaterial.SPECULARTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE),
                    this._shaderValues.setTexture(PBRSpecularMaterial.SPECULARTEXTURE, e);
            }
        }, {
            key: "specularColor",
            get: function() {
                return this._shaderValues.getVector(PBRSpecularMaterial.SPECULARCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(PBRSpecularMaterial.SPECULARCOLOR, e);
            }
        }], [{
            key: "__init__",
            value: function() {
                PBRSpecularMaterial.SHADERDEFINE_SPECULARGLOSSTEXTURE = G.getDefineByName("SPECULARGLOSSTEXTURE"),
                    PBRSpecularMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = G.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                        a_Position: Ne.MESH_POSITION0,
                        a_Normal: Ne.MESH_NORMAL0,
                        a_Tangent0: Ne.MESH_TANGENT0,
                        a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
                        a_BoneIndices: Ne.MESH_BLENDINDICES0,
                        a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
                    },
                    t = {
                        u_Bones: G.PERIOD_CUSTOM,
                        u_MvpMatrix: G.PERIOD_SPRITE,
                        u_WorldMat: G.PERIOD_SPRITE,
                        u_LightmapScaleOffset: G.PERIOD_SPRITE,
                        u_LightMap: G.PERIOD_SPRITE,
                        u_LightMapDirection: G.PERIOD_SPRITE,
                        u_CameraPos: G.PERIOD_CAMERA,
                        u_View: G.PERIOD_CAMERA,
                        u_ProjectionParams: G.PERIOD_CAMERA,
                        u_Viewport: G.PERIOD_CAMERA,
                        u_ViewProjection: G.PERIOD_CAMERA,
                        u_AlphaTestValue: G.PERIOD_MATERIAL,
                        u_AlbedoColor: G.PERIOD_MATERIAL,
                        u_EmissionColor: G.PERIOD_MATERIAL,
                        u_AlbedoTexture: G.PERIOD_MATERIAL,
                        u_NormalTexture: G.PERIOD_MATERIAL,
                        u_ParallaxTexture: G.PERIOD_MATERIAL,
                        u_OcclusionTexture: G.PERIOD_MATERIAL,
                        u_EmissionTexture: G.PERIOD_MATERIAL,
                        u_Smoothness: G.PERIOD_MATERIAL,
                        u_SmoothnessScale: G.PERIOD_MATERIAL,
                        u_occlusionStrength: G.PERIOD_MATERIAL,
                        u_NormalScale: G.PERIOD_MATERIAL,
                        u_ParallaxScale: G.PERIOD_MATERIAL,
                        u_TilingOffset: G.PERIOD_MATERIAL,
                        u_SpecGlossTexture: G.PERIOD_MATERIAL,
                        u_SpecularColor: G.PERIOD_MATERIAL,
                        u_ReflectTexture: G.PERIOD_SCENE,
                        u_ReflectIntensity: G.PERIOD_SCENE,
                        u_AmbientColor: G.PERIOD_SCENE,
                        u_FogStart: G.PERIOD_SCENE,
                        u_FogRange: G.PERIOD_SCENE,
                        u_FogColor: G.PERIOD_SCENE,
                        u_DirationLightCount: G.PERIOD_SCENE,
                        u_LightBuffer: G.PERIOD_SCENE,
                        u_LightClusterBuffer: G.PERIOD_SCENE,
                        u_ShadowBias: G.PERIOD_SCENE,
                        u_ShadowLightDirection: G.PERIOD_SCENE,
                        u_ShadowMap: G.PERIOD_SCENE,
                        u_ShadowParams: G.PERIOD_SCENE,
                        u_ShadowSplitSpheres: G.PERIOD_SCENE,
                        u_ShadowMatrices: G.PERIOD_SCENE,
                        u_ShadowMapSize: G.PERIOD_SCENE,
                        u_AmbientSHAr: G.PERIOD_SCENE,
                        u_AmbientSHAg: G.PERIOD_SCENE,
                        u_AmbientSHAb: G.PERIOD_SCENE,
                        u_AmbientSHBr: G.PERIOD_SCENE,
                        u_AmbientSHBg: G.PERIOD_SCENE,
                        u_AmbientSHBb: G.PERIOD_SCENE,
                        u_AmbientSHC: G.PERIOD_SCENE,
                        u_ReflectionProbe: G.PERIOD_SCENE,
                        u_ReflectCubeHDRParams: G.PERIOD_SCENE,
                        "u_DirectionLight.direction": G.PERIOD_SCENE,
                        "u_DirectionLight.color": G.PERIOD_SCENE,
                        "u_PointLight.position": G.PERIOD_SCENE,
                        "u_PointLight.range": G.PERIOD_SCENE,
                        "u_PointLight.color": G.PERIOD_SCENE,
                        "u_SpotLight.position": G.PERIOD_SCENE,
                        "u_SpotLight.direction": G.PERIOD_SCENE,
                        "u_SpotLight.range": G.PERIOD_SCENE,
                        "u_SpotLight.spot": G.PERIOD_SCENE,
                        "u_SpotLight.color": G.PERIOD_SCENE
                    },
                    r = {
                        s_Cull: G.RENDER_STATE_CULL,
                        s_Blend: G.RENDER_STATE_BLEND,
                        s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: G.RENDER_STATE_BLEND_DST,
                        s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                    },
                    n = G.add("PBRSpecular"),
                    i = new $t(e, t);
                n.addSubShader(i), i.addShaderPass('#include "PBRVSInput.glsl";\r\n#include "Lighting.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#define SETUP_BRDF_INPUT specularSetup\r\n\r\n#include "Lighting.glsl";\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', r, "Forward"),
                    i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', r, "ShadowCaster");
            }
        }]), PBRSpecularMaterial;
    }();
    er.SPECULARTEXTURE = G.propertyNameToID("u_SpecGlossTexture"), er.SPECULARCOLOR = G.propertyNameToID("u_SpecularColor");
    var tr;
    (tr = e.PBRMetallicSmoothnessSource || (e.PBRMetallicSmoothnessSource = {}))[tr.MetallicGlossTextureAlpha = 0] = "MetallicGlossTextureAlpha",
    tr[tr.AlbedoTextureAlpha = 1] = "AlbedoTextureAlpha";
    var rr = function(e) {
        function PBRStandardMaterial() {
            var e;
            return _classCallCheck(this, PBRStandardMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(PBRStandardMaterial).call(this)))._smoothnessSource = 0,
                e.setShaderName("PBR"), e._shaderValues.setNumber(PBRStandardMaterial.METALLIC, 0),
                e;
        }
        return _inherits(PBRStandardMaterial, ee), _createClass(PBRStandardMaterial, [{
            key: "clone",
            value: function() {
                var e = new PBRStandardMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "metallicGlossTexture",
            get: function() {
                return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE),
                    this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, e);
            }
        }, {
            key: "metallic",
            get: function() {
                return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
            },
            set: function(e) {
                this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0, Math.min(1, e)));
            }
        }, {
            key: "smoothnessSource",
            get: function() {
                return this._smoothnessSource;
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA) : this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                    this._smoothnessSource = e;
            }
        }], [{
            key: "__init__",
            value: function() {
                PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = G.getDefineByName("METALLICGLOSSTEXTURE"),
                    PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = G.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
                var e = {
                        a_Position: Ne.MESH_POSITION0,
                        a_Normal: Ne.MESH_NORMAL0,
                        a_Tangent0: Ne.MESH_TANGENT0,
                        a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
                        a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
                        a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
                        a_BoneIndices: Ne.MESH_BLENDINDICES0,
                        a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
                        a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
                    },
                    t = {
                        u_Bones: G.PERIOD_CUSTOM,
                        u_MvpMatrix: G.PERIOD_SPRITE,
                        u_WorldMat: G.PERIOD_SPRITE,
                        u_LightmapScaleOffset: G.PERIOD_SPRITE,
                        u_LightMap: G.PERIOD_SPRITE,
                        u_LightMapDirection: G.PERIOD_SPRITE,
                        u_CameraPos: G.PERIOD_CAMERA,
                        u_View: G.PERIOD_CAMERA,
                        u_ProjectionParams: G.PERIOD_CAMERA,
                        u_Viewport: G.PERIOD_CAMERA,
                        u_ViewProjection: G.PERIOD_CAMERA,
                        u_AlphaTestValue: G.PERIOD_MATERIAL,
                        u_AlbedoColor: G.PERIOD_MATERIAL,
                        u_EmissionColor: G.PERIOD_MATERIAL,
                        u_AlbedoTexture: G.PERIOD_MATERIAL,
                        u_NormalTexture: G.PERIOD_MATERIAL,
                        u_ParallaxTexture: G.PERIOD_MATERIAL,
                        u_OcclusionTexture: G.PERIOD_MATERIAL,
                        u_EmissionTexture: G.PERIOD_MATERIAL,
                        u_Smoothness: G.PERIOD_MATERIAL,
                        u_SmoothnessScale: G.PERIOD_MATERIAL,
                        u_occlusionStrength: G.PERIOD_MATERIAL,
                        u_NormalScale: G.PERIOD_MATERIAL,
                        u_ParallaxScale: G.PERIOD_MATERIAL,
                        u_TilingOffset: G.PERIOD_MATERIAL,
                        u_MetallicGlossTexture: G.PERIOD_MATERIAL,
                        u_Metallic: G.PERIOD_MATERIAL,
                        u_ReflectTexture: G.PERIOD_SCENE,
                        u_ReflectIntensity: G.PERIOD_SCENE,
                        u_AmbientColor: G.PERIOD_SCENE,
                        u_FogStart: G.PERIOD_SCENE,
                        u_FogRange: G.PERIOD_SCENE,
                        u_FogColor: G.PERIOD_SCENE,
                        u_DirationLightCount: G.PERIOD_SCENE,
                        u_LightBuffer: G.PERIOD_SCENE,
                        u_LightClusterBuffer: G.PERIOD_SCENE,
                        u_ShadowBias: G.PERIOD_SCENE,
                        u_ShadowLightDirection: G.PERIOD_SCENE,
                        u_ShadowMap: G.PERIOD_SCENE,
                        u_ShadowParams: G.PERIOD_SCENE,
                        u_ShadowSplitSpheres: G.PERIOD_SCENE,
                        u_ShadowMatrices: G.PERIOD_SCENE,
                        u_ShadowMapSize: G.PERIOD_SCENE,
                        u_AmbientSHAr: G.PERIOD_SCENE,
                        u_AmbientSHAg: G.PERIOD_SCENE,
                        u_AmbientSHAb: G.PERIOD_SCENE,
                        u_AmbientSHBr: G.PERIOD_SCENE,
                        u_AmbientSHBg: G.PERIOD_SCENE,
                        u_AmbientSHBb: G.PERIOD_SCENE,
                        u_AmbientSHC: G.PERIOD_SCENE,
                        u_ReflectionProbe: G.PERIOD_SCENE,
                        u_ReflectCubeHDRParams: G.PERIOD_SCENE,
                        "u_DirectionLight.direction": G.PERIOD_SCENE,
                        "u_DirectionLight.color": G.PERIOD_SCENE,
                        "u_PointLight.position": G.PERIOD_SCENE,
                        "u_PointLight.range": G.PERIOD_SCENE,
                        "u_PointLight.color": G.PERIOD_SCENE,
                        "u_SpotLight.position": G.PERIOD_SCENE,
                        "u_SpotLight.direction": G.PERIOD_SCENE,
                        "u_SpotLight.range": G.PERIOD_SCENE,
                        "u_SpotLight.spot": G.PERIOD_SCENE,
                        "u_SpotLight.color": G.PERIOD_SCENE
                    },
                    r = {
                        s_Cull: G.RENDER_STATE_CULL,
                        s_Blend: G.RENDER_STATE_BLEND,
                        s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                        s_BlendDst: G.RENDER_STATE_BLEND_DST,
                        s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                        s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                    },
                    n = G.add("PBR"),
                    i = new $t(e, t);
                n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRVSInput.glsl";\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n\tvertexForward();\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n#include "PBRFSInput.glsl";\r\n#include "LayaPBRBRDF.glsl";\r\n#include "GlobalIllumination.glsl";\r\n#include "PBRCore.glsl";\r\n\r\nvoid main()\r\n{\r\n\tfragmentForward();\r\n}', r, "Forward"),
                    i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', r, "ShadowCaster");
            }
        }]), PBRStandardMaterial;
    }();
    rr.METALLICGLOSSTEXTURE = G.propertyNameToID("u_MetallicGlossTexture"), rr.METALLIC = G.propertyNameToID("u_Metallic");
    var nr = function(e) {
        function SkyBoxMaterial() {
            var e;
            return _classCallCheck(this, SkyBoxMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyBoxMaterial).call(this))).setShaderName("SkyBox"),
                e.tintColor = new i(.5, .5, .5, .5), e.exposure = 1, e.rotation = 0, e;
        }
        return _inherits(SkyBoxMaterial, j), _createClass(SkyBoxMaterial, [{
            key: "clone",
            value: function() {
                var e = new SkyBoxMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "tintColor",
            get: function() {
                return this._shaderValues.getVector(SkyBoxMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyBoxMaterial.TINTCOLOR, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, e);
            }
        }, {
            key: "rotation",
            get: function() {
                return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
            },
            set: function(e) {
                this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, e);
            }
        }, {
            key: "textureCube",
            get: function() {
                return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
            },
            set: function(e) {
                this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {}
        }]), SkyBoxMaterial;
    }();
    nr.TINTCOLOR = G.propertyNameToID("u_TintColor"), nr.EXPOSURE = G.propertyNameToID("u_Exposure"),
        nr.ROTATION = G.propertyNameToID("u_Rotation"), nr.TEXTURECUBE = G.propertyNameToID("u_CubeTexture");
    var ir = function(e) {
        function SkyProceduralMaterial() {
            var e;
            return _classCallCheck(this, SkyProceduralMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyProceduralMaterial).call(this))).setShaderName("SkyBoxProcedural"),
                e.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY, e.sunSize = .04, e.sunSizeConvergence = 5,
                e.atmosphereThickness = 1, e.skyTint = new i(.5, .5, .5, 1), e.groundTint = new i(.369, .349, .341, 1),
                e.exposure = 1.3, e;
        }
        return _inherits(SkyProceduralMaterial, j), _createClass(SkyProceduralMaterial, [{
            key: "clone",
            value: function() {
                var e = new SkyProceduralMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "sunDisk",
            get: function() {
                return this._sunDisk;
            },
            set: function(e) {
                switch (e) {
                    case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE),
                            this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                        break;

                    case SkyProceduralMaterial.SUN_SIMPLE:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY),
                            this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                        break;

                    case SkyProceduralMaterial.SUN_NODE:
                        this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY),
                            this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                        break;

                    default:
                        throw "SkyBoxProceduralMaterial: unknown sun value.";
                }
                this._sunDisk = e;
            }
        }, {
            key: "sunSize",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, e);
            }
        }, {
            key: "sunSizeConvergence",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, e);
            }
        }, {
            key: "atmosphereThickness",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, e);
            }
        }, {
            key: "skyTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.SKYTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.SKYTINT, e);
            }
        }, {
            key: "groundTint",
            get: function() {
                return this._shaderValues.getVector(SkyProceduralMaterial.GROUNDTINT);
            },
            set: function(e) {
                this._shaderValues.setVector(SkyProceduralMaterial.GROUNDTINT, e);
            }
        }, {
            key: "exposure",
            get: function() {
                return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
            },
            set: function(e) {
                e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = G.getDefineByName("SUN_HIGH_QUALITY"),
                    SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = G.getDefineByName("SUN_SIMPLE");
            }
        }]), SkyProceduralMaterial;
    }();
    ir.SUN_NODE = 0, ir.SUN_SIMPLE = 1, ir.SUN_HIGH_QUALITY = 2, ir.SUNSIZE = G.propertyNameToID("u_SunSize"),
        ir.SUNSIZECONVERGENCE = G.propertyNameToID("u_SunSizeConvergence"), ir.ATMOSPHERETHICKNESS = G.propertyNameToID("u_AtmosphereThickness"),
        ir.SKYTINT = G.propertyNameToID("u_SkyTint"), ir.GROUNDTINT = G.propertyNameToID("u_GroundTint"),
        ir.EXPOSURE = G.propertyNameToID("u_Exposure");
    var ar = function(e) {
        function UnlitMaterial() {
            var e;
            return _classCallCheck(this, UnlitMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(UnlitMaterial).call(this)))._albedoColor = new i(1, 1, 1, 1),
                e._albedoIntensity = 1, e._enableVertexColor = !1, e.setShaderName("Unlit"), e._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, new i(1, 1, 1, 1)),
                e.renderMode = UnlitMaterial.RENDERMODE_OPAQUE, e;
        }
        return _inherits(UnlitMaterial, j), _createClass(UnlitMaterial, [{
            key: "clone",
            value: function() {
                var e = new UnlitMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_ColorR",
            get: function() {
                return this._albedoColor.x;
            },
            set: function(e) {
                this._albedoColor.x = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorG",
            get: function() {
                return this._albedoColor.y;
            },
            set: function(e) {
                this._albedoColor.y = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorB",
            get: function() {
                return this._albedoColor.z;
            },
            set: function(e) {
                this._albedoColor.z = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_ColorA",
            get: function() {
                return this._albedoColor.w;
            },
            set: function(e) {
                this._albedoColor.w = e, this.albedoColor = this._albedoColor;
            }
        }, {
            key: "_AlbedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                if (this._albedoIntensity !== e) {
                    var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                    i.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
                }
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "_Cutoff",
            get: function() {
                return this.alphaTestValue;
            },
            set: function(e) {
                this.alphaTestValue = e;
            }
        }, {
            key: "albedoColorR",
            get: function() {
                return this._ColorR;
            },
            set: function(e) {
                this._ColorR = e;
            }
        }, {
            key: "albedoColorG",
            get: function() {
                return this._ColorG;
            },
            set: function(e) {
                this._ColorG = e;
            }
        }, {
            key: "albedoColorB",
            get: function() {
                return this._ColorB;
            },
            set: function(e) {
                this._ColorB = e;
            }
        }, {
            key: "albedoColorA",
            get: function() {
                return this._ColorA;
            },
            set: function(e) {
                this._ColorA = e;
            }
        }, {
            key: "albedoColor",
            get: function() {
                return this._albedoColor;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(UnlitMaterial.ALBEDOCOLOR);
                i.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(UnlitMaterial.ALBEDOCOLOR, t);
            }
        }, {
            key: "albedoIntensity",
            get: function() {
                return this._albedoIntensity;
            },
            set: function(e) {
                this._AlbedoIntensity = e;
            }
        }, {
            key: "albedoTexture",
            get: function() {
                return this._shaderValues.getTexture(UnlitMaterial.ALBEDOTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE),
                    this._shaderValues.setTexture(UnlitMaterial.ALBEDOTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(UnlitMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(UnlitMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "enableVertexColor",
            get: function() {
                return this._enableVertexColor;
            },
            set: function(e) {
                this._enableVertexColor = e, e ? this._shaderValues.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case UnlitMaterial.RENDERMODE_OPAQUE:
                        this.alphaTest = !1, this.renderQueue = j.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    case UnlitMaterial.RENDERMODE_CUTOUT:
                        this.renderQueue = j.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_DISABLE, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    case UnlitMaterial.RENDERMODE_TRANSPARENT:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_BACK, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS;
                        break;

                    default:
                        throw new Error("UnlitMaterial : renderMode value error.");
                }
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(UnlitMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(UnlitMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(UnlitMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(UnlitMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = G.getDefineByName("ALBEDOTEXTURE"), UnlitMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                    UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = G.getDefineByName("ENABLEVERTEXCOLOR");
            }
        }]), UnlitMaterial;
    }();
    ar.RENDERMODE_OPAQUE = 0, ar.RENDERMODE_CUTOUT = 1, ar.RENDERMODE_TRANSPARENT = 2,
        ar.RENDERMODE_ADDTIVE = 3, ar.ALBEDOTEXTURE = G.propertyNameToID("u_AlbedoTexture"),
        ar.ALBEDOCOLOR = G.propertyNameToID("u_AlbedoColor"), ar.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
        ar.CULL = G.propertyNameToID("s_Cull"), ar.BLEND = G.propertyNameToID("s_Blend"),
        ar.BLEND_SRC = G.propertyNameToID("s_BlendSrc"), ar.BLEND_DST = G.propertyNameToID("s_BlendDst"),
        ar.DEPTH_TEST = G.propertyNameToID("s_DepthTest"), ar.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var or = function(e) {
        function WaterPrimaryMaterial() {
            var e;
            return _classCallCheck(this, WaterPrimaryMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(WaterPrimaryMaterial).call(this))).setShaderName("WaterPrimary"),
                e._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, new i(.172, .463, .435, 0)),
                e._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, .15), e._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, new i(19, 9, -16, -7)),
                e;
        }
        return _inherits(WaterPrimaryMaterial, j), _createClass(WaterPrimaryMaterial, [{
            key: "clone",
            value: function() {
                var e = new WaterPrimaryMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "horizonColor",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.HORIZONCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.HORIZONCOLOR, e);
            }
        }, {
            key: "mainTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(WaterPrimaryMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "normalTexture",
            get: function() {
                return this._shaderValues.getTexture(WaterPrimaryMaterial.NORMALTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE),
                    this._shaderValues.setTexture(WaterPrimaryMaterial.NORMALTEXTURE, e);
            }
        }, {
            key: "waveScale",
            get: function() {
                return this._shaderValues.getNumber(WaterPrimaryMaterial.WAVESCALE);
            },
            set: function(e) {
                this._shaderValues.setNumber(WaterPrimaryMaterial.WAVESCALE, e);
            }
        }, {
            key: "waveSpeed",
            get: function() {
                return this._shaderValues.getVector(WaterPrimaryMaterial.WAVESPEED);
            },
            set: function(e) {
                this._shaderValues.setVector(WaterPrimaryMaterial.WAVESPEED, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                WaterPrimaryMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"),
                    WaterPrimaryMaterial.SHADERDEFINE_NORMALTEXTURE = G.getDefineByName("NORMALTEXTURE");
            }
        }]), WaterPrimaryMaterial;
    }();
    or.HORIZONCOLOR = G.propertyNameToID("u_HorizonColor"), or.MAINTEXTURE = G.propertyNameToID("u_MainTexture"),
        or.NORMALTEXTURE = G.propertyNameToID("u_NormalTexture"), or.WAVESCALE = G.propertyNameToID("u_WaveScale"),
        or.WAVESPEED = G.propertyNameToID("u_WaveSpeed");
    var sr = function MeshSprite3DShaderDeclaration() {
            _classCallCheck(this, MeshSprite3DShaderDeclaration);
        },
        lr = function(e) {
            function MeshRenderer(e) {
                var t;
                return _classCallCheck(this, MeshRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderer).call(this, e)))._revertStaticBatchDefineUV1 = !1,
                    t._projectionViewWorldMatrix = new L(), t;
            }
            return _inherits(MeshRenderer, wt), _createClass(MeshRenderer, [{
                key: "_createRenderElement",
                value: function() {
                    return new kt();
                }
            }, {
                key: "_onMeshChange",
                value: function(e) {
                    if (e) {
                        var t = e.subMeshCount;
                        this._renderElements.length = t;
                        for (var r = 0; r < t; r++) {
                            var n = this._renderElements[r];
                            if (!n) {
                                var i = this.sharedMaterials[r];
                                (n = this._renderElements[r] = this._createRenderElement()).setTransform(this._owner._transform),
                                    n.render = this, n.material = i || q.defaultMaterial;
                            }
                            n.setGeometry(e.getSubMesh(r));
                        }
                    } else this._renderElements.length = 0;
                    this._boundsChange = !0;
                }
            }, {
                key: "_calculateBoundingBox",
                value: function() {
                    var e = this._owner.meshFilter.sharedMesh;
                    if (e) {
                        var r = this._owner.transform.worldMatrix;
                        e.bounds._tranform(r, this._bounds);
                    }
                    if (t.Render.supportWebGLPlusCulling) {
                        var n = this._bounds.getMin(),
                            i = this._bounds.getMax(),
                            a = de._cullingBuffer;
                        a[this._cullingBufferIndex + 1] = n.x, a[this._cullingBufferIndex + 2] = n.y, a[this._cullingBufferIndex + 3] = n.z,
                            a[this._cullingBufferIndex + 4] = i.x, a[this._cullingBufferIndex + 5] = i.y, a[this._cullingBufferIndex + 6] = i.z;
                    }
                }
            }, {
                key: "_needRender",
                value: function(e, t) {
                    return !e || e.intersects(this.bounds._getBoundBox());
                }
            }, {
                key: "_renderUpdate",
                value: function(e, t) {
                    this._applyLightMapParams();
                    var r = e.renderElement;
                    switch (r.renderType) {
                        case bt.RENDERTYPE_NORMAL:
                            this._shaderValues.setMatrix4x4(le.WORLDMATRIX, t.worldMatrix);
                            break;

                        case bt.RENDERTYPE_STATICBATCH:
                            t ? this._shaderValues.setMatrix4x4(le.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(le.WORLDMATRIX, L.DEFAULT),
                                this._shaderValues.hasDefine(sr.SHADERDEFINE_UV1) ? this._revertStaticBatchDefineUV1 = !1 : (this._shaderValues.addDefine(sr.SHADERDEFINE_UV1),
                                    this._revertStaticBatchDefineUV1 = !0), this._shaderValues.setVector(ue.LIGHTMAPSCALEOFFSET, wt._defaultLightmapScaleOffset);
                            break;

                        case bt.RENDERTYPE_VERTEXBATCH:
                            this._shaderValues.setMatrix4x4(le.WORLDMATRIX, L.DEFAULT);
                            break;

                        case bt.RENDERTYPE_INSTANCEBATCH:
                            for (var n = Nt.instance.instanceWorldMatrixData, i = r.instanceBatchElementList, a = i.elements, o = i.length, s = 0; s < o; s++) n.set(a[s]._transform.worldMatrix.elements, 16 * s);
                            var l = Nt.instance.instanceWorldMatrixBuffer;
                            l.orphanStorage(), l.setData(n.buffer, 0, 0, 16 * o * 4), this._shaderValues.addDefine(sr.SHADERDEFINE_GPU_INSTANCE);
                    }
                }
            }, {
                key: "_renderUpdateWithCamera",
                value: function(e, t) {
                    var r = e.projectionViewMatrix;
                    if (r) {
                        var n = e.renderElement;
                        switch (n.renderType) {
                            case bt.RENDERTYPE_NORMAL:
                            case bt.RENDERTYPE_STATICBATCH:
                            case bt.RENDERTYPE_VERTEXBATCH:
                                t ? (L.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(le.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(le.MVPMATRIX, r);
                                break;

                            case bt.RENDERTYPE_INSTANCEBATCH:
                                for (var i = Nt.instance.instanceMVPMatrixData, a = n.instanceBatchElementList, o = a.elements, s = a.length, l = 0; l < s; l++) {
                                    var u = o[l]._transform.worldMatrix;
                                    R.mulMatrixByArray(r.elements, 0, u.elements, 0, i, 16 * l);
                                }
                                var c = Nt.instance.instanceMVPMatrixBuffer;
                                c.orphanStorage(), c.setData(i.buffer, 0, 0, 16 * s * 4);
                        }
                    }
                }
            }, {
                key: "_revertBatchRenderUpdate",
                value: function(e) {
                    switch (e.renderElement.renderType) {
                        case bt.RENDERTYPE_STATICBATCH:
                            this._revertStaticBatchDefineUV1 && this._shaderValues.removeDefine(sr.SHADERDEFINE_UV1),
                                this._shaderValues.setVector(ue.LIGHTMAPSCALEOFFSET, this.lightmapScaleOffset);
                            break;

                        case bt.RENDERTYPE_INSTANCEBATCH:
                            this._shaderValues.removeDefine(sr.SHADERDEFINE_GPU_INSTANCE);
                    }
                }
            }, {
                key: "_destroy",
                value: function() {
                    this._isPartOfStaticBatch && Bt.instance._removeRenderSprite(this._owner), _get(_getPrototypeOf(MeshRenderer.prototype), "_destroy", this).call(this);
                }
            }]), MeshRenderer;
        }(),
        ur = function() {
            function MeshFilter(e) {
                _classCallCheck(this, MeshFilter), this._owner = e;
            }
            return _createClass(MeshFilter, [{
                key: "_getMeshDefine",
                value: function(e, t) {
                    t.length = 0;
                    for (var r = 0, n = e._subMeshes.length; r < n; r++)
                        for (var i = e.getSubMesh(r)._vertexBuffer._vertexDeclaration._vertexElements, a = 0, o = i.length; a < o; a++) {
                            switch (i[a]._elementUsage) {
                                case Ne.MESH_COLOR0:
                                    t.push(sr.SHADERDEFINE_COLOR);
                                    break;

                                case Ne.MESH_TEXTURECOORDINATE0:
                                    t.push(sr.SHADERDEFINE_UV0);
                                    break;

                                case Ne.MESH_TEXTURECOORDINATE1:
                                    t.push(sr.SHADERDEFINE_UV1);
                            }
                        }
                }
            }, {
                key: "destroy",
                value: function() {
                    this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
                }
            }, {
                key: "sharedMesh",
                get: function() {
                    return this._sharedMesh;
                },
                set: function(e) {
                    if (this._sharedMesh !== e) {
                        var t = this._owner._render._shaderValues,
                            r = this._sharedMesh;
                        if (r) {
                            r._removeReference(), this._getMeshDefine(r, MeshFilter._meshVerticeDefine);
                            for (var n = 0, i = MeshFilter._meshVerticeDefine.length; n < i; n++) t.removeDefine(MeshFilter._meshVerticeDefine[n]);
                        }
                        if (e) {
                            e._addReference(), this._getMeshDefine(e, MeshFilter._meshVerticeDefine);
                            for (n = 0, i = MeshFilter._meshVerticeDefine.length; n < i; n++) t.addDefine(MeshFilter._meshVerticeDefine[n]);
                        }
                        this._owner._render._onMeshChange(e), this._sharedMesh = e;
                    }
                }
            }]), MeshFilter;
        }();
    ur._meshVerticeDefine = [];
    var cr = function(r) {
        function SubMeshDynamicBatch() {
            var r;
            _classCallCheck(this, SubMeshDynamicBatch), (r = _possibleConstructorReturn(this, _getPrototypeOf(SubMeshDynamicBatch).call(this)))._bufferState = new Ae();
            var n = t.LayaGL.instance,
                i = Ne.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * SubMeshDynamicBatch.maxIndicesCount;
            r._vertices = new Float32Array(i / 4), r._vertexBuffer = new be(i, n.DYNAMIC_DRAW),
                r._indices = new Int16Array(SubMeshDynamicBatch.maxIndicesCount), r._indexBuffer = new Le(e.IndexFormat.UInt16, r._indices.length, n.DYNAMIC_DRAW);
            var a = r._vertexBuffer._byteLength + r._indexBuffer._byteLength;
            return t.Resource._addMemory(a, a), r;
        }
        return _inherits(SubMeshDynamicBatch, Lt), _createClass(SubMeshDynamicBatch, [{
            key: "_getBatchVertices",
            value: function(e, t, r, n, i, a) {
                var o = e.vertexStride / 4,
                    s = a._vertexBuffer.getFloat32Data(),
                    l = (i.render.lightmapScaleOffset,
                        i._dynamicMultiSubMesh),
                    u = i._dynamicVertexCount;
                i._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, u);
                for (var c = i._dynamicWorldPositions, h = i._dynamicWorldNormals, _ = a._indices, d = 0; d < u; d++) {
                    var f = (l ? _[d] : d) * o,
                        m = (d + r) * o,
                        T = 3 * d,
                        p = m + this._positionOffset;
                    t[p] = c[T], t[p + 1] = c[T + 1], t[p + 2] = c[T + 2], -1 !== this._normalOffset && (t[p = m + this._normalOffset] = h[T],
                        t[p + 1] = h[T + 1], t[p + 2] = h[T + 2]), -1 !== this._colorOffset && (p = m + this._colorOffset,
                        T = f + this._colorOffset, t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2],
                        t[p + 3] = s[T + 3]), -1 !== this._uv0Offset && (p = m + this._uv0Offset, T = f + this._uv0Offset,
                        t[p] = s[T], t[p + 1] = s[T + 1]), -1 !== this._sTangentOffset && (p = m + this._sTangentOffset,
                        T = f + this._sTangentOffset, t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2],
                        t[p + 3] = s[T + 3], p = m + this._sTangentOffset, T = f + this._sTangentOffset,
                        t[p] = s[T], t[p + 1] = s[T + 1], t[p + 2] = s[T + 2], t[p + 3] = s[T + 3]);
                }
            }
        }, {
            key: "_getBatchIndices",
            value: function(e, t, r, n, i, a) {
                var o, s, l, u = i._indices,
                    c = n._isFrontFaceInvert;
                if (a)
                    if (c)
                        for (o = 0, s = u.length; o < s; o += 3) {
                            var h = r + o;
                            e[l = t + o] = h, e[l + 1] = h + 2, e[l + 2] = h + 1;
                        } else
                            for (o = 0, s = u.length; o < s; o += 3) h = r + o, e[l = t + o] = h, e[l + 1] = h + 1,
                                e[l + 2] = h + 2;
                    else if (c)
                    for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = r + u[o],
                        e[l + 1] = r + u[o + 2], e[l + 2] = r + u[o + 1];
                else
                    for (o = 0, s = u.length; o < s; o += 3) e[l = t + o] = r + u[o],
                        e[l + 1] = r + u[o + 1], e[l + 2] = r + u[o + 2];
            }
        }, {
            key: "_flush",
            value: function(e, r) {
                var n = t.LayaGL.instance;
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._bufferState.vertexDeclaration.vertexStride),
                    this._indexBuffer.setData(this._indices, 0, 0, r), n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0);
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                var t = e.renderElement.vertexBatchVertexDeclaration;
                this._bufferState = l.MeshRenderDynamicBatchManager.instance._getBufferState(t),
                    this._positionOffset = t.getVertexElementByUsage(Ne.MESH_POSITION0)._offset / 4;
                var r = t.getVertexElementByUsage(Ne.MESH_NORMAL0);
                this._normalOffset = r ? r._offset / 4 : -1;
                var n = t.getVertexElementByUsage(Ne.MESH_COLOR0);
                this._colorOffset = n ? n._offset / 4 : -1;
                var i = t.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0);
                this._uv0Offset = i ? i._offset / 4 : -1;
                var a = t.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE1);
                this._uv1Offset = a ? a._offset / 4 : -1;
                var o = t.getVertexElementByUsage(Ne.MESH_TANGENT0);
                return this._sTangentOffset = o ? o._offset / 4 : -1, !0;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                for (var r = e.renderElement, n = r.vertexBatchVertexDeclaration, i = r.vertexBatchElementList, a = 0, o = 0, s = (n.vertexStride,
                        0), l = i.length, u = i.elements, c = 0; c < l; c++) {
                    var h = u[c],
                        _ = h._geometry,
                        d = _._indexCount;
                    o + d > SubMeshDynamicBatch.maxIndicesCount && (this._flush(a, o), s++, t.Stat.trianglesFaces += o / 3,
                        a = o = 0);
                    var f = h._transform;
                    this._getBatchVertices(n, this._vertices, a, f, h, _), this._getBatchIndices(this._indices, o, a, f, _, h._dynamicMultiSubMesh),
                        a += h._dynamicVertexCount, o += d;
                }
                this._flush(a, o), s++, t.Stat.renderBatches += s, t.Stat.savedRenderBatches += l - s,
                    t.Stat.trianglesFaces += o / 3;
            }
        }], [{
            key: "__init__",
            value: function() {
                SubMeshDynamicBatch.instance = new SubMeshDynamicBatch();
            }
        }]), SubMeshDynamicBatch;
    }();
    cr.maxAllowVertexCount = 10, cr.maxAllowAttribueCount = 900, cr.maxIndicesCount = 32e3;
    var hr = function(e) {
        function MeshRenderDynamicBatchManager() {
            var e;
            return _classCallCheck(this, MeshRenderDynamicBatchManager), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderDynamicBatchManager).call(this)))._instanceBatchOpaqueMarks = [],
                e._vertexBatchOpaqueMarks = [], e._cacheBufferStates = [], e._updateCountMark = 0,
                e;
        }
        return _inherits(MeshRenderDynamicBatchManager, oe), _createClass(MeshRenderDynamicBatchManager, [{
            key: "getInstanceBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = []),
                    a = i[t] || (i[t] = []),
                    o = a[r] || (a[r] = []);
                return o[n ? 1 : 0] || (o[n ? 1 : 0] = new Pt());
            }
        }, {
            key: "getVertexBatchOpaquaMark",
            value: function(e, t, r, n) {
                var i = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []),
                    a = i[t ? 0 : 1] || (i[t ? 0 : 1] = []),
                    o = a[r] || (a[r] = []);
                return o[n] || (o[n] = new Pt());
            }
        }, {
            key: "_getBufferState",
            value: function(e) {
                var t = this._cacheBufferStates[e.id];
                if (!t) {
                    var r = cr.instance;
                    (t = new Ae()).bind();
                    var n = r._vertexBuffer;
                    n.vertexDeclaration = e, t.applyVertexBuffer(n), t.applyIndexBuffer(r._indexBuffer),
                        t.unBind(), this._cacheBufferStates[e.id] = t;
                }
                return t;
            }
        }, {
            key: "_getBatchRenderElementFromPool",
            value: function() {
                var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
                return e || (e = new kt(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                    e.vertexBatchElementList = new ne(), e.instanceBatchElementList = new ne()), e;
            }
        }, {
            key: "_clear",
            value: function() {
                _get(_getPrototypeOf(MeshRenderDynamicBatchManager.prototype), "_clear", this).call(this),
                    this._updateCountMark++;
            }
        }]), MeshRenderDynamicBatchManager;
    }();
    hr.instance = new hr();
    var _r = function(e) {
            function MeshSprite3D() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                return _classCallCheck(this, MeshSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(MeshSprite3D).call(this, r)))._meshFilter = new ur(_assertThisInitialized(e)),
                    e._render = new lr(_assertThisInitialized(e)), t && (e._meshFilter.sharedMesh = t),
                    e;
            }
            return _inherits(MeshSprite3D, ue), _createClass(MeshSprite3D, [{
                key: "meshFilter",
                get: function() {
                    return this._meshFilter;
                }
            }, {
                key: "meshRenderer",
                get: function() {
                    return this._render;
                }
            }], [{
                key: "__init__",
                value: function() {
                    sr.SHADERDEFINE_UV0 = G.getDefineByName("UV"), sr.SHADERDEFINE_COLOR = G.getDefineByName("COLOR"),
                        sr.SHADERDEFINE_UV1 = G.getDefineByName("UV1"), sr.SHADERDEFINE_GPU_INSTANCE = G.getDefineByName("GPU_INSTANCE"),
                        ce._registerManager(Bt.instance), oe._registerManager(hr.instance);
                }
            }]), _createClass(MeshSprite3D, [{
                key: "_parse",
                value: function(e, r) {
                    _get(_getPrototypeOf(MeshSprite3D.prototype), "_parse", this).call(this, e, r);
                    var n = this.meshRenderer,
                        a = e.lightmapIndex;
                    null != a && (n.lightmapIndex = a);
                    var o = e.lightmapScaleOffset;
                    o && (n.lightmapScaleOffset = new i(o[0], o[1], o[2], o[3])), null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)),
                        null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
                    var s = e.materials;
                    if (s) {
                        var l = n.sharedMaterials,
                            u = s.length;
                        l.length = u;
                        for (var c = 0; c < u; c++) l[c] = t.Loader.getRes(s[c].path);
                        n.sharedMaterials = l;
                    }
                }
            }, {
                key: "_addToInitStaticBatchManager",
                value: function() {
                    this.meshFilter.sharedMesh && Bt.instance._addBatchSprite(this);
                }
            }, {
                key: "_cloneTo",
                value: function(e, t, r) {
                    var n = e;
                    n._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
                    var i = this._render,
                        a = n._render;
                    a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i.castShadow;
                    var o = i.lightmapScaleOffset;
                    o && (a.lightmapScaleOffset = o.clone()), a.lightmapIndex = i.lightmapIndex, a.receiveShadow = i.receiveShadow,
                        a.sortingFudge = i.sortingFudge, _get(_getPrototypeOf(MeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
                }
            }, {
                key: "destroy",
                value: function() {
                    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.destroyed || (_get(_getPrototypeOf(MeshSprite3D.prototype), "destroy", this).call(this, e),
                        this._meshFilter.destroy());
                }
            }, {
                key: "_create",
                value: function() {
                    return new MeshSprite3D();
                }
            }]), MeshSprite3D;
        }(),
        dr = function GradientMode() {
            _classCallCheck(this, GradientMode);
        };
    dr.Blend = 0, dr.Fixed = 1;
    var fr = function() {
            function Gradient(e, t) {
                _classCallCheck(this, Gradient), this._mode = 0, this._maxColorRGBKeysCount = 0,
                    this._maxColorAlphaKeysCount = 0, this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0,
                    this._alphaElements = null, this._rgbElements = null, this._maxColorRGBKeysCount = e,
                    this._maxColorAlphaKeysCount = t, this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
            }
            return _createClass(Gradient, [{
                key: "addColorRGB",
                value: function(e, t) {
                    if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                        var r = 4 * this._colorRGBKeysCount;
                        this._rgbElements[r] = e, this._rgbElements[r + 1] = t.r, this._rgbElements[r + 2] = t.g,
                            this._rgbElements[r + 3] = t.b, this._colorRGBKeysCount++;
                    } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
                }
            }, {
                key: "addColorAlpha",
                value: function(e, t) {
                    if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                        var r = 2 * this._colorAlphaKeysCount;
                        this._alphaElements[r] = e, this._alphaElements[r + 1] = t, this._colorAlphaKeysCount++;
                    } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
                }
            }, {
                key: "updateColorRGB",
                value: function(e, t, r) {
                    if (e < this._colorRGBKeysCount) {
                        var n = 4 * e;
                        this._rgbElements[n] = t, this._rgbElements[n + 1] = r.r, this._rgbElements[n + 2] = r.g,
                            this._rgbElements[n + 3] = r.b;
                    } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
                }
            }, {
                key: "updateColorAlpha",
                value: function(e, t, r) {
                    if (e < this._colorAlphaKeysCount) {
                        var n = 2 * e;
                        this._alphaElements[n] = t, this._alphaElements[n + 1] = r;
                    } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
                }
            }, {
                key: "evaluateColorRGB",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    e = Math.min(Math.max(e, 0), 1);
                    var i = this._rgbElements,
                        a = r;
                    if (n)
                        for (var o = a; o >= 0; o--) {
                            var s = 4 * o;
                            if (e === (d = i[s])) return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], a;
                            switch (this._mode) {
                                case dr.Blend:
                                    if (e > d) {
                                        if (e > (_ = i[s + 4])) throw "Gradient:wrong startSearchIndex.";
                                        var l = _ - d,
                                            u = _ - e,
                                            c = e - d;
                                        return t.r = (u * i[s + 1] + c * i[s + 5]) / l, t.g = (u * i[s + 2] + c * i[s + 6]) / l,
                                            t.b = (u * i[s + 3] + c * i[s + 7]) / l, a;
                                    }
                                    a--;
                                    continue;

                                case dr.Fixed:
                                    if (e > d) {
                                        if (e > i[s + 4]) throw "Gradient:wrong startSearchIndex.";
                                        return t.r = i[s + 5], t.g = i[s + 6], t.b = i[s + 7], a;
                                    }
                                    a--;
                                    continue;

                                default:
                                    throw "Gradient:unknown mode.";
                            }
                        } else {
                            o = 0;
                            for (var h = this._rgbElements.length; o < h; o++) {
                                var _;
                                if (e === (_ = i[s = 4 * o])) return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3],
                                    a;
                                switch (this._mode) {
                                    case dr.Blend:
                                        if (e < _) {
                                            var d;
                                            if (e < (d = i[s - 4])) throw "Gradient:wrong startSearchIndex.";
                                            l = _ - d, u = _ - e, c = e - d;
                                            return t.r = (u * i[s - 3] + c * i[s + 1]) / l, t.g = (u * i[s - 2] + c * i[s + 2]) / l,
                                                t.b = (u * i[s - 1] + c * i[s + 3]) / l, a;
                                        }
                                        a++;
                                        continue;

                                    case dr.Fixed:
                                        if (e < _) {
                                            if (e < i[s - 4]) throw "Gradient:wrong startSearchIndex.";
                                            return t.r = i[s + 1], t.g = i[s + 2], t.b = i[s + 3], a;
                                        }
                                        a++;
                                        continue;

                                    default:
                                        throw "Gradient:unknown mode.";
                                }
                            }
                        }
                    return a;
                }
            }, {
                key: "evaluateColorAlpha",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    e = Math.min(Math.max(e, 0), 1);
                    var i = this._alphaElements,
                        a = r;
                    if (n)
                        for (var o = a; o >= 0; o--) {
                            if (e === (d = i[h = 2 * o])) return t.a = i[h + 1], a;
                            switch (this._mode) {
                                case dr.Blend:
                                    if (e > d) {
                                        if (e > (_ = i[h + 2])) throw "Gradient:wrong startSearchIndex.";
                                        var s = _ - d,
                                            l = _ - e,
                                            u = e - d;
                                        return t.a = (l * i[h + 1] + u * i[h + 3]) / s, a;
                                    }
                                    a--;
                                    continue;

                                case dr.Fixed:
                                    if (e > d) {
                                        if (e > i[h + 2]) throw "Gradient:wrong startSearchIndex.";
                                        return t.a = i[h + 3], a;
                                    }
                                    a--;
                                    continue;

                                default:
                                    throw "Gradient:unknown mode.";
                            }
                        } else {
                            o = a;
                            for (var c = this._alphaElements.length; o < c; o++) {
                                var h, _;
                                if (e === (_ = i[h = 2 * o])) return t.a = i[h + 1], a;
                                switch (this._mode) {
                                    case dr.Blend:
                                        if (e < _) {
                                            var d;
                                            if (e < (d = i[h - 2])) throw "Gradient:wrong startSearchIndex.";
                                            s = _ - d, l = _ - e, u = e - d;
                                            return t.a = (l * i[h - 1] + u * i[h + 1]) / s, a;
                                        }
                                        a++;
                                        continue;

                                    case dr.Fixed:
                                        if (e < _) {
                                            if (e < i[h - 2]) throw "Gradient:wrong startSearchIndex.";
                                            return t.a = i[h + 1], a;
                                        }
                                        a++;
                                        continue;

                                    default:
                                        throw "Gradient:unknown mode.";
                                }
                            }
                        }
                    return a;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t, r, n = e;
                    n._colorAlphaKeysCount = this._colorAlphaKeysCount;
                    var i = n._alphaElements;
                    for (t = 0, r = this._alphaElements.length; t < r; t++) i[t] = this._alphaElements[t];
                    n._colorRGBKeysCount = this._colorRGBKeysCount;
                    var a = n._rgbElements;
                    for (t = 0, r = this._rgbElements.length; t < r; t++) a[t] = this._rgbElements[t];
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Gradient(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
                    return this.cloneTo(e), e;
                }
            }, {
                key: "mode",
                get: function() {
                    return this._mode;
                },
                set: function(e) {
                    this._mode = e;
                }
            }, {
                key: "colorRGBKeysCount",
                get: function() {
                    return this._colorRGBKeysCount;
                }
            }, {
                key: "colorAlphaKeysCount",
                get: function() {
                    return this._colorAlphaKeysCount;
                }
            }, {
                key: "maxColorRGBKeysCount",
                get: function() {
                    return this._maxColorRGBKeysCount;
                }
            }, {
                key: "maxColorAlphaKeysCount",
                get: function() {
                    return this._maxColorAlphaKeysCount;
                }
            }]), Gradient;
        }(),
        mr = function() {
            function Burst(e, t, r) {
                _classCallCheck(this, Burst), this._time = e, this._minCount = t, this._maxCount = r;
            }
            return _createClass(Burst, [{
                key: "time",
                get: function() {
                    return this._time;
                }
            }, {
                key: "minCount",
                get: function() {
                    return this._minCount;
                }
            }, {
                key: "maxCount",
                get: function() {
                    return this._maxCount;
                }
            }]), _createClass(Burst, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Burst(this._time, this._minCount, this._maxCount);
                    return this.cloneTo(e), e;
                }
            }]), Burst;
        }(),
        Tr = function() {
            function GradientColor() {
                _classCallCheck(this, GradientColor), this._type = 0, this._constant = null, this._constantMin = null,
                    this._constantMax = null, this._gradient = null, this._gradientMin = null, this._gradientMax = null;
            }
            return _createClass(GradientColor, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin),
                        this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient),
                        this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientColor();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "constant",
                get: function() {
                    return this._constant;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }, {
                key: "gradient",
                get: function() {
                    return this._gradient;
                }
            }, {
                key: "gradientMin",
                get: function() {
                    return this._gradientMin;
                }
            }, {
                key: "gradientMax",
                get: function() {
                    return this._gradientMax;
                }
            }], [{
                key: "createByConstant",
                value: function(e) {
                    var t = new GradientColor();
                    return t._type = 0, t._constant = e, t;
                }
            }, {
                key: "createByGradient",
                value: function(e) {
                    var t = new GradientColor();
                    return t._type = 1, t._gradient = e, t;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function(e, t) {
                    var r = new GradientColor();
                    return r._type = 2, r._constantMin = e, r._constantMax = t, r;
                }
            }, {
                key: "createByRandomTwoGradient",
                value: function(e, t) {
                    var r = new GradientColor();
                    return r._type = 3, r._gradientMin = e, r._gradientMax = t, r;
                }
            }]), GradientColor;
        }(),
        pr = function() {
            function ColorOverLifetime(e) {
                _classCallCheck(this, ColorOverLifetime), this._color = e;
            }
            return _createClass(ColorOverLifetime, [{
                key: "color",
                get: function() {
                    return this._color;
                }
            }]), _createClass(ColorOverLifetime, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this._color.cloneTo(t._color), t.enable = this.enable;
                }
            }, {
                key: "clone",
                value: function() {
                    var e;
                    switch (this._color.type) {
                        case 0:
                            e = Tr.createByConstant(this._color.constant.clone());
                            break;

                        case 1:
                            e = Tr.createByGradient(this._color.gradient.clone());
                            break;

                        case 2:
                            e = Tr.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                            break;

                        case 3:
                            e = Tr.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
                    }
                    var t = new ColorOverLifetime(e);
                    return t.enable = this.enable, t;
                }
            }]), ColorOverLifetime;
        }(),
        vr = function() {
            function FrameOverTime() {
                _classCallCheck(this, FrameOverTime), this._type = 0, this._constant = 0, this._overTime = null,
                    this._constantMin = 0, this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
            }
            return _createClass(FrameOverTime, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, t._constant = this._constant, this._overTime && this._overTime.cloneTo(t._overTime),
                        t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin),
                        this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new FrameOverTime();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "constant",
                get: function() {
                    return this._constant;
                }
            }, {
                key: "frameOverTimeData",
                get: function() {
                    return this._overTime;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }, {
                key: "frameOverTimeDataMin",
                get: function() {
                    return this._overTimeMin;
                }
            }, {
                key: "frameOverTimeDataMax",
                get: function() {
                    return this._overTimeMax;
                }
            }], [{
                key: "createByConstant",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = new FrameOverTime();
                    return t._type = 0, t._constant = e, t;
                }
            }, {
                key: "createByOverTime",
                value: function(e) {
                    var t = new FrameOverTime();
                    return t._type = 1, t._overTime = e, t;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = new FrameOverTime();
                    return r._type = 2, r._constantMin = e, r._constantMax = t, r;
                }
            }, {
                key: "createByRandomTwoOverTime",
                value: function(e, t) {
                    var r = new FrameOverTime();
                    return r._type = 3, r._overTimeMin = e, r._overTimeMax = t, r;
                }
            }]), FrameOverTime;
        }(),
        Er = function() {
            function GradientAngularVelocity() {
                _classCallCheck(this, GradientAngularVelocity), this._type = 0, this._separateAxes = !1,
                    this._constant = 0, this._constantSeparate = null, this._gradient = null, this._gradientX = null,
                    this._gradientY = null, this._gradientZ = null, this._gradientW = null, this._constantMin = 0,
                    this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null,
                    this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null,
                    this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                    this._gradientZMax = null, this._gradientWMin = null, this._gradientWMax = null;
            }
            return _createClass(GradientAngularVelocity, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant,
                        this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient),
                        this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                        t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                        this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                        this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                        this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                        this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                        this._gradientZMax.cloneTo(t._gradientZMax);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientAngularVelocity();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "separateAxes",
                get: function() {
                    return this._separateAxes;
                }
            }, {
                key: "constant",
                get: function() {
                    return this._constant;
                }
            }, {
                key: "constantSeparate",
                get: function() {
                    return this._constantSeparate;
                }
            }, {
                key: "gradient",
                get: function() {
                    return this._gradient;
                }
            }, {
                key: "gradientX",
                get: function() {
                    return this._gradientX;
                }
            }, {
                key: "gradientY",
                get: function() {
                    return this._gradientY;
                }
            }, {
                key: "gradientZ",
                get: function() {
                    return this._gradientZ;
                }
            }, {
                key: "gradientW",
                get: function() {
                    return this._gradientW;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }, {
                key: "constantMinSeparate",
                get: function() {
                    return this._constantMinSeparate;
                }
            }, {
                key: "constantMaxSeparate",
                get: function() {
                    return this._constantMaxSeparate;
                }
            }, {
                key: "gradientMin",
                get: function() {
                    return this._gradientMin;
                }
            }, {
                key: "gradientMax",
                get: function() {
                    return this._gradientMax;
                }
            }, {
                key: "gradientXMin",
                get: function() {
                    return this._gradientXMin;
                }
            }, {
                key: "gradientXMax",
                get: function() {
                    return this._gradientXMax;
                }
            }, {
                key: "gradientYMin",
                get: function() {
                    return this._gradientYMin;
                }
            }, {
                key: "gradientYMax",
                get: function() {
                    return this._gradientYMax;
                }
            }, {
                key: "gradientZMin",
                get: function() {
                    return this._gradientZMin;
                }
            }, {
                key: "gradientZMax",
                get: function() {
                    return this._gradientZMax;
                }
            }, {
                key: "gradientWMin",
                get: function() {
                    return this._gradientWMin;
                }
            }, {
                key: "gradientWMax",
                get: function() {
                    return this._gradientWMax;
                }
            }], [{
                key: "createByConstant",
                value: function(e) {
                    var t = new GradientAngularVelocity();
                    return t._type = 0, t._separateAxes = !1, t._constant = e, t;
                }
            }, {
                key: "createByConstantSeparate",
                value: function(e) {
                    var t = new GradientAngularVelocity();
                    return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
                }
            }, {
                key: "createByGradient",
                value: function(e) {
                    var t = new GradientAngularVelocity();
                    return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
                }
            }, {
                key: "createByGradientSeparate",
                value: function(e, t, r) {
                    var n = new GradientAngularVelocity();
                    return n._type = 1, n._separateAxes = !0, n._gradientX = e, n._gradientY = t, n._gradientZ = r,
                        n;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function(e, t) {
                    var r = new GradientAngularVelocity();
                    return r._type = 2, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                        r;
                }
            }, {
                key: "createByRandomTwoConstantSeparate",
                value: function(e, t) {
                    var r = new GradientAngularVelocity();
                    return r._type = 2, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                        r;
                }
            }, {
                key: "createByRandomTwoGradient",
                value: function(e, t) {
                    var r = new GradientAngularVelocity();
                    return r._type = 3, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                        r;
                }
            }, {
                key: "createByRandomTwoGradientSeparate",
                value: function(e, t, r, n, i, a, o, s) {
                    var l = new GradientAngularVelocity();
                    return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t,
                        l._gradientYMin = r, l._gradientYMax = n, l._gradientZMin = i, l._gradientZMax = a,
                        l._gradientWMin = o, l._gradientWMax = s, l;
                }
            }]), GradientAngularVelocity;
        }(),
        gr = function() {
            function GradientDataInt() {
                _classCallCheck(this, GradientDataInt), this._currentLength = 0, this._elements = new Float32Array(8);
            }
            return _createClass(GradientDataInt, [{
                key: "add",
                value: function(e, t) {
                    this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")),
                        this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._currentLength = this._currentLength;
                    for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] = this._elements[n];
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientDataInt();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "gradientCount",
                get: function() {
                    return this._currentLength / 2;
                }
            }]), GradientDataInt;
        }(),
        yr = function() {
            function GradientDataNumber() {
                _classCallCheck(this, GradientDataNumber), this._currentLength = 0, this._elements = new Float32Array(8);
            }
            return _createClass(GradientDataNumber, [{
                key: "add",
                value: function(e, t) {
                    this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")),
                        this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
                }
            }, {
                key: "getKeyByIndex",
                value: function(e) {
                    return this._elements[2 * e];
                }
            }, {
                key: "getValueByIndex",
                value: function(e) {
                    return this._elements[2 * e + 1];
                }
            }, {
                key: "getAverageValue",
                value: function() {
                    for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                        this._elements[e + 1];
                        this._elements[e + 3], this._elements[e + 2] - this._elements[e];
                    }
                    return 0;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._currentLength = this._currentLength;
                    for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] = this._elements[n];
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientDataNumber();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "gradientCount",
                get: function() {
                    return this._currentLength / 2;
                }
            }]), GradientDataNumber;
        }(),
        Sr = function() {
            function GradientSize() {
                _classCallCheck(this, GradientSize), this._type = 0, this._separateAxes = !1, this._gradient = null,
                    this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = 0,
                    this._constantMax = 0, this._constantMinSeparate = null, this._constantMaxSeparate = null,
                    this._gradientMin = null, this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null,
                    this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                    this._gradientZMax = null;
            }
            return _createClass(GradientSize, [{
                key: "getMaxSizeInGradient",
                value: function() {
                    var e, t, r = -Number.MAX_VALUE;
                    switch (this._type) {
                        case 0:
                            if (this._separateAxes) {
                                for (e = 0, t = this._gradientX.gradientCount; e < t; e++) r = Math.max(r, this._gradientX.getValueByIndex(e));
                                for (e = 0, t = this._gradientY.gradientCount; e < t; e++) r = Math.max(r, this._gradientY.getValueByIndex(e));
                            } else
                                for (e = 0, t = this._gradient.gradientCount; e < t; e++) r = Math.max(r, this._gradient.getValueByIndex(e));
                            break;

                        case 1:
                            this._separateAxes ? (r = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x),
                                r = Math.max(r, this._constantMinSeparate.y), r = Math.max(r, this._constantMaxSeparate.y)) : r = Math.max(this._constantMin, this._constantMax);
                            break;

                        case 2:
                            if (this._separateAxes) {
                                for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMin.getValueByIndex(e));
                                for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMax.getValueByIndex(e));
                                for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientYMin.getValueByIndex(e));
                                for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientZMax.getValueByIndex(e));
                            } else {
                                for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientMin.getValueByIndex(e));
                                for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientMax.getValueByIndex(e));
                            }
                    }
                    return r;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient),
                        this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                        t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                        this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                        this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                        this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                        this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                        this._gradientZMax.cloneTo(t._gradientZMax);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientSize();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "separateAxes",
                get: function() {
                    return this._separateAxes;
                }
            }, {
                key: "gradient",
                get: function() {
                    return this._gradient;
                }
            }, {
                key: "gradientX",
                get: function() {
                    return this._gradientX;
                }
            }, {
                key: "gradientY",
                get: function() {
                    return this._gradientY;
                }
            }, {
                key: "gradientZ",
                get: function() {
                    return this._gradientZ;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }, {
                key: "constantMinSeparate",
                get: function() {
                    return this._constantMinSeparate;
                }
            }, {
                key: "constantMaxSeparate",
                get: function() {
                    return this._constantMaxSeparate;
                }
            }, {
                key: "gradientMin",
                get: function() {
                    return this._gradientMin;
                }
            }, {
                key: "gradientMax",
                get: function() {
                    return this._gradientMax;
                }
            }, {
                key: "gradientXMin",
                get: function() {
                    return this._gradientXMin;
                }
            }, {
                key: "gradientXMax",
                get: function() {
                    return this._gradientXMax;
                }
            }, {
                key: "gradientYMin",
                get: function() {
                    return this._gradientYMin;
                }
            }, {
                key: "gradientYMax",
                get: function() {
                    return this._gradientYMax;
                }
            }, {
                key: "gradientZMin",
                get: function() {
                    return this._gradientZMin;
                }
            }, {
                key: "gradientZMax",
                get: function() {
                    return this._gradientZMax;
                }
            }], [{
                key: "createByGradient",
                value: function(e) {
                    var t = new GradientSize();
                    return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
                }
            }, {
                key: "createByGradientSeparate",
                value: function(e, t, r) {
                    var n = new GradientSize();
                    return n._type = 0, n._separateAxes = !0, n._gradientX = e, n._gradientY = t, n._gradientZ = r,
                        n;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function(e, t) {
                    var r = new GradientSize();
                    return r._type = 1, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                        r;
                }
            }, {
                key: "createByRandomTwoConstantSeparate",
                value: function(e, t) {
                    var r = new GradientSize();
                    return r._type = 1, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                        r;
                }
            }, {
                key: "createByRandomTwoGradient",
                value: function(e, t) {
                    var r = new GradientSize();
                    return r._type = 2, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                        r;
                }
            }, {
                key: "createByRandomTwoGradientSeparate",
                value: function(e, t, r, n, i, a) {
                    var o = new GradientSize();
                    return o._type = 2, o._separateAxes = !0, o._gradientXMin = e, o._gradientXMax = t,
                        o._gradientYMin = r, o._gradientYMax = n, o._gradientZMin = i, o._gradientZMax = a,
                        o;
                }
            }]), GradientSize;
        }(),
        Rr = function() {
            function GradientVelocity() {
                _classCallCheck(this, GradientVelocity), this._type = 0, this._constant = null,
                    this._gradientX = null, this._gradientY = null, this._gradientZ = null, this._constantMin = null,
                    this._constantMax = null, this._gradientXMin = null, this._gradientXMax = null,
                    this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                    this._gradientZMax = null;
            }
            return _createClass(GradientVelocity, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX),
                        this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin),
                        this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin),
                        this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                        this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                        this._gradientZMax.cloneTo(t._gradientZMax);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientVelocity();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "constant",
                get: function() {
                    return this._constant;
                }
            }, {
                key: "gradientX",
                get: function() {
                    return this._gradientX;
                }
            }, {
                key: "gradientY",
                get: function() {
                    return this._gradientY;
                }
            }, {
                key: "gradientZ",
                get: function() {
                    return this._gradientZ;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }, {
                key: "gradientXMin",
                get: function() {
                    return this._gradientXMin;
                }
            }, {
                key: "gradientXMax",
                get: function() {
                    return this._gradientXMax;
                }
            }, {
                key: "gradientYMin",
                get: function() {
                    return this._gradientYMin;
                }
            }, {
                key: "gradientYMax",
                get: function() {
                    return this._gradientYMax;
                }
            }, {
                key: "gradientZMin",
                get: function() {
                    return this._gradientZMin;
                }
            }, {
                key: "gradientZMax",
                get: function() {
                    return this._gradientZMax;
                }
            }], [{
                key: "createByConstant",
                value: function(e) {
                    var t = new GradientVelocity();
                    return t._type = 0, t._constant = e, t;
                }
            }, {
                key: "createByGradient",
                value: function(e, t, r) {
                    var n = new GradientVelocity();
                    return n._type = 1, n._gradientX = e, n._gradientY = t, n._gradientZ = r, n;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function(e, t) {
                    var r = new GradientVelocity();
                    return r._type = 2, r._constantMin = e, r._constantMax = t, r;
                }
            }, {
                key: "createByRandomTwoGradient",
                value: function(e, t, r, n, i, a) {
                    var o = new GradientVelocity();
                    return o._type = 3, o._gradientXMin = e, o._gradientXMax = t, o._gradientYMin = r,
                        o._gradientYMax = n, o._gradientZMin = i, o._gradientZMax = a, o;
                }
            }]), GradientVelocity;
        }(),
        Cr = function() {
            function RotationOverLifetime(e) {
                _classCallCheck(this, RotationOverLifetime), this._angularVelocity = e;
            }
            return _createClass(RotationOverLifetime, [{
                key: "angularVelocity",
                get: function() {
                    return this._angularVelocity;
                }
            }]), _createClass(RotationOverLifetime, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this._angularVelocity.cloneTo(t._angularVelocity), t.enable = this.enable;
                }
            }, {
                key: "clone",
                value: function() {
                    var e;
                    switch (this._angularVelocity.type) {
                        case 0:
                            e = this._angularVelocity.separateAxes ? Er.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : Er.createByConstant(this._angularVelocity.constant);
                            break;

                        case 1:
                            e = this._angularVelocity.separateAxes ? Er.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : Er.createByGradient(this._angularVelocity.gradient.clone());
                            break;

                        case 2:
                            e = this._angularVelocity.separateAxes ? Er.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : Er.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                            break;

                        case 3:
                            e = this._angularVelocity.separateAxes ? Er.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : Er.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
                    }
                    var t = new RotationOverLifetime(e);
                    return t.enable = this.enable, t;
                }
            }]), RotationOverLifetime;
        }(),
        Mr = function() {
            function BaseShape() {
                _classCallCheck(this, BaseShape), this.enable = !0, this.randomDirection = 0;
            }
            return _createClass(BaseShape, [{
                key: "_getShapeBoundBox",
                value: function(e) {
                    throw new Error("BaseShape: must override it.");
                }
            }, {
                key: "_getSpeedBoundBox",
                value: function(e) {
                    throw new Error("BaseShape: must override it.");
                }
            }, {
                key: "generatePositionAndDirection",
                value: function(e, t) {
                    arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                    throw new Error("BaseShape: must override it.");
                }
            }, {
                key: "_calculateProceduralBounds",
                value: function(e, t, r) {
                    this._getShapeBoundBox(e);
                    var n = e.min,
                        i = e.max;
                    o.multiply(n, t, n), o.multiply(i, t, i);
                    var a = new Dt(new o(), new o());
                    this.randomDirection ? (a.min = new o(-1, -1, -1), a.max = new o(1, 1, 1)) : this._getSpeedBoundBox(a);
                    var s = new Dt(new o(), new o()),
                        l = s.min,
                        u = s.max;
                    o.scale(a.min, r.y, l), o.scale(a.max, r.y, u), o.add(e.min, l, l), o.add(e.max, u, u),
                        o.min(e.min, l, e.min), o.max(e.max, l, e.max);
                    var c = new Dt(new o(), new o()),
                        h = c.min,
                        _ = c.max;
                    o.scale(a.min, r.x, h), o.scale(a.max, r.x, _), o.min(c.min, _, l), o.max(c.min, _, u),
                        o.min(e.min, l, e.min), o.max(e.max, l, e.max);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    e.enable = this.enable;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new BaseShape();
                    return this.cloneTo(e), e;
                }
            }]), BaseShape;
        }(),
        xr = function() {
            function ShapeUtils() {
                _classCallCheck(this, ShapeUtils);
            }
            return _createClass(ShapeUtils, null, [{
                key: "_randomPointUnitArcCircle",
                value: function(e, t) {
                    var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    r = n ? n.getFloat() * e : Math.random() * e, t.x = Math.cos(r), t.y = Math.sin(r);
                }
            }, {
                key: "_randomPointInsideUnitArcCircle",
                value: function(e, t) {
                    var r, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                    ShapeUtils._randomPointUnitArcCircle(e, t, n), r = n ? Math.pow(n.getFloat(), .5) : Math.pow(Math.random(), .5),
                        t.x = t.x * r, t.y = t.y * r;
                }
            }, {
                key: "_randomPointUnitCircle",
                value: function(e) {
                    var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    t = r ? r.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(t),
                        e.y = Math.sin(t);
                }
            }, {
                key: "_randomPointInsideUnitCircle",
                value: function(e) {
                    var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    ShapeUtils._randomPointUnitCircle(e), t = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5),
                        e.x = e.x * t, e.y = e.y * t;
                }
            }, {
                key: "_randomPointUnitSphere",
                value: function(e) {
                    var t, r, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    n ? (t = e.z = 2 * n.getFloat() - 1, r = n.getFloat() * Math.PI * 2) : (t = e.z = 2 * Math.random() - 1,
                        r = Math.random() * Math.PI * 2);
                    var i = Math.sqrt(1 - t * t);
                    e.x = i * Math.cos(r), e.y = i * Math.sin(r);
                }
            }, {
                key: "_randomPointInsideUnitSphere",
                value: function(e) {
                    var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    ShapeUtils._randomPointUnitSphere(e), t = r ? Math.pow(r.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3),
                        e.x = e.x * t, e.y = e.y * t, e.z = e.z * t;
                }
            }, {
                key: "_randomPointInsideHalfUnitBox",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5,
                        e.y = Math.random() - .5, e.z = Math.random() - .5);
                }
            }]), ShapeUtils;
        }(),
        Dr = function(e) {
            function BoxShape() {
                var e;
                return _classCallCheck(this, BoxShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(BoxShape).call(this))).x = 1,
                    e.y = 1, e.z = 1, e;
            }
            return _inherits(BoxShape, Mr), _createClass(BoxShape, [{
                key: "_getShapeBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
                    var r = e.max;
                    r.x = .5 * this.x, r.y = .5 * this.y, r.z = .5 * this.z;
                }
            }, {
                key: "_getSpeedBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = 0, t.y = 0, t.z = 0;
                    var r = e.max;
                    r.x = 0, r.y = 1, r.z = 0;
                }
            }, {
                key: "generatePositionAndDirection",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    r ? (r.seed = n[16], xr._randomPointInsideHalfUnitBox(e, r), n[16] = r.seed) : xr._randomPointInsideHalfUnitBox(e),
                        e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? r ? (r.seed = n[17],
                            xr._randomPointUnitSphere(t, r), n[17] = r.seed) : xr._randomPointUnitSphere(t) : (t.x = 0,
                            t.y = 0, t.z = 1);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(BoxShape.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this.randomDirection;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new BoxShape();
                    return this.cloneTo(e), e;
                }
            }]), BoxShape;
        }(),
        Ar = function(e) {
            function CircleShape() {
                var e;
                return _classCallCheck(this, CircleShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(CircleShape).call(this))).radius = 1,
                    e.arc = 2 * Math.PI, e.emitFromEdge = !1, e;
            }
            return _inherits(CircleShape, Mr), _createClass(CircleShape, [{
                key: "_getShapeBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.z = -this.radius, t.y = 0;
                    var r = e.max;
                    r.x = r.z = this.radius, r.y = 0;
                }
            }, {
                key: "_getSpeedBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.y = -1, t.z = 0;
                    var r = e.max;
                    r.x = r.y = 1, r.z = 0;
                }
            }, {
                key: "generatePositionAndDirection",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                        i = CircleShape._tempPositionPoint;
                    r ? (r.seed = n[16], this.emitFromEdge ? xr._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint, r) : xr._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint, r),
                            n[16] = r.seed) : this.emitFromEdge ? xr._randomPointUnitArcCircle(this.arc, CircleShape._tempPositionPoint) : xr._randomPointInsideUnitArcCircle(this.arc, CircleShape._tempPositionPoint),
                        e.x = -i.x, e.y = i.y, e.z = 0, o.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = n[17],
                            xr._randomPointUnitSphere(t, r), n[17] = r.seed) : xr._randomPointUnitSphere(t) : e.cloneTo(t);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(CircleShape.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t.randomDirection = this.randomDirection;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new CircleShape();
                    return this.cloneTo(e), e;
                }
            }]), CircleShape;
        }();
    Ar._tempPositionPoint = new n();
    var Lr = function(e) {
        function ConeShape() {
            var e;
            return _classCallCheck(this, ConeShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConeShape).call(this))).angle = 25 / 180 * Math.PI,
                e.radius = 1, e.length = 5, e.emitType = 0, e;
        }
        return _inherits(ConeShape, Mr), _createClass(ConeShape, [{
            key: "_getShapeBoundBox",
            value: function(e) {
                var t = this.radius + this.length * Math.sin(this.angle),
                    r = this.length * Math.cos(this.angle),
                    n = e.min;
                n.x = n.y = -t, n.z = 0;
                var i = e.max;
                i.x = i.y = t, i.z = r;
            }
        }, {
            key: "_getSpeedBoundBox",
            value: function(e) {
                var t = Math.sin(this.angle),
                    r = e.min;
                r.x = r.y = -t, r.z = 0;
                var n = e.max;
                n.x = n.y = t, n.z = 1;
            }
        }, {
            key: "generatePositionAndDirection",
            value: function(e, t) {
                var r, n, i, a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                    l = ConeShape._tempPositionPoint,
                    u = Math.cos(this.angle),
                    c = Math.sin(this.angle);
                switch (this.emitType) {
                    case 0:
                        a ? (a.seed = s[16], xr._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a),
                                s[16] = a.seed) : xr._randomPointInsideUnitCircle(ConeShape._tempPositionPoint),
                            r = l.x, n = l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0, this.randomDirection ? (a ? (a.seed = s[17],
                                    xr._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a), s[17] = a.seed) : xr._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint),
                                i = ConeShape._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = r * c,
                                t.y = n * c), t.z = u;
                        break;

                    case 1:
                        a ? (a.seed = s[16], xr._randomPointUnitCircle(ConeShape._tempPositionPoint, a),
                                s[16] = a.seed) : xr._randomPointUnitCircle(ConeShape._tempPositionPoint), r = l.x,
                            n = l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0, this.randomDirection ? (a ? (a.seed = s[17],
                                    xr._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint, a), s[17] = a.seed) : xr._randomPointInsideUnitCircle(ConeShape._tempDirectionPoint),
                                i = ConeShape._tempDirectionPoint, t.x = i.x * c, t.y = i.y * c) : (t.x = r * c,
                                t.y = n * c), t.z = u;
                        break;

                    case 2:
                        a ? (a.seed = s[16], xr._randomPointInsideUnitCircle(ConeShape._tempPositionPoint, a)) : xr._randomPointInsideUnitCircle(ConeShape._tempPositionPoint),
                            r = l.x, n = l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0, t.x = r * c,
                            t.y = n * c, t.z = u, o.normalize(t, t), a ? (o.scale(t, this.length * a.getFloat(), t),
                                s[16] = a.seed) : o.scale(t, this.length * Math.random(), t), o.add(e, t, e), this.randomDirection && (a ? (a.seed = s[17],
                                xr._randomPointUnitSphere(t, a), s[17] = a.seed) : xr._randomPointUnitSphere(t));
                        break;

                    case 3:
                        a ? (a.seed = s[16], xr._randomPointUnitCircle(ConeShape._tempPositionPoint, a)) : xr._randomPointUnitCircle(ConeShape._tempPositionPoint),
                            r = l.x, n = l.y, e.x = r * this.radius, e.y = n * this.radius, e.z = 0, t.x = r * c,
                            t.y = n * c, t.z = u, o.normalize(t, t), a ? (o.scale(t, this.length * a.getFloat(), t),
                                s[16] = a.seed) : o.scale(t, this.length * Math.random(), t), o.add(e, t, e), this.randomDirection && (a ? (a.seed = s[17],
                                xr._randomPointUnitSphere(t, a), s[17] = a.seed) : xr._randomPointUnitSphere(t));
                        break;

                    default:
                        throw new Error("ConeShape:emitType is invalid.");
                }
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(ConeShape.prototype), "cloneTo", this).call(this, e);
                var t = e;
                t.angle = this.angle, t.radius = this.radius, t.length = this.length, t.emitType = this.emitType,
                    t.randomDirection = this.randomDirection;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ConeShape();
                return this.cloneTo(e), e;
            }
        }]), ConeShape;
    }();
    Lr._tempPositionPoint = new n(), Lr._tempDirectionPoint = new n();
    var Ir = function(e) {
            function HemisphereShape() {
                var e;
                return _classCallCheck(this, HemisphereShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(HemisphereShape).call(this))).radius = 1,
                    e.emitFromShell = !1, e;
            }
            return _inherits(HemisphereShape, Mr), _createClass(HemisphereShape, [{
                key: "_getShapeBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.y = t.z = -this.radius;
                    var r = e.max;
                    r.x = r.y = this.radius, r.z = 0;
                }
            }, {
                key: "_getSpeedBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.y = -1, t.z = 0;
                    var r = e.max;
                    r.x = r.y = r.z = 1;
                }
            }, {
                key: "generatePositionAndDirection",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    r ? (r.seed = n[16], this.emitFromShell ? xr._randomPointUnitSphere(e, r) : xr._randomPointInsideUnitSphere(e, r),
                            n[16] = r.seed) : this.emitFromShell ? xr._randomPointUnitSphere(e) : xr._randomPointInsideUnitSphere(e),
                        o.scale(e, this.radius, e);
                    var i = e.z;
                    i < 0 && (e.z = -1 * i), this.randomDirection ? r ? (r.seed = n[17], xr._randomPointUnitSphere(t, r),
                        n[17] = r.seed) : xr._randomPointUnitSphere(t) : e.cloneTo(t);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(HemisphereShape.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new HemisphereShape();
                    return this.cloneTo(e), e;
                }
            }]), HemisphereShape;
        }(),
        Or = function(e) {
            function SphereShape() {
                var e;
                return _classCallCheck(this, SphereShape), (e = _possibleConstructorReturn(this, _getPrototypeOf(SphereShape).call(this))).radius = 1,
                    e.emitFromShell = !1, e;
            }
            return _inherits(SphereShape, Mr), _createClass(SphereShape, [{
                key: "_getShapeBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.y = t.z = -this.radius;
                    var r = e.max;
                    r.x = r.y = r.z = this.radius;
                }
            }, {
                key: "_getSpeedBoundBox",
                value: function(e) {
                    var t = e.min;
                    t.x = t.y = t.z = -1;
                    var r = e.max;
                    r.x = r.y = r.z = 1;
                }
            }, {
                key: "generatePositionAndDirection",
                value: function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                    r ? (r.seed = n[16], this.emitFromShell ? xr._randomPointUnitSphere(e, r) : xr._randomPointInsideUnitSphere(e, r),
                            n[16] = r.seed) : this.emitFromShell ? xr._randomPointUnitSphere(e) : xr._randomPointInsideUnitSphere(e),
                        o.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = n[17], xr._randomPointUnitSphere(t, r),
                            n[17] = r.seed) : xr._randomPointUnitSphere(t) : e.cloneTo(t);
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(SphereShape.prototype), "cloneTo", this).call(this, e);
                    var t = e;
                    t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new SphereShape();
                    return this.cloneTo(e), e;
                }
            }]), SphereShape;
        }(),
        Pr = function() {
            function SizeOverLifetime(e) {
                _classCallCheck(this, SizeOverLifetime), this._size = e;
            }
            return _createClass(SizeOverLifetime, [{
                key: "size",
                get: function() {
                    return this._size;
                }
            }]), _createClass(SizeOverLifetime, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this._size.cloneTo(t._size), t.enable = this.enable;
                }
            }, {
                key: "clone",
                value: function() {
                    var e;
                    switch (this._size.type) {
                        case 0:
                            e = this._size.separateAxes ? Sr.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : Sr.createByGradient(this._size.gradient.clone());
                            break;

                        case 1:
                            e = this._size.separateAxes ? Sr.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : Sr.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                            break;

                        case 2:
                            e = this._size.separateAxes ? Sr.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : Sr.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
                    }
                    var t = new SizeOverLifetime(e);
                    return t.enable = this.enable, t;
                }
            }]), SizeOverLifetime;
        }(),
        Nr = function() {
            function StartFrame() {
                _classCallCheck(this, StartFrame), this._type = 0, this._constant = 0, this._constantMin = 0,
                    this._constantMax = 0;
            }
            return _createClass(StartFrame, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin,
                        t._constantMax = this._constantMax;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new StartFrame();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "type",
                get: function() {
                    return this._type;
                }
            }, {
                key: "constant",
                get: function() {
                    return this._constant;
                }
            }, {
                key: "constantMin",
                get: function() {
                    return this._constantMin;
                }
            }, {
                key: "constantMax",
                get: function() {
                    return this._constantMax;
                }
            }], [{
                key: "createByConstant",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = new StartFrame();
                    return t._type = 0, t._constant = e, t;
                }
            }, {
                key: "createByRandomTwoConstant",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = new StartFrame();
                    return r._type = 1, r._constantMin = e, r._constantMax = t, r;
                }
            }]), StartFrame;
        }(),
        br = function() {
            function TextureSheetAnimation(e, t) {
                _classCallCheck(this, TextureSheetAnimation), this.type = 0, this.randomRow = !1,
                    this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0, this.enable = !1,
                    this.tiles = new n(1, 1), this.type = 0, this.randomRow = !0, this.rowIndex = 0,
                    this.cycles = 1, this.enableUVChannels = 1, this._frame = e, this._startFrame = t;
            }
            return _createClass(TextureSheetAnimation, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t.rowIndex = this.rowIndex,
                        t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, t.enable = this.enable,
                        this._frame.cloneTo(t._frame), this._startFrame.cloneTo(t._startFrame);
                }
            }, {
                key: "clone",
                value: function() {
                    var e, t;
                    switch (this._frame.type) {
                        case 0:
                            e = vr.createByConstant(this._frame.constant);
                            break;

                        case 1:
                            e = vr.createByOverTime(this._frame.frameOverTimeData.clone());
                            break;

                        case 2:
                            e = vr.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                            break;

                        case 3:
                            e = vr.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
                    }
                    switch (this._startFrame.type) {
                        case 0:
                            t = Nr.createByConstant(this._startFrame.constant);
                            break;

                        case 1:
                            t = Nr.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
                    }
                    var r = new TextureSheetAnimation(e, t);
                    return this.cloneTo(r), r;
                }
            }, {
                key: "frame",
                get: function() {
                    return this._frame;
                }
            }, {
                key: "startFrame",
                get: function() {
                    return this._startFrame;
                }
            }]), TextureSheetAnimation;
        }(),
        kr = function() {
            function VelocityOverLifetime(e) {
                _classCallCheck(this, VelocityOverLifetime), this.enable = !1, this.space = 0, this._velocity = e;
            }
            return _createClass(VelocityOverLifetime, [{
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    this._velocity.cloneTo(t._velocity), t.enable = this.enable, t.space = this.space;
                }
            }, {
                key: "clone",
                value: function() {
                    var e;
                    switch (this._velocity.type) {
                        case 0:
                            e = Rr.createByConstant(this._velocity.constant.clone());
                            break;

                        case 1:
                            e = Rr.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                            break;

                        case 2:
                            e = Rr.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                            break;

                        case 3:
                            e = Rr.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
                    }
                    var t = new VelocityOverLifetime(e);
                    return t.enable = this.enable, t.space = this.space, t;
                }
            }, {
                key: "velocity",
                get: function() {
                    return this._velocity;
                }
            }]), VelocityOverLifetime;
        }(),
        Vr = function ShuriKenParticle3DShaderDeclaration() {
            _classCallCheck(this, ShuriKenParticle3DShaderDeclaration);
        };
    Vr.WORLDPOSITION = G.propertyNameToID("u_WorldPosition"), Vr.WORLDROTATION = G.propertyNameToID("u_WorldRotation"),
        Vr.POSITIONSCALE = G.propertyNameToID("u_PositionScale"), Vr.SIZESCALE = G.propertyNameToID("u_SizeScale"),
        Vr.SCALINGMODE = G.propertyNameToID("u_ScalingMode"), Vr.GRAVITY = G.propertyNameToID("u_Gravity"),
        Vr.THREEDSTARTROTATION = G.propertyNameToID("u_ThreeDStartRotation"), Vr.STRETCHEDBILLBOARDLENGTHSCALE = G.propertyNameToID("u_StretchedBillboardLengthScale"),
        Vr.STRETCHEDBILLBOARDSPEEDSCALE = G.propertyNameToID("u_StretchedBillboardSpeedScale"),
        Vr.SIMULATIONSPACE = G.propertyNameToID("u_SimulationSpace"), Vr.CURRENTTIME = G.propertyNameToID("u_CurrentTime"),
        Vr.VOLVELOCITYCONST = G.propertyNameToID("u_VOLVelocityConst"), Vr.VOLVELOCITYGRADIENTX = G.propertyNameToID("u_VOLVelocityGradientX"),
        Vr.VOLVELOCITYGRADIENTY = G.propertyNameToID("u_VOLVelocityGradientY"), Vr.VOLVELOCITYGRADIENTZ = G.propertyNameToID("u_VOLVelocityGradientZ"),
        Vr.VOLVELOCITYCONSTMAX = G.propertyNameToID("u_VOLVelocityConstMax"), Vr.VOLVELOCITYGRADIENTXMAX = G.propertyNameToID("u_VOLVelocityGradientMaxX"),
        Vr.VOLVELOCITYGRADIENTYMAX = G.propertyNameToID("u_VOLVelocityGradientMaxY"), Vr.VOLVELOCITYGRADIENTZMAX = G.propertyNameToID("u_VOLVelocityGradientMaxZ"),
        Vr.VOLSPACETYPE = G.propertyNameToID("u_VOLSpaceType"), Vr.COLOROVERLIFEGRADIENTALPHAS = G.propertyNameToID("u_ColorOverLifeGradientAlphas"),
        Vr.COLOROVERLIFEGRADIENTCOLORS = G.propertyNameToID("u_ColorOverLifeGradientColors"),
        Vr.MAXCOLOROVERLIFEGRADIENTALPHAS = G.propertyNameToID("u_MaxColorOverLifeGradientAlphas"),
        Vr.MAXCOLOROVERLIFEGRADIENTCOLORS = G.propertyNameToID("u_MaxColorOverLifeGradientColors"),
        Vr.SOLSIZEGRADIENT = G.propertyNameToID("u_SOLSizeGradient"), Vr.SOLSIZEGRADIENTX = G.propertyNameToID("u_SOLSizeGradientX"),
        Vr.SOLSIZEGRADIENTY = G.propertyNameToID("u_SOLSizeGradientY"), Vr.SOLSizeGradientZ = G.propertyNameToID("u_SOLSizeGradientZ"),
        Vr.SOLSizeGradientMax = G.propertyNameToID("u_SOLSizeGradientMax"), Vr.SOLSIZEGRADIENTXMAX = G.propertyNameToID("u_SOLSizeGradientMaxX"),
        Vr.SOLSIZEGRADIENTYMAX = G.propertyNameToID("u_SOLSizeGradientMaxY"), Vr.SOLSizeGradientZMAX = G.propertyNameToID("u_SOLSizeGradientMaxZ"),
        Vr.ROLANGULARVELOCITYCONST = G.propertyNameToID("u_ROLAngularVelocityConst"), Vr.ROLANGULARVELOCITYCONSTSEPRARATE = G.propertyNameToID("u_ROLAngularVelocityConstSeprarate"),
        Vr.ROLANGULARVELOCITYGRADIENT = G.propertyNameToID("u_ROLAngularVelocityGradient"),
        Vr.ROLANGULARVELOCITYGRADIENTX = G.propertyNameToID("u_ROLAngularVelocityGradientX"),
        Vr.ROLANGULARVELOCITYGRADIENTY = G.propertyNameToID("u_ROLAngularVelocityGradientY"),
        Vr.ROLANGULARVELOCITYGRADIENTZ = G.propertyNameToID("u_ROLAngularVelocityGradientZ"),
        Vr.ROLANGULARVELOCITYCONSTMAX = G.propertyNameToID("u_ROLAngularVelocityConstMax"),
        Vr.ROLANGULARVELOCITYCONSTMAXSEPRARATE = G.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"),
        Vr.ROLANGULARVELOCITYGRADIENTMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMax"),
        Vr.ROLANGULARVELOCITYGRADIENTXMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxX"),
        Vr.ROLANGULARVELOCITYGRADIENTYMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxY"),
        Vr.ROLANGULARVELOCITYGRADIENTZMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"),
        Vr.ROLANGULARVELOCITYGRADIENTWMAX = G.propertyNameToID("u_ROLAngularVelocityGradientMaxW"),
        Vr.TEXTURESHEETANIMATIONCYCLES = G.propertyNameToID("u_TSACycles"), Vr.TEXTURESHEETANIMATIONSUBUVLENGTH = G.propertyNameToID("u_TSASubUVLength"),
        Vr.TEXTURESHEETANIMATIONGRADIENTUVS = G.propertyNameToID("u_TSAGradientUVs"), Vr.TEXTURESHEETANIMATIONGRADIENTMAXUVS = G.propertyNameToID("u_TSAMaxGradientUVs");
    var Br = function(e) {
        function ShurikenParticleMaterial() {
            var e;
            return _classCallCheck(this, ShurikenParticleMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleMaterial).call(this))).setShaderName("PARTICLESHURIKEN"),
                e._color = new i(1, 1, 1, 1), e.renderMode = ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED,
                e;
        }
        return _inherits(ShurikenParticleMaterial, j), _createClass(ShurikenParticleMaterial, [{
            key: "clone",
            value: function() {
                var e = new ShurikenParticleMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case ShurikenParticleMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Z.CULL_NONE,
                            this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA, this.blendDst = Z.BLENDPARAM_ONE,
                            this.alphaTest = !1, this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case ShurikenParticleMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = Z.CULL_NONE,
                            this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA, this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                            this.alphaTest = !1, this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TINTCOLOR);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR),
                    this._shaderValues.setVector(ShurikenParticleMaterial.TINTCOLOR, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(ShurikenParticleMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(ShurikenParticleMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(ShurikenParticleMaterial.DIFFUSETEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP),
                    this._shaderValues.setTexture(ShurikenParticleMaterial.DIFFUSETEXTURE, e);
            }
        }, {
            key: "depthWrite",
            get: function() {
                return this._shaderValues.getBool(ShurikenParticleMaterial.DEPTH_WRITE);
            },
            set: function(e) {
                this._shaderValues.setBool(ShurikenParticleMaterial.DEPTH_WRITE, e);
            }
        }, {
            key: "cull",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.CULL);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.CULL, e);
            }
        }, {
            key: "blend",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND, e);
            }
        }, {
            key: "blendSrc",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_SRC);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_SRC, e);
            }
        }, {
            key: "blendDst",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.BLEND_DST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.BLEND_DST, e);
            }
        }, {
            key: "depthTest",
            get: function() {
                return this._shaderValues.getInt(ShurikenParticleMaterial.DEPTH_TEST);
            },
            set: function(e) {
                this._shaderValues.setInt(ShurikenParticleMaterial.DEPTH_TEST, e);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                ShurikenParticleMaterial.SHADERDEFINE_DIFFUSEMAP = G.getDefineByName("DIFFUSEMAP"),
                    ShurikenParticleMaterial.SHADERDEFINE_TINTCOLOR = G.getDefineByName("TINTCOLOR"),
                    ShurikenParticleMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG"),
                    ShurikenParticleMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET");
            }
        }]), ShurikenParticleMaterial;
    }();
    Br.RENDERMODE_ALPHABLENDED = 0, Br.RENDERMODE_ADDTIVE = 1, Br.DIFFUSETEXTURE = G.propertyNameToID("u_texture"),
        Br.TINTCOLOR = G.propertyNameToID("u_Tintcolor"), Br.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
        Br.CULL = G.propertyNameToID("s_Cull"), Br.BLEND = G.propertyNameToID("s_Blend"),
        Br.BLEND_SRC = G.propertyNameToID("s_BlendSrc"), Br.BLEND_DST = G.propertyNameToID("s_BlendDst"),
        Br.DEPTH_TEST = G.propertyNameToID("s_DepthTest"), Br.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var wr = function(e) {
            function ShurikenParticleRenderer(e) {
                var t;
                return _classCallCheck(this, ShurikenParticleRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleRenderer).call(this, e)))._finalGravity = new o(),
                    t._tempRotationMatrix = new L(), t._mesh = null, t.stretchedBillboardCameraSpeedScale = 0,
                    t.stretchedBillboardSpeedScale = 0, t.stretchedBillboardLengthScale = 2, t._defaultBoundBox = new Dt(new o(), new o()),
                    t.renderMode = 0, t._supportOctree = !1, t;
            }
            return _inherits(ShurikenParticleRenderer, wt), _createClass(ShurikenParticleRenderer, [{
                key: "_calculateBoundingBox",
                value: function() {
                    if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE,
                        e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (r = this._bounds.getMax()).x = Number.MAX_VALUE,
                        r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, this._bounds.setMax(r), t.Render.supportWebGLPlusCulling) {
                        var e = this._bounds.getMin(),
                            r = this._bounds.getMax(),
                            n = de._cullingBuffer;
                        n[this._cullingBufferIndex + 1] = e.x, n[this._cullingBufferIndex + 2] = e.y, n[this._cullingBufferIndex + 3] = e.z,
                            n[this._cullingBufferIndex + 4] = r.x, n[this._cullingBufferIndex + 5] = r.y, n[this._cullingBufferIndex + 6] = r.z;
                    }
                }
            }, {
                key: "_needRender",
                value: function(e, t) {
                    return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
                }
            }, {
                key: "_renderUpdate",
                value: function(e, t) {
                    var r = this._owner.particleSystem,
                        n = this._shaderValues,
                        i = this._owner.transform;
                    switch (r.simulationSpace) {
                        case 0:
                            break;

                        case 1:
                            n.setVector3(Vr.WORLDPOSITION, i.position), n.setQuaternion(Vr.WORLDROTATION, i.rotation);
                            break;

                        default:
                            throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                    switch (r.scaleMode) {
                        case 0:
                            var a = i.getWorldLossyScale();
                            n.setVector3(Vr.POSITIONSCALE, a), n.setVector3(Vr.SIZESCALE, a);
                            break;

                        case 1:
                            var s = i.localScale;
                            n.setVector3(Vr.POSITIONSCALE, s), n.setVector3(Vr.SIZESCALE, s);
                            break;

                        case 2:
                            n.setVector3(Vr.POSITIONSCALE, i.getWorldLossyScale()), n.setVector3(Vr.SIZESCALE, o._ONE);
                    }
                    o.scale(rt.gravity, r.gravityModifier, this._finalGravity), n.setVector3(Vr.GRAVITY, this._finalGravity),
                        n.setInt(Vr.SIMULATIONSPACE, r.simulationSpace), n.setBool(Vr.THREEDSTARTROTATION, r.threeDStartRotation),
                        n.setInt(Vr.SCALINGMODE, r.scaleMode), n.setNumber(Vr.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale),
                        n.setNumber(Vr.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale),
                        n.setNumber(Vr.CURRENTTIME, r._currentTime);
                }
            }, {
                key: "_destroy",
                value: function() {
                    _get(_getPrototypeOf(ShurikenParticleRenderer.prototype), "_destroy", this).call(this),
                        this._mesh && (this._mesh._removeReference(), this._mesh = null);
                }
            }, {
                key: "renderMode",
                get: function() {
                    return this._renderMode;
                },
                set: function(e) {
                    if (this._renderMode !== e) {
                        var t = this._shaderValues;
                        switch (this._renderMode) {
                            case 0:
                                t.removeDefine(Vr.SHADERDEFINE_RENDERMODE_BILLBOARD);
                                break;

                            case 1:
                                t.removeDefine(Vr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                                break;

                            case 2:
                                t.removeDefine(Vr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                                break;

                            case 3:
                                t.removeDefine(Vr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                                break;

                            case 4:
                                t.removeDefine(Vr.SHADERDEFINE_RENDERMODE_MESH);
                        }
                        switch (this._renderMode = e, e) {
                            case 0:
                                t.addDefine(Vr.SHADERDEFINE_RENDERMODE_BILLBOARD);
                                break;

                            case 1:
                                t.addDefine(Vr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                                break;

                            case 2:
                                t.addDefine(Vr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                                break;

                            case 3:
                                t.addDefine(Vr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                                break;

                            case 4:
                                t.addDefine(Vr.SHADERDEFINE_RENDERMODE_MESH);
                                break;

                            default:
                                throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                        }
                        var r = this._owner.particleSystem;
                        r && r._initBufferDatas();
                    }
                }
            }, {
                key: "mesh",
                get: function() {
                    return this._mesh;
                },
                set: function(e) {
                    this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e,
                        e && e._addReference(), this._owner.particleSystem._initBufferDatas());
                }
            }, {
                key: "bounds",
                get: function() {
                    return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                        this._bounds;
                }
            }]), ShurikenParticleRenderer;
        }(),
        Fr = function VertexShuriKenParticle() {
            _classCallCheck(this, VertexShuriKenParticle);
        };
    Fr.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, Fr.PARTICLE_POSITION0 = 1, Fr.PARTICLE_COLOR0 = 2,
        Fr.PARTICLE_TEXTURECOORDINATE0 = 3, Fr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4,
        Fr.PARTICLE_DIRECTIONTIME = 5, Fr.PARTICLE_STARTCOLOR0 = 6, Fr.PARTICLE_ENDCOLOR0 = 7,
        Fr.PARTICLE_STARTSIZE = 8, Fr.PARTICLE_STARTROTATION = 9, Fr.PARTICLE_STARTSPEED = 10,
        Fr.PARTICLE_RANDOM0 = 11, Fr.PARTICLE_RANDOM1 = 12, Fr.PARTICLE_SIMULATIONWORLDPOSTION = 13,
        Fr.PARTICLE_SIMULATIONWORLDROTATION = 14;
    var Ur = function(e) {
            function VertexShurikenParticleBillboard(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
                var f;
                return _classCallCheck(this, VertexShurikenParticleBillboard), (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleBillboard).call(this)))._cornerTextureCoordinate = e,
                    f._positionStartLifeTime = t, f._velocity = r, f._startColor = n, f._startSize = i,
                    f._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l,
                    f._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1,
                    f._simulationWorldPostion = d, f;
            }
            return _inherits(VertexShurikenParticleBillboard, Fr), _createClass(VertexShurikenParticleBillboard, [{
                key: "cornerTextureCoordinate",
                get: function() {
                    return this._cornerTextureCoordinate;
                }
            }, {
                key: "positionStartLifeTime",
                get: function() {
                    return this._positionStartLifeTime;
                }
            }, {
                key: "velocity",
                get: function() {
                    return this._velocity;
                }
            }, {
                key: "startColor",
                get: function() {
                    return this._startColor;
                }
            }, {
                key: "startSize",
                get: function() {
                    return this._startSize;
                }
            }, {
                key: "startRotation0",
                get: function() {
                    return this._startRotation0;
                }
            }, {
                key: "startRotation1",
                get: function() {
                    return this._startRotation1;
                }
            }, {
                key: "startRotation2",
                get: function() {
                    return this._startRotation2;
                }
            }, {
                key: "startLifeTime",
                get: function() {
                    return this._startLifeTime;
                }
            }, {
                key: "time",
                get: function() {
                    return this._time;
                }
            }, {
                key: "startSpeed",
                get: function() {
                    return this._startSpeed;
                }
            }, {
                key: "random0",
                get: function() {
                    return this._randoms0;
                }
            }, {
                key: "random1",
                get: function() {
                    return this._randoms1;
                }
            }, {
                key: "simulationWorldPostion",
                get: function() {
                    return this._simulationWorldPostion;
                }
            }], [{
                key: "__init__",
                value: function() {
                    VertexShurikenParticleBillboard._vertexDeclaration = new Oe(152, [new Pe(0, Ie.Vector4, Fr.PARTICLE_CORNERTEXTURECOORDINATE0), new Pe(16, Ie.Vector4, Fr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new Pe(32, Ie.Vector4, Fr.PARTICLE_DIRECTIONTIME), new Pe(48, Ie.Vector4, Fr.PARTICLE_STARTCOLOR0), new Pe(64, Ie.Vector3, Fr.PARTICLE_STARTSIZE), new Pe(76, Ie.Vector3, Fr.PARTICLE_STARTROTATION), new Pe(88, Ie.Single, Fr.PARTICLE_STARTSPEED), new Pe(92, Ie.Vector4, Fr.PARTICLE_RANDOM0), new Pe(108, Ie.Vector4, Fr.PARTICLE_RANDOM1), new Pe(124, Ie.Vector3, Fr.PARTICLE_SIMULATIONWORLDPOSTION), new Pe(136, Ie.Vector4, Fr.PARTICLE_SIMULATIONWORLDROTATION)]);
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexShurikenParticleBillboard._vertexDeclaration;
                }
            }]), VertexShurikenParticleBillboard;
        }(),
        Gr = function(e) {
            function VertexShurikenParticleMesh(e, t, r, n, i, a, o, s, l, u, c, h, _, d) {
                var f;
                return _classCallCheck(this, VertexShurikenParticleMesh), (f = _possibleConstructorReturn(this, _getPrototypeOf(VertexShurikenParticleMesh).call(this)))._cornerTextureCoordinate = e,
                    f._positionStartLifeTime = t, f._velocity = r, f._startColor = n, f._startSize = i,
                    f._startRotation0 = a, f._startRotation1 = o, f._startRotation2 = s, f._startLifeTime = l,
                    f._time = u, f._startSpeed = c, f._randoms0 = f.random0, f._randoms1 = f.random1,
                    f._simulationWorldPostion = d, f;
            }
            return _inherits(VertexShurikenParticleMesh, Fr), _createClass(VertexShurikenParticleMesh, [{
                key: "cornerTextureCoordinate",
                get: function() {
                    return this._cornerTextureCoordinate;
                }
            }, {
                key: "position",
                get: function() {
                    return this._positionStartLifeTime;
                }
            }, {
                key: "velocity",
                get: function() {
                    return this._velocity;
                }
            }, {
                key: "startColor",
                get: function() {
                    return this._startColor;
                }
            }, {
                key: "startSize",
                get: function() {
                    return this._startSize;
                }
            }, {
                key: "startRotation0",
                get: function() {
                    return this._startRotation0;
                }
            }, {
                key: "startRotation1",
                get: function() {
                    return this._startRotation1;
                }
            }, {
                key: "startRotation2",
                get: function() {
                    return this._startRotation2;
                }
            }, {
                key: "startLifeTime",
                get: function() {
                    return this._startLifeTime;
                }
            }, {
                key: "time",
                get: function() {
                    return this._time;
                }
            }, {
                key: "startSpeed",
                get: function() {
                    return this._startSpeed;
                }
            }, {
                key: "random0",
                get: function() {
                    return this._randoms0;
                }
            }, {
                key: "random1",
                get: function() {
                    return this._randoms1;
                }
            }, {
                key: "simulationWorldPostion",
                get: function() {
                    return this._simulationWorldPostion;
                }
            }], [{
                key: "__init__",
                value: function() {
                    VertexShurikenParticleMesh._vertexDeclaration = new Oe(172, [new Pe(0, Ie.Vector3, Fr.PARTICLE_POSITION0), new Pe(12, Ie.Vector4, Fr.PARTICLE_COLOR0), new Pe(28, Ie.Vector2, Fr.PARTICLE_TEXTURECOORDINATE0), new Pe(36, Ie.Vector4, Fr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new Pe(52, Ie.Vector4, Fr.PARTICLE_DIRECTIONTIME), new Pe(68, Ie.Vector4, Fr.PARTICLE_STARTCOLOR0), new Pe(84, Ie.Vector3, Fr.PARTICLE_STARTSIZE), new Pe(96, Ie.Vector3, Fr.PARTICLE_STARTROTATION), new Pe(108, Ie.Single, Fr.PARTICLE_STARTSPEED), new Pe(112, Ie.Vector4, Fr.PARTICLE_RANDOM0), new Pe(128, Ie.Vector4, Fr.PARTICLE_RANDOM1), new Pe(144, Ie.Vector3, Fr.PARTICLE_SIMULATIONWORLDPOSTION), new Pe(156, Ie.Vector4, Fr.PARTICLE_SIMULATIONWORLDROTATION)]);
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexShurikenParticleMesh._vertexDeclaration;
                }
            }]), VertexShurikenParticleMesh;
        }(),
        zr = function() {
            function Rand(e) {
                _classCallCheck(this, Rand), this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4),
                    this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                    this.seeds[3] = 1812433253 * this.seeds[2] + 1;
            }
            return _createClass(Rand, [{
                key: "getUint",
                value: function() {
                    return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1],
                        this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8,
                        this.seeds[3];
                }
            }, {
                key: "getFloat",
                value: function() {
                    return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
                }
            }, {
                key: "getSignedFloat",
                value: function() {
                    return 2 * this.getFloat() - 1;
                }
            }, {
                key: "seed",
                get: function() {
                    return this.seeds[0];
                },
                set: function(e) {
                    this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                        this.seeds[3] = 1812433253 * this.seeds[2] + 1;
                }
            }], [{
                key: "getFloatFromInt",
                value: function(e) {
                    return 1 / 8388607 * (8388607 & e);
                }
            }, {
                key: "getByteFromInt",
                value: function(e) {
                    return (8388607 & e) >>> 15;
                }
            }]), Rand;
        }(),
        Hr = function() {
            function Emission() {
                _classCallCheck(this, Emission), this._emissionRate = 10, this._destroyed = !1,
                    this._bursts = [];
            }
            return _createClass(Emission, [{
                key: "destroy",
                value: function() {
                    this._bursts = null, this._destroyed = !0;
                }
            }, {
                key: "getBurstsCount",
                value: function() {
                    return this._bursts.length;
                }
            }, {
                key: "getBurstByIndex",
                value: function(e) {
                    return this._bursts[e];
                }
            }, {
                key: "addBurst",
                value: function(e) {
                    var t = this._bursts.length;
                    if (t > 0)
                        for (var r = 0; r < t; r++) this._bursts[r].time > e.time && this._bursts.splice(r, 0, e);
                    this._bursts.push(e);
                }
            }, {
                key: "removeBurst",
                value: function(e) {
                    var t = this._bursts.indexOf(e); -
                    1 !== t && this._bursts.splice(t, 1);
                }
            }, {
                key: "removeBurstByIndex",
                value: function(e) {
                    this._bursts.splice(e, 1);
                }
            }, {
                key: "clearBurst",
                value: function() {
                    this._bursts.length = 0;
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e,
                        r = t._bursts;
                    r.length = this._bursts.length;
                    for (var n = 0, i = this._bursts.length; n < i; n++) {
                        var a = r[n];
                        a ? this._bursts[n].cloneTo(a) : r[n] = this._bursts[n].clone();
                    }
                    t._emissionRate = this._emissionRate, t.enable = this.enable;
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Emission();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "emissionRate",
                set: function(e) {
                    if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
                    this._emissionRate = e;
                },
                get: function() {
                    return this._emissionRate;
                }
            }, {
                key: "destroyed",
                get: function() {
                    return this._destroyed;
                }
            }]), Emission;
        }(),
        Wr = function() {
            function ShurikenParticleData() {
                _classCallCheck(this, ShurikenParticleData);
            }
            return _createClass(ShurikenParticleData, null, [{
                key: "_getStartLifetimeFromGradient",
                value: function(e, r) {
                    for (var n = 1, i = e.gradientCount; n < i; n++) {
                        var a = e.getKeyByIndex(n);
                        if (a >= r) {
                            var o = e.getKeyByIndex(n - 1),
                                s = (r - o) / (a - o);
                            return t.MathUtil.lerp(e.getValueByIndex(n - 1), e.getValueByIndex(n), s);
                        }
                    }
                    throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
                }
            }, {
                key: "_randomInvertRoationArray",
                value: function(e, t, r, n, i) {
                    var a;
                    n ? (n.seed = i[6], a = n.getFloat(), i[6] = n.seed) : a = Math.random(), a < r ? (t.x = -e.x,
                        t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
                }
            }, {
                key: "_randomInvertRoation",
                value: function(e, t, r, n) {
                    var i;
                    return r ? (r.seed = n[6], i = r.getFloat(), n[6] = r.seed) : i = Math.random(),
                        i < t && (e = -e), e;
                }
            }, {
                key: "create",
                value: function(e, r, n) {
                    var a = e.autoRandomSeed,
                        o = e._rand,
                        s = e._randomSeeds;
                    switch (e.startColorType) {
                        case 0:
                            var l = e.startColorConstant;
                            ShurikenParticleData.startColor.x = l.x, ShurikenParticleData.startColor.y = l.y,
                                ShurikenParticleData.startColor.z = l.z, ShurikenParticleData.startColor.w = l.w;
                            break;

                        case 2:
                            a ? i.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), ShurikenParticleData.startColor) : (o.seed = s[3],
                                i.lerp(e.startColorConstantMin, e.startColorConstantMax, o.getFloat(), ShurikenParticleData.startColor),
                                s[3] = o.seed);
                    }
                    var u = e.colorOverLifetime;
                    if (u && u.enable) {
                        var c = u.color;
                        switch (c.type) {
                            case 0:
                                ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * c.constant.x,
                                    ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * c.constant.y,
                                    ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * c.constant.z,
                                    ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * c.constant.w;
                                break;

                            case 2:
                                var h;
                                a ? h = Math.random() : (o.seed = s[10], h = o.getFloat(), s[10] = o.seed);
                                var _ = c.constantMin,
                                    d = c.constantMax;
                                ShurikenParticleData.startColor.x = ShurikenParticleData.startColor.x * t.MathUtil.lerp(_.x, d.x, h),
                                    ShurikenParticleData.startColor.y = ShurikenParticleData.startColor.y * t.MathUtil.lerp(_.y, d.y, h),
                                    ShurikenParticleData.startColor.z = ShurikenParticleData.startColor.z * t.MathUtil.lerp(_.z, d.z, h),
                                    ShurikenParticleData.startColor.w = ShurikenParticleData.startColor.w * t.MathUtil.lerp(_.w, d.w, h);
                        }
                    }
                    var f = ShurikenParticleData.startSize;
                    switch (e.startSizeType) {
                        case 0:
                            if (e.threeDStartSize) {
                                var m = e.startSizeConstantSeparate;
                                f[0] = m.x, f[1] = m.y, f[2] = m.z;
                            } else f[0] = f[1] = f[2] = e.startSizeConstant;
                            break;

                        case 2:
                            if (e.threeDStartSize) {
                                var T = e.startSizeConstantMinSeparate,
                                    p = e.startSizeConstantMaxSeparate;
                                a ? (f[0] = t.MathUtil.lerp(T.x, p.x, Math.random()), f[1] = t.MathUtil.lerp(T.y, p.y, Math.random()),
                                    f[2] = t.MathUtil.lerp(T.z, p.z, Math.random())) : (o.seed = s[4], f[0] = t.MathUtil.lerp(T.x, p.x, o.getFloat()),
                                    f[1] = t.MathUtil.lerp(T.y, p.y, o.getFloat()), f[2] = t.MathUtil.lerp(T.z, p.z, o.getFloat()),
                                    s[4] = o.seed);
                            } else a ? f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (o.seed = s[4],
                                f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, o.getFloat()),
                                s[4] = o.seed);
                    }
                    var v = e.sizeOverLifetime;
                    if (v && v.enable && 1 === v.size.type) {
                        var E, g = v.size;
                        if (g.separateAxes) a ? (f[0] = f[0] * t.MathUtil.lerp(g.constantMinSeparate.x, g.constantMaxSeparate.x, Math.random()),
                            f[1] = f[1] * t.MathUtil.lerp(g.constantMinSeparate.y, g.constantMaxSeparate.y, Math.random()),
                            f[2] = f[2] * t.MathUtil.lerp(g.constantMinSeparate.z, g.constantMaxSeparate.z, Math.random())) : (o.seed = s[11],
                            f[0] = f[0] * t.MathUtil.lerp(g.constantMinSeparate.x, g.constantMaxSeparate.x, o.getFloat()),
                            f[1] = f[1] * t.MathUtil.lerp(g.constantMinSeparate.y, g.constantMaxSeparate.y, o.getFloat()),
                            f[2] = f[2] * t.MathUtil.lerp(g.constantMinSeparate.z, g.constantMaxSeparate.z, o.getFloat()),
                            s[11] = o.seed);
                        else a ? E = t.MathUtil.lerp(g.constantMin, g.constantMax, Math.random()) : (o.seed = s[11],
                                E = t.MathUtil.lerp(g.constantMin, g.constantMax, o.getFloat()), s[11] = o.seed),
                            f[0] = f[0] * E, f[1] = f[1] * E, f[2] = f[2] * E;
                    }
                    var y = r.renderMode;
                    if (1 !== y) switch (e.startRotationType) {
                        case 0:
                            if (e.threeDStartRotation) {
                                var S = e.startRotationConstantSeparate,
                                    R = ShurikenParticleData._tempVector30;
                                ShurikenParticleData._randomInvertRoationArray(S, R, e.randomizeRotationDirection, a ? null : o, s),
                                    ShurikenParticleData.startRotation[0] = R.x, ShurikenParticleData.startRotation[1] = R.y,
                                    ShurikenParticleData.startRotation[2] = 4 !== y ? -R.z : R.z;
                            } else ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, a ? null : o, s),
                                ShurikenParticleData.startRotation[1] = 0, ShurikenParticleData.startRotation[2] = 0;
                            break;

                        case 2:
                            if (e.threeDStartRotation) {
                                var C = e.startRotationConstantMinSeparate,
                                    M = e.startRotationConstantMaxSeparate,
                                    x = ShurikenParticleData._tempVector30;
                                a ? (x.x = t.MathUtil.lerp(C.x, M.x, Math.random()), x.y = t.MathUtil.lerp(C.y, M.y, Math.random()),
                                        x.z = t.MathUtil.lerp(C.z, M.z, Math.random())) : (o.seed = s[5], x.x = t.MathUtil.lerp(C.x, M.x, o.getFloat()),
                                        x.y = t.MathUtil.lerp(C.y, M.y, o.getFloat()), x.z = t.MathUtil.lerp(C.z, M.z, o.getFloat()),
                                        s[5] = o.seed), ShurikenParticleData._randomInvertRoationArray(x, x, e.randomizeRotationDirection, a ? null : o, s),
                                    ShurikenParticleData.startRotation[0] = x.x, ShurikenParticleData.startRotation[1] = x.y,
                                    ShurikenParticleData.startRotation[2] = 4 !== y ? -x.z : x.z;
                            } else a ? ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, a ? null : o, s) : (o.seed = s[5],
                                ShurikenParticleData.startRotation[0] = ShurikenParticleData._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, o.getFloat()), e.randomizeRotationDirection, a ? null : o, s),
                                s[5] = o.seed);
                    }
                    switch (e.startLifetimeType) {
                        case 0:
                            ShurikenParticleData.startLifeTime = e.startLifetimeConstant;
                            break;

                        case 1:
                            ShurikenParticleData.startLifeTime = ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                            break;

                        case 2:
                            a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (o.seed = s[7],
                                ShurikenParticleData.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, o.getFloat()),
                                s[7] = o.seed);
                            break;

                        case 3:
                            var D = e.emissionTime;
                            a ? ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, D), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, D), Math.random()) : (o.seed = s[7],
                                ShurikenParticleData.startLifeTime = t.MathUtil.lerp(ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, D), ShurikenParticleData._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, D), o.getFloat()),
                                s[7] = o.seed);
                    }
                    var A = e.textureSheetAnimation;
                    if (A && A.enable) {
                        var L, I = A.tiles,
                            O = I.x,
                            P = I.y,
                            N = 1 / O,
                            b = 1 / P,
                            k = A.startFrame;
                        switch (k.type) {
                            case 0:
                                L = k.constant;
                                break;

                            case 1:
                                a ? L = t.MathUtil.lerp(k.constantMin, k.constantMax, Math.random()) : (o.seed = s[14],
                                    L = t.MathUtil.lerp(k.constantMin, k.constantMax, o.getFloat()), s[14] = o.seed);
                        }
                        var V = A.frame,
                            B = A.cycles;
                        switch (V.type) {
                            case 0:
                                L += V.constant * B;
                                break;

                            case 2:
                                a ? L += t.MathUtil.lerp(V.constantMin, V.constantMax, Math.random()) * B : (o.seed = s[15],
                                    L += t.MathUtil.lerp(V.constantMin, V.constantMax, o.getFloat()) * B, s[15] = o.seed);
                        }
                        var w = 0;
                        switch (A.type) {
                            case 0:
                                w = Math.floor(L / O);
                                break;

                            case 1:
                                A.randomRow ? a ? w = Math.floor(Math.random() * P) : (o.seed = s[13], w = Math.floor(o.getFloat() * P),
                                    s[13] = o.seed) : w = A.rowIndex;
                        }
                        var F = Math.floor(L % O);
                        ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = N,
                            ShurikenParticleData.startUVInfo[1] = b, ShurikenParticleData.startUVInfo[2] = F * N,
                            ShurikenParticleData.startUVInfo[3] = w * b;
                    } else ShurikenParticleData.startUVInfo = ShurikenParticleData.startUVInfo, ShurikenParticleData.startUVInfo[0] = 1,
                        ShurikenParticleData.startUVInfo[1] = 1, ShurikenParticleData.startUVInfo[2] = 0,
                        ShurikenParticleData.startUVInfo[3] = 0;
                }
            }]), ShurikenParticleData;
        }();
    Wr._tempVector30 = new o(), Wr.startColor = new i(), Wr.startSize = new Float32Array(3),
        Wr.startRotation = new Float32Array(3), Wr.startUVInfo = new Float32Array(4);
    var Xr = function(r) {
        function ShurikenParticleSystem(e) {
            var t;
            return _classCallCheck(this, ShurikenParticleSystem), (t = _possibleConstructorReturn(this, _getPrototypeOf(ShurikenParticleSystem).call(this)))._boundingSphere = null,
                t._boundingBox = null, t._boundingBoxCorners = null, t._owner = null, t._ownerRender = null,
                t._vertices = null, t._floatCountPerVertex = 0, t._startLifeTimeIndex = 0, t._timeIndex = 0,
                t._simulateUpdate = !1, t._firstActiveElement = 0, t._firstNewElement = 0, t._firstFreeElement = 0,
                t._firstRetiredElement = 0, t._drawCounter = 0, t._bufferMaxParticles = 0, t._emission = null,
                t._shape = null, t._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t._playStartDelay = 0,
                t._frameRateTime = 0, t._emissionTime = 0, t._totalDelayTime = 0, t._burstsIndex = 0,
                t._velocityOverLifetime = null, t._colorOverLifetime = null, t._sizeOverLifetime = null,
                t._rotationOverLifetime = null, t._textureSheetAnimation = null, t._startLifetimeType = 0,
                t._startLifetimeConstant = 0, t._startLifeTimeGradient = null, t._startLifetimeConstantMin = 0,
                t._startLifetimeConstantMax = 0, t._startLifeTimeGradientMin = null, t._startLifeTimeGradientMax = null,
                t._maxStartLifetime = 0, t._uvLength = new n(), t._vertexStride = 0, t._indexStride = 0,
                t._vertexBuffer = null, t._indexBuffer = null, t._bufferState = new Ae(), t._currentTime = 0,
                t._startUpdateLoopCount = 0, t._rand = null, t._randomSeeds = null, t.duration = 0,
                t.looping = !1, t.prewarm = !1, t.startDelayType = 0, t.startDelay = 0, t.startDelayMin = 0,
                t.startDelayMax = 0, t.startSpeedType = 0, t.startSpeedConstant = 0, t.startSpeedConstantMin = 0,
                t.startSpeedConstantMax = 0, t.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant = 0,
                t.startSizeConstantSeparate = null, t.startSizeConstantMin = 0, t.startSizeConstantMax = 0,
                t.startSizeConstantMinSeparate = null, t.startSizeConstantMaxSeparate = null, t.threeDStartRotation = !1,
                t.startRotationType = 0, t.startRotationConstant = 0, t.startRotationConstantSeparate = null,
                t.startRotationConstantMin = 0, t.startRotationConstantMax = 0, t.startRotationConstantMinSeparate = null,
                t.startRotationConstantMaxSeparate = null, t.randomizeRotationDirection = 0, t.startColorType = 0,
                t.startColorConstant = new i(1, 1, 1, 1), t.startColorConstantMin = new i(0, 0, 0, 0),
                t.startColorConstantMax = new i(1, 1, 1, 1), t.gravityModifier = 0, t.simulationSpace = 0,
                t.simulationSpeed = 1, t.scaleMode = 0, t.playOnAwake = !1, t.randomSeed = null,
                t.autoRandomSeed = !1, t.isPerformanceMode = !1, t._firstActiveElement = 0, t._firstNewElement = 0,
                t._firstFreeElement = 0, t._firstRetiredElement = 0, t._owner = e, t._ownerRender = e.particleRenderer,
                t._boundingBoxCorners = [], t._boundingSphere = new Yt(new o(), Number.MAX_VALUE),
                t._boundingBox = new Dt(new o(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new o(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)),
                t._currentTime = 0, t._isEmitting = !1, t._isPlaying = !1, t._isPaused = !1, t._burstsIndex = 0,
                t._frameRateTime = 0, t._emissionTime = 0, t._totalDelayTime = 0, t._simulateUpdate = !1,
                t._bufferMaxParticles = 1, t.duration = 5, t.looping = !0, t.prewarm = !1, t.startDelayType = 0,
                t.startDelay = 0, t.startDelayMin = 0, t.startDelayMax = 0, t._startLifetimeType = 0,
                t._startLifetimeConstant = 5, t._startLifeTimeGradient = new yr(), t._startLifetimeConstantMin = 0,
                t._startLifetimeConstantMax = 5, t._startLifeTimeGradientMin = new yr(), t._startLifeTimeGradientMax = new yr(),
                t._maxStartLifetime = 5, t.startSpeedType = 0, t.startSpeedConstant = 5, t.startSpeedConstantMin = 0,
                t.startSpeedConstantMax = 5, t.threeDStartSize = !1, t.startSizeType = 0, t.startSizeConstant = 1,
                t.startSizeConstantSeparate = new o(1, 1, 1), t.startSizeConstantMin = 0, t.startSizeConstantMax = 1,
                t.startSizeConstantMinSeparate = new o(0, 0, 0), t.startSizeConstantMaxSeparate = new o(1, 1, 1),
                t.threeDStartRotation = !1, t.startRotationType = 0, t.startRotationConstant = 0,
                t.startRotationConstantSeparate = new o(0, 0, 0), t.startRotationConstantMin = 0,
                t.startRotationConstantMax = 0, t.startRotationConstantMinSeparate = new o(0, 0, 0),
                t.startRotationConstantMaxSeparate = new o(0, 0, 0), t.gravityModifier = 0, t.simulationSpace = 1,
                t.scaleMode = 0, t.playOnAwake = !0, t._rand = new zr(0), t.autoRandomSeed = !0,
                t.randomSeed = new Uint32Array(1), t._randomSeeds = new Uint32Array(ShurikenParticleSystem._RANDOMOFFSET.length),
                t.isPerformanceMode = !0, t._emission = new Hr(), t._emission.enable = !0, t;
        }
        return _inherits(ShurikenParticleSystem, Lt), _createClass(ShurikenParticleSystem, [{
            key: "_getVertexBuffer",
            value: function() {
                return 0 === (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0) ? this._vertexBuffer : null;
            }
        }, {
            key: "_getIndexBuffer",
            value: function() {
                return this._indexBuffer;
            }
        }, {
            key: "_generateBoundingSphere",
            value: function() {
                var e = this._boundingSphere.center;
                e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
            }
        }, {
            key: "_generateBoundingBox",
            value: function() {
                var e, t, r, n, i, a, s, l, u, c = this._owner.particleRenderer,
                    h = this._boundingBox.min,
                    _ = this._boundingBox.max;
                switch (this.startLifetimeType) {
                    case 0:
                        r = this.startLifetimeConstant;
                        break;

                    case 1:
                        r = -Number.MAX_VALUE;
                        var d = d;
                        for (e = 0, t = d.gradientCount; e < t; e++) r = Math.max(r, d.getValueByIndex(e));
                        break;

                    case 2:
                        r = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        r = -Number.MAX_VALUE;
                        var f = f;
                        for (e = 0, t = f.gradientCount; e < t; e++) r = Math.max(r, f.getValueByIndex(e));
                        var m = m;
                        for (e = 0, t = m.gradientCount; e < t; e++) r = Math.max(r, m.getValueByIndex(e));
                }
                switch (this.startSpeedType) {
                    case 0:
                        n = i = this.startSpeedConstant;
                        break;

                    case 1:
                        break;

                    case 2:
                        n = this.startLifetimeConstantMin, i = this.startLifetimeConstantMax;
                }
                this._shape && this._shape.enable || (a = s = o._ZERO, l = o._ZERO, u = o._UnitZ);
                var T, p, v = new o(l.x * n, l.y * n, l.z * n),
                    E = new o(u.x * i, u.y * i, u.z * i);
                if (this._velocityOverLifetime && this._velocityOverLifetime.enable) {
                    var g = this._velocityOverLifetime.velocity;
                    switch (g.type) {
                        case 0:
                            g.constant;
                            break;

                        case 1:
                            new o(g.gradientX.getAverageValue(), g.gradientY.getAverageValue(), g.gradientZ.getAverageValue());
                            break;

                        case 2:
                            g.constantMin, g.constantMax;
                            break;

                        case 3:
                            new o(g.gradientXMin.getAverageValue(), g.gradientYMin.getAverageValue(), g.gradientZMin.getAverageValue()),
                                new o(g.gradientXMax.getAverageValue(), g.gradientYMax.getAverageValue(), g.gradientZMax.getAverageValue());
                    }
                }
                var y, S, R, C, M = this._owner.transform,
                    x = M.position,
                    D = ShurikenParticleSystem._tempVector39,
                    A = c.renderMode;
                switch (this.scaleMode) {
                    case 0:
                        var L = M.getWorldLossyScale();
                        T = L, D.x = L.x, D.y = L.z, D.z = L.y, 1 === A && (p = L);
                        break;

                    case 1:
                        var I = M.localScale;
                        T = I, D.x = I.x, D.y = I.z, D.z = I.y, 1 === A && (p = I);
                        break;

                    case 2:
                        T = M.getWorldLossyScale(), D.x = D.y = D.z = 1, 1 === A && (p = o._ONE);
                }
                switch (this._velocityOverLifetime && this._velocityOverLifetime.enable || (y = new o(v.x * r, v.y * r, v.z * r),
                    S = new o(E.x * r, E.y * r, E.z * r), 2 != this.scaleMode ? (o.add(a, y, h), o.multiply(T, h, h),
                        o.add(s, S, _), o.multiply(T, _, _)) : (o.multiply(T, a, h), o.add(h, y, h), o.multiply(T, s, _),
                        o.add(_, S, _))), this.simulationSpace) {
                    case 0:
                        break;

                    case 1:
                        o.add(h, x, h), o.add(_, x, _);
                }
                switch (this.startSizeType) {
                    case 0:
                        if (this.threeDStartSize) {
                            var O = O;
                            R = Math.max(O.x, O.y), 1 === A && (C = O.y);
                        } else R = this.startSizeConstant, 1 === A && (C = this.startSizeConstant);
                        break;

                    case 1:
                        break;

                    case 2:
                        if (this.threeDStartSize) {
                            var P = P;
                            R = Math.max(P.x, P.y), 1 === A && (C = P.y);
                        } else R = this.startSizeConstantMax, 1 === A && (C = this.startSizeConstantMax);
                }
                if (this._sizeOverLifetime && this._sizeOverLifetime.enable) {
                    this._sizeOverLifetime.size;
                    R *= this._sizeOverLifetime.size.getMaxSizeInGradient();
                }
                var N, b, k = ShurikenParticleSystem._tempVector30;
                switch (A) {
                    case 0:
                        N = R * ShurikenParticleSystem.halfKSqrtOf2, o.scale(D, R, k), o.subtract(h, k, h),
                            o.add(_, k, _);
                        break;

                    case 1:
                        var V = ShurikenParticleSystem._tempVector31,
                            B = ShurikenParticleSystem._tempVector32,
                            w = ShurikenParticleSystem._tempVector33,
                            F = ShurikenParticleSystem._tempVector34;
                        this._velocityOverLifetime && this._velocityOverLifetime.enable || (o.multiply(p, E, B),
                            o.multiply(p, v, w));
                        var U = C * c.stretchedBillboardLengthScale,
                            G = o.scalarLength(B) * c.stretchedBillboardSpeedScale + U,
                            z = o.scalarLength(w) * c.stretchedBillboardSpeedScale + U,
                            H = ShurikenParticleSystem._tempVector35,
                            W = ShurikenParticleSystem._tempVector36;
                        o.normalize(B, H), o.scale(H, G, F), o.subtract(S, F, F), o.normalize(w, W), o.scale(W, z, V),
                            o.add(y, V, V), N = R * ShurikenParticleSystem.halfKSqrtOf2, o.scale(D, N, k);
                        var X = ShurikenParticleSystem._tempVector37,
                            Y = ShurikenParticleSystem._tempVector38;
                        o.scale(H, .5, X), o.scale(W, .5, Y), o.multiply(X, D, X), o.multiply(Y, D, Y),
                            o.add(h, Y, h), o.min(h, F, h), o.subtract(h, k, h), o.subtract(_, X, _), o.max(_, V, _),
                            o.add(_, k, _);
                        break;

                    case 2:
                        b = .5 * (R *= Math.cos(.7853981633974483)), k.x = D.x * b, k.y = D.z * b, o.subtract(h, k, h),
                            o.add(_, k, _);
                        break;

                    case 3:
                        b = .5 * (R *= Math.cos(.7853981633974483)), o.scale(D, b, k), o.subtract(h, k, h),
                            o.add(_, k, _);
                }
                this._boundingBox.getCorners(this._boundingBoxCorners);
            }
        }, {
            key: "_updateEmission",
            value: function() {
                if (this.isAlive)
                    if (this._simulateUpdate) this._simulateUpdate = !1;
                    else {
                        var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                        e = Math.min(ShurikenParticleSystem._maxElapsedTime, e * this.simulationSpeed),
                            this._updateParticles(e);
                    }
            }
        }, {
            key: "_updateParticles",
            value: function(e) {
                (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e,
                    this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e,
                    this._totalDelayTime < this._playStartDelay || this._emission.enable && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
            }
        }, {
            key: "_updateParticlesSimulationRestart",
            value: function(e) {
                this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0,
                    this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0,
                    this._totalDelayTime = 0, this._currentTime = e;
                var t = e;
                t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enable && this._advanceTime(e, e);
            }
        }, {
            key: "_retireActiveParticles",
            value: function() {
                for (; this._firstActiveElement != this._firstNewElement;) {
                    var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride,
                        t = e + this._timeIndex;
                    if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                    this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
                }
            }
        }, {
            key: "_freeRetiredParticles",
            value: function() {
                for (; this._firstRetiredElement != this._firstActiveElement;) {
                    var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                    if (this.isPerformanceMode && e < 3) break;
                    this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
                }
            }
        }, {
            key: "_burst",
            value: function(e, r) {
                for (var n = 0, i = this._emission._bursts, a = i.length; this._burstsIndex < a; this._burstsIndex++) {
                    var o, s = i[this._burstsIndex],
                        l = s.time;
                    if (!(e <= l && l < r)) break;
                    this.autoRandomSeed ? o = t.MathUtil.lerp(s.minCount, s.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0],
                            o = t.MathUtil.lerp(s.minCount, s.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed),
                        n += o;
                }
                return n;
            }
        }, {
            key: "_advanceTime",
            value: function(e, t) {
                var r, n = this._emissionTime;
                this._emissionTime += e;
                var i = 0;
                if (this._emissionTime > this.duration) {
                    if (!this.looping) {
                        for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), r = 0; r < i; r++) this.emit(t);
                        return this._isPlaying = !1, void this.stop();
                    }
                    i += this._burst(n, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0,
                        i += this._burst(0, this._emissionTime);
                } else i += this._burst(n, this._emissionTime);
                for (i = Math.min(this.maxParticles - this.aliveParticleCount, i), r = 0; r < i; r++) this.emit(t);
                var a = this.emission.emissionRate;
                if (a > 0) {
                    var o = 1 / a;
                    for (this._frameRateTime += o, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime);) this._frameRateTime += o;
                    this._frameRateTime = Math.floor(t / o) * o;
                }
            }
        }, {
            key: "_initBufferDatas",
            value: function() {
                if (this._vertexBuffer) {
                    this._vertexBuffer.destroy(), this._indexBuffer.destroy();
                    var r = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                    t.Resource._addMemory(-r, -r);
                }
                var n = t.LayaGL.instance,
                    i = this._ownerRender,
                    a = i.renderMode;
                if (-1 !== a && this.maxParticles > 0) {
                    var o, s, l, u, c, h, _, d = 0,
                        f = (r = 0, i.mesh);
                    if (4 === a) {
                        if (f) {
                            _ = Gr.vertexDeclaration, this._floatCountPerVertex = _.vertexStride / 4, this._startLifeTimeIndex = 12,
                                this._timeIndex = 16, this._vertexStride = f._vertexCount;
                            var m = this._bufferMaxParticles * this._vertexStride,
                                T = m % 65535;
                            if (Math.floor(m / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                            d = _.vertexStride * T, this._vertexBuffer = new be(d, n.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _,
                                this._vertices = new Float32Array(this._floatCountPerVertex * T), this._indexStride = f._indexBuffer.indexCount;
                            var p = f._indexBuffer.getData(),
                                v = this._bufferMaxParticles * this._indexStride;
                            for (this._indexBuffer = new Le(e.IndexFormat.UInt16, v, n.STATIC_DRAW), o = new Uint16Array(v),
                                r = d + 2 * v, c = 0, s = 0; s < this._bufferMaxParticles; s++) {
                                var E = s * this._vertexStride;
                                for (l = 0, u = p.length; l < u; l++) o[c++] = E + p[l];
                            }
                            this._indexBuffer.setData(o), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                                this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                        }
                    } else {
                        for (_ = Ur.vertexDeclaration, this._floatCountPerVertex = _.vertexStride / 4, this._startLifeTimeIndex = 7,
                            this._timeIndex = 11, this._vertexStride = 4, d = _.vertexStride * this._bufferMaxParticles * this._vertexStride,
                            this._vertexBuffer = new be(d, n.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = _,
                            this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride),
                            s = 0; s < this._bufferMaxParticles; s++) h = s * this._floatCountPerVertex * this._vertexStride,
                            this._vertices[h] = -.5, this._vertices[h + 1] = -.5, this._vertices[h + 2] = 0,
                            this._vertices[h + 3] = 1, h += this._floatCountPerVertex, this._vertices[h] = .5,
                            this._vertices[h + 1] = -.5, this._vertices[h + 2] = 1, this._vertices[h + 3] = 1,
                            h += this._floatCountPerVertex, this._vertices[h] = .5, this._vertices[h + 1] = .5,
                            this._vertices[h + 2] = 1, this._vertices[h + 3] = 0, h += this._floatCountPerVertex,
                            this._vertices[h] = -.5, this._vertices[h + 1] = .5, this._vertices[h + 2] = 0,
                            this._vertices[h + 3] = 0;
                        for (this._indexStride = 6, this._indexBuffer = new Le(e.IndexFormat.UInt16, 6 * this._bufferMaxParticles, n.STATIC_DRAW),
                            o = new Uint16Array(6 * this._bufferMaxParticles), s = 0; s < this._bufferMaxParticles; s++) {
                            c = 6 * s;
                            var g = s * this._vertexStride,
                                y = g + 2;
                            o[c++] = g, o[c++] = y, o[c++] = g + 1, o[c++] = g, o[c++] = g + 3, o[c++] = y;
                        }
                        this._indexBuffer.setData(o), r = d + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(),
                            this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer),
                            this._bufferState.unBind();
                    }
                    t.Resource._addMemory(r, r);
                }
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(ShurikenParticleSystem.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer.destroy(),
                    this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null,
                    this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null,
                    this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null,
                    this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null,
                    this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null,
                    this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null,
                    this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null,
                    this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null,
                    this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
            }
        }, {
            key: "emit",
            value: function(e) {
                var t = ShurikenParticleSystem._tempPosition,
                    r = ShurikenParticleSystem._tempDirection;
                return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, r) : this._shape.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0,
                    r.x = r.y = 0, r.z = 1), this.addParticle(t, r, e);
            }
        }, {
            key: "addParticle",
            value: function(e, r, n) {
                o.normalize(r, r);
                var i = this._firstFreeElement + 1;
                if (i >= this._bufferMaxParticles && (i = 0), i === this._firstRetiredElement) return !1;
                var a, s, l, u, c, h, _, d, f, m, T = this._owner.transform;
                if (Wr.create(this, this._ownerRender, T), this._currentTime - n >= Wr.startLifeTime) return !0;
                switch (0 == this.simulationSpace && (a = T.position, s = T.rotation), this.startSpeedType) {
                    case 0:
                        l = this.startSpeedConstant;
                        break;

                    case 2:
                        this.autoRandomSeed ? l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, Math.random()) : (this._rand.seed = this._randomSeeds[8],
                            l = t.MathUtil.lerp(this.startSpeedConstantMin, this.startSpeedConstantMax, this._rand.getFloat()),
                            this._randomSeeds[8] = this._rand.seed);
                }
                var p = this._velocityOverLifetime && this._velocityOverLifetime.enable;
                if (p) {
                    var v = this._velocityOverLifetime.velocity.type;
                    2 === v || 3 === v ? this.autoRandomSeed ? (u = Math.random(), c = Math.random(),
                        h = Math.random()) : (this._rand.seed = this._randomSeeds[9], u = this._rand.getFloat(),
                        c = this._rand.getFloat(), h = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : p = !1;
                } else p = !1;
                var E = this._colorOverLifetime && this._colorOverLifetime.enable;
                E ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? _ = Math.random() : (this._rand.seed = this._randomSeeds[10],
                    _ = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : E = !1 : E = !1;
                var g = this._sizeOverLifetime && this._sizeOverLifetime.enable;
                g ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? d = Math.random() : (this._rand.seed = this._randomSeeds[11],
                    d = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : g = !1 : g = !1;
                var y = this._rotationOverLifetime && this._rotationOverLifetime.enable;
                if (y) {
                    var S = this._rotationOverLifetime.angularVelocity.type;
                    2 === S || 3 === S ? this.autoRandomSeed ? f = Math.random() : (this._rand.seed = this._randomSeeds[12],
                        f = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : y = !1;
                } else y = !1;
                var R = this._textureSheetAnimation && this._textureSheetAnimation.enable;
                R ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? m = Math.random() : (this._rand.seed = this._randomSeeds[15],
                    m = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : R = !1 : R = !1;
                var C, M, x, D, A, L, I = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride,
                    O = Wr.startUVInfo[0],
                    P = Wr.startUVInfo[1],
                    N = Wr.startUVInfo[2],
                    b = Wr.startUVInfo[3],
                    k = this._ownerRender;
                if (4 === k.renderMode) {
                    var V = k.mesh._vertexBuffer;
                    C = V.getFloat32Data();
                    var B = V.vertexDeclaration;
                    x = B.getVertexElementByUsage(Ne.MESH_POSITION0)._offset / 4;
                    var w = B.getVertexElementByUsage(Ne.MESH_COLOR0);
                    D = w ? w._offset / 4 : -1;
                    var F = B.getVertexElementByUsage(Ne.MESH_TEXTURECOORDINATE0);
                    A = F ? F._offset / 4 : -1, M = B.vertexStride / 4, L = 0;
                } else {
                    this._vertices[I + 2] = N, this._vertices[I + 3] = b + P;
                    var U = I + this._floatCountPerVertex;
                    this._vertices[U + 2] = N + O, this._vertices[U + 3] = b + P;
                    var G = U + this._floatCountPerVertex;
                    this._vertices[G + 2] = N + O, this._vertices[G + 3] = b;
                    var z = G + this._floatCountPerVertex;
                    this._vertices[z + 2] = N, this._vertices[z + 3] = b;
                }
                for (var H = I, W = I + this._floatCountPerVertex * this._vertexStride; H < W; H += this._floatCountPerVertex) {
                    var X;
                    if (4 === k.renderMode) {
                        X = H;
                        var Y = M * L++,
                            j = Y + x;
                        this._vertices[X++] = C[j++], this._vertices[X++] = C[j++], this._vertices[X++] = C[j], -1 === D ? (this._vertices[X++] = 1, this._vertices[X++] = 1, this._vertices[X++] = 1,
                            this._vertices[X++] = 1) : (j = Y + D, this._vertices[X++] = C[j++], this._vertices[X++] = C[j++],
                            this._vertices[X++] = C[j++], this._vertices[X++] = C[j]), -1 === A ? (this._vertices[X++] = 0,
                            this._vertices[X++] = 0) : (j = Y + A, this._vertices[X++] = N + C[j++] * O, this._vertices[X++] = b + C[j] * P);
                    } else X = H + 4;
                    switch (this._vertices[X++] = e.x, this._vertices[X++] = e.y, this._vertices[X++] = e.z,
                        this._vertices[X++] = Wr.startLifeTime, this._vertices[X++] = r.x, this._vertices[X++] = r.y,
                        this._vertices[X++] = r.z, this._vertices[X++] = n, this._vertices[X++] = Wr.startColor.x,
                        this._vertices[X++] = Wr.startColor.y, this._vertices[X++] = Wr.startColor.z, this._vertices[X++] = Wr.startColor.w,
                        this._vertices[X++] = Wr.startSize[0], this._vertices[X++] = Wr.startSize[1], this._vertices[X++] = Wr.startSize[2],
                        this._vertices[X++] = Wr.startRotation[0], this._vertices[X++] = Wr.startRotation[1],
                        this._vertices[X++] = Wr.startRotation[2], this._vertices[X++] = l, E && (this._vertices[X + 1] = _),
                        g && (this._vertices[X + 2] = d), y && (this._vertices[X + 3] = f), R && (this._vertices[X + 4] = m),
                        p && (this._vertices[X + 5] = u, this._vertices[X + 6] = c, this._vertices[X + 7] = h),
                        this.simulationSpace) {
                        case 0:
                            X += 8, this._vertices[X++] = a.x, this._vertices[X++] = a.y, this._vertices[X++] = a.z,
                                this._vertices[X++] = s.x, this._vertices[X++] = s.y, this._vertices[X++] = s.z,
                                this._vertices[X++] = s.w;
                            break;

                        case 1:
                            break;

                        default:
                            throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                    }
                }
                return this._firstFreeElement = i, !0;
            }
        }, {
            key: "addNewParticlesToVertexBuffer",
            value: function() {
                var e, t = this._vertexStride * this._floatCountPerVertex * 4;
                this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t,
                        this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t,
                        this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t),
                        this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)),
                    this._firstNewElement = this._firstFreeElement;
            }
        }, {
            key: "_getType",
            value: function() {
                return ShurikenParticleSystem._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(),
                    this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
            }
        }, {
            key: "_render",
            value: function(e) {
                var r;
                this._bufferState.bind();
                var n = t.LayaGL.instance;
                this._firstActiveElement < this._firstFreeElement ? (r = (this._firstFreeElement - this._firstActiveElement) * this._indexStride,
                    n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                    t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride,
                    n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                    t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++, this._firstFreeElement > 0 && (r = this._firstFreeElement * this._indexStride,
                        n.drawElements(n.TRIANGLES, r, n.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3,
                        t.Stat.renderBatches++));
            }
        }, {
            key: "play",
            value: function() {
                if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1,
                    this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed)
                    for (var e = 0, r = this._randomSeeds.length; e < r; e++) this._randomSeeds[e] = this.randomSeed[0] + ShurikenParticleSystem._RANDOMOFFSET[e];
                switch (this.startDelayType) {
                    case 0:
                        this._playStartDelay = this.startDelay;
                        break;

                    case 1:
                        this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2],
                            this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()),
                            this._randomSeeds[2] = this._rand.seed);
                        break;

                    default:
                        throw new Error("Utils3D: startDelayType is invalid.");
                }
                this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = t.Stat.loopCount;
            }
        }, {
            key: "pause",
            value: function() {
                this._isPaused = !0;
            }
        }, {
            key: "simulate",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1,
                    this._updateParticles(e)), this.pause();
            }
        }, {
            key: "stop",
            value: function() {
                this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
            }
        }, {
            key: "cloneTo",
            value: function(e) {
                var t = e;
                t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm,
                    t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin,
                    t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime,
                    t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant,
                    this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin,
                    t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin),
                    this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType,
                    t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin,
                    t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize,
                    t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant,
                    this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin,
                    t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate),
                    this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation,
                    t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant,
                    this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin,
                    t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate),
                    this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate),
                    t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType,
                    this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin),
                    this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier,
                    t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake,
                    t.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0], t.maxParticles = this.maxParticles,
                    this._emission && (t._emission = this._emission.clone()), this.shape && (t.shape = this.shape.clone()),
                    this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()),
                    this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()),
                    this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()),
                    this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()),
                    t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting,
                    t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay,
                    t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime,
                    t._burstsIndex = this._burstsIndex;
            }
        }, {
            key: "clone",
            value: function() {
                var e = new ShurikenParticleSystem(null);
                return this.cloneTo(e), e;
            }
        }, {
            key: "maxParticles",
            get: function() {
                return this._bufferMaxParticles - 1;
            },
            set: function(e) {
                var t = e + 1;
                t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
            }
        }, {
            key: "emission",
            get: function() {
                return this._emission;
            }
        }, {
            key: "aliveParticleCount",
            get: function() {
                return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
            }
        }, {
            key: "emissionTime",
            get: function() {
                return this._emissionTime > this.duration ? this.duration : this._emissionTime;
            }
        }, {
            key: "shape",
            get: function() {
                return this._shape;
            },
            set: function(e) {
                this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(Vr.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(Vr.SHADERDEFINE_SHAPE),
                    this._shape = e);
            }
        }, {
            key: "isAlive",
            get: function() {
                return !!(this._isPlaying || this.aliveParticleCount > 0);
            }
        }, {
            key: "isEmitting",
            get: function() {
                return this._isEmitting;
            }
        }, {
            key: "isPlaying",
            get: function() {
                return this._isPlaying;
            }
        }, {
            key: "isPaused",
            get: function() {
                return this._isPaused;
            }
        }, {
            key: "startLifetimeType",
            get: function() {
                return this._startLifetimeType;
            },
            set: function(e) {
                var t, r;
                switch (this.startLifetimeType) {
                    case 0:
                        this._maxStartLifetime = this.startLifetimeConstant;
                        break;

                    case 1:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var n = n;
                        for (t = 0, r = n.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, n.getValueByIndex(t));
                        break;

                    case 2:
                        this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                        break;

                    case 3:
                        this._maxStartLifetime = -Number.MAX_VALUE;
                        var i = i;
                        for (t = 0, r = i.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                        var a = a;
                        for (t = 0, r = a.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
                }
                this._startLifetimeType = e;
            }
        }, {
            key: "startLifetimeConstant",
            get: function() {
                return this._startLifetimeConstant;
            },
            set: function(e) {
                0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
            }
        }, {
            key: "startLifeTimeGradient",
            get: function() {
                return this._startLifeTimeGradient;
            },
            set: function(e) {
                if (1 === this._startLifetimeType) {
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    for (var t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradient = e;
            }
        }, {
            key: "startLifetimeConstantMin",
            get: function() {
                return this._startLifetimeConstantMin;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)),
                    this._startLifetimeConstantMin = e;
            }
        }, {
            key: "startLifetimeConstantMax",
            get: function() {
                return this._startLifetimeConstantMax;
            },
            set: function(e) {
                2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)),
                    this._startLifetimeConstantMax = e;
            }
        }, {
            key: "startLifeTimeGradientMin",
            get: function() {
                return this._startLifeTimeGradientMin;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                    for (t = 0, r = this._startLifeTimeGradientMax.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
                }
                this._startLifeTimeGradientMin = e;
            }
        }, {
            key: "startLifeTimeGradientMax",
            get: function() {
                return this._startLifeTimeGradientMax;
            },
            set: function(e) {
                if (3 === this._startLifetimeType) {
                    var t, r;
                    for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = this._startLifeTimeGradientMin.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                    for (t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                }
                this._startLifeTimeGradientMax = e;
            }
        }, {
            key: "velocityOverLifetime",
            get: function() {
                return this._velocityOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.velocity,
                        n = r.type;
                    if (e.enable) switch (n) {
                        case 0:
                            t.addDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            t.addDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                            break;

                        case 2:
                            t.addDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                            break;

                        case 3:
                            t.addDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    } else t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                        t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                    switch (n) {
                        case 0:
                            t.setVector3(Vr.VOLVELOCITYCONST, r.constant);
                            break;

                        case 1:
                            t.setBuffer(Vr.VOLVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Vr.VOLVELOCITYGRADIENTY, r.gradientY._elements),
                                t.setBuffer(Vr.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
                            break;

                        case 2:
                            t.setVector3(Vr.VOLVELOCITYCONST, r.constantMin), t.setVector3(Vr.VOLVELOCITYCONSTMAX, r.constantMax);
                            break;

                        case 3:
                            t.setBuffer(Vr.VOLVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Vr.VOLVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(Vr.VOLVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Vr.VOLVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(Vr.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Vr.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements);
                    }
                    t.setInt(Vr.VOLSPACETYPE, e.space);
                } else t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                    t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                this._velocityOverLifetime = e;
            }
        }, {
            key: "colorOverLifetime",
            get: function() {
                return this._colorOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.color;
                    if (e.enable) switch (r.type) {
                        case 1:
                            t.addDefine(Vr.SHADERDEFINE_COLOROVERLIFETIME);
                            break;

                        case 3:
                            t.addDefine(Vr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    } else t.removeDefine(Vr.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Vr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                    switch (r.type) {
                        case 1:
                            var n = r.gradient;
                            t.setBuffer(Vr.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Vr.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements);
                            break;

                        case 3:
                            var i = r.gradientMin,
                                a = r.gradientMax;
                            t.setBuffer(Vr.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Vr.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                                t.setBuffer(Vr.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Vr.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                    }
                } else t.removeDefine(Vr.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Vr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME),
                    t.setBuffer(Vr.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Vr.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements),
                    t.setBuffer(Vr.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Vr.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                    t.setBuffer(Vr.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Vr.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                this._colorOverLifetime = e;
            }
        }, {
            key: "sizeOverLifetime",
            get: function() {
                return this._sizeOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.size,
                        n = r.separateAxes,
                        i = r.type;
                    if (e.enable) switch (i) {
                        case 0:
                            n ? t.addDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                            break;

                        case 2:
                            n ? t.addDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                        t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                    switch (i) {
                        case 0:
                            n ? (t.setBuffer(Vr.SOLSIZEGRADIENTX, r.gradientX._elements), t.setBuffer(Vr.SOLSIZEGRADIENTY, r.gradientY._elements),
                                t.setBuffer(Vr.SOLSizeGradientZ, r.gradientZ._elements)) : t.setBuffer(Vr.SOLSIZEGRADIENT, r.gradient._elements);
                            break;

                        case 2:
                            n ? (t.setBuffer(Vr.SOLSIZEGRADIENTX, r.gradientXMin._elements), t.setBuffer(Vr.SOLSIZEGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(Vr.SOLSIZEGRADIENTY, r.gradientYMin._elements), t.setBuffer(Vr.SOLSIZEGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(Vr.SOLSizeGradientZ, r.gradientZMin._elements), t.setBuffer(Vr.SOLSizeGradientZMAX, r.gradientZMax._elements)) : (t.setBuffer(Vr.SOLSIZEGRADIENT, r.gradientMin._elements),
                                t.setBuffer(Vr.SOLSizeGradientMax, r.gradientMax._elements));
                    }
                } else t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                    t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                this._sizeOverLifetime = e;
            }
        }, {
            key: "rotationOverLifetime",
            get: function() {
                return this._rotationOverLifetime;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.angularVelocity;
                    if (!r) return;
                    var n = r.separateAxes,
                        i = r.type;
                    if (e.enable) switch (n ? t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIME),
                        i) {
                        case 0:
                            t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                            break;

                        case 1:
                            t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                            break;

                        case 2:
                            t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                            break;

                        case 3:
                            t.addDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    } else t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                        t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                        t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                    switch (i) {
                        case 0:
                            n ? t.setVector3(Vr.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantSeparate) : t.setNumber(Vr.ROLANGULARVELOCITYCONST, r.constant);
                            break;

                        case 1:
                            n ? (t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTY, r.gradientY._elements),
                                t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
                            break;

                        case 2:
                            n ? (t.setVector3(Vr.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantMinSeparate), t.setVector3(Vr.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r.constantMaxSeparate)) : (t.setNumber(Vr.ROLANGULARVELOCITYCONST, r.constantMin),
                                t.setNumber(Vr.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
                            break;

                        case 3:
                            n ? (t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                                t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                                t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax._elements)) : (t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENT, r.gradientMin._elements),
                                t.setBuffer(Vr.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements));
                    }
                } else t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                    t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                    t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                this._rotationOverLifetime = e;
            }
        }, {
            key: "textureSheetAnimation",
            get: function() {
                return this._textureSheetAnimation;
            },
            set: function(e) {
                var t = this._owner._render._shaderValues;
                if (e) {
                    var r = e.frame,
                        n = r.type;
                    if (e.enable) switch (n) {
                        case 1:
                            t.addDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                            break;

                        case 3:
                            t.addDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    } else t.removeDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                    if (1 === n || 3 === n) {
                        t.setNumber(Vr.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                        var i = e.tiles,
                            a = this._uvLength;
                        a.x = 1 / i.x, a.y = 1 / i.y, t.setVector2(Vr.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                    }
                    switch (n) {
                        case 1:
                            t.setBuffer(Vr.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData._elements);
                            break;

                        case 3:
                            t.setBuffer(Vr.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeDataMin._elements),
                                t.setBuffer(Vr.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax._elements);
                    }
                } else t.removeDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Vr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                this._textureSheetAnimation = e;
            }
        }]), ShurikenParticleSystem;
    }();
    Xr._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]),
        Xr.halfKSqrtOf2 = .71, Xr._maxElapsedTime = 1 / 3, Xr._tempVector30 = new o(), Xr._tempVector31 = new o(),
        Xr._tempVector32 = new o(), Xr._tempVector33 = new o(), Xr._tempVector34 = new o(),
        Xr._tempVector35 = new o(), Xr._tempVector36 = new o(), Xr._tempVector37 = new o(),
        Xr._tempVector38 = new o(), Xr._tempVector39 = new o(), Xr._tempPosition = new o(),
        Xr._tempDirection = new o(), Xr._type = Lt._typeCounter++;
    var Yr = function(e) {
            function ShuriKenParticle3D() {
                var e;
                _classCallCheck(this, ShuriKenParticle3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(ShuriKenParticle3D).call(this, null)))._render = new wr(_assertThisInitialized(e)),
                    e._particleSystem = new Xr(_assertThisInitialized(e));
                var t = e._render._renderElements[0] = new bt();
                return t.setTransform(e._transform), t.render = e._render, t.setGeometry(e._particleSystem),
                    t.material = Br.defaultMaterial, e;
            }
            return _inherits(ShuriKenParticle3D, ue), _createClass(ShuriKenParticle3D, [{
                key: "particleSystem",
                get: function() {
                    return this._particleSystem;
                }
            }, {
                key: "particleRenderer",
                get: function() {
                    return this._render;
                }
            }], [{
                key: "__init__",
                value: function() {
                    Vr.SHADERDEFINE_RENDERMODE_BILLBOARD = G.getDefineByName("SPHERHBILLBOARD"), Vr.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = G.getDefineByName("STRETCHEDBILLBOARD"),
                        Vr.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = G.getDefineByName("HORIZONTALBILLBOARD"),
                        Vr.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = G.getDefineByName("VERTICALBILLBOARD"),
                        Vr.SHADERDEFINE_COLOROVERLIFETIME = G.getDefineByName("COLOROVERLIFETIME"), Vr.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = G.getDefineByName("RANDOMCOLOROVERLIFETIME"),
                        Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = G.getDefineByName("VELOCITYOVERLIFETIMECONSTANT"),
                        Vr.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = G.getDefineByName("VELOCITYOVERLIFETIMECURVE"),
                        Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = G.getDefineByName("VELOCITYOVERLIFETIMERANDOMCONSTANT"),
                        Vr.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = G.getDefineByName("VELOCITYOVERLIFETIMERANDOMCURVE"),
                        Vr.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = G.getDefineByName("TEXTURESHEETANIMATIONCURVE"),
                        Vr.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = G.getDefineByName("TEXTURESHEETANIMATIONRANDOMCURVE"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIME = G.getDefineByName("ROTATIONOVERLIFETIME"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = G.getDefineByName("ROTATIONOVERLIFETIMESEPERATE"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = G.getDefineByName("ROTATIONOVERLIFETIMECONSTANT"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = G.getDefineByName("ROTATIONOVERLIFETIMECURVE"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = G.getDefineByName("ROTATIONOVERLIFETIMERANDOMCONSTANTS"),
                        Vr.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = G.getDefineByName("ROTATIONOVERLIFETIMERANDOMCURVES"),
                        Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVE = G.getDefineByName("SIZEOVERLIFETIMECURVE"),
                        Vr.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = G.getDefineByName("SIZEOVERLIFETIMECURVESEPERATE"),
                        Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = G.getDefineByName("SIZEOVERLIFETIMERANDOMCURVES"),
                        Vr.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = G.getDefineByName("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"),
                        Vr.SHADERDEFINE_RENDERMODE_MESH = G.getDefineByName("RENDERMODE_MESH"), Vr.SHADERDEFINE_SHAPE = G.getDefineByName("SHAPE");
                }
            }]), _createClass(ShuriKenParticle3D, [{
                key: "_parseModule",
                value: function(e, r) {
                    for (var n in r) switch (n) {
                        case "bases":
                            var i = r.bases;
                            for (var a in i) e[a] = i[a];
                            break;

                        case "vector2s":
                            var o = r.vector2s;
                            for (var a in o) {
                                var s = e[a],
                                    l = o[a];
                                s.setValue(l[0], l[1]), e[a] = s;
                            }
                            break;

                        case "vector3s":
                            var u = r.vector3s;
                            for (var a in u) {
                                var c = e[a],
                                    h = u[a];
                                c.setValue(h[0], h[1], h[2]), e[a] = c;
                            }
                            break;

                        case "vector4s":
                            var _ = r.vector4s;
                            for (var a in _) {
                                var d = e[a],
                                    f = _[a];
                                d.setValue(f[0], f[1], f[2], f[3]), e[a] = d;
                            }
                            break;

                        case "gradientDataNumbers":
                            var m = r.gradientDataNumbers;
                            for (var a in m) {
                                for (var T = e[a], p = r[a], v = 0, E = p.length; v < E; v++) {
                                    var g = p[v];
                                    T.add(g.key, g.value);
                                }
                                e[a] = T;
                            }
                            break;

                        case "resources":
                            var y = r.resources;
                            for (var a in y) e[a] = t.Loader.getRes(y[a]);
                            break;

                        case "bursts":
                            var S = r.bursts;
                            for (v = 0, E = S.length; v < E; v++) {
                                var R = S[v];
                                e.addBurst(new mr(R.time, R.min, R.max));
                            }
                            break;

                        case "randomSeed":
                            e.randomSeed[0] = r.randomSeed;
                            break;

                        case "shapeType":
                        case "type":
                        case "color":
                        case "size":
                        case "frame":
                        case "startFrame":
                        case "angularVelocity":
                        case "velocity":
                            break;

                        default:
                            throw "ShurikenParticle3D:unknown type.";
                    }
                }
            }, {
                key: "_parse",
                value: function(e, t) {
                    if (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_parse", this).call(this, e, t),
                        e.main) {
                        var r = this.particleSystem,
                            n = this.particleRenderer;
                        this._parseModule(n, e.renderer), this._parseModule(r, e.main), this._parseModule(r.emission, e.emission);
                        var a = e.shape;
                        if (a) {
                            var s;
                            switch (a.shapeType) {
                                case 0:
                                    s = new Or();
                                    break;

                                case 1:
                                    s = new Ir();
                                    break;

                                case 2:
                                    s = new Lr();
                                    break;

                                case 3:
                                    s = new Dr();
                                    break;

                                case 7:
                                    s = new Ar();
                                    break;

                                default:
                                    throw "ShuriKenParticle3D:unknown shape type.";
                            }
                            this._parseModule(s, a), r.shape = s;
                        }
                        var l = e.velocityOverLifetime;
                        if (l) {
                            var u, c = l.velocity;
                            switch (c.type) {
                                case 0:
                                    var h = c.constant;
                                    u = Rr.createByConstant(h ? new o(h[0], h[1], h[2]) : new o(0, 0, 0));
                                    break;

                                case 1:
                                    u = Rr.createByGradient(this._initParticleVelocity(c.gradientX), this._initParticleVelocity(c.gradientY), this._initParticleVelocity(c.gradientZ));
                                    break;

                                case 2:
                                    var _ = c.constantMin,
                                        d = c.constantMax;
                                    u = Rr.createByRandomTwoConstant(_ ? new o(_[0], _[1], _[2]) : new o(0, 0, 0), d ? new o(d[0], d[1], d[2]) : new o(0, 0, 0));
                                    break;

                                case 3:
                                    u = Rr.createByRandomTwoGradient(this._initParticleVelocity(c.gradientXMin), this._initParticleVelocity(c.gradientXMax), this._initParticleVelocity(c.gradientYMin), this._initParticleVelocity(c.gradientYMax), this._initParticleVelocity(c.gradientZMin), this._initParticleVelocity(c.gradientZMax));
                            }
                            var f = new kr(u);
                            this._parseModule(f, l), r.velocityOverLifetime = f;
                        }
                        var m = e.colorOverLifetime;
                        if (m) {
                            var T, p = m.color;
                            switch (p.type) {
                                case 0:
                                    var v = p.constant;
                                    T = Tr.createByConstant(v ? new i(v[0], v[1], v[2], v[3]) : new i(0, 0, 0, 0));
                                    break;

                                case 1:
                                    T = Tr.createByGradient(this._initParticleColor(p.gradient));
                                    break;

                                case 2:
                                    var E = p.constantMin,
                                        g = p.constantMax;
                                    T = Tr.createByRandomTwoConstant(E ? new i(E[0], E[1], E[2], E[3]) : new i(0, 0, 0, 0), E ? new i(g[0], g[1], g[2], g[3]) : new i(0, 0, 0, 0));
                                    break;

                                case 3:
                                    T = Tr.createByRandomTwoGradient(this._initParticleColor(p.gradientMin), this._initParticleColor(p.gradientMax));
                            }
                            var y = new pr(T);
                            this._parseModule(y, m), r.colorOverLifetime = y;
                        }
                        var S = e.sizeOverLifetime;
                        if (S) {
                            var R, C = S.size;
                            switch (C.type) {
                                case 0:
                                    R = C.separateAxes ? Sr.createByGradientSeparate(this._initParticleSize(C.gradientX), this._initParticleSize(C.gradientY), this._initParticleSize(C.gradientZ)) : Sr.createByGradient(this._initParticleSize(C.gradient));
                                    break;

                                case 1:
                                    if (C.separateAxes) {
                                        var M = C.constantMinSeparate,
                                            x = C.constantMaxSeparate;
                                        R = Sr.createByRandomTwoConstantSeparate(M ? new o(M[0], M[1], M[2]) : new o(0, 0, 0), x ? new o(x[0], x[1], x[2]) : new o(0, 0, 0));
                                    } else R = Sr.createByRandomTwoConstant(C.constantMin || 0, C.constantMax || 0);
                                    break;

                                case 2:
                                    R = C.separateAxes ? Sr.createByRandomTwoGradientSeparate(this._initParticleSize(C.gradientXMin), this._initParticleSize(C.gradientYMin), this._initParticleSize(C.gradientZMin), this._initParticleSize(C.gradientXMax), this._initParticleSize(C.gradientYMax), this._initParticleSize(C.gradientZMax)) : Sr.createByRandomTwoGradient(this._initParticleSize(C.gradientMin), this._initParticleSize(C.gradientMax));
                            }
                            var D = new Pr(R);
                            this._parseModule(D, S), r.sizeOverLifetime = D;
                        }
                        var A = e.rotationOverLifetime;
                        if (A) {
                            var L, I = A.angularVelocity;
                            switch (I.type) {
                                case 0:
                                    if (I.separateAxes) {
                                        var O = I.constantSeparate;
                                        L = Er.createByConstantSeparate(O ? new o(O[0], O[1], O[2]) : new o(0, 0, Math.PI / 4));
                                    } else L = Er.createByConstant(I.constant || Math.PI / 4);
                                    break;

                                case 1:
                                    L = I.separateAxes ? Er.createByGradientSeparate(this._initParticleRotation(I.gradientX), this._initParticleRotation(I.gradientY), this._initParticleRotation(I.gradientZ)) : Er.createByGradient(this._initParticleRotation(I.gradient));
                                    break;

                                case 2:
                                    if (I.separateAxes) {
                                        var P = I.constantMinSeparate,
                                            N = I.constantMaxSeparate;
                                        L = Er.createByRandomTwoConstantSeparate(P ? new o(P[0], P[1], P[2]) : new o(0, 0, 0), N ? new o(N[0], N[1], N[2]) : new o(0, 0, Math.PI / 4));
                                    } else L = Er.createByRandomTwoConstant(I.constantMin || 0, I.constantMax || Math.PI / 4);
                                    break;

                                case 3:
                                    I.separateAxes || (L = Er.createByRandomTwoGradient(this._initParticleRotation(I.gradientMin), this._initParticleRotation(I.gradientMax)));
                            }
                            var b = new Cr(L);
                            this._parseModule(b, A), r.rotationOverLifetime = b;
                        }
                        var k = e.textureSheetAnimation;
                        if (k) {
                            var V, B = k.frame;
                            switch (B.type) {
                                case 0:
                                    V = vr.createByConstant(B.constant);
                                    break;

                                case 1:
                                    V = vr.createByOverTime(this._initParticleFrame(B.overTime));
                                    break;

                                case 2:
                                    V = vr.createByRandomTwoConstant(B.constantMin, B.constantMax);
                                    break;

                                case 3:
                                    V = vr.createByRandomTwoOverTime(this._initParticleFrame(B.overTimeMin), this._initParticleFrame(B.overTimeMax));
                            }
                            var w, F = k.startFrame;
                            switch (F.type) {
                                case 0:
                                    w = Nr.createByConstant(F.constant);
                                    break;

                                case 1:
                                    w = Nr.createByRandomTwoConstant(F.constantMin, F.constantMax);
                            }
                            var U = new br(V, w);
                            this._parseModule(U, k), r.textureSheetAnimation = U;
                        }
                    } else this._parseOld(e);
                }
            }, {
                key: "_activeHierarchy",
                value: function(e) {
                    _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_activeHierarchy", this).call(this, e),
                        this.particleSystem.playOnAwake && this.particleSystem.play();
                }
            }, {
                key: "_inActiveHierarchy",
                value: function(e) {
                    _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_inActiveHierarchy", this).call(this, e),
                        this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
                }
            }, {
                key: "_cloneTo",
                value: function(e, t, r) {
                    var n = e,
                        i = n._particleSystem;
                    this._particleSystem.cloneTo(i);
                    var a = n._render,
                        o = this._render;
                    a.sharedMaterials = o.sharedMaterials, a.enable = o.enable, a.renderMode = o.renderMode,
                        a.mesh = o.mesh, a.stretchedBillboardCameraSpeedScale = o.stretchedBillboardCameraSpeedScale,
                        a.stretchedBillboardSpeedScale = o.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = o.stretchedBillboardLengthScale,
                        a.sortingFudge = o.sortingFudge, _get(_getPrototypeOf(ShuriKenParticle3D.prototype), "_cloneTo", this).call(this, e, t, r);
                }
            }, {
                key: "destroy",
                value: function() {
                    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.destroyed || (_get(_getPrototypeOf(ShuriKenParticle3D.prototype), "destroy", this).call(this, e),
                        this._particleSystem.destroy(), this._particleSystem = null);
                }
            }, {
                key: "_create",
                value: function() {
                    return new ShuriKenParticle3D();
                }
            }, {
                key: "_parseOld",
                value: function(e) {
                    var r, a, s, l = Math.PI / 180,
                        u = this.particleRenderer,
                        c = e.material;
                    c && (s = t.Loader.getRes(c.path)), u.sharedMaterial = s;
                    var h = e.meshPath;
                    h && (u.mesh = t.Loader.getRes(h)), u.renderMode = e.renderMode, u.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale,
                        u.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, u.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale,
                        u.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
                    var _ = this.particleSystem;
                    _.isPerformanceMode = e.isPerformanceMode, _.duration = e.duration, _.looping = e.looping,
                        _.prewarm = e.prewarm, _.startDelayType = e.startDelayType, _.startDelay = e.startDelay,
                        _.startDelayMin = e.startDelayMin, _.startDelayMax = e.startDelayMax, _.startLifetimeType = e.startLifetimeType,
                        _.startLifetimeConstant = e.startLifetimeConstant, _.startLifeTimeGradient = ShuriKenParticle3D._initStartLife(e.startLifetimeGradient),
                        _.startLifetimeConstantMin = e.startLifetimeConstantMin, _.startLifetimeConstantMax = e.startLifetimeConstantMax,
                        _.startLifeTimeGradientMin = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMin),
                        _.startLifeTimeGradientMax = ShuriKenParticle3D._initStartLife(e.startLifetimeGradientMax),
                        _.startSpeedType = e.startSpeedType, _.startSpeedConstant = e.startSpeedConstant,
                        _.startSpeedConstantMin = e.startSpeedConstantMin, _.startSpeedConstantMax = e.startSpeedConstantMax,
                        _.threeDStartSize = e.threeDStartSize, _.startSizeType = e.startSizeType, _.startSizeConstant = e.startSizeConstant;
                    var d = e.startSizeConstantSeparate,
                        f = _.startSizeConstantSeparate;
                    f.x = d[0], f.y = d[1], f.z = d[2], _.startSizeConstantMin = e.startSizeConstantMin,
                        _.startSizeConstantMax = e.startSizeConstantMax;
                    var m = e.startSizeConstantMinSeparate,
                        T = _.startSizeConstantMinSeparate;
                    T.x = m[0], T.y = m[1], T.z = m[2];
                    var p = e.startSizeConstantMaxSeparate,
                        v = _.startSizeConstantMaxSeparate;
                    v.x = p[0], v.y = p[1], v.z = p[2], _.threeDStartRotation = e.threeDStartRotation,
                        _.startRotationType = e.startRotationType, _.startRotationConstant = e.startRotationConstant * l;
                    var E = e.startRotationConstantSeparate,
                        g = _.startRotationConstantSeparate;
                    g.x = E[0] * l, g.y = E[1] * l, g.z = E[2] * l, _.startRotationConstantMin = e.startRotationConstantMin * l,
                        _.startRotationConstantMax = e.startRotationConstantMax * l;
                    var y = e.startRotationConstantMinSeparate,
                        S = _.startRotationConstantMinSeparate;
                    S.x = y[0] * l, S.y = y[1] * l, S.z = y[2] * l;
                    var R = e.startRotationConstantMaxSeparate,
                        C = _.startRotationConstantMaxSeparate;
                    C.x = R[0] * l, C.y = R[1] * l, C.z = R[2] * l, _.randomizeRotationDirection = e.randomizeRotationDirection,
                        _.startColorType = e.startColorType;
                    var M = e.startColorConstant,
                        x = _.startColorConstant;
                    x.x = M[0], x.y = M[1], x.z = M[2], x.w = M[3];
                    var D = e.startColorConstantMin,
                        A = _.startColorConstantMin;
                    A.x = D[0], A.y = D[1], A.z = D[2], A.w = D[3];
                    var L = e.startColorConstantMax,
                        I = _.startColorConstantMax;
                    I.x = L[0], I.y = L[1], I.z = L[2], I.w = L[3], _.gravityModifier = e.gravityModifier,
                        _.simulationSpace = e.simulationSpace, void 0 !== e.simulationSpeed && (_.simulationSpeed = e.simulationSpeed),
                        _.scaleMode = e.scaleMode, _.playOnAwake = e.playOnAwake, _.maxParticles = e.maxParticles;
                    var O = e.autoRandomSeed;
                    null != O && (_.autoRandomSeed = O);
                    var P = e.randomSeed;
                    null != P && (_.randomSeed[0] = P);
                    var N = e.emission,
                        b = _.emission;
                    if (N) {
                        b.emissionRate = N.emissionRate;
                        var k = N.bursts;
                        if (k)
                            for (r = 0, a = k.length; r < a; r++) {
                                var V = k[r];
                                b.addBurst(new mr(V.time, V.min, V.max));
                            }
                        b.enable = N.enable;
                    } else b.enable = !1;
                    var B = e.shape;
                    if (B) {
                        var w;
                        switch (B.shapeType) {
                            case 0:
                                var F;
                                w = F = new Or(), F.radius = B.sphereRadius, F.emitFromShell = B.sphereEmitFromShell,
                                    F.randomDirection = B.sphereRandomDirection;
                                break;

                            case 1:
                                var U;
                                w = U = new Ir(), U.radius = B.hemiSphereRadius, U.emitFromShell = B.hemiSphereEmitFromShell,
                                    U.randomDirection = B.hemiSphereRandomDirection;
                                break;

                            case 2:
                                var G;
                                w = G = new Lr(), G.angle = B.coneAngle * l, G.radius = B.coneRadius, G.length = B.coneLength,
                                    G.emitType = B.coneEmitType, G.randomDirection = B.coneRandomDirection;
                                break;

                            case 3:
                                var z;
                                w = z = new Dr(), z.x = B.boxX, z.y = B.boxY, z.z = B.boxZ, z.randomDirection = B.boxRandomDirection;
                                break;

                            case 7:
                                var H;
                                w = H = new Ar(), H.radius = B.circleRadius, H.arc = B.circleArc * l, H.emitFromEdge = B.circleEmitFromEdge,
                                    H.randomDirection = B.circleRandomDirection;
                                break;

                            default:
                                var W;
                                w = W = new Ar(), W.radius = B.circleRadius, W.arc = B.circleArc * l, W.emitFromEdge = B.circleEmitFromEdge,
                                    W.randomDirection = B.circleRandomDirection;
                        }
                        w.enable = B.enable, _.shape = w;
                    }
                    var X = e.velocityOverLifetime;
                    if (X) {
                        var Y, j = X.velocity;
                        switch (j.type) {
                            case 0:
                                var Q = j.constant;
                                Y = Rr.createByConstant(new o(Q[0], Q[1], Q[2]));
                                break;

                            case 1:
                                Y = Rr.createByGradient(this._initParticleVelocity(j.gradientX), this._initParticleVelocity(j.gradientY), this._initParticleVelocity(j.gradientZ));
                                break;

                            case 2:
                                var Z = j.constantMin,
                                    q = j.constantMax;
                                Y = Rr.createByRandomTwoConstant(new o(Z[0], Z[1], Z[2]), new o(q[0], q[1], q[2]));
                                break;

                            case 3:
                                Y = Rr.createByRandomTwoGradient(this._initParticleVelocity(j.gradientXMin), this._initParticleVelocity(j.gradientXMax), this._initParticleVelocity(j.gradientYMin), this._initParticleVelocity(j.gradientYMax), this._initParticleVelocity(j.gradientZMin), this._initParticleVelocity(j.gradientZMax));
                        }
                        var K = new kr(Y);
                        K.space = X.space, K.enable = X.enable, _.velocityOverLifetime = K;
                    }
                    var J = e.colorOverLifetime;
                    if (J) {
                        var $, ee = J.color;
                        switch (ee.type) {
                            case 0:
                                var te = ee.constant;
                                $ = Tr.createByConstant(new i(te[0], te[1], te[2], te[3]));
                                break;

                            case 1:
                                $ = Tr.createByGradient(this._initParticleColor(ee.gradient));
                                break;

                            case 2:
                                var re = ee.constantMin,
                                    ne = ee.constantMax;
                                $ = Tr.createByRandomTwoConstant(new i(re[0], re[1], re[2], re[3]), new i(ne[0], ne[1], ne[2], ne[3]));
                                break;

                            case 3:
                                $ = Tr.createByRandomTwoGradient(this._initParticleColor(ee.gradientMin), this._initParticleColor(ee.gradientMax));
                        }
                        var ie = new pr($);
                        ie.enable = J.enable, _.colorOverLifetime = ie;
                    }
                    var ae = e.sizeOverLifetime;
                    if (ae) {
                        var oe, se = ae.size;
                        switch (se.type) {
                            case 0:
                                oe = se.separateAxes ? Sr.createByGradientSeparate(this._initParticleSize(se.gradientX), this._initParticleSize(se.gradientY), this._initParticleSize(se.gradientZ)) : Sr.createByGradient(this._initParticleSize(se.gradient));
                                break;

                            case 1:
                                if (se.separateAxes) {
                                    var le = se.constantMinSeparate,
                                        ue = se.constantMaxSeparate;
                                    oe = Sr.createByRandomTwoConstantSeparate(new o(le[0], le[1], le[2]), new o(ue[0], ue[1], ue[2]));
                                } else oe = Sr.createByRandomTwoConstant(se.constantMin, se.constantMax);
                                break;

                            case 2:
                                oe = se.separateAxes ? Sr.createByRandomTwoGradientSeparate(this._initParticleSize(se.gradientXMin), this._initParticleSize(se.gradientYMin), this._initParticleSize(se.gradientZMin), this._initParticleSize(se.gradientXMax), this._initParticleSize(se.gradientYMax), this._initParticleSize(se.gradientZMax)) : Sr.createByRandomTwoGradient(this._initParticleSize(se.gradientMin), this._initParticleSize(se.gradientMax));
                        }
                        var ce = new Pr(oe);
                        ce.enable = ae.enable, _.sizeOverLifetime = ce;
                    }
                    var he = e.rotationOverLifetime;
                    if (he) {
                        var _e, de = he.angularVelocity;
                        switch (de.type) {
                            case 0:
                                if (de.separateAxes) {
                                    var fe = de.constantSeparate;
                                    _e = Er.createByConstantSeparate(new o(fe[0] * l, fe[1] * l, fe[2] * l));
                                } else _e = Er.createByConstant(de.constant * l);
                                break;

                            case 1:
                                _e = de.separateAxes ? Er.createByGradientSeparate(this._initParticleRotation(de.gradientX), this._initParticleRotation(de.gradientY), this._initParticleRotation(de.gradientZ)) : Er.createByGradient(this._initParticleRotation(de.gradient));
                                break;

                            case 2:
                                if (de.separateAxes) {
                                    var me = de.constantMinSeparate,
                                        Te = de.constantMaxSeparate;
                                    _e = Er.createByRandomTwoConstantSeparate(new o(me[0] * l, me[1] * l, me[2] * l), new o(Te[0] * l, Te[1] * l, Te[2] * l));
                                } else _e = Er.createByRandomTwoConstant(de.constantMin * l, de.constantMax * l);
                                break;

                            case 3:
                                de.separateAxes || (_e = Er.createByRandomTwoGradient(this._initParticleRotation(de.gradientMin), this._initParticleRotation(de.gradientMax)));
                        }
                        var pe = new Cr(_e);
                        pe.enable = he.enable, _.rotationOverLifetime = pe;
                    }
                    var ve = e.textureSheetAnimation;
                    if (ve) {
                        var Ee, ge = ve.frame;
                        switch (ge.type) {
                            case 0:
                                Ee = vr.createByConstant(ge.constant);
                                break;

                            case 1:
                                Ee = vr.createByOverTime(this._initParticleFrame(ge.overTime));
                                break;

                            case 2:
                                Ee = vr.createByRandomTwoConstant(ge.constantMin, ge.constantMax);
                                break;

                            case 3:
                                Ee = vr.createByRandomTwoOverTime(this._initParticleFrame(ge.overTimeMin), this._initParticleFrame(ge.overTimeMax));
                        }
                        var ye, Se = ve.startFrame;
                        switch (Se.type) {
                            case 0:
                                ye = Nr.createByConstant(Se.constant);
                                break;

                            case 1:
                                ye = Nr.createByRandomTwoConstant(Se.constantMin, Se.constantMax);
                        }
                        var Re = new br(Ee, ye);
                        Re.enable = ve.enable;
                        var Ce = ve.tiles;
                        Re.tiles = new n(Ce[0], Ce[1]), Re.type = ve.type, Re.randomRow = ve.randomRow;
                        var Me = ve.rowIndex;
                        void 0 !== Me && (Re.rowIndex = Me), Re.cycles = ve.cycles, _.textureSheetAnimation = Re;
                    }
                }
            }, {
                key: "_initParticleColor",
                value: function(e) {
                    var t = new fr(4, 4);
                    if (e) {
                        var r, n, i = e.alphas;
                        if (i)
                            for (r = 0, n = i.length; r < n; r++) {
                                3 == r && n > 4 && (r = n - 1, console.warn("GradientDataColor warning:alpha data length is large than 4, will ignore the middle data."));
                                var a = i[r];
                                t.addColorAlpha(a.key, a.value);
                            } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1);
                        var o = e.rgbs;
                        if (o)
                            for (r = 0, n = o.length; r < n; r++) {
                                3 == r && n > 4 && (r = n - 1, console.warn("GradientDataColor warning:rgb data length is large than 4, will ignore the middle data."));
                                var s = o[r],
                                    l = s.value;
                                t.addColorRGB(s.key, new ae(l[0], l[1], l[2], 1));
                            } else t.addColorRGB(0, new ae(1, 1, 1, 1)), t.addColorRGB(1, new ae(1, 1, 1, 1));
                    } else t.addColorAlpha(0, 1), t.addColorAlpha(1, 1), t.addColorRGB(0, new ae(1, 1, 1, 1)),
                        t.addColorRGB(1, new ae(1, 1, 1, 1));
                    return t;
                }
            }, {
                key: "_initParticleFrame",
                value: function(e) {
                    var t = new gr();
                    if (e)
                        for (var r = e.frames, n = 0, i = r.length; n < i; n++) {
                            var a = r[n];
                            t.add(a.key, a.value);
                        } else t.add(0, 0), t.add(1, 1);
                    return t;
                }
            }, {
                key: "_initParticleVelocity",
                value: function(e) {
                    for (var t = new yr(), r = e.velocitys, n = 0, i = r.length; n < i; n++) {
                        var a = r[n];
                        t.add(a.key, a.value);
                    }
                    return t;
                }
            }, {
                key: "_initParticleSize",
                value: function(e) {
                    var t = new yr();
                    if (e)
                        for (var r = e.sizes, n = 0, i = r.length; n < i; n++) {
                            var a = r[n];
                            t.add(a.key, a.value);
                        } else t.add(0, 0), t.add(1, 1);
                    return t;
                }
            }, {
                key: "_initParticleRotation",
                value: function(e) {
                    for (var t = new yr(), r = e.angularVelocitys, n = 0, i = r.length; n < i; n++) {
                        var a = r[n];
                        t.add(a.key, a.value / 180 * Math.PI);
                    }
                    return t;
                }
            }], [{
                key: "_initStartLife",
                value: function(e) {
                    for (var t = new yr(), r = e.startLifetimes, n = 0, i = r.length; n < i; n++) {
                        var a = r[n];
                        t.add(a.key, a.value);
                    }
                    return t;
                }
            }]), ShuriKenParticle3D;
        }(),
        jr = function SkinnedMeshSprite3DShaderDeclaration() {
            _classCallCheck(this, SkinnedMeshSprite3DShaderDeclaration);
        },
        Qr = function(e) {
            function SkinnedMeshRenderer(e) {
                var t;
                return _classCallCheck(this, SkinnedMeshRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshRenderer).call(this, e)))._bones = [],
                    t._skinnedDataLoopMarks = [], t._localBounds = new At(o._ZERO, o._ZERO), t._cacheAnimationNode = [],
                    t;
            }
            return _inherits(SkinnedMeshRenderer, lr), _createClass(SkinnedMeshRenderer, [{
                key: "_computeSkinnedData",
                value: function() {
                    if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                        for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._skinnedMatrixCaches, r = 0, n = this._cacheMesh.subMeshCount; r < n; r++)
                            for (var i = this._cacheMesh.getSubMesh(r)._boneIndicesList, a = this._skinnedData[r], o = 0, s = i.length; o < s; o++) {
                                var l = i[o];
                                this._computeSubSkinnedData(e, l, a[o], t);
                            }
                }
            }, {
                key: "_computeSubSkinnedData",
                value: function(e, r, n, i) {
                    for (var a = 0, o = r.length; a < o; a++) {
                        var s = r[a];
                        if (this._skinnedDataLoopMarks[s] === t.Stat.loopCount)
                            for (var l = i[s], u = this._skinnedData[l.subMeshIndex][l.batchIndex], c = 16 * l.batchBoneIndex, h = 16 * a, _ = 0; _ < 16; _++) n[h + _] = u[c + _];
                        else this._cacheAvatar ? R._mulMatrixArray(this._cacheAnimationNode[s].transform.getWorldMatrix(), e[s].elements, 0, n, 16 * a) : R._mulMatrixArray(this._bones[s].transform.worldMatrix.elements, e[s].elements, 0, n, 16 * a),
                            this._skinnedDataLoopMarks[s] = t.Stat.loopCount;
                    }
                }
            }, {
                key: "_onWorldMatNeedChange",
                value: function(e) {
                    this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= se.TRANSFORM_WORLDPOSITION | se.TRANSFORM_WORLDQUATERNION | se.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
                }
            }, {
                key: "_createRenderElement",
                value: function() {
                    return new bt();
                }
            }, {
                key: "_onMeshChange",
                value: function(e) {
                    _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_onMeshChange", this).call(this, e),
                        this._cacheMesh = e;
                    var t = e.subMeshCount;
                    this._skinnedData = [], this._skinnedDataLoopMarks.length = e._inverseBindPoses.length;
                    for (var r = 0; r < t; r++)
                        for (var n = e.getSubMesh(r)._boneIndicesList, i = n.length, a = this._skinnedData[r] = [], o = 0; o < i; o++) a[o] = new Float32Array(16 * n[o].length);
                    this._cacheAvatar && e && this._getCacheAnimationNodes();
                }
            }, {
                key: "_setCacheAnimator",
                value: function(e) {
                    this._cacheAnimator = e, this._shaderValues.addDefine(jr.SHADERDEFINE_BONE), this._setRootNode();
                }
            }, {
                key: "_calculateBoundingBox",
                value: function() {
                    if (this._cacheAvatar)
                        if (this._cacheAnimator && this._rootBone) {
                            var e = SkinnedMeshRenderer._tempMatrix4x4;
                            R.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e),
                                this._localBounds._tranform(e, this._bounds);
                        } else _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_calculateBoundingBox", this).call(this);
                    else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
                    if (t.Render.supportWebGLPlusCulling) {
                        var r = this._bounds.getMin(),
                            n = this._bounds.getMax(),
                            i = de._cullingBuffer;
                        i[this._cullingBufferIndex + 1] = r.x, i[this._cullingBufferIndex + 2] = r.y, i[this._cullingBufferIndex + 3] = r.z,
                            i[this._cullingBufferIndex + 4] = n.x, i[this._cullingBufferIndex + 5] = n.y, i[this._cullingBufferIndex + 6] = n.z;
                    }
                }
            }, {
                key: "_renderUpdate",
                value: function(e, t) {
                    if (this._cacheAnimator)
                        if (this._computeSkinnedData(), this._cacheAvatar) {
                            var r = this._cacheAnimator.owner._transform;
                            this._shaderValues.setMatrix4x4(le.WORLDMATRIX, r.worldMatrix);
                        } else this._shaderValues.setMatrix4x4(le.WORLDMATRIX, L.DEFAULT);
                    else this._shaderValues.setMatrix4x4(le.WORLDMATRIX, t.worldMatrix);
                }
            }, {
                key: "_renderUpdateWithCamera",
                value: function(e, t) {
                    var r = e.projectionViewMatrix;
                    if (this._cacheAnimator)
                        if (this._cacheAvatar) {
                            var n = this._cacheAnimator.owner._transform;
                            L.multiply(r, n.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(le.MVPMATRIX, this._projectionViewWorldMatrix);
                        } else this._shaderValues.setMatrix4x4(le.MVPMATRIX, r);
                    else L.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
                        this._shaderValues.setMatrix4x4(le.MVPMATRIX, this._projectionViewWorldMatrix);
                }
            }, {
                key: "_destroy",
                value: function() {
                    _get(_getPrototypeOf(SkinnedMeshRenderer.prototype), "_destroy", this).call(this),
                        this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                }
            }, {
                key: "_setRootBone",
                value: function(e) {
                    this._rootBone = e, this._setRootNode();
                }
            }, {
                key: "_setRootNode",
                value: function() {
                    var e;
                    e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null,
                        this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(se.TRANSFORM_WORLDPOSITION | se.TRANSFORM_WORLDQUATERNION | se.TRANSFORM_WORLDSCALE),
                            this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                            this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                            e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                            this._cacheRootAnimationNode = e);
                }
            }, {
                key: "_getCacheAnimationNodes",
                value: function() {
                    var e = this._cacheMesh._boneNames,
                        r = this._cacheMesh._inverseBindPoses.length;
                    if (t.Render.supportWebGLPlusAnimation) {
                        this._cacheAnimationNodeIndices = new Uint16Array(r);
                        var n = this._cacheAnimator._avatarNodeMap;
                        for (o = 0; o < r; o++) {
                            var i = n[e[o]];
                            this._cacheAnimationNodeIndices[o] = i ? i._worldMatrixIndex : 0;
                        }
                    } else {
                        this._cacheAnimationNode.length = r;
                        for (var a = this._cacheAnimator._avatarNodeMap, o = 0; o < r; o++) {
                            var s = a[e[o]];
                            this._cacheAnimationNode[o] = s;
                        }
                    }
                }
            }, {
                key: "_setCacheAvatar",
                value: function(e) {
                    this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._shaderValues.addDefine(jr.SHADERDEFINE_BONE),
                        this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
                }
            }, {
                key: "_computeSubSkinnedDataNative",
                value: function(e, r, n, i, a) {
                    t.LayaGL.instance.computeSubSkinnedData(e, r, n, i, a);
                }
            }, {
                key: "_computeSkinnedDataForNative",
                value: function() {
                    if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                        for (var e = this._cacheMesh._inverseBindPoses, r = this._cacheMesh._skinnedMatrixCaches, n = 0, i = this._cacheMesh.subMeshCount; n < i; n++)
                            for (var a = this._cacheMesh.getSubMesh(n)._boneIndicesList, o = this._skinnedData[n], s = 0, l = a.length; s < l; s++) {
                                var u = a[s];
                                this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, u, o[s]) : this._computeSubSkinnedData(e, u, o[s], r);
                            }
                }
            }, {
                key: "localBounds",
                get: function() {
                    return this._localBounds;
                },
                set: function(e) {
                    this._localBounds = e;
                }
            }, {
                key: "rootBone",
                get: function() {
                    return this._cacheRootBone;
                },
                set: function(e) {
                    this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                        e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                        this._cacheRootBone = e, this._onWorldMatNeedChange(se.TRANSFORM_WORLDPOSITION | se.TRANSFORM_WORLDQUATERNION | se.TRANSFORM_WORLDSCALE));
                }
            }, {
                key: "bones",
                get: function() {
                    return this._bones;
                }
            }, {
                key: "bounds",
                get: function() {
                    return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(),
                        this._boundsChange = !1), this._bounds;
                }
            }]), SkinnedMeshRenderer;
        }();
    Qr._tempMatrix4x4 = new L();
    var Zr = function(e) {
        function SkinnedMeshSprite3D() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
            return _classCallCheck(this, SkinnedMeshSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkinnedMeshSprite3D).call(this, r)))._meshFilter = new ur(_assertThisInitialized(e)),
                e._render = new Qr(_assertThisInitialized(e)), t && (e._meshFilter.sharedMesh = t),
                e;
        }
        return _inherits(SkinnedMeshSprite3D, ue), _createClass(SkinnedMeshSprite3D, [{
            key: "_parse",
            value: function(e, r) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_parse", this).call(this, e, r);
                var n = this.skinnedMeshRenderer,
                    a = e.lightmapIndex;
                null != a && (n.lightmapIndex = a);
                var s, l = e.lightmapScaleOffset;
                if (l && (n.lightmapScaleOffset = new i(l[0], l[1], l[2], l[3])), s = e.meshPath) {
                    var u = t.Loader.getRes(s);
                    u && (this.meshFilter.sharedMesh = u);
                }
                var c = e.materials;
                if (c) {
                    var h = n.sharedMaterials,
                        _ = c.length;
                    h.length = _;
                    for (var d = 0; d < _; d++) h[d] = t.Loader.getRes(c[d].path);
                    n.sharedMaterials = h;
                }
                var f = e.boundBox,
                    m = f.min,
                    T = f.max;
                if (n.localBounds.setMin(new o(m[0], m[1], m[2])), n.localBounds.setMax(new o(T[0], T[1], T[2])),
                    r) {
                    var p = e.rootBone;
                    n.rootBone = r[p];
                    var v, E = e.bones;
                    for (d = 0, v = E.length; d < v; d++) n.bones.push(r[E[d]]);
                } else e.rootBone && n._setRootBone(e.rootBone);
            }
        }, {
            key: "_changeHierarchyAnimator",
            value: function(e) {
                _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_changeHierarchyAnimator", this).call(this, e),
                    this.skinnedMeshRenderer._setCacheAnimator(e);
            }
        }, {
            key: "_changeAnimatorAvatar",
            value: function(e) {
                this.skinnedMeshRenderer._setCacheAvatar(e);
            }
        }, {
            key: "_cloneTo",
            value: function(e, t, r) {
                var n = e;
                n.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
                var i = this._render,
                    a = n._render;
                a.enable = i.enable, a.sharedMaterials = i.sharedMaterials, a.castShadow = i.castShadow;
                var o = i.lightmapScaleOffset;
                o && (a.lightmapScaleOffset = o.clone()), a.receiveShadow = i.receiveShadow, a.sortingFudge = i.sortingFudge,
                    a._rootBone = i._rootBone;
                var s = i.bones,
                    l = a.bones,
                    u = s.length;
                l.length = u;
                var c = i.rootBone;
                if (c) {
                    var h = R._getHierarchyPath(t, c, SkinnedMeshSprite3D._tempArray0);
                    a.rootBone = h ? R._getNodeByHierarchyPath(r, h) : c;
                }
                for (var _ = 0; _ < s.length; _++) h = R._getHierarchyPath(t, s[_], SkinnedMeshSprite3D._tempArray0),
                    l[_] = h ? R._getNodeByHierarchyPath(r, h) : s[_];
                var d = i.localBounds;
                d && d.cloneTo(a.localBounds), _get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
            }
        }, {
            key: "destroy",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                this.destroyed || (_get(_getPrototypeOf(SkinnedMeshSprite3D.prototype), "destroy", this).call(this, e),
                    this._meshFilter.destroy());
            }
        }, {
            key: "_create",
            value: function() {
                return new SkinnedMeshSprite3D();
            }
        }, {
            key: "meshFilter",
            get: function() {
                return this._meshFilter;
            }
        }, {
            key: "skinnedMeshRenderer",
            get: function() {
                return this._render;
            }
        }], [{
            key: "__init__",
            value: function() {
                jr.SHADERDEFINE_BONE = G.getDefineByName("BONE");
            }
        }]), SkinnedMeshSprite3D;
    }();
    Zr._tempArray0 = [], Zr.BONES = G.propertyNameToID("u_Bones");
    var qr = function(e) {
        function TrailMaterial() {
            var e;
            return _classCallCheck(this, TrailMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailMaterial).call(this))).setShaderName("Trail"),
                e._color = new i(1, 1, 1, 1), e._shaderValues.setVector(TrailMaterial.TINTCOLOR, new i(1, 1, 1, 1)),
                e.renderMode = TrailMaterial.RENDERMODE_ALPHABLENDED, e;
        }
        return _inherits(TrailMaterial, j), _createClass(TrailMaterial, [{
            key: "clone",
            value: function() {
                var e = new TrailMaterial();
                return this.cloneTo(e), e;
            }
        }, {
            key: "_TintColorR",
            get: function() {
                return this._color.x;
            },
            set: function(e) {
                this._color.x = e, this.color = this._color;
            }
        }, {
            key: "_TintColorG",
            get: function() {
                return this._color.y;
            },
            set: function(e) {
                this._color.y = e, this.color = this._color;
            }
        }, {
            key: "_TintColorB",
            get: function() {
                return this._color.z;
            },
            set: function(e) {
                this._color.z = e, this.color = this._color;
            }
        }, {
            key: "_TintColorA",
            get: function() {
                return this._color.w;
            },
            set: function(e) {
                this._color.w = e, this.color = this._color;
            }
        }, {
            key: "_MainTex_STX",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).x;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.x = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STY",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).y;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.y = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STZ",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).z;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.z = e, this.tilingOffset = t;
            }
        }, {
            key: "_MainTex_STW",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET).w;
            },
            set: function(e) {
                var t = this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
                t.w = e, this.tilingOffset = t;
            }
        }, {
            key: "renderMode",
            set: function(e) {
                switch (e) {
                    case TrailMaterial.RENDERMODE_ADDTIVE:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_NONE, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE, this.depthTest = Z.DEPTHTEST_LESS, this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    case TrailMaterial.RENDERMODE_ALPHABLENDED:
                        this.renderQueue = j.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                            this.cull = Z.CULL_NONE, this.blend = Z.BLEND_ENABLE_ALL, this.blendSrc = Z.BLENDPARAM_SRC_ALPHA,
                            this.blendDst = Z.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = Z.DEPTHTEST_LESS,
                            this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_ADDTIVEFOG);
                        break;

                    default:
                        throw new Error("TrailMaterial : renderMode value error.");
                }
            }
        }, {
            key: "colorR",
            get: function() {
                return this._TintColorR;
            },
            set: function(e) {
                this._TintColorR = e;
            }
        }, {
            key: "colorG",
            get: function() {
                return this._TintColorG;
            },
            set: function(e) {
                this._TintColorG = e;
            }
        }, {
            key: "colorB",
            get: function() {
                return this._TintColorB;
            },
            set: function(e) {
                this._TintColorB = e;
            }
        }, {
            key: "colorA",
            get: function() {
                return this._TintColorA;
            },
            set: function(e) {
                this._TintColorA = e;
            }
        }, {
            key: "color",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TINTCOLOR);
            },
            set: function(e) {
                this._shaderValues.setVector(TrailMaterial.TINTCOLOR, e);
            }
        }, {
            key: "texture",
            get: function() {
                return this._shaderValues.getTexture(TrailMaterial.MAINTEXTURE);
            },
            set: function(e) {
                e ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_MAINTEXTURE),
                    this._shaderValues.setTexture(TrailMaterial.MAINTEXTURE, e);
            }
        }, {
            key: "tilingOffsetX",
            get: function() {
                return this._MainTex_STX;
            },
            set: function(e) {
                this._MainTex_STX = e;
            }
        }, {
            key: "tilingOffsetY",
            get: function() {
                return this._MainTex_STY;
            },
            set: function(e) {
                this._MainTex_STY = e;
            }
        }, {
            key: "tilingOffsetZ",
            get: function() {
                return this._MainTex_STZ;
            },
            set: function(e) {
                this._MainTex_STZ = e;
            }
        }, {
            key: "tilingOffsetW",
            get: function() {
                return this._MainTex_STW;
            },
            set: function(e) {
                this._MainTex_STW = e;
            }
        }, {
            key: "tilingOffset",
            get: function() {
                return this._shaderValues.getVector(TrailMaterial.TILINGOFFSET);
            },
            set: function(e) {
                e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(TrailMaterial.SHADERDEFINE_TILINGOFFSET),
                    this._shaderValues.setVector(TrailMaterial.TILINGOFFSET, e);
            }
        }, {
            key: "depthWrite",
            set: function(e) {
                this._shaderValues.setBool(TrailMaterial.DEPTH_WRITE, e);
            },
            get: function() {
                return this._shaderValues.getBool(TrailMaterial.DEPTH_WRITE);
            }
        }, {
            key: "cull",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.CULL, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.CULL);
            }
        }, {
            key: "blend",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND);
            }
        }, {
            key: "blendSrc",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_SRC, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_SRC);
            }
        }, {
            key: "blendDst",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.BLEND_DST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.BLEND_DST);
            }
        }, {
            key: "depthTest",
            set: function(e) {
                this._shaderValues.setInt(TrailMaterial.DEPTH_TEST, e);
            },
            get: function() {
                return this._shaderValues.getInt(TrailMaterial.DEPTH_TEST);
            }
        }], [{
            key: "__initDefine__",
            value: function() {
                TrailMaterial.SHADERDEFINE_MAINTEXTURE = G.getDefineByName("MAINTEXTURE"), TrailMaterial.SHADERDEFINE_TILINGOFFSET = G.getDefineByName("TILINGOFFSET"),
                    TrailMaterial.SHADERDEFINE_ADDTIVEFOG = G.getDefineByName("ADDTIVEFOG");
            }
        }]), TrailMaterial;
    }();
    qr.RENDERMODE_ALPHABLENDED = 0, qr.RENDERMODE_ADDTIVE = 1, qr.MAINTEXTURE = G.propertyNameToID("u_MainTexture"),
        qr.TINTCOLOR = G.propertyNameToID("u_MainColor"), qr.TILINGOFFSET = G.propertyNameToID("u_TilingOffset"),
        qr.CULL = G.propertyNameToID("s_Cull"), qr.BLEND = G.propertyNameToID("s_Blend"),
        qr.BLEND_SRC = G.propertyNameToID("s_BlendSrc"), qr.BLEND_DST = G.propertyNameToID("s_BlendDst"),
        qr.DEPTH_TEST = G.propertyNameToID("s_DepthTest"), qr.DEPTH_WRITE = G.propertyNameToID("s_DepthWrite");
    var Kr, Jr = function TextureMode() {
        _classCallCheck(this, TextureMode);
    };
    Jr.Stretch = 0, Jr.Tile = 1, (Kr = e.TrailAlignment || (e.TrailAlignment = {}))[Kr.View = 0] = "View",
        Kr[Kr.TransformZ = 1] = "TransformZ";
    var $r = function() {
        function VertexTrail() {
            _classCallCheck(this, VertexTrail);
        }
        return _createClass(VertexTrail, [{
            key: "vertexDeclaration",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        }], [{
            key: "__init__",
            value: function() {
                VertexTrail._vertexDeclaration1 = new Oe(32, [new Pe(0, Ie.Vector3, VertexTrail.TRAIL_POSITION0), new Pe(12, Ie.Vector3, VertexTrail.TRAIL_OFFSETVECTOR), new Pe(24, Ie.Single, VertexTrail.TRAIL_TIME0), new Pe(28, Ie.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0Y)]),
                    VertexTrail._vertexDeclaration2 = new Oe(20, [new Pe(0, Ie.Single, VertexTrail.TRAIL_TEXTURECOORDINATE0X), new Pe(4, Ie.Color, VertexTrail.TRAIL_COLOR)]);
            }
        }, {
            key: "vertexDeclaration1",
            get: function() {
                return VertexTrail._vertexDeclaration1;
            }
        }, {
            key: "vertexDeclaration2",
            get: function() {
                return VertexTrail._vertexDeclaration2;
            }
        }]), VertexTrail;
    }();
    $r.TRAIL_POSITION0 = 0, $r.TRAIL_OFFSETVECTOR = 1, $r.TRAIL_TIME0 = 2, $r.TRAIL_TEXTURECOORDINATE0Y = 3,
        $r.TRAIL_TEXTURECOORDINATE0X = 4, $r.TRAIL_COLOR = 5;
    var en = function(n) {
        function TrailGeometry(e) {
            var r;
            _classCallCheck(this, TrailGeometry), (r = _possibleConstructorReturn(this, _getPrototypeOf(TrailGeometry).call(this)))._floatCountPerVertices1 = 8,
                r._floatCountPerVertices2 = 5, r._increaseSegementCount = 16, r._activeIndex = 0,
                r._endIndex = 0, r._needAddFirstVertex = !1, r._isTempEndVertex = !1, r._vertices1 = null,
                r._vertices2 = null, r._lastFixedVertexPosition = new o(), r._bufferState = new Ae(),
                r.tmpColor = new ae(), r._disappearBoundsMode = !1, r._owner = e, r._segementCount = r._increaseSegementCount,
                r._resizeData(r._segementCount, r._bufferState);
            var n = r._owner._owner.trailRenderer.bounds,
                i = r._owner._owner.transform.position;
            return n.setMin(i), n.setMax(i), t.Render.supportWebGLPlusCulling && r._calculateBoundingBoxForNative(),
                r;
        }
        return _inherits(TrailGeometry, Lt), _createClass(TrailGeometry, [{
            key: "_resizeData",
            value: function(e, r) {
                this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(e);
                var n = t.LayaGL.instance,
                    i = 2 * e,
                    a = $r.vertexDeclaration1,
                    o = $r.vertexDeclaration2,
                    s = [],
                    l = i * a.vertexStride,
                    u = i * o.vertexStride,
                    c = l + u;
                this._vertices1 = new Float32Array(i * this._floatCountPerVertices1), this._vertices2 = new Float32Array(i * this._floatCountPerVertices2),
                    this._vertexBuffer1 = new be(l, n.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = a,
                    this._vertexBuffer2 = new be(u, n.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = o,
                    s.push(this._vertexBuffer1), s.push(this._vertexBuffer2), r.bind(), r.applyVertexBuffers(s),
                    r.unBind(), t.Resource._addMemory(c, c);
            }
        }, {
            key: "_resetData",
            value: function() {
                var e = this._endIndex - this._activeIndex,
                    r = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e),
                    n = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e),
                    i = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e),
                    a = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
                if (e === this._segementCount) {
                    this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy();
                    var o = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                    t.Resource._addMemory(-o, -o), this._segementCount += this._increaseSegementCount,
                        this._resizeData(this._segementCount, this._bufferState);
                }
                this._vertices1.set(r, 0), this._vertices2.set(n, 0), this._subDistance.set(i, 0),
                    this._subBirthTime.set(a, 0), this._endIndex = e, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4),
                    this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
            }
        }, {
            key: "_updateTrail",
            value: function(e, t, r) {
                o.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r));
            }
        }, {
            key: "_addTrailByFirstPosition",
            value: function(e, t) {
                this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0,
                    this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition),
                    this._needAddFirstVertex = !0;
            }
        }, {
            key: "_addTrailByNextPosition",
            value: function(t, n) {
                var i = TrailGeometry._tempVector30,
                    a = TrailGeometry._tempVector31;
                switch (this._owner.alignment) {
                    case e.TrailAlignment.View:
                        var s = t.viewMatrix;
                        o.transformCoordinate(n, s, TrailGeometry._tempVector33), o.transformCoordinate(this._lastFixedVertexPosition, s, TrailGeometry._tempVector34),
                            o.subtract(TrailGeometry._tempVector33, TrailGeometry._tempVector34, i), o.cross(TrailGeometry._tempVector33, i, a);
                        break;

                    case e.TrailAlignment.TransformZ:
                        o.subtract(n, this._lastFixedVertexPosition, i);
                        var l = TrailGeometry._tempVector32;
                        this._owner._owner.transform.getForward(l), o.cross(i, l, a);
                }
                o.normalize(a, a), o.scale(a, this._owner.widthMultiplier / 2, a);
                var u, c, h = o.scalarLength(i);
                this._needAddFirstVertex && (this._updateVerticesByPositionData(n, a, this._endIndex - 1),
                    this._needAddFirstVertex = !1), h - this._owner.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (u = this._endIndex - 1,
                    c = h - this._subDistance[u], this._updateVerticesByPosition(n, a, h, u), this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(n, a, h, this._endIndex), this._owner._totalLength += h,
                    this._endIndex++), n.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (u = this._endIndex - 1,
                    c = h - this._subDistance[u], this._updateVerticesByPosition(n, a, h, u), this._owner._totalLength += c) : (this._endIndex === this._segementCount && this._resetData(),
                    this._updateVerticesByPosition(n, a, h, this._endIndex), this._owner._totalLength += h,
                    this._endIndex++), this._isTempEndVertex = !0);
            }
        }, {
            key: "_updateVerticesByPositionData",
            value: function(e, r, n) {
                var i = 2 * this._floatCountPerVertices1 * n,
                    a = this._owner._curtime;
                this._vertices1[i] = e.x, this._vertices1[i + 1] = e.y, this._vertices1[i + 2] = e.z,
                    this._vertices1[i + 3] = -r.x, this._vertices1[i + 4] = -r.y, this._vertices1[i + 5] = -r.z,
                    this._vertices1[i + 6] = a, this._vertices1[i + 7] = 1, this._vertices1[i + 8] = e.x,
                    this._vertices1[i + 9] = e.y, this._vertices1[i + 10] = e.z, this._vertices1[i + 11] = r.x,
                    this._vertices1[i + 12] = r.y, this._vertices1[i + 13] = r.z, this._vertices1[i + 14] = a,
                    this._vertices1[i + 15] = 0;
                var s = this._owner._owner.trailRenderer.bounds,
                    l = s.getMin(),
                    u = s.getMax(),
                    c = TrailGeometry._tempVector35,
                    h = TrailGeometry._tempVector36,
                    _ = TrailGeometry._tempVector32;
                o.add(e, r, c), o.subtract(e, r, h), o.min(h, c, _), o.min(l, _, l), s.setMin(l),
                    o.max(c, h, _), o.max(u, _, u), s.setMax(u), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                var d = 2 * this._floatCountPerVertices1;
                this._vertexBuffer1.setData(this._vertices1.buffer, 4 * i, 4 * i, 4 * d);
            }
        }, {
            key: "_updateVerticesByPosition",
            value: function(e, t, r, n) {
                this._updateVerticesByPositionData(e, t, n), this._subDistance[n] = r, this._subBirthTime[n] = this._owner._curtime;
            }
        }, {
            key: "_updateVertexBufferUV",
            value: function() {
                var e, r, n;
                if (this._disappearBoundsMode) {
                    e = this._owner._owner.trailRenderer.bounds;
                    var i = this._owner._owner.transform.position;
                    e.setMin(i), e.setMax(i), r = e.getMin(), n = e.getMax(), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
                }
                for (var a = this._endIndex, s = 0, l = this._owner.colorGradient, u = l.colorAlphaKeysCount - 1, c = l.colorRGBKeysCount - 1, h = this._owner._totalLength, _ = 2 * this._floatCountPerVertices2, d = this._activeIndex; d < a; d++) {
                    var f, m;
                    d !== this._activeIndex && (s += this._subDistance[d]), this._owner.textureMode == Jr.Stretch ? m = f = 1 - s / h : (m = 1 - s / h,
                        f = 1 - (h - s)), c = l.evaluateColorRGB(m, this.tmpColor, c, !0), u = l.evaluateColorAlpha(m, this.tmpColor, u, !0);
                    var T = d * _;
                    if (this._vertices2[T + 0] = f, this._vertices2[T + 1] = this.tmpColor.r, this._vertices2[T + 2] = this.tmpColor.g,
                        this._vertices2[T + 3] = this.tmpColor.b, this._vertices2[T + 4] = this.tmpColor.a,
                        this._vertices2[T + 5] = f, this._vertices2[T + 6] = this.tmpColor.r, this._vertices2[T + 7] = this.tmpColor.g,
                        this._vertices2[T + 8] = this.tmpColor.b, this._vertices2[T + 9] = this.tmpColor.a,
                        this._disappearBoundsMode) {
                        var p = 2 * this._floatCountPerVertices1 * d,
                            v = TrailGeometry._tempVector32,
                            E = TrailGeometry._tempVector33,
                            g = TrailGeometry._tempVector34;
                        v.setValue(this._vertices1[p + 0], this._vertices1[p + 1], this._vertices1[p + 2]),
                            E.setValue(this._vertices1[p + 3], this._vertices1[p + 4], this._vertices1[p + 5]),
                            o.add(v, E, g), o.min(g, r, r), o.max(g, n, n), o.subtract(v, E, g), o.min(g, r, r),
                            o.max(g, n, n);
                    }
                }
                this._disappearBoundsMode && (e.setMin(r), e.setMax(n), this._disappearBoundsMode = !1,
                    t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
                var y = this._activeIndex * _;
                this._vertexBuffer2.setData(this._vertices2.buffer, 4 * y, 4 * y, 4 * (a * _ - y));
            }
        }, {
            key: "_updateDisappear",
            value: function() {
                for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++) {
                    var n = t + 1;
                    if (n !== e && (this._owner._totalLength -= this._subDistance[n]), this._isTempEndVertex && n === e - 1) {
                        this._floatCountPerVertices1;
                        var i = this._lastFixedVertexPosition;
                        i.x = this._vertices1[0], i.y = this._vertices1[1], i.z = this._vertices1[2], this._isTempEndVertex = !1;
                    }
                    this._activeIndex++, this._disappearBoundsMode = !0;
                }
            }
        }, {
            key: "_getType",
            value: function() {
                return TrailGeometry._type;
            }
        }, {
            key: "_prepareRender",
            value: function(e) {
                return this._endIndex - this._activeIndex > 1;
            }
        }, {
            key: "_render",
            value: function(e) {
                this._bufferState.bind();
                var r = t.LayaGL.instance,
                    n = 2 * this._activeIndex,
                    i = 2 * this._endIndex - n;
                r.drawArrays(r.TRIANGLE_STRIP, n, i), t.Stat.renderBatches++, t.Stat.trianglesFaces += i - 2;
            }
        }, {
            key: "destroy",
            value: function() {
                _get(_getPrototypeOf(TrailGeometry.prototype), "destroy", this).call(this);
                var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
                t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1.destroy(),
                    this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null,
                    this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null,
                    this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null,
                    this._disappearBoundsMode = !1;
            }
        }, {
            key: "_calculateBoundingBoxForNative",
            value: function() {
                var e = this._owner._owner.trailRenderer,
                    t = e.bounds,
                    r = t.getMin(),
                    n = t.getMax(),
                    i = de._cullingBuffer;
                i[e._cullingBufferIndex + 1] = r.x, i[e._cullingBufferIndex + 2] = r.y, i[e._cullingBufferIndex + 3] = r.z,
                    i[e._cullingBufferIndex + 4] = n.x, i[e._cullingBufferIndex + 5] = n.y, i[e._cullingBufferIndex + 6] = n.z;
            }
        }, {
            key: "clear",
            value: function() {
                this._activeIndex = 0, this._endIndex = 0, this._disappearBoundsMode = !1, this._subBirthTime.fill(0),
                    this._subDistance.fill(0), this._segementCount = 0, this._isTempEndVertex = !1,
                    this._needAddFirstVertex = !1, this._lastFixedVertexPosition.setValue(0, 0, 0);
            }
        }]), TrailGeometry;
    }();
    en.ALIGNMENT_VIEW = 0, en.ALIGNMENT_TRANSFORM_Z = 1, en._tempVector30 = new o(),
        en._tempVector31 = new o(), en._tempVector32 = new o(), en._tempVector33 = new o(),
        en._tempVector34 = new o(), en._tempVector35 = new o(), en._tempVector36 = new o(),
        en._type = Lt._typeCounter++;
    var tn = function() {
        function TrailFilter(e) {
            _classCallCheck(this, TrailFilter), this._totalLength = 0, this._lastPosition = new o(),
                this._curtime = 0, this.alignment = TrailFilter.ALIGNMENT_VIEW, this._owner = e,
                this._initDefaultData(), this.addRenderElement();
        }
        return _createClass(TrailFilter, [{
            key: "addRenderElement",
            value: function() {
                var e = this._owner._render,
                    t = e._renderElements,
                    r = e.sharedMaterials[0];
                r || (r = qr.defaultMaterial);
                var n = new bt();
                n.setTransform(this._owner._transform), n.render = e, n.material = r, this._trialGeometry = new en(this),
                    n.setGeometry(this._trialGeometry), t.push(n);
            }
        }, {
            key: "_update",
            value: function(e) {
                var t = this._owner._render;
                this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(TrailFilter.CURTIME, this._curtime);
                var r = this._owner.transform.position,
                    n = t._renderElements[0]._geometry;
                n._updateDisappear(), n._updateTrail(e.camera, this._lastPosition, r), n._updateVertexBufferUV(),
                    r.cloneTo(this._lastPosition);
            }
        }, {
            key: "_initDefaultData",
            value: function() {
                this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = Jr.Stretch;
                var e = [],
                    t = new _();
                t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
                var r = new _();
                r.time = 1, r.inTangent = 0, r.outTangent = 0, r.value = 1, e.push(r), this.widthCurve = e;
                var n = new fr(2, 2);
                n.mode = dr.Blend, n.addColorRGB(0, ae.WHITE), n.addColorRGB(1, ae.WHITE), n.addColorAlpha(0, 1),
                    n.addColorAlpha(1, 1), this.colorGradient = n;
            }
        }, {
            key: "destroy",
            value: function() {
                this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null,
                    this._colorGradient = null;
            }
        }, {
            key: "clear",
            value: function() {
                this._trialGeometry.clear(), this._lastPosition.setValue(0, 0, 0), this._curtime = 0,
                    this._totalLength = 0;
            }
        }, {
            key: "time",
            get: function() {
                return this._time;
            },
            set: function(e) {
                this._time = e, this._owner._render._shaderValues.setNumber(TrailFilter.LIFETIME, e);
            }
        }, {
            key: "minVertexDistance",
            get: function() {
                return this._minVertexDistance;
            },
            set: function(e) {
                this._minVertexDistance = e;
            }
        }, {
            key: "widthMultiplier",
            get: function() {
                return this._widthMultiplier;
            },
            set: function(e) {
                this._widthMultiplier = e;
            }
        }, {
            key: "widthCurve",
            get: function() {
                return this._widthCurve;
            },
            set: function(e) {
                this._widthCurve = e;
                var t, r, n = new Float32Array(4 * e.length),
                    i = 0;
                for (t = 0, r = e.length; t < r; t++) n[i++] = e[t].time, n[i++] = e[t].inTangent,
                    n[i++] = e[t].outTangent, n[i++] = e[t].value;
                this._owner._render._shaderValues.setBuffer(TrailFilter.WIDTHCURVE, n), this._owner._render._shaderValues.setInt(TrailFilter.WIDTHCURVEKEYLENGTH, e.length);
            }
        }, {
            key: "colorGradient",
            get: function() {
                return this._colorGradient;
            },
            set: function(e) {
                this._colorGradient = e;
            }
        }, {
            key: "textureMode",
            get: function() {
                return this._textureMode;
            },
            set: function(e) {
                this._textureMode = e;
            }
        }]), TrailFilter;
    }();
    tn.CURTIME = G.propertyNameToID("u_CurTime"), tn.LIFETIME = G.propertyNameToID("u_LifeTime"),
        tn.WIDTHCURVE = G.propertyNameToID("u_WidthCurve"), tn.WIDTHCURVEKEYLENGTH = G.propertyNameToID("u_WidthCurveKeyLength"),
        tn.ALIGNMENT_VIEW = 0, tn.ALIGNMENT_TRANSFORM_Z = 1;
    var rn = function(e) {
            function TrailRenderer(e) {
                var t;
                return _classCallCheck(this, TrailRenderer), (t = _possibleConstructorReturn(this, _getPrototypeOf(TrailRenderer).call(this, e)))._projectionViewWorldMatrix = new L(),
                    t;
            }
            return _inherits(TrailRenderer, wt), _createClass(TrailRenderer, [{
                key: "_calculateBoundingBox",
                value: function() {}
            }, {
                key: "_needRender",
                value: function(e, t) {
                    return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds._getBoundBox());
                }
            }, {
                key: "_updateForNative",
                value: function(e) {
                    this._owner.trailFilter._update(e);
                }
            }, {
                key: "_renderUpdate",
                value: function(e, t) {
                    _get(_getPrototypeOf(TrailRenderer.prototype), "_renderUpdate", this).call(this, e, t);
                }
            }, {
                key: "_renderUpdateWithCamera",
                value: function(e, t) {
                    var r = e.projectionViewMatrix;
                    t ? (L.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(le.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(le.MVPMATRIX, r);
                }
            }]), TrailRenderer;
        }(),
        nn = function(e) {
            function TrailSprite3D() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return _classCallCheck(this, TrailSprite3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(TrailSprite3D).call(this, t)))._render = new rn(_assertThisInitialized(e)),
                    e._geometryFilter = new tn(_assertThisInitialized(e)), e;
            }
            return _inherits(TrailSprite3D, ue), _createClass(TrailSprite3D, [{
                key: "trailFilter",
                get: function() {
                    return this._geometryFilter;
                }
            }, {
                key: "trailRenderer",
                get: function() {
                    return this._render;
                }
            }], [{
                key: "__init__",
                value: function() {}
            }]), _createClass(TrailSprite3D, [{
                key: "_parse",
                value: function(e, r) {
                    _get(_getPrototypeOf(TrailSprite3D.prototype), "_parse", this).call(this, e, r);
                    var n, i, a = this._render,
                        o = this._geometryFilter,
                        s = e.materials;
                    if (s) {
                        var l = a.sharedMaterials,
                            u = s.length;
                        for (l.length = u, n = 0; n < u; n++) l[n] = t.Loader.getRes(s[n].path);
                        a.sharedMaterials = l;
                    }
                    o.time = e.time, o.minVertexDistance = e.minVertexDistance, o.widthMultiplier = e.widthMultiplier,
                        o.textureMode = e.textureMode, null != e.alignment && (o.alignment = e.alignment);
                    var c = [],
                        h = e.widthCurve;
                    for (n = 0, i = h.length; n < i; n++) {
                        var d = new _();
                        d.time = h[n].time, d.inTangent = h[n].inTangent, d.outTangent = h[n].outTangent,
                            d.value = h[n].value, c.push(d);
                    }
                    o.widthCurve = c;
                    var f = e.colorGradient,
                        m = f.colorKeys,
                        T = f.alphaKeys,
                        p = new fr(m.length, T.length);
                    for (p.mode = f.mode, n = 0, i = m.length; n < i; n++) {
                        var v = m[n];
                        p.addColorRGB(v.time, new ae(v.value[0], v.value[1], v.value[2], 1));
                    }
                    for (n = 0, i = T.length; n < i; n++) {
                        var E = T[n];
                        p.addColorAlpha(E.time, E.value);
                    }
                    o.colorGradient = p;
                }
            }, {
                key: "_onActive",
                value: function() {
                    _get(_getPrototypeOf(TrailSprite3D.prototype), "_onActive", this).call(this), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
                }
            }, {
                key: "_cloneTo",
                value: function(e, t, r) {
                    var n, i;
                    _get(_getPrototypeOf(TrailSprite3D.prototype), "_cloneTo", this).call(this, e, t, r);
                    var a = e,
                        o = a.trailFilter;
                    o.time = this.trailFilter.time, o.minVertexDistance = this.trailFilter.minVertexDistance,
                        o.widthMultiplier = this.trailFilter.widthMultiplier, o.textureMode = this.trailFilter.textureMode,
                        o.alignment = this.trailFilter.alignment;
                    var s = this.trailFilter.widthCurve,
                        l = [];
                    for (n = 0, i = s.length; n < i; n++) {
                        var u = new _();
                        s[n].cloneTo(u), l.push(u);
                    }
                    o.widthCurve = l;
                    var c = new fr(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
                    this.trailFilter.colorGradient.cloneTo(c), o.colorGradient = c, a.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
                }
            }, {
                key: "destroy",
                value: function() {
                    var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                    this.destroyed || (_get(_getPrototypeOf(TrailSprite3D.prototype), "destroy", this).call(this, e),
                        this._geometryFilter.destroy(), this._geometryFilter = null);
                }
            }, {
                key: "clear",
                value: function() {
                    this._geometryFilter.clear();
                }
            }, {
                key: "_create",
                value: function() {
                    return new TrailSprite3D();
                }
            }]), TrailSprite3D;
        }(),
        an = function() {
            function VertexPositionTerrain(e, t, r, n) {
                _classCallCheck(this, VertexPositionTerrain), this._position = e, this._normal = t,
                    this._textureCoord0 = r, this._textureCoord1 = n;
            }
            return _createClass(VertexPositionTerrain, [{
                key: "position",
                get: function() {
                    return this._position;
                }
            }, {
                key: "normal",
                get: function() {
                    return this._normal;
                }
            }, {
                key: "textureCoord0",
                get: function() {
                    return this._textureCoord0;
                }
            }, {
                key: "textureCoord1",
                get: function() {
                    return this._textureCoord1;
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexPositionTerrain._vertexDeclaration;
                }
            }], [{
                key: "__init__",
                value: function() {
                    VertexPositionTerrain._vertexDeclaration = new Oe(40, [new Pe(0, Ie.Vector3, VertexPositionTerrain.TERRAIN_POSITION0), new Pe(12, Ie.Vector3, VertexPositionTerrain.TERRAIN_NORMAL0), new Pe(24, Ie.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE0), new Pe(32, Ie.Vector2, VertexPositionTerrain.TERRAIN_TEXTURECOORDINATE1)]);
                }
            }, {
                key: "vertexDeclaration",
                get: function() {
                    return VertexPositionTerrain._vertexDeclaration;
                }
            }]), VertexPositionTerrain;
        }();
    an.TERRAIN_POSITION0 = 0, an.TERRAIN_NORMAL0 = 1, an.TERRAIN_TEXTURECOORDINATE0 = 2,
        an.TERRAIN_TEXTURECOORDINATE1 = 3;
    var on = function BulletInteractive() {
        _classCallCheck(this, BulletInteractive);
    };
    on._interactive = {
        getWorldTransform: function(e, t) {},
        setWorldTransform: function(e, t) {
            var r = mt._physicObjectsMap[e];
            r._simulation._updatedRigidbodies++, r._updateTransformComponent(t);
        }
    };
    var sn = function(e) {
        function CharacterController() {
            var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .1,
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : rt.COLLISIONFILTERGROUP_DEFAULTFILTER,
                i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : rt.COLLISIONFILTERGROUP_ALLFILTER;
            return _classCallCheck(this, CharacterController), (e = _possibleConstructorReturn(this, _getPrototypeOf(CharacterController).call(this, n, i)))._upAxis = new o(0, 1, 0),
                e._maxSlope = 45, e._jumpSpeed = 10, e._fallSpeed = 55, e._gravity = new o(0, 3 * -9.8, 0),
                e._btKinematicCharacter = null, e._stepHeight = t, r && (e._upAxis = r), e._controlBySimulation = !0,
                e;
        }
        return _inherits(CharacterController, mt), _createClass(CharacterController, [{
            key: "_constructCharacter",
            value: function() {
                var e = y._bullet;
                this._btKinematicCharacter && e.btKinematicCharacterController_destroy(this._btKinematicCharacter);
                var t = CharacterController._btTempVector30;
                e.btVector3_setValue(t, this._upAxis.x, this._upAxis.y, this._upAxis.z), this._btKinematicCharacter = e.btKinematicCharacterController_create(this._btColliderObject, this._colliderShape._btShape, this._stepHeight, t),
                    this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed,
                    this.gravity = this._gravity;
            }
        }, {
            key: "_onShapeChange",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_onShapeChange", this).call(this, e),
                    this._constructCharacter();
            }
        }, {
            key: "_onAdded",
            value: function() {
                var e = y._bullet,
                    t = e.btPairCachingGhostObject_create();
                e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_setCollisionFlags(t, mt.COLLISIONFLAGS_CHARACTER_OBJECT),
                    this._btColliderObject = t, this._colliderShape && this._constructCharacter(), _get(_getPrototypeOf(CharacterController.prototype), "_onAdded", this).call(this);
            }
        }, {
            key: "_addToSimulation",
            value: function() {
                this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
            }
        }, {
            key: "_removeFromSimulation",
            value: function() {
                this._simulation._removeCharacter(this);
                var e = this._simulation._characters;
                e.splice(e.indexOf(this), 1);
            }
        }, {
            key: "_cloneTo",
            value: function(e) {
                _get(_getPrototypeOf(CharacterController.prototype), "_cloneTo", this).call(this, e);
                var t = e;
                t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this._maxSlope,
                    t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t.gravity = this._gravity;
            }
        }, {
            key: "_onDestroy",
            value: function() {
                y._bullet.btKinematicCharacterController_destroy(this._btKinematicCharacter), _get(_getPrototypeOf(CharacterController.prototype), "_onDestroy", this).call(this),
                    this._btKinematicCharacter = null;
            }
        }, {
            key: "move",
            value: function(e) {
                var t = CharacterController._btVector30,
                    r = y._bullet;
                r.btVector3_setValue(t, -e.x, e.y, e.z), r.btKinematicCharacterController_setWalkDirection(this._btKinematicCharacter, t);
            }
        }, {
            key: "jump",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = y._bullet,
                    r = CharacterController._btVector30;
                e ? (R._convertToBulletVec3(e, r, !0), t.btKinematicCharacterController_jump(this._btKinematicCharacter, r)) : (t.btVector3_setValue(r, 0, 0, 0),
                    t.btKinematicCharacterController_jump(this._btKinematicCharacter, r));
            }
        }, {
            key: "fallSpeed",
            get: function() {
                return this._fallSpeed;
            },
            set: function(e) {
                this._fallSpeed = e, y._bullet.btKinematicCharacterController_setFallSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "jumpSpeed",
            get: function() {
                return this._jumpSpeed;
            },
            set: function(e) {
                this._jumpSpeed = e, y._bullet.btKinematicCharacterController_setJumpSpeed(this._btKinematicCharacter, e);
            }
        }, {
            key: "gravity",
            get: function() {
                return this._gravity;
            },
            set: function(e) {
                this._gravity = e;
                var t = y._bullet,
                    r = CharacterController._btTempVector30;
                t.btVector3_setValue(r, -e.x, e.y, e.z), t.btKinematicCharacterController_setGravity(this._btKinematicCharacter, r);
            }
        }, {
            key: "maxSlope",
            get: function() {
                return this._maxSlope;
            },
            set: function(e) {
                this._maxSlope = e, y._bullet.btKinematicCharacterController_setMaxSlope(this._btKinematicCharacter, e / 180 * Math.PI);
            }
        }, {
            key: "isGrounded",
            get: function() {
                return y._bullet.btKinematicCharacterController_onGround(this._btKinematicCharacter);
            }
        }, {
            key: "stepHeight",
            get: function() {
                return this._stepHeight;
            },
            set: function(e) {
                this._stepHeight = e, y._bullet.btKinematicCharacterController_setStepHeight(this._btKinematicCharacter, e);
            }
        }, {
            key: "upAxis",
            get: function() {
                return this._upAxis;
            },
            set: function(e) {
                this._upAxis = e;
                var t = CharacterController._btTempVector30;
                R._convertToBulletVec3(e, t, !1), y._bullet.btKinematicCharacterController_setUp(this._btKinematicCharacter, t);
            }
        }], [{
            key: "__init__",
            value: function() {
                CharacterController._btTempVector30 = y._bullet.btVector3_create(0, 0, 0);
            }
        }]), CharacterController;
    }();
    sn.UPAXIS_X = 0, sn.UPAXIS_Y = 1, sn.UPAXIS_Z = 2;
    var ln = function(e) {
            function PhysicsTriggerComponent(e, t) {
                var r;
                return _classCallCheck(this, PhysicsTriggerComponent), (r = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsTriggerComponent).call(this, e, t)))._isTrigger = !1,
                    r;
            }
            return _inherits(PhysicsTriggerComponent, mt), _createClass(PhysicsTriggerComponent, [{
                key: "_onAdded",
                value: function() {
                    _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_onAdded", this).call(this),
                        this.isTrigger = this._isTrigger;
                }
            }, {
                key: "_cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(PhysicsTriggerComponent.prototype), "_cloneTo", this).call(this, e),
                        e.isTrigger = this._isTrigger;
                }
            }, {
                key: "isTrigger",
                get: function() {
                    return this._isTrigger;
                },
                set: function(e) {
                    this._isTrigger = e;
                    var t = y._bullet;
                    if (this._btColliderObject) {
                        var r = t.btCollisionObject_getCollisionFlags(this._btColliderObject);
                        e ? 0 == (r & mt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r | mt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (r & mt.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && t.btCollisionObject_setCollisionFlags(this._btColliderObject, r ^ mt.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
                    }
                }
            }]), PhysicsTriggerComponent;
        }(),
        un = function(e) {
            function PhysicsCollider() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rt.COLLISIONFILTERGROUP_DEFAULTFILTER,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rt.COLLISIONFILTERGROUP_ALLFILTER;
                return _classCallCheck(this, PhysicsCollider), (e = _possibleConstructorReturn(this, _getPrototypeOf(PhysicsCollider).call(this, t, r)))._enableProcessCollisions = !1,
                    e;
            }
            return _inherits(PhysicsCollider, ln), _createClass(PhysicsCollider, [{
                key: "_addToSimulation",
                value: function() {
                    this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
                }
            }, {
                key: "_removeFromSimulation",
                value: function() {
                    this._simulation._removePhysicsCollider(this);
                }
            }, {
                key: "_parse",
                value: function(e) {
                    null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                        null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                        _get(_getPrototypeOf(PhysicsCollider.prototype), "_parse", this).call(this, e),
                        this._parseShape(e.shapes);
                }
            }, {
                key: "_onAdded",
                value: function() {
                    var e = y._bullet,
                        t = e.btCollisionObject_create();
                    e.btCollisionObject_setUserIndex(t, this.id), e.btCollisionObject_forceActivationState(t, mt.ACTIVATIONSTATE_DISABLE_SIMULATION);
                    var r = e.btCollisionObject_getCollisionFlags(t);
                    this.owner.isStatic ? ((r & mt.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (r ^= mt.COLLISIONFLAGS_KINEMATIC_OBJECT),
                            r |= mt.COLLISIONFLAGS_STATIC_OBJECT) : ((r & mt.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (r ^= mt.COLLISIONFLAGS_STATIC_OBJECT),
                            r |= mt.COLLISIONFLAGS_KINEMATIC_OBJECT), e.btCollisionObject_setCollisionFlags(t, r),
                        this._btColliderObject = t, _get(_getPrototypeOf(PhysicsCollider.prototype), "_onAdded", this).call(this);
                }
            }]), PhysicsCollider;
        }(),
        cn = function(e) {
            function Rigidbody3D() {
                var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : rt.COLLISIONFILTERGROUP_DEFAULTFILTER,
                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rt.COLLISIONFILTERGROUP_ALLFILTER;
                return _classCallCheck(this, Rigidbody3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Rigidbody3D).call(this, t, r)))._isKinematic = !1,
                    e._mass = 1, e._gravity = new o(0, -10, 0), e._angularDamping = 0, e._linearDamping = 0,
                    e._overrideGravity = !1, e._totalTorque = new o(0, 0, 0), e._totalForce = new o(0, 0, 0),
                    e._linearVelocity = new o(), e._angularVelocity = new o(), e._linearFactor = new o(1, 1, 1),
                    e._angularFactor = new o(1, 1, 1), e._detectCollisions = !0, e._controlBySimulation = !0,
                    e;
            }
            return _inherits(Rigidbody3D, ln), _createClass(Rigidbody3D, [{
                key: "_updateMass",
                value: function(e) {
                    if (this._btColliderObject && this._colliderShape) {
                        var t = y._bullet;
                        t.btCollisionShape_calculateLocalInertia(this._colliderShape._btShape, e, Rigidbody3D._btInertia),
                            t.btRigidBody_setMassProps(this._btColliderObject, e, Rigidbody3D._btInertia), t.btRigidBody_updateInertiaTensor(this._btColliderObject);
                    }
                }
            }, {
                key: "_onScaleChange",
                value: function(e) {
                    _get(_getPrototypeOf(Rigidbody3D.prototype), "_onScaleChange", this).call(this, e),
                        this._updateMass(this._isKinematic ? 0 : this._mass);
                }
            }, {
                key: "_derivePhysicsTransformation",
                value: function(e) {
                    var t = y._bullet,
                        r = this._btColliderObject,
                        n = t.btCollisionObject_getWorldTransform(r),
                        i = Rigidbody3D._btTransform0;
                    t.btTransform_equal(i, n), this._innerDerivePhysicsTransformation(i, e), t.btRigidBody_setCenterOfMassTransform(r, i);
                }
            }, {
                key: "_onAdded",
                value: function() {
                    var e = y._bullet,
                        t = e.layaMotionState_create();
                    e.layaMotionState_set_rigidBodyID(t, this._id), this._btLayaMotionState = t;
                    var r = e.btRigidBodyConstructionInfo_create(0, t, null, Rigidbody3D._btVector3Zero),
                        n = e.btRigidBody_create(r);
                    e.btCollisionObject_setUserIndex(n, this.id), this._btColliderObject = n, _get(_getPrototypeOf(Rigidbody3D.prototype), "_onAdded", this).call(this),
                        this.mass = this._mass, this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor,
                        this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping,
                        this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic,
                        e.btRigidBodyConstructionInfo_destroy(r);
                }
            }, {
                key: "_onShapeChange",
                value: function(e) {
                    if (_get(_getPrototypeOf(Rigidbody3D.prototype), "_onShapeChange", this).call(this, e),
                        this._isKinematic) this._updateMass(0);
                    else {
                        var t = y._bullet;
                        t.btRigidBody_setCenterOfMassTransform(this._btColliderObject, t.btCollisionObject_getWorldTransform(this._btColliderObject)),
                            this._updateMass(this._mass);
                    }
                }
            }, {
                key: "_parse",
                value: function(e) {
                    if (null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                        null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                        null != e.mass && (this.mass = e.mass), null != e.isKinematic && (this.isKinematic = e.isKinematic),
                        null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e.angularDamping && (this.angularDamping = e.angularDamping),
                        null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), null != e.linearFactor) {
                        var t = this.linearFactor;
                        t.fromArray(e.linearFactor), this.linearFactor = t;
                    }
                    if (null != e.angularFactor) {
                        var r = this.angularFactor;
                        r.fromArray(e.angularFactor), this.angularFactor = r;
                    }
                    e.gravity && (this.gravity.fromArray(e.gravity), this.gravity = this.gravity), _get(_getPrototypeOf(Rigidbody3D.prototype), "_parse", this).call(this, e),
                        this._parseShape(e.shapes);
                }
            }, {
                key: "_onDestroy",
                value: function() {
                    y._bullet.btMotionState_destroy(this._btLayaMotionState), _get(_getPrototypeOf(Rigidbody3D.prototype), "_onDestroy", this).call(this),
                        this._btLayaMotionState = null, this._gravity = null, this._totalTorque = null,
                        this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null,
                        this._angularFactor = null;
                }
            }, {
                key: "_addToSimulation",
                value: function() {
                    this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
                }
            }, {
                key: "_removeFromSimulation",
                value: function() {
                    this._simulation._removeRigidBody(this);
                }
            }, {
                key: "_cloneTo",
                value: function(e) {
                    _get(_getPrototypeOf(Rigidbody3D.prototype), "_cloneTo", this).call(this, e);
                    var t = e;
                    t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this._gravity,
                        t.angularDamping = this._angularDamping, t.linearDamping = this._linearDamping,
                        t.overrideGravity = this._overrideGravity, t.linearVelocity = this._linearVelocity,
                        t.angularVelocity = this._angularVelocity, t.linearFactor = this._linearFactor,
                        t.angularFactor = this._angularFactor, t.detectCollisions = this._detectCollisions;
                }
            }, {
                key: "applyForce",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var r = y._bullet,
                        n = Rigidbody3D._btTempVector30;
                    if (r.btVector3_setValue(n, -e.x, e.y, e.z), t) {
                        var i = Rigidbody3D._btTempVector31;
                        r.btVector3_setValue(i, -t.x, t.y, t.z), r.btRigidBody_applyForce(this._btColliderObject, n, i);
                    } else r.btRigidBody_applyCentralForce(this._btColliderObject, n);
                }
            }, {
                key: "applyTorque",
                value: function(e) {
                    if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var t = y._bullet,
                        r = Rigidbody3D._btTempVector30;
                    t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorque(this._btColliderObject, r);
                }
            }, {
                key: "applyImpulse",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                    if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var r = y._bullet;
                    r.btVector3_setValue(Rigidbody3D._btImpulse, -e.x, e.y, e.z), t ? (r.btVector3_setValue(Rigidbody3D._btImpulseOffset, -t.x, t.y, t.z),
                        r.btRigidBody_applyImpulse(this._btColliderObject, Rigidbody3D._btImpulse, Rigidbody3D._btImpulseOffset)) : r.btRigidBody_applyCentralImpulse(this._btColliderObject, Rigidbody3D._btImpulse);
                }
            }, {
                key: "applyTorqueImpulse",
                value: function(e) {
                    if (null == this._btColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var t = y._bullet,
                        r = Rigidbody3D._btTempVector30;
                    t.btVector3_setValue(r, -e.x, e.y, e.z), t.btRigidBody_applyTorqueImpulse(this._btColliderObject, r);
                }
            }, {
                key: "wakeUp",
                value: function() {
                    this._btColliderObject && y._bullet.btCollisionObject_activate(this._btColliderObject, !1);
                }
            }, {
                key: "clearForces",
                value: function() {
                    var e = this._btColliderObject;
                    if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
                    var t = y._bullet;
                    t.btRigidBody_clearForces(e);
                    var r = Rigidbody3D._btVector3Zero;
                    t.btCollisionObject_setInterpolationLinearVelocity(e, r), t.btRigidBody_setLinearVelocity(e, r),
                        t.btCollisionObject_setInterpolationAngularVelocity(e, r), t.btRigidBody_setAngularVelocity(e, r);
                }
            }, {
                key: "mass",
                get: function() {
                    return this._mass;
                },
                set: function(e) {
                    e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
                }
            }, {
                key: "isKinematic",
                get: function() {
                    return this._isKinematic;
                },
                set: function(e) {
                    this._isKinematic = e, this._controlBySimulation = !e;
                    var t = y._bullet,
                        r = !!(this._simulation && this._enabled && this._colliderShape);
                    r && this._removeFromSimulation();
                    var n = this._btColliderObject,
                        i = t.btCollisionObject_getCollisionFlags(n);
                    e ? (i |= mt.COLLISIONFLAGS_KINEMATIC_OBJECT, t.btCollisionObject_setCollisionFlags(n, i),
                        t.btCollisionObject_forceActivationState(this._btColliderObject, mt.ACTIVATIONSTATE_DISABLE_DEACTIVATION),
                        this._enableProcessCollisions = !1, this._updateMass(0)) : ((i & mt.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (i ^= mt.COLLISIONFLAGS_KINEMATIC_OBJECT),
                        t.btCollisionObject_setCollisionFlags(n, i), t.btCollisionObject_setActivationState(this._btColliderObject, mt.ACTIVATIONSTATE_ACTIVE_TAG),
                        this._enableProcessCollisions = !0, this._updateMass(this._mass));
                    var a = Rigidbody3D._btVector3Zero;
                    t.btCollisionObject_setInterpolationLinearVelocity(n, a), t.btRigidBody_setLinearVelocity(n, a),
                        t.btCollisionObject_setInterpolationAngularVelocity(n, a), t.btRigidBody_setAngularVelocity(n, a),
                        r && this._addToSimulation();
                }
            }, {
                key: "linearDamping",
                get: function() {
                    return this._linearDamping;
                },
                set: function(e) {
                    this._linearDamping = e, this._btColliderObject && y._bullet.btRigidBody_setDamping(this._btColliderObject, e, this._angularDamping);
                }
            }, {
                key: "angularDamping",
                get: function() {
                    return this._angularDamping;
                },
                set: function(e) {
                    this._angularDamping = e, this._btColliderObject && y._bullet.btRigidBody_setDamping(this._btColliderObject, this._linearDamping, e);
                }
            }, {
                key: "overrideGravity",
                get: function() {
                    return this._overrideGravity;
                },
                set: function(e) {
                    this._overrideGravity = e;
                    var t = y._bullet;
                    if (this._btColliderObject) {
                        var r = t.btRigidBody_getFlags(this._btColliderObject);
                        e ? 0 == (r & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) && t.btRigidBody_setFlags(this._btColliderObject, r | Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) : (r & Rigidbody3D._BT_DISABLE_WORLD_GRAVITY) > 0 && t.btRigidBody_setFlags(this._btColliderObject, r ^ Rigidbody3D._BT_DISABLE_WORLD_GRAVITY);
                    }
                }
            }, {
                key: "gravity",
                get: function() {
                    return this._gravity;
                },
                set: function(e) {
                    this._gravity = e;
                    var t = y._bullet;
                    t.btVector3_setValue(Rigidbody3D._btGravity, -e.x, e.y, e.z), t.btRigidBody_setGravity(this._btColliderObject, Rigidbody3D._btGravity);
                }
            }, {
                key: "totalForce",
                get: function() {
                    if (this._btColliderObject) {
                        var e = y._bullet.btRigidBody_getTotalForce(this._btColliderObject);
                        return R._convertToLayaVec3(e, this._totalForce, !0), this._totalForce;
                    }
                    return null;
                }
            }, {
                key: "linearFactor",
                get: function() {
                    return this._linearFactor;
                },
                set: function(e) {
                    this._linearFactor = e;
                    var t = Rigidbody3D._btTempVector30;
                    R._convertToBulletVec3(e, t, !1), y._bullet.btRigidBody_setLinearFactor(this._btColliderObject, t);
                }
            }, {
                key: "linearVelocity",
                get: function() {
                    return this._btColliderObject && R._convertToLayaVec3(y._bullet.btRigidBody_getLinearVelocity(this._btColliderObject), this._linearVelocity, !0),
                        this._linearVelocity;
                },
                set: function(e) {
                    if (this._linearVelocity = e, this._btColliderObject) {
                        var t = Rigidbody3D._btTempVector30;
                        R._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), y._bullet.btRigidBody_setLinearVelocity(this._btColliderObject, t);
                    }
                }
            }, {
                key: "angularFactor",
                get: function() {
                    return this._angularFactor;
                },
                set: function(e) {
                    this._angularFactor = e;
                    var t = Rigidbody3D._btTempVector30;
                    R._convertToBulletVec3(e, t, !1), y._bullet.btRigidBody_setAngularFactor(this._btColliderObject, t);
                }
            }, {
                key: "angularVelocity",
                get: function() {
                    return this._btColliderObject && R._convertToLayaVec3(y._bullet.btRigidBody_getAngularVelocity(this._btColliderObject), this._angularVelocity, !0),
                        this._angularVelocity;
                },
                set: function(e) {
                    if (this._angularVelocity = e, this._btColliderObject) {
                        var t = Rigidbody3D._btTempVector30;
                        R._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), y._bullet.btRigidBody_setAngularVelocity(this._btColliderObject, t);
                    }
                }
            }, {
                key: "totalTorque",
                get: function() {
                    if (this._btColliderObject) {
                        var e = y._bullet.btRigidBody_getTotalTorque(this._btColliderObject);
                        return R._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque;
                    }
                    return null;
                }
            }, {
                key: "detectCollisions",
                get: function() {
                    return this._detectCollisions;
                },
                set: function(e) {
                    this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this),
                        this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
                }
            }, {
                key: "isSleeping",
                get: function() {
                    return !!this._btColliderObject && y._bullet.btCollisionObject_getActivationState(this._btColliderObject) === mt.ACTIVATIONSTATE_ISLAND_SLEEPING;
                }
            }, {
                key: "sleepLinearVelocity",
                get: function() {
                    return y._bullet.btRigidBody_getLinearSleepingThreshold(this._btColliderObject);
                },
                set: function(e) {
                    var t = y._bullet;
                    t.btRigidBody_setSleepingThresholds(this._btColliderObject, e, t.btRigidBody_getAngularSleepingThreshold(this._btColliderObject));
                }
            }, {
                key: "sleepAngularVelocity",
                get: function() {
                    return y._bullet.btRigidBody_getAngularSleepingThreshold(this._btColliderObject);
                },
                set: function(e) {
                    var t = y._bullet;
                    t.btRigidBody_setSleepingThresholds(this._btColliderObject, t.btRigidBody_getLinearSleepingThreshold(this._btColliderObject), e);
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = y._bullet;
                    Rigidbody3D._btTempVector30 = e.btVector3_create(0, 0, 0), Rigidbody3D._btTempVector31 = e.btVector3_create(0, 0, 0),
                        Rigidbody3D._btVector3Zero = e.btVector3_create(0, 0, 0), Rigidbody3D._btInertia = e.btVector3_create(0, 0, 0),
                        Rigidbody3D._btImpulse = e.btVector3_create(0, 0, 0), Rigidbody3D._btImpulseOffset = e.btVector3_create(0, 0, 0),
                        Rigidbody3D._btGravity = e.btVector3_create(0, 0, 0), Rigidbody3D._btTransform0 = e.btTransform_create();
                }
            }]), Rigidbody3D;
        }();
    cn.TYPE_STATIC = 0, cn.TYPE_DYNAMIC = 1, cn.TYPE_KINEMATIC = 2, cn._BT_DISABLE_WORLD_GRAVITY = 1,
        cn._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    var hn = function(e) {
            function StaticPlaneColliderShape(e, t) {
                var r;
                _classCallCheck(this, StaticPlaneColliderShape), (r = _possibleConstructorReturn(this, _getPrototypeOf(StaticPlaneColliderShape).call(this)))._normal = e,
                    r._offset = t, r._type = st.SHAPETYPES_STATICPLANE;
                var n = y._bullet;
                return n.btVector3_setValue(StaticPlaneColliderShape._btNormal, -e.x, e.y, e.z),
                    r._btShape = n.btStaticPlaneShape_create(StaticPlaneColliderShape._btNormal, t),
                    r;
            }
            return _inherits(StaticPlaneColliderShape, st), _createClass(StaticPlaneColliderShape, null, [{
                key: "__init__",
                value: function() {
                    StaticPlaneColliderShape._btNormal = y._bullet.btVector3_create(0, 0, 0);
                }
            }]), _createClass(StaticPlaneColliderShape, [{
                key: "clone",
                value: function() {
                    var e = new StaticPlaneColliderShape(this._normal, this._offset);
                    return this.cloneTo(e), e;
                }
            }]), StaticPlaneColliderShape;
        }(),
        _n = function(r) {
            function SubMesh(e) {
                var t;
                return _classCallCheck(this, SubMesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(SubMesh).call(this)))._id = ++SubMesh._uniqueIDCounter,
                    t._mesh = e, t._boneIndicesList = [], t._subIndexBufferStart = [], t._subIndexBufferCount = [],
                    t;
            }
            return _inherits(SubMesh, Lt), _createClass(SubMesh, [{
                key: "_setIndexRange",
                value: function(e, t) {
                    this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * e, t);
                }
            }, {
                key: "_getType",
                value: function() {
                    return SubMesh._type;
                }
            }, {
                key: "_prepareRender",
                value: function(e) {
                    return this._mesh._uploadVerticesData(), !0;
                }
            }, {
                key: "_render",
                value: function(r) {
                    var n = this._mesh;
                    if (n.indexFormat !== e.IndexFormat.UInt32 || t.LayaGL.layaGPUInstance.supportElementIndexUint32()) {
                        var i, a, o = t.LayaGL.instance,
                            s = r.renderElement.render._skinnedData;
                        switch (n.indexFormat) {
                            case e.IndexFormat.UInt32:
                                i = o.UNSIGNED_INT, a = 4;
                                break;

                            case e.IndexFormat.UInt16:
                                i = o.UNSIGNED_SHORT, a = 2;
                                break;

                            case e.IndexFormat.UInt8:
                                i = o.UNSIGNED_BYTE, a = 1;
                        }
                        if (n._bufferState.bind(), s)
                            for (var l = s[this._indexInMesh], u = 0, c = this._boneIndicesList.length; u < c; u++) r.shader.uploadCustomUniform(Zr.BONES, l[u]),
                                o.drawElements(o.TRIANGLES, this._subIndexBufferCount[u], i, this._subIndexBufferStart[u] * a);
                        else o.drawElements(o.TRIANGLES, this._indexCount, i, this._indexStart * a);
                        t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++;
                    } else console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
                }
            }, {
                key: "getIndices",
                value: function() {
                    if (this._mesh._isReadable) return this._indices.slice();
                    throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
                }
            }, {
                key: "setIndices",
                value: function(e) {
                    this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
                }
            }, {
                key: "destroy",
                value: function() {
                    this._destroyed || (_get(_getPrototypeOf(SubMesh.prototype), "destroy", this).call(this),
                        this._indexBuffer.destroy(), this._indexBuffer = null, this._mesh = null, this._boneIndicesList = null,
                        this._subIndexBufferStart = null, this._subIndexBufferCount = null, this._skinAnimationDatas = null);
                }
            }, {
                key: "indexCount",
                get: function() {
                    return this._indexCount;
                }
            }]), SubMesh;
        }();
    _n._uniqueIDCounter = 0, _n._type = Lt._typeCounter++;
    var dn = function skinnedMatrixCache(e, t, r) {
            _classCallCheck(this, skinnedMatrixCache), this.subMeshIndex = e, this.batchIndex = t,
                this.batchBoneIndex = r;
        },
        fn = function(r) {
            function Mesh() {
                var t, r = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                return _classCallCheck(this, Mesh), (t = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this)))._tempVector30 = new o(),
                    t._tempVector31 = new o(), t._tempVector32 = new o(), t._minVerticesUpdate = -1,
                    t._maxVerticesUpdate = -1, t._needUpdateBounds = !0, t._bounds = new At(new o(), new o()),
                    t._bufferState = new Ae(), t._instanceBufferState = new Ae(), t._vertexBuffer = null,
                    t._indexBuffer = null, t._skinnedMatrixCaches = [], t._vertexCount = 0, t._indexFormat = e.IndexFormat.UInt16,
                    t._isReadable = r, t._subMeshes = [], t;
            }
            return _inherits(Mesh, t.Resource), _createClass(Mesh, [{
                key: "_getPositionElement",
                value: function(e) {
                    for (var t = e.vertexDeclaration._vertexElements, r = 0, n = t.length; r < n; r++) {
                        var i = t[r];
                        if (i._elementFormat === Ie.Vector3 && i._elementUsage === Ne.MESH_POSITION0) return i;
                    }
                    return null;
                }
            }, {
                key: "_getVerticeElementData",
                value: function(e, t) {
                    e.length = this._vertexCount;
                    var r = this._vertexBuffer.vertexDeclaration,
                        a = r.getVertexElementByUsage(t);
                    if (a) {
                        var s = this._vertexBuffer.getUint8Data(),
                            l = this._vertexBuffer.getFloat32Data(),
                            u = r.vertexStride,
                            c = u / 4,
                            h = a._offset,
                            _ = h / 4;
                        switch (t) {
                            case Ne.MESH_TEXTURECOORDINATE0:
                            case Ne.MESH_TEXTURECOORDINATE1:
                                for (var d = 0; d < this._vertexCount; d++) {
                                    var f = c * d + _;
                                    e[d] = new n(l[f], l[f + 1]);
                                }
                                break;

                            case Ne.MESH_POSITION0:
                            case Ne.MESH_NORMAL0:
                                for (d = 0; d < this._vertexCount; d++) {
                                    f = c * d + _;
                                    e[d] = new o(l[f], l[f + 1], l[f + 2]);
                                }
                                break;

                            case Ne.MESH_TANGENT0:
                            case Ne.MESH_BLENDWEIGHT0:
                                for (d = 0; d < this._vertexCount; d++) {
                                    f = c * d + _;
                                    e[d] = new i(l[f], l[f + 1], l[f + 2], l[f + 3]);
                                }
                                break;

                            case Ne.MESH_COLOR0:
                                for (d = 0; d < this._vertexCount; d++) {
                                    f = c * d + _;
                                    e[d] = new ae(l[f], l[f + 1], l[f + 2], l[f + 3]);
                                }
                                break;

                            case Ne.MESH_BLENDINDICES0:
                                for (d = 0; d < this._vertexCount; d++) {
                                    f = u * d + h;
                                    e[d] = new i(s[f], s[f + 1], s[f + 2], s[f + 3]);
                                }
                                break;

                            default:
                                throw "Mesh:Unknown elementUsage.";
                        }
                    }
                }
            }, {
                key: "_setVerticeElementData",
                value: function(e, t) {
                    var r = this._vertexBuffer.vertexDeclaration,
                        n = r.getVertexElementByUsage(t);
                    if (n) {
                        var i = this._vertexBuffer.getUint8Data(),
                            a = this._vertexBuffer.getFloat32Data(),
                            o = r.vertexStride,
                            s = o / 4,
                            l = n._offset,
                            u = l / 4;
                        switch (t) {
                            case Ne.MESH_TEXTURECOORDINATE0:
                            case Ne.MESH_TEXTURECOORDINATE1:
                                for (var c = 0, h = e.length; c < h; c++) {
                                    var _ = s * c + u,
                                        d = e[c];
                                    a[_] = d.x, a[_ + 1] = d.y;
                                }
                                break;

                            case Ne.MESH_POSITION0:
                            case Ne.MESH_NORMAL0:
                                for (c = 0, h = e.length; c < h; c++) {
                                    _ = s * c + u;
                                    var f = e[c];
                                    a[_] = f.x, a[_ + 1] = f.y, a[_ + 2] = f.z;
                                }
                                break;

                            case Ne.MESH_TANGENT0:
                            case Ne.MESH_BLENDWEIGHT0:
                                for (c = 0, h = e.length; c < h; c++) {
                                    _ = s * c + u;
                                    var m = e[c];
                                    a[_] = m.x, a[_ + 1] = m.y, a[_ + 2] = m.z, a[_ + 3] = m.w;
                                }
                                break;

                            case Ne.MESH_COLOR0:
                                for (c = 0, h = e.length; c < h; c++) {
                                    _ = s * c + u;
                                    var T = e[c];
                                    a[_] = T.r, a[_ + 1] = T.g, a[_ + 2] = T.b, a[_ + 3] = T.a;
                                }
                                break;

                            case Ne.MESH_BLENDINDICES0:
                                for (c = 0, h = e.length; c < h; c++) {
                                    _ = o * c + l, m = e[c];
                                    i[_] = m.x, i[_ + 1] = m.y, i[_ + 2] = m.z, i[_ + 3] = m.w;
                                }
                                break;

                            default:
                                throw "Mesh:Unknown elementUsage.";
                        }
                        this._minVerticesUpdate = 0, this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
                    } else console.warn("Mesh: the mesh don't have  this VertexElement.");
                }
            }, {
                key: "_disposeResource",
                value: function() {
                    for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e].destroy();
                    this._btTriangleMesh && y._bullet.btStridingMeshInterface_destroy(this._btTriangleMesh),
                        this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._bufferState.destroy(),
                        this._instanceBufferState.destroy(), this._setCPUMemory(0), this._setGPUMemory(0),
                        this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null,
                        this._indexBuffer = null, this._subMeshes = null, this._btTriangleMesh = null, this._indexBuffer = null,
                        this._boneNames = null, this._inverseBindPoses = null;
                }
            }, {
                key: "_setSubMeshes",
                value: function(e) {
                    this._subMeshes = e;
                    for (var t = 0, r = e.length; t < r; t++) e[t]._indexInMesh = t;
                }
            }, {
                key: "_setBuffer",
                value: function(e, t) {
                    var r = this._bufferState;
                    r.bind(), r.applyVertexBuffer(e), r.applyIndexBuffer(t), r.unBind();
                    var n = this._instanceBufferState;
                    n.bind(), n.applyVertexBuffer(e), n.applyInstanceVertexBuffer(Nt.instance.instanceWorldMatrixBuffer),
                        n.applyInstanceVertexBuffer(Nt.instance.instanceMVPMatrixBuffer), n.applyIndexBuffer(t),
                        n.unBind();
                }
            }, {
                key: "_getPhysicMesh",
                value: function() {
                    if (!this._btTriangleMesh) {
                        for (var e = y._bullet, t = e.btTriangleMesh_create(), r = Mesh._nativeTempVector30, n = Mesh._nativeTempVector31, i = Mesh._nativeTempVector32, a = this._tempVector30, o = this._tempVector31, s = this._tempVector32, l = this._vertexBuffer, u = this._getPositionElement(l), c = l.getFloat32Data(), h = l.vertexDeclaration.vertexStride / 4, _ = u._offset / 4, d = this._indexBuffer.getData(), f = 0, m = d.length; f < m; f += 3) {
                            var T = d[f] * h + _,
                                p = d[f + 1] * h + _,
                                v = d[f + 2] * h + _;
                            a.setValue(c[T], c[T + 1], c[T + 2]), o.setValue(c[p], c[p + 1], c[p + 2]), s.setValue(c[v], c[v + 1], c[v + 2]),
                                R._convertToBulletVec3(a, r, !0), R._convertToBulletVec3(o, n, !0), R._convertToBulletVec3(s, i, !0),
                                e.btTriangleMesh_addTriangle(t, r, n, i, !0);
                        }
                        this._btTriangleMesh = t;
                    }
                    return this._btTriangleMesh;
                }
            }, {
                key: "_uploadVerticesData",
                value: function() {
                    var e = this._minVerticesUpdate,
                        t = this._maxVerticesUpdate;
                    if (-1 !== e && -1 !== t) {
                        var r = e;
                        this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r, t - e),
                            this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1;
                    }
                }
            }, {
                key: "getSubMesh",
                value: function(e) {
                    return this._subMeshes[e];
                }
            }, {
                key: "getPositions",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get positions on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_POSITION0);
                }
            }, {
                key: "setPositions",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_POSITION0), this._needUpdateBounds = !0;
                }
            }, {
                key: "getColors",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_COLOR0);
                }
            }, {
                key: "setColors",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setColors() need isReadable must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_COLOR0);
                }
            }, {
                key: "getUVs",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    if (!this._isReadable) throw "Mesh:can't get uvs on mesh,isReadable must be true.";
                    switch (t) {
                        case 0:
                            this._getVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE0);
                            break;

                        case 1:
                            this._getVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE1);
                            break;

                        default:
                            throw "Mesh:Invalid channel.";
                    }
                }
            }, {
                key: "setUVs",
                value: function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    if (!this._isReadable) throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
                    switch (t) {
                        case 0:
                            this._setVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE0);
                            break;

                        case 1:
                            this._setVerticeElementData(e, Ne.MESH_TEXTURECOORDINATE1);
                            break;

                        default:
                            throw "Mesh:Invalid channel.";
                    }
                }
            }, {
                key: "getNormals",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_NORMAL0);
                }
            }, {
                key: "setNormals",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setNormals() need must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_NORMAL0);
                }
            }, {
                key: "getTangents",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_TANGENT0);
                }
            }, {
                key: "setTangents",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_TANGENT0);
                }
            }, {
                key: "getBoneWeights",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_BLENDWEIGHT0);
                }
            }, {
                key: "setBoneWeights",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_BLENDWEIGHT0);
                }
            }, {
                key: "getBoneIndices",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
                    this._getVerticeElementData(e, Ne.MESH_BLENDINDICES0);
                }
            }, {
                key: "setBoneIndices",
                value: function(e) {
                    if (!this._isReadable) throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
                    this._setVerticeElementData(e, Ne.MESH_BLENDINDICES0);
                }
            }, {
                key: "markAsUnreadbale",
                value: function() {
                    this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1;
                }
            }, {
                key: "getVertexDeclaration",
                value: function() {
                    return this._vertexBuffer._vertexDeclaration;
                }
            }, {
                key: "getVertices",
                value: function() {
                    if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
                    throw "Mesh:can't get vertices on mesh,isReadable must be true.";
                }
            }, {
                key: "setVertices",
                value: function(e) {
                    this._vertexBuffer.setData(e), this._needUpdateBounds = !0;
                }
            }, {
                key: "getIndices",
                value: function() {
                    if (this._isReadable) return this._indexBuffer.getData().slice();
                    throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
                }
            }, {
                key: "setIndices",
                value: function(r) {
                    var n;
                    r instanceof Uint32Array ? n = e.IndexFormat.UInt32 : r instanceof Uint16Array ? n = e.IndexFormat.UInt16 : r instanceof Uint8Array && (n = e.IndexFormat.UInt8);
                    var i = this._indexBuffer;
                    this._indexFormat === n && i.indexCount === r.length || (i.destroy(), this._indexBuffer = i = new Le(n, r.length, t.LayaGL.instance.STATIC_DRAW, this._isReadable)),
                        i.setData(r), this._indexFormat = n;
                }
            }, {
                key: "calculateBounds",
                value: function() {
                    if (!this._isReadable) throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
                    if (this._needUpdateBounds) {
                        var e = this._tempVector30,
                            t = this._tempVector31;
                        e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
                        for (var r = this._vertexBuffer, n = this._getPositionElement(r), i = r.getFloat32Data(), a = r.vertexDeclaration.vertexStride / 4, o = n._offset / 4, s = 0, l = i.length; s < l; s += a) {
                            var u = s + o,
                                c = i[u],
                                h = i[u + 1],
                                _ = i[u + 2];
                            e.x = Math.min(e.x, c), e.y = Math.min(e.y, h), e.z = Math.min(e.z, _), t.x = Math.max(t.x, c),
                                t.y = Math.max(t.y, h), t.z = Math.max(t.z, _);
                        }
                        this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1;
                    }
                }
            }, {
                key: "cloneTo",
                value: function(t) {
                    var r = t,
                        n = this._vertexBuffer,
                        i = new be(n._byteLength, n.bufferUsage, n.canRead);
                    i.vertexDeclaration = n.vertexDeclaration, i.setData(n.getUint8Data().slice().buffer),
                        r._vertexBuffer = i, r._vertexCount = this._vertexCount;
                    var a, o = this._indexBuffer,
                        s = new Le(e.IndexFormat.UInt16, o.indexCount, o.bufferUsage, o.canRead);
                    s.setData(o.getData().slice()), r._indexBuffer = s, r._setBuffer(r._vertexBuffer, s),
                        r._setCPUMemory(this.cpuMemory), r._setGPUMemory(this.gpuMemory);
                    var l = this._boneNames;
                    if (l) {
                        var u = r._boneNames = [];
                        for (a = 0; a < l.length; a++) u[a] = l[a];
                    }
                    var c = this._inverseBindPoses;
                    if (c) {
                        var h = r._inverseBindPoses = [];
                        for (a = 0; a < c.length; a++) h[a] = c[a];
                    }
                    var _ = this._skinnedMatrixCaches.length;
                    for (r._skinnedMatrixCaches.length = _, a = 0; a < _; a++) {
                        var d = this._skinnedMatrixCaches[a];
                        r._skinnedMatrixCaches[a] = new dn(d.subMeshIndex, d.batchIndex, d.batchBoneIndex);
                    }
                    for (a = 0; a < this.subMeshCount; a++) {
                        var f = this._subMeshes[a],
                            m = f._subIndexBufferStart,
                            T = f._subIndexBufferCount,
                            p = f._boneIndicesList,
                            v = new _n(r);
                        v._subIndexBufferStart.length = m.length, v._subIndexBufferCount.length = T.length,
                            v._boneIndicesList.length = p.length;
                        for (var E = 0; E < m.length; E++) v._subIndexBufferStart[E] = m[E];
                        for (E = 0; E < T.length; E++) v._subIndexBufferCount[E] = T[E];
                        for (E = 0; E < p.length; E++) v._boneIndicesList[E] = new Uint16Array(p[E]);
                        v._indexBuffer = s, v._indexStart = f._indexStart, v._indexCount = f._indexCount,
                            v._indices = new Uint16Array(s.getData().buffer, 2 * f._indexStart, f._indexCount);
                        var g = r._vertexBuffer;
                        v._vertexBuffer = g, r._subMeshes.push(v);
                    }
                    r._setSubMeshes(r._subMeshes);
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new Mesh();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "inverseAbsoluteBindPoses",
                get: function() {
                    return this._inverseBindPoses;
                }
            }, {
                key: "vertexCount",
                get: function() {
                    return this._vertexCount;
                }
            }, {
                key: "indexCount",
                get: function() {
                    return this._indexBuffer.indexCount;
                }
            }, {
                key: "subMeshCount",
                get: function() {
                    return this._subMeshes.length;
                }
            }, {
                key: "bounds",
                get: function() {
                    return this._bounds;
                },
                set: function(e) {
                    this._bounds !== e && e.cloneTo(this._bounds);
                }
            }, {
                key: "indexFormat",
                get: function() {
                    return this._indexFormat;
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = y._bullet;
                    e && (Mesh._nativeTempVector30 = e.btVector3_create(0, 0, 0), Mesh._nativeTempVector31 = e.btVector3_create(0, 0, 0),
                        Mesh._nativeTempVector32 = e.btVector3_create(0, 0, 0));
                }
            }, {
                key: "load",
                value: function(e, r) {
                    t.ILaya.loader.create(e, r, null, Mesh.MESH);
                }
            }]), Mesh;
        }();
    fn.MESH = "MESH";
    var mn = function() {
            function PrimitiveMesh() {
                _classCallCheck(this, PrimitiveMesh);
            }
            return _createClass(PrimitiveMesh, null, [{
                key: "__init__",
                value: function() {}
            }, {
                key: "_createMesh",
                value: function(r, n, i) {
                    var a = t.LayaGL.instance,
                        o = new fn(),
                        s = new _n(o),
                        l = new be(4 * n.length, a.STATIC_DRAW, !0);
                    l.vertexDeclaration = r, l.setData(n.buffer), o._vertexBuffer = l, o._vertexCount = l._byteLength / r.vertexStride;
                    var u = new Le(e.IndexFormat.UInt16, i.length, a.STATIC_DRAW, !0);
                    u.setData(i), o._indexBuffer = u, o._setBuffer(l, u), s._vertexBuffer = l, s._indexBuffer = u,
                        s._setIndexRange(0, u.indexCount);
                    var c = s._subIndexBufferStart,
                        h = s._subIndexBufferCount,
                        _ = s._boneIndicesList;
                    c.length = 1, h.length = 1, _.length = 1, c[0] = 0, h[0] = u.indexCount;
                    var d = [];
                    d.push(s), o._setSubMeshes(d), o.calculateBounds();
                    var f = l._byteLength + u._byteLength;
                    return o._setCPUMemory(f), o._setGPUMemory(f), o;
                }
            }, {
                key: "createBox",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        n = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
                        i = e / 2,
                        a = t / 2,
                        o = r / 2,
                        s = new Float32Array([-i, a, -o, 0, 1, 0, 0, 0, i, a, -o, 0, 1, 0, 1, 0, i, a, o, 0, 1, 0, 1, 1, -i, a, o, 0, 1, 0, 0, 1, -i, -a, -o, 0, -1, 0, 0, 1, i, -a, -o, 0, -1, 0, 1, 1, i, -a, o, 0, -1, 0, 1, 0, -i, -a, o, 0, -1, 0, 0, 0, -i, a, -o, -1, 0, 0, 0, 0, -i, a, o, -1, 0, 0, 1, 0, -i, -a, o, -1, 0, 0, 1, 1, -i, -a, -o, -1, 0, 0, 0, 1, i, a, -o, 1, 0, 0, 1, 0, i, a, o, 1, 0, 0, 0, 0, i, -a, o, 1, 0, 0, 0, 1, i, -a, -o, 1, 0, 0, 1, 1, -i, a, o, 0, 0, 1, 0, 0, i, a, o, 0, 0, 1, 1, 0, i, -a, o, 0, 0, 1, 1, 1, -i, -a, o, 0, 0, 1, 0, 1, -i, a, -o, 0, 0, -1, 1, 0, i, a, -o, 0, 0, -1, 0, 0, i, -a, -o, 0, 0, -1, 0, 1, -i, -a, -o, 0, 0, -1, 1, 1]),
                        l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
                    return PrimitiveMesh._createMesh(n, s, l);
                }
            }, {
                key: "createCapsule",
                value: function() {
                    var e, t, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2,
                        i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 16,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 32,
                        o = (i + 1) * (a + 1) * 2 + 2 * (a + 1),
                        s = 3 * i * (a + 1) * 2 * 2 + 2 * a * 3,
                        l = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
                        u = l.vertexStride / 4,
                        c = new Float32Array(o * u),
                        h = new Uint16Array(s),
                        _ = Math.PI / 2 / i,
                        d = 2 * Math.PI / a,
                        f = n / 2 - r,
                        m = 0,
                        T = 0,
                        p = 0,
                        v = 0,
                        E = 0,
                        g = 0;
                    for (e = 0; e <= i; e++)
                        for (t = 0; t <= a; t++) m = r * Math.cos(e * _) * Math.cos(t * d + Math.PI),
                            T = r * Math.sin(e * _), p = r * Math.cos(e * _) * Math.sin(t * d + Math.PI), c[v++] = m,
                            c[v++] = T + f, c[v++] = p, c[v++] = m, c[v++] = T, c[v++] = p, c[v++] = 1 - t / a,
                            c[v++] = (1 - e / i) * (Math.PI * r / 2 / (n + Math.PI * r)), e < i && (h[E++] = e * (a + 1) + t + (a + 1),
                                h[E++] = e * (a + 1) + t, h[E++] = e * (a + 1) + t + 1, h[E++] = e * (a + 1) + t + a,
                                h[E++] = e * (a + 1) + t, h[E++] = e * (a + 1) + t + (a + 1));
                    for (g += (i + 1) * (a + 1), e = 0; e <= i; e++)
                        for (t = 0; t <= a; t++) m = r * Math.cos(e * _) * Math.cos(t * d + Math.PI),
                            T = r * Math.sin(-e * _), p = r * Math.cos(e * _) * Math.sin(t * d + Math.PI), c[v++] = m,
                            c[v++] = T - f, c[v++] = p, c[v++] = m, c[v++] = T, c[v++] = p, c[v++] = 1 - t / a,
                            c[v++] = (e / i * (Math.PI * r / 2) + (n + Math.PI * r / 2)) / (n + Math.PI * r),
                            e < i && (h[E++] = g + e * (a + 1) + t, h[E++] = g + e * (a + 1) + t + (a + 1),
                                h[E++] = g + e * (a + 1) + t + 1, h[E++] = g + e * (a + 1) + t, h[E++] = g + e * (a + 1) + t + a,
                                h[E++] = g + e * (a + 1) + t + (a + 1));
                    for (g += (i + 1) * (a + 1), t = 0; t <= a; t++) m = r * Math.cos(t * d + Math.PI),
                        T = f, p = r * Math.sin(t * d + Math.PI), c[v++] = m, c[v + 8 * (a + 1) - 1] = m,
                        c[v++] = T, c[v + 8 * (a + 1) - 1] = -T, c[v++] = p, c[v + 8 * (a + 1) - 1] = p,
                        c[v++] = m, c[v + 8 * (a + 1) - 1] = m, c[v++] = 0, c[v + 8 * (a + 1) - 1] = 0,
                        c[v++] = p, c[v + 8 * (a + 1) - 1] = p, c[v++] = 1 - 1 * t / a, c[v + 8 * (a + 1) - 1] = 1 - 1 * t / a,
                        c[v++] = Math.PI * r / 2 / (n + Math.PI * r), c[v + 8 * (a + 1) - 1] = (Math.PI * r / 2 + n) / (n + Math.PI * r);
                    for (t = 0; t < a; t++) h[E++] = t + g + (a + 1), h[E++] = t + g + 1, h[E++] = t + g,
                        h[E++] = t + g + (a + 1), h[E++] = t + g + (a + 1) + 1, h[E++] = t + g + 1;
                    return g += 2 * (a + 1), PrimitiveMesh._createMesh(l, c, h);
                }
            }, {
                key: "createCone",
                value: function() {
                    for (var e, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, i = n + 1 + 1 + 2 * (n + 1), a = 6 * n + 3 * n, s = Ne.getVertexDeclaration("POSITION,NORMAL,UV"), l = s.vertexStride / 4, u = new Float32Array(i * l), c = new Uint16Array(a), h = 2 * Math.PI / n, _ = r / 2, d = 0, m = 0, T = 0, p = 0, v = 0, E = new o(), g = new o(0, -1, 0), y = new o(0, _, 0), S = new o(), R = new o(), C = new f(), M = new o(), x = 0, D = 0, A = 0; A <= n; A++) d = A * h,
                        T = Math.cos(d + Math.PI) * t, p = _, v = Math.sin(d + Math.PI) * t, u[x++] = 0,
                        u[x + 8 * (n + 1) - 1] = T, u[x++] = p, u[x + 8 * (n + 1) - 1] = -p, u[x++] = 0,
                        u[x + 8 * (n + 1) - 1] = v, E.x = T, E.y = 0, E.z = v, S.x = T, S.y = -p, S.z = v,
                        o.subtract(S, y, R), o.normalize(R, R), e = Math.acos(o.dot(g, R)), o.cross(g, R, M),
                        o.normalize(M, M), f.createFromAxisAngle(M, e, C), o.normalize(E, E), o.transformQuat(E, C, E),
                        o.normalize(E, E), u[x++] = E.x, u[x + 8 * (n + 1) - 1] = E.x, u[x++] = E.y, u[x + 8 * (n + 1) - 1] = E.y,
                        u[x++] = E.z, u[x + 8 * (n + 1) - 1] = E.z, u[x++] = 1 - 1 * A / n, u[x + 8 * (n + 1) - 1] = 1 - 1 * A / n,
                        u[x++] = 0, u[x + 8 * (n + 1) - 1] = 1;
                    x += 8 * (n + 1);
                    for (var L = 0; L < n; L++) c[D++] = L + m + (n + 1), c[D++] = L + m + 1, c[D++] = L + m,
                        c[D++] = L + m + (n + 1), c[D++] = L + m + (n + 1) + 1, c[D++] = L + m + 1;
                    m += 2 * (n + 1);
                    for (var I = 0; I <= n; I++) 0 === I && (u[x++] = 0, u[x++] = -_, u[x++] = 0, u[x++] = 0,
                            u[x++] = -1, u[x++] = 0, u[x++] = .5, u[x++] = .5), d = I * h, T = Math.cos(d + Math.PI) * t,
                        p = -_, v = Math.sin(d + Math.PI) * t, u[x++] = T, u[x++] = p, u[x++] = v, u[x++] = 0,
                        u[x++] = -1, u[x++] = 0, u[x++] = .5 + .5 * Math.cos(d), u[x++] = .5 + .5 * Math.sin(d);
                    for (var O = 0; O < n; O++) c[D++] = 0 + m, c[D++] = O + 2 + m, c[D++] = O + 1 + m;
                    return m += n + 1 + 1, PrimitiveMesh._createMesh(s, u, c);
                }
            }, {
                key: "createCylinder",
                value: function() {
                    for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32, n = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), i = 3 * r + 6 * r + 3 * r, a = Ne.getVertexDeclaration("POSITION,NORMAL,UV"), o = a.vertexStride / 4, s = new Float32Array(n * o), l = new Uint16Array(i), u = 2 * Math.PI / r, c = t / 2, h = 0, _ = 0, d = 0, f = 0, m = 0, T = 0, p = 0, v = 0; v <= r; v++) 0 === v && (s[T++] = 0,
                            s[T++] = c, s[T++] = 0, s[T++] = 0, s[T++] = 1, s[T++] = 0, s[T++] = .5, s[T++] = .5),
                        h = v * u, d = Math.cos(h) * e, f = c, m = Math.sin(h) * e, s[T++] = d, s[T++] = f,
                        s[T++] = m, s[T++] = 0, s[T++] = 1, s[T++] = 0, s[T++] = .5 + .5 * Math.cos(h),
                        s[T++] = .5 + .5 * Math.sin(h);
                    for (var E = 0; E < r; E++) l[p++] = 0, l[p++] = E + 1, l[p++] = E + 2;
                    _ += r + 1 + 1;
                    for (var g = 0; g <= r; g++) h = g * u, d = Math.cos(h + Math.PI) * e, f = c, m = Math.sin(h + Math.PI) * e,
                        s[T++] = d, s[T + 8 * (r + 1) - 1] = d, s[T++] = f, s[T + 8 * (r + 1) - 1] = -f,
                        s[T++] = m, s[T + 8 * (r + 1) - 1] = m, s[T++] = d, s[T + 8 * (r + 1) - 1] = d,
                        s[T++] = 0, s[T + 8 * (r + 1) - 1] = 0, s[T++] = m, s[T + 8 * (r + 1) - 1] = m,
                        s[T++] = 1 - 1 * g / r, s[T + 8 * (r + 1) - 1] = 1 - 1 * g / r, s[T++] = 0, s[T + 8 * (r + 1) - 1] = 1;
                    T += 8 * (r + 1);
                    for (var y = 0; y < r; y++) l[p++] = y + _ + (r + 1), l[p++] = y + _ + 1, l[p++] = y + _,
                        l[p++] = y + _ + (r + 1), l[p++] = y + _ + (r + 1) + 1, l[p++] = y + _ + 1;
                    _ += 2 * (r + 1);
                    for (var S = 0; S <= r; S++) 0 === S && (s[T++] = 0, s[T++] = -c, s[T++] = 0, s[T++] = 0,
                            s[T++] = -1, s[T++] = 0, s[T++] = .5, s[T++] = .5), h = S * u, d = Math.cos(h + Math.PI) * e,
                        f = -c, m = Math.sin(h + Math.PI) * e, s[T++] = d, s[T++] = f, s[T++] = m, s[T++] = 0,
                        s[T++] = -1, s[T++] = 0, s[T++] = .5 + .5 * Math.cos(h), s[T++] = .5 + .5 * Math.sin(h);
                    for (var R = 0; R < r; R++) l[p++] = 0 + _, l[p++] = R + 2 + _, l[p++] = R + 1 + _;
                    return _ += r + 1 + 1, PrimitiveMesh._createMesh(a, s, l);
                }
            }, {
                key: "createPlane",
                value: function() {
                    for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 10, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 10, r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10, i = (r + 1) * (n + 1), a = new Uint16Array(r * n * 2 * 3), o = Ne.getVertexDeclaration("POSITION,NORMAL,UV"), s = o.vertexStride / 4, l = new Float32Array(i * s), u = e / 2, c = t / 2, h = e / r, _ = t / n, d = 0, f = 0; f <= n; f++)
                        for (var m = 0; m <= r; m++) l[d++] = m * h - u,
                            l[d++] = 0, l[d++] = f * _ - c, l[d++] = 0, l[d++] = 1, l[d++] = 0, l[d++] = 1 * m / r,
                            l[d++] = 1 * f / n;
                    var T = 0;
                    for (f = 0; f < n; f++)
                        for (m = 0; m < r; m++) a[T++] = (f + 1) * (r + 1) + m,
                            a[T++] = f * (r + 1) + m, a[T++] = (f + 1) * (r + 1) + m + 1, a[T++] = f * (r + 1) + m,
                            a[T++] = f * (r + 1) + m + 1, a[T++] = (f + 1) * (r + 1) + m + 1;
                    return PrimitiveMesh._createMesh(o, l, a);
                }
            }, {
                key: "createQuad",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        r = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
                        n = e / 2,
                        i = t / 2,
                        a = new Float32Array([-n, i, 0, 0, 0, 1, 0, 0, n, i, 0, 0, 0, 1, 1, 0, -n, -i, 0, 0, 0, 1, 0, 1, n, -i, 0, 0, 0, 1, 1, 1]),
                        o = new Uint16Array([0, 1, 2, 3, 2, 1]);
                    return PrimitiveMesh._createMesh(r, a, o);
                }
            }, {
                key: "createSphere",
                value: function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : .5,
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 32,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 32,
                        n = (t + 1) * (r + 1),
                        i = 3 * t * (r + 1) * 2,
                        a = new Uint16Array(i),
                        o = Ne.getVertexDeclaration("POSITION,NORMAL,UV"),
                        s = o.vertexStride / 4,
                        l = new Float32Array(n * s),
                        u = Math.PI / t,
                        c = 2 * Math.PI / r,
                        h = 0;
                    n = 0, i = 0;
                    for (var _ = 0; _ < t + 1; _++)
                        for (var d = Math.sin(_ * u), f = Math.cos(_ * u), m = 0; m < r + 1; m++) {
                            var T = d * Math.sin(m * c + 1 * Math.PI / 2),
                                p = d * Math.cos(m * c + 1 * Math.PI / 2);
                            l[n + 0] = T * e, l[n + 1] = f * e, l[n + 2] = p * e, l[n + 3] = T, l[n + 4] = f,
                                l[n + 5] = p, l[n + 6] = m / r, l[n + 7] = _ / t, n += s, _ != t - 1 && (a[i++] = h + (r + 1),
                                    a[i++] = h, a[i++] = h + 1, a[i++] = h + r, a[i++] = h, a[i++] = h + (r + 1), h++);
                        }
                    return PrimitiveMesh._createMesh(o, l, a);
                }
            }]), PrimitiveMesh;
        }(),
        Tn = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        pn = function() {
            function ShaderInit3D() {
                _classCallCheck(this, ShaderInit3D);
            }
            return _createClass(ShaderInit3D, null, [{
                key: "__init__",
                value: function() {
                    G.SHADERDEFINE_LEGACYSINGALLIGHTING = G.getDefineByName("LEGACYSINGLELIGHTING"),
                        G.SHADERDEFINE_GRAPHICS_API_GLES2 = G.getDefineByName("GRAPHICS_API_GLES2"), G.SHADERDEFINE_GRAPHICS_API_GLES3 = G.getDefineByName("GRAPHICS_API_GLES3"),
                        G.addInclude("Lighting.glsl", "#ifdef GRAPHICS_API_GLES3\r\n\t#define INVERSE_MAT(mat) inverse(mat)\r\n#else\r\n\t#define INVERSE_MAT(mat) inverseMat(mat)\r\n#endif\r\n\r\nstruct DirectionLight {\r\n\tvec3 color;\r\n\tvec3 direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 color;\r\n\tvec3 position;\r\n\tfloat range;\r\n\tvec3 direction;\r\n\tfloat spot;\r\n};\r\n\r\nstruct LayaGI{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nstruct LayaLight{\r\n\tvec3 color;\r\n\tvec3 dir;\r\n};\r\n\r\nconst int c_ClusterBufferWidth = CLUSTER_X_COUNT*CLUSTER_Y_COUNT;\r\nconst int c_ClusterBufferHeight = CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));\r\nconst int c_ClusterBufferFloatWidth = c_ClusterBufferWidth*4;\r\n\r\n#ifndef GRAPHICS_API_GLES3\r\n\tmat3 inverseMat(mat3 m) {\r\n\t\tfloat a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n\t\tfloat a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n\t\tfloat a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n\t\tfloat b01 = a22 * a11 - a12 * a21;\r\n\t\tfloat b11 = -a22 * a10 + a12 * a20;\r\n\t\tfloat b21 = a21 * a10 - a11 * a20;\r\n\r\n\t\tfloat det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n\t\treturn mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n\t\t\t\t\tb11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n\t\t\t\t\tb21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n\t}\r\n#endif\r\n\r\nivec4 getClusterInfo(sampler2D clusterBuffer,mat4 viewMatrix,vec4 viewport,vec3 position,vec4 fragCoord,vec4 projectParams)\r\n{\r\n\tvec3 viewPos = vec3(viewMatrix*vec4(position, 1.0)); //position in viewspace\r\n\r\n\tint clusterXIndex = int(floor(fragCoord.x/ (float(viewport.z)/float(CLUSTER_X_COUNT))));\r\n    int clusterYIndex = int(floor((viewport.w * (projectParams.z <0.0? 0.0 : 1.0) - fragCoord.y * projectParams.z)/ (float(viewport.w)/float(CLUSTER_Y_COUNT))));//Maybe Flipped ProjectMatrix\r\n\tfloat zSliceParam =float(CLUSTER_Z_COUNT)/log2(projectParams.y / projectParams.x);\r\n \tint clusterZIndex = int(floor(log2(-viewPos.z) * zSliceParam- log2(projectParams.x) * zSliceParam));//projectParams x:cameraNear y:cameraFar\r\n\r\n\tvec2 uv= vec2((float(clusterXIndex + clusterYIndex * CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 clusterPixel=texture2D(clusterBuffer, uv);\r\n\treturn ivec4(clusterPixel);//X:Point Count Y:Spot Count Z、W:Light Offset\r\n}\r\n\r\n\r\nint getLightIndex(sampler2D clusterBuffer,int offset,int index) \r\n{\r\n\tint totalOffset=offset+index;\r\n\tint row=totalOffset/c_ClusterBufferFloatWidth;\r\n\tint lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;\r\n\tint col=lastRowFloat/4;\r\n\tvec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),\r\n\t\t\t\t(float(row)+0.5)/float(c_ClusterBufferHeight));\r\n\tvec4 texel = texture2D(clusterBuffer, uv);\r\n    int pixelComponent = lastRowFloat-col*4;\r\n    if (pixelComponent == 0) \r\n      return int(texel.x);\r\n    else if (pixelComponent == 1) \r\n      return int(texel.y);\r\n    else if (pixelComponent == 2) \r\n      return int(texel.z);\r\n    else //pixelComponent==3\r\n      return int(texel.w);\r\n}\r\n\r\nDirectionLight getDirectionLight(sampler2D lightBuffer,int index) \r\n{\r\n    DirectionLight light;\r\n    float v = (float(index)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n    light.direction = p2.rgb;\r\n    return light;\r\n}\r\n\r\nPointLight getPointLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    PointLight light;\r\n\tint pointIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,index);\r\n    float v = (float(pointIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tlight.color=p1.rgb;\r\n\tlight.range = p1.a;\r\n    light.position = p2.rgb;\r\n    return light;\r\n}\r\n\r\nSpotLight getSpotLight(sampler2D lightBuffer,sampler2D clusterBuffer,ivec4 clusterInfo,int index) \r\n{\r\n    SpotLight light;\r\n\tint spoIndex=getLightIndex(clusterBuffer,clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w,clusterInfo.x+index);\r\n    float v = (float(spoIndex)+0.5)/ float(MAX_LIGHT_COUNT);\r\n    vec4 p1 = texture2D(lightBuffer, vec2(0.125,v));\r\n    vec4 p2 = texture2D(lightBuffer, vec2(0.375,v));\r\n\tvec4 p3 = texture2D(lightBuffer, vec2(0.625,v));\r\n    light.color = p1.rgb;\r\n\tlight.range=p1.a;\r\n    light.position = p2.rgb;\r\n\tlight.spot = p2.a;\r\n\tlight.direction = p3.rgb;\r\n    return light;\r\n}\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\tmediump vec3 N = unitNormal;\r\n\tmediump vec3 T = tangent;\r\n\tmediump vec3 B = binormal;\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal =normalize(TBN*normalT);\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec3 decodeHDR(vec4 color,float range) {\r\n\treturn color.rgb*color.a*range;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmediump vec3 layaLinearToGammaSpace (mediump vec3 linRGB)\r\n{\r\n    linRGB = max(linRGB, vec3(0.0));\r\n    // An almost-perfect approximation from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n    return max(1.055 * pow(linRGB,vec3(0.416666667)) - 0.055, 0.0);   \r\n}\r\n\r\nLayaLight layaDirectionLightToLight(in DirectionLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = light.direction;\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaPointLightToLight(in vec3 pos,in vec3 normal, in PointLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range);\r\n\trelight.color = light.color*attenuate;\r\n\trelight.dir = normalize(lightVec);\r\n\treturn relight;\r\n}\r\n\r\nLayaLight layaSpotLightToLight(in vec3 pos,in vec3 normal, in SpotLight light,in float attenuate)\r\n{\r\n\tLayaLight relight;\r\n\tvec3 lightVec =  pos-light.position;\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tvec2 cosAngles=cos(vec2(light.spot,light.spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tattenuate *= LayaAttenuation(lightVec, 1.0/light.range)*dl;\r\n\trelight.dir = lightVec;\r\n\trelight.color = light.color*attenuate;\r\n\treturn relight;\r\n}\r\n\r\n"),
                        G.addInclude("ShadowSampleTent.glsl", '// ------------------------------------------------------------------\r\n//  PCF Filtering Tent Functions\r\n// ------------------------------------------------------------------\r\n\r\n// Assuming a isoceles right angled triangle of height "triangleHeight" (as drawn below).\r\n// This function return the area of the triangle above the first texel(in Y the first texel).\r\n//\r\n// |\\      <-- 45 degree slop isosceles right angled triangle\r\n// | \\\r\n// ----    <-- length of this side is "triangleHeight"\r\n// _ _ _ _ <-- texels\r\nfloat sampleShadowGetIRTriangleTexelArea(float triangleHeight)\r\n{\r\n    return triangleHeight - 0.5;\r\n}\r\n\r\n// Assuming a isoceles triangle of 1.5 texels height and 3 texels wide lying on 4 texels.\r\n// This function return the area of the triangle above each of those texels.\r\n//    |    <-- offset from -0.5 to 0.5, 0 meaning triangle is exactly in the center\r\n//   / \\   <-- 45 degree slop isosceles triangle (ie tent projected in 2D)\r\n//  /   \\\r\n// _ _ _ _ <-- texels\r\n// X Y Z W <-- result indices (in computedArea.xyzw and computedAreaUncut.xyzw)\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelAreasTent3x3(float offset, out vec4 computedArea, out vec4 computedAreaUncut)\r\n{\r\n    // Compute the exterior areas,a and h is same.\r\n    float a = offset + 0.5;\r\n    float offsetSquaredHalved = a * a * 0.5;\r\n    computedAreaUncut.x = computedArea.x = offsetSquaredHalved - offset;\r\n    computedAreaUncut.w = computedArea.w = offsetSquaredHalved;\r\n\r\n    // Compute the middle areas\r\n    // For Y : We find the area in Y of as if the left section of the isoceles triangle would\r\n    // intersect the axis between Y and Z (ie where offset = 0).\r\n    computedAreaUncut.y = sampleShadowGetIRTriangleTexelArea(1.5 - offset);\r\n    // This area is superior to the one we are looking for if (offset < 0) thus we need to\r\n    // subtract the area of the triangle defined by (0,1.5-offset), (0,1.5+offset), (-offset,1.5).\r\n    float clampedOffsetLeft = min(offset,0.0);\r\n    float areaOfSmallLeftTriangle = clampedOffsetLeft * clampedOffsetLeft;\r\n    computedArea.y = computedAreaUncut.y - areaOfSmallLeftTriangle;\r\n\r\n    // We do the same for the Z but with the right part of the isoceles triangle\r\n    computedAreaUncut.z = sampleShadowGetIRTriangleTexelArea(1.5 + offset);\r\n    float clampedOffsetRight = max(offset,0.0);\r\n    float areaOfSmallRightTriangle = clampedOffsetRight * clampedOffsetRight;\r\n    computedArea.z = computedAreaUncut.z - areaOfSmallRightTriangle;\r\n}\r\n\r\n// Assuming a isoceles triangle of 2.5 texel height and 5 texels wide lying on 6 texels.\r\n// This function return the weight of each texels area relative to the full triangle area.\r\n//  /       \\\r\n// _ _ _ _ _ _ <-- texels\r\n// 0 1 2 3 4 5 <-- computed area indices (in texelsWeights[])\r\n// Top point at (right,top) in a texel,left bottom point at (middle,middle) in a texel,right bottom point at (middle,middle) in a texel.\r\nvoid sampleShadowGetTexelWeightsTent5x5(float offset, out vec3 texelsWeightsA, out vec3 texelsWeightsB)\r\n{\r\n    vec4 areaFrom3texelTriangle;\r\n    vec4 areaUncutFrom3texelTriangle;\r\n    sampleShadowGetTexelAreasTent3x3(offset, areaFrom3texelTriangle, areaUncutFrom3texelTriangle);\r\n\r\n    // Triangle slope is 45 degree thus we can almost reuse the result of the 3 texel wide computation.\r\n    // the 5 texel wide triangle can be seen as the 3 texel wide one but shifted up by one unit/texel.\r\n    // 0.16 is 1/(the triangle area)\r\n    texelsWeightsA.x = 0.16 * (areaFrom3texelTriangle.x);\r\n    texelsWeightsA.y = 0.16 * (areaUncutFrom3texelTriangle.y);\r\n    texelsWeightsA.z = 0.16 * (areaFrom3texelTriangle.y + 1.0);\r\n    texelsWeightsB.x = 0.16 * (areaFrom3texelTriangle.z + 1.0);\r\n    texelsWeightsB.y = 0.16 * (areaUncutFrom3texelTriangle.z);\r\n    texelsWeightsB.z = 0.16 * (areaFrom3texelTriangle.w);\r\n}\r\n\r\n// 5x5 Tent filter (45 degree sloped triangles in U and V)\r\nvoid sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize, vec2 coord, out float fetchesWeights[9], out vec2 fetchesUV[9])\r\n{\r\n    // tent base is 5x5 base thus covering from 25 to 36 texels, thus we need 9 bilinear PCF fetches\r\n    vec2 tentCenterInTexelSpace = coord.xy * shadowMapTextureTexelSize.zw;\r\n    vec2 centerOfFetchesInTexelSpace = floor(tentCenterInTexelSpace + 0.5);\r\n    vec2 offsetFromTentCenterToCenterOfFetches = tentCenterInTexelSpace - centerOfFetchesInTexelSpace;\r\n\r\n    // find the weight of each texel based on the area of a 45 degree slop tent above each of them.\r\n    vec3 texelsWeightsUA, texelsWeightsUB;\r\n    vec3 texelsWeightsVA, texelsWeightsVB;\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x, texelsWeightsUA, texelsWeightsUB);\r\n    sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y, texelsWeightsVA, texelsWeightsVB);\r\n\r\n    // each fetch will cover a group of 2x2 texels, the weight of each group is the sum of the weights of the texels\r\n    vec3 fetchesWeightsU = vec3(texelsWeightsUA.xz, texelsWeightsUB.y) + vec3(texelsWeightsUA.y, texelsWeightsUB.xz);\r\n    vec3 fetchesWeightsV = vec3(texelsWeightsVA.xz, texelsWeightsVB.y) + vec3(texelsWeightsVA.y, texelsWeightsVB.xz);\r\n\r\n    // move the PCF bilinear fetches to respect texels weights\r\n    vec3 fetchesOffsetsU = vec3(texelsWeightsUA.y, texelsWeightsUB.xz) / fetchesWeightsU.xyz + vec3(-2.5,-0.5,1.5);\r\n    vec3 fetchesOffsetsV = vec3(texelsWeightsVA.y, texelsWeightsVB.xz) / fetchesWeightsV.xyz + vec3(-2.5,-0.5,1.5);\r\n    fetchesOffsetsU *= shadowMapTextureTexelSize.xxx;\r\n    fetchesOffsetsV *= shadowMapTextureTexelSize.yyy;\r\n\r\n    vec2 bilinearFetchOrigin = centerOfFetchesInTexelSpace * shadowMapTextureTexelSize.xy;\r\n    fetchesUV[0] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.x);\r\n    fetchesUV[1] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.x);\r\n    fetchesUV[2] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.x);\r\n    fetchesUV[3] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.y);\r\n    fetchesUV[4] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.y);\r\n    fetchesUV[5] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.y);\r\n    fetchesUV[6] = bilinearFetchOrigin + vec2(fetchesOffsetsU.x, fetchesOffsetsV.z);\r\n    fetchesUV[7] = bilinearFetchOrigin + vec2(fetchesOffsetsU.y, fetchesOffsetsV.z);\r\n    fetchesUV[8] = bilinearFetchOrigin + vec2(fetchesOffsetsU.z, fetchesOffsetsV.z);\r\n\r\n    fetchesWeights[0] = fetchesWeightsU.x * fetchesWeightsV.x;\r\n    fetchesWeights[1] = fetchesWeightsU.y * fetchesWeightsV.x;\r\n    fetchesWeights[2] = fetchesWeightsU.z * fetchesWeightsV.x;\r\n    fetchesWeights[3] = fetchesWeightsU.x * fetchesWeightsV.y;\r\n    fetchesWeights[4] = fetchesWeightsU.y * fetchesWeightsV.y;\r\n    fetchesWeights[5] = fetchesWeightsU.z * fetchesWeightsV.y;\r\n    fetchesWeights[6] = fetchesWeightsU.x * fetchesWeightsV.z;\r\n    fetchesWeights[7] = fetchesWeightsU.y * fetchesWeightsV.z;\r\n    fetchesWeights[8] = fetchesWeightsU.z * fetchesWeightsV.z;\r\n}'),
                        G.addInclude("GlobalIllumination.glsl", 'struct LayaGIInput\r\n{\r\n\tvec2 lightmapUV;\r\n};\r\n\r\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n#if defined(GI_AMBIENT_SH)\r\n\tuniform vec4 u_AmbientSHAr;\r\n\tuniform vec4 u_AmbientSHAg;\r\n\tuniform vec4 u_AmbientSHAb;\r\n\tuniform vec4 u_AmbientSHBr;\r\n\tuniform vec4 u_AmbientSHBg;\r\n\tuniform vec4 u_AmbientSHBb;\r\n\tuniform vec4 u_AmbientSHC;\r\n#endif\r\n\r\nuniform samplerCube u_ReflectTexture;\r\nuniform vec4 u_ReflectCubeHDRParams;\r\n\r\n\r\n#ifdef GI_AMBIENT_SH\r\n\tmediump vec3 shEvalLinearL0L1(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x;\r\n\t\t// Linear (L1) + constant (L0) polynomial terms\r\n\t\tx.r = dot(u_AmbientSHAr, normal);\r\n\t\tx.g = dot(u_AmbientSHAg, normal);\r\n\t\tx.b = dot(u_AmbientSHAb, normal);\r\n\t\treturn x;\r\n\t}\r\n\r\n\tmediump vec3 shEvalLinearL2(mediump vec4 normal)\r\n\t{\r\n\t\tmediump vec3 x1,x2;\r\n\t\t// 4 of the quadratic (L2) polynomials\r\n\t\tmediump vec4 vB = normal.xyzz * normal.yzzx;\r\n\t\tx1.r = dot(u_AmbientSHBr, vB);\r\n\t\tx1.g = dot(u_AmbientSHBg, vB);\r\n\t\tx1.b = dot(u_AmbientSHBb, vB);\r\n\r\n\t\t// Final (5th) quadratic (L2) polynomial\r\n\t\tmediump float vC = normal.x*normal.x - normal.y*normal.y;\r\n\t\tx2 = u_AmbientSHC.rgb * vC;\r\n\r\n\t\treturn x1 + x2;\r\n\t}\r\n\t\r\n\tmediump vec3 shadeSHPerPixel(mediump vec3 normal)\r\n\t{\r\n\t\tmediump vec3 ambientContrib;\r\n\t\tmediump vec4 normalV4=vec4(-normal.x,normal.yz, 1.0);//Note:SH Data is left-hand,so x need inverse\r\n\t\tambientContrib = shEvalLinearL0L1(normalV4);\r\n\t\tambientContrib += shEvalLinearL2(normalV4);\r\n\t\tmediump vec3 ambient = max(vec3(0.0), ambientContrib);\r\n\t\tambient = layaLinearToGammaSpace(ambient);\r\n\t\treturn ambient;\r\n\t}\r\n#endif\r\n\r\nmediump vec3 layaDecodeDirectionalLightmap (mediump vec3 color, lowp vec4 dirTex, mediump vec3 normalWorld)\r\n{\r\n    // In directional (non-specular) mode Enlighten bakes dominant light direction\r\n    // in a way, that using it for half Lambert and then dividing by a "rebalancing coefficient"\r\n    // gives a result close to plain diffuse response lightmaps, but normalmapped.\r\n\r\n    // Note that dir is not unit length on purpose. Its length is "directionality", like\r\n    // for the directional specular lightmaps.\r\n\tlowp vec3 directional=dirTex.xyz - 0.5;\r\n\tdirectional.x=-directional.x;//NOTE:because coord System\r\n    mediump float halfLambert = dot(normalWorld,directional) + 0.5;\r\n\r\n    return color * halfLambert / max(1e-4, dirTex.w);\r\n}\r\n\r\nvec3 layaGIBase(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld)\r\n{\r\n\tvec3 indirectDiffuse;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tmediump vec3 bakedColor =decodeHDR(texture2D(u_LightMap, giInput.lightmapUV),5.0);\r\n\t\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\t\tlowp vec4 bakedDirTex = texture2D (u_LightMapDirection, giInput.lightmapUV);\r\n            indirectDiffuse = layaDecodeDirectionalLightmap (bakedColor, bakedDirTex, normalWorld);\r\n\t\t#else //unDirectional lightmap\r\n\t\t\tindirectDiffuse = bakedColor;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef GI_AMBIENT_SH\r\n\t\t\tindirectDiffuse = shadeSHPerPixel(normalWorld);\r\n\t\t#else\r\n\t\t\tindirectDiffuse = u_AmbientColor; //already in gamma space\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tindirectDiffuse*=occlusion;\r\n\treturn indirectDiffuse;\r\n}\r\n\r\nmediump vec3 layaGlossyEnvironment(mediump vec4 glossIn)\r\n{\r\n\tmediump float perceptualRoughness = glossIn.a;\r\n\r\n\t// use approximation to solve,below is more reasonable,but maybe slow. \r\n\t// float m = perceptualRoughnessToRoughness(perceptualRoughness); // m is the real roughness parameter\r\n    // const float fEps = 1.192092896e-07F;        // smallest such that 1.0+FLT_EPSILON != 1.0  (+1e-4h is NOT good here. is visibly very wrong)\r\n    // float n =  (2.0/max(fEps, m*m))-2.0;        // remap to spec power. See eq. 21 in --\x3e https://dl.dropboxusercontent.com/u/55891920/papers/mm_brdf.pdf\r\n    // n /= 4;                                     // remap from n_dot_h formulatino to n_dot_r. See section "Pre-convolved Cube Maps vs Path Tracers" --\x3e https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys_power_drops.html\r\n    // perceptualRoughness = pow( 2/(n+2), 0.25);  // remap back to square root of real roughness (0.25 include both the sqrt root of the conversion and sqrt for going from roughness to perceptualRoughness)\r\n\tperceptualRoughness = perceptualRoughness * (1.7 - 0.7*perceptualRoughness);//just a approximation,but fast.\r\n \r\n\tmediump float mip = perceptualRoughness * LAYA_SPECCUBE_LOD_STEPS;\r\n\tmediump vec3 uvw = glossIn.rgb;\r\n\tuvw.x=-uvw.x;//Note:reflectCube is left-hand,so x need inverse\r\n\tmediump vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,uvw,mip);\r\n\treturn decodeHDR(rgbm,u_ReflectCubeHDRParams.x);\r\n}\r\n\r\nmediump vec3 layaGIIndirectSpecular(LayaGIInput giInput,mediump float occlusion, vec4 glossIn)\r\n{\r\n\tmediump vec3 specular = layaGlossyEnvironment(glossIn);\r\n\treturn specular * occlusion;\r\n}\r\n\r\n\r\nLayaGI layaGlobalIllumination(LayaGIInput giInput,mediump float occlusion, mediump vec3 normalWorld,mediump vec4 uvwRoughness)\r\n{\r\n\tLayaGI gi;\r\n\tgi.diffuse = layaGIBase(giInput,occlusion, normalWorld);\r\n\tgi.specular = layaGIIndirectSpecular(giInput,occlusion, uvwRoughness);\r\n\treturn gi;\r\n}\r\n\r\n\r\n'),
                        G.addInclude("Shadow.glsl", '#ifndef GRAPHICS_API_GLES3\r\n\t#define NO_NATIVE_SHADOWMAP\r\n#endif\r\n\r\n#ifdef NO_NATIVE_SHADOWMAP\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2D textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName,coord3.xy).r<coord3.z?0.0:1.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\r\n#else\r\n\t#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2DShadow textureName\r\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName,coord3,0.0)\r\n\t#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\r\n#endif\r\n\r\n#if defined(RECEIVESHADOW)&&defined(SHADOW)\r\n    #define CALCULATE_SHADOWS\r\n#endif\r\n\r\nuniform vec4 u_ShadowBias; // x: depth bias, y: normal bias\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\t#include "ShadowSampleTent.glsl"\r\n\r\n\tTEXTURE2D_SHADOW(u_ShadowMap);\r\n\tuniform vec4 u_ShadowMapSize;\r\n\tuniform vec4 u_ShadowParams; // x: shadowStrength\r\n\tuniform mat4 u_ShadowMatrices[4];\r\n\tuniform vec4 u_ShadowSplitSpheres[4];// max cascade is 4\r\n\r\n\tmediump int computeCascadeIndex(vec3 positionWS)\r\n\t{\r\n\t\tvec3 fromCenter0 = positionWS - u_ShadowSplitSpheres[0].xyz;\r\n\t\tvec3 fromCenter1 = positionWS - u_ShadowSplitSpheres[1].xyz;\r\n\t\tvec3 fromCenter2 = positionWS - u_ShadowSplitSpheres[2].xyz;\r\n\t\tvec3 fromCenter3 = positionWS - u_ShadowSplitSpheres[3].xyz;\r\n\r\n\t\tmediump vec4 comparison = vec4(\r\n\t\t\tdot(fromCenter0, fromCenter0)<u_ShadowSplitSpheres[0].w,\r\n\t\t\tdot(fromCenter1, fromCenter1)<u_ShadowSplitSpheres[1].w,\r\n\t\t\tdot(fromCenter2, fromCenter2)<u_ShadowSplitSpheres[2].w,\r\n\t\t\tdot(fromCenter3, fromCenter3)<u_ShadowSplitSpheres[3].w);\r\n\t\tcomparison.yzw = clamp(comparison.yzw - comparison.xyz,0.0,1.0);//keep the nearest\r\n\t\tmediump vec4 indexCoefficient = vec4(4.0,3.0,2.0,1.0);\r\n\t\tmediump int index = 4 - int(dot(comparison, indexCoefficient));\r\n\t\treturn index;\r\n\t}\r\n\r\n\tvec4 getShadowCoord(vec4 positionWS)\r\n\t{\r\n\t\t#ifdef SHADOW_CASCADE\r\n\t\t\tmediump int cascadeIndex = computeCascadeIndex(positionWS.xyz);\r\n\t\t\tif(cascadeIndex > 3)// out of shadow range cascadeIndex is 4.\r\n\t\t\t\treturn vec4(0.0);\r\n\t\t\t\r\n\t\t\t#ifdef GRAPHICS_API_GLES3\r\n\t\t\t\treturn u_ShadowMatrices[cascadeIndex] * positionWS;\r\n\t\t\t#else\r\n\t\t\t\tmat4 shadowMat;\r\n\t\t\t\tif(cascadeIndex == 0)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[0];\r\n\t\t\t\telse if(cascadeIndex == 1)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[1];\r\n\t\t\t\telse if(cascadeIndex == 2)\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[2];\r\n\t\t\t\telse\r\n\t\t\t\t\tshadowMat = u_ShadowMatrices[3];\r\n\t\t\t\treturn shadowMat * positionWS;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\treturn u_ShadowMatrices[0] * positionWS;\r\n\t\t#endif\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tvec4 attenuation4;\r\n\t\tvec2 offset=shadowMapSize.xy/2.0;\r\n\t\tvec3 shadowCoord0=shadowCoord + vec3(-offset,0.0);\r\n\t\tvec3 shadowCoord1=shadowCoord + vec3(offset.x,-offset.y,0.0);\r\n\t\tvec3 shadowCoord2=shadowCoord + vec3(-offset.x,offset.y,0.0);\r\n\t\tvec3 shadowCoord3=shadowCoord + vec3(offset,0.0);\r\n\t\tattenuation4.x = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord0);\r\n\t\tattenuation4.y = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord1);\r\n\t\tattenuation4.z = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord2);\r\n\t\tattenuation4.w = SAMPLE_TEXTURE2D_SHADOW(shadowMap, shadowCoord3);\r\n\t\tattenuation = dot(attenuation4, vec4(0.25));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize)\r\n\t{\r\n\t\tfloat attenuation;\r\n\t\tfloat fetchesWeights[9];\r\n\t\tvec2 fetchesUV[9];\r\n\t\tsampleShadowComputeSamplesTent5x5(shadowmapSize, shadowCoord.xy, fetchesWeights, fetchesUV);\r\n\t\tattenuation = fetchesWeights[0] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[0].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[1] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[1].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[2] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[2].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[3] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[3].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[4] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[4].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[5] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[5].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[6] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[6].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[7] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[7].xy, shadowCoord.z));\r\n\t\tattenuation += fetchesWeights[8] * SAMPLE_TEXTURE2D_SHADOW(shadowMap, vec3(fetchesUV[8].xy, shadowCoord.z));\r\n\t\treturn attenuation;\r\n\t}\r\n\r\n\tfloat sampleShadowmap(vec4 shadowCoord)\r\n\t{\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tfloat attenuation = 1.0;\r\n\t\tif(shadowCoord.z > 0.0 && shadowCoord.z < 1.0)\r\n\t\t{\r\n\t\t\t#if defined(SHADOW_SOFT_SHADOW_HIGH)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered9(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#elif defined(SHADOW_SOFT_SHADOW_LOW)\r\n\t\t\t\tattenuation = sampleShdowMapFiltered4(u_ShadowMap,shadowCoord.xyz,u_ShadowMapSize);\r\n\t\t\t#else\r\n\t\t\t\tattenuation = SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap,shadowCoord.xyz);\r\n\t\t\t#endif\r\n\t\t\tattenuation = mix(1.0,attenuation,u_ShadowParams.x);//shadowParams.x:shadow strength\r\n\t\t}\r\n\t\treturn attenuation;\r\n\t}\r\n#endif\r\n\r\nvec3 applyShadowBias(vec3 positionWS, vec3 normalWS, vec3 lightDirection)\r\n{\r\n    float invNdotL = 1.0 - clamp(dot(-lightDirection, normalWS),0.0,1.0);\r\n    float scale = invNdotL * u_ShadowBias.y;\r\n\r\n    // normal bias is negative since we want to apply an inset normal offset\r\n    positionWS += -lightDirection * u_ShadowBias.xxx;\r\n    positionWS += normalWS * vec3(scale);\r\n    return positionWS;\r\n}\r\n'),
                        G.addInclude("ShadowCasterVS.glsl", '#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform mat4 u_ViewProjection;\r\n\r\nuniform vec3 u_ShadowLightDirection;\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nvec4 shadowCasterVertex()\r\n{\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\t\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tworldMat = worldMat * skinTransform;\r\n\t#endif\r\n\r\n\tvec4 positionWS = worldMat * a_Position;\r\n\tvec3 normalWS = normalize(a_Normal*INVERSE_MAT(mat3(worldMat)));//if no normalize will cause precision problem\r\n\r\n\tpositionWS.xyz = applyShadowBias(positionWS.xyz,normalWS,u_ShadowLightDirection);\r\n\r\n\tvec4 positionCS = u_ViewProjection * positionWS;\r\n\tpositionCS.z = max(positionCS.z, 0.0);//min ndc z is 0.0\r\n\r\n\t// //TODO没考虑UV动画呢\r\n\t// #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tv_Texcoord0=a_Texcoord0;\r\n\t// #endif\r\n    return positionCS;\r\n}\r\n'),
                        G.addInclude("ShadowCasterFS.glsl", "// #ifdef ALPHATEST\r\n// \tuniform float u_AlphaTestValue;\r\n// #endif\r\n\r\n// #ifdef DIFFUSEMAP\r\n// \tuniform sampler2D u_DiffuseTexture;\r\n// #endif\r\n\r\n// #if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n// \tvarying vec2 v_Texcoord0;\r\n// #endif\r\n\r\nvec4 shadowCasterFragment()\r\n{\r\n    return vec4(0.0);\r\n    // #if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t// \tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t// \tif( alpha < u_AlphaTestValue )\r\n\t// \t{\r\n\t// \t\tdiscard;\r\n\t// \t}\r\n\t// #endif\r\n}\r\n"),
                        G.addInclude("Colors.glsl", '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}'),
                        G.addInclude("Sampling.glsl", "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}"),
                        G.addInclude("StdLib.glsl", "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}"),
                        G.addInclude("PBRVSInput.glsl", "attribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(NORMALTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n    #ifdef PARALLAXTEXTURE\r\n\t    varying vec3 v_ViewDirForParallax;\r\n    #endif\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\nvarying vec3 v_EyeVec;\r\nvarying vec3 v_PositionWorld;\r\nvarying float v_posViewZ;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif"),
                        G.addInclude("PBRFSInput.glsl", "#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_NormalScale;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\nuniform float u_Metallic;\r\n\r\n#ifdef SPECULARGLOSSTEXTURE\r\n\tuniform sampler2D u_SpecGlossTexture;\r\n#endif\r\nuniform vec3 u_SpecularColor;\r\n\r\nuniform float u_Smoothness;\r\nuniform float u_SmoothnessScale;\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_ParallaxScale;\r\n\tvarying vec3 v_ViewDirForParallax;\r\n#endif\r\n\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n\r\n#ifdef EMISSION \r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n\r\n#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n\t#ifdef LIGHTMAP_DIRECTIONAL\r\n\t\tuniform sampler2D u_LightMapDirection;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\nvarying vec3 v_EyeVec;\r\n\r\n#ifdef NORMALTEXTURE\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n//后面考虑宏TODO\r\nvarying vec3 v_PositionWorld;\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n\r\nmediump float lerpOneTo(mediump float b, mediump float t)\r\n{\r\n    mediump float oneMinusT = 1.0 - t;\r\n    return oneMinusT + b * t;\r\n}\r\n\r\n#ifdef EMISSION \r\n\tvec3 emission(vec2 uv)\r\n\t{\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\treturn texture2D(u_EmissionTexture, uv).rgb * u_EmissionColor.rgb;\r\n\t\t#else\r\n\t\t\treturn u_EmissionColor.rgb;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n\r\nmediump float getAlpha(vec2 uv)\r\n{\r\n\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\treturn u_AlbedoColor.a;\r\n\t#else\r\n\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\treturn texture2D(u_AlbedoTexture, uv).a * u_AlbedoColor.a;\r\n\t\t#else\r\n\t\t\treturn u_AlbedoColor.a;\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\nmediump float getOcclusion(vec2 uv)\r\n{\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tmediump float occ = texture2D(u_OcclusionTexture, uv).g;\r\n\t\treturn lerpOneTo(occ, u_occlusionStrength);\r\n\t#else\r\n\t\treturn 1.0;\r\n\t#endif\r\n}\r\n\r\nmediump vec3 albedo(vec2 uv)\r\n{\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\treturn u_AlbedoColor.rgb * texture2D(u_AlbedoTexture, uv).rgb;\r\n\t#else\r\n\t\treturn u_AlbedoColor.rgb;\r\n\t#endif\r\n\t//TODO:Detail Texture\r\n}\r\n\r\nmediump vec2 getMetallicGloss(vec2 uv)\r\n{\r\n\tmediump vec2 ms;//x is metallic,y is smoothness\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tms.x = texture2D(u_MetallicGlossTexture, uv).r;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms = texture2D(u_MetallicGlossTexture, uv).ra;\r\n\t\t\tms.y *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tms.x = u_Metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tms.y = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tms.y = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tms.y = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\treturn ms;\r\n}\r\n\r\nmediump vec4 specularGloss(vec2 uv)\r\n{\r\n\tmediump vec4 sg;\r\n\t#ifdef SPECULARGLOSSTEXTURE\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = texture2D(u_SpecGlossTexture, uv).rgb;\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a*u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg = texture2D(u_SpecGlossTexture, uv);\r\n\t\t\tsg.a *= u_SmoothnessScale;\r\n\t\t#endif\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\t#ifdef ALBEDOTEXTURE\r\n\t\t\t\tsg.a = texture2D(u_AlbedoTexture, uv).a * u_SmoothnessScale;\r\n\t\t\t#else\r\n\t\t\t\tsg.a = u_SmoothnessScale;\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\tsg.a = u_Smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\treturn sg;\r\n}\r\n\r\n\r\n#ifdef NORMALTEXTURE\r\n\tmediump vec3 unpackScaleNormal(mediump vec3 packednormal, mediump float bumpScale)\r\n\t{\r\n\t\tmediump vec3 normal = packednormal.xyz * 2.0 - 1.0;\r\n\t\tnormal.y=-normal.y;//NOTE:because unity to LayaAir coordSystem.\r\n\t\tnormal.xy *= bumpScale;\r\n\t\treturn normal;\r\n\t}\r\n\t\r\n\tmediump vec3 normalInTangentSpace(vec2 texcoords)\r\n\t{\r\n\t\tmediump vec3 normalTangent = unpackScaleNormal(texture2D(u_NormalTexture, texcoords).rgb,u_NormalScale);\r\n\t\treturn normalTangent;\r\n\t}\r\n#endif\r\n\r\n#ifdef PARALLAXTEXTURE\r\n\tmediump vec2 parallaxOffset1Step(mediump float h, mediump float height, mediump vec3 viewDir)\r\n\t{\r\n\t\th = h * height - height / 2.0;\r\n\t\tviewDir.z += 0.42;\r\n\t\treturn h * (viewDir.xy / viewDir.z);\r\n\t}\r\n\r\n\tvec2 parallax(vec2 texcoords, mediump vec3 viewDir)\r\n\t{\r\n\t\tmediump float h = texture2D(u_ParallaxTexture, texcoords.xy).g;\r\n\t\tvec2 offset = parallaxOffset1Step(h, u_ParallaxScale, viewDir);\r\n\t\treturn texcoords+offset;\r\n\t}\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"),
                        G.addInclude("LayaPBRBRDF.glsl", '// allow to explicitly override LAYA_BRDF_GI and LAYA_BRDF_LIGHT in custom shader,default is layaBRDFHighGI and layaBRDFHighLight\r\n#if !defined (LAYA_BRDF_GI) \r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_GI layaBRDFLowGI\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_GI layaBRDFHighGI\r\n\t#endif\r\n#endif\r\n#if !defined (LAYA_BRDF_LIGHT)\r\n\t#if defined(LAYA_PBR_BRDF_LOW)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFLowLight\r\n\t#elif defined(LAYA_PBR_BRDF_HIGH)\r\n\t\t#define LAYA_BRDF_LIGHT layaBRDFHighLight\r\n\t#endif\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define INV_PI 0.31830988618\r\n\r\nmediump float pow4(mediump float x)\r\n{\r\n\treturn x * x * x * x;\r\n}\r\n\r\nmediump float pow5(mediump float x)\r\n{\r\n\treturn x * x * x * x * x;\r\n}\r\n\r\nmediump vec3 fresnelLerp(mediump vec3 F0,mediump vec3 F90,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn mix(F0, F90, t);\r\n}\r\n\r\nmediump vec3 fresnelTerm(mediump vec3 F0,mediump float cosA)\r\n{\r\n\tfloat t = pow5(1.0 - cosA);   // ala Schlick interpoliation\r\n\treturn F0 + (vec3(1.0) - F0) * t;\r\n}\r\n\r\n// approximage Schlick with ^4 instead of ^5\r\nmediump vec3 fresnelLerpFast (mediump vec3 F0, mediump vec3 F90,mediump float cosA)\r\n{\r\n    mediump float t = pow4 (1.0 - cosA);\r\n    return mix (F0, F90, t);\r\n}\r\n\r\nfloat smoothnessToPerceptualRoughness(float smoothness)\r\n{\r\n    return 1.0 - smoothness;\r\n}\r\n\r\nfloat perceptualRoughnessToRoughness(float perceptualRoughness)\r\n{\r\n    return perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nvec3 safeNormalize(vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * inversesqrt(dp3);\r\n}\r\n\r\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\r\nmediump float disneyDiffuse(mediump float NdotV,mediump float NdotL,mediump float LdotH,mediump float perceptualRoughness)\r\n{\r\n\t//https://www.cnblogs.com/herenzhiming/articles/5790389.html\r\n\tmediump float fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\t// Two schlick fresnel term\r\n\tmediump float lightScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotL));\r\n\tmediump float viewScatter = (1.0 + (fd90 - 1.0) * pow5(1.0 - NdotV));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\n// Ref: http://jcgt.org/published/0003/02/03/paper.pdf\r\nfloat smithJointGGXVisibilityTerm(float NdotL, float NdotV, float roughness)\r\n{\r\n\t// Original formulation:\r\n    // lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\r\n    // lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\r\n    // G           = 1 / (1 + lambda_v + lambda_l);\r\n\r\n\t// scientific code implement:\r\n\t// Reorder code to be more optimal\r\n    // half a          = roughness;\r\n    // half a2         = a * a;\r\n\r\n    // half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\r\n    // half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\r\n\r\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\r\n    // return 0.5f / (lambdaV + lambdaL + 1e-5f);  \r\n\t// This function is not intended to be running on Mobile,therefore epsilon is smaller than can be represented by half\r\n\r\n\t// Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough)\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\treturn 0.5 / (lambdaV + lambdaL + 1e-5);\r\n}\r\n\r\nfloat ggxTerm(float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0; // 2 mad\r\n\treturn INV_PI * a2 / (d * d + 1e-7); // This function is not intended to be running on Mobile,therefore epsilon is smaller than what can be represented by half//返回值小用half来返回\r\n}\r\n\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n// Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization purposes,\r\n// mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves a few precious ALU slots.\r\n\r\n// Main Physically Based BRDF\r\n// Derived from Disney work and based on Torrance-Sparrow micro-facet model\r\n//\r\n// BRDF = kD / pi + kS * (D * V * F) / 4\r\n// I = BRDF * NdotL\r\n//\r\n// *NDF GGX:\r\n// *Smith for Visiblity term\r\n// *Schlick approximation for Fresnel\r\nmediump vec4 layaBRDFHighLight(mediump vec3 diffColor, mediump vec3 specColor, mediump float oneMinusReflectivity, float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaLight light)\r\n{\r\n\tvec3 halfDir = safeNormalize(viewDir-light.dir);\r\n\r\n\tfloat nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n\tfloat nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n\tmediump float lv = clamp(dot(light.dir, viewDir),0.0,1.0);\r\n\tmediump float lh = clamp(dot(light.dir, -halfDir),0.0,1.0);\r\n\r\n\t// Diffuse term\r\n\tmediump float diffuseTerm = disneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\r\n\t// Specular term\r\n    // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm!\r\n    // BUT that will make shader look significantly darker than Legacy ones\r\n\r\n\t// GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness, 0.002);\r\n\tfloat V = smithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = ggxTerm(nh, roughness);\r\n\r\n\tfloat specularTerm = V * D * PI; // Torrance-Sparrow model, Fresnel is applied later\r\n\r\n\t//#ifdef LAYA_COLORSPACE_GAMMA\r\n\tspecularTerm = sqrt(max(1e-4, specularTerm));\r\n\t//#endif\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\t\r\n\tmediump vec3 color = diffColor * light.color * diffuseTerm + specularTerm * light.color * fresnelTerm(specColor, lh);\r\n\treturn vec4(color, 1.0);\r\n}\r\n\r\nvec4 layaBRDFHighGI(mediump vec3 diffColor,mediump vec3 specColor,mediump float oneMinusReflectivity,float smoothness ,float perceptualRoughness,float roughness,mediump float nv,vec3 normal, vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\r\n\tfloat surfaceReduction;\r\n\tsurfaceReduction = 1.0 - 0.28*roughness*perceptualRoughness;// 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =diffColor * gi.diffuse + surfaceReduction * gi.specular * fresnelLerp(specColor,vec3(grazingTerm), nv);\r\n\treturn vec4(color,1.0);\r\n}\r\n// BRDF1-------------------------------------------------------------------------------------\r\n\r\n\r\n// BRDF2-------------------------------------------------------------------------------------\r\n// Based on Minimalist CookTorrance BRDF\r\n// Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255\r\n//\r\n// *NDF [Modified] GGX:\r\n// *Modified Kelemen and Szirmay-​Kalos for Visibility term\r\n// *Fresnel approximated with 1/LdotH\r\nmediump vec4 layaBRDFLowLight (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaLight light)\r\n{\r\n    vec3 halfDir = safeNormalize (viewDir-light.dir);\r\n    mediump float nl = clamp(dot(normal, -light.dir),0.0,1.0);\r\n    float nh = clamp(dot(normal, halfDir),0.0,1.0);\r\n    float lh = clamp(dot(-light.dir, halfDir),0.0,1.0);\r\n\r\n    // GGX Distribution multiplied by combined approximation of Visibility and Fresnel\r\n    // See "Optimizing PBR for Mobile" from Siggraph 2015 moving mobile graphics course\r\n    // https://community.arm.com/events/1155\r\n    mediump float a = roughness;\r\n    float a2 = a*a;\r\n\r\n    float d = nh * nh * (a2 - 1.0) + 1.00001;\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// Tighter approximation for Gamma only rendering mode!\r\n\t\t// DVF = sqrt(DVF);\r\n\t\t// DVF = (a * sqrt(.25)) / (max(sqrt(0.1), lh)*sqrt(roughness + .5) * d);\r\n\t\tfloat specularTerm = a / (max(0.32, lh) * (1.5 + roughness) * d);\r\n\t// #else\r\n\t// \tfloat specularTerm = a2 / (max(0.1f, lh*lh) * (roughness + 0.5f) * (d * d) * 4);\r\n\t// #endif\r\n\r\n    // on mobiles (where half actually means something) denominator have risk of overflow\r\n    // clamp below was added specifically to "fix" that, but dx compiler (we convert bytecode to metal/gles)\r\n    // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...))\r\n\r\n\t//#if defined (SHADER_API_MOBILE)\r\n    specularTerm = specularTerm - 1e-4;\r\n\t//#endif\r\n\r\n\t// #else\r\n\t\t// // Legacy\r\n\t\t// half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness);\r\n\t\t// // Modified with approximate Visibility function that takes roughness into account\r\n\t\t// // Original ((n+1)*N.H^n) / (8*Pi * L.H^3) didn\'t take into account roughness\r\n\t\t// // and produced extremely bright specular at grazing angles\r\n\r\n\t\t// half invV = lh * lh * smoothness + perceptualRoughness * perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness);\r\n\t\t// half invF = lh;\r\n\r\n\t\t// half specularTerm = ((specularPower + 1) * pow (nh, specularPower)) / (8 * invV * invF + 1e-4h);\r\n\r\n\t\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\t// \tspecularTerm = sqrt(max(1e-4f, specularTerm));\r\n\t\t// #endif\r\n\t// #endif\r\n\r\n\t// #if defined (SHADER_API_MOBILE)\r\n\t\tspecularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles\r\n\t// #endif\r\n    \r\n    mediump vec3 color = (diffColor + specularTerm * specColor) * light.color * nl;\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n\r\nmediump vec4 layaBRDFLowGI (mediump vec3 diffColor, mediump vec3 specColor,mediump float oneMinusReflectivity,mediump float smoothness,float perceptualRoughness,float roughness,mediump float nv,vec3 normal,vec3 viewDir,LayaGI gi)\r\n{\r\n\t// surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(realRoughness^2+1)\r\n\r\n    // 1-0.28*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain [0;1]\r\n    // 1-x^3*(0.6-0.08*x)   approximation for 1/(x^4+1)\r\n\t// #ifdef LAYA_COLORSPACE_GAMMA\r\n\t\tmediump float surfaceReduction = 0.28;\r\n\t// #else\r\n\t\t// mediump float surfaceReduction = (0.6-0.08*perceptualRoughness);\r\n\t// #endif\r\n\r\n    surfaceReduction = 1.0 - roughness*perceptualRoughness*surfaceReduction;\r\n\r\n\tmediump float grazingTerm = clamp(smoothness + (1.0-oneMinusReflectivity),0.0,1.0);\r\n\tmediump vec3 color =gi.diffuse * diffColor+ surfaceReduction * gi.specular * fresnelLerpFast (specColor, vec3(grazingTerm), nv);\r\n\r\n    return vec4(color, 1.0);\r\n}\r\n// BRDF2-------------------------------------------------------------------------------------'),
                        G.addInclude("PBRCore.glsl", "struct FragmentCommonData{\r\n\tvec3 diffColor;\r\n\tvec3 specColor;\r\n\tfloat oneMinusReflectivity;\r\n\tfloat smoothness;\r\n\t//vec3 eyeVec;TODO:maybe can remove\r\n\t//float alpha;\r\n\t//vec3 reflUVW;\r\n};\r\n\r\n#ifndef SETUP_BRDF_INPUT\r\n    #define SETUP_BRDF_INPUT metallicSetup//default is metallicSetup,also can be other. \r\n#endif\r\n\r\nconst mediump vec4 dielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nmediump vec3 diffuseAndSpecularFromMetallic(mediump vec3 albedo,mediump float metallic, out mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\tspecColor = mix(dielectricSpecularColor.rgb, albedo, metallic);\r\n\toneMinusReflectivity= dielectricSpecularColor.a*(1.0-metallic);//diffuse proportion\r\n\treturn albedo * oneMinusReflectivity;\r\n}\r\n\r\nmediump float specularStrength(mediump vec3 specular)\r\n{\r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\n// Diffuse/Spec Energy conservation\r\nmediump vec3 energyConservationBetweenDiffuseAndSpecular (mediump vec3 albedo, mediump vec3 specColor, out mediump float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - specularStrength(specColor);\r\n    return albedo * (vec3(1.0) - specColor);\r\n}\r\n\r\n#ifdef TRANSPARENTBLEND\r\n\tmediump vec3 preMultiplyAlpha (mediump vec3 diffColor, mediump float alpha, mediump float oneMinusReflectivity,out mediump float modifiedAlpha)\r\n\t{\r\n\t\t// Transparency 'removes' from Diffuse component\r\n\t\tdiffColor *= alpha;\r\n\t\t// Reflectivity 'removes' from the rest of components, including Transparency\r\n\t\t// modifiedAlpha = 1.0-(1.0-alpha)*(1.0-reflectivity) = 1.0-(oneMinusReflectivity - alpha*oneMinusReflectivity) = 1.0-oneMinusReflectivity + alpha*oneMinusReflectivity\r\n\t\tmodifiedAlpha = 1.0 - oneMinusReflectivity + alpha*oneMinusReflectivity;\r\n\t\treturn diffColor;\r\n\t}\r\n#endif\r\n\r\nFragmentCommonData metallicSetup(vec2 uv)\r\n{\r\n\tmediump vec2 metallicGloss = getMetallicGloss(uv);\r\n\tmediump float metallic = metallicGloss.x;\r\n\tmediump float smoothness = metallicGloss.y; // this is 1 minus the square root of real roughness m.\r\n\tmediump float oneMinusReflectivity;\r\n\tmediump vec3 specColor;\r\n\tmediump vec3 diffColor = diffuseAndSpecularFromMetallic(albedo(uv), metallic,/*out*/specColor,/*out*/oneMinusReflectivity);\r\n\r\n\tFragmentCommonData o;\r\n\to.diffColor = diffColor;\r\n\to.specColor = specColor;\r\n\to.oneMinusReflectivity = oneMinusReflectivity;\r\n\to.smoothness = smoothness;\r\n\treturn o;\r\n}\r\n\r\nFragmentCommonData specularSetup(vec2 uv)\r\n{\r\n    mediump vec4 specGloss = specularGloss(uv);\r\n    mediump vec3 specColor = specGloss.rgb;\r\n    mediump float smoothness = specGloss.a;\r\n\r\n    mediump float oneMinusReflectivity;\r\n    mediump vec3 diffColor = energyConservationBetweenDiffuseAndSpecular (albedo(uv), specColor, /*out*/ oneMinusReflectivity);\r\n\r\n    FragmentCommonData o;\r\n    o.diffColor = diffColor;\r\n    o.specColor = specColor;\r\n    o.oneMinusReflectivity = oneMinusReflectivity;\r\n    o.smoothness = smoothness;\r\n    return o;\r\n}\r\n\r\nLayaGI fragmentGI(float smoothness,vec3 eyeVec,mediump float occlusion,mediump vec2 lightmapUV,vec3 worldnormal)\r\n{\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\r\n\t\tgiInput.lightmapUV=lightmapUV;\r\n\t#endif\r\n\r\n\tvec3 worldViewDir = -eyeVec;\r\n\tmediump vec4 uvwRoughness;\r\n\tuvwRoughness.rgb = reflect(worldViewDir, worldnormal);//reflectUVW\r\n\tuvwRoughness.a= smoothnessToPerceptualRoughness(smoothness);//perceptualRoughness\r\n\r\n\treturn layaGlobalIllumination(giInput,occlusion, worldnormal, uvwRoughness);\r\n}\r\n\r\n\r\nvec3 perPixelWorldNormal(vec2 uv,vec3 normal,vec3 binormal,vec3 tangent)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tmediump vec3 normalTangent=normalInTangentSpace(uv);\r\n\t\tvec3 normalWorld = normalize(tangent * normalTangent.x + binormal * normalTangent.y + normal * normalTangent.z);\r\n\t#else\r\n\t\tvec3 normalWorld = normalize(normal);\r\n\t#endif\r\n\t\treturn normalWorld;\r\n}\r\n\r\nvoid fragmentForward()\r\n{\r\n\tvec2 uv;\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef PARALLAXTEXTURE\r\n\t\t\tuv = parallax(v_Texcoord0,normalize(v_ViewDirForParallax));\r\n\t\t#else\r\n\t\t\tuv = v_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tmediump float alpha = getAlpha(uv);\r\n\t#ifdef ALPHATEST\r\n\t\tif(alpha<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\r\n\tFragmentCommonData o = SETUP_BRDF_INPUT(uv);\r\n\t\r\n\tvec3 binormal;\r\n\tvec3 tangent;\r\n\t#ifdef NORMALTEXTURE\r\n\t\ttangent = v_Tangent;\r\n\t\tbinormal = v_Binormal;\r\n\t#endif\r\n\r\n\tvec3 normal = v_Normal;\r\n\tvec3 normalWorld = perPixelWorldNormal(uv,normal,binormal,tangent);//In FS if the normal use mediump before normalize will cause precision prolem in mobile device.\r\n\tvec3 eyeVec = normalize(v_EyeVec);\r\n\tvec3 posworld = v_PositionWorld;\r\n\r\n\t#ifdef TRANSPARENTBLEND\r\n\t\to.diffColor=preMultiplyAlpha(o.diffColor,alpha,o.oneMinusReflectivity,/*out*/alpha);// shader relies on pre-multiply alpha-blend (srcBlend = One, dstBlend = OneMinusSrcAlpha)\r\n\t#endif\r\n\r\n\tmediump float occlusion = getOcclusion(uv);\r\n\tmediump vec2 lightMapUV;\r\n\t#ifdef LIGHTMAP\r\n\t\tlightMapUV=v_LightMapUV;\r\n\t#endif\r\n\tfloat perceptualRoughness = smoothnessToPerceptualRoughness(o.smoothness);\r\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat nv = abs(dot(normalWorld, eyeVec));\r\n\tLayaGI gi =fragmentGI(o.smoothness,eyeVec,occlusion,lightMapUV,normalWorld);\r\n\tvec4 color = LAYA_BRDF_GI(o.diffColor,o.specColor,o.oneMinusReflectivity,o.smoothness,perceptualRoughness,roughness,nv,normalWorld,eyeVec,gi);\r\n\t\r\n\tfloat shadowAttenuation = 1.0;\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tshadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t#endif\r\n\t\t\tLayaLight dirLight = layaDirectionLightToLight(u_DirectionLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,u_PointLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t    LayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,u_SpotLight,shadowAttenuation);\r\n\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t#endif\r\n\t#else\r\n\t \t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tshadowAttenuation *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaLight dirLight = layaDirectionLightToLight(directionLight,shadowAttenuation);\r\n\t\t\t \tcolor+=LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,dirLight);\r\n\t\t\t}\r\n\t \t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight poiLight = layaPointLightToLight(posworld,normalWorld,pointLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,poiLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaLight spoLight = layaSpotLightToLight(posworld,normalWorld,spotLight,shadowAttenuation);\r\n\t\t\t\t\tcolor+= LAYA_BRDF_LIGHT(o.diffColor,o.specColor,o.oneMinusReflectivity,perceptualRoughness,roughness,nv,normalWorld,eyeVec,spoLight);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t #endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tcolor.rgb += emission(uv);\r\n\t#endif\r\n\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tcolor.rgb=mix(color.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n\t\r\n\tgl_FragColor=vec4(color.rgb,alpha);\r\n}\r\n\r\n\r\n"),
                        G.addInclude("PBRVertex.glsl", "vec2 transformLightMapUV(in vec2 texcoord,in vec4 lightmapScaleOffset)\r\n{\r\n\tvec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*lightmapScaleOffset.xy+lightmapScaleOffset.zw;\r\n\tlightMapUV.y=1.0-lightMapUV.y;\r\n\treturn lightMapUV; \r\n}\r\n\r\nvoid vertexForward()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tv_PositionWorld=(worldMat*position).xyz;\r\n\r\n\t#if defined(ALBEDOTEXTURE)||defined(METALLICGLOSSTEXTURE)||defined(NORMALTEXTURE)||defined(EMISSIONTEXTURE)||defined(OCCLUSIONTEXTURE)||defined(PARALLAXTEXTURE)\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tv_EyeVec =u_CameraPos-v_PositionWorld;//will normalize per-pixel\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\tvec2 texcoord;\r\n\t\t#ifdef UV1\r\n\t\t\ttexcoord=a_Texcoord1;\r\n\t\t#else\r\n\t\t\ttexcoord=a_Texcoord0;\r\n\t\t#endif\r\n\t\tv_LightMapUV=transformLightMapUV(texcoord,u_LightmapScaleOffset);\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif\r\n\r\n\tv_Normal=normalize(a_Normal*worldInvMat);//if no normalize will cause precision problem.\r\n\r\n\t#ifdef NORMALTEXTURE\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tvec3 binormal = cross(a_Normal, a_Tangent0.xyz)*a_Tangent0.w;\r\n\t\tmat3 objectTBN = mat3(a_Tangent0.xyz, binormal, a_Normal);\r\n\t\tv_ViewDirForParallax=(worldInvMat*u_CameraPos-position.xyz)*objectTBN;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t#endif\r\n}");
                    var e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Color: Ne.MESH_COLOR0,
                            a_Normal: Ne.MESH_NORMAL0,
                            a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
                            a_Texcoord1: Ne.MESH_TEXTURECOORDINATE1,
                            a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
                            a_BoneIndices: Ne.MESH_BLENDINDICES0,
                            a_Tangent0: Ne.MESH_TANGENT0,
                            a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0,
                            a_WorldMat: Ne.MESH_WORLDMATRIX_ROW0
                        },
                        t = {
                            u_Bones: G.PERIOD_CUSTOM,
                            u_DiffuseTexture: G.PERIOD_MATERIAL,
                            u_SpecularTexture: G.PERIOD_MATERIAL,
                            u_NormalTexture: G.PERIOD_MATERIAL,
                            u_AlphaTestValue: G.PERIOD_MATERIAL,
                            u_DiffuseColor: G.PERIOD_MATERIAL,
                            u_MaterialSpecular: G.PERIOD_MATERIAL,
                            u_Shininess: G.PERIOD_MATERIAL,
                            u_TilingOffset: G.PERIOD_MATERIAL,
                            u_WorldMat: G.PERIOD_SPRITE,
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_LightmapScaleOffset: G.PERIOD_SPRITE,
                            u_LightMap: G.PERIOD_SPRITE,
                            u_LightMapDirection: G.PERIOD_SPRITE,
                            u_CameraPos: G.PERIOD_CAMERA,
                            u_Viewport: G.PERIOD_CAMERA,
                            u_ProjectionParams: G.PERIOD_CAMERA,
                            u_View: G.PERIOD_CAMERA,
                            u_ViewProjection: G.PERIOD_CAMERA,
                            u_ReflectTexture: G.PERIOD_SCENE,
                            u_ReflectIntensity: G.PERIOD_SCENE,
                            u_FogStart: G.PERIOD_SCENE,
                            u_FogRange: G.PERIOD_SCENE,
                            u_FogColor: G.PERIOD_SCENE,
                            u_DirationLightCount: G.PERIOD_SCENE,
                            u_LightBuffer: G.PERIOD_SCENE,
                            u_LightClusterBuffer: G.PERIOD_SCENE,
                            u_AmbientColor: G.PERIOD_SCENE,
                            u_ShadowBias: G.PERIOD_SCENE,
                            u_ShadowLightDirection: G.PERIOD_SCENE,
                            u_ShadowMap: G.PERIOD_SCENE,
                            u_ShadowParams: G.PERIOD_SCENE,
                            u_ShadowSplitSpheres: G.PERIOD_SCENE,
                            u_ShadowMatrices: G.PERIOD_SCENE,
                            u_ShadowMapSize: G.PERIOD_SCENE,
                            u_AmbientSHAr: G.PERIOD_SCENE,
                            u_AmbientSHAg: G.PERIOD_SCENE,
                            u_AmbientSHAb: G.PERIOD_SCENE,
                            u_AmbientSHBr: G.PERIOD_SCENE,
                            u_AmbientSHBg: G.PERIOD_SCENE,
                            u_AmbientSHBb: G.PERIOD_SCENE,
                            u_AmbientSHC: G.PERIOD_SCENE,
                            "u_DirectionLight.color": G.PERIOD_SCENE,
                            "u_DirectionLight.direction": G.PERIOD_SCENE,
                            "u_PointLight.position": G.PERIOD_SCENE,
                            "u_PointLight.range": G.PERIOD_SCENE,
                            "u_PointLight.color": G.PERIOD_SCENE,
                            "u_SpotLight.position": G.PERIOD_SCENE,
                            "u_SpotLight.direction": G.PERIOD_SCENE,
                            "u_SpotLight.range": G.PERIOD_SCENE,
                            "u_SpotLight.spot": G.PERIOD_SCENE,
                            "u_SpotLight.color": G.PERIOD_SCENE
                        },
                        r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        },
                        n = G.add("BLINNPHONG", null, null, !0),
                        i = new $t(e, t);
                    n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n#include "Shadow.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nattribute vec3 a_Normal;\r\nvarying vec3 v_Normal; \r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\tmat4 worldMat;\r\n\t#ifdef GPU_INSTANCE\r\n\t\tworldMat = a_WorldMat;\r\n\t#else\r\n\t\tworldMat = u_WorldMat;\r\n\t#endif\r\n\r\n\tmat3 worldInvMat;\r\n\t#ifdef BONE\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat*skinTransform));\r\n\t#else\r\n\t\tworldInvMat=INVERSE_MAT(mat3(worldMat));\r\n\t#endif  \r\n\tv_Normal=normalize(a_Normal*worldInvMat);\r\n\t#if defined(NORMALMAP)\r\n\t\tv_Tangent=normalize(a_Tangent0.xyz*worldInvMat);\r\n\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\t\tvec3 positionWS=(worldMat*position).xyz;\r\n\t\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tv_ViewDir = u_CameraPos-positionWS;\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\t\t\tv_PositionWorld = positionWS;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef UV1\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#else\r\n\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t#endif \r\n\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\t\tv_ShadowCoord =getShadowCoord(vec4(positionWS,1.0));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n#include "Shadow.glsl"\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\nvarying vec3 v_Normal;\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NORMALMAP \r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||(defined(CALCULATE_SHADOWS)&&defined(SHADOW_CASCADE))\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n\r\n#include "GlobalIllumination.glsl";//"GlobalIllumination.glsl use uniform should at front of this\r\n\r\n#if defined(CALCULATE_SHADOWS)&&!defined(SHADOW_CASCADE)\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec3 normal;//light and SH maybe use normal\r\n\t#if defined(NORMALMAP)\r\n\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t#else\r\n\t\tnormal = normalize(v_Normal);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\r\n\tLayaGIInput giInput;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tgiInput.lightmapUV=v_LightMapUV;\r\n\t#endif\r\n\tvec3 globalDiffuse=layaGIBase(giInput,1.0,normal);\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t#else\r\n\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t#endif\r\n\t\t\t\tfloat shadowAttenuation=sampleShadowmap(shadowCoord);\r\n\t\t\t\tdif *= shadowAttenuation;\r\n\t\t\t\tspe *= shadowAttenuation;\r\n\t\t\t#endif\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\t#ifdef CALCULATE_SHADOWS\r\n\t\t\t\t\tif(i == 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t#ifdef SHADOW_CASCADE\r\n\t\t\t\t\t\t\tvec4 shadowCoord = getShadowCoord(vec4(v_PositionWorld,1.0));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tvec4 shadowCoord = v_ShadowCoord;\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\tdirectionLight.color *= sampleShadowmap(shadowCoord);\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tgl_FragColor.rgb+=specular;\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\n', r, "Forward");
                    i.addShaderPass('#include "ShadowCasterVS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionCS =  shadowCasterVertex();\r\n\tgl_Position=remapGLPositionZ(positionCS);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n\tprecision highp int;\r\n#else\r\n\tprecision mediump float;\r\n\tprecision mediump int;\r\n#endif\r\n\r\n#include "ShadowCasterFS.glsl"\r\n\r\nvoid main()\r\n{\r\n\tgl_FragColor=shadowCasterFragment();\r\n}', r, "ShadowCaster");
                    e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Color: Ne.MESH_COLOR0
                        }, t = {
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_Color: G.PERIOD_MATERIAL
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("LineShader"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n", r),
                        e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Color: Ne.MESH_COLOR0,
                            a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
                            a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
                            a_BoneIndices: Ne.MESH_BLENDINDICES0,
                            a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0
                        }, t = {
                            u_Bones: G.PERIOD_CUSTOM,
                            u_AlbedoTexture: G.PERIOD_MATERIAL,
                            u_AlbedoColor: G.PERIOD_MATERIAL,
                            u_TilingOffset: G.PERIOD_MATERIAL,
                            u_AlphaTestValue: G.PERIOD_MATERIAL,
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_FogStart: G.PERIOD_SCENE,
                            u_FogRange: G.PERIOD_SCENE,
                            u_FogColor: G.PERIOD_SCENE
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("Unlit", null, null, !0), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n", r),
                        e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0,
                            a_BoneWeights: Ne.MESH_BLENDWEIGHT0,
                            a_BoneIndices: Ne.MESH_BLENDINDICES0,
                            a_MvpMatrix: Ne.MESH_MVPMATRIX_ROW0
                        }, t = {
                            u_Bones: G.PERIOD_CUSTOM,
                            u_AlbedoTexture: G.PERIOD_MATERIAL,
                            u_AlbedoColor: G.PERIOD_MATERIAL,
                            u_TilingOffset: G.PERIOD_MATERIAL,
                            u_AlphaTestValue: G.PERIOD_MATERIAL,
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_FogStart: G.PERIOD_SCENE,
                            u_FogRange: G.PERIOD_SCENE,
                            u_FogColor: G.PERIOD_SCENE
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("Effect", null, null, !0), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n", r),
                        e = {
                            a_CornerTextureCoordinate: Fr.PARTICLE_CORNERTEXTURECOORDINATE0,
                            a_MeshPosition: Fr.PARTICLE_POSITION0,
                            a_MeshColor: Fr.PARTICLE_COLOR0,
                            a_MeshTextureCoordinate: Fr.PARTICLE_TEXTURECOORDINATE0,
                            a_ShapePositionStartLifeTime: Fr.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                            a_DirectionTime: Fr.PARTICLE_DIRECTIONTIME,
                            a_StartColor: Fr.PARTICLE_STARTCOLOR0,
                            a_EndColor: Fr.PARTICLE_ENDCOLOR0,
                            a_StartSize: Fr.PARTICLE_STARTSIZE,
                            a_StartRotation0: Fr.PARTICLE_STARTROTATION,
                            a_StartSpeed: Fr.PARTICLE_STARTSPEED,
                            a_Random0: Fr.PARTICLE_RANDOM0,
                            a_Random1: Fr.PARTICLE_RANDOM1,
                            a_SimulationWorldPostion: Fr.PARTICLE_SIMULATIONWORLDPOSTION,
                            a_SimulationWorldRotation: Fr.PARTICLE_SIMULATIONWORLDROTATION
                        }, t = {
                            u_Tintcolor: G.PERIOD_MATERIAL,
                            u_TilingOffset: G.PERIOD_MATERIAL,
                            u_texture: G.PERIOD_MATERIAL,
                            u_WorldPosition: G.PERIOD_SPRITE,
                            u_WorldRotation: G.PERIOD_SPRITE,
                            u_PositionScale: G.PERIOD_SPRITE,
                            u_SizeScale: G.PERIOD_SPRITE,
                            u_ScalingMode: G.PERIOD_SPRITE,
                            u_Gravity: G.PERIOD_SPRITE,
                            u_ThreeDStartRotation: G.PERIOD_SPRITE,
                            u_StretchedBillboardLengthScale: G.PERIOD_SPRITE,
                            u_StretchedBillboardSpeedScale: G.PERIOD_SPRITE,
                            u_SimulationSpace: G.PERIOD_SPRITE,
                            u_CurrentTime: G.PERIOD_SPRITE,
                            u_ColorOverLifeGradientAlphas: G.PERIOD_SPRITE,
                            u_ColorOverLifeGradientColors: G.PERIOD_SPRITE,
                            u_MaxColorOverLifeGradientAlphas: G.PERIOD_SPRITE,
                            u_MaxColorOverLifeGradientColors: G.PERIOD_SPRITE,
                            u_VOLVelocityConst: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientX: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientY: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientZ: G.PERIOD_SPRITE,
                            u_VOLVelocityConstMax: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientMaxX: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientMaxY: G.PERIOD_SPRITE,
                            u_VOLVelocityGradientMaxZ: G.PERIOD_SPRITE,
                            u_VOLSpaceType: G.PERIOD_SPRITE,
                            u_SOLSizeGradient: G.PERIOD_SPRITE,
                            u_SOLSizeGradientX: G.PERIOD_SPRITE,
                            u_SOLSizeGradientY: G.PERIOD_SPRITE,
                            u_SOLSizeGradientZ: G.PERIOD_SPRITE,
                            u_SOLSizeGradientMax: G.PERIOD_SPRITE,
                            u_SOLSizeGradientMaxX: G.PERIOD_SPRITE,
                            u_SOLSizeGradientMaxY: G.PERIOD_SPRITE,
                            u_SOLSizeGradientMaxZ: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityConst: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityConstSeprarate: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradient: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientX: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientY: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientZ: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityConstMax: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityConstMaxSeprarate: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientMax: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientMaxX: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientMaxY: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientMaxZ: G.PERIOD_SPRITE,
                            u_ROLAngularVelocityGradientMaxW: G.PERIOD_SPRITE,
                            u_TSACycles: G.PERIOD_SPRITE,
                            u_TSASubUVLength: G.PERIOD_SPRITE,
                            u_TSAGradientUVs: G.PERIOD_SPRITE,
                            u_TSAMaxGradientUVs: G.PERIOD_SPRITE,
                            u_CameraPos: G.PERIOD_CAMERA,
                            u_CameraDirection: G.PERIOD_CAMERA,
                            u_CameraUp: G.PERIOD_CAMERA,
                            u_View: G.PERIOD_CAMERA,
                            u_Projection: G.PERIOD_CAMERA,
                            u_FogStart: G.PERIOD_SCENE,
                            u_FogRange: G.PERIOD_SCENE,
                            u_FogColor: G.PERIOD_SCENE
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("PARTICLESHURIKEN"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0)\r\n\t{ \r\n\t\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t\t#endif \r\n\t\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\t\r\n\t\tvec4 worldRotation;\r\n\t\tif(u_SimulationSpace==0)\r\n\t\t\tworldRotation=a_SimulationWorldRotation;\r\n\t\telse\r\n\t\t\tworldRotation=u_WorldRotation;\r\n\t\t\r\n\t\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n\t\r\n\t\r\n\t\t#ifdef SPHERHBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\tvec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef STRETCHEDBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tvec3 velocity;\r\n\t\t\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\t\t\tif(u_VOLSpaceType==0)\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t\t\t\telse\r\n\t\t\t\tvelocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n\t\t\t#else\r\n\t\t\t\tvelocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n\t\t\t#endif\t\r\n\t\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\t\tvec3 direction = normalize(center-u_CameraPos);\r\n\t\t\tvec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\t\r\n\t\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\t\r\n\t\t\tvec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\t\r\n\t\t\tconst mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t\t\tcorner=rotaionZHalfPI*corner;\r\n\t\t\tcorner.y=corner.y-abs(corner.y);\r\n\t\t\t\r\n\t\t\tfloat speed=length(velocity);//TODO:\r\n\t\t\tcenter +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef HORIZONTALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t\t\tconst vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef VERTICALBILLBOARD\r\n\t\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\t\t\tconst vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n\t\t\tvec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\t\r\n\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\tfloat c = cos(rot);\r\n\t\t\tfloat s = sin(rot);\r\n\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\tcorner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\tcenter +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tvec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse{\r\n\t\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t\t#endif\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t#endif\r\n\t\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t\t#endif\t\t\r\n\t\t\t\t}\r\n\t\t\t#else\r\n\t\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\tv_MeshColor=a_MeshColor;\r\n\t\t#endif\r\n\t\r\n\t\tgl_Position=u_Projection*u_View*vec4(center,1.0);\r\n\t\tv_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t\t#ifdef DIFFUSEMAP\r\n\t\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t#ifdef RENDERMODE_MESH\r\n\t\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t\t#endif\r\n\t\t\t\r\n\t\t\t#ifdef TILINGOFFSET\r\n\t\t\t\tv_TextureCoordinate=TransformUV(v_TextureCoordinate,u_TilingOffset);\r\n\t\t\t#endif\r\n\t\t#endif\r\n   \t}\r\n   \telse\r\n\t{\r\n\t\tgl_Position=vec4(2.0,2.0,2.0,1.0);//Discard use out of X(-1,1),Y(-1,1),Z(0,1)\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}", r),
                        e = {
                            a_Position: Ne.MESH_POSITION0
                        }, t = {
                            u_TintColor: G.PERIOD_MATERIAL,
                            u_Exposure: G.PERIOD_MATERIAL,
                            u_Rotation: G.PERIOD_MATERIAL,
                            u_CubeTexture: G.PERIOD_MATERIAL,
                            u_ViewProjection: G.PERIOD_CAMERA
                        }, n = G.add("SkyBox"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n"),
                        e = {
                            a_Position: Ne.MESH_POSITION0
                        }, t = {
                            u_SunSize: G.PERIOD_MATERIAL,
                            u_SunSizeConvergence: G.PERIOD_MATERIAL,
                            u_AtmosphereThickness: G.PERIOD_MATERIAL,
                            u_SkyTint: G.PERIOD_MATERIAL,
                            u_GroundTint: G.PERIOD_MATERIAL,
                            u_Exposure: G.PERIOD_MATERIAL,
                            u_ViewProjection: G.PERIOD_CAMERA,
                            "u_SunLight.direction": G.PERIOD_SCENE,
                            "u_SunLight.color": G.PERIOD_SCENE
                        }, n = G.add("SkyBoxProcedural"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_SunLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = u_ViewProjection*a_Position;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_SunLight.direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_SunLight.direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_SunLight.direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_SunLight.color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_SunLight.color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n", '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_SunLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_SunLight.direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n'),
                        e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Normal: Ne.MESH_NORMAL0,
                            a_Texcoord0: Ne.MESH_TEXTURECOORDINATE0
                        }, t = {
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_WorldMat: G.PERIOD_SPRITE,
                            u_CameraPos: G.PERIOD_CAMERA,
                            u_Viewport: G.PERIOD_CAMERA,
                            u_ProjectionParams: G.PERIOD_CAMERA,
                            u_View: G.PERIOD_CAMERA,
                            u_LightmapScaleOffset: G.PERIOD_SPRITE,
                            u_LightMap: G.PERIOD_SPRITE,
                            u_SplatAlphaTexture: G.PERIOD_MATERIAL,
                            u_DiffuseTexture1: G.PERIOD_MATERIAL,
                            u_DiffuseTexture2: G.PERIOD_MATERIAL,
                            u_DiffuseTexture3: G.PERIOD_MATERIAL,
                            u_DiffuseTexture4: G.PERIOD_MATERIAL,
                            u_DiffuseTexture5: G.PERIOD_MATERIAL,
                            u_DiffuseScaleOffset1: G.PERIOD_MATERIAL,
                            u_DiffuseScaleOffset2: G.PERIOD_MATERIAL,
                            u_DiffuseScaleOffset3: G.PERIOD_MATERIAL,
                            u_DiffuseScaleOffset4: G.PERIOD_MATERIAL,
                            u_DiffuseScaleOffset5: G.PERIOD_MATERIAL,
                            u_FogStart: G.PERIOD_SCENE,
                            u_FogRange: G.PERIOD_SCENE,
                            u_FogColor: G.PERIOD_SCENE,
                            u_DirationLightCount: G.PERIOD_SCENE,
                            u_LightBuffer: G.PERIOD_SCENE,
                            u_LightClusterBuffer: G.PERIOD_SCENE,
                            u_AmbientColor: G.PERIOD_SCENE,
                            u_ShadowMap: G.PERIOD_SCENE,
                            u_shadowMap2: G.PERIOD_SCENE,
                            u_shadowMap3: G.PERIOD_SCENE,
                            u_ShadowSplitSpheres: G.PERIOD_SCENE,
                            u_ShadowMatrices: G.PERIOD_SCENE,
                            u_ShadowMapSize: G.PERIOD_SCENE,
                            "u_DirectionLight.color": G.PERIOD_SCENE,
                            "u_DirectionLight.direction": G.PERIOD_SCENE,
                            "u_PointLight.position": G.PERIOD_SCENE,
                            "u_PointLight.range": G.PERIOD_SCENE,
                            "u_PointLight.color": G.PERIOD_SCENE,
                            "u_SpotLight.position": G.PERIOD_SCENE,
                            "u_SpotLight.direction": G.PERIOD_SCENE,
                            "u_SpotLight.range": G.PERIOD_SCENE,
                            "u_SpotLight.spot": G.PERIOD_SCENE,
                            "u_SpotLight.color": G.PERIOD_SCENE
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("ExtendTerrain"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(CALCULATE_SHADOWS)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tv_ShadowCoord = getShadowCoord(vec4(v_PositionWorld));\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tuniform DirectionLight u_DirectionLight;\r\n\t\t#endif\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tuniform PointLight u_PointLight;\r\n\t\t#endif\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tuniform SpotLight u_SpotLight;\r\n\t\t#endif\r\n\t#else\r\n\t\tuniform mat4 u_View;\r\n\t\tuniform vec4 u_ProjectionParams;\r\n\t\tuniform vec4 u_Viewport;\r\n\t\tuniform int u_DirationLightCount;\r\n\t\tuniform sampler2D u_LightBuffer;\r\n\t\tuniform sampler2D u_LightClusterBuffer;\r\n\t#endif\r\n#endif\r\n\r\n#include "Shadow.glsl"\r\n#ifdef CALCULATE_SHADOWS\r\n\tvarying vec4 v_ShadowCoord;\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal = v_Normal;\r\n\t\tvec3 dif, spe;\r\n\t#endif\r\n\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\t\tvec3 toEye;\r\n\t\t#ifdef FOG\r\n\t\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\t\tfloat toEyeLength=length(toEye);\r\n\t\t\ttoEye/=toEyeLength;\r\n\t\t#else\r\n\t\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LEGACYSINGLELIGHTING\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,u_DirectionLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t\r\n\t\t#ifdef POINTLIGHT\r\n\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_PointLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\r\n\t\t#ifdef SPOTLIGHT\r\n\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,u_SpotLight,dif,spe);\r\n\t\t\tdiffuse+=dif;\r\n\t\t\tspecular+=spe;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef DIRECTIONLIGHT\r\n\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t{\r\n\t\t\t\tif(i >= u_DirationLightCount)\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tDirectionLight directionLight = getDirectionLight(u_LightBuffer,i);\r\n\t\t\t\tLayaAirBlinnPhongDiectionLight(vec3(0.0),1.0,normal,vec3(1.0),toEye,directionLight,dif,spe);\r\n\t\t\t\tdiffuse+=dif;\r\n\t\t\t\tspecular+=spe;\r\n\t\t\t}\r\n\t\t#endif\r\n\t\t#if defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t\tivec4 clusterInfo =getClusterInfo(u_LightClusterBuffer,u_View,u_Viewport, v_PositionWorld,gl_FragCoord,u_ProjectionParams);\r\n\t\t\t#ifdef POINTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.x)//PointLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tPointLight pointLight = getPointLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye,pointLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t\t#ifdef SPOTLIGHT\r\n\t\t\t\tfor (int i = 0; i < MAX_LIGHT_COUNT; i++) \r\n\t\t\t\t{\r\n\t\t\t\t\tif(i >= clusterInfo.y)//SpotLightCount\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tSpotLight spotLight = getSpotLight(u_LightBuffer,u_LightClusterBuffer,clusterInfo,i);\r\n\t\t\t\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,vec3(0.0),1.0,normal,vec3(1.0),toEye\t,spotLight,dif,spe);\r\n\t\t\t\t\tdiffuse+=dif;\r\n\t\t\t\t\tspecular+=spe;\r\n\t\t\t\t}\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += decodeHDR(texture2D(u_LightMap, v_LightMapUV),5.0);\r\n#endif\r\n\r\n#ifdef CALCULATE_SHADOWS\r\n\tfloat shadowValue = shadowValue = sampleShadowmap(v_ShadowCoord);\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef CALCULATE_SHADOWS\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n', r),
                        e = {
                            a_Position: $r.TRAIL_POSITION0,
                            a_OffsetVector: $r.TRAIL_OFFSETVECTOR,
                            a_Texcoord0X: $r.TRAIL_TEXTURECOORDINATE0X,
                            a_Texcoord0Y: $r.TRAIL_TEXTURECOORDINATE0Y,
                            a_BirthTime: $r.TRAIL_TIME0,
                            a_Color: $r.TRAIL_COLOR
                        }, t = {
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_View: G.PERIOD_CAMERA,
                            u_Projection: G.PERIOD_CAMERA,
                            u_TilingOffset: G.PERIOD_MATERIAL,
                            u_MainTexture: G.PERIOD_MATERIAL,
                            u_MainColor: G.PERIOD_MATERIAL,
                            u_CurTime: G.PERIOD_SPRITE,
                            u_LifeTime: G.PERIOD_SPRITE,
                            u_WidthCurve: G.PERIOD_SPRITE,
                            u_WidthCurveKeyLength: G.PERIOD_SPRITE,
                            u_GradientColorkey: G.PERIOD_SPRITE,
                            u_GradientAlphakey: G.PERIOD_SPRITE
                        }, r = {
                            s_Cull: G.RENDER_STATE_CULL,
                            s_Blend: G.RENDER_STATE_BLEND,
                            s_BlendSrc: G.RENDER_STATE_BLEND_SRC,
                            s_BlendDst: G.RENDER_STATE_BLEND_DST,
                            s_DepthTest: G.RENDER_STATE_DEPTH_TEST,
                            s_DepthWrite: G.RENDER_STATE_DEPTH_WRITE
                        }, n = G.add("Trail"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ", r),
                        e = {
                            a_Position: Ne.MESH_POSITION0,
                            a_Normal: Ne.MESH_NORMAL0,
                            a_Tangent0: Ne.MESH_TANGENT0
                        }, t = {
                            u_MvpMatrix: G.PERIOD_SPRITE,
                            u_WorldMat: G.PERIOD_SPRITE,
                            u_CameraPos: G.PERIOD_CAMERA,
                            u_Time: G.PERIOD_SCENE,
                            u_MainTexture: G.PERIOD_MATERIAL,
                            u_NormalTexture: G.PERIOD_MATERIAL,
                            u_HorizonColor: G.PERIOD_MATERIAL,
                            u_WaveScale: G.PERIOD_MATERIAL,
                            u_WaveSpeed: G.PERIOD_MATERIAL
                        }, n = G.add("WaterPrimary"), i = new $t(e, t), n.addSubShader(i), i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n\r\n#include "Lighting.glsl"\r\n\r\n\r\n\r\nvec3 NormalSampleToWorldSpace(vec4 normalMapSample) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 bumpedNormal = normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\r\n\tvec3 normal1 = NormalSampleToWorldSpace(bumpColor1);\r\n\tvec3 normal2 = NormalSampleToWorldSpace(bumpColor2);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n\r\n'),
                        e = {
                            a_PositionTexcoord: Ne.MESH_POSITION0
                        }, t = {
                            u_MainTex: G.PERIOD_MATERIAL,
                            u_OffsetScale: G.PERIOD_MATERIAL
                        }, n = G.add("BlitScreen"), i = new $t(e, t), n.addSubShader(i);
                    var a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nuniform vec4 u_OffsetScale;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\t\r\n\tgl_Position = vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0, 0.0, 1.0);\t\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n").renderState;
                    a.depthTest = Z.DEPTHTEST_ALWAYS, a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE,
                        e = {
                            a_PositionTexcoord: Ne.MESH_POSITION0
                        }, t = {
                            u_MainTex: G.PERIOD_MATERIAL,
                            u_BloomTex: G.PERIOD_MATERIAL,
                            u_AutoExposureTex: G.PERIOD_MATERIAL,
                            u_MainTex_TexelSize: G.PERIOD_MATERIAL,
                            u_SampleScale: G.PERIOD_MATERIAL,
                            u_Threshold: G.PERIOD_MATERIAL,
                            u_Params: G.PERIOD_MATERIAL
                        }, n = G.add("PostProcessBloom"), i = new $t(e, t), n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, i = new $t(e, t),
                        n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, i = new $t(e, t),
                        n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, i = new $t(e, t),
                        n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, i = new $t(e, t),
                        n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, i = new $t(e, t),
                        n.addSubShader(i), (a = i.addShaderPass(Tn, '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE, e = {
                            a_PositionTexcoord: Ne.MESH_POSITION0
                        }, t = {
                            u_MainTex: G.PERIOD_MATERIAL,
                            u_BloomTex: G.PERIOD_MATERIAL,
                            u_AutoExposureTex: G.PERIOD_MATERIAL,
                            u_Bloom_DirtTileOffset: G.PERIOD_MATERIAL,
                            u_Bloom_DirtTex: G.PERIOD_MATERIAL,
                            u_BloomTex_TexelSize: G.PERIOD_MATERIAL,
                            u_Bloom_Settings: G.PERIOD_MATERIAL,
                            u_Bloom_Color: G.PERIOD_MATERIAL
                        }, n = G.add("PostProcessComposite"), i = new $t(e, t), n.addSubShader(i), (a = i.addShaderPass('#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}').renderState).depthTest = Z.DEPTHTEST_ALWAYS,
                        a.depthWrite = !1, a.cull = Z.CULL_NONE, a.blend = Z.BLEND_DISABLE;
                }
            }]), ShaderInit3D;
        }(),
        vn = function(t) {
            function DirectionLight() {
                var t;
                return _classCallCheck(this, DirectionLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(DirectionLight).call(this)))._direction = new o(),
                    t._shadowCascadesMode = e.ShadowCascadesMode.NoCascades, t._shadowTwoCascadeSplits = 1 / 3,
                    t._shadowFourCascadeSplits = new o(1 / 15, .2, 7 / 15), t._lightType = e.LightType.Directional,
                    t;
            }
            return _inherits(DirectionLight, Ke), _createClass(DirectionLight, [{
                key: "_addToLightQueue",
                value: function() {
                    this._scene._directionLights.add(this);
                }
            }, {
                key: "_removeFromLightQueue",
                value: function() {
                    this._scene._directionLights.remove(this);
                }
            }, {
                key: "shadowCascadesMode",
                get: function() {
                    return this._shadowCascadesMode;
                },
                set: function(e) {
                    this._shadowCascadesMode = e;
                }
            }, {
                key: "shadowTwoCascadeSplits",
                get: function() {
                    return this._shadowTwoCascadeSplits;
                },
                set: function(e) {
                    this._shadowTwoCascadeSplits = e;
                }
            }, {
                key: "shadowFourCascadeSplits",
                get: function() {
                    return this._shadowFourCascadeSplits;
                },
                set: function(e) {
                    if (e.x > e.y || e.y > e.z || e.z > 1) throw "DiretionLight:Invalid value.";
                    e.cloneTo(this._shadowFourCascadeSplits);
                }
            }]), DirectionLight;
        }(),
        En = function(t) {
            function PointLight() {
                var t;
                return _classCallCheck(this, PointLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(PointLight).call(this)))._range = 6,
                    t._lightType = e.LightType.Point, t;
            }
            return _inherits(PointLight, Ke), _createClass(PointLight, [{
                key: "range",
                get: function() {
                    return this._range;
                },
                set: function(e) {
                    this._range = e;
                }
            }]), _createClass(PointLight, [{
                key: "_addToLightQueue",
                value: function() {
                    this._scene._pointLights.add(this);
                }
            }, {
                key: "_removeFromLightQueue",
                value: function() {
                    this._scene._pointLights.remove(this);
                }
            }, {
                key: "_parse",
                value: function(e, t) {
                    _get(_getPrototypeOf(PointLight.prototype), "_parse", this).call(this, e, t), this.range = e.range;
                }
            }]), PointLight;
        }(),
        gn = function(t) {
            function SpotLight() {
                var t;
                return _classCallCheck(this, SpotLight), (t = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this)))._spotAngle = 30,
                    t._range = 10, t._direction = new o(), t._lightType = e.LightType.Spot, t;
            }
            return _inherits(SpotLight, Ke), _createClass(SpotLight, [{
                key: "spotAngle",
                get: function() {
                    return this._spotAngle;
                },
                set: function(e) {
                    this._spotAngle = Math.max(Math.min(e, 179), 0);
                }
            }, {
                key: "range",
                get: function() {
                    return this._range;
                },
                set: function(e) {
                    this._range = e;
                }
            }]), _createClass(SpotLight, [{
                key: "_addToLightQueue",
                value: function() {
                    this._scene._spotLights.add(this);
                }
            }, {
                key: "_removeFromLightQueue",
                value: function() {
                    this._scene._spotLights.remove(this);
                }
            }, {
                key: "_parse",
                value: function(e, t) {
                    _get(_getPrototypeOf(SpotLight.prototype), "_parse", this).call(this, e, t), this.range = e.range,
                        this.spotAngle = e.spotAngle;
                }
            }]), SpotLight;
        }(),
        yn = function() {
            function Scene3DUtils() {
                _classCallCheck(this, Scene3DUtils);
            }
            return _createClass(Scene3DUtils, null, [{
                key: "_createSprite3DInstance",
                value: function(e, t, r) {
                    var n;
                    switch (e.type) {
                        case "Scene3D":
                            n = new qt();
                            break;

                        case "Sprite3D":
                            n = new le();
                            break;

                        case "MeshSprite3D":
                            n = new _r(), r && e.props.isStatic && r.push(n);
                            break;

                        case "SkinnedMeshSprite3D":
                            n = new Zr();
                            break;

                        case "ShuriKenParticle3D":
                            n = new Yr();
                            break;

                        case "Camera":
                            n = new et();
                            break;

                        case "DirectionLight":
                            n = new vn();
                            break;

                        case "PointLight":
                            n = new En();
                            break;

                        case "SpotLight":
                            n = new gn();
                            break;

                        case "TrailSprite3D":
                            n = new nn();
                            break;

                        default:
                            throw new Error("Utils3D:unidentified class type in (.lh) file.");
                    }
                    var i = e.child;
                    if (i)
                        for (var a = 0, o = i.length; a < o; a++) {
                            var s = Scene3DUtils._createSprite3DInstance(i[a], t, r);
                            n.addChild(s);
                        }
                    return t[e.instanceID] = n, n;
                }
            }, {
                key: "_createComponentInstance",
                value: function(e, r) {
                    var n = r[e.instanceID];
                    n._parse(e.props, r);
                    var i = e.child;
                    if (i)
                        for (var a = 0, o = i.length; a < o; a++) Scene3DUtils._createComponentInstance(i[a], r);
                    var s = e.components;
                    if (s)
                        for (var l = 0, u = s.length; l < u; l++) {
                            var c = s[l],
                                h = t.ClassUtils.getRegClass(c.type);
                            if (h) n.addComponent(h)._parse(c);
                            else console.warn("Unkown component type.");
                        }
                }
            }, {
                key: "_createNodeByJson02",
                value: function(e, t) {
                    var r = {},
                        n = Scene3DUtils._createSprite3DInstance(e, r, t);
                    return Scene3DUtils._createComponentInstance(e, r), n;
                }
            }, {
                key: "_parse",
                value: function(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    var t, r = e.data,
                        n = [];
                    switch (e.version) {
                        case "LAYAHIERARCHY:02":
                            t = Scene3DUtils._createNodeByJson02(r, n);
                            break;

                        default:
                            t = Scene3DUtils._createNodeByJson(r, n);
                    }
                    return ce.combine(t, n), t;
                }
            }, {
                key: "_parseScene",
                value: function(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    var t, r = e.data,
                        n = [];
                    switch (e.version) {
                        case "LAYASCENE3D:02":
                            t = Scene3DUtils._createNodeByJson02(r, n);
                            break;

                        default:
                            t = Scene3DUtils._createNodeByJson(r, n);
                    }
                    return ce.combine(null, n), t;
                }
            }, {
                key: "_createNodeByJson",
                value: function(e, r) {
                    var n;
                    switch (e.type) {
                        case "Scene3D":
                            n = new qt();
                            break;

                        case "Sprite3D":
                            n = new le();
                            break;

                        case "MeshSprite3D":
                            n = new _r(), r && e.props.isStatic && r.push(n);
                            break;

                        case "SkinnedMeshSprite3D":
                            n = new Zr();
                            break;

                        case "ShuriKenParticle3D":
                            n = new Yr();
                            break;

                        case "Camera":
                            n = new et();
                            break;

                        case "DirectionLight":
                            n = new vn();
                            break;

                        case "PointLight":
                            n = new En();
                            break;

                        case "SpotLight":
                            n = new gn();
                            break;

                        case "TrailSprite3D":
                            n = new nn();
                            break;

                        default:
                            throw new Error("Utils3D:unidentified class type in (.lh) file.");
                    }
                    var i = e.child;
                    if (i)
                        for (var a = 0, o = i.length; a < o; a++) {
                            var s = Scene3DUtils._createNodeByJson(i[a], r);
                            n.addChild(s);
                        }
                    var l = e.components;
                    if (l)
                        for (var u = 0, c = l.length; u < c; u++) {
                            var h = l[u],
                                _ = t.ClassUtils.getRegClass(h.type);
                            if (_) n.addComponent(_)._parse(h);
                            else console.warn("Unkown component type.");
                        }
                    return n._parse(e.props, null), n;
                }
            }]), Scene3DUtils;
        }(),
        Sn = function() {
            function LoadModelV04() {
                _classCallCheck(this, LoadModelV04);
            }
            return _createClass(LoadModelV04, null, [{
                key: "parse",
                value: function(e, t, r, n) {
                    LoadModelV04._mesh = r, LoadModelV04._subMeshes = n, LoadModelV04._version = t,
                        LoadModelV04._readData = e, LoadModelV04.READ_DATA(), LoadModelV04.READ_BLOCK(),
                        LoadModelV04.READ_STRINGS();
                    for (var i = 0, a = LoadModelV04._BLOCK.count; i < a; i++) {
                        LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                        var o = LoadModelV04._readData.getUint16(),
                            s = LoadModelV04._strings[o],
                            l = LoadModelV04["READ_" + s];
                        if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                        l.call(null);
                    }
                    LoadModelV04._strings.length = 0, LoadModelV04._readData = null, LoadModelV04._version = null,
                        LoadModelV04._mesh = null, LoadModelV04._subMeshes = null;
                }
            }, {
                key: "_readString",
                value: function() {
                    return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
                }
            }, {
                key: "READ_DATA",
                value: function() {
                    LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32(), LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
                }
            }, {
                key: "READ_BLOCK",
                value: function() {
                    for (var e = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16(), t = LoadModelV04._BLOCK.blockStarts = [], r = LoadModelV04._BLOCK.blockLengths = [], n = 0; n < e; n++) t.push(LoadModelV04._readData.getUint32()),
                        r.push(LoadModelV04._readData.getUint32());
                }
            }, {
                key: "READ_STRINGS",
                value: function() {
                    var e = LoadModelV04._readData.getUint32(),
                        t = LoadModelV04._readData.getUint16(),
                        r = LoadModelV04._readData.pos;
                    LoadModelV04._readData.pos = e + LoadModelV04._DATA.offset;
                    for (var n = 0; n < t; n++) LoadModelV04._strings[n] = LoadModelV04._readData.readUTFString();
                    LoadModelV04._readData.pos = r;
                }
            }, {
                key: "READ_MESH",
                value: function() {
                    var r, n = t.LayaGL.instance,
                        i = (LoadModelV04._readString(), LoadModelV04._readData.__getBuffer()),
                        a = 0,
                        o = LoadModelV04._readData.getInt16(),
                        s = LoadModelV04._DATA.offset;
                    for (r = 0; r < o; r++) {
                        var l, u = s + LoadModelV04._readData.getUint32(),
                            c = LoadModelV04._readData.getUint32(),
                            h = i.slice(u, u + c),
                            _ = new Float32Array(h),
                            d = LoadModelV04._readString();
                        switch (LoadModelV04._version) {
                            case "LAYAMODEL:0301":
                            case "LAYAMODEL:0400":
                                l = Ne.getVertexDeclaration(d);
                                break;

                            case "LAYAMODEL:0401":
                                l = Ne.getVertexDeclaration(d, !1);
                                break;

                            default:
                                throw new Error("LoadModelV03: unknown version.");
                        }
                        if (!l) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                        var f = new be(4 * _.length, n.STATIC_DRAW, !0);
                        f.vertexDeclaration = l, f.setData(_.buffer), LoadModelV04._mesh._vertexBuffer = f,
                            LoadModelV04._mesh._vertexCount += f._byteLength / l.vertexStride, a += 4 * _.length;
                    }
                    var m = s + LoadModelV04._readData.getUint32(),
                        T = LoadModelV04._readData.getUint32(),
                        p = new Uint16Array(i.slice(m, m + T)),
                        v = new Le(e.IndexFormat.UInt16, T / 2, n.STATIC_DRAW, !0);
                    v.setData(p), LoadModelV04._mesh._indexBuffer = v, a += 2 * v.indexCount, LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, v),
                        LoadModelV04._mesh._setCPUMemory(a), LoadModelV04._mesh._setGPUMemory(a);
                    var E = LoadModelV04._mesh._boneNames = [],
                        g = LoadModelV04._readData.getUint16();
                    for (E.length = g, r = 0; r < g; r++) E[r] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
                    LoadModelV04._readData.pos += 8;
                    var y = LoadModelV04._readData.getUint32(),
                        S = LoadModelV04._readData.getUint32(),
                        R = new Float32Array(i.slice(s + y, s + y + S)),
                        C = R.length,
                        M = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * C);
                    for (LoadModelV04._mesh._inverseBindPoses = [], r = 0; r < C; r += 16) {
                        var x = new L(R[r + 0], R[r + 1], R[r + 2], R[r + 3], R[r + 4], R[r + 5], R[r + 6], R[r + 7], R[r + 8], R[r + 9], R[r + 10], R[r + 11], R[r + 12], R[r + 13], R[r + 14], R[r + 15], new Float32Array(M, 4 * r, 16));
                        LoadModelV04._mesh._inverseBindPoses[r / 16] = x;
                    }
                    return !0;
                }
            }, {
                key: "READ_SUBMESH",
                value: function() {
                    var e = LoadModelV04._readData.__getBuffer(),
                        t = new _n(LoadModelV04._mesh);
                    LoadModelV04._readData.getInt16(), LoadModelV04._readData.getUint32(), LoadModelV04._readData.getUint32();
                    var r = LoadModelV04._readData.getUint32(),
                        n = LoadModelV04._readData.getUint32(),
                        i = LoadModelV04._mesh._indexBuffer;
                    t._indexBuffer = i, t._setIndexRange(r, n);
                    var a = LoadModelV04._mesh._vertexBuffer;
                    t._vertexBuffer = a;
                    var o = LoadModelV04._DATA.offset,
                        s = t._subIndexBufferStart,
                        l = t._subIndexBufferCount,
                        u = t._boneIndicesList,
                        c = LoadModelV04._readData.getUint16();
                    s.length = c, l.length = c, u.length = c;
                    var h = LoadModelV04._mesh._skinnedMatrixCaches,
                        _ = LoadModelV04._subMeshes.length;
                    h.length = LoadModelV04._mesh._inverseBindPoses.length;
                    for (var d = 0; d < c; d++) {
                        s[d] = LoadModelV04._readData.getUint32(), l[d] = LoadModelV04._readData.getUint32();
                        for (var f = LoadModelV04._readData.getUint32(), m = LoadModelV04._readData.getUint32(), T = u[d] = new Uint16Array(e.slice(o + f, o + f + m)), p = T.length, v = 0; v < p; v++) {
                            var E = T[v];
                            h[E] || (h[E] = new dn(_, d, v));
                        }
                    }
                    return LoadModelV04._subMeshes.push(t), !0;
                }
            }]), LoadModelV04;
        }();
    Sn._BLOCK = {
        count: 0
    }, Sn._DATA = {
        offset: 0,
        size: 0
    }, Sn._strings = [];
    var Rn = function() {
        function LoadModelV05() {
            _classCallCheck(this, LoadModelV05);
        }
        return _createClass(LoadModelV05, null, [{
            key: "parse",
            value: function(e, t, r, n) {
                LoadModelV05._mesh = r, LoadModelV05._subMeshes = n, LoadModelV05._version = t,
                    LoadModelV05._readData = e, LoadModelV05.READ_DATA(), LoadModelV05.READ_BLOCK(),
                    LoadModelV05.READ_STRINGS();
                for (var i = 0, a = LoadModelV05._BLOCK.count; i < a; i++) {
                    LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                    var o = LoadModelV05._readData.getUint16(),
                        s = LoadModelV05._strings[o],
                        l = LoadModelV05["READ_" + s];
                    if (null == l) throw new Error("model file err,no this function:" + o + " " + s);
                    l.call(null);
                }
                LoadModelV05._strings.length = 0, LoadModelV05._readData = null, LoadModelV05._version = null,
                    LoadModelV05._mesh = null, LoadModelV05._subMeshes = null;
            }
        }, {
            key: "_readString",
            value: function() {
                return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
            }
        }, {
            key: "READ_DATA",
            value: function() {
                LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32(), LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
            }
        }, {
            key: "READ_BLOCK",
            value: function() {
                for (var e = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16(), t = LoadModelV05._BLOCK.blockStarts = [], r = LoadModelV05._BLOCK.blockLengths = [], n = 0; n < e; n++) t.push(LoadModelV05._readData.getUint32()),
                    r.push(LoadModelV05._readData.getUint32());
            }
        }, {
            key: "READ_STRINGS",
            value: function() {
                var e = LoadModelV05._readData.getUint32(),
                    t = LoadModelV05._readData.getUint16(),
                    r = LoadModelV05._readData.pos;
                LoadModelV05._readData.pos = e + LoadModelV05._DATA.offset;
                for (var n = 0; n < t; n++) LoadModelV05._strings[n] = LoadModelV05._readData.readUTFString();
                LoadModelV05._readData.pos = r;
            }
        }, {
            key: "READ_MESH",
            value: function() {
                var r, n = t.LayaGL.instance,
                    i = 0,
                    a = (LoadModelV05._readString(), LoadModelV05._readData),
                    o = a.__getBuffer(),
                    s = a.getInt16(),
                    l = LoadModelV05._DATA.offset;
                for (r = 0; r < s; r++) {
                    var u, c, h, _ = l + a.getUint32(),
                        d = a.getUint32(),
                        f = LoadModelV05._readString(),
                        m = Ne.getVertexDeclaration(f, !1),
                        T = m.vertexStride,
                        p = f.split(","),
                        E = p.length,
                        g = LoadModelV05._mesh;
                    switch (LoadModelV05._version) {
                        case "LAYAMODEL:05":
                        case "LAYAMODEL:0501":
                            u = o.slice(_, _ + d * T), c = new Float32Array(u), h = new Uint8Array(u);
                            break;

                        case "LAYAMODEL:COMPRESSION_05":
                        case "LAYAMODEL:COMPRESSION_0501":
                            u = new ArrayBuffer(T * d), c = new Float32Array(u), h = new Uint8Array(u);
                            var y = a.pos;
                            a.pos = _;
                            for (var S = 0; S < d; S++)
                                for (var R, C = S * T, M = 0; M < E; M++) switch (p[M]) {
                                    case "POSITION":
                                        c[R = C / 4] = v.convertToNumber(a.getUint16()), c[R + 1] = v.convertToNumber(a.getUint16()),
                                            c[R + 2] = v.convertToNumber(a.getUint16()), C += 12;
                                        break;

                                    case "NORMAL":
                                        c[R = C / 4] = a.getUint8() / 127.5 - 1, c[R + 1] = a.getUint8() / 127.5 - 1, c[R + 2] = a.getUint8() / 127.5 - 1,
                                            C += 12;
                                        break;

                                    case "COLOR":
                                        c[R = C / 4] = a.getUint8() / 255, c[R + 1] = a.getUint8() / 255, c[R + 2] = a.getUint8() / 255,
                                            c[R + 3] = a.getUint8() / 255, C += 16;
                                        break;

                                    case "UV":
                                    case "UV1":
                                        c[R = C / 4] = v.convertToNumber(a.getUint16()), c[R + 1] = v.convertToNumber(a.getUint16()),
                                            C += 8;
                                        break;

                                    case "BLENDWEIGHT":
                                        c[R = C / 4] = a.getUint8() / 255, c[R + 1] = a.getUint8() / 255, c[R + 2] = a.getUint8() / 255,
                                            c[R + 3] = a.getUint8() / 255, C += 16;
                                        break;

                                    case "BLENDINDICES":
                                        h[C] = a.getUint8(), h[C + 1] = a.getUint8(), h[C + 2] = a.getUint8(), h[C + 3] = a.getUint8(),
                                            C += 4;
                                        break;

                                    case "TANGENT":
                                        c[R = C / 4] = a.getUint8() / 127.5 - 1, c[R + 1] = a.getUint8() / 127.5 - 1, c[R + 2] = a.getUint8() / 127.5 - 1,
                                            c[R + 3] = a.getUint8() / 127.5 - 1, C += 16;
                                }
                            a.pos = y;
                    }
                    var x = new be(u.byteLength, n.STATIC_DRAW, !0);
                    x.vertexDeclaration = m, x.setData(u);
                    d = x._byteLength / m.vertexStride;
                    g._indexFormat = d > 65535 ? e.IndexFormat.UInt32 : e.IndexFormat.UInt16, g._vertexBuffer = x,
                        g._vertexCount += d, i += 4 * c.length;
                }
                var D, A = l + a.getUint32(),
                    I = a.getUint32();
                D = g.indexFormat == e.IndexFormat.UInt32 ? new Uint32Array(o.slice(A, A + I)) : new Uint16Array(o.slice(A, A + I));
                var O = new Le(g.indexFormat, D.length, n.STATIC_DRAW, !0);
                if (O.setData(D), g._indexBuffer = O, g._setBuffer(g._vertexBuffer, O), i += 2 * O.indexCount,
                    g._setCPUMemory(i), g._setGPUMemory(i), "LAYAMODEL:0501" == LoadModelV05._version || "LAYAMODEL:COMPRESSION_0501" == LoadModelV05._version) {
                    var P = g.bounds,
                        N = P.getMin(),
                        b = P.getMax();
                    N.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()), b.setValue(a.getFloat32(), a.getFloat32(), a.getFloat32()),
                        P.setMin(N), P.setMax(b), g.bounds = P;
                }
                var k = g._boneNames = [],
                    V = a.getUint16();
                for (k.length = V, r = 0; r < V; r++) k[r] = LoadModelV05._strings[a.getUint16()];
                var B = a.getUint32(),
                    w = a.getUint32(),
                    F = new Float32Array(o.slice(l + B, l + B + w)),
                    U = F.length,
                    G = g._inverseBindPosesBuffer = new ArrayBuffer(4 * U);
                for (g._inverseBindPoses = [], r = 0; r < U; r += 16) {
                    var z = new L(F[r + 0], F[r + 1], F[r + 2], F[r + 3], F[r + 4], F[r + 5], F[r + 6], F[r + 7], F[r + 8], F[r + 9], F[r + 10], F[r + 11], F[r + 12], F[r + 13], F[r + 14], F[r + 15], new Float32Array(G, 4 * r, 16));
                    g._inverseBindPoses[r / 16] = z;
                }
                return !0;
            }
        }, {
            key: "READ_SUBMESH",
            value: function() {
                var e = LoadModelV05._readData,
                    t = e.__getBuffer(),
                    r = new _n(LoadModelV05._mesh);
                e.getInt16();
                var n = e.getUint32(),
                    i = e.getUint32(),
                    a = LoadModelV05._mesh._indexBuffer;
                r._indexBuffer = a, r._setIndexRange(n, i);
                var o = LoadModelV05._mesh._vertexBuffer;
                r._vertexBuffer = o;
                var s = LoadModelV05._DATA.offset,
                    l = r._subIndexBufferStart,
                    u = r._subIndexBufferCount,
                    c = r._boneIndicesList,
                    h = e.getUint16();
                l.length = h, u.length = h, c.length = h;
                var _ = LoadModelV05._mesh._skinnedMatrixCaches,
                    d = LoadModelV05._subMeshes.length;
                _.length = LoadModelV05._mesh._inverseBindPoses.length;
                for (var f = 0; f < h; f++) {
                    l[f] = e.getUint32(), u[f] = e.getUint32();
                    for (var m = e.getUint32(), T = e.getUint32(), p = c[f] = new Uint16Array(t.slice(s + m, s + m + T)), v = 0, E = p.length; v < E; v++) {
                        var g = p[v];
                        _[g] || (_[g] = new dn(d, f, v));
                    }
                }
                return LoadModelV05._subMeshes.push(r), !0;
            }
        }]), LoadModelV05;
    }();
    Rn._BLOCK = {
        count: 0
    }, Rn._DATA = {
        offset: 0,
        size: 0
    }, Rn._strings = [];
    var Cn = function() {
            function MeshReader() {
                _classCallCheck(this, MeshReader);
            }
            return _createClass(MeshReader, null, [{
                key: "_parse",
                value: function(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1], arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    var t = new fn();
                    return MeshReader.read(e, t, t._subMeshes), t;
                }
            }, {
                key: "read",
                value: function(e, r, n) {
                    var i = new t.Byte(e);
                    i.pos = 0;
                    var a = i.readUTFString();
                    switch (a) {
                        case "LAYAMODEL:0301":
                        case "LAYAMODEL:0400":
                        case "LAYAMODEL:0401":
                            Sn.parse(i, a, r, n);
                            break;

                        case "LAYAMODEL:05":
                        case "LAYAMODEL:COMPRESSION_05":
                        case "LAYAMODEL:0501":
                        case "LAYAMODEL:COMPRESSION_0501":
                            Rn.parse(i, a, r, n);
                            break;

                        default:
                            throw new Error("MeshReader: unknown mesh version.");
                    }
                    r._setSubMeshes(n), "LAYAMODEL:0501" != a && "LAYAMODEL:COMPRESSION_0501" != a && r.calculateBounds();
                }
            }]), MeshReader;
        }(),
        Mn = function(e) {
            function SkyPanoramicMaterial() {
                var e;
                _classCallCheck(this, SkyPanoramicMaterial), (e = _possibleConstructorReturn(this, _getPrototypeOf(SkyPanoramicMaterial).call(this)))._exposure = 1,
                    e._textureDecodeFormat = t.TextureDecodeFormat.Normal, e._textureHDRParams = new i(1, 0, 0, 1),
                    e.setShaderName("SkyPanoramic");
                var r = e._shaderValues;
                return r.setVector(SkyPanoramicMaterial.TINTCOLOR, new i(.5, .5, .5, .5)), r.setNumber(SkyPanoramicMaterial.ROTATION, 0),
                    r.setVector(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, e._textureHDRParams), e;
            }
            return _inherits(SkyPanoramicMaterial, j), _createClass(SkyPanoramicMaterial, [{
                key: "tintColor",
                get: function() {
                    return this._shaderValues.getVector(SkyPanoramicMaterial.TINTCOLOR);
                },
                set: function(e) {
                    this._shaderValues.setVector(SkyPanoramicMaterial.TINTCOLOR, e);
                }
            }, {
                key: "exposure",
                get: function() {
                    return this._exposure;
                },
                set: function(e) {
                    this._exposure !== e && (this._exposure = e, this._textureDecodeFormat == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = e * t.BaseTexture._rgbmRange : this._textureHDRParams.x = e);
                }
            }, {
                key: "rotation",
                get: function() {
                    return this._shaderValues.getNumber(SkyPanoramicMaterial.ROTATION);
                },
                set: function(e) {
                    this._shaderValues.setNumber(SkyPanoramicMaterial.ROTATION, e);
                }
            }, {
                key: "panoramicTexture",
                get: function() {
                    return this._shaderValues.getTexture(SkyPanoramicMaterial.TEXTURE);
                },
                set: function(e) {
                    this._shaderValues.setTexture(SkyPanoramicMaterial.TEXTURE, e);
                }
            }, {
                key: "panoramicTextureDecodeFormat",
                get: function() {
                    return this._textureDecodeFormat;
                },
                set: function(e) {
                    this._textureDecodeFormat !== e && (this._textureDecodeFormat = e, e == t.TextureDecodeFormat.RGBM ? this._textureHDRParams.x = this._exposure * t.BaseTexture._rgbmRange : this._textureHDRParams.x = this._exposure);
                }
            }], [{
                key: "__init__",
                value: function() {
                    var e = {
                            a_Position: Ne.MESH_POSITION0
                        },
                        t = {
                            u_TintColor: G.PERIOD_MATERIAL,
                            u_TextureHDRParams: G.PERIOD_MATERIAL,
                            u_Rotation: G.PERIOD_MATERIAL,
                            u_Texture: G.PERIOD_MATERIAL,
                            u_ViewProjection: G.PERIOD_CAMERA
                        },
                        r = G.add("SkyPanoramic"),
                        n = new $t(e, t);
                    r.addSubShader(n), n.addShaderPass('#include "Lighting.glsl";\r\n\r\n#define PI 3.14159265359\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * PI / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position = rotateAroundYInDegrees(a_Position, u_Rotation);\r\n\tgl_Position = u_ViewProjection*position;\r\n\r\n\tv_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);// NOTE: -a_Position.x convert coords system\r\n\r\n\t// Calculate constant horizontal scale and cutoff for 180 (vs 360) image type\r\n\tv_Image180ScaleAndCutoff = vec2(1.0, 1.0);// 360 degree mode\r\n\r\n\t// Calculate constant scale and offset for 3D layouts\r\n\tv_Layout3DScaleAndOffset = vec4(0,0,1,1);\r\n}\r\n', '#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#include "Lighting.glsl";\r\n\r\nuniform sampler2D u_Texture;\r\nuniform vec4 u_TextureHDRParams;\r\nuniform vec4 u_TintColor;\r\n\r\nvarying vec3 v_Texcoord;\r\nvarying vec2 v_Image180ScaleAndCutoff;\r\nvarying vec4 v_Layout3DScaleAndOffset;\r\n\r\nvec2 ToRadialCoords(vec3 coords)\r\n{\r\n\tvec3 normalizedCoords = normalize(coords);\r\n\tfloat latitude = acos(normalizedCoords.y);\r\n\tfloat longitude = atan(normalizedCoords.z,normalizedCoords.x);\r\n\tvec2 sphereCoords = vec2(longitude, latitude) * vec2(0.5/PI, 1.0/PI);\r\n\treturn vec2(0.5,1.0) - sphereCoords;\r\n}\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec2 tc = ToRadialCoords(v_Texcoord);\r\n\tif (tc.x > v_Image180ScaleAndCutoff.y)\r\n\t\tgl_FragColor=vec4(0,0,0,1);\r\n\ttc.x = mod(tc.x*v_Image180ScaleAndCutoff.x, 1.0);\r\n\ttc = (tc + v_Layout3DScaleAndOffset.xy) * v_Layout3DScaleAndOffset.zw;\r\n\r\n\tmediump vec4 tex = texture2D (u_Texture, tc);\r\n\tmediump vec3 c = decodeHDR (tex, u_TextureHDRParams.x);\r\n\tc = c * u_TintColor.rgb * 2.0;//Gamma Space is 2.0,linear space is 4.59479380\r\n\tgl_FragColor=vec4(c, 1.0);\r\n}\r\n\r\n');
                }
            }]), SkyPanoramicMaterial;
        }();
    Mn.TINTCOLOR = G.propertyNameToID("u_TintColor"), Mn.EXPOSURE = G.propertyNameToID("u_Exposure"),
        Mn.ROTATION = G.propertyNameToID("u_Rotation"), Mn.TEXTURE = G.propertyNameToID("u_Texture"),
        Mn.TEXTURE_HDR_PARAMS = G.propertyNameToID("u_TextureHDRParams");
    var xn = function() {
        function Laya3D() {
            _classCallCheck(this, Laya3D);
        }
        return _createClass(Laya3D, null, [{
            key: "_cancelLoadByUrl",
            value: function(e) {
                t.Laya.loader.cancelLoadByUrl(e), Laya3D._innerFirstLevelLoaderManager.cancelLoadByUrl(e),
                    Laya3D._innerSecondLevelLoaderManager.cancelLoadByUrl(e), Laya3D._innerThirdLevelLoaderManager.cancelLoadByUrl(e),
                    Laya3D._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
            }
        }, {
            key: "_changeWebGLSize",
            value: function(e, r) {
                t.WebGL.onStageResize(e, r), k.clientWidth = e, k.clientHeight = r;
            }
        }, {
            key: "__init__",
            value: function(e, r, n) {
                if (t.Config.isAntialias = n.isAntialias, t.Config.isAlpha = n.isAlpha, t.Config.premultipliedAlpha = n.premultipliedAlpha,
                    t.Config.isStencil = n.isStencil, t.WebGL.enable()) {
                    t.RunDriver.changeWebGLSize = Laya3D._changeWebGLSize, t.Render.is3DMode = !0, t.Laya.init(e, r),
                        t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext,
                            t.LayaGL.instance.createCommandEncoder = function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128,
                                    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 64,
                                    n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                return new t.CommandEncoder(this, e, r, n);
                            }), n._multiLighting = n.enableMultiLight && t.SystemUtils.supportTextureFormat(t.TextureFormat.R32G32B32A32),
                        l.Shader3D = G, l.Scene3D = qt, l.MeshRenderStaticBatchManager = Bt, l.MeshRenderDynamicBatchManager = hr,
                        l.SubMeshDynamicBatch = cr, l.Laya3D = Laya3D, l.Matrix4x4 = L, Laya3D.enableNative3D(),
                        Ie.__init__(), Ne.__init__(), Ur.__init__(), Gr.__init__(), gt.__init__(), $r.__init__(),
                        an.__init__(), It.__init__(), Nt.__init__(), cr.__init__(), y._bullet = window.Physics3D,
                        y._bullet && (hn.__init__(), st.__init__(), ct.__init__(), mt.__init__(), Tt.__init__(),
                            lt.__init__(), _t.__init__(), sn.__init__(), cn.__init__()), pn.__init__(), $e.init(),
                        ee.__init__(), rr.__init__(), er.__init__(), Mn.__init__(), fn.__init__(), mn.__init__(),
                        le.__init__(), ue.__init__(), _r.__init__(), Zr.__init__(), Yr.__init__(), nn.__init__(),
                        H.__init__(), qt.__init__(), Bt.__init__(), j.__initDefine__(), Q.__initDefine__(),
                        q.__initDefine__(), ir.__initDefine__(), ar.__initDefine__(), qr.__initDefine__(),
                        K.__initDefine__(), or.__initDefine__(), Br.__initDefine__(), $.__initDefine__(),
                        xt.__initDefine__(), nr.__initDefine__(), ze.__init__(), t.ClassUtils.regClass("Laya.SkyPanoramicMaterial", Mn),
                        t.ClassUtils.regClass("Laya.EffectMaterial", K), t.ClassUtils.regClass("Laya.UnlitMaterial", ar),
                        t.ClassUtils.regClass("Laya.BlinnPhongMaterial", q), t.ClassUtils.regClass("Laya.SkyProceduralMaterial", ir),
                        t.ClassUtils.regClass("Laya.PBRStandardMaterial", rr), t.ClassUtils.regClass("Laya.PBRSpecularMaterial", er),
                        t.ClassUtils.regClass("Laya.SkyBoxMaterial", nr), t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", or),
                        t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", $), t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", Br),
                        t.ClassUtils.regClass("Laya.TrailMaterial", qr), t.ClassUtils.regClass("Laya.PhysicsCollider", un),
                        t.ClassUtils.regClass("Laya.Rigidbody3D", cn), t.ClassUtils.regClass("Laya.CharacterController", sn),
                        t.ClassUtils.regClass("Laya.Animator", N), t.ClassUtils.regClass("PhysicsCollider", un),
                        t.ClassUtils.regClass("CharacterController", sn), t.ClassUtils.regClass("Animator", N),
                        t.ClassUtils.regClass("Rigidbody3D", cn), xt.defaultMaterial = new xt(), q.defaultMaterial = new q(),
                        K.defaultMaterial = new K(), ar.defaultMaterial = new ar(), Br.defaultMaterial = new Br(),
                        qr.defaultMaterial = new qr(), ir.defaultMaterial = new ir(), nr.defaultMaterial = new nr(),
                        or.defaultMaterial = new or(), xt.defaultMaterial.lock = !0, q.defaultMaterial.lock = !0,
                        K.defaultMaterial.lock = !0, ar.defaultMaterial.lock = !0, Br.defaultMaterial.lock = !0,
                        qr.defaultMaterial.lock = !0, ir.defaultMaterial.lock = !0, nr.defaultMaterial.lock = !0,
                        or.defaultMaterial.lock = !0, t.Texture2D.__init__(), St.__init__(), Ve.__init__(),
                        yt.__init__(), Ue.__init__(), Ge.__init__(), de.__init__(), v.__init__();
                    var i = t.LoaderManager.createMap;
                    i.lh = [Laya3D.HIERARCHY, yn._parse], i.ls = [Laya3D.HIERARCHY, yn._parseScene],
                        i.lm = [Laya3D.MESH, Cn._parse], i.lmat = [Laya3D.MATERIAL, j._parse], i.jpg = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                        i.jpeg = [Laya3D.TEXTURE2D, t.Texture2D._parse], i.bmp = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                        i.gif = [Laya3D.TEXTURE2D, t.Texture2D._parse], i.png = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                        i.dds = [Laya3D.TEXTURE2D, t.Texture2D._parse], i.ktx = [Laya3D.TEXTURE2D, t.Texture2D._parse],
                        i.pvr = [Laya3D.TEXTURE2D, t.Texture2D._parse], i.lani = [Laya3D.ANIMATIONCLIP, C._parse],
                        i.lav = [Laya3D.AVATAR, Y._parse], i.ltc = [Laya3D.TEXTURECUBE, St._parse],
                        i.ltcb = [Laya3D.TEXTURECUBEBIN, St._parseBin];
                    var a = t.Loader.parserMap;
                    a[Laya3D.HIERARCHY] = Laya3D._loadHierarchy, a[Laya3D.MESH] = Laya3D._loadMesh,
                        a[Laya3D.MATERIAL] = Laya3D._loadMaterial, a[Laya3D.TEXTURECUBE] = Laya3D._loadTextureCube,
                        a[Laya3D.TEXTURECUBEBIN] = Laya3D._loadTextureCubeBin, a[Laya3D.TEXTURE2D] = Laya3D._loadTexture2D,
                        a[Laya3D.ANIMATIONCLIP] = Laya3D._loadAnimationClip, a[Laya3D.AVATAR] = Laya3D._loadAvatar,
                        Laya3D._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                        Laya3D._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                        Laya3D._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError),
                        Laya3D._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Laya3D._eventLoadManagerError);
                } else alert("Laya3D init error,must support webGL!");
            }
        }, {
            key: "enableNative3D",
            value: function() {
                var e = z,
                    r = re,
                    n = Qr,
                    i = Y,
                    a = de;
                if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative,
                        e.prototype.setBool = e.prototype.setBoolForNative, e.prototype.getBool = e.prototype.getBoolForNative,
                        e.prototype.setInt = e.prototype.setIntForNative, e.prototype.getInt = e.prototype.getIntForNative,
                        e.prototype.setNumber = e.prototype.setNumberForNative, e.prototype.getNumber = e.prototype.getNumberForNative,
                        e.prototype.setVector = e.prototype.setVectorForNative, e.prototype.getVector = e.prototype.getVectorForNative,
                        e.prototype.setVector2 = e.prototype.setVector2ForNative, e.prototype.getVector2 = e.prototype.getVector2ForNative,
                        e.prototype.setVector3 = e.prototype.setVector3ForNative, e.prototype.getVector3 = e.prototype.getVector3ForNative,
                        e.prototype.setQuaternion = e.prototype.setQuaternionForNative, e.prototype.getQuaternion = e.prototype.getQuaternionForNative,
                        e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative,
                        e.prototype.setBuffer = e.prototype.setBufferForNative, e.prototype.getBuffer = e.prototype.getBufferForNative,
                        e.prototype.setTexture = e.prototype.setTextureForNative, e.prototype.getTexture = e.prototype.getTextureForNative,
                        e.prototype.setAttribute = e.prototype.setAttributeForNative, e.prototype.getAttribute = e.prototype.getAttributeForNative,
                        e.prototype.cloneTo = e.prototype.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative,
                        r.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative, r.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative,
                        r.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative, t.LayaGLRunner.uploadShaderUniforms = t.LayaGLRunner.uploadShaderUniformsForNative),
                    t.Render.supportWebGLPlusCulling && (a.renderObjectCulling = de.renderObjectCullingNative),
                    t.Render.supportWebGLPlusAnimation) {
                    i.prototype._cloneDatasToAnimator = i.prototype._cloneDatasToAnimatorNative;
                    var o = C;
                    o.prototype._evaluateClipDatasRealTime = o.prototype._evaluateClipDatasRealTimeForNative,
                        n.prototype._computeSkinnedData = n.prototype._computeSkinnedDataForNative;
                }
            }
        }, {
            key: "formatRelativePath",
            value: function(e, t) {
                var r;
                if (r = e + t, "." === t.charAt(0)) {
                    for (var n = r.split("/"), i = 0, a = n.length; i < a; i++)
                        if (".." == n[i]) {
                            var o = i - 1;
                            o > 0 && ".." !== n[o] && (n.splice(o, 2), i -= 2);
                        }
                    r = n.join("/");
                }
                return r;
            }
        }, {
            key: "_endLoad",
            value: function(e) {
                var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
                if (n)
                    for (var i = 0, a = n.length; i < a; i++) {
                        var o = t.Loader.getRes(n[i]);
                        o && o._removeReference();
                    }
                e.endLoad(r);
            }
        }, {
            key: "_eventLoadManagerError",
            value: function(e) {
                t.Laya.loader.event(t.Event.ERROR, e);
            }
        }, {
            key: "_addHierarchyInnerUrls",
            value: function(e, t, r, n, i, a) {
                var o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                    l = Laya3D.formatRelativePath(n, i);
                return r && (l += r), e.push({
                    url: l,
                    type: a,
                    constructParams: o,
                    propertyParams: s
                }), t.push(l), l;
            }
        }, {
            key: "_getSprite3DHierarchyInnerUrls",
            value: function(e, t, r, n, i, a, o, s) {
                var l, u, c = e.props;
                switch (e.type) {
                    case "Scene3D":
                        var h = c.lightmaps;
                        for (l = 0, u = h.length; l < u; l++) {
                            var _ = h[l];
                            if (_.path) _.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, _.path, Laya3D.TEXTURE2D, _.constructParams, _.propertyParams);
                            else {
                                var d = _.color;
                                d.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, d.path, Laya3D.TEXTURE2D, d.constructParams, d.propertyParams);
                                var f = _.direction;
                                f && (f.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, f.path, Laya3D.TEXTURE2D, f.constructParams, f.propertyParams));
                            }
                        }
                        var m = c.reflectionTexture;
                        m && (c.reflection = Laya3D._addHierarchyInnerUrls(n, a, o, s, m, Laya3D.TEXTURECUBE));
                        var T = c.reflection;
                        if (T && (c.reflection = Laya3D._addHierarchyInnerUrls(i, a, o, s, T, Laya3D.TEXTURECUBEBIN)),
                            c.sky) {
                            var p = c.sky.material;
                            p && (p.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, p.path, Laya3D.MATERIAL));
                        }
                        break;

                    case "Camera":
                        var v = c.skyboxMaterial;
                        v && (v.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, v.path, Laya3D.MATERIAL));
                        break;

                    case "TrailSprite3D":
                    case "MeshSprite3D":
                    case "SkinnedMeshSprite3D":
                        var E = c.meshPath;
                        E && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, E, Laya3D.MESH));
                        var g = c.materials;
                        if (g)
                            for (l = 0, u = g.length; l < u; l++) g[l].path = Laya3D._addHierarchyInnerUrls(r, a, o, s, g[l].path, Laya3D.MATERIAL);
                        break;

                    case "ShuriKenParticle3D":
                        if (c.main) {
                            var y = c.renderer.resources,
                                S = y.mesh,
                                R = y.material;
                            S && (y.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, Laya3D.MESH)), R && (y.material = Laya3D._addHierarchyInnerUrls(r, a, o, s, R, Laya3D.MATERIAL));
                        } else {
                            var C = c.meshPath;
                            C && (c.meshPath = Laya3D._addHierarchyInnerUrls(t, a, o, s, C, Laya3D.MESH)), c.material.path = Laya3D._addHierarchyInnerUrls(r, a, o, s, c.material.path, Laya3D.MATERIAL);
                        }
                        break;

                    case "Terrain":
                        Laya3D._addHierarchyInnerUrls(i, a, o, s, c.dataPath, Laya3D.TERRAINRES);
                }
                var M = e.components;
                if (M)
                    for (var x = 0, D = M.length; x < D; x++) {
                        var A = M[x];
                        switch (A.type) {
                            case "Animator":
                                A.avatarPath;
                                var L = A.avatar;
                                L && (L.path = Laya3D._addHierarchyInnerUrls(i, a, o, s, L.path, Laya3D.AVATAR));
                                var I = A.clipPaths;
                                if (I)
                                    for (l = 0, u = I.length; l < u; l++) I[l] = Laya3D._addHierarchyInnerUrls(i, a, o, s, I[l], Laya3D.ANIMATIONCLIP);
                                else {
                                    var O = A.layers;
                                    for (l = 0; l < O.length; l++)
                                        for (var P = O[l].states, N = 0, b = P.length; N < b; N++) {
                                            var k = P[N].clipPath;
                                            k && (P[N].clipPath = Laya3D._addHierarchyInnerUrls(i, a, o, s, k, Laya3D.ANIMATIONCLIP));
                                        }
                                }
                                break;

                            case "PhysicsCollider":
                            case "Rigidbody3D":
                            case "CharacterController":
                                var V = A.shapes;
                                for (l = 0; l < V.length; l++) {
                                    var B = V[l];
                                    if ("MeshColliderShape" === B.type)(S = B.mesh) && (B.mesh = Laya3D._addHierarchyInnerUrls(t, a, o, s, S, Laya3D.MESH));
                                }
                        }
                    }
                var w = e.child;
                for (l = 0, u = w.length; l < u; l++) Laya3D._getSprite3DHierarchyInnerUrls(w[l], t, r, n, i, a, o, s);
            }
        }, {
            key: "_loadHierarchy",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onHierarchylhLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onHierarchylhLoaded",
            value: function(e, r) {
                var n = e.url,
                    i = R.getURLVerion(n),
                    a = t.URL.getPath(n),
                    o = [],
                    s = [],
                    l = [],
                    u = [],
                    c = [];
                Laya3D._getSprite3DHierarchyInnerUrls(r.data, o, s, l, u, c, i, a);
                var h = o.length + s.length + u.length,
                    _ = h + 1,
                    d = 1 / _;
                if (Laya3D._onProcessChange(e, 0, d, 1), u.length > 0) {
                    var f = h / _,
                        m = t.Handler.create(null, Laya3D._onProcessChange, [e, d, f], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(u, !1, t.Handler.create(null, Laya3D._onHierarchyInnerForthLevResouLoaded, [e, m, r, c, o, s, l, d + f * u.length, f]), m, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerForthLevResouLoaded(e, null, r, c, o, s, l, d, f);
            }
        }, {
            key: "_onHierarchyInnerForthLevResouLoaded",
            value: function(e, r, n, i, a, o, s, l, u) {
                if (r && r.recover(), s.length > 0) {
                    var c = t.Handler.create(null, Laya3D._onProcessChange, [e, l, u], !1);
                    Laya3D._innerThirdLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onHierarchyInnerThirdLevResouLoaded, [e, c, n, i, a, o, l + u * o.length, u]), r, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerThirdLevResouLoaded(e, null, n, i, a, o, l, u);
            }
        }, {
            key: "_onHierarchyInnerThirdLevResouLoaded",
            value: function(e, r, n, i, a, o, s, l) {
                if (r && r.recover(), o.length > 0) {
                    var u = t.Handler.create(null, Laya3D._onProcessChange, [e, s, l], !1);
                    Laya3D._innerSecondLevelLoaderManager._create(o, !1, t.Handler.create(null, Laya3D._onHierarchyInnerSecondLevResouLoaded, [e, u, n, i, a, s + l * o.length, l]), r, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerSecondLevResouLoaded(e, null, n, i, a, s, l);
            }
        }, {
            key: "_onHierarchyInnerSecondLevResouLoaded",
            value: function(e, r, n, i, a, o, s) {
                if (r && r.recover(), a.length > 0) {
                    var l = t.Handler.create(null, Laya3D._onProcessChange, [e, o, s], !1);
                    Laya3D._innerFirstLevelLoaderManager._create(a, !1, t.Handler.create(null, Laya3D._onHierarchyInnerFirstLevResouLoaded, [e, l, n, i]), r, null, null, null, 1, !0);
                } else Laya3D._onHierarchyInnerFirstLevResouLoaded(e, null, n, i);
            }
        }, {
            key: "_onHierarchyInnerFirstLevResouLoaded",
            value: function(e, t, r, n) {
                t && t.recover(), e._cache = e._createCache;
                var i = "Scene3D" === r.data.type ? yn._parseScene(r, e._propertyParams, e._constructParams) : yn._parse(r, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, n);
            }
        }, {
            key: "_loadMesh",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMeshLmLoaded, [e]), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onMeshLmLoaded",
            value: function(e, t) {
                e._cache = e._createCache;
                var r = Cn._parse(t, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, r);
            }
        }, {
            key: "_loadMaterial",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onMaterilLmatLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_onMaterilLmatLoaded",
            value: function(e, r) {
                var n, i = e.url,
                    a = R.getURLVerion(i),
                    o = t.URL.getPath(i),
                    s = [],
                    l = [];
                r.customProps;
                switch (r.version) {
                    case "LAYAMATERIAL:01":
                    case "LAYAMATERIAL:02":
                        var u, c, h = r.props.textures;
                        if (h)
                            for (u = 0, c = h.length; u < c; u++) {
                                var _ = h[u],
                                    d = _.path;
                                d && (n = Laya3D.formatRelativePath(o, d), a && (n += a), s.push({
                                    url: n,
                                    constructParams: _.constructParams,
                                    propertyParams: _.propertyParams
                                }), l.push(n), _.path = n);
                            }
                        break;

                    default:
                        throw new Error("Laya3D:unkonwn version.");
                }
                var f = s.length,
                    m = f + 1,
                    T = 1 / m;
                if (Laya3D._onProcessChange(e, 0, T, 1), f > 0) {
                    var p = t.Handler.create(null, Laya3D._onProcessChange, [e, T, f / m], !1);
                    Laya3D._innerFourthLevelLoaderManager._create(s, !1, t.Handler.create(null, Laya3D._onMateialTexturesLoaded, [e, p, r, l]), p, null, null, null, 1, !0);
                } else Laya3D._onMateialTexturesLoaded(e, null, r, null);
            }
        }, {
            key: "_onMateialTexturesLoaded",
            value: function(e, t, r, n) {
                e._cache = e._createCache;
                var i = j._parse(r, e._propertyParams, e._constructParams);
                Laya3D._endLoad(e, i, n), t && t.recover();
            }
        }, {
            key: "_loadAvatar",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = Y._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, r);
                }), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadAnimationClip",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(t) {
                    e._cache = e._createCache;
                    var r = C._parse(t, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, r);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_loadTexture2D",
            value: function(e) {
                var r, n = e.url,
                    i = n.lastIndexOf(".") + 1,
                    a = n.indexOf("?"),
                    o = -1 == a ? n.length : a;
                switch (n.substr(i, o - i)) {
                    case "jpg":
                    case "jpeg":
                    case "bmp":
                    case "gif":
                    case "png":
                        r = "nativeimage";
                        break;

                    case "dds":
                    case "ktx":
                    case "pvr":
                        r = t.Loader.BUFFER;
                }
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var n = t.Texture2D._parse(r, e._propertyParams, e._constructParams);
                    Laya3D._endLoad(e, n);
                }), e.load(e.url, r, !1, null, !0);
            }
        }, {
            key: "_loadTextureCube",
            value: function(e) {
                e.on(t.Event.LOADED, null, Laya3D._onTextureCubeLtcLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
            }
        }, {
            key: "_loadTextureCubeBin",
            value: function(e) {
                e.on(t.Event.LOADED, null, function(r) {
                    e._cache = e._createCache;
                    var n = new t.Byte(r);
                    if ("LAYATEXTURECUBE:0000" !== n.readUTFString()) throw "Laya3D:unknow version.";
                    var i = n.readUint8(),
                        a = n.getUint8(),
                        o = n.readUint16(),
                        s = n.getUint8(),
                        l = n.getUint8(),
                        u = n.getUint8(),
                        c = n.getUint8(),
                        h = new St(o, i, a > 1);
                    h.filterMode = s, h.wrapModeU = l, h.wrapModeV = u, h.anisoLevel = c;
                    for (var _ = n.pos, d = o, f = 0; f < a; f++) {
                        for (var m = new Array(6), T = d * d * h._getFormatByteCount(), p = 0; p < 6; p++) m[p] = new Uint8Array(r, _, T),
                            _ += T;
                        h.setSixSidePixels(m, f), d /= 2;
                    }
                    Laya3D._endLoad(e, h);
                }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
            }
        }, {
            key: "_onTextureCubeLtcLoaded",
            value: function(e, r) {
                var n = t.URL.getPath(e.url),
                    i = [Laya3D.formatRelativePath(n, r.front), Laya3D.formatRelativePath(n, r.back), Laya3D.formatRelativePath(n, r.left), Laya3D.formatRelativePath(n, r.right), Laya3D.formatRelativePath(n, r.up), Laya3D.formatRelativePath(n, r.down)];
                Laya3D._onProcessChange(e, 0, 1 / 7, 1);
                var a = t.Handler.create(null, Laya3D._onProcessChange, [e, 1 / 7, 6 / 7], !1);
                Laya3D._innerFourthLevelLoaderManager.load(i, t.Handler.create(null, Laya3D._onTextureCubeImagesLoaded, [e, i, a]), a, "nativeimage");
            }
        }, {
            key: "_onTextureCubeImagesLoaded",
            value: function(e, r, n) {
                for (var i = new Array(6), a = 0; a < 6; a++) i[a] = t.Loader.getRes(r[a]);
                e._cache = e._createCache;
                var o = St._parse(i, e._propertyParams, e._constructParams);
                for (n.recover(), a = 0; a < 6; a++) t.Loader.clearRes(r[a]);
                Laya3D._endLoad(e, o);
            }
        }, {
            key: "_onProcessChange",
            value: function(e, r, n, i) {
                (i = r + i * n) < 1 && e.event(t.Event.PROGRESS, i);
            }
        }, {
            key: "init",
            value: function(e, t) {
                var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
                if (Laya3D._isInit) n && n.run();
                else {
                    Laya3D._isInit = !0, r && r.cloneTo(s._config), r = s._config, de.debugFrustumCulling = r.debugFrustumCulling,
                        Laya3D._editerEnvironment = r._editerEnvironment, qt.octreeCulling = r.octreeCulling,
                        qt.octreeInitialSize = r.octreeInitialSize, qt.octreeInitialCenter = r.octreeInitialCenter,
                        qt.octreeMinNodeSize = r.octreeMinNodeSize, qt.octreeLooseness = r.octreeLooseness;
                    var i = window.Physics3D;
                    null == i ? (y._enablePhysics = !1, Laya3D.__init__(e, t, r), n && n.run()) : (y._enablePhysics = !0,
                        i(16 * r.defaultPhysicsMemory, on._interactive).then(function() {
                            Laya3D.__init__(e, t, r), n && n.run();
                        }));
                }
            }
        }, {
            key: "enablePhysics",
            get: function() {
                return y._enablePhysics;
            }
        }]), Laya3D;
    }();
    xn.HIERARCHY = "HIERARCHY", xn.MESH = "MESH", xn.MATERIAL = "MATERIAL", xn.TEXTURE2D = "TEXTURE2D",
        xn.TEXTURECUBE = "TEXTURECUBE", xn.TEXTURECUBEBIN = "TEXTURECUBEBIN", xn.ANIMATIONCLIP = "ANIMATIONCLIP",
        xn.AVATAR = "AVATAR", xn.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", xn.TERRAINRES = "TERRAIN",
        xn._innerFirstLevelLoaderManager = new t.LoaderManager(), xn._innerSecondLevelLoaderManager = new t.LoaderManager(),
        xn._innerThirdLevelLoaderManager = new t.LoaderManager(), xn._innerFourthLevelLoaderManager = new t.LoaderManager(),
        xn._isInit = !1, xn._editerEnvironment = !1, xn.physicsSettings = new Et(), window.Laya3D = xn;
    var Dn = function(e) {
            function CastShadowList() {
                return _classCallCheck(this, CastShadowList), _possibleConstructorReturn(this, _getPrototypeOf(CastShadowList).call(this));
            }
            return _inherits(CastShadowList, ne), _createClass(CastShadowList, [{
                key: "add",
                value: function(e) {
                    if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
                    this._add(e), e._indexInCastShadowList = this.length++;
                }
            }, {
                key: "remove",
                value: function(e) {
                    var t = e._indexInCastShadowList;
                    if (this.length--, t !== this.length) {
                        var r = this.elements[this.length];
                        this.elements[t] = r, r._indexInCastShadowList = t;
                    }
                    e._indexInCastShadowList = -1;
                }
            }]), CastShadowList;
        }(),
        An = function() {
            function AnimatorStateScript() {
                _classCallCheck(this, AnimatorStateScript);
            }
            return _createClass(AnimatorStateScript, [{
                key: "onStateEnter",
                value: function() {}
            }, {
                key: "onStateUpdate",
                value: function() {}
            }, {
                key: "onStateExit",
                value: function() {}
            }]), AnimatorStateScript;
        }(),
        Ln = function(e) {
            function Script3D() {
                var e;
                return _classCallCheck(this, Script3D), (e = _possibleConstructorReturn(this, _getPrototypeOf(Script3D).apply(this, arguments)))._indexInPool = -1,
                    e;
            }
            return _inherits(Script3D, t.Component), _createClass(Script3D, [{
                key: "_checkProcessTriggers",
                value: function() {
                    var e = Script3D.prototype;
                    return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
                }
            }, {
                key: "_checkProcessCollisions",
                value: function() {
                    var e = Script3D.prototype;
                    return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
                }
            }, {
                key: "_onAwake",
                value: function() {
                    this.onAwake(), this.onStart !== Script3D.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
                }
            }, {
                key: "_onEnable",
                value: function() {
                    this.owner._scene._addScript(this), this.onEnable();
                }
            }, {
                key: "_onDisable",
                value: function() {
                    this.owner._scene._removeScript(this), this.owner.offAllCaller(this), this.onDisable();
                }
            }, {
                key: "_onDestroy",
                value: function() {
                    var e = this.owner._scripts;
                    e.splice(e.indexOf(this), 1);
                    var t = this.owner;
                    t._needProcessTriggers = !1;
                    for (var r = 0, n = e.length; r < n; r++)
                        if (e[r]._checkProcessTriggers()) {
                            t._needProcessTriggers = !0;
                            break;
                        }
                    for (t._needProcessCollisions = !1, r = 0, n = e.length; r < n; r++)
                        if (e[r]._checkProcessCollisions()) {
                            t._needProcessCollisions = !0;
                            break;
                        }
                    this.onDestroy();
                }
            }, {
                key: "_isScript",
                value: function() {
                    return !0;
                }
            }, {
                key: "_onAdded",
                value: function() {
                    var e = this.owner,
                        t = e._scripts;
                    t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()),
                        e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
                }
            }, {
                key: "onAwake",
                value: function() {}
            }, {
                key: "onEnable",
                value: function() {}
            }, {
                key: "onStart",
                value: function() {}
            }, {
                key: "onTriggerEnter",
                value: function(e) {}
            }, {
                key: "onTriggerStay",
                value: function(e) {}
            }, {
                key: "onTriggerExit",
                value: function(e) {}
            }, {
                key: "onCollisionEnter",
                value: function(e) {}
            }, {
                key: "onCollisionStay",
                value: function(e) {}
            }, {
                key: "onCollisionExit",
                value: function(e) {}
            }, {
                key: "onMouseDown",
                value: function() {}
            }, {
                key: "onMouseDrag",
                value: function() {}
            }, {
                key: "onMouseClick",
                value: function() {}
            }, {
                key: "onMouseUp",
                value: function() {}
            }, {
                key: "onMouseEnter",
                value: function() {}
            }, {
                key: "onMouseOver",
                value: function() {}
            }, {
                key: "onMouseOut",
                value: function() {}
            }, {
                key: "onUpdate",
                value: function() {}
            }, {
                key: "onLateUpdate",
                value: function() {}
            }, {
                key: "onPreRender",
                value: function() {}
            }, {
                key: "onPostRender",
                value: function() {}
            }, {
                key: "onDisable",
                value: function() {}
            }, {
                key: "onDestroy",
                value: function() {}
            }, {
                key: "isSingleton",
                get: function() {
                    return !1;
                }
            }]), Script3D;
        }(),
        In = function() {
            function HeightMap(e, t, r, n) {
                _classCallCheck(this, HeightMap), this._datas = [], this._w = e, this._h = t, this._minHeight = r,
                    this._maxHeight = n;
            }
            return _createClass(HeightMap, [{
                key: "_inBounds",
                value: function(e, t) {
                    return e >= 0 && e < this._h && t >= 0 && t < this._w;
                }
            }, {
                key: "getHeight",
                value: function(e, t) {
                    return this._inBounds(e, t) ? this._datas[e][t] : NaN;
                }
            }, {
                key: "width",
                get: function() {
                    return this._w;
                }
            }, {
                key: "height",
                get: function() {
                    return this._h;
                }
            }, {
                key: "maxHeight",
                get: function() {
                    return this._maxHeight;
                }
            }, {
                key: "minHeight",
                get: function() {
                    return this._minHeight;
                }
            }], [{
                key: "creatFromMesh",
                value: function(e, t, r, n) {
                    for (var i = [], a = [], s = e.subMeshCount, l = 0; l < s; l++) {
                        for (var u = e.getSubMesh(l), c = u._vertexBuffer, h = c.getFloat32Data(), _ = [], d = 0; d < h.length; d += c.vertexDeclaration.vertexStride / 4) {
                            var f = new o(h[d + 0], h[d + 1], h[d + 2]);
                            _.push(f);
                        }
                        i.push(_);
                        var m = u._indexBuffer;
                        a.push(m.getData());
                    }
                    var T = e.bounds,
                        p = T.getMin().x,
                        v = T.getMin().z,
                        E = T.getMax().x,
                        g = T.getMax().z,
                        y = T.getMin().y,
                        S = T.getMax().y,
                        R = E - p,
                        C = g - v,
                        M = n.x = R / (t - 1),
                        x = n.y = C / (r - 1),
                        D = new HeightMap(t, r, y, S),
                        A = HeightMap._tempRay,
                        L = A.direction;
                    L.x = 0, L.y = -1, L.z = 0;
                    var I = S + .1;
                    A.origin.y = I;
                    for (var O = 0; O < r; O++) {
                        var P = v + O * x;
                        D._datas[O] = [];
                        for (var N = 0; N < t; N++) {
                            var b = p + N * M,
                                k = A.origin;
                            k.x = b, k.z = P;
                            var V = HeightMap._getPosition(A, i, a);
                            D._datas[O][N] = V === Number.MAX_VALUE ? NaN : I - V;
                        }
                    }
                    return D;
                }
            }, {
                key: "createFromImage",
                value: function(e, t, r) {
                    for (var n = e.width, i = e.height, a = new HeightMap(n, i, t, r), o = (r - t) / 254, s = e.getPixels(), l = 0, u = 0; u < i; u++)
                        for (var c = a._datas[u] = [], h = 0; h < n; h++) {
                            var _ = s[l++],
                                d = s[l++],
                                f = s[l++],
                                m = s[l++];
                            c[h] = 255 == _ && 255 == d && 255 == f && 255 == m ? NaN : (_ + d + f) / 3 * o + t;
                        }
                    return a;
                }
            }, {
                key: "_getPosition",
                value: function(e, t, r) {
                    for (var n = Number.MAX_VALUE, i = 0; i < t.length; i++)
                        for (var a = t[i], o = r[i], s = 0; s < o.length; s += 3) {
                            var l = a[o[s + 0]],
                                u = a[o[s + 1]],
                                c = a[o[s + 2]],
                                h = xe.rayIntersectsTriangle(e, l, u, c);
                            !isNaN(h) && h < n && (n = h);
                        }
                    return n;
                }
            }]), HeightMap;
        }();
    In._tempRay = new ge(new o(), new o());
    var On = function(e) {
        function MeshTerrainSprite3D(e, t) {
            var r, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
            return _classCallCheck(this, MeshTerrainSprite3D), (r = _possibleConstructorReturn(this, _getPrototypeOf(MeshTerrainSprite3D).call(this, e, i)))._heightMap = t,
                r._cellSize = new n(), r;
        }
        return _inherits(MeshTerrainSprite3D, _r), _createClass(MeshTerrainSprite3D, [{
            key: "_disableRotation",
            value: function() {
                var e = this.transform.rotation;
                e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
            }
        }, {
            key: "_getScaleX",
            value: function() {
                var e = this.transform.worldMatrix.elements,
                    t = e[0],
                    r = e[1],
                    n = e[2];
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "_getScaleZ",
            value: function() {
                var e = this.transform.worldMatrix.elements,
                    t = e[8],
                    r = e[9],
                    n = e[10];
                return Math.sqrt(t * t + r * r + n * n);
            }
        }, {
            key: "_initCreateFromMesh",
            value: function(e, t) {
                this._heightMap = In.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
                var r = this.meshFilter.sharedMesh.bounds,
                    n = r.getMin();
                r.getMax();
                this._minX = n.x, this._minZ = n.z;
            }
        }, {
            key: "_initCreateFromMeshHeightMap",
            value: function(e, t, r) {
                var n = this.meshFilter.sharedMesh.bounds;
                this._heightMap = In.createFromImage(e, t, r), this._computeCellSize(n);
                var i = n.getMin();
                n.getMax();
                this._minX = i.x, this._minZ = i.z;
            }
        }, {
            key: "_computeCellSize",
            value: function(e) {
                var t = e.getMin(),
                    r = e.getMax(),
                    n = t.x,
                    i = t.z,
                    a = r.x - n,
                    o = r.z - i;
                this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = o / (this._heightMap.height - 1);
            }
        }, {
            key: "_update",
            value: function(e) {
                this._disableRotation();
            }
        }, {
            key: "getHeight",
            value: function(e, t) {
                MeshTerrainSprite3D._tempVector3.x = e, MeshTerrainSprite3D._tempVector3.y = 0,
                    MeshTerrainSprite3D._tempVector3.z = t, this._disableRotation();
                var r = this.transform.worldMatrix;
                r.invert(MeshTerrainSprite3D._tempMatrix4x4), o.transformCoordinate(MeshTerrainSprite3D._tempVector3, MeshTerrainSprite3D._tempMatrix4x4, MeshTerrainSprite3D._tempVector3),
                    e = MeshTerrainSprite3D._tempVector3.x, t = MeshTerrainSprite3D._tempVector3.z;
                var n = (e - this._minX) / this._cellSize.x,
                    i = (t - this._minZ) / this._cellSize.y,
                    a = Math.floor(i),
                    s = Math.floor(n),
                    l = n - s,
                    u = i - a,
                    c = r.elements,
                    h = c[4],
                    _ = c[5],
                    d = c[6],
                    f = Math.sqrt(h * h + _ * _ + d * d),
                    m = c[13],
                    T = this._heightMap.getHeight(a, s + 1),
                    p = this._heightMap.getHeight(a + 1, s);
                if (isNaN(T) || isNaN(p)) return NaN;
                if (l + u <= 1) {
                    var v = this._heightMap.getHeight(a, s);
                    return isNaN(v) ? NaN : (v + l * (T - v) + u * (p - v)) * f + m;
                }
                var E = this._heightMap.getHeight(a + 1, s + 1);
                return isNaN(E) ? NaN : (E + (1 - l) * (p - E) + (1 - u) * (T - E)) * f + m;
            }
        }, {
            key: "minX",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minX * this._getScaleX() + e[12];
            }
        }, {
            key: "minZ",
            get: function() {
                var e = this.transform.worldMatrix.elements;
                return this._minZ * this._getScaleZ() + e[14];
            }
        }, {
            key: "width",
            get: function() {
                return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
            }
        }, {
            key: "depth",
            get: function() {
                return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
            }
        }], [{
            key: "createFromMesh",
            value: function(e, t, r) {
                var n = new MeshTerrainSprite3D(e, null, arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null);
                return n._initCreateFromMesh(t, r), n;
            }
        }, {
            key: "createFromMeshAndHeightMap",
            value: function(e, t, r, n) {
                var i = new MeshTerrainSprite3D(e, null, arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null);
                return i._initCreateFromMeshHeightMap(t, r, n), i;
            }
        }]), MeshTerrainSprite3D;
    }();
    On._tempVector3 = new o(), On._tempMatrix4x4 = new L();
    var Pn = function() {
            function GradientDataVector2() {
                _classCallCheck(this, GradientDataVector2), this._currentLength = 0, this._elements = new Float32Array(12);
            }
            return _createClass(GradientDataVector2, [{
                key: "add",
                value: function(e, t) {
                    this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")),
                        this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x,
                        this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
                }
            }, {
                key: "cloneTo",
                value: function(e) {
                    var t = e;
                    t._currentLength = this._currentLength;
                    for (var r = t._elements, n = 0, i = this._elements.length; n < i; n++) r[n] = this._elements[n];
                }
            }, {
                key: "clone",
                value: function() {
                    var e = new GradientDataVector2();
                    return this.cloneTo(e), e;
                }
            }, {
                key: "gradientCount",
                get: function() {
                    return this._currentLength / 3;
                }
            }]), GradientDataVector2;
        }(),
        Nn = function() {
            function PixelLineData() {
                _classCallCheck(this, PixelLineData), this.startPosition = new o(), this.endPosition = new o(),
                    this.startColor = new ae(), this.endColor = new ae();
            }
            return _createClass(PixelLineData, [{
                key: "cloneTo",
                value: function(e) {
                    this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition),
                        this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
                }
            }]), PixelLineData;
        }(),
        bn = function() {
            function PostProcessEffect() {
                _classCallCheck(this, PostProcessEffect);
            }
            return _createClass(PostProcessEffect, [{
                key: "render",
                value: function(e) {}
            }]), PostProcessEffect;
        }(),
        kn = function(e) {
            function BloomEffect() {
                var e;
                return _classCallCheck(this, BloomEffect), (e = _possibleConstructorReturn(this, _getPrototypeOf(BloomEffect).call(this)))._shader = null,
                    e._shaderData = new z(), e._linearColor = new ae(), e._bloomTextureTexelSize = new i(),
                    e._shaderThreshold = new i(), e._shaderParams = new i(), e._pyramid = null, e._intensity = 0,
                    e._threshold = 1, e._softKnee = .5, e._diffusion = 7, e._anamorphicRatio = 0, e._dirtIntensity = 0,
                    e._shaderSetting = new i(), e._dirtTileOffset = new i(), e.clamp = 65472, e.color = new ae(1, 1, 1, 1),
                    e.fastMode = !1, e.dirtTexture = null, e._shader = G.find("PostProcessBloom"), e._pyramid = new Array(2 * BloomEffect.MAXPYRAMIDSIZE),
                    e;
            }
            return _inherits(BloomEffect, bn), _createClass(BloomEffect, [{
                key: "render",
                value: function(e) {
                    var r = e.command,
                        n = e.camera.viewport;
                    this._shaderData.setTexture(BloomEffect.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
                    var a, o = this._anamorphicRatio,
                        s = o < 0 ? -o : 0,
                        l = o > 0 ? o : 0,
                        u = Math.floor(n.width / (2 - s)),
                        c = Math.floor(n.height / (2 - l)),
                        h = Math.max(u, c);
                    a = Math.log2(h) + this._diffusion - 10;
                    var _ = Math.floor(a),
                        d = Math.min(Math.max(_, 1), BloomEffect.MAXPYRAMIDSIZE),
                        f = .5 + a - _;
                    this._shaderData.setNumber(BloomEffect.SHADERVALUE_SAMPLESCALE, f);
                    var m = ae.gammaToLinearSpace(this.threshold),
                        T = m * this._softKnee + 1e-5;
                    this._shaderThreshold.setValue(m, m - T, 2 * T, .25 / T), this._shaderData.setVector(BloomEffect.SHADERVALUE_THRESHOLD, this._shaderThreshold);
                    var p = ae.gammaToLinearSpace(this.clamp);
                    this._shaderParams.setValue(p, 0, 0, 0), this._shaderData.setVector(BloomEffect.SHADERVALUE_PARAMS, this._shaderParams);
                    for (var v = this.fastMode ? 1 : 0, E = e.source, g = 0; g < d; g++) {
                        var y = 2 * g,
                            S = y + 1,
                            R = 0 == g ? BloomEffect.SUBSHADER_PREFILTER13 + v : BloomEffect.SUBSHADER_DOWNSAMPLE13 + v,
                            C = V.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                        if (C.filterMode = t.FilterMode.Bilinear, this._pyramid[y] = C, g !== d - 1) {
                            var M = V.createFromPool(u, c, t.RenderTextureFormat.R8G8B8, t.RenderTextureDepthFormat.DEPTHSTENCIL_NONE);
                            M.filterMode = t.FilterMode.Bilinear, this._pyramid[S] = M;
                        }
                        r.blitScreenTriangle(E, C, null, this._shader, this._shaderData, R), E = C, u = Math.max(Math.floor(u / 2), 1),
                            c = Math.max(Math.floor(c / 2), 1);
                    }
                    var x = this._pyramid[2 * (d - 1)];
                    for (g = d - 2; g >= 0; g--) S = (y = 2 * g) + 1, C = this._pyramid[y], M = this._pyramid[S],
                        r.setShaderDataTexture(this._shaderData, BloomEffect.SHADERVALUE_BLOOMTEX, C), r.blitScreenTriangle(x, M, null, this._shader, this._shaderData, BloomEffect.SUBSHADER_UPSAMPLETENT + v),
                        x = M;
                    var D = this._linearColor;
                    this.color.toLinear(D);
                    var A = Math.pow(2, this._intensity / 10) - 1,
                        L = this._shaderSetting;
                    this._shaderSetting.setValue(f, A, this._dirtIntensity, d);
                    var I = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture,
                        O = I.width / I.height,
                        P = n.width / n.height,
                        N = this._dirtTileOffset;
                    O > P ? N.setValue(P / O, 1, .5 * (1 - N.x), 0) : O < P && N.setValue(1, O / P, 0, .5 * (1 - N.y));
                    var b = e.compositeShaderData;
                    for (this.fastMode ? b.addDefine(H.SHADERDEFINE_BLOOM_LOW) : b.addDefine(H.SHADERDEFINE_BLOOM),
                        this._bloomTextureTexelSize.setValue(1 / x.width, 1 / x.height, x.width, x.height),
                        b.setVector(H.SHADERVALUE_BLOOM_DIRTTILEOFFSET, N), b.setVector(H.SHADERVALUE_BLOOM_SETTINGS, L),
                        b.setVector(H.SHADERVALUE_BLOOM_COLOR, new i(D.r, D.g, D.b, D.a)), b.setTexture(H.SHADERVALUE_BLOOM_DIRTTEX, I),
                        b.setTexture(H.SHADERVALUE_BLOOMTEX, x), b.setVector(H.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize),
                        g = 0; g < d; g++) S = (y = 2 * g) + 1, V.recoverToPool(this._pyramid[y]), 0 !== g && g !== d - 1 && V.recoverToPool(this._pyramid[S]);
                    e.deferredReleaseTextures.push(x);
                }
            }, {
                key: "intensity",
                get: function() {
                    return this._intensity;
                },
                set: function(e) {
                    this._intensity = Math.max(e, 0);
                }
            }, {
                key: "threshold",
                get: function() {
                    return this._threshold;
                },
                set: function(e) {
                    this._threshold = Math.max(e, 0);
                }
            }, {
                key: "softKnee",
                get: function() {
                    return this._softKnee;
                },
                set: function(e) {
                    this._softKnee = Math.min(Math.max(e, 0), 1);
                }
            }, {
                key: "diffusion",
                get: function() {
                    return this._diffusion;
                },
                set: function(e) {
                    this._diffusion = Math.min(Math.max(e, 1), 10);
                }
            }, {
                key: "anamorphicRatio",
                get: function() {
                    return this._anamorphicRatio;
                },
                set: function(e) {
                    this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
                }
            }, {
                key: "dirtIntensity",
                get: function() {
                    return this._dirtIntensity;
                },
                set: function(e) {
                    this._dirtIntensity = Math.max(e, 0);
                }
            }]), BloomEffect;
        }();
    kn.SHADERVALUE_MAINTEX = G.propertyNameToID("u_MainTex"), kn.SHADERVALUE_AUTOEXPOSURETEX = G.propertyNameToID("u_AutoExposureTex"),
        kn.SHADERVALUE_SAMPLESCALE = G.propertyNameToID("u_SampleScale"), kn.SHADERVALUE_THRESHOLD = G.propertyNameToID("u_Threshold"),
        kn.SHADERVALUE_PARAMS = G.propertyNameToID("u_Params"), kn.SHADERVALUE_BLOOMTEX = G.propertyNameToID("u_BloomTex"),
        kn.SUBSHADER_PREFILTER13 = 0, kn.SUBSHADER_PREFILTER4 = 1, kn.SUBSHADER_DOWNSAMPLE13 = 2,
        kn.SUBSHADER_DOWNSAMPLE4 = 3, kn.SUBSHADER_UPSAMPLETENT = 4, kn.SUBSHADER_UPSAMPLEBOX = 5,
        kn.MAXPYRAMIDSIZE = 16;
    var Vn = function() {
        function RandX(e) {
            if (_classCallCheck(this, RandX), !(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        return _createClass(RandX, [{
            key: "randomint",
            value: function() {
                var e = this._state0U,
                    t = this._state0L,
                    r = this._state1U,
                    n = this._state1L,
                    i = (n >>> 0) + (t >>> 0),
                    a = r + e + (i / 2 >>> 31) >>> 0,
                    o = i >>> 0;
                this._state0U = r, this._state0L = n;
                var s = 0,
                    l = 0;
                s = (e ^= s = e << 23 | (-512 & t) >>> 9) ^ r, l = (t ^= l = t << 23) ^ n;
                s ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
                return s ^= r >>> 5, l ^= n >>> 5 | (31 & r) << 27, this._state1U = s, this._state1L = l, [a, o];
            }
        }, {
            key: "random",
            value: function() {
                var e = this.randomint(),
                    t = e[0],
                    r = 1023 << 20 | t >>> 12,
                    n = 0 | (e[1] >>> 12 | (4095 & t) << 20);
                return RandX._CONVERTION_BUFFER.setUint32(0, r, !1), RandX._CONVERTION_BUFFER.setUint32(4, n, !1),
                    RandX._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
            }
        }]), RandX;
    }();
    Vn._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Vn.defaultRand = new Vn([0, Date.now() / 65536, 0, Date.now() % 65536]);
    var Bn = function(e) {
            function ConstraintComponent() {
                var e;
                return _classCallCheck(this, ConstraintComponent), (e = _possibleConstructorReturn(this, _getPrototypeOf(ConstraintComponent).call(this)))._feedbackEnabled = !1,
                    e;
            }
            return _inherits(ConstraintComponent, t.Component), _createClass(ConstraintComponent, [{
                key: "_onDestroy",
                value: function() {
                    y._bullet.destroy(this._btConstraint), this._btConstraint = null;
                }
            }, {
                key: "enabled",
                get: function() {
                    return _get(_getPrototypeOf(ConstraintComponent.prototype), "enabled", this);
                },
                set: function(e) {
                    this._btConstraint.IsEnabled = e, _set(_getPrototypeOf(ConstraintComponent.prototype), "enabled", e, this, !0);
                }
            }, {
                key: "breakingImpulseThreshold",
                get: function() {
                    return this._breakingImpulseThreshold;
                },
                set: function(e) {
                    this._btConstraint.BreakingImpulseThreshold = e, this._breakingImpulseThreshold = e;
                }
            }, {
                key: "appliedImpulse",
                get: function() {
                    return this._feedbackEnabled || (this._btConstraint.EnableFeedback(!0), this._feedbackEnabled = !0),
                        this._btConstraint.AppliedImpulse;
                }
            }, {
                key: "connectedBody",
                get: function() {
                    return this._connectedBody;
                },
                set: function(e) {
                    this._connectedBody = e;
                }
            }]), ConstraintComponent;
        }(),
        wn = function() {
            function Point2PointConstraint() {
                _classCallCheck(this, Point2PointConstraint), this._pivotInA = new o(), this._pivotInB = new o();
            }
            return _createClass(Point2PointConstraint, [{
                key: "pivotInA",
                get: function() {
                    return this._pivotInA;
                },
                set: function(e) {
                    this._pivotInA = e;
                }
            }, {
                key: "pivotInB",
                get: function() {
                    return this._pivotInB;
                },
                set: function(e) {
                    this._pivotInB = e;
                }
            }, {
                key: "damping",
                get: function() {
                    return this._damping;
                },
                set: function(e) {
                    this._damping = e;
                }
            }, {
                key: "impulseClamp",
                get: function() {
                    return this._impulseClamp;
                },
                set: function(e) {
                    this._impulseClamp = e;
                }
            }, {
                key: "tau",
                get: function() {
                    return this._tau;
                },
                set: function(e) {
                    this._tau = e;
                }
            }]), Point2PointConstraint;
        }(),
        Fn = function() {
            function TextMesh() {
                _classCallCheck(this, TextMesh);
            }
            return _createClass(TextMesh, [{
                key: "text",
                get: function() {
                    return this._text;
                },
                set: function(e) {
                    this._text = e;
                }
            }, {
                key: "fontSize",
                get: function() {
                    return this._fontSize;
                },
                set: function(e) {
                    this._fontSize = e;
                }
            }, {
                key: "color",
                get: function() {
                    return this._color;
                },
                set: function(e) {
                    this._color = e;
                }
            }]), _createClass(TextMesh, [{
                key: "_createVertexBuffer",
                value: function(e) {}
            }, {
                key: "_resizeVertexBuffer",
                value: function(e) {}
            }, {
                key: "_addChar",
                value: function() {}
            }]), TextMesh;
        }(),
        Un = function() {
            function Size(e, t) {
                _classCallCheck(this, Size), this._width = 0, this._height = 0, this._width = e,
                    this._height = t;
            }
            return _createClass(Size, [{
                key: "width",
                get: function() {
                    return -1 === this._width ? k.clientWidth : this._width;
                }
            }, {
                key: "height",
                get: function() {
                    return -1 === this._height ? k.clientHeight : this._height;
                }
            }], [{
                key: "fullScreen",
                get: function() {
                    return new Size(-1, -1);
                }
            }]), Size;
        }();
    e.AlternateLightQueue = Mt, e.AnimationClip = C, e.AnimationClipParser03 = p, e.AnimationClipParser04 = E,
        e.AnimationEvent = c, e.AnimationNode = X, e.AnimationTransform3D = W, e.Animator = N,
        e.AnimatorControllerLayer = x, e.AnimatorPlayState = M, e.AnimatorState = O, e.AnimatorStateScript = An,
        e.Avatar = Y, e.BaseCamera = Fe, e.BaseMaterial = Q, e.BaseRender = wt, e.BaseShape = Mr,
        e.BatchMark = Pt, e.BlinnPhongMaterial = q, e.BlitScreenQuadCMD = He, e.BloomEffect = kn,
        e.BoundBox = Dt, e.BoundFrustum = Ce, e.BoundSphere = Yt, e.Bounds = At, e.BoundsOctree = Wt,
        e.BoundsOctreeNode = zt, e.BoxColliderShape = lt, e.BoxShape = Dr, e.BufferState = Ae,
        e.BulletInteractive = on, e.Burst = mr, e.Camera = et, e.CameraCullInfo = he, e.CapsuleColliderShape = ut,
        e.CastShadowList = Dn, e.CharacterController = sn, e.CircleShape = Ar, e.Cluster = me,
        e.ColliderShape = st, e.Collision = at, e.CollisionTool = ot, e.CollisionUtils = Re,
        e.Color = ae, e.ColorOverLifetime = pr, e.Command = ze, e.CommandBuffer = je, e.CompoundColliderShape = ct,
        e.ConchQuaternion = I, e.ConchVector3 = A, e.ConchVector4 = D, e.ConeColliderShape = ht,
        e.ConeShape = Lr, e.Config3D = s, e.Constraint3D = function Constraint3D() {
            _classCallCheck(this, Constraint3D);
        }, e.ConstraintComponent = Bn, e.ContactPoint = it, e.ContainmentType = ye, e.CylinderColliderShape = _t,
        e.DefineDatas = B, e.DirectionLight = vn, e.DirectionLightQueue = Ct, e.DynamicBatchManager = oe,
        e.EffectMaterial = K, e.Emission = Hr, e.ExtendTerrainMaterial = $, e.FloatKeyframe = _,
        e.FrameOverTime = vr, e.FrustumCulling = de, e.GeometryElement = Lt, e.Gradient = fr,
        e.GradientAngularVelocity = Er, e.GradientColor = Tr, e.GradientDataInt = gr, e.GradientDataNumber = yr,
        e.GradientDataVector2 = Pn, e.GradientMode = dr, e.GradientSize = Sr, e.GradientVelocity = Rr,
        e.HalfFloatUtils = v, e.HeightMap = In, e.HeightfieldColliderShape = function HeightfieldColliderShape() {
            _classCallCheck(this, HeightfieldColliderShape);
        }, e.HemisphereShape = Ir, e.HitResult = tt, e.ILaya3D = l, e.IndexBuffer3D = Le,
        e.Input3D = pt, e.Keyframe = h, e.KeyframeNode = u, e.KeyframeNodeList = g, e.KeyframeNodeOwner = P,
        e.Laya3D = xn, e.LightQueue = Rt, e.LightSprite = Ke, e.Lightmap = Xt, e.LoadModelV04 = Sn,
        e.LoadModelV05 = Rn, e.Material = j, e.MathUtils3D = r, e.Matrix3x3 = d, e.Matrix4x4 = L,
        e.Mesh = fn, e.MeshColliderShape = dt, e.MeshFilter = ur, e.MeshReader = Cn, e.MeshRenderDynamicBatchManager = hr,
        e.MeshRenderStaticBatchManager = Bt, e.MeshRenderer = lr, e.MeshSprite3D = _r, e.MeshSprite3DShaderDeclaration = sr,
        e.MeshTerrainSprite3D = On, e.MouseTouch = pe, e.OctreeMotionList = Ht, e.PBRMaterial = ee,
        e.PBRSpecularMaterial = er, e.PBRStandardMaterial = rr, e.Physics3D = y, e.Physics3DUtils = rt,
        e.PhysicsCollider = un, e.PhysicsComponent = mt, e.PhysicsSettings = Et, e.PhysicsSimulation = Tt,
        e.PhysicsTriggerComponent = ln, e.PhysicsUpdateList = nt, e.Picker = xe, e.PixelLineData = Nn,
        e.PixelLineFilter = Ot, e.PixelLineMaterial = xt, e.PixelLineRenderer = Ft, e.PixelLineSprite3D = Ut,
        e.PixelLineVertex = It, e.Plane = Ee, e.Point2PointConstraint = wn, e.PointLight = En,
        e.PostProcess = H, e.PostProcessEffect = bn, e.PostProcessRenderContext = b, e.PrimitiveMesh = mn,
        e.Quaternion = f, e.QuaternionKeyframe = m, e.Rand = zr, e.RandX = Vn, e.Ray = ge,
        e.RenderContext3D = k, e.RenderElement = bt, e.RenderQueue = Gt, e.RenderState = Z,
        e.RenderTexture = V, e.RenderableSprite3D = ue, e.Rigidbody3D = cn, e.RotationOverLifetime = Cr,
        e.Scene3D = qt, e.Scene3DShaderDeclaration = Qe, e.Scene3DUtils = yn, e.SceneManager = function SceneManager() {
            _classCallCheck(this, SceneManager);
        }, e.ScreenQuad = Ue, e.ScreenTriangle = Ge, e.Script3D = Ln, e.SetRenderTargetCMD = We,
        e.SetShaderDataTextureCMD = Xe, e.Shader3D = G, e.ShaderData = z, e.ShaderDefine = w,
        e.ShaderInit3D = pn, e.ShaderInstance = re, e.ShaderPass = Kt, e.ShaderVariable = te,
        e.ShaderVariant = F, e.ShaderVariantCollection = U, e.ShadowCasterPass = Zt, e.ShadowCullInfo = _e,
        e.ShadowSliceData = Qt, e.ShadowUtils = $e, e.ShapeUtils = xr, e.ShuriKenParticle3D = Yr,
        e.ShuriKenParticle3DShaderDeclaration = Vr, e.ShurikenParticleData = Wr, e.ShurikenParticleMaterial = Br,
        e.ShurikenParticleRenderer = wr, e.ShurikenParticleSystem = Xr, e.SimpleSingletonList = ie,
        e.SingletonList = ne, e.Size = Un, e.SizeOverLifetime = Pr, e.SkinnedMeshRenderer = Qr,
        e.SkinnedMeshSprite3D = Zr, e.SkinnedMeshSprite3DShaderDeclaration = jr, e.SkyBox = Ve,
        e.SkyBoxMaterial = nr, e.SkyDome = yt, e.SkyMesh = ke, e.SkyPanoramicMaterial = Mn,
        e.SkyProceduralMaterial = ir, e.SkyRenderer = Be, e.SphereColliderShape = ft, e.SphereShape = Or,
        e.SphericalHarmonicsL2 = Te, e.SpotLight = gn, e.Sprite3D = le, e.StartFrame = Nr,
        e.StaticBatchManager = ce, e.StaticPlaneColliderShape = hn, e.SubMesh = _n, e.SubMeshDynamicBatch = cr,
        e.SubMeshInstanceBatch = Nt, e.SubMeshRenderElement = kt, e.SubMeshStaticBatch = Vt,
        e.SubShader = $t, e.TextMesh = Fn, e.TextureCube = St, e.TextureGenerator = S, e.TextureMode = Jr,
        e.TextureSheetAnimation = br, e.Touch = ve, e.TrailFilter = tn, e.TrailGeometry = en,
        e.TrailMaterial = qr, e.TrailRenderer = rn, e.TrailSprite3D = nn, e.Transform3D = se,
        e.UnlitMaterial = ar, e.Utils3D = R, e.Vector2 = n, e.Vector3 = o, e.Vector3Keyframe = T,
        e.Vector4 = i, e.VelocityOverLifetime = kr, e.VertexBuffer3D = be, e.VertexDeclaration = Oe,
        e.VertexElement = Pe, e.VertexElementFormat = Ie, e.VertexMesh = Ne, e.VertexPositionTerrain = an,
        e.VertexPositionTexture0 = gt, e.VertexShuriKenParticle = Fr, e.VertexShurikenParticleBillboard = Ur,
        e.VertexShurikenParticleMesh = Gr, e.VertexTrail = $r, e.Viewport = Me, e.WaterPrimaryMaterial = or,
        e.skinnedMatrixCache = dn;
}(window.Laya = window.Laya || {}, Laya);