! function(e, t) {
    "use strict";
    class r {
        constructor() {}
        static isZero(e) {
            return Math.abs(e) < r.zeroTolerance;
        }
        static nearEqual(e, t) {
            return !!r.isZero(e - t);
        }
        static fastInvSqrt(e) {
            return r.isZero(e) ? e : 1 / Math.sqrt(e);
        }
    }
    r.zeroTolerance = 1e-6, r.MaxValue = 3.40282347e38, r.MinValue = -3.40282347e38;
    class i {
        constructor(e = 0, t = 0) {
            this.x = e, this.y = t;
        }
        setValue(e, t) {
            this.x = e, this.y = t;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y;
        }
        static normalize(e, t) {
            var r = e.x,
                i = e.y,
                n = r * r + i * i;
            n > 0 && (n = 1 / Math.sqrt(n), t.x = r * n, t.y = i * n);
        }
        static scalarLength(e) {
            var t = e.x,
                r = e.y;
            return Math.sqrt(t * t + r * r);
        }
        clone() {
            var e = new i();
            return this.cloneTo(e), e;
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y) : this.elements = new Float32Array([this.x, this.y]),
                i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1);
        }
        static rewriteNumProperty(e, t, r) {
            Object.defineProperty(e, t, {
                get: function() {
                    return this.elements[r];
                },
                set: function(e) {
                    this.elements[r] = e;
                }
            });
        }
    }
    i.ZERO = new i(0, 0), i.ONE = new i(1, 1);
    class n {
        constructor(e = 0, t = 0, r = 0, i = 0) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        setValue(e, t, r, i) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z, t.w = this.w;
        }
        clone() {
            var e = new n();
            return this.cloneTo(e), e;
        }
        static lerp(e, t, r, i) {
            var n = e.x,
                a = e.y,
                s = e.z,
                o = e.w;
            i.x = n + r * (t.x - n), i.y = a + r * (t.y - a), i.z = s + r * (t.z - s), i.w = o + r * (t.w - o);
        }
        static transformByM4x4(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = e.w,
                o = t.elements;
            r.x = i * o[0] + n * o[4] + a * o[8] + s * o[12], r.y = i * o[1] + n * o[5] + a * o[9] + s * o[13],
                r.z = i * o[2] + n * o[6] + a * o[10] + s * o[14], r.w = i * o[3] + n * o[7] + a * o[11] + s * o[15];
        }
        static equals(e, t) {
            return r.nearEqual(Math.abs(e.x), Math.abs(t.x)) && r.nearEqual(Math.abs(e.y), Math.abs(t.y)) && r.nearEqual(Math.abs(e.z), Math.abs(t.z)) && r.nearEqual(Math.abs(e.w), Math.abs(t.w));
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(e, t) {
            var r = e.length();
            r > 0 && (t.x = e.x * r, t.y = e.y * r, t.z = e.z * r, t.w = e.w * r);
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
        }
        static subtract(e, t, r) {
            r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z, r.w = e.w - t.w;
        }
        static multiply(e, t, r) {
            r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z, r.w = e.w * t.w;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w * t;
        }
        static Clamp(e, t, r, i) {
            var n = e.x,
                a = e.y,
                s = e.z,
                o = e.w,
                l = t.x,
                _ = t.y,
                h = t.z,
                c = t.w,
                d = r.x,
                u = r.y,
                f = r.z,
                E = r.w;
            n = (n = n > d ? d : n) < l ? l : n, a = (a = a > u ? u : a) < _ ? _ : a, s = (s = s > f ? f : s) < h ? h : s,
                o = (o = o > E ? E : o) < c ? c : o, i.x = n, i.y = a, i.z = s, i.w = o;
        }
        static distanceSquared(e, t) {
            var r = e.x - t.x,
                i = e.y - t.y,
                n = e.z - t.z,
                a = e.w - t.w;
            return r * r + i * i + n * n + a * a;
        }
        static distance(e, t) {
            var r = e.x - t.x,
                i = e.y - t.y,
                n = e.z - t.z,
                a = e.w - t.w;
            return Math.sqrt(r * r + i * i + n * n + a * a);
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }
        static min(e, t, r) {
            r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z), r.w = Math.min(e.w, t.w);
        }
        static max(e, t, r) {
            r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z), r.w = Math.max(e.w, t.w);
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                    this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2),
                i.rewriteNumProperty(this, "w", 3);
        }
    }
    n.ZERO = new n(), n.ONE = new n(1, 1, 1, 1), n.UnitX = new n(1, 0, 0, 0), n.UnitY = new n(0, 1, 0, 0),
        n.UnitZ = new n(0, 0, 1, 0), n.UnitW = new n(0, 0, 0, 1);
    class a {
        constructor(e = 0, t = 0, r = 0, i = null) {
            this.x = e, this.y = t, this.z = r;
        }
        static distanceSquared(e, t) {
            var r = e.x - t.x,
                i = e.y - t.y,
                n = e.z - t.z;
            return r * r + i * i + n * n;
        }
        static distance(e, t) {
            var r = e.x - t.x,
                i = e.y - t.y,
                n = e.z - t.z;
            return Math.sqrt(r * r + i * i + n * n);
        }
        static min(e, t, r) {
            r.x = Math.min(e.x, t.x), r.y = Math.min(e.y, t.y), r.z = Math.min(e.z, t.z);
        }
        static max(e, t, r) {
            r.x = Math.max(e.x, t.x), r.y = Math.max(e.y, t.y), r.z = Math.max(e.z, t.z);
        }
        static transformQuat(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.x,
                o = t.y,
                l = t.z,
                _ = t.w,
                h = _ * i + o * a - l * n,
                c = _ * n + l * i - s * a,
                d = _ * a + s * n - o * i,
                u = -s * i - o * n - l * a;
            r.x = h * _ + u * -s + c * -l - d * -o, r.y = c * _ + u * -o + d * -s - h * -l,
                r.z = d * _ + u * -l + h * -o - c * -s;
        }
        static scalarLength(e) {
            var t = e.x,
                r = e.y,
                i = e.z;
            return Math.sqrt(t * t + r * r + i * i);
        }
        static scalarLengthSquared(e) {
            var t = e.x,
                r = e.y,
                i = e.z;
            return t * t + r * r + i * i;
        }
        static normalize(e, t) {
            var r = e.x,
                i = e.y,
                n = e.z,
                a = r * r + i * i + n * n;
            a > 0 && (a = 1 / Math.sqrt(a), t.x = e.x * a, t.y = e.y * a, t.z = e.z * a);
        }
        static multiply(e, t, r) {
            r.x = e.x * t.x, r.y = e.y * t.y, r.z = e.z * t.z;
        }
        static scale(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t;
        }
        static lerp(e, t, r, i) {
            var n = e.x,
                a = e.y,
                s = e.z;
            i.x = n + r * (t.x - n), i.y = a + r * (t.y - a), i.z = s + r * (t.z - s);
        }
        static transformV3ToV3(e, t, r) {
            var i = a._tempVector4;
            a.transformV3ToV4(e, t, i), r.x = i.x, r.y = i.y, r.z = i.z;
        }
        static transformV3ToV4(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.elements;
            r.x = i * s[0] + n * s[4] + a * s[8] + s[12], r.y = i * s[1] + n * s[5] + a * s[9] + s[13],
                r.z = i * s[2] + n * s[6] + a * s[10] + s[14], r.w = i * s[3] + n * s[7] + a * s[11] + s[15];
        }
        static TransformNormal(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.elements;
            r.x = i * s[0] + n * s[4] + a * s[8], r.y = i * s[1] + n * s[5] + a * s[9], r.z = i * s[2] + n * s[6] + a * s[10];
        }
        static transformCoordinate(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.elements,
                o = i * s[3] + n * s[7] + a * s[11] + s[15];
            r.x = i * s[0] + n * s[4] + a * s[8] + s[12] / o, r.y = i * s[1] + n * s[5] + a * s[9] + s[13] / o,
                r.z = i * s[2] + n * s[6] + a * s[10] + s[14] / o;
        }
        static Clamp(e, t, r, i) {
            var n = e.x,
                a = e.y,
                s = e.z,
                o = t.x,
                l = t.y,
                _ = t.z,
                h = r.x,
                c = r.y,
                d = r.z;
            n = (n = n > h ? h : n) < o ? o : n, a = (a = a > c ? c : a) < l ? l : a, s = (s = s > d ? d : s) < _ ? _ : s,
                i.x = n, i.y = a, i.z = s;
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z;
        }
        static subtract(e, t, r) {
            r.x = e.x - t.x, r.y = e.y - t.y, r.z = e.z - t.z;
        }
        static cross(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.x,
                o = t.y,
                l = t.z;
            r.x = n * l - a * o, r.y = a * s - i * l, r.z = i * o - n * s;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z;
        }
        static equals(e, t) {
            return r.nearEqual(e.x, t.x) && r.nearEqual(e.y, t.y) && r.nearEqual(e.z, t.z);
        }
        setValue(e, t, r) {
            this.x = e, this.y = t, this.z = r;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2];
        }
        cloneTo(e) {
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z;
        }
        clone() {
            var e = new a();
            return this.cloneTo(e), e;
        }
        toDefault() {
            this.x = 0, this.y = 0, this.z = 0;
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z) : this.elements = new Float32Array([this.x, this.y, this.z]),
                i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2);
        }
    }
    a._tempVector4 = new n(), a._ZERO = new a(0, 0, 0), a._ONE = new a(1, 1, 1), a._NegativeUnitX = new a(-1, 0, 0),
        a._UnitX = new a(1, 0, 0), a._UnitY = new a(0, 1, 0), a._UnitZ = new a(0, 0, 1),
        a._ForwardRH = new a(0, 0, -1), a._ForwardLH = new a(0, 0, 1), a._Up = new a(0, 1, 0);
    class s {
        constructor() {
            this._defaultPhysicsMemory = 16, this._editerEnvironment = !1, this.isAntialias = !0,
                this.isAlpha = !1, this.premultipliedAlpha = !0, this.isStencil = !0, this.octreeCulling = !1,
                this.octreeInitialSize = 64, this.octreeInitialCenter = new a(0, 0, 0), this.octreeMinNodeSize = 2,
                this.octreeLooseness = 1.25, this.debugFrustumCulling = !1;
        }
        get defaultPhysicsMemory() {
            return this._defaultPhysicsMemory;
        }
        set defaultPhysicsMemory(e) {
            if (e < 16) throw "defaultPhysicsMemory must large than 16M";
            this._defaultPhysicsMemory = e;
        }
        cloneTo(e) {
            var t = e;
            t._defaultPhysicsMemory = this._defaultPhysicsMemory, t._editerEnvironment = this._editerEnvironment,
                t.isAntialias = this.isAntialias, t.isAlpha = this.isAlpha, t.premultipliedAlpha = this.premultipliedAlpha,
                t.isStencil = this.isStencil, t.octreeCulling = this.octreeCulling, this.octreeInitialCenter.cloneTo(t.octreeInitialCenter),
                t.octreeInitialSize = this.octreeInitialSize, t.octreeMinNodeSize = this.octreeMinNodeSize,
                t.octreeLooseness = this.octreeLooseness, t.debugFrustumCulling = this.debugFrustumCulling;
        }
        clone() {
            var e = new s();
            return this.cloneTo(e), e;
        }
    }
    s._default = new s(), window.Config3D = s;
    class o {}
    o.Scene3D = null, o.MeshRenderStaticBatchManager = null, o.MeshRenderDynamicBatchManager = null,
        o.SubMeshDynamicBatch = null, o.Laya3D = null, o.Matrix4x4 = null;
    class l {
        constructor() {
            this._batchRenderElementPool = [];
        }
        static _registerManager(e) {
            l._managers.push(e);
        }
        _clear() {
            this._batchRenderElementPoolIndex = 0;
        }
        _getBatchRenderElementFromPool() {
            throw "StaticBatch:must override this function.";
        }
        dispose() {}
    }
    l._managers = [];
    class _ extends t.BufferStateBase {
        constructor() {
            super();
        }
        applyVertexBuffer(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            var r = t.LayaGL.instance,
                i = e.vertexDeclaration._shaderValues.getData();
            for (var n in e.bind(), i) {
                var a = parseInt(n),
                    s = i[n];
                r.enableVertexAttribArray(a), r.vertexAttribPointer(a, s[0], s[1], !!s[2], s[3], s[4]);
            }
        }
        applyVertexBuffers(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            for (var r = t.LayaGL.instance, i = 0, n = e.length; i < n; i++) {
                var a = e[i],
                    s = a.vertexDeclaration._shaderValues.getData();
                for (var o in a.bind(), s) {
                    var l = parseInt(o),
                        _ = s[o];
                    r.enableVertexAttribArray(l), r.vertexAttribPointer(l, _[0], _[1], !!_[2], _[3], _[4]);
                }
            }
        }
        applyInstanceVertexBuffer(e) {
            if (t.LayaGL.layaGPUInstance.supportInstance()) {
                if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
                var r = t.LayaGL.instance,
                    i = e.vertexDeclaration._shaderValues.getData();
                for (var n in e.bind(), i) {
                    var a = parseInt(n),
                        s = i[n];
                    r.enableVertexAttribArray(a), r.vertexAttribPointer(a, s[0], s[1], !!s[2], s[3], s[4]),
                        t.LayaGL.layaGPUInstance.vertexAttribDivisor(a, 1);
                }
            }
        }
        applyIndexBuffer(e) {
            if (t.BufferStateBase._curBindedBufferState !== this) throw "BufferState: must call bind() function first.";
            this._bindedIndexBuffer !== e && (e._bindForVAO(), this._bindedIndexBuffer = e);
        }
    }
    class h {
        constructor() {
            this._destroyed = !1;
        }
        get destroyed() {
            return this._destroyed;
        }
        _getType() {
            throw "GeometryElement:must override it.";
        }
        _prepareRender(e) {
            return !0;
        }
        _render(e) {
            throw "GeometryElement:must override it.";
        }
        destroy() {
            this._destroyed || (this._destroyed = !0);
        }
    }
    h._typeCounter = 0;
    class c extends t.Buffer {
        constructor(e, r, i = 35044, n = !1) {
            var a;
            if (super(), this._indexType = e, this._indexCount = r, this._bufferUsage = i, this._bufferType = t.LayaGL.instance.ELEMENT_ARRAY_BUFFER,
                this._canRead = n, e == c.INDEXTYPE_USHORT) this._indexTypeByteCount = 2;
            else {
                if (e != c.INDEXTYPE_UBYTE) throw new Error("unidentification index type.");
                this._indexTypeByteCount = 1;
            }
            a = this._indexTypeByteCount * r, this._byteLength = a;
            var s = t.BufferStateBase._curBindedBufferState;
            s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferData(this._bufferType, a, this._bufferUsage) : (s.unBind(),
                    this.bind(), t.LayaGL.instance.bufferData(this._bufferType, a, this._bufferUsage),
                    s.bind()) : (this.bind(), t.LayaGL.instance.bufferData(this._bufferType, a, this._bufferUsage)),
                n && (e == c.INDEXTYPE_USHORT ? this._buffer = new Uint16Array(r) : e == c.INDEXTYPE_UBYTE && (this._buffer = new Uint8Array(r)));
        }
        get indexType() {
            return this._indexType;
        }
        get indexTypeByteCount() {
            return this._indexTypeByteCount;
        }
        get indexCount() {
            return this._indexCount;
        }
        get canRead() {
            return this._canRead;
        }
        _bindForVAO() {
            if (!t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must bind current BufferState.";
            var e = t.LayaGL.instance;
            e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer);
        }
        bind() {
            if (t.BufferStateBase._curBindedBufferState) throw "IndexBuffer3D: must unbind current BufferState.";
            if (t.Buffer._bindedIndexBuffer !== this._glBuffer) {
                var e = t.LayaGL.instance;
                return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedIndexBuffer = this._glBuffer, !0;
            }
            return !1;
        }
        setData(e, r = 0, i = 0, n = 4294967295) {
            var a;
            this._indexType == c.INDEXTYPE_USHORT ? (a = 2, 0 === i && 4294967295 === n || (e = new Uint16Array(e.buffer, i * a, n))) : this._indexType == c.INDEXTYPE_UBYTE && (a = 1,
                0 === i && 4294967295 === n || (e = new Uint8Array(e.buffer, i * a, n)));
            var s = t.BufferStateBase._curBindedBufferState;
            if (s ? s._bindedIndexBuffer === this ? t.LayaGL.instance.bufferSubData(this._bufferType, r * a, e) : (s.unBind(),
                    this.bind(), t.LayaGL.instance.bufferSubData(this._bufferType, r * a, e), s.bind()) : (this.bind(),
                    t.LayaGL.instance.bufferSubData(this._bufferType, r * a, e)), this._canRead)
                if (0 !== r || 0 !== i || 4294967295 !== n) {
                    var o = this._buffer.length - r;
                    n > o && (n = o);
                    for (var l = 0; l < n; l++) this._buffer[r + l] = e[l];
                } else this._buffer = e;
        }
        getData() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        destroy() {
            super.destroy(), this._buffer = null;
        }
    }
    c.INDEXTYPE_UBYTE = "ubyte", c.INDEXTYPE_USHORT = "ushort";
    class d extends t.Buffer {
        constructor(e, r, i = !1) {
            super(), this._vertexCount = 0, this._vertexDeclaration = null, this._float32Reader = null;
            var n = t.LayaGL.instance;
            this._vertexCount = -1, this._bufferUsage = r, this._bufferType = n.ARRAY_BUFFER,
                this._canRead = i, this._byteLength = e, this.bind(), n.bufferData(this._bufferType, this._byteLength, this._bufferUsage),
                i && (this._buffer = new Uint8Array(e), this._float32Reader = new Float32Array(this._buffer.buffer));
        }
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(e) {
            this._vertexDeclaration !== e && (this._vertexDeclaration = e, this._vertexCount = e ? this._byteLength / e.vertexStride : -1);
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get canRead() {
            return this._canRead;
        }
        bind() {
            if (t.Buffer._bindedVertexBuffer !== this._glBuffer) {
                var e = t.LayaGL.instance;
                return e.bindBuffer(e.ARRAY_BUFFER, this._glBuffer), t.Buffer._bindedVertexBuffer = this._glBuffer, !0;
            }
            return !1;
        }
        setData(e, r = 0, i = 0, n = 4294967295) {
            if (this.bind(), 0 !== i || 4294967295 !== n) {
                var a = new Uint8Array(e, i, n);
                t.LayaGL.instance.bufferSubData(this._bufferType, r, a), this._canRead && this._buffer.set(a, r);
            } else t.LayaGL.instance.bufferSubData(this._bufferType, r, e), this._canRead && this._buffer.set(new Uint8Array(e), r);
        }
        getUint8Data() {
            if (this._canRead) return this._buffer;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        getFloat32Data() {
            if (this._canRead) return this._float32Reader;
            throw new Error("Can't read data from VertexBuffer with only write flag!");
        }
        markAsUnreadbale() {
            this._canRead = !1, this._buffer = null, this._float32Reader = null;
        }
        destroy() {
            super.destroy(), this._buffer = null, this._float32Reader = null, this._vertexDeclaration = null;
        }
    }
    d.DATATYPE_FLOAT32ARRAY = 0, d.DATATYPE_UINT8ARRAY = 1;
    class u {
        static __init__() {
            var e = t.LayaGL.instance;
            u._elementInfos = {
                single: [1, e.FLOAT, 0],
                vector2: [2, e.FLOAT, 0],
                vector3: [3, e.FLOAT, 0],
                vector4: [4, e.FLOAT, 0],
                color: [4, e.FLOAT, 0],
                byte4: [4, e.UNSIGNED_BYTE, 0],
                short2: [2, e.FLOAT, 0],
                short4: [4, e.FLOAT, 0],
                normalizedshort2: [2, e.FLOAT, 0],
                normalizedshort4: [4, e.FLOAT, 0],
                halfvector2: [2, e.FLOAT, 0],
                halfvector4: [4, e.FLOAT, 0]
            };
        }
        static getElementInfos(e) {
            var t = u._elementInfos[e];
            if (t) return t;
            throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }
    }
    u.Single = "single", u.Vector2 = "vector2", u.Vector3 = "vector3", u.Vector4 = "vector4",
        u.Color = "color", u.Byte4 = "byte4", u.Short2 = "short2", u.Short4 = "short4",
        u.NormalizedShort2 = "normalizedshort2", u.NormalizedShort4 = "normalizedshort4",
        u.HalfVector2 = "halfvector2", u.HalfVector4 = "halfvector4";
    class f {
        constructor() {
            var e = this.elements = new Float32Array(9);
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                e[8] = 1;
        }
        static createRotationQuaternion(e, t) {
            var r = e.x,
                i = e.y,
                n = e.z,
                a = e.w,
                s = r * r,
                o = i * i,
                l = n * n,
                _ = r * i,
                h = n * a,
                c = n * r,
                d = i * a,
                u = i * n,
                f = r * a,
                E = t.elements;
            E[0] = 1 - 2 * (o + l), E[1] = 2 * (_ + h), E[2] = 2 * (c - d), E[3] = 2 * (_ - h),
                E[4] = 1 - 2 * (l + s), E[5] = 2 * (u + f), E[6] = 2 * (c + d), E[7] = 2 * (u - f),
                E[8] = 1 - 2 * (o + s);
        }
        static createFromTranslation(e, t) {
            t.elements;
            t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e.x, t[7] = e.y,
                t[8] = 1;
        }
        static createFromRotation(e, t) {
            var r = t.elements,
                i = Math.sin(e),
                n = Math.cos(e);
            r[0] = n, r[1] = i, r[2] = 0, r[3] = -i, r[4] = n, r[5] = 0, r[6] = 0, r[7] = 0,
                r[8] = 1;
        }
        static createFromScaling(e, t) {
            var r = t.elements;
            r[0] = e.x, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = e.y, r[5] = 0, r[6] = 0, r[7] = 0,
                r[8] = e.z;
        }
        static createFromMatrix4x4(e, t) {
            var r = e.elements,
                i = t.elements;
            i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[4], i[4] = r[5], i[5] = r[6], i[6] = r[8],
                i[7] = r[9], i[8] = r[10];
        }
        static multiply(e, t, r) {
            var i = e.elements,
                n = t.elements,
                a = r.elements,
                s = i[0],
                o = i[1],
                l = i[2],
                _ = i[3],
                h = i[4],
                c = i[5],
                d = i[6],
                u = i[7],
                f = i[8],
                E = n[0],
                T = n[1],
                m = n[2],
                p = n[3],
                g = n[4],
                S = n[5],
                v = n[6],
                R = n[7],
                A = n[8];
            a[0] = E * s + T * _ + m * d, a[1] = E * o + T * h + m * R, a[2] = E * l + T * c + m * f,
                a[3] = p * s + g * _ + S * d, a[4] = p * o + g * h + S * u, a[5] = p * l + g * c + S * f,
                a[6] = v * s + R * _ + A * d, a[7] = v * o + R * h + A * u, a[8] = v * l + R * c + A * f;
        }
        determinant() {
            var e = this.elements,
                t = e[0],
                r = e[1],
                i = e[2],
                n = e[3],
                a = e[4],
                s = e[5],
                o = e[6],
                l = e[7],
                _ = e[8];
            return t * (_ * a - s * l) + r * (-_ * n + s * o) + i * (l * n - a * o);
        }
        translate(e, t) {
            var r = t.elements,
                i = this.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = i[4],
                _ = i[5],
                h = i[6],
                c = i[7],
                d = i[8],
                u = e.x,
                f = e.y;
            r[0] = n, r[1] = a, r[2] = s, r[3] = o, r[4] = l, r[5] = _, r[6] = u * n + f * o + h,
                r[7] = u * a + f * l + c, r[8] = u * s + f * _ + d;
        }
        rotate(e, t) {
            var r = t.elements,
                i = this.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = i[4],
                _ = i[5],
                h = i[6],
                c = i[7],
                d = i[8],
                u = Math.sin(e),
                f = Math.cos(e);
            r[0] = f * n + u * o, r[1] = f * a + u * l, r[2] = f * s + u * _, r[3] = f * o - u * n,
                r[4] = f * l - u * a, r[5] = f * _ - u * s, r[6] = h, r[7] = c, r[8] = d;
        }
        scale(e, t) {
            var r = t.elements,
                i = this.elements,
                n = e.x,
                a = e.y;
            r[0] = n * i[0], r[1] = n * i[1], r[2] = n * i[2], r[3] = a * i[3], r[4] = a * i[4],
                r[5] = a * i[5], r[6] = i[6], r[7] = i[7], r[8] = i[8];
        }
        invert(e) {
            var t = e.elements,
                r = this.elements,
                i = r[0],
                n = r[1],
                a = r[2],
                s = r[3],
                o = r[4],
                l = r[5],
                _ = r[6],
                h = r[7],
                c = r[8],
                d = c * o - l * h,
                u = -c * s + l * _,
                f = h * s - o * _,
                E = i * d + n * u + a * f;
            E || (e = null), E = 1 / E, t[0] = d * E, t[1] = (-c * n + a * h) * E, t[2] = (l * n - a * o) * E,
                t[3] = u * E, t[4] = (c * i - a * _) * E, t[5] = (-l * i + a * s) * E, t[6] = f * E,
                t[7] = (-h * i + n * _) * E, t[8] = (o * i - n * s) * E;
        }
        transpose(e) {
            var t = e.elements,
                r = this.elements;
            if (e === this) {
                var i = r[1],
                    n = r[2],
                    a = r[5];
                t[1] = r[3], t[2] = r[6], t[3] = i, t[5] = r[7], t[6] = n, t[7] = a;
            } else t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] = r[7],
                t[6] = r[2], t[7] = r[5], t[8] = r[8];
        }
        identity() {
            var e = this.elements;
            e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0,
                e[8] = 1;
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements))
                for (t = 0; t < 9; ++t) i[t] = r[t];
        }
        clone() {
            var e = new f();
            return this.cloneTo(e), e;
        }
        static lookAt(e, t, r, i) {
            a.subtract(e, t, f._tempV30), a.normalize(f._tempV30, f._tempV30), a.cross(r, f._tempV30, f._tempV31),
                a.normalize(f._tempV31, f._tempV31), a.cross(f._tempV30, f._tempV31, f._tempV32);
            var n = f._tempV30,
                s = f._tempV31,
                o = f._tempV32,
                l = i.elements;
            l[0] = s.x, l[3] = s.y, l[6] = s.z, l[1] = o.x, l[4] = o.y, l[7] = o.z, l[2] = n.x,
                l[5] = n.y, l[8] = n.z;
        }
    }
    f.DEFAULT = new f(), f._tempV30 = new a(), f._tempV31 = new a(), f._tempV32 = new a();
    class E {
        constructor(e = 0, t = 0, r = 0, i = 1, n = null) {
            this.x = e, this.y = t, this.z = r, this.w = i;
        }
        static createFromYawPitchRoll(e, t, r, i) {
            var n = .5 * r,
                a = .5 * t,
                s = .5 * e,
                o = Math.sin(n),
                l = Math.cos(n),
                _ = Math.sin(a),
                h = Math.cos(a),
                c = Math.sin(s),
                d = Math.cos(s);
            i.x = d * _ * l + c * h * o, i.y = c * h * l - d * _ * o, i.z = d * h * o - c * _ * l,
                i.w = d * h * l + c * _ * o;
        }
        static multiply(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = e.w,
                o = t.x,
                l = t.y,
                _ = t.z,
                h = t.w,
                c = n * _ - a * l,
                d = a * o - i * _,
                u = i * l - n * o,
                f = i * o + n * l + a * _;
            r.x = i * h + o * s + c, r.y = n * h + l * s + d, r.z = a * h + _ * s + u, r.w = s * h - f;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            a.subtract(t, e, E.TEMPVector30), a.normalize(E.TEMPVector30, E.TEMPVector30), r.x = Math.asin(E.TEMPVector30.y),
                r.y = E.arcTanAngle(-E.TEMPVector30.z, -E.TEMPVector30.x);
        }
        static createFromAxisAngle(e, t, r) {
            t *= .5;
            var i = Math.sin(t);
            r.x = i * e.x, r.y = i * e.y, r.z = i * e.z, r.w = Math.cos(t);
        }
        static createFromMatrix4x4(e, t) {
            var r, i, n = e.elements,
                a = n[0] + n[5] + n[10];
            a > 0 ? (r = Math.sqrt(a + 1), t.w = .5 * r, r = .5 / r, t.x = (n[6] - n[9]) * r,
                t.y = (n[8] - n[2]) * r, t.z = (n[1] - n[4]) * r) : n[0] >= n[5] && n[0] >= n[10] ? (i = .5 / (r = Math.sqrt(1 + n[0] - n[5] - n[10])),
                t.x = .5 * r, t.y = (n[1] + n[4]) * i, t.z = (n[2] + n[8]) * i, t.w = (n[6] - n[9]) * i) : n[5] > n[10] ? (i = .5 / (r = Math.sqrt(1 + n[5] - n[0] - n[10])),
                t.x = (n[4] + n[1]) * i, t.y = .5 * r, t.z = (n[9] + n[6]) * i, t.w = (n[8] - n[2]) * i) : (i = .5 / (r = Math.sqrt(1 + n[10] - n[0] - n[5])),
                t.x = (n[8] + n[2]) * i, t.y = (n[9] + n[6]) * i, t.z = .5 * r, t.w = (n[1] - n[4]) * i);
        }
        static slerp(e, t, r, i) {
            var n, a, s, o, l, _ = e.x,
                h = e.y,
                c = e.z,
                d = e.w,
                u = t.x,
                f = t.y,
                E = t.z,
                T = t.w;
            return (a = _ * u + h * f + c * E + d * T) < 0 && (a = -a, u = -u, f = -f, E = -E,
                    T = -T), 1 - a > 1e-6 ? (n = Math.acos(a), s = Math.sin(n), o = Math.sin((1 - r) * n) / s,
                    l = Math.sin(r * n) / s) : (o = 1 - r, l = r), i.x = o * _ + l * u, i.y = o * h + l * f,
                i.z = o * c + l * E, i.w = o * d + l * T, i;
        }
        static lerp(e, t, r, i) {
            var n = 1 - r;
            E.dot(e, t) >= 0 ? (i.x = n * e.x + r * t.x, i.y = n * e.y + r * t.y, i.z = n * e.z + r * t.z,
                i.w = n * e.w + r * t.w) : (i.x = n * e.x - r * t.x, i.y = n * e.y - r * t.y, i.z = n * e.z - r * t.z,
                i.w = n * e.w - r * t.w), i.normalize(i);
        }
        static add(e, t, r) {
            r.x = e.x + t.x, r.y = e.y + t.y, r.z = e.z + t.z, r.w = e.w + t.w;
        }
        static dot(e, t) {
            return e.x * t.x + e.y * t.y + e.z * t.z + e.w * t.w;
        }
        scaling(e, t) {
            t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e;
        }
        normalize(e) {
            var t = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            t > 0 && (t = 1 / Math.sqrt(t), e.x = this.x * t, e.y = this.y * t, e.z = this.z * t,
                e.w = this.w * t);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(e, t) {
            e *= .5;
            var r = Math.sin(e),
                i = Math.cos(e);
            t.x = this.x * i + this.w * r, t.y = this.y * i + this.z * r, t.z = this.z * i - this.y * r,
                t.w = this.w * i - this.x * r;
        }
        rotateY(e, t) {
            e *= .5;
            var r = Math.sin(e),
                i = Math.cos(e);
            t.x = this.x * i - this.z * r, t.y = this.y * i + this.w * r, t.z = this.z * i + this.x * r,
                t.w = this.w * i - this.y * r;
        }
        rotateZ(e, t) {
            e *= .5;
            var r = Math.sin(e),
                i = Math.cos(e);
            t.x = this.x * i + this.y * r, t.y = this.y * i - this.x * r, t.z = this.z * i + this.w * r,
                t.w = this.w * i - this.z * r;
        }
        getYawPitchRoll(e) {
            a.transformQuat(a._ForwardRH, this, E.TEMPVector31), a.transformQuat(a._Up, this, E.TEMPVector32);
            var t = E.TEMPVector32;
            E.angleTo(a._ZERO, E.TEMPVector31, E.TEMPVector33);
            var r = E.TEMPVector33;
            r.x == Math.PI / 2 ? (r.y = E.arcTanAngle(t.z, t.x), r.z = 0) : r.x == -Math.PI / 2 ? (r.y = E.arcTanAngle(-t.z, -t.x),
                    r.z = 0) : (o.Matrix4x4.createRotationY(-r.y, o.Matrix4x4.TEMPMatrix0), o.Matrix4x4.createRotationX(-r.x, o.Matrix4x4.TEMPMatrix1),
                    a.transformCoordinate(E.TEMPVector32, o.Matrix4x4.TEMPMatrix0, E.TEMPVector32),
                    a.transformCoordinate(E.TEMPVector32, o.Matrix4x4.TEMPMatrix1, E.TEMPVector32),
                    r.z = E.arcTanAngle(t.y, -t.x)), r.y <= -Math.PI && (r.y = Math.PI), r.z <= -Math.PI && (r.z = Math.PI),
                r.y >= Math.PI && r.z >= Math.PI && (r.y = 0, r.z = 0, r.x = Math.PI - r.x);
            var i = e;
            i.x = r.y, i.y = r.x, i.z = r.z;
        }
        invert(e) {
            var t = this.x,
                r = this.y,
                i = this.z,
                n = this.w,
                a = t * t + r * r + i * i + n * n,
                s = a ? 1 / a : 0;
            e.x = -t * s, e.y = -r * s, e.z = -i * s, e.w = n * s;
        }
        identity() {
            this.x = 0, this.y = 0, this.z = 0, this.w = 1;
        }
        fromArray(e, t = 0) {
            this.x = e[t + 0], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3];
        }
        cloneTo(e) {
            this !== e && (e.x = this.x, e.y = this.y, e.z = this.z, e.w = this.w);
        }
        clone() {
            var e = new E();
            return this.cloneTo(e), e;
        }
        equals(e) {
            return r.nearEqual(this.x, e.x) && r.nearEqual(this.y, e.y) && r.nearEqual(this.z, e.z) && r.nearEqual(this.w, e.w);
        }
        static rotationLookAt(e, t, r) {
            E.lookAt(a._ZERO, e, t, r);
        }
        static lookAt(e, t, r, i) {
            f.lookAt(e, t, r, E._tempMatrix3x3), E.rotationMatrix(E._tempMatrix3x3, i);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static invert(e, t) {
            var i = e.lengthSquared();
            r.isZero(i) || (i = 1 / i, t.x = -e.x * i, t.y = -e.y * i, t.z = -e.z * i, t.w = e.w * i);
        }
        static rotationMatrix(e, t) {
            var r, i, n = e.elements,
                a = n[0],
                s = n[1],
                o = n[2],
                l = n[3],
                _ = n[4],
                h = n[5],
                c = n[6],
                d = n[7],
                u = n[8],
                f = a + _ + u;
            f > 0 ? (r = Math.sqrt(f + 1), t.w = .5 * r, r = .5 / r, t.x = (h - d) * r, t.y = (c - o) * r,
                t.z = (s - l) * r) : a >= _ && a >= u ? (i = .5 / (r = Math.sqrt(1 + a - _ - u)),
                t.x = .5 * r, t.y = (s + l) * i, t.z = (o + c) * i, t.w = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - a - u)),
                t.x = (l + s) * i, t.y = .5 * r, t.z = (d + h) * i, t.w = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - a - _)),
                t.x = (c + o) * i, t.y = (d + h) * i, t.z = .5 * r, t.w = (s - l) * i);
        }
        forNativeElement(e = null) {
            e ? (this.elements = e, this.elements[0] = this.x, this.elements[1] = this.y, this.elements[2] = this.z,
                    this.elements[3] = this.w) : this.elements = new Float32Array([this.x, this.y, this.z, this.w]),
                i.rewriteNumProperty(this, "x", 0), i.rewriteNumProperty(this, "y", 1), i.rewriteNumProperty(this, "z", 2),
                i.rewriteNumProperty(this, "w", 3);
        }
    }
    E.TEMPVector30 = new a(), E.TEMPVector31 = new a(), E.TEMPVector32 = new a(), E.TEMPVector33 = new a(),
        E._tempMatrix3x3 = new f(), E.DEFAULT = new E(), E.NAN = new E(NaN, NaN, NaN, NaN);
    class T {
        constructor(e = 1, t = 0, r = 0, i = 0, n = 0, a = 1, s = 0, o = 0, l = 0, _ = 0, h = 1, c = 0, d = 0, u = 0, f = 0, E = 1, T = null) {
            var m = this.elements = T || new Float32Array(16);
            m[0] = e, m[1] = t, m[2] = r, m[3] = i, m[4] = n, m[5] = a, m[6] = s, m[7] = o,
                m[8] = l, m[9] = _, m[10] = h, m[11] = c, m[12] = d, m[13] = u, m[14] = f, m[15] = E;
        }
        static createRotationX(e, t) {
            var r = t.elements,
                i = Math.sin(e),
                n = Math.cos(e);
            r[1] = r[2] = r[3] = r[4] = r[7] = r[8] = r[11] = r[12] = r[13] = r[14] = 0, r[0] = r[15] = 1,
                r[5] = r[10] = n, r[6] = i, r[9] = -i;
        }
        static createRotationY(e, t) {
            var r = t.elements,
                i = Math.sin(e),
                n = Math.cos(e);
            r[1] = r[3] = r[4] = r[6] = r[7] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[5] = r[15] = 1,
                r[0] = r[10] = n, r[2] = -i, r[8] = i;
        }
        static createRotationZ(e, t) {
            var r = t.elements,
                i = Math.sin(e),
                n = Math.cos(e);
            r[2] = r[3] = r[6] = r[7] = r[8] = r[9] = r[11] = r[12] = r[13] = r[14] = 0, r[10] = r[15] = 1,
                r[0] = r[5] = n, r[1] = i, r[4] = -i;
        }
        static createRotationYawPitchRoll(e, t, r, i) {
            E.createFromYawPitchRoll(e, t, r, T._tempQuaternion), T.createRotationQuaternion(T._tempQuaternion, i);
        }
        static createRotationAxis(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = Math.cos(t),
                o = Math.sin(t),
                l = i * i,
                _ = n * n,
                h = a * a,
                c = i * n,
                d = i * a,
                u = n * a,
                f = r.elements;
            f[3] = f[7] = f[11] = f[12] = f[13] = f[14] = 0, f[15] = 1, f[0] = l + s * (1 - l),
                f[1] = c - s * c + o * a, f[2] = d - s * d - o * n, f[4] = c - s * c - o * a, f[5] = _ + s * (1 - _),
                f[6] = u - s * u + o * i, f[8] = d - s * d + o * n, f[9] = u - s * u - o * i, f[10] = h + s * (1 - h);
        }
        setRotation(e) {
            var t = e.x,
                r = e.y,
                i = e.z,
                n = e.w,
                a = t * t,
                s = r * r,
                o = i * i,
                l = t * r,
                _ = i * n,
                h = i * t,
                c = r * n,
                d = r * i,
                u = t * n,
                f = this.elements;
            f[0] = 1 - 2 * (s + o), f[1] = 2 * (l + _), f[2] = 2 * (h - c), f[4] = 2 * (l - _),
                f[5] = 1 - 2 * (o + a), f[6] = 2 * (d + u), f[8] = 2 * (h + c), f[9] = 2 * (d - u),
                f[10] = 1 - 2 * (s + a);
        }
        setPosition(e) {
            var t = this.elements;
            t[12] = e.x, t[13] = e.y, t[14] = e.z;
        }
        static createRotationQuaternion(e, t) {
            var r = t.elements,
                i = e.x,
                n = e.y,
                a = e.z,
                s = e.w,
                o = i * i,
                l = n * n,
                _ = a * a,
                h = i * n,
                c = a * s,
                d = a * i,
                u = n * s,
                f = n * a,
                E = i * s;
            r[3] = r[7] = r[11] = r[12] = r[13] = r[14] = 0, r[15] = 1, r[0] = 1 - 2 * (l + _),
                r[1] = 2 * (h + c), r[2] = 2 * (d - u), r[4] = 2 * (h - c), r[5] = 1 - 2 * (_ + o),
                r[6] = 2 * (f + E), r[8] = 2 * (d + u), r[9] = 2 * (f - E), r[10] = 1 - 2 * (l + o);
        }
        static createTranslate(e, t) {
            var r = t.elements;
            r[4] = r[8] = r[1] = r[9] = r[2] = r[6] = r[3] = r[7] = r[11] = 0, r[0] = r[5] = r[10] = r[15] = 1,
                r[12] = e.x, r[13] = e.y, r[14] = e.z;
        }
        static createScaling(e, t) {
            var r = t.elements;
            r[0] = e.x, r[5] = e.y, r[10] = e.z, r[1] = r[4] = r[8] = r[12] = r[9] = r[13] = r[2] = r[6] = r[14] = r[3] = r[7] = r[11] = 0,
                r[15] = 1;
        }
        static multiply(e, t, r) {
            var i = t.elements,
                n = e.elements,
                a = r.elements,
                s = i[0],
                o = i[1],
                l = i[2],
                _ = i[3],
                h = i[4],
                c = i[5],
                d = i[6],
                u = i[7],
                f = i[8],
                E = i[9],
                T = i[10],
                m = i[11],
                p = i[12],
                g = i[13],
                S = i[14],
                v = i[15],
                R = n[0],
                A = n[1],
                D = n[2],
                I = n[3],
                x = n[4],
                M = n[5],
                L = n[6],
                C = n[7],
                y = n[8],
                O = n[9],
                N = n[10],
                P = n[11],
                V = n[12],
                w = n[13],
                b = n[14],
                F = n[15];
            a[0] = s * R + o * x + l * y + _ * V, a[1] = s * A + o * M + l * O + _ * w, a[2] = s * D + o * L + l * N + _ * b,
                a[3] = s * I + o * C + l * P + _ * F, a[4] = h * R + c * x + d * y + u * V, a[5] = h * A + c * M + d * O + u * w,
                a[6] = h * D + c * L + d * N + u * b, a[7] = h * I + c * C + d * P + u * F, a[8] = f * R + E * x + T * y + m * V,
                a[9] = f * A + E * M + T * O + m * w, a[10] = f * D + E * L + T * N + m * b, a[11] = f * I + E * C + T * P + m * F,
                a[12] = p * R + g * x + S * y + v * V, a[13] = p * A + g * M + S * O + v * w, a[14] = p * D + g * L + S * N + v * b,
                a[15] = p * I + g * C + S * P + v * F;
        }
        static multiplyForNative(e, r, i) {
            t.LayaGL.instance.matrix4x4Multiply(e.elements, r.elements, i.elements);
        }
        static createFromQuaternion(e, t) {
            var r = t.elements,
                i = e.x,
                n = e.y,
                a = e.z,
                s = e.w,
                o = i + i,
                l = n + n,
                _ = a + a,
                h = i * o,
                c = n * o,
                d = n * l,
                u = a * o,
                f = a * l,
                E = a * _,
                T = s * o,
                m = s * l,
                p = s * _;
            r[0] = 1 - d - E, r[1] = c + p, r[2] = u - m, r[3] = 0, r[4] = c - p, r[5] = 1 - h - E,
                r[6] = f + T, r[7] = 0, r[8] = u + m, r[9] = f - T, r[10] = 1 - h - d, r[11] = 0,
                r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1;
        }
        static createAffineTransformation(e, t, r, i) {
            var n = i.elements,
                a = t.x,
                s = t.y,
                o = t.z,
                l = t.w,
                _ = a + a,
                h = s + s,
                c = o + o,
                d = a * _,
                u = a * h,
                f = a * c,
                E = s * h,
                T = s * c,
                m = o * c,
                p = l * _,
                g = l * h,
                S = l * c,
                v = r.x,
                R = r.y,
                A = r.z;
            n[0] = (1 - (E + m)) * v, n[1] = (u + S) * v, n[2] = (f - g) * v, n[3] = 0, n[4] = (u - S) * R,
                n[5] = (1 - (d + m)) * R, n[6] = (T + p) * R, n[7] = 0, n[8] = (f + g) * A, n[9] = (T - p) * A,
                n[10] = (1 - (d + E)) * A, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1;
        }
        static createLookAt(e, t, r, i) {
            var n = i.elements,
                s = T._tempVector0,
                o = T._tempVector1,
                l = T._tempVector2;
            a.subtract(e, t, l), a.normalize(l, l), a.cross(r, l, s), a.normalize(s, s), a.cross(l, s, o),
                i.identity(), n[0] = s.x, n[4] = s.y, n[8] = s.z, n[1] = o.x, n[5] = o.y, n[9] = o.z,
                n[2] = l.x, n[6] = l.y, n[10] = l.z, n[12] = -a.dot(s, e), n[13] = -a.dot(o, e),
                n[14] = -a.dot(l, e);
        }
        static createPerspective(e, t, r, i, n) {
            var a = 1 / Math.tan(.5 * e),
                s = r / (a / t),
                o = r / a;
            T.createPerspectiveOffCenter(-s, s, -o, o, r, i, n);
        }
        static createPerspectiveOffCenter(e, t, r, i, n, a, s) {
            var o = s.elements,
                l = a / (a - n);
            o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[12] = o[13] = o[15] = 0, o[0] = 2 * n / (t - e),
                o[5] = 2 * n / (i - r), o[8] = (e + t) / (t - e), o[9] = (i + r) / (i - r), o[10] = -l,
                o[11] = -1, o[14] = -n * l;
        }
        static createOrthoOffCenter(e, t, r, i, n, a, s) {
            var o = s.elements,
                l = 1 / (a - n);
            o[1] = o[2] = o[3] = o[4] = o[6] = o[8] = o[7] = o[9] = o[11] = 0, o[15] = 1, o[0] = 2 / (t - e),
                o[5] = 2 / (i - r), o[10] = -l, o[12] = (e + t) / (e - t), o[13] = (i + r) / (r - i),
                o[14] = -n * l;
        }
        getElementByRowColumn(e, t) {
            if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            return this.elements[4 * e + t];
        }
        setElementByRowColumn(e, t, r) {
            if (e < 0 || e > 3) throw new Error("row Rows and columns for matrices run from 0 to 3, inclusive.");
            if (t < 0 || t > 3) throw new Error("column Rows and columns for matrices run from 0 to 3, inclusive.");
            this.elements[4 * e + t] = r;
        }
        equalsOtherMatrix(e) {
            var t = this.elements,
                i = e.elements;
            return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]) && r.nearEqual(t[4], i[4]) && r.nearEqual(t[5], i[5]) && r.nearEqual(t[6], i[6]) && r.nearEqual(t[7], i[7]) && r.nearEqual(t[8], i[8]) && r.nearEqual(t[9], i[9]) && r.nearEqual(t[10], i[10]) && r.nearEqual(t[11], i[11]) && r.nearEqual(t[12], i[12]) && r.nearEqual(t[13], i[13]) && r.nearEqual(t[14], i[14]) && r.nearEqual(t[15], i[15]);
        }
        decomposeTransRotScale(e, t, r) {
            var i = T._tempMatrix4x4;
            return this.decomposeTransRotMatScale(e, i, r) ? (E.createFromMatrix4x4(i, t), !0) : (t.identity(), !1);
        }
        decomposeTransRotMatScale(e, t, i) {
            var n = this.elements,
                s = e,
                o = t.elements,
                l = i;
            s.x = n[12], s.y = n[13], s.z = n[14];
            var _ = n[0],
                h = n[1],
                c = n[2],
                d = n[4],
                u = n[5],
                f = n[6],
                E = n[8],
                m = n[9],
                p = n[10],
                g = l.x = Math.sqrt(_ * _ + h * h + c * c),
                S = l.y = Math.sqrt(d * d + u * u + f * f),
                v = l.z = Math.sqrt(E * E + m * m + p * p);
            if (r.isZero(g) || r.isZero(S) || r.isZero(v)) return o[1] = o[2] = o[3] = o[4] = o[6] = o[7] = o[8] = o[9] = o[11] = o[12] = o[13] = o[14] = 0,
                o[0] = o[5] = o[10] = o[15] = 1, !1;
            var R = T._tempVector0;
            R.x = E / v, R.y = m / v, R.z = p / v;
            var A = T._tempVector1;
            A.x = _ / g, A.y = h / g, A.z = c / g;
            var D = T._tempVector2;
            a.cross(R, A, D);
            var I = T._tempVector1;
            return a.cross(D, R, I), o[3] = o[7] = o[11] = o[12] = o[13] = o[14] = 0, o[15] = 1,
                o[0] = I.x, o[1] = I.y, o[2] = I.z, o[4] = D.x, o[5] = D.y, o[6] = D.z, o[8] = R.x,
                o[9] = R.y, o[10] = R.z, o[0] * _ + o[1] * h + o[2] * c < 0 && (l[0] = -g), o[4] * d + o[5] * u + o[6] * f < 0 && (l[1] = -S),
                o[8] * E + o[9] * m + o[10] * p < 0 && (l[2] = -v), !0;
        }
        decomposeYawPitchRoll(e) {
            var t = Math.asin(-this.elements[9]);
            e.y = t, Math.cos(t) > r.zeroTolerance ? (e.z = Math.atan2(this.elements[1], this.elements[5]),
                e.x = Math.atan2(this.elements[8], this.elements[10])) : (e.z = Math.atan2(-this.elements[4], this.elements[0]),
                e.x = 0);
        }
        normalize() {
            var e = this.elements,
                t = e[0],
                r = e[1],
                i = e[2],
                n = Math.sqrt(t * t + r * r + i * i);
            if (!n) return e[0] = 0, e[1] = 0, void(e[2] = 0);
            1 != n && (n = 1 / n, e[0] = t * n, e[1] = r * n, e[2] = i * n);
        }
        transpose() {
            var e, t;
            return t = (e = this.elements)[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8],
                e[8] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[7],
                e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        invert(e) {
            var t = this.elements,
                r = e.elements,
                i = t[0],
                n = t[1],
                a = t[2],
                s = t[3],
                o = t[4],
                l = t[5],
                _ = t[6],
                h = t[7],
                c = t[8],
                d = t[9],
                u = t[10],
                f = t[11],
                E = t[12],
                T = t[13],
                m = t[14],
                p = t[15],
                g = i * l - n * o,
                S = i * _ - a * o,
                v = i * h - s * o,
                R = n * _ - a * l,
                A = n * h - s * l,
                D = a * h - s * _,
                I = c * T - d * E,
                x = c * m - u * E,
                M = c * p - f * E,
                L = d * m - u * T,
                C = d * p - f * T,
                y = u * p - f * m,
                O = g * y - S * C + v * L + R * M - A * x + D * I;
            0 !== Math.abs(O) && (O = 1 / O, r[0] = (l * y - _ * C + h * L) * O, r[1] = (a * C - n * y - s * L) * O,
                r[2] = (T * D - m * A + p * R) * O, r[3] = (u * A - d * D - f * R) * O, r[4] = (_ * M - o * y - h * x) * O,
                r[5] = (i * y - a * M + s * x) * O, r[6] = (m * v - E * D - p * S) * O, r[7] = (c * D - u * v + f * S) * O,
                r[8] = (o * C - l * M + h * I) * O, r[9] = (n * M - i * C - s * I) * O, r[10] = (E * A - T * v + p * g) * O,
                r[11] = (d * v - c * A - f * g) * O, r[12] = (l * x - o * L - _ * I) * O, r[13] = (i * L - n * x + a * I) * O,
                r[14] = (T * S - E * R - m * g) * O, r[15] = (c * R - d * S + u * g) * O);
        }
        static billboard(e, t, i, n, s, o) {
            a.subtract(e, t, T._tempVector0);
            var l = a.scalarLengthSquared(T._tempVector0);
            r.isZero(l) ? (a.scale(s, -1, T._tempVector1), T._tempVector1.cloneTo(T._tempVector0)) : a.scale(T._tempVector0, 1 / Math.sqrt(l), T._tempVector0),
                a.cross(n, T._tempVector0, T._tempVector2), a.normalize(T._tempVector2, T._tempVector2),
                a.cross(T._tempVector0, T._tempVector2, T._tempVector3);
            var _ = T._tempVector2,
                h = T._tempVector3,
                c = T._tempVector0,
                d = e,
                u = o.elements;
            u[0] = _.x, u[1] = _.y, u[2] = _.z, u[3] = 0, u[4] = h.x, u[5] = h.y, u[6] = h.z,
                u[7] = 0, u[8] = c.x, u[9] = c.y, u[10] = c.z, u[11] = 0, u[12] = d.x, u[13] = d.y,
                u[14] = d.z, u[15] = 1;
        }
        identity() {
            var e = this.elements;
            e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                e[0] = e[5] = e[10] = e[15] = 1;
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements))
                for (t = 0; t < 16; ++t) i[t] = r[t];
        }
        clone() {
            var e = new T();
            return this.cloneTo(e), e;
        }
        static translation(e, t) {
            var r = t.elements;
            r[0] = r[5] = r[10] = r[15] = 1, r[12] = e.x, r[13] = e.y, r[14] = e.z;
        }
        getTranslationVector(e) {
            var t = this.elements;
            e.x = t[12], e.y = t[13], e.z = t[14];
        }
        setTranslationVector(e) {
            var t = this.elements,
                r = e;
            t[12] = r.x, t[13] = r.y, t[14] = r.z;
        }
        getForward(e) {
            var t = this.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }
        setForward(e) {
            var t = this.elements;
            t[8] = -e.x, t[9] = -e.y, t[10] = -e.z;
        }
    }
    T._tempMatrix4x4 = new T(), T.TEMPMatrix0 = new T(), T.TEMPMatrix1 = new T(), T._tempVector0 = new a(),
        T._tempVector1 = new a(), T._tempVector2 = new a(), T._tempVector3 = new a(), T._tempQuaternion = new E(),
        T.DEFAULT = new T(), T.ZERO = new T(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    class m {
        constructor() {
            this.value = 0;
        }
        add(e) {
            this.value |= e;
        }
        remove(e) {
            this.value &= ~e;
        }
        has(e) {
            return (this.value & e) > 0;
        }
        cloneTo(e) {
            e.value = this.value;
        }
        clone() {
            var e = new m();
            return this.cloneTo(e), e;
        }
    }
    class p {
        constructor(e = null) {
            this._ownerResource = null, this._data = null, this._defineDatas = new m(), this._runtimeCopyValues = [],
                this._ownerResource = e, this._initData();
        }
        _initData() {
            this._data = new Object();
        }
        getData() {
            return this._data;
        }
        addDefine(e) {
            this._defineDatas.add(e);
        }
        removeDefine(e) {
            this._defineDatas.remove(e);
        }
        hasDefine(e) {
            return (this._defineDatas.value & e) > 0;
        }
        clearDefine() {
            this._defineDatas.value = 0;
        }
        getBool(e) {
            return this._data[e];
        }
        setBool(e, t) {
            this._data[e] = t;
        }
        getInt(e) {
            return this._data[e];
        }
        setInt(e, t) {
            this._data[e] = t;
        }
        getNumber(e) {
            return this._data[e];
        }
        setNumber(e, t) {
            this._data[e] = t;
        }
        getVector2(e) {
            return this._data[e];
        }
        setVector2(e, t) {
            this._data[e] = t;
        }
        getVector3(e) {
            return this._data[e];
        }
        setVector3(e, t) {
            this._data[e] = t;
        }
        getVector(e) {
            return this._data[e];
        }
        setVector(e, t) {
            this._data[e] = t;
        }
        getQuaternion(e) {
            return this._data[e];
        }
        setQuaternion(e, t) {
            this._data[e] = t;
        }
        getMatrix4x4(e) {
            return this._data[e];
        }
        setMatrix4x4(e, t) {
            this._data[e] = t;
        }
        getBuffer(e) {
            return this._data[e];
        }
        setBuffer(e, t) {
            this._data[e] = t;
        }
        setTexture(e, t) {
            var r = this._data[e];
            this._data[e] = t, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                t && t._addReference());
        }
        getTexture(e) {
            return this._data[e];
        }
        setAttribute(e, t) {
            this._data[e] = t;
        }
        getAttribute(e) {
            return this._data[e];
        }
        getLength() {
            return this._data.length;
        }
        setLength(e) {
            this._data.length = e;
        }
        cloneTo(e) {
            var r = e,
                s = r._data;
            for (var o in this._data) {
                var l = this._data[o];
                if (null != l)
                    if ("number" == typeof l) s[o] = l;
                    else if ("number" == typeof l) s[o] = l;
                else if ("boolean" == typeof l) s[o] = l;
                else if (l instanceof i) {
                    var _ = s[o] || (s[o] = new i());
                    l.cloneTo(_), s[o] = _;
                } else if (l instanceof a) {
                    var h = s[o] || (s[o] = new a());
                    l.cloneTo(h), s[o] = h;
                } else if (l instanceof n) {
                    var c = s[o] || (s[o] = new n());
                    l.cloneTo(c), s[o] = c;
                } else if (l instanceof T) {
                    var d = s[o] || (s[o] = new T());
                    l.cloneTo(d), s[o] = d;
                } else l instanceof t.BaseTexture && (s[o] = l);
            }
            this._defineDatas.cloneTo(r._defineDatas);
        }
        clone() {
            var e = new p();
            return this.cloneTo(e), e;
        }
        cloneToForNative(e) {
            var r = e;
            this._int32Data.length - r._int32Data.length > 0 && r.needRenewArrayBufferForNative(this._int32Data.length),
                r._int32Data.set(this._int32Data, 0);
            var s = r._nativeArray,
                o = this._nativeArray.length;
            s.length = o;
            for (var l = 0; l < o; l++) {
                var _ = this._nativeArray[l];
                if (_)
                    if ("number" == typeof _) s[l] = _, r.setNumber(l, _);
                    else if ("number" == typeof _) s[l] = _,
                    r.setInt(l, _);
                else if ("boolean" == typeof _) s[l] = _, r.setBool(l, _);
                else if (_ instanceof i) {
                    var h = s[l] || (s[l] = new i());
                    _.cloneTo(h), s[l] = h, r.setVector2(l, h);
                } else if (_ instanceof a) {
                    var c = s[l] || (s[l] = new a());
                    _.cloneTo(c), s[l] = c, r.setVector3(l, c);
                } else if (_ instanceof n) {
                    var d = s[l] || (s[l] = new n());
                    _.cloneTo(d), s[l] = d, r.setVector(l, d);
                } else if (_ instanceof T) {
                    var u = s[l] || (s[l] = new T());
                    _.cloneTo(u), s[l] = u, r.setMatrix4x4(l, u);
                } else _ instanceof t.BaseTexture && (s[l] = _, r.setTexture(l, _));
            }
            this._defineDatas.cloneTo(r._defineDatas);
        }
        _initDataForNative() {
            this._frameCount = -1, this._runtimeCopyValues.length = 0, this._nativeArray = [],
                this._data = new ArrayBuffer(32), this._int32Data = new Int32Array(this._data),
                this._float32Data = new Float32Array(this._data), t.LayaGL.instance.createArrayBufferRef(this._data, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0);
        }
        needRenewArrayBufferForNative(e) {
            if (e >= this._int32Data.length) {
                var t = 4 * (e + 1),
                    r = this._int32Data,
                    i = this._data.conchRef,
                    n = this._data._ptrID;
                this._data = new ArrayBuffer(t), this._int32Data = new Int32Array(this._data), this._float32Data = new Float32Array(this._data),
                    this._data.conchRef = i, this._data._ptrID = n, r && this._int32Data.set(r, 0),
                    window.conch.updateArrayBufferRef(this._data._ptrID, i.isSyncToRender(), this._data);
            }
        }
        getDataForNative() {
            return this._nativeArray;
        }
        getIntForNative(e) {
            return this._int32Data[e];
        }
        setIntForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t, this._nativeArray[e] = t;
        }
        getBoolForNative(e) {
            return 1 == this._int32Data[e];
        }
        setBoolForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._int32Data[e] = t ? 1 : 0, this._nativeArray[e] = t;
        }
        getNumberForNative(e) {
            return this._float32Data[e];
        }
        setNumberForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._float32Data[e] = t, this._nativeArray[e] = t;
        }
        getMatrix4x4ForNative(e) {
            return this._nativeArray[e];
        }
        setMatrix4x4ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVectorForNative(e) {
            return this._nativeArray[e];
        }
        setVectorForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVector2ForNative(e) {
            return this._nativeArray[e];
        }
        setVector2ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getVector3ForNative(e) {
            return this._nativeArray[e];
        }
        setVector3ForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getQuaternionForNative(e) {
            return this._nativeArray[e];
        }
        setQuaternionForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t, t.elements || t.forNativeElement();
            var r = this.setReferenceForNative(t.elements);
            this._int32Data[e] = r;
        }
        getBufferForNative(e) {
            return this._nativeArray[e];
        }
        setBufferForNative(e, t) {
            this.needRenewArrayBufferForNative(e), this._nativeArray[e] = t;
            var r = this.setReferenceForNative(t);
            this._int32Data[e] = r;
        }
        getAttributeForNative(e) {
            return this._nativeArray[e];
        }
        setAttributeForNative(e, r) {
            this._nativeArray[e] = r, r._ptrID || t.LayaGL.instance.createArrayBufferRef(r, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0),
                t.LayaGL.instance.syncBufferToRenderThread(r), this._int32Data[e] = r._ptrID;
        }
        getTextureForNative(e) {
            return this._nativeArray[e];
        }
        setTextureForNative(e, t) {
            if (t) {
                this.needRenewArrayBufferForNative(e);
                var r = this._nativeArray[e];
                this._nativeArray[e] = t, this._int32Data[e] = t._glTexture.id, this._ownerResource && this._ownerResource.referenceCount > 0 && (r && r._removeReference(),
                    t && t._addReference());
            }
        }
        setReferenceForNative(e) {
            this.clearRuntimeCopyArray();
            var r = 0,
                i = 0;
            return p._SET_RUNTIME_VALUE_MODE_REFERENCE_ ? (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_REFERENCE),
                r = 0, i = e.getPtrID(r)) : (t.LayaGL.instance.createArrayBufferRefs(e, t.LayaGL.ARRAY_BUFFER_TYPE_DATA, !0, t.LayaGL.ARRAY_BUFFER_REF_COPY),
                r = e.getRefNum() - 1, i = e.getPtrID(r), this._runtimeCopyValues.push({
                    obj: e,
                    refID: r,
                    ptrID: i
                })), t.LayaGL.instance.syncBufferToRenderThread(e, r), i;
        }
        static setRuntimeValueMode(e) {
            p._SET_RUNTIME_VALUE_MODE_REFERENCE_ = e;
        }
        clearRuntimeCopyArray() {
            var e = t.LayaGL.instance.getFrameCount();
            if (this._frameCount != e) {
                this._frameCount = e;
                for (var r = 0, i = this._runtimeCopyValues.length; r < i; r++) {
                    this._runtimeCopyValues[r].obj.clearRefNum();
                }
                this._runtimeCopyValues.length = 0;
            }
        }
    }
    p._SET_RUNTIME_VALUE_MODE_REFERENCE_ = !0;
    class g {
        constructor(e, t) {
            this._id = ++g._uniqueIDCounter, this._vertexElementsDic = {}, this._vertexStride = e,
                this._vertexElements = t;
            var r = t.length;
            this._shaderValues = new p(null);
            for (var i = 0; i < r; i++) {
                var n = t[i],
                    a = n._elementUsage;
                this._vertexElementsDic[a] = n;
                var s = new Int32Array(5),
                    o = u.getElementInfos(n._elementFormat);
                s[0] = o[0], s[1] = o[1], s[2] = o[2], s[3] = this._vertexStride, s[4] = n._offset,
                    this._shaderValues.setAttribute(a, s);
            }
        }
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        getVertexElementByIndex(e) {
            return this._vertexElements[e];
        }
        getVertexElementByUsage(e) {
            return this._vertexElementsDic[e];
        }
    }
    g._uniqueIDCounter = 1;
    class S {
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
        constructor(e, t, r) {
            this._offset = e, this._elementFormat = t, this._elementUsage = r;
        }
    }
    class v {
        static __init__() {
            v.instanceWorldMatrixDeclaration = new g(64, [new S(0, u.Vector4, v.MESH_WORLDMATRIX_ROW0), new S(16, u.Vector4, v.MESH_WORLDMATRIX_ROW1), new S(32, u.Vector4, v.MESH_WORLDMATRIX_ROW2), new S(48, u.Vector4, v.MESH_WORLDMATRIX_ROW3)]),
                v.instanceMVPMatrixDeclaration = new g(64, [new S(0, u.Vector4, v.MESH_MVPMATRIX_ROW0), new S(16, u.Vector4, v.MESH_MVPMATRIX_ROW1), new S(32, u.Vector4, v.MESH_MVPMATRIX_ROW2), new S(48, u.Vector4, v.MESH_MVPMATRIX_ROW3)]);
        }
        static getVertexDeclaration(e, t = !0) {
            var r = v._vertexDeclarationMap[e + (t ? "_0" : "_1")];
            if (!r) {
                for (var i = e.split(","), n = 0, a = [], s = 0, o = i.length; s < o; s++) {
                    var l;
                    switch (i[s]) {
                        case "POSITION":
                            l = new S(n, u.Vector3, v.MESH_POSITION0), n += 12;
                            break;

                        case "NORMAL":
                            l = new S(n, u.Vector3, v.MESH_NORMAL0), n += 12;
                            break;

                        case "COLOR":
                            l = new S(n, u.Vector4, v.MESH_COLOR0), n += 16;
                            break;

                        case "UV":
                            l = new S(n, u.Vector2, v.MESH_TEXTURECOORDINATE0), n += 8;
                            break;

                        case "UV1":
                            l = new S(n, u.Vector2, v.MESH_TEXTURECOORDINATE1), n += 8;
                            break;

                        case "BLENDWEIGHT":
                            l = new S(n, u.Vector4, v.MESH_BLENDWEIGHT0), n += 16;
                            break;

                        case "BLENDINDICES":
                            t ? (l = new S(n, u.Vector4, v.MESH_BLENDINDICES0), n += 16) : (l = new S(n, u.Byte4, v.MESH_BLENDINDICES0),
                                n += 4);
                            break;

                        case "TANGENT":
                            l = new S(n, u.Vector4, v.MESH_TANGENT0), n += 16;
                            break;

                        default:
                            throw "VertexMesh: unknown vertex flag.";
                    }
                    a.push(l);
                }
                r = new g(n, a), v._vertexDeclarationMap[e + (t ? "_0" : "_1")] = r;
            }
            return r;
        }
    }
    v.MESH_POSITION0 = 0, v.MESH_COLOR0 = 1, v.MESH_TEXTURECOORDINATE0 = 2, v.MESH_NORMAL0 = 3,
        v.MESH_TANGENT0 = 4, v.MESH_BLENDINDICES0 = 5, v.MESH_BLENDWEIGHT0 = 6, v.MESH_TEXTURECOORDINATE1 = 7,
        v.MESH_WORLDMATRIX_ROW0 = 8, v.MESH_WORLDMATRIX_ROW1 = 9, v.MESH_WORLDMATRIX_ROW2 = 10,
        v.MESH_WORLDMATRIX_ROW3 = 11, v.MESH_MVPMATRIX_ROW0 = 12, v.MESH_MVPMATRIX_ROW1 = 13,
        v.MESH_MVPMATRIX_ROW2 = 14, v.MESH_MVPMATRIX_ROW3 = 15, v._vertexDeclarationMap = {};
    class R extends h {
        constructor() {
            super(), this._bufferState = new _();
            var e = t.LayaGL.instance,
                r = v.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT").vertexStride * R.maxIndicesCount;
            this._vertices = new Float32Array(r / 4), this._vertexBuffer = new d(r, e.DYNAMIC_DRAW),
                this._indices = new Int16Array(R.maxIndicesCount), this._indexBuffer = new c(c.INDEXTYPE_USHORT, this._indices.length, e.DYNAMIC_DRAW);
            var i = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addMemory(i, i);
        }
        static __init__() {
            R.instance = new R();
        }
        _getBatchVertices(e, t, r, i, n, a) {
            var s = e.vertexStride / 4,
                o = a._vertexBuffer.getFloat32Data(),
                l = (n.render.lightmapScaleOffset,
                    n._dynamicMultiSubMesh),
                _ = n._dynamicVertexCount;
            n._computeWorldPositionsAndNormals(this._positionOffset, this._normalOffset, l, _);
            for (var h = n._dynamicWorldPositions, c = n._dynamicWorldNormals, d = a._indices, u = 0; u < _; u++) {
                var f = (l ? d[u] : u) * s,
                    E = (u + r) * s,
                    T = 3 * u,
                    m = E + this._positionOffset;
                t[m] = h[T], t[m + 1] = h[T + 1], t[m + 2] = h[T + 2], -1 !== this._normalOffset && (t[m = E + this._normalOffset] = c[T],
                    t[m + 1] = c[T + 1], t[m + 2] = c[T + 2]), -1 !== this._colorOffset && (m = E + this._colorOffset,
                    T = f + this._colorOffset, t[m] = o[T], t[m + 1] = o[T + 1], t[m + 2] = o[T + 2],
                    t[m + 3] = o[T + 3]), -1 !== this._uv0Offset && (m = E + this._uv0Offset, T = f + this._uv0Offset,
                    t[m] = o[T], t[m + 1] = o[T + 1]), -1 !== this._sTangentOffset && (m = E + this._sTangentOffset,
                    T = f + this._sTangentOffset, t[m] = o[T], t[m + 1] = o[T + 1], t[m + 2] = o[T + 2],
                    t[m + 3] = o[T + 3], m = E + this._sTangentOffset, T = f + this._sTangentOffset,
                    t[m] = o[T], t[m + 1] = o[T + 1], t[m + 2] = o[T + 2], t[m + 3] = o[T + 3]);
            }
        }
        _getBatchIndices(e, t, r, i, n, a) {
            var s, o, l, _ = n._indices,
                h = i._isFrontFaceInvert;
            if (a)
                if (h)
                    for (s = 0, o = _.length; s < o; s += 3) {
                        var c = r + s;
                        e[l = t + s] = c, e[l + 1] = c + 2, e[l + 2] = c + 1;
                    } else
                        for (s = o, o = _.length; s < o; s += 3) c = r + s, e[l = t + s] = c, e[l + 1] = c + 1,
                            e[l + 2] = c + 2;
                else if (h)
                for (s = 0, o = _.length; s < o; s += 3) e[l = t + s] = r + _[s],
                    e[l + 1] = r + _[s + 2], e[l + 2] = r + _[s + 1];
            else
                for (s = o, o = _.length; s < o; s += 3) e[l = t + s] = r + _[s],
                    e[l + 1] = r + _[s + 1], e[l + 2] = r + _[s + 2];
        }
        _flush(e, r) {
            var i = t.LayaGL.instance;
            this._vertexBuffer.setData(this._vertices.buffer, 0, 0, e * this._vertexBuffer.vertexDeclaration.vertexStride),
                this._indexBuffer.setData(this._indices, 0, 0, r), i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0);
        }
        _prepareRender(e) {
            var t = e.renderElement.vertexBatchVertexDeclaration;
            this._bufferState = o.MeshRenderDynamicBatchManager.instance._getBufferState(t),
                this._positionOffset = t.getVertexElementByUsage(v.MESH_POSITION0)._offset / 4;
            var r = t.getVertexElementByUsage(v.MESH_NORMAL0);
            this._normalOffset = r ? r._offset / 4 : -1;
            var i = t.getVertexElementByUsage(v.MESH_COLOR0);
            this._colorOffset = i ? i._offset / 4 : -1;
            var n = t.getVertexElementByUsage(v.MESH_TEXTURECOORDINATE0);
            this._uv0Offset = n ? n._offset / 4 : -1;
            var a = t.getVertexElementByUsage(v.MESH_TEXTURECOORDINATE1);
            this._uv1Offset = a ? a._offset / 4 : -1;
            var s = t.getVertexElementByUsage(v.MESH_TANGENT0);
            return this._sTangentOffset = s ? s._offset / 4 : -1, !0;
        }
        _render(e) {
            this._bufferState.bind();
            for (var r = e.renderElement, i = r.vertexBatchVertexDeclaration, n = r.vertexBatchElementList, a = 0, s = 0, o = (i.vertexStride,
                    0), l = n.length, _ = 0; _ < l; _++) {
                var h = n[_],
                    c = h._geometry,
                    d = c._indexCount;
                s + d > R.maxIndicesCount && (this._flush(a, s), o++, t.Stat.trianglesFaces += s / 3,
                    a = s = 0);
                var u = h._transform;
                this._getBatchVertices(i, this._vertices, a, u, h, c), this._getBatchIndices(this._indices, s, a, u, c, h._dynamicMultiSubMesh),
                    a += h._dynamicVertexCount, s += d;
            }
            this._flush(a, s), o++, t.Stat.renderBatches += o, t.Stat.savedRenderBatches += l - o,
                t.Stat.trianglesFaces += s / 3;
        }
    }
    R.maxAllowVertexCount = 10, R.maxAllowAttribueCount = 900, R.maxIndicesCount = 32e3;
    class A {
        constructor() {
            this.updateMark = -1, this.indexInList = -1, this.batched = !1;
        }
    }
    class D extends h {
        constructor() {
            super(), this.maxInstanceCount = 1024, this.instanceWorldMatrixData = new Float32Array(16 * this.maxInstanceCount),
                this.instanceMVPMatrixData = new Float32Array(16 * this.maxInstanceCount);
            var e = t.LayaGL.instance;
            this.instanceWorldMatrixBuffer = new d(4 * this.instanceWorldMatrixData.length, e.DYNAMIC_DRAW),
                this.instanceMVPMatrixBuffer = new d(4 * this.instanceMVPMatrixData.length, e.DYNAMIC_DRAW),
                this.instanceWorldMatrixBuffer.vertexDeclaration = v.instanceWorldMatrixDeclaration,
                this.instanceMVPMatrixBuffer.vertexDeclaration = v.instanceMVPMatrixDeclaration;
        }
        static __init__() {
            D.instance = new D();
        }
        _render(e) {
            var r = t.LayaGL.instance,
                i = e.renderElement,
                n = i.instanceSubMesh,
                a = i.instanceBatchElementList.length,
                s = n._indexCount;
            n._mesh._instanceBufferState.bind(), t.LayaGL.layaGPUInstance.drawElementsInstanced(r.TRIANGLES, s, r.UNSIGNED_SHORT, 2 * n._indexStart, a),
                t.Stat.renderBatches++, t.Stat.savedRenderBatches += a - 1, t.Stat.trianglesFaces += s * a / 3;
        }
    }
    class I {
        constructor(e = 1, t = 1, r = 1, i = 1) {
            this.r = e, this.g = t, this.b = r, this.a = i;
        }
        static gammaToLinearSpace(e) {
            return e <= .04045 ? e / 12.92 : e < 1 ? Math.pow((e + .055) / 1.055, 2.4) : Math.pow(e, 2.4);
        }
        static linearToGammaSpace(e) {
            return e <= 0 ? 0 : e <= .0031308 ? 12.92 * e : e <= 1 ? 1.055 * Math.pow(e, .41666) - .055 : Math.pow(e, .41666);
        }
        toLinear(e) {
            e.r = I.gammaToLinearSpace(this.r), e.g = I.gammaToLinearSpace(this.g), e.b = I.gammaToLinearSpace(this.b);
        }
        toGamma(e) {
            e.r = I.linearToGammaSpace(this.r), e.g = I.linearToGammaSpace(this.g), e.b = I.linearToGammaSpace(this.b);
        }
        cloneTo(e) {
            var t = e;
            t.r = this.r, t.g = this.g, t.b = this.b, t.a = this.a;
        }
        clone() {
            var e = new I();
            return this.cloneTo(e), e;
        }
        forNativeElement() {}
    }
    I.RED = new I(1, 0, 0, 1), I.GREEN = new I(0, 1, 0, 1), I.BLUE = new I(0, 0, 1, 1),
        I.CYAN = new I(0, 1, 1, 1), I.YELLOW = new I(1, .92, .016, 1), I.MAGENTA = new I(1, 0, 1, 1),
        I.GRAY = new I(.5, .5, .5, 1), I.WHITE = new I(1, 1, 1, 1), I.BLACK = new I(0, 0, 0, 1);
    class x {
        constructor() {}
        static lightAttenTexture(e, t, r, i, n, a) {
            var s = e / r,
                o = 1 / (1 + 25 * s);
            s >= .64 && (s > 1 ? o = 0 : o *= 1 - (s - .64) / .36), a[n] = Math.floor(255 * o + .5);
        }
        static haloTexture(e, t, r, i, n, a) {
            var s = (e - (r >>= 1)) / r,
                o = (t - (i >>= 1)) / i,
                l = s * s + o * o;
            l > 1 && (l = 1), a[n] = Math.floor(255 * (1 - l) + .5);
        }
        static _generateTexture2D(e, r, i, n) {
            var a = 0,
                s = 0;
            switch (e.format) {
                case t.BaseTexture.FORMAT_R8G8B8:
                    s = 3;
                    break;

                case t.BaseTexture.FORMAT_R8G8B8A8:
                    s = 4;
                    break;

                case t.BaseTexture.FORMAT_ALPHA8:
                    s = 1;
                    break;

                default:
                    throw "GeneratedTexture._generateTexture: unkonw texture format.";
            }
            for (var o = new Uint8Array(r * i * s), l = 0; l < i; l++)
                for (var _ = 0; _ < r; _++) n(_, l, r, i, a, o),
                    a += s;
            e.setPixels(o);
        }
    }
    class M {
        static _convertToLayaVec3(e, t, r) {
            t.x = r ? -e.x() : e.x(), t.y = e.y(), t.z = e.z();
        }
        static _convertToBulletVec3(e, t, r) {
            t.setValue(r ? -e.x : e.x, e.y, e.z);
        }
        static _rotationTransformScaleSkinAnimation(e, t, r, i, n, a, s, o, l, _, h, c) {
            var d, u, f, E, T, m = M._tempArray16_0,
                p = M._tempArray16_1,
                g = M._tempArray16_2,
                S = i + i,
                v = n + n,
                R = a + a,
                A = i * S,
                D = n * S,
                I = n * v,
                x = a * S,
                L = a * v,
                C = a * R,
                y = s * S,
                O = s * v,
                N = s * R;
            for (m[15] = 1, m[0] = 1 - I - C, m[1] = D + N, m[2] = x - O, m[4] = D - N, m[5] = 1 - A - C,
                m[6] = L + y, m[8] = x + O, m[9] = L - y, m[10] = 1 - A - I, p[15] = 1, p[0] = o,
                p[5] = l, p[10] = _, d = 0; d < 4; d++) u = m[d], f = m[d + 4], E = m[d + 8], T = m[d + 12],
                g[d] = u, g[d + 4] = f, g[d + 8] = E, g[d + 12] = u * e + f * t + E * r + T;
            for (d = 0; d < 4; d++) u = g[d], f = g[d + 4], E = g[d + 8], T = g[d + 12], h[d + c] = u * p[0] + f * p[1] + E * p[2] + T * p[3],
                h[d + c + 4] = u * p[4] + f * p[5] + E * p[6] + T * p[7], h[d + c + 8] = u * p[8] + f * p[9] + E * p[10] + T * p[11],
                h[d + c + 12] = u * p[12] + f * p[13] + E * p[14] + T * p[15];
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxix(e, t, r, i, n, a) {
            var s, o, l = 0,
                _ = 0,
                h = e.length;
            for (s = 0; s < h; l += e[s].keyframeWidth, _ += 16, s++) M._rotationTransformScaleSkinAnimation(t[l + 0], t[l + 1], t[l + 2], t[l + 3], t[l + 4], t[l + 5], t[l + 6], t[l + 7], t[l + 8], t[l + 9], i, _),
                0 != s && (o = 16 * e[s].parentIndex, M.mulMatrixByArray(i, o, i, _, i, _));
            var c = r.length;
            for (s = 0; s < c; s++) M.mulMatrixByArrayAndMatrixFast(i, 16 * a[s], r[s], n, 16 * s);
        }
        static _computeAnimationDatasByArrayAndMatrixFast(e, t, r, i) {
            for (var n = 0, a = e.length; n < a; n++) M.mulMatrixByArrayAndMatrixFast(t, 16 * i[n], e[n], r, 16 * n);
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(e, t, r, i, n) {
            var a, s, o = 0,
                l = 0,
                _ = e.length;
            for (a = 0; a < _; o += e[a].keyframeWidth, l += 16, a++) M._rotationTransformScaleSkinAnimation(t[o + 7], t[o + 8], t[o + 9], t[o + 3], t[o + 4], t[o + 5], t[o + 6], t[o + 0], t[o + 1], t[o + 2], i, l),
                0 != a && (s = 16 * e[a].parentIndex, M.mulMatrixByArray(i, s, i, l, i, l));
            var h = r.length;
            for (a = 0; a < h; a++) {
                var c = 16 * a;
                M.mulMatrixByArrayAndMatrixFast(i, c, r[a], n, c);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFastOld(e, t, r) {
            for (var i = e.length, n = 0; n < i; n++) {
                var a = 16 * n;
                M.mulMatrixByArrayAndMatrixFast(t, a, e[n], r, a);
            }
        }
        static _computeRootAnimationData(e, t, r) {
            for (var i = 0, n = 0, a = 0, s = e.length; i < s; n += e[i].keyframeWidth, a += 16,
                i++) M.createAffineTransformationArray(t[n + 0], t[n + 1], t[n + 2], t[n + 3], t[n + 4], t[n + 5], t[n + 6], t[n + 7], t[n + 8], t[n + 9], r, a);
        }
        static transformVector3ArrayByQuat(e, t, r, i, n) {
            var a = e[t],
                s = e[t + 1],
                o = e[t + 2],
                l = r.x,
                _ = r.y,
                h = r.z,
                c = r.w,
                d = c * a + _ * o - h * s,
                u = c * s + h * a - l * o,
                f = c * o + l * s - _ * a,
                E = -l * a - _ * s - h * o;
            i[n] = d * c + E * -l + u * -h - f * -_, i[n + 1] = u * c + E * -_ + f * -l - d * -h,
                i[n + 2] = f * c + E * -h + d * -_ - u * -l;
        }
        static mulMatrixByArray(e, t, r, i, n, a) {
            var s, o, l, _, h;
            if (n === r) {
                for (r = M._tempArray16_3, s = 0; s < 16; ++s) r[s] = n[a + s];
                i = 0;
            }
            for (s = 0; s < 4; s++) o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12],
                n[a + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3], n[a + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7],
                n[a + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11], n[a + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
        }
        static mulMatrixByArrayFast(e, t, r, i, n, a) {
            var s, o, l, _, h;
            for (s = 0; s < 4; s++) o = e[t + s], l = e[t + s + 4], _ = e[t + s + 8], h = e[t + s + 12],
                n[a + s] = o * r[i + 0] + l * r[i + 1] + _ * r[i + 2] + h * r[i + 3], n[a + s + 4] = o * r[i + 4] + l * r[i + 5] + _ * r[i + 6] + h * r[i + 7],
                n[a + s + 8] = o * r[i + 8] + l * r[i + 9] + _ * r[i + 10] + h * r[i + 11], n[a + s + 12] = o * r[i + 12] + l * r[i + 13] + _ * r[i + 14] + h * r[i + 15];
        }
        static mulMatrixByArrayAndMatrixFast(e, t, r, i, n) {
            var a, s, o, l, _, h = r.elements,
                c = h[0],
                d = h[1],
                u = h[2],
                f = h[3],
                E = h[4],
                T = h[5],
                m = h[6],
                p = h[7],
                g = h[8],
                S = h[9],
                v = h[10],
                R = h[11],
                A = h[12],
                D = h[13],
                I = h[14],
                x = h[15],
                M = t,
                L = t + 4,
                C = t + 8,
                y = t + 12,
                O = n,
                N = n + 4,
                P = n + 8,
                V = n + 12;
            for (a = 0; a < 4; a++) s = e[M + a], o = e[L + a], l = e[C + a], _ = e[y + a],
                i[O + a] = s * c + o * d + l * u + _ * f, i[N + a] = s * E + o * T + l * m + _ * p,
                i[P + a] = s * g + o * S + l * v + _ * R, i[V + a] = s * A + o * D + l * I + _ * x;
        }
        static createAffineTransformationArray(e, t, r, i, n, a, s, o, l, _, h, c) {
            var d = i + i,
                u = n + n,
                f = a + a,
                E = i * d,
                T = i * u,
                m = i * f,
                p = n * u,
                g = n * f,
                S = a * f,
                v = s * d,
                R = s * u,
                A = s * f;
            h[c + 0] = (1 - (p + S)) * o, h[c + 1] = (T + A) * o, h[c + 2] = (m - R) * o, h[c + 3] = 0,
                h[c + 4] = (T - A) * l, h[c + 5] = (1 - (E + S)) * l, h[c + 6] = (g + v) * l, h[c + 7] = 0,
                h[c + 8] = (m + R) * _, h[c + 9] = (g - v) * _, h[c + 10] = (1 - (E + p)) * _, h[c + 11] = 0,
                h[c + 12] = e, h[c + 13] = t, h[c + 14] = r, h[c + 15] = 1;
        }
        static transformVector3ArrayToVector3ArrayCoordinate(e, t, r, i, n) {
            var a = e[t + 0],
                s = e[t + 1],
                o = e[t + 2],
                l = r.elements,
                _ = a * l[3] + s * l[7] + o * l[11] + l[15];
            i[n] = a * l[0] + s * l[4] + o * l[8] + l[12] / _, i[n + 1] = a * l[1] + s * l[5] + o * l[9] + l[13] / _,
                i[n + 2] = a * l[2] + s * l[6] + o * l[10] + l[14] / _;
        }
        static transformLightingMapTexcoordArray(e, t, r, i, n) {
            i[n + 0] = e[t + 0] * r.x + r.z, i[n + 1] = 1 - ((1 - e[t + 1]) * r.y + r.w);
        }
        static getURLVerion(e) {
            var t = e.indexOf("?");
            return t >= 0 ? e.substr(t) : null;
        }
        static _createAffineTransformationArray(e, t, r, i) {
            var n = t.x,
                a = t.y,
                s = t.z,
                o = t.w,
                l = n + n,
                _ = a + a,
                h = s + s,
                c = n * l,
                d = n * _,
                u = n * h,
                f = a * _,
                E = a * h,
                T = s * h,
                m = o * l,
                p = o * _,
                g = o * h,
                S = r.x,
                v = r.y,
                R = r.z;
            i[0] = (1 - (f + T)) * S, i[1] = (d + g) * S, i[2] = (u - p) * S, i[3] = 0, i[4] = (d - g) * v,
                i[5] = (1 - (c + T)) * v, i[6] = (E + m) * v, i[7] = 0, i[8] = (u + p) * R, i[9] = (E - m) * R,
                i[10] = (1 - (c + f)) * R, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1;
        }
        static _mulMatrixArray(e, t, r, i) {
            var n, a, s, o, l, _ = t.elements,
                h = _[0],
                c = _[1],
                d = _[2],
                u = _[3],
                f = _[4],
                E = _[5],
                T = _[6],
                m = _[7],
                p = _[8],
                g = _[9],
                S = _[10],
                v = _[11],
                R = _[12],
                A = _[13],
                D = _[14],
                I = _[15],
                x = i,
                M = i + 4,
                L = i + 8,
                C = i + 12;
            for (n = 0; n < 4; n++) a = e[n], s = e[n + 4], o = e[n + 8], l = e[n + 12], r[x + n] = a * h + s * c + o * d + l * u,
                r[M + n] = a * f + s * E + o * T + l * m, r[L + n] = a * p + s * g + o * S + l * v,
                r[C + n] = a * R + s * A + o * D + l * I;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            a.subtract(t, e, E.TEMPVector30), a.normalize(E.TEMPVector30, E.TEMPVector30), r.x = Math.asin(E.TEMPVector30.y),
                r.y = M.arcTanAngle(-E.TEMPVector30.z, -E.TEMPVector30.x);
        }
        static transformQuat(e, t, r) {
            var i = t,
                n = e.x,
                a = e.y,
                s = e.z,
                o = i[0],
                l = i[1],
                _ = i[2],
                h = i[3],
                c = h * n + l * s - _ * a,
                d = h * a + _ * n - o * s,
                u = h * s + o * a - l * n,
                f = -o * n - l * a - _ * s;
            r.x = c * h + f * -o + d * -_ - u * -l, r.y = d * h + f * -l + u * -o - c * -_,
                r.z = u * h + f * -_ + c * -l - d * -o;
        }
        static quaternionWeight(e, t, r) {
            r.x = e.x * t, r.y = e.y * t, r.z = e.z * t, r.w = e.w;
        }
        static quaternionConjugate(e, t) {
            t.x = -e.x, t.y = -e.y, t.z = -e.z, t.w = e.w;
        }
        static scaleWeight(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z;
            r.x = i > 0 ? Math.pow(Math.abs(i), t) : -Math.pow(Math.abs(i), t), r.y = n > 0 ? Math.pow(Math.abs(n), t) : -Math.pow(Math.abs(n), t),
                r.z = a > 0 ? Math.pow(Math.abs(a), t) : -Math.pow(Math.abs(a), t);
        }
        static scaleBlend(e, t, r, i) {
            var n = M._tempVector3_0,
                a = M._tempVector3_1;
            M.scaleWeight(e, 1 - r, n), M.scaleWeight(t, r, a);
            var s = r > .5 ? t : e;
            i.x = s.x > 0 ? Math.abs(n.x * a.x) : -Math.abs(n.x * a.x), i.y = s.y > 0 ? Math.abs(n.y * a.y) : -Math.abs(n.y * a.y),
                i.z = s.z > 0 ? Math.abs(n.z * a.z) : -Math.abs(n.z * a.z);
        }
        static matrix4x4MultiplyFFF(e, t, r) {
            var i, n, a, s, o;
            if (r === t)
                for (t = new Float32Array(16), i = 0; i < 16; ++i) t[i] = r[i];
            var l = t[0],
                _ = t[1],
                h = t[2],
                c = t[3],
                d = t[4],
                u = t[5],
                f = t[6],
                E = t[7],
                T = t[8],
                m = t[9],
                p = t[10],
                g = t[11],
                S = t[12],
                v = t[13],
                R = t[14],
                A = t[15];
            for (i = 0; i < 4; i++) n = e[i], a = e[i + 4], s = e[i + 8], o = e[i + 12], r[i] = n * l + a * _ + s * h + o * c,
                r[i + 4] = n * d + a * u + s * f + o * E, r[i + 8] = n * T + a * m + s * p + o * g,
                r[i + 12] = n * S + a * v + s * R + o * A;
        }
        static matrix4x4MultiplyFFFForNative(e, r, i) {
            t.LayaGL.instance.matrix4x4Multiply(e, r, i);
        }
        static matrix4x4MultiplyMFM(e, t, r) {
            M.matrix4x4MultiplyFFF(e.elements, t, r.elements);
        }
        static _buildTexture2D(e, r, i, n, a = !1) {
            var s = new t.Texture2D(e, r, i, a, !0);
            return s.anisoLevel = 1, s.filterMode = t.BaseTexture.FILTERMODE_POINT, x._generateTexture2D(s, e, r, n),
                s;
        }
        static _drawBound(e, t, r) {
            e.lineCount + 12 > e.maxLineCount && (e.maxLineCount += 12);
            var i = M._tempVector3_0,
                n = M._tempVector3_1,
                a = t.min,
                s = t.max;
            i.setValue(a.x, a.y, a.z), n.setValue(s.x, a.y, a.z), e.addLine(i, n, r, r), i.setValue(a.x, a.y, a.z),
                n.setValue(a.x, a.y, s.z), e.addLine(i, n, r, r), i.setValue(s.x, a.y, a.z), n.setValue(s.x, a.y, s.z),
                e.addLine(i, n, r, r), i.setValue(a.x, a.y, s.z), n.setValue(s.x, a.y, s.z), e.addLine(i, n, r, r),
                i.setValue(a.x, a.y, a.z), n.setValue(a.x, s.y, a.z), e.addLine(i, n, r, r), i.setValue(a.x, a.y, s.z),
                n.setValue(a.x, s.y, s.z), e.addLine(i, n, r, r), i.setValue(s.x, a.y, a.z), n.setValue(s.x, s.y, a.z),
                e.addLine(i, n, r, r), i.setValue(s.x, a.y, s.z), n.setValue(s.x, s.y, s.z), e.addLine(i, n, r, r),
                i.setValue(a.x, s.y, a.z), n.setValue(s.x, s.y, a.z), e.addLine(i, n, r, r), i.setValue(a.x, s.y, a.z),
                n.setValue(a.x, s.y, s.z), e.addLine(i, n, r, r), i.setValue(s.x, s.y, a.z), n.setValue(s.x, s.y, s.z),
                e.addLine(i, n, r, r), i.setValue(a.x, s.y, s.z), n.setValue(s.x, s.y, s.z), e.addLine(i, n, r, r);
        }
        static _getHierarchyPath(e, t, r) {
            r.length = 0;
            for (var i = t; i !== e;) {
                var n = i._parent;
                if (!n) return null;
                r.push(n.getChildIndex(i)), i = n;
            }
            return r;
        }
        static _getNodeByHierarchyPath(e, t) {
            for (var r = e, i = t.length - 1; i >= 0; i--) r = r.getChildAt(t[i]);
            return r;
        }
    }
    M._tempVector3_0 = new a(), M._tempVector3_1 = new a(), M._tempVector3_2 = new a(),
        M._tempColor0 = new I(), M._tempArray16_0 = new Float32Array(16), M._tempArray16_1 = new Float32Array(16),
        M._tempArray16_2 = new Float32Array(16), M._tempArray16_3 = new Float32Array(16),
        M._compIdToNode = new Object();
    class L {
        constructor(e, t, r, i) {
            this._attributeMap = null, this._uniformMap = null, this._enableInstancing = !1,
                this._subShaders = [], this._name = e, this._attributeMap = t, this._uniformMap = r,
                this._enableInstancing = i;
        }
        static propertyNameToID(e) {
            if (null != L._propertyNameMap[e]) return L._propertyNameMap[e];
            var t = L._propertyNameCounter++;
            return L._propertyNameMap[e] = t, t;
        }
        static addInclude(e, r) {
            r = r.replace(t.ShaderCompile._clearCR, ""), t.ShaderCompile.addInclude(e, r);
        }
        static registerPublicDefine(e) {
            var t = Math.pow(2, L._publicCounter++);
            return L._globleDefines[t] = e, t;
        }
        static compileShader(e, r, i, n, a, s) {
            var o = L.find(e);
            if (o) {
                var l = o.getSubShaderAt(r);
                if (l) {
                    var _ = l._passes[i];
                    _ ? t.WebGL.shaderHighPrecision ? _.withCompile(n, a, s) : _.withCompile(n - L.SHADERDEFINE_HIGHPRECISION, a, s) : console.warn("Shader3D: unknown passIndex.");
                } else console.warn("Shader3D: unknown subShaderIndex.");
            } else console.warn("Shader3D: unknown shader name.");
        }
        static add(e, t = null, r = null, i = !1) {
            return L._preCompileShader[e] = new L(e, t, r, i);
        }
        static find(e) {
            return L._preCompileShader[e];
        }
        addSubShader(e) {
            this._subShaders.push(e), e._owner = this;
        }
        getSubShaderAt(e) {
            return this._subShaders[e];
        }
    }
    L.RENDER_STATE_CULL = 0, L.RENDER_STATE_BLEND = 1, L.RENDER_STATE_BLEND_SRC = 2,
        L.RENDER_STATE_BLEND_DST = 3, L.RENDER_STATE_BLEND_SRC_RGB = 4, L.RENDER_STATE_BLEND_DST_RGB = 5,
        L.RENDER_STATE_BLEND_SRC_ALPHA = 6, L.RENDER_STATE_BLEND_DST_ALPHA = 7, L.RENDER_STATE_BLEND_CONST_COLOR = 8,
        L.RENDER_STATE_BLEND_EQUATION = 9, L.RENDER_STATE_BLEND_EQUATION_RGB = 10, L.RENDER_STATE_BLEND_EQUATION_ALPHA = 11,
        L.RENDER_STATE_DEPTH_TEST = 12, L.RENDER_STATE_DEPTH_WRITE = 13, L.PERIOD_CUSTOM = 0,
        L.PERIOD_MATERIAL = 1, L.PERIOD_SPRITE = 2, L.PERIOD_CAMERA = 3, L.PERIOD_SCENE = 4,
        L._propertyNameCounter = 0, L._propertyNameMap = {}, L._publicCounter = 0, L._globleDefines = [],
        L._preCompileShader = {}, L.debugMode = !1;
    class C {
        constructor(e = null) {
            if (this._counter = 0, this.defines = {}, e)
                for (var t in this._counter = e._counter,
                        e.defines) this.defines[t] = e.defines[t];
        }
        registerDefine(e) {
            var t = Math.pow(2, this._counter++);
            return this.defines[t] = e, t;
        }
    }
    class y {
        get normalizedTime() {
            return this._normalizedTime;
        }
        get duration() {
            return this._duration;
        }
        constructor() {}
        _resetPlayState(e) {
            this._finish = !1, this._startPlayTime = e, this._elapsedTime = e, this._playEventIndex = 0,
                this._lastIsFront = !0;
        }
        _cloneTo(e) {
            e._finish = this._finish, e._startPlayTime = this._startPlayTime, e._elapsedTime = this._elapsedTime,
                e._playEventIndex = this._playEventIndex, e._lastIsFront = this._lastIsFront;
        }
    }
    class O {
        constructor(e) {
            this._defaultState = null, this._referenceCount = 0, this._statesMap = {}, this.playOnWake = !0,
                this._playType = -1, this._crossMark = 0, this._crossDuration = -1, this._crossNodesOwnersIndicesMap = {},
                this._crossNodesOwnersCount = 0, this._crossNodesOwners = [], this._currentPlayState = null,
                this._states = [], this._playStateInfo = new y(), this._crossPlayStateInfo = new y(),
                this._srcCrossClipNodeIndices = [], this._destCrossClipNodeIndices = [], this.name = e,
                this.defaultWeight = 1, this.blendingMode = O.BLENDINGMODE_OVERRIDE;
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(e) {
            this._defaultState = e, this._statesMap[e.name] = e;
        }
        _removeClip(e, t, r, i) {
            var n = i._clip,
                a = e[r];
            if (e.splice(r, 1), delete t[i.name], this._animator) {
                var s = n._nodes,
                    o = a._nodeOwners;
                n._removeReference();
                for (var l = 0, _ = s.count; l < _; l++) this._animator._removeKeyframeNodeOwner(o, s.getNodeByIndex(l));
            }
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(e = 1) {
            for (var t = 0, r = this._states.length; t < r; t++) this._states[t]._addReference(e);
            this._referenceCount += e;
        }
        _removeReference(e = 1) {
            for (var t = 0, r = this._states.length; t < r; t++) this._states[t]._removeReference(e);
            this._referenceCount -= e;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getAnimatorState(e) {
            var t = this._statesMap[e];
            return t || null;
        }
        addState(e) {
            var t = e.name;
            if (this._statesMap[t]) throw "AnimatorControllerLayer:this stat's name has exist.";
            this._statesMap[t] = e, this._states.push(e), this._animator && (e._clip._addReference(),
                this._animator._getOwnersByClip(e));
        }
        removeState(e) {
            for (var t = this._states, r = -1, i = 0, n = t.length; i < n; i++)
                if (t[i] === e) {
                    r = i;
                    break;
                } -
            1 !== r && this._removeClip(t, this._statesMap, r, e);
        }
        destroy() {
            this._clearReference(), this._statesMap = null, this._states = null, this._playStateInfo = null,
                this._crossPlayStateInfo = null, this._defaultState = null;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.blendingMode = this.blendingMode, t.defaultWeight = this.defaultWeight,
                t.playOnWake = this.playOnWake;
        }
        clone() {
            var e = new O(this.name);
            return this.cloneTo(e), e;
        }
    }
    O.BLENDINGMODE_OVERRIDE = 0, O.BLENDINGMODE_ADDTIVE = 1;
    class N {
        constructor() {
            this._referenceCount = 0, this._clip = null, this._nodeOwners = [], this._currentFrameIndices = null,
                this._scripts = null, this.speed = 1, this.clipStart = 0, this.clipEnd = 1;
        }
        get clip() {
            return this._clip;
        }
        set clip(e) {
            this._clip !== e && (this._clip && this._referenceCount > 0 && this._clip._removeReference(this._referenceCount),
                e && (this._currentFrameIndices = new Int16Array(e._nodes.count), this._resetFrameIndices(),
                    this._referenceCount > 0 && this._clip._addReference(this._referenceCount)), this._clip = e);
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(e = 1) {
            this._clip && this._clip._addReference(e), this._referenceCount += e;
        }
        _removeReference(e = 1) {
            this._clip && this._clip._removeReference(e), this._referenceCount -= e;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        _resetFrameIndices() {
            for (var e = 0, t = this._currentFrameIndices.length; e < t; e++) this._currentFrameIndices[e] = -1;
        }
        addScript(e) {
            var t = new e();
            return this._scripts = this._scripts || [], this._scripts.push(t), t;
        }
        getScript(e) {
            if (this._scripts)
                for (var t = 0, r = this._scripts.length; t < r; t++) {
                    var i = this._scripts[t];
                    if (i instanceof e) return i;
                }
            return null;
        }
        getScripts(e) {
            var t;
            if (this._scripts)
                for (var r = 0, i = this._scripts.length; r < i; r++) {
                    var n = this._scripts[r];
                    n instanceof e && (t = t || []).push(n);
                }
            return t;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.speed = this.speed, t.clipStart = this.clipStart, t.clipEnd = this.clipEnd,
                t.clip = this._clip;
        }
        clone() {
            var e = new N();
            return this.cloneTo(e), e;
        }
    }
    class P {
        constructor() {
            this.indexInList = -1, this.referenceCount = 0, this.updateMark = -1, this.type = -1,
                this.fullPath = null, this.propertyOwner = null, this.property = null, this.defaultValue = null,
                this.crossFixedValue = null;
        }
        saveCrossFixedValue() {
            var e = this.propertyOwner;
            if (e) switch (this.type) {
                case 0:
                    for (var t = this.property, r = t.length - 1, i = 0; i < r && (e = e[t[i]]); i++);
                    this.crossFixedValue = e[t[r]];
                    break;

                case 1:
                    var n = e.localPosition;
                    this.crossFixedValue || (this.crossFixedValue = new a()), this.crossFixedValue.x = n.x,
                        this.crossFixedValue.y = n.y, this.crossFixedValue.z = n.z;
                    break;

                case 2:
                    var s = e.localRotation;
                    this.crossFixedValue || (this.crossFixedValue = new E()), this.crossFixedValue.x = s.x,
                        this.crossFixedValue.y = s.y, this.crossFixedValue.z = s.z, this.crossFixedValue.w = s.w;
                    break;

                case 3:
                    var o = e.localScale;
                    this.crossFixedValue || (this.crossFixedValue = new a()), this.crossFixedValue.x = o.x,
                        this.crossFixedValue.y = o.y, this.crossFixedValue.z = o.z;
                    break;

                case 4:
                    var l = e.localRotationEuler;
                    this.crossFixedValue || (this.crossFixedValue = new a()), this.crossFixedValue.x = l.x,
                        this.crossFixedValue.y = l.y, this.crossFixedValue.z = l.z;
                    break;

                default:
                    throw "Animator:unknown type.";
            }
        }
    }
    class V extends t.Component {
        constructor() {
            super(), this._keyframeNodeOwners = [], this._linkAvatarSpritesData = {}, this._linkAvatarSprites = [],
                this._renderableSprites = [], this.cullingMode = V.CULLINGMODE_CULLCOMPLETELY, this._controllerLayers = [],
                this._linkSprites = {}, this._speed = 1, this._keyframeNodeOwnerMap = {}, this._updateMark = 0;
        }
        static _update(e) {
            for (var t = e._animatorPool, r = t.elements, i = 0, n = t.length; i < n; i++) {
                var a = r[i];
                a && a.enabled && a._update();
            }
        }
        get speed() {
            return this._speed;
        }
        set speed(e) {
            this._speed = e;
        }
        _linkToSprites(e) {
            for (var t in e) {
                for (var r = this.owner, i = e[t], n = 0, a = i.length; n < a; n++) {
                    var s = i[n];
                    if ("" === s) break;
                    if (!(r = r.getChildByName(s))) break;
                }
                r && this.linkSprite3DToAvatarNode(t, r);
            }
        }
        _addKeyframeNodeOwner(e, t, r) {
            var i = t._indexInList,
                n = t.fullPath,
                a = this._keyframeNodeOwnerMap[n];
            if (a) a.referenceCount++, e[i] = a;
            else {
                for (var s = r, o = 0, l = t.propertyCount; o < l && (s = s[t.getPropertyByIndex(o)]); o++);
                (a = this._keyframeNodeOwnerMap[n] = new P()).fullPath = n, a.indexInList = this._keyframeNodeOwners.length,
                    a.referenceCount = 1, a.propertyOwner = r;
                var _ = t.propertyCount,
                    h = [];
                for (o = 0; o < _; o++) h[o] = t.getPropertyByIndex(o);
                if (a.property = h, a.type = t.type, s)
                    if (0 === t.type) a.defaultValue = s;
                    else {
                        var c = new s.constructor();
                        s.cloneTo(c), a.defaultValue = c;
                    }
                this._keyframeNodeOwners.push(a), e[i] = a;
            }
        }
        _removeKeyframeNodeOwner(e, t) {
            var r = t.fullPath,
                i = this._keyframeNodeOwnerMap[r];
            i && (i.referenceCount--, 0 === i.referenceCount && (delete this._keyframeNodeOwnerMap[r],
                this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(i), 1)), e[t._indexInList] = null);
        }
        _getOwnersByClip(e) {
            var t = e._clip._nodes,
                r = t.count,
                i = e._nodeOwners;
            i.length = r;
            for (var n = 0; n < r; n++) {
                for (var a = t.getNodeByIndex(n), s = this._avatar ? this._avatarNodeMap[this._avatar._rootNode.name] : this.owner, o = 0, l = a.ownerPathCount; o < l; o++) {
                    var _ = a.getOwnerPathByIndex(o);
                    if ("" === _) break;
                    if (!(s = s.getChildByName(_))) break;
                }
                if (s) {
                    var h = a.propertyOwner;
                    h && (s = s[h]), s && this._addKeyframeNodeOwner(i, a, s);
                }
            }
        }
        _updatePlayer(e, t, r, i) {
            var n = e._clip._duration * (e.clipEnd - e.clipStart),
                a = t._elapsedTime,
                s = a + r;
            t._lastElapsedTime = a, t._elapsedTime = s;
            var o = s / n;
            t._normalizedTime = o;
            var l = o % 1;
            t._normalizedPlayTime = l < 0 ? l + 1 : l, t._duration = n;
            var _ = e._scripts;
            if (!i && s >= n) {
                if (t._finish = !0, t._elapsedTime = n, t._normalizedPlayTime = 1, _)
                    for (var h = 0, c = _.length; h < c; h++) _[h].onStateExit();
            } else if (_)
                for (h = 0, c = _.length; h < c; h++) _[h].onStateUpdate();
        }
        _eventScript(e, t, r, i, n) {
            if (n)
                for (var a = t.length; r < a; r++) {
                    var s = t[r];
                    if (!(s.time <= i)) break;
                    for (var o = 0, l = e.length; o < l; o++) {
                        var _ = e[o],
                            h = _[s.eventName];
                        h && h.apply(_, s.params);
                    }
                } else
                    for (; r >= 0 && (s = t[r]).time >= i; r--)
                        for (o = 0, l = e.length; o < l; o++)(h = (_ = e[o])[s.eventName]) && h.apply(_, s.params);
            return r;
        }
        _updateEventScript(e, t) {
            var r = this.owner._scripts;
            if (r) {
                var i = e._clip,
                    n = i._animationEvents,
                    a = i._duration,
                    s = t._elapsedTime,
                    o = s % a,
                    l = Math.abs(Math.floor(s / a) - Math.floor(t._lastElapsedTime / a)),
                    _ = t._elapsedTime >= t._lastElapsedTime;
                if (t._lastIsFront !== _ && (_ ? t._playEventIndex++ : t._playEventIndex--, t._lastIsFront = _),
                    0 == l) t._playEventIndex = this._eventScript(r, n, t._playEventIndex, o, _);
                else if (_) {
                    this._eventScript(r, n, t._playEventIndex, a, !0);
                    for (var h = 0, c = l - 1; h < c; h++) this._eventScript(r, n, 0, a, !0);
                    t._playEventIndex = this._eventScript(r, n, 0, o, !0);
                } else {
                    this._eventScript(r, n, t._playEventIndex, 0, !1);
                    var d = n.length - 1;
                    for (h = 0, c = l - 1; h < c; h++) this._eventScript(r, n, d, 0, !1);
                    t._playEventIndex = this._eventScript(r, n, d, o, !1);
                }
            }
        }
        _updateClipDatas(e, t, r, i) {
            var n = e._clip,
                a = n._duration,
                s = e.clipStart * a + r._normalizedPlayTime * r._duration,
                o = e._currentFrameIndices,
                l = r._elapsedTime > r._lastElapsedTime;
            n._evaluateClipDatasRealTime(n._nodes, s, o, t, l);
        }
        _applyFloat(e, t, r, i, n, a, s) {
            if (r.updateMark === this._updateMark)
                if (i) e[t] += n * s;
                else {
                    var o = e[t];
                    e[t] = o + n * (s - o);
                }
            else if (a) e[t] = i ? r.defaultValue + s : s;
            else if (i) e[t] = r.defaultValue + n * s;
            else {
                var l = r.defaultValue;
                e[t] = l + n * (s - l);
            }
        }
        _applyPositionAndRotationEuler(e, t, r, i, n, a) {
            if (e.updateMark === this._updateMark)
                if (t) a.x += r * n.x, a.y += r * n.y, a.z += r * n.z;
                else {
                    var s = a.x,
                        o = a.y,
                        l = a.z;
                    a.x = s + r * (n.x - s), a.y = o + r * (n.y - o), a.z = l + r * (n.z - l);
                }
            else if (i)
                if (t) {
                    var _ = e.defaultValue;
                    a.x = _.x + n.x, a.y = _.y + n.y, a.z = _.z + n.z;
                } else a.x = n.x, a.y = n.y, a.z = n.z;
            else if (_ = e.defaultValue, t) a.x = _.x + r * n.x,
                a.y = _.y + r * n.y, a.z = _.z + r * n.z;
            else {
                var h = _.x,
                    c = _.y,
                    d = _.z;
                a.x = h + r * (n.x - h), a.y = c + r * (n.y - c), a.z = d + r * (n.z - d);
            }
        }
        _applyRotation(e, t, r, i, n, a) {
            if (e.updateMark === this._updateMark)
                if (t) {
                    var s = V._tempQuaternion1;
                    M.quaternionWeight(n, r, s), s.normalize(s), E.multiply(a, s, a);
                } else E.lerp(a, n, r, a);
            else if (i)
                if (t) {
                    var o = e.defaultValue;
                    E.multiply(o, n, a);
                } else a.x = n.x, a.y = n.y, a.z = n.z, a.w = n.w;
            else o = e.defaultValue, t ? (s = V._tempQuaternion1,
                M.quaternionWeight(n, r, s), s.normalize(s), E.multiply(o, s, a)) : E.lerp(o, n, r, a);
        }
        _applyScale(e, t, r, i, n, a) {
            if (e.updateMark === this._updateMark)
                if (t) {
                    var s = V._tempVector31;
                    M.scaleWeight(n, r, s), a.x = a.x * s.x, a.y = a.y * s.y, a.z = a.z * s.z;
                } else M.scaleBlend(a, n, r, a);
            else if (i)
                if (t) {
                    var o = e.defaultValue;
                    a.x = o.x * n.x, a.y = o.y * n.y, a.z = o.z * n.z;
                } else a.x = n.x, a.y = n.y, a.z = n.z;
            else o = e.defaultValue, t ? (s = V._tempVector31,
                M.scaleWeight(n, r, s), a.x = o.x * s.x, a.y = o.y * s.y, a.z = o.z * s.z) : M.scaleBlend(o, n, r, a);
        }
        _applyCrossData(e, t, r, i, n, a, s) {
            var o = e.propertyOwner;
            if (o) {
                switch (e.type) {
                    case 0:
                        for (var l = e.property, _ = l.length - 1, h = 0; h < _ && (o = o[l[h]]); h++);
                        var c = n + s * (a - n);
                        this._applyFloat(o, l[_], e, t, r, i, c);
                        break;

                    case 1:
                        var d = o.localPosition,
                            u = V._tempVector30,
                            f = n.x,
                            T = n.y,
                            m = n.z;
                        u.x = f + s * (a.x - f), u.y = T + s * (a.y - T), u.z = m + s * (a.z - m), this._applyPositionAndRotationEuler(e, t, r, i, u, d),
                            o.localPosition = d;
                        break;

                    case 2:
                        var p = o.localRotation,
                            g = V._tempQuaternion0;
                        E.lerp(n, a, s, g), this._applyRotation(e, t, r, i, g, p), o.localRotation = p;
                        break;

                    case 3:
                        var S = o.localScale,
                            v = V._tempVector30;
                        M.scaleBlend(n, a, s, v), this._applyScale(e, t, r, i, v, S), o.localScale = S;
                        break;

                    case 4:
                        var R = o.localRotationEuler,
                            A = V._tempVector30;
                        f = n.x, T = n.y, m = n.z, A.x = f + s * (a.x - f), A.y = T + s * (a.y - T), A.z = m + s * (a.z - m),
                            this._applyPositionAndRotationEuler(e, t, r, i, A, R), o.localRotationEuler = R;
                }
                e.updateMark = this._updateMark;
            }
        }
        _setClipDatasToNode(e, t, r, i) {
            for (var n = e._clip._nodes, a = e._nodeOwners, s = 0, o = n.count; s < o; s++) {
                var l = a[s];
                if (l) {
                    var _ = l.propertyOwner;
                    if (_) {
                        switch (l.type) {
                            case 0:
                                for (var h = l.property, c = h.length - 1, d = 0; d < c && (_ = _[h[d]]); d++);
                                this._applyFloat(_, h[c], l, t, r, i, n.getNodeByIndex(s).data);
                                break;

                            case 1:
                                var u = _.localPosition;
                                this._applyPositionAndRotationEuler(l, t, r, i, n.getNodeByIndex(s).data, u), _.localPosition = u;
                                break;

                            case 2:
                                var f = _.localRotation;
                                this._applyRotation(l, t, r, i, n.getNodeByIndex(s).data, f), _.localRotation = f;
                                break;

                            case 3:
                                var E = _.localScale;
                                this._applyScale(l, t, r, i, n.getNodeByIndex(s).data, E), _.localScale = E;
                                break;

                            case 4:
                                var T = _.localRotationEuler;
                                this._applyPositionAndRotationEuler(l, t, r, i, n.getNodeByIndex(s).data, T), _.localRotationEuler = T;
                        }
                        l.updateMark = this._updateMark;
                    }
                }
            }
        }
        _setCrossClipDatasToNode(e, t, r, i, n) {
            for (var a = e._crossNodesOwners, s = e._crossNodesOwnersCount, o = e.blendingMode !== O.BLENDINGMODE_OVERRIDE, l = e.defaultWeight, _ = e._destCrossClipNodeIndices, h = r._clip._nodes, c = r._nodeOwners, d = e._srcCrossClipNodeIndices, u = t._nodeOwners, f = t._clip._nodes, E = 0; E < s; E++) {
                var T = a[E];
                if (T) {
                    var m = d[E],
                        p = _[E],
                        g = -1 !== m ? f.getNodeByIndex(m).data : c[p].defaultValue,
                        S = -1 !== p ? h.getNodeByIndex(p).data : u[m].defaultValue;
                    this._applyCrossData(T, o, l, n, g, S, i);
                }
            }
        }
        _setFixedCrossClipDatasToNode(e, t, r, i) {
            for (var n = e._crossNodesOwners, a = e._crossNodesOwnersCount, s = e.blendingMode !== O.BLENDINGMODE_OVERRIDE, o = e.defaultWeight, l = e._destCrossClipNodeIndices, _ = t._clip._nodes, h = 0; h < a; h++) {
                var c = n[h];
                if (c) {
                    var d = l[h],
                        u = c.crossFixedValue,
                        f = -1 !== d ? _.getNodeByIndex(d).data : c.defaultValue;
                    this._applyCrossData(c, s, o, i, u, f, r);
                }
            }
        }
        _revertDefaultKeyframeNodes(e) {
            for (var t = e._nodeOwners, r = 0, i = t.length; r < i; r++) {
                var n = t[r];
                if (n) {
                    var a = n.propertyOwner;
                    if (a) switch (n.type) {
                        case 0:
                            for (var s = n.property, o = s.length - 1, l = 0; l < o && (a = a[s[l]]); l++);
                            a[s[o]] = n.defaultValue;
                            break;

                        case 1:
                            var _ = a.localPosition,
                                h = n.defaultValue;
                            _.x = h.x, _.y = h.y, _.z = h.z, a.localPosition = _;
                            break;

                        case 2:
                            var c = a.localRotation,
                                d = n.defaultValue;
                            c.x = d.x, c.y = d.y, c.z = d.z, c.w = d.w, a.localRotation = c;
                            break;

                        case 3:
                            var u = a.localScale;
                            h = n.defaultValue, u.x = h.x, u.y = h.y, u.z = h.z, a.localScale = u;
                            break;

                        case 4:
                            var f = a.localRotationEuler;
                            h = n.defaultValue, f.x = h.x, f.y = h.y, f.z = h.z, a.localRotationEuler = f;
                            break;

                        default:
                            throw "Animator:unknown type.";
                    }
                }
            }
        }
        _onAdded() {
            var e = this.owner._parent;
            this.owner._setHierarchyAnimator(this, e ? e._hierarchyAnimator : null), this.owner._changeAnimatorToLinkSprite3DNoAvatar(this, !0, []);
        }
        _onDestroy() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) this._controllerLayers[e]._removeReference();
            var r = this.owner._parent;
            this.owner._clearHierarchyAnimator(this, r ? r._hierarchyAnimator : null);
        }
        _onEnable() {
            this.owner._scene._animatorPool.add(this);
            for (var e = 0, t = this._controllerLayers.length; e < t; e++) {
                if (this._controllerLayers[e].playOnWake) this.getDefaultState(e) && this.play(null, e, 0);
            }
        }
        _onDisable() {
            this.owner._scene._animatorPool.remove(this);
        }
        _handleSpriteOwnersBySprite(e, t, r) {
            for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                for (var a = this._controllerLayers[i]._states, s = 0, o = a.length; s < o; s++) {
                    var l = a[s],
                        _ = l._clip,
                        h = t.join("/"),
                        c = _._nodesMap[h];
                    if (c)
                        for (var d = l._nodeOwners, u = 0, f = c.length; u < f; u++) e ? this._addKeyframeNodeOwner(d, c[u], r) : this._removeKeyframeNodeOwner(d, c[u]);
                }
        }
        _parse(e) {
            var r = e.avatar;
            if (r) {
                this.avatar = t.Loader.getRes(r.path);
                var i = r.linkSprites;
                this._linkSprites = i, this._linkToSprites(i);
            }
            e.clipPaths;
            for (var n = e.playOnWake, a = e.layers, s = 0; s < a.length; s++) {
                var o = a[s],
                    l = new O(o.name);
                l.defaultWeight = 0 === s ? 1 : o.weight;
                var _ = o.blendingMode;
                _ && (l.blendingMode = _), this.addControllerLayer(l);
                for (var h = o.states, c = 0, d = h.length; c < d; c++) {
                    var u = h[c],
                        f = u.clipPath;
                    if (f) {
                        var E, T = u.name;
                        if (E = t.Loader.getRes(f)) {
                            var m = new N();
                            m.name = T, m.clip = E, l.addState(m), 0 === c && (this.getControllerLayer(s).defaultState = m);
                        }
                    }
                }
                void 0 !== n && (l.playOnWake = n);
            }
            var p = e.cullingMode;
            void 0 !== p && (this.cullingMode = p);
        }
        _update() {
            var e = this.owner._scene.timer,
                r = e._delta / 1e3;
            if (0 !== this._speed && 0 !== r) {
                var i;
                if (this.cullingMode === V.CULLINGMODE_CULLCOMPLETELY) {
                    i = !1;
                    for (var n = 0, a = this._renderableSprites.length; n < a; n++)
                        if (this._renderableSprites[n]._render._visible) {
                            i = !0;
                            break;
                        }
                } else i = !0;
                this._updateMark++;
                var s = e.scale;
                for (n = 0, a = this._controllerLayers.length; n < a; n++) {
                    var o = this._controllerLayers[n],
                        l = o._playStateInfo,
                        _ = o._crossPlayStateInfo;
                    switch (f = o.blendingMode !== O.BLENDINGMODE_OVERRIDE, o._playType) {
                        case 0:
                            var h = o._currentPlayState,
                                c = h._clip,
                                d = this._speed * h.speed,
                                u = l._finish;
                            if (u || this._updatePlayer(h, l, r * d, c.islooping), i) {
                                var f = o.blendingMode !== O.BLENDINGMODE_OVERRIDE;
                                this._updateClipDatas(h, f, l, s * d), this._setClipDatasToNode(h, f, o.defaultWeight, 0 === n),
                                    u || this._updateEventScript(h, l);
                            }
                            break;

                        case 1:
                            c = (h = o._currentPlayState)._clip;
                            var E = o._crossPlayState,
                                T = E._clip,
                                m = o._crossDuration,
                                p = _._startPlayTime,
                                g = T._duration - p,
                                S = m > g ? g / m : 1,
                                v = this._speed * E.speed;
                            this._updatePlayer(E, _, r * S * v, T.islooping);
                            var R = (_._elapsedTime - p) / S / m;
                            R >= 1 ? i && (this._updateClipDatas(E, f, _, s * v), this._setClipDatasToNode(E, f, o.defaultWeight, 0 === n),
                                    o._playType = 0, o._currentPlayState = E, _._cloneTo(l)) : (l._finish || (d = this._speed * h.speed,
                                        this._updatePlayer(h, l, r * d, c.islooping), i && this._updateClipDatas(h, f, l, s * d)),
                                    i && (this._updateClipDatas(E, f, _, s * S * v), this._setCrossClipDatasToNode(o, h, E, R, 0 === n))),
                                i && (this._updateEventScript(h, l), this._updateEventScript(E, _));
                            break;

                        case 2:
                            T = (E = o._crossPlayState)._clip, m = o._crossDuration, p = _._startPlayTime, S = m > (g = T._duration - p) ? g / m : 1,
                                v = this._speed * E.speed, this._updatePlayer(E, _, r * S * v, T.islooping), i && ((R = (_._elapsedTime - p) / S / m) >= 1 ? (this._updateClipDatas(E, f, _, s * v),
                                        this._setClipDatasToNode(E, f, 1, 0 === n), o._playType = 0, o._currentPlayState = E,
                                        _._cloneTo(l)) : (this._updateClipDatas(E, f, _, s * S * v), this._setFixedCrossClipDatasToNode(o, E, R, 0 === n)),
                                    this._updateEventScript(E, _));
                    }
                }
                i && this._avatar && (t.Render.supportWebGLPlusAnimation && this._updateAnimationNodeWorldMatix(this._animationNodeLocalPositions, this._animationNodeLocalRotations, this._animationNodeLocalScales, this._animationNodeWorldMatrixs, this._animationNodeParentIndices),
                    this._updateAvatarNodesToSprite());
            }
        }
        _cloneTo(e) {
            var t = e;
            t.avatar = this.avatar, t.cullingMode = this.cullingMode;
            for (var r = 0, i = this._controllerLayers.length; r < i; r++) {
                var n = this._controllerLayers[r];
                t.addControllerLayer(n.clone());
                for (var a = n._states, s = 0, o = a.length; s < o; s++) {
                    var l = a[s].clone(),
                        _ = t.getControllerLayer(r);
                    _.addState(l), 0 == s && (_.defaultState = l);
                }
            }
            t._linkSprites = this._linkSprites, t._linkToSprites(this._linkSprites);
        }
        getDefaultState(e = 0) {
            return this._controllerLayers[e].defaultState;
        }
        addState(e, t = 0) {
            this._controllerLayers[t].addState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
        }
        removeState(e, t = 0) {
            this._controllerLayers[t].removeState(e), console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
        }
        addControllerLayer(e) {
            this._controllerLayers.push(e), e._animator = this, e._addReference();
            for (var t = e._states, r = 0, i = t.length; r < i; r++) this._getOwnersByClip(t[r]);
        }
        getControllerLayer(e = 0) {
            return this._controllerLayers[e];
        }
        getCurrentAnimatorPlayState(e = 0) {
            return this._controllerLayers[e]._playStateInfo;
        }
        play(e = null, t = 0, r = Number.NEGATIVE_INFINITY) {
            var i = this._controllerLayers[t];
            if (i) {
                var n = i.defaultState;
                if (!e && !n) throw new Error("Animator:must have  default clip value,please set clip property.");
                var a = i._currentPlayState,
                    s = i._playStateInfo,
                    o = e ? i._statesMap[e] : n,
                    l = o._clip._duration;
                a !== o ? (r !== Number.NEGATIVE_INFINITY ? s._resetPlayState(l * r) : s._resetPlayState(0),
                    null !== a && a !== o && this._revertDefaultKeyframeNodes(a), i._playType = 0, i._currentPlayState = o) : r !== Number.NEGATIVE_INFINITY && (s._resetPlayState(l * r),
                    i._playType = 0);
                var _ = o._scripts;
                if (_)
                    for (var h = 0, c = _.length; h < c; h++) _[h].onStateEnter();
            } else console.warn("Invalid layerIndex " + t + ".");
        }
        crossFade(e, t, r = 0, i = Number.NEGATIVE_INFINITY) {
            var n = this._controllerLayers[r];
            if (n) {
                var a = n._statesMap[e];
                if (a) {
                    var s = n._playType;
                    if (-1 === s) return void this.play(e, r, i);
                    var o = n._crossPlayStateInfo,
                        l = n._crossNodesOwners,
                        _ = n._crossNodesOwnersIndicesMap,
                        h = n._currentPlayState,
                        c = a._nodeOwners,
                        d = n._destCrossClipNodeIndices,
                        u = a._clip,
                        f = u._nodes,
                        E = u._nodesDic;
                    switch (s) {
                        case 0:
                            var T = h._nodeOwners,
                                m = n._srcCrossClipNodeIndices,
                                p = h._clip,
                                g = p._nodes,
                                S = p._nodesDic;
                            n._playType = 1;
                            for (var v = ++n._crossMark, R = n._crossNodesOwnersCount = 0, A = 0, D = g.count; A < D; A++) {
                                var I = g.getNodeByIndex(A),
                                    x = I._indexInList,
                                    M = T[x];
                                if (M) {
                                    var L = I.fullPath;
                                    m[R] = x;
                                    var C = E[L];
                                    d[R] = C ? C._indexInList : -1, _[L] = v, l[R] = M, R++;
                                }
                            }
                            for (A = 0, D = f.count; A < D; A++) {
                                var y = (C = f.getNodeByIndex(A))._indexInList,
                                    O = c[y];
                                if (O) {
                                    var N = C.fullPath;
                                    S[N] || (m[R] = -1, d[R] = y, _[N] = v, l[R] = O, R++);
                                }
                            }
                            break;

                        case 1:
                        case 2:
                            for (n._playType = 2, A = 0, D = l.length; A < D; A++) {
                                var P = l[A];
                                P.saveCrossFixedValue(), C = E[P.fullPath], d[A] = C ? C._indexInList : -1;
                            }
                            for (R = n._crossNodesOwnersCount, v = n._crossMark, A = 0, D = f.count; A < D; A++)(O = c[y = (C = f.getNodeByIndex(A))._indexInList]) && _[N = C.fullPath] !== v && (d[R] = y,
                                _[N] = v, P = c[y], l[R] = P, P.saveCrossFixedValue(), R++);
                    }
                    n._crossNodesOwnersCount = R, n._crossPlayState = a, n._crossDuration = h._clip._duration * t,
                        i !== Number.NEGATIVE_INFINITY ? o._resetPlayState(u._duration * i) : o._resetPlayState(0);
                    var V = a._scripts;
                    if (V)
                        for (A = 0, D = V.length; A < D; A++) V[A].onStateEnter();
                } else console.warn("Invalid name " + r + ".");
            } else console.warn("Invalid layerIndex " + r + ".");
        }
        get avatar() {
            return this._avatar;
        }
        set avatar(e) {
            if (this._avatar !== e)
                if (this._avatar = e, e) this._getAvatarOwnersAndInitDatasAsync(),
                    this.owner._changeHierarchyAnimatorAvatar(this, e);
                else {
                    var t = this.owner._parent;
                    this.owner._changeHierarchyAnimatorAvatar(this, t ? t._hierarchyAnimator._avatar : null);
                }
        }
        _getAvatarOwnersAndInitDatasAsync() {
            for (var e = 0, t = this._controllerLayers.length; e < t; e++)
                for (var r = this._controllerLayers[e]._states, i = 0, n = r.length; i < n; i++) this._getOwnersByClip(r[i]);
            for (var a in this._avatar._cloneDatasToAnimator(this), this._linkAvatarSpritesData) {
                var s = this._linkAvatarSpritesData[a];
                if (s)
                    for (var o = 0, l = s.length; o < l; o++) this._isLinkSpriteToAnimationNode(s[o], a, !0);
            }
        }
        _isLinkSpriteToAnimationNode(e, t, r) {
            if (this._avatar) {
                var i = this._avatarNodeMap[t];
                if (i)
                    if (r) {
                        e._transform._dummy = i.transform, this._linkAvatarSprites.push(e);
                        var n = i.transform,
                            a = e.transform;
                        if (!a.owner.isStatic && n) {
                            var s = a.worldMatrix,
                                o = this.owner._transform._parent;
                            if (o) M.matrix4x4MultiplyMFM(o.worldMatrix, n.getWorldMatrix(), s);
                            else
                                for (var l = s.elements, _ = n.getWorldMatrix(), h = 0; h < 16; h++) l[h] = _[h];
                            a.worldMatrix = s;
                        }
                    } else e._transform._dummy = null, this._linkAvatarSprites.splice(this._linkAvatarSprites.indexOf(e), 1);
            }
        }
        _isLinkSpriteToAnimationNodeData(e, t, r) {
            var i = this._linkAvatarSpritesData[t];
            if (r) i || (this._linkAvatarSpritesData[t] = i = []), i.push(e);
            else {
                var n = i.indexOf(e);
                i.splice(n, 1);
            }
        }
        _updateAvatarNodesToSprite() {
            for (var e = 0, t = this._linkAvatarSprites.length; e < t; e++) {
                var r = this._linkAvatarSprites[e],
                    i = r.transform._dummy,
                    n = r.transform;
                if (!n.owner.isStatic && i) {
                    var a = n.worldMatrix,
                        s = this.owner._transform;
                    M.matrix4x4MultiplyMFM(s.worldMatrix, i.getWorldMatrix(), a), n.worldMatrix = a;
                }
            }
        }
        linkSprite3DToAvatarNode(e, t) {
            return this._isLinkSpriteToAnimationNodeData(t, e, !0), this._isLinkSpriteToAnimationNode(t, e, !0), !0;
        }
        unLinkSprite3DToAvatarNode(e) {
            if (e._hierarchyAnimator === this) {
                var t = e.transform._dummy;
                if (t) {
                    var r = t._owner.name;
                    return this._isLinkSpriteToAnimationNodeData(e, r, !1), this._isLinkSpriteToAnimationNode(e, r, !1), !0;
                }
                return !1;
            }
            throw "Animator:sprite3D must belong to this Animator";
        }
        _updateAnimationNodeWorldMatix(e, r, i, n, a) {
            t.LayaGL.instance.updateAnimationNodeWorldMatix(e, r, i, a, n);
        }
    }
    V._tempVector30 = new a(), V._tempVector31 = new a(), V._tempQuaternion0 = new E(),
        V._tempQuaternion1 = new E(), V._tempVector3Array0 = new Float32Array(3), V._tempVector3Array1 = new Float32Array(3),
        V._tempQuaternionArray0 = new Float32Array(4), V._tempQuaternionArray1 = new Float32Array(4),
        V.CULLINGMODE_ALWAYSANIMATE = 0, V.CULLINGMODE_CULLCOMPLETELY = 2;
    class w extends t.EventDispatcher {
        constructor(e) {
            super(), this._localPosition = new a(0, 0, 0), this._localRotation = new E(0, 0, 0, 1),
                this._localScale = new a(1, 1, 1), this._localRotationEuler = new a(0, 0, 0), this._localMatrix = new T(),
                this._position = new a(0, 0, 0), this._rotation = new E(0, 0, 0, 1), this._scale = new a(1, 1, 1),
                this._rotationEuler = new a(0, 0, 0), this._worldMatrix = new T(), this._children = null,
                this._parent = null, this._dummy = null, this._transformFlag = 0, this._owner = e,
                this._children = [], this._setTransformFlag(w.TRANSFORM_LOCALQUATERNION | w.TRANSFORM_LOCALEULER | w.TRANSFORM_LOCALMATRIX, !1),
                this._setTransformFlag(w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDEULER | w.TRANSFORM_WORLDSCALE | w.TRANSFORM_WORLDMATRIX, !0);
        }
        get _isFrontFaceInvert() {
            var e = this.getWorldLossyScale(),
                t = e.x < 0;
            return e.y < 0 && (t = !t), e.z < 0 && (t = !t), t;
        }
        get owner() {
            return this._owner;
        }
        get worldNeedUpdate() {
            return this._getTransformFlag(w.TRANSFORM_WORLDMATRIX);
        }
        get localPositionX() {
            return this._localPosition.x;
        }
        set localPositionX(e) {
            this._localPosition.x = e, this.localPosition = this._localPosition;
        }
        get localPositionY() {
            return this._localPosition.y;
        }
        set localPositionY(e) {
            this._localPosition.y = e, this.localPosition = this._localPosition;
        }
        get localPositionZ() {
            return this._localPosition.z;
        }
        set localPositionZ(e) {
            this._localPosition.z = e, this.localPosition = this._localPosition;
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(e) {
            this._localPosition !== e && e.cloneTo(this._localPosition), this._setTransformFlag(w.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldPositionTransform();
        }
        get localRotationX() {
            return this.localRotation.x;
        }
        set localRotationX(e) {
            this._localRotation.x = e, this.localRotation = this._localRotation;
        }
        get localRotationY() {
            return this.localRotation.y;
        }
        set localRotationY(e) {
            this._localRotation.y = e, this.localRotation = this._localRotation;
        }
        get localRotationZ() {
            return this.localRotation.z;
        }
        set localRotationZ(e) {
            this._localRotation.z = e, this.localRotation = this._localRotation;
        }
        get localRotationW() {
            return this.localRotation.w;
        }
        set localRotationW(e) {
            this._localRotation.w = e, this.localRotation = this._localRotation;
        }
        get localRotation() {
            if (this._getTransformFlag(w.TRANSFORM_LOCALQUATERNION)) {
                var e = this._localRotationEuler;
                E.createFromYawPitchRoll(e.y / w._angleToRandin, e.x / w._angleToRandin, e.z / w._angleToRandin, this._localRotation),
                    this._setTransformFlag(w.TRANSFORM_LOCALQUATERNION, !1);
            }
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation !== e && e.cloneTo(this._localRotation), this._localRotation.normalize(this._localRotation),
                this._setTransformFlag(w.TRANSFORM_LOCALEULER | w.TRANSFORM_LOCALMATRIX, !0), this._setTransformFlag(w.TRANSFORM_LOCALQUATERNION, !1),
                this._onWorldRotationTransform();
        }
        get localScaleX() {
            return this._localScale.x;
        }
        set localScaleX(e) {
            this._localScale.x = e, this.localScale = this._localScale;
        }
        get localScaleY() {
            return this._localScale.y;
        }
        set localScaleY(e) {
            this._localScale.y = e, this.localScale = this._localScale;
        }
        get localScaleZ() {
            return this._localScale.z;
        }
        set localScaleZ(e) {
            this._localScale.z = e, this.localScale = this._localScale;
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(e) {
            this._localScale !== e && e.cloneTo(this._localScale), this._setTransformFlag(w.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldScaleTransform();
        }
        get localRotationEulerX() {
            return this.localRotationEuler.x;
        }
        set localRotationEulerX(e) {
            this._localRotationEuler.x = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEulerY() {
            return this.localRotationEuler.y;
        }
        set localRotationEulerY(e) {
            this._localRotationEuler.y = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEulerZ() {
            return this.localRotationEuler.z;
        }
        set localRotationEulerZ(e) {
            this._localRotationEuler.z = e, this.localRotationEuler = this._localRotationEuler;
        }
        get localRotationEuler() {
            if (this._getTransformFlag(w.TRANSFORM_LOCALEULER)) {
                this._localRotation.getYawPitchRoll(w._tempVector30);
                var e = w._tempVector30,
                    t = this._localRotationEuler;
                t.x = e.y * w._angleToRandin, t.y = e.x * w._angleToRandin, t.z = e.z * w._angleToRandin,
                    this._setTransformFlag(w.TRANSFORM_LOCALEULER, !1);
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(e) {
            this._localRotationEuler !== e && e.cloneTo(this._localRotationEuler), this._setTransformFlag(w.TRANSFORM_LOCALEULER, !1),
                this._setTransformFlag(w.TRANSFORM_LOCALQUATERNION | w.TRANSFORM_LOCALMATRIX, !0),
                this._onWorldRotationTransform();
        }
        get localMatrix() {
            return this._getTransformFlag(w.TRANSFORM_LOCALMATRIX) && (T.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix),
                this._setTransformFlag(w.TRANSFORM_LOCALMATRIX, !1)), this._localMatrix;
        }
        set localMatrix(e) {
            this._localMatrix !== e && e.cloneTo(this._localMatrix), this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale),
                this._setTransformFlag(w.TRANSFORM_LOCALEULER, !0), this._setTransformFlag(w.TRANSFORM_LOCALMATRIX, !1),
                this._onWorldTransform();
        }
        get position() {
            if (this._getTransformFlag(w.TRANSFORM_WORLDPOSITION)) {
                if (null != this._parent) {
                    var e = this.worldMatrix.elements;
                    this._position.x = e[12], this._position.y = e[13], this._position.z = e[14];
                } else this._localPosition.cloneTo(this._position);
                this._setTransformFlag(w.TRANSFORM_WORLDPOSITION, !1);
            }
            return this._position;
        }
        set position(e) {
            if (null != this._parent) {
                var t = w._tempMatrix0;
                this._parent.worldMatrix.invert(t), a.transformCoordinate(e, t, this._localPosition);
            } else e.cloneTo(this._localPosition);
            this.localPosition = this._localPosition, this._position !== e && e.cloneTo(this._position),
                this._setTransformFlag(w.TRANSFORM_WORLDPOSITION, !1);
        }
        get rotation() {
            return this._getTransformFlag(w.TRANSFORM_WORLDQUATERNION) && (null != this._parent ? E.multiply(this._parent.rotation, this.localRotation, this._rotation) : this.localRotation.cloneTo(this._rotation),
                this._setTransformFlag(w.TRANSFORM_WORLDQUATERNION, !1)), this._rotation;
        }
        set rotation(e) {
            null != this._parent ? (this._parent.rotation.invert(w._tempQuaternion0), E.multiply(w._tempQuaternion0, e, this._localRotation)) : e.cloneTo(this._localRotation),
                this.localRotation = this._localRotation, e !== this._rotation && e.cloneTo(this._rotation),
                this._setTransformFlag(w.TRANSFORM_WORLDQUATERNION, !1);
        }
        get rotationEuler() {
            if (this._getTransformFlag(w.TRANSFORM_WORLDEULER)) {
                this.rotation.getYawPitchRoll(w._tempVector30);
                var e = w._tempVector30,
                    t = this._rotationEuler;
                t.x = e.y * w._angleToRandin, t.y = e.x * w._angleToRandin, t.z = e.z * w._angleToRandin,
                    this._setTransformFlag(w.TRANSFORM_WORLDEULER, !1);
            }
            return this._rotationEuler;
        }
        set rotationEuler(e) {
            E.createFromYawPitchRoll(e.y / w._angleToRandin, e.x / w._angleToRandin, e.z / w._angleToRandin, this._rotation),
                this.rotation = this._rotation, this._rotationEuler !== e && e.cloneTo(this._rotationEuler),
                this._setTransformFlag(w.TRANSFORM_WORLDEULER, !1);
        }
        get worldMatrix() {
            return this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) && (null != this._parent ? T.multiply(this._parent.worldMatrix, this.localMatrix, this._worldMatrix) : this.localMatrix.cloneTo(this._worldMatrix),
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX, !1)), this._worldMatrix;
        }
        set worldMatrix(e) {
            null === this._parent ? e.cloneTo(this._localMatrix) : (this._parent.worldMatrix.invert(this._localMatrix),
                    T.multiply(this._localMatrix, e, this._localMatrix)), this.localMatrix = this._localMatrix,
                this._worldMatrix !== e && e.cloneTo(this._worldMatrix), this._setTransformFlag(w.TRANSFORM_WORLDMATRIX, !1);
        }
        _getScaleMatrix() {
            var e = w._tempQuaternion0,
                t = w._tempMatrix3x30,
                r = w._tempMatrix3x31,
                i = w._tempMatrix3x32;
            return f.createFromMatrix4x4(this.worldMatrix, r), this.rotation.invert(e), f.createRotationQuaternion(e, t),
                f.multiply(t, r, i), i;
        }
        _setTransformFlag(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }
        _getTransformFlag(e) {
            return 0 != (this._transformFlag & e);
        }
        _setParent(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children,
                        r = t.indexOf(this);
                    t.splice(r, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }
        _onWorldPositionRotationTransform() {
            if (!(this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(w.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(w.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(w.TRANSFORM_WORLDEULER))) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDEULER, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }
        _onWorldPositionScaleTransform() {
            if (!this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(w.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(w.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDSCALE, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }
        _onWorldPositionTransform() {
            if (!this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(w.TRANSFORM_WORLDPOSITION)) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDPOSITION, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionTransform();
            }
        }
        _onWorldRotationTransform() {
            if (!this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(w.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(w.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDEULER, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionRotationTransform();
            }
        }
        _onWorldScaleTransform() {
            if (!this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(w.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDSCALE, !0), this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldPositionScaleTransform();
            }
        }
        _onWorldTransform() {
            if (!(this._getTransformFlag(w.TRANSFORM_WORLDMATRIX) && this._getTransformFlag(w.TRANSFORM_WORLDPOSITION) && this._getTransformFlag(w.TRANSFORM_WORLDQUATERNION) && this._getTransformFlag(w.TRANSFORM_WORLDEULER) && this._getTransformFlag(w.TRANSFORM_WORLDSCALE))) {
                this._setTransformFlag(w.TRANSFORM_WORLDMATRIX | w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDEULER | w.TRANSFORM_WORLDSCALE, !0),
                    this.event(t.Event.TRANSFORM_CHANGED, this._transformFlag);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
            }
        }
        translate(e, t = !0) {
            t ? (T.createFromQuaternion(this.localRotation, w._tempMatrix0), a.transformCoordinate(e, w._tempMatrix0, w._tempVector30),
                a.add(this.localPosition, w._tempVector30, this._localPosition), this.localPosition = this._localPosition) : (a.add(this.position, e, this._position),
                this.position = this._position);
        }
        rotate(e, t = !0, r = !0) {
            var i;
            r ? i = e : (a.scale(e, Math.PI / 180, w._tempVector30), i = w._tempVector30), E.createFromYawPitchRoll(i.y, i.x, i.z, w._tempQuaternion0),
                t ? (E.multiply(this._localRotation, w._tempQuaternion0, this._localRotation), this.localRotation = this._localRotation) : (E.multiply(w._tempQuaternion0, this.rotation, this._rotation),
                    this.rotation = this._rotation);
        }
        getForward(e) {
            var t = this.worldMatrix.elements;
            e.x = -t[8], e.y = -t[9], e.z = -t[10];
        }
        getUp(e) {
            var t = this.worldMatrix.elements;
            e.x = t[4], e.y = t[5], e.z = t[6];
        }
        getRight(e) {
            var t = this.worldMatrix.elements;
            e.x = t[0], e.y = t[1], e.z = t[2];
        }
        lookAt(e, t, i = !1) {
            var n;
            if (i) {
                if (n = this._localPosition, Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance) return;
                E.lookAt(this._localPosition, e, t, this._localRotation), this._localRotation.invert(this._localRotation),
                    this.localRotation = this._localRotation;
            } else {
                var a = this.position;
                if (n = a, Math.abs(n.x - e.x) < r.zeroTolerance && Math.abs(n.y - e.y) < r.zeroTolerance && Math.abs(n.z - e.z) < r.zeroTolerance) return;
                E.lookAt(a, e, t, this._rotation), this._rotation.invert(this._rotation), this.rotation = this._rotation;
            }
        }
        getWorldLossyScale() {
            if (this._getTransformFlag(w.TRANSFORM_WORLDSCALE)) {
                if (null !== this._parent) {
                    var e = this._getScaleMatrix().elements;
                    this._scale.x = e[0], this._scale.y = e[4], this._scale.z = e[8];
                } else this._localScale.cloneTo(this._scale);
                this._setTransformFlag(w.TRANSFORM_WORLDSCALE, !1);
            }
            return this._scale;
        }
        setWorldLossyScale(e) {
            if (null !== this._parent) {
                var t = w._tempMatrix3x33,
                    r = w._tempMatrix3x33,
                    i = r.elements,
                    n = this._parent._getScaleMatrix();
                n.invert(n), f.createFromScaling(e, t), f.multiply(n, t, r), this._localScale.x = i[0],
                    this._localScale.y = i[4], this._localScale.z = i[8];
            } else e.cloneTo(this._localScale);
            this.localScale = this._localScale, this._scale !== e && e.cloneTo(this._scale),
                this._setTransformFlag(w.TRANSFORM_WORLDSCALE, !1);
        }
        get scale() {
            return console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead."),
                this.getWorldLossyScale();
        }
        set scale(e) {
            console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead."),
                this.setWorldLossyScale(e);
        }
    }
    w._tempVector30 = new a(), w._tempQuaternion0 = new E(), w._tempMatrix0 = new T(),
        w._tempMatrix3x30 = new f(), w._tempMatrix3x31 = new f(), w._tempMatrix3x32 = new f(),
        w._tempMatrix3x33 = new f(), w.TRANSFORM_LOCALQUATERNION = 1, w.TRANSFORM_LOCALEULER = 2,
        w.TRANSFORM_LOCALMATRIX = 4, w.TRANSFORM_WORLDPOSITION = 8, w.TRANSFORM_WORLDQUATERNION = 16,
        w.TRANSFORM_WORLDSCALE = 32, w.TRANSFORM_WORLDMATRIX = 64, w.TRANSFORM_WORLDEULER = 128,
        w._angleToRandin = 180 / Math.PI;
    class b extends t.Node {
        constructor(e = null, t = !1) {
            super(), this._needProcessCollisions = !1, this._needProcessTriggers = !1, this._id = ++b._uniqueIDCounter,
                this._transform = new w(this), this._isStatic = t, this.layer = 0, this.name = e || "New Sprite3D";
        }
        static __init__() {}
        static instantiate(e, t = null, r = !0, i = null, n = null) {
            var a = e.clone();
            t && t.addChild(a);
            var s = a.transform;
            if (r) {
                var o = s.worldMatrix;
                e.transform.worldMatrix.cloneTo(o), s.worldMatrix = o;
            } else i && (s.position = i), n && (s.rotation = n);
            return a;
        }
        static load(e, r) {
            t.Laya.loader.create(e, r, null, b.HIERARCHY);
        }
        get id() {
            return this._id;
        }
        get layer() {
            return this._layer;
        }
        set layer(e) {
            if (this._layer !== e) {
                if (!(e >= 0 && e <= 30)) throw new Error("Layer value must be 0-30.");
                this._layer = e;
            }
        }
        get url() {
            return this._url;
        }
        get isStatic() {
            return this._isStatic;
        }
        get transform() {
            return this._transform;
        }
        _setCreateURL(e) {
            this._url = t.URL.formatURL(e);
        }
        _changeAnimatorsToLinkSprite3D(e, t, r) {
            var i = this.getComponent(V);
            if (i && (i.avatar || e._changeAnimatorToLinkSprite3DNoAvatar(i, t, r)), this._parent && this._parent instanceof b) {
                r.unshift(this._parent.name);
                var n = this._parent;
                n._hierarchyAnimator && n._changeAnimatorsToLinkSprite3D(e, t, r);
            }
        }
        _setHierarchyAnimator(e, t) {
            this._changeHierarchyAnimator(e), this._changeAnimatorAvatar(e.avatar);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var n = this._children[r];
                n._hierarchyAnimator == t && n._setHierarchyAnimator(e, t);
            }
        }
        _clearHierarchyAnimator(e, t) {
            this._changeHierarchyAnimator(t), this._changeAnimatorAvatar(t ? t.avatar : null);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var n = this._children[r];
                n._hierarchyAnimator == e && n._clearHierarchyAnimator(e, t);
            }
        }
        _changeHierarchyAnimatorAvatar(e, t) {
            this._changeAnimatorAvatar(t);
            for (var r = 0, i = this._children.length; r < i; r++) {
                var n = this._children[r];
                n._hierarchyAnimator == e && n._changeHierarchyAnimatorAvatar(e, t);
            }
        }
        _changeAnimatorToLinkSprite3DNoAvatar(e, t, r) {
            e._handleSpriteOwnersBySprite(t, r, this);
            for (var i = 0, n = this._children.length; i < n; i++) {
                var a = this._children[i],
                    s = r.length;
                r.push(a.name), a._changeAnimatorToLinkSprite3DNoAvatar(e, t, r), r.splice(s, 1);
            }
        }
        _changeHierarchyAnimator(e) {
            this._hierarchyAnimator = e;
        }
        _changeAnimatorAvatar(e) {}
        _onAdded() {
            if (this._parent instanceof b) {
                var e = this._parent;
                this.transform._setParent(e.transform), e._hierarchyAnimator && (!this._hierarchyAnimator && this._setHierarchyAnimator(e._hierarchyAnimator, null),
                    e._changeAnimatorsToLinkSprite3D(this, !0, [this.name]));
            }
            super._onAdded();
        }
        _onRemoved() {
            if (super._onRemoved(), this._parent instanceof b) {
                var e = this._parent;
                this.transform._setParent(null), e._hierarchyAnimator && (this._hierarchyAnimator == e._hierarchyAnimator && this._clearHierarchyAnimator(e._hierarchyAnimator, null),
                    e._changeAnimatorsToLinkSprite3D(this, !1, [this.name]));
            }
        }
        _parse(e, t) {
            if (void 0 !== e.isStatic && (this._isStatic = e.isStatic), void 0 !== e.active && (this.active = e.active),
                null != e.name && (this.name = e.name), void 0 !== e.position) {
                var r = this.transform.localPosition;
                r.fromArray(e.position), this.transform.localPosition = r;
            }
            if (void 0 !== e.rotationEuler) {
                var i = this.transform.localRotationEuler;
                i.fromArray(e.rotationEuler), this.transform.localRotationEuler = i;
            }
            if (void 0 !== e.rotation) {
                var n = this.transform.localRotation;
                n.fromArray(e.rotation), this.transform.localRotation = n;
            }
            if (void 0 !== e.scale) {
                var a = this.transform.localScale;
                a.fromArray(e.scale), this.transform.localScale = a;
            }
            null != e.layer && (this.layer = e.layer);
        }
        _cloneTo(e, t, r) {
            if (this.destroyed) throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
            var i = e;
            i.name = this.name, i.destroyed = this.destroyed, i.active = this.active;
            var n = i.transform.localPosition;
            this.transform.localPosition.cloneTo(n), i.transform.localPosition = n;
            var a = i.transform.localRotation;
            this.transform.localRotation.cloneTo(a), i.transform.localRotation = a;
            var s = i.transform.localScale;
            this.transform.localScale.cloneTo(s), i.transform.localScale = s, i._isStatic = this._isStatic,
                i.layer = this.layer, super._cloneTo(i, t, r);
        }
        static _createSprite3DInstance(e) {
            for (var t = e._create(), r = e._children, i = 0, n = r.length; i < n; i++) {
                var a = b._createSprite3DInstance(r[i]);
                t.addChild(a);
            }
            return t;
        }
        static _parseSprite3DInstance(e, t, r, i) {
            for (var n = r._children, a = i._children, s = 0, o = n.length; s < o; s++) b._parseSprite3DInstance(e, t, n[s], a[s]);
            r._cloneTo(i, e, t);
        }
        clone() {
            var e = b._createSprite3DInstance(this);
            return b._parseSprite3DInstance(this, e, this, e), e;
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._transform = null, this._scripts = null,
                this._url && t.Loader.clearRes(this._url));
        }
        _create() {
            return new b();
        }
    }
    b.HIERARCHY = "HIERARCHY", b.WORLDMATRIX = L.propertyNameToID("u_WorldMat"), b.MVPMATRIX = L.propertyNameToID("u_MvpMatrix"),
        b._uniqueIDCounter = 0;
    class F extends b {
        constructor(e) {
            super(e);
        }
        static __init__() {
            F.SHADERDEFINE_RECEIVE_SHADOW = F.shaderDefines.registerDefine("RECEIVESHADOW"),
                F.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV = F.shaderDefines.registerDefine("SCALEOFFSETLIGHTINGMAPUV"),
                F.SAHDERDEFINE_LIGHTMAP = F.shaderDefines.registerDefine("LIGHTMAP");
        }
        _onInActive() {
            super._onInActive();
            var e = this._scene;
            e._removeRenderObject(this._render), this._render.castShadow && e._removeShadowCastRenderObject(this._render);
        }
        _onActive() {
            super._onActive();
            var e = this._scene;
            e._addRenderObject(this._render), this._render.castShadow && e._addShadowCastRenderObject(this._render);
        }
        _onActiveInScene() {
            if (super._onActiveInScene(), o.Laya3D._editerEnvironment) {
                var e = this._scene,
                    t = new n();
                e._allotPickColorByID(this.id, t), e._pickIdToSprite[this.id] = this, this._render._shaderValues.setVector(F.PICKCOLOR, t);
            }
        }
        _addToInitStaticBatchManager() {}
        _setBelongScene(e) {
            super._setBelongScene(e), this._render._setBelongScene(e);
        }
        _setUnBelongScene() {
            this._render._shaderValues.removeDefine(F.SAHDERDEFINE_LIGHTMAP), super._setUnBelongScene();
        }
        _changeHierarchyAnimator(e) {
            if (this._hierarchyAnimator) {
                var t = this._hierarchyAnimator._renderableSprites;
                t.splice(t.indexOf(this), 1);
            }
            e && e._renderableSprites.push(this), super._changeHierarchyAnimator(e);
        }
        destroy(e = !0) {
            super.destroy(e), this._render._destroy(), this._render = null;
        }
        _create() {
            return new F(this.name);
        }
    }
    F.LIGHTMAPSCALEOFFSET = L.propertyNameToID("u_LightmapScaleOffset"), F.LIGHTMAP = L.propertyNameToID("u_LightMap"),
        F.PICKCOLOR = L.propertyNameToID("u_PickColor"), F.shaderDefines = new C();
    class B {
        constructor() {
            this._initBatchSprites = [], this._staticBatches = {}, this._batchRenderElementPoolIndex = 0,
                this._batchRenderElementPool = [];
        }
        static _registerManager(e) {
            B._managers.push(e);
        }
        static _addToStaticBatchQueue(e, t) {
            e instanceof F && e.isStatic && t.push(e);
            for (var r = 0, i = e.numChildren; r < i; r++) B._addToStaticBatchQueue(e._children[r], t);
        }
        static combine(e, t = null) {
            t || (t = [], e && B._addToStaticBatchQueue(e, t));
            var r = t.length;
            if (r > 0) {
                for (var i = 0; i < r; i++) {
                    var n = t[i];
                    n.isStatic && n._addToInitStaticBatchManager();
                }
                for (var a = 0, s = B._managers.length; a < s; a++) {
                    B._managers[a]._initStaticBatchs(e);
                }
            }
        }
        _partition(e, t, r) {
            for (var i = e[Math.floor((r + t) / 2)]; t <= r;) {
                for (; this._compare(e[t], i) < 0;) t++;
                for (; this._compare(e[r], i) > 0;) r--;
                if (t < r) {
                    var n = e[t];
                    e[t] = e[r], e[r] = n, t++, r--;
                } else if (t === r) {
                    t++;
                    break;
                }
            }
            return t;
        }
        _quickSort(e, t, r) {
            if (e.length > 1) {
                var i = this._partition(e, t, r),
                    n = i - 1;
                t < n && this._quickSort(e, t, n), i < r && this._quickSort(e, i, r);
            }
        }
        _compare(e, t) {
            throw "StaticBatch:must override this function.";
        }
        _initStaticBatchs(e) {
            throw "StaticBatch:must override this function.";
        }
        _getBatchRenderElementFromPool() {
            throw "StaticBatch:must override this function.";
        }
        _addBatchSprite(e) {
            this._initBatchSprites.push(e);
        }
        _clear() {
            this._batchRenderElementPoolIndex = 0;
        }
        _garbageCollection() {
            throw "StaticBatchManager: must override it.";
        }
        dispose() {
            this._staticBatches = null;
        }
    }
    B._managers = [];
    class U {
        constructor() {}
        static __init__() {
            t.Render.supportWebGLPlusCulling && (U._cullingBufferLength = 0, U._cullingBuffer = new Float32Array(4096));
        }
        static _drawTraversalCullingBound(e, t) {
            e.length;
            for (var r = e.elements, i = 0, n = e.length; i < n; i++) {
                var a = U._tempColor0;
                a.r = 0, a.g = 1, a.b = 0, a.a = 1, M._drawBound(t, r[i].bounds._getBoundBox(), a);
            }
        }
        static _traversalCulling(e, t, r, i, n, s) {
            i.length;
            for (var o = i.elements, l = e.boundFrustum, _ = e._transform.position, h = 0; h < o.length; h++) {
                var c = o[h];
                if (c._enable)
                    if (!e.useOcclusionCulling || c._needRender(l, r)) {
                        c._visible = !0, c._distanceForSort = a.distance(c.bounds.getCenter(), _);
                        for (var d = c._renderElements, u = 0, f = d.length; u < f; u++) d[u]._update(t, r, n, s);
                    } else c._visible = !1;
                else c._visible = !1;
            }
        }
        static renderObjectCulling(e, t, r, i, n, a) {
            var s, o, _ = t._opaqueQueue,
                h = t._transparentQueue;
            _.clear(), h.clear();
            var c = B._managers;
            for (s = 0, o = c.length; s < o; s++) c[s]._clear();
            var d = l._managers;
            for (s = 0, o = d.length; s < o; s++) d[s]._clear();
            var u = t._octree;
            if (u && (u.updateMotionObjects(), u.shrinkRootIfPossible(), u.getCollidingWithFrustum(r, n, a)),
                U._traversalCulling(e, t, r, i, n, a), U.debugFrustumCulling) {
                var f = t._debugTool;
                f.clear(), u && (u.drawAllBounds(f), u.drawAllObjects(f)), U._drawTraversalCullingBound(i, f);
            }
            var E = _.elements.length;
            E > 0 && _._quickSort(0, E - 1), (E = h.elements.length) > 0 && h._quickSort(0, E - 1);
        }
        static renderObjectCullingNative(e, t, r, i, n, s) {
            var o, _, h, c, d = t._opaqueQueue,
                u = t._transparentQueue;
            d.clear(), u.clear();
            var f = B._managers;
            for (o = 0, _ = f.length; o < _; o++) f[o]._clear();
            var E = l._managers;
            for (o = 0, _ = E.length; o < _; o++) E[o]._clear();
            var T = i.length,
                m = i.elements;
            for (o = 0; o < T; o++) m[o].bounds, m[o]._updateForNative && m[o]._updateForNative(r);
            e.boundFrustum;
            U.cullingNative(e._boundFrustumBuffer, U._cullingBuffer, t._cullingBufferIndices, T, t._cullingBufferResult);
            var p = r.camera._transform.position;
            for (o = 0; o < T; o++) {
                var g = m[o];
                if (!e.useOcclusionCulling || e._isLayerVisible(g._owner._layer) && g._enable && t._cullingBufferResult[o]) {
                    g._visible = !0, g._distanceForSort = a.distance(g.bounds.getCenter(), p);
                    var S = g._renderElements;
                    for (h = 0, c = S.length; h < c; h++) {
                        S[h]._update(t, r, n, s);
                    }
                } else g._visible = !1;
            }
            var v = d.elements.length;
            v > 0 && d._quickSort(0, v - 1), (v = u.elements.length) > 0 && u._quickSort(0, v - 1);
        }
        static cullingNative(e, r, i, n, a) {
            return t.LayaGL.instance.culling(e, r, i, n, a);
        }
    }
    U._tempVector3 = new a(), U._tempColor0 = new I(), U.debugFrustumCulling = !1;
    class G {
        constructor(e, t = 0) {
            this.normal = e, this.distance = t;
        }
        static createPlaneBy3P(e, t, r) {
            var i = t.x - e.x,
                n = t.y - e.y,
                a = t.z - e.z,
                s = r.x - e.x,
                o = r.y - e.y,
                l = r.z - e.z,
                _ = n * l - a * o,
                h = a * s - i * l,
                c = i * o - n * s,
                d = 1 / Math.sqrt(_ * _ + h * h + c * c),
                u = _ * d,
                f = h * d,
                E = c * d;
            G._TEMPVec3.x = u, G._TEMPVec3.y = f, G._TEMPVec3.z = E;
            var T = -(u * e.x + f * e.y + E * e.z);
            return new G(G._TEMPVec3, T);
        }
        normalize() {
            var e = this.normal.x,
                t = this.normal.y,
                r = this.normal.z,
                i = 1 / Math.sqrt(e * e + t * t + r * r);
            this.normal.x = e * i, this.normal.y = t * i, this.normal.z = r * i, this.distance *= i;
        }
    }
    G._TEMPVec3 = new a(), G.PlaneIntersectionType_Back = 0, G.PlaneIntersectionType_Front = 1,
        G.PlaneIntersectionType_Intersecting = 2;
    class z {
        constructor(e, t) {
            this.origin = e, this.direction = t;
        }
    }
    class H {}
    H.Disjoint = 0, H.Contains = 1, H.Intersects = 2;
    class W {
        constructor() {}
        static distancePlaneToPoint(e, t) {
            return a.dot(e.normal, t) - e.distance;
        }
        static distanceBoxToPoint(e, t) {
            var r = e.min,
                i = r.x,
                n = r.y,
                a = r.z,
                s = e.max,
                o = s.x,
                l = s.y,
                _ = s.z,
                h = t.x,
                c = t.y,
                d = t.z,
                u = 0;
            return h < i && (u += (i - h) * (i - h)), h > o && (u += (o - h) * (o - h)), c < n && (u += (n - c) * (n - c)),
                c > l && (u += (l - c) * (l - c)), d < a && (u += (a - d) * (a - d)), d > _ && (u += (_ - d) * (_ - d)),
                Math.sqrt(u);
        }
        static distanceBoxToBox(e, t) {
            var r, i = e.min,
                n = i.x,
                a = i.y,
                s = i.z,
                o = e.max,
                l = o.x,
                _ = o.y,
                h = o.z,
                c = t.min,
                d = c.x,
                u = c.y,
                f = c.z,
                E = t.max,
                T = E.x,
                m = E.y,
                p = E.z,
                g = 0;
            return n > T ? g += (r = n - T) * r : d > l && (g += (r = d - l) * r), a > m ? g += (r = a - m) * r : u > _ && (g += (r = u - _) * r),
                s > p ? g += (r = s - p) * r : f > h && (g += (r = f - h) * r), Math.sqrt(g);
        }
        static distanceSphereToPoint(e, t) {
            var r = Math.sqrt(a.distanceSquared(e.center, t));
            return r -= e.radius, Math.max(r, 0);
        }
        static distanceSphereToSphere(e, t) {
            var r = Math.sqrt(a.distanceSquared(e.center, t.center));
            return r -= e.radius + t.radius, Math.max(r, 0);
        }
        static intersectsRayAndTriangleRD(e, t, i, n, a) {
            var s = e.origin,
                o = s.x,
                l = s.y,
                _ = s.z,
                h = e.direction,
                c = h.x,
                d = h.y,
                u = h.z,
                f = t.x,
                E = t.y,
                T = t.z,
                m = i.x,
                p = i.y,
                g = i.z,
                S = n.x,
                v = n.y,
                R = n.z,
                A = W._tempV30.x,
                D = W._tempV30.y,
                I = W._tempV30.z;
            A = m - f, D = p - E, I = g - T;
            var x = W._tempV31.x,
                M = W._tempV31.y,
                L = W._tempV31.z;
            x = S - f, M = v - E, L = R - T;
            var C = W._tempV32.x,
                y = W._tempV32.y,
                O = W._tempV32.z,
                N = A * (C = d * L - u * M) + D * (y = u * x - c * L) + I * (O = c * M - d * x);
            if (r.isZero(N)) return !1;
            var P = 1 / N,
                V = W._tempV33.x,
                w = W._tempV33.y,
                b = W._tempV33.z,
                F = (V = o - f) * C + (w = l - E) * y + (b = _ - T) * O;
            if ((F *= P) < 0 || F > 1) return !1;
            var B = W._tempV34.x,
                U = W._tempV34.y,
                G = W._tempV34.z,
                z = c * (B = w * I - b * D) + d * (U = b * A - V * I) + u * (G = V * D - w * A);
            if ((z *= P) < 0 || F + z > 1) return !1;
            var H = x * B + M * U + L * G;
            return !((H *= P) < 0);
        }
        static intersectsRayAndTriangleRP(e, t, r, i, n) {
            return W.intersectsRayAndTriangleRD(e, t, r, i, void 0) ? (a.scale(e.direction, void 0, W._tempV30),
                a.add(e.origin, W._tempV30, n), !0) : (n = a._ZERO, !1);
        }
        static intersectsRayAndPoint(e, t) {
            a.subtract(e.origin, t, W._tempV30);
            var i = a.dot(W._tempV30, e.direction),
                n = a.dot(W._tempV30, W._tempV30) - r.zeroTolerance;
            return !(n > 0 && i > 0) && !(i * i - n < 0);
        }
        static intersectsRayAndRay(e, t, i) {
            var n = e.origin,
                s = n.x,
                o = n.y,
                l = n.z,
                _ = e.direction,
                h = _.x,
                c = _.y,
                d = _.z,
                u = t.origin,
                f = u.x,
                E = u.y,
                T = u.z,
                m = t.direction,
                p = m.x,
                g = m.y,
                S = m.z;
            a.cross(_, m, W._tempV30);
            var v = W._tempV30,
                R = a.scalarLength(W._tempV30);
            if (r.isZero(R) && r.nearEqual(f, s) && r.nearEqual(E, o) && r.nearEqual(T, l)) return !0;
            R *= R;
            var A = f - s,
                D = E - o,
                I = T - l,
                x = p,
                M = g,
                L = S,
                C = v.x,
                y = v.y,
                O = v.z,
                N = A * M * O + D * L * C + I * x * y - A * L * y - D * x * O - I * M * C;
            x = h, M = c, L = d;
            var P = N / R;
            a.scale(_, P, W._tempV30), a.scale(m, P, W._tempV31), a.add(n, W._tempV30, W._tempV32),
                a.add(u, W._tempV31, W._tempV33);
            var V = W._tempV32,
                w = W._tempV33;
            return !!(r.nearEqual(w.x, V.x) && r.nearEqual(w.y, V.y) && r.nearEqual(w.z, V.z));
        }
        static intersectsPlaneAndTriangle(e, t, r, i) {
            var n = W.intersectsPlaneAndPoint(e, t),
                a = W.intersectsPlaneAndPoint(e, r),
                s = W.intersectsPlaneAndPoint(e, i);
            return n == G.PlaneIntersectionType_Front && a == G.PlaneIntersectionType_Front && s == G.PlaneIntersectionType_Front ? G.PlaneIntersectionType_Front : n == G.PlaneIntersectionType_Back && a == G.PlaneIntersectionType_Back && s == G.PlaneIntersectionType_Back ? G.PlaneIntersectionType_Back : G.PlaneIntersectionType_Intersecting;
        }
        static intersectsRayAndPlaneRD(e, t, i) {
            var n = t.normal,
                s = a.dot(n, e.direction);
            if (r.isZero(s)) return 0, !1;
            var o = a.dot(n, e.origin);
            return !((-t.distance - o) / s < 0) || (0, !1);
        }
        static intersectsRayAndPlaneRP(e, t, r) {
            return !!W.intersectsRayAndPlaneRD(e, t, void 0) && (a.scale(e.direction, void 0, W._tempV30),
                a.add(e.origin, W._tempV30, W._tempV31), !0);
        }
        static intersectsRayAndBoxRD(e, t) {
            var i = e.origin,
                n = i.x,
                a = i.y,
                s = i.z,
                o = e.direction,
                l = o.x,
                _ = o.y,
                h = o.z,
                c = t.min,
                d = c.x,
                u = c.y,
                f = c.z,
                E = t.max,
                T = E.x,
                m = E.y,
                p = E.z,
                g = 0,
                S = r.MaxValue;
            if (r.isZero(l)) {
                if (n < d || n > T) return -1;
            } else {
                var v = 1 / l,
                    R = (d - n) * v,
                    A = (T - n) * v;
                if (R > A) {
                    var D = R;
                    R = A, A = D;
                }
                if ((g = Math.max(R, g)) > (S = Math.min(A, S))) return -1;
            }
            if (r.isZero(_)) {
                if (a < u || a > m) return -1;
            } else {
                var I = 1 / _,
                    x = (u - a) * I,
                    M = (m - a) * I;
                if (x > M) {
                    var L = x;
                    x = M, M = L;
                }
                if ((g = Math.max(x, g)) > (S = Math.min(M, S))) return -1;
            }
            if (r.isZero(h)) {
                if (s < f || s > p) return -1;
            } else {
                var C = 1 / h,
                    y = (f - s) * C,
                    O = (p - s) * C;
                if (y > O) {
                    var N = y;
                    y = O, O = N;
                }
                if ((g = Math.max(y, g)) > (S = Math.min(O, S))) return -1;
            }
            return g;
        }
        static intersectsRayAndBoxRP(e, t, r) {
            var i = W.intersectsRayAndBoxRD(e, t);
            return -1 === i ? (a._ZERO.cloneTo(r), i) : (a.scale(e.direction, i, W._tempV30),
                a.add(e.origin, W._tempV30, W._tempV31), W._tempV31.cloneTo(r), i);
        }
        static intersectsRayAndSphereRD(e, t) {
            var r = t.radius;
            a.subtract(e.origin, t.center, W._tempV30);
            var i = a.dot(W._tempV30, e.direction),
                n = a.dot(W._tempV30, W._tempV30) - r * r;
            if (n > 0 && i > 0) return -1;
            var s = i * i - n;
            if (s < 0) return -1;
            var o = -i - Math.sqrt(s);
            return o < 0 && (o = 0), o;
        }
        static intersectsRayAndSphereRP(e, t, r) {
            var i = W.intersectsRayAndSphereRD(e, t);
            return -1 === i ? (a._ZERO.cloneTo(r), i) : (a.scale(e.direction, i, W._tempV30),
                a.add(e.origin, W._tempV30, W._tempV31), W._tempV31.cloneTo(r), i);
        }
        static intersectsSphereAndTriangle(e, t, r, i) {
            var n = e.center,
                s = e.radius;
            return W.closestPointPointTriangle(n, t, r, i, W._tempV30), a.subtract(W._tempV30, n, W._tempV31),
                a.dot(W._tempV31, W._tempV31) <= s * s;
        }
        static intersectsPlaneAndPoint(e, t) {
            var r = a.dot(e.normal, t) + e.distance;
            return r > 0 ? G.PlaneIntersectionType_Front : r < 0 ? G.PlaneIntersectionType_Back : G.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndPlane(e, t) {
            a.cross(e.normal, t.normal, W._tempV30);
            var i = a.dot(W._tempV30, W._tempV30);
            return !r.isZero(i);
        }
        static intersectsPlaneAndPlaneRL(e, t, i) {
            var n = e.normal,
                s = t.normal;
            a.cross(n, s, W._tempV34);
            var o = a.dot(W._tempV34, W._tempV34);
            return !r.isZero(o) && (a.scale(s, e.distance, W._tempV30), a.scale(n, t.distance, W._tempV31),
                a.subtract(W._tempV30, W._tempV31, W._tempV32), a.cross(W._tempV32, W._tempV34, W._tempV33),
                a.normalize(W._tempV34, W._tempV34), !0);
        }
        static intersectsPlaneAndBox(e, t) {
            var r = e.distance,
                i = e.normal,
                n = i.x,
                s = i.y,
                o = i.z,
                l = t.min,
                _ = l.x,
                h = l.y,
                c = l.z,
                d = t.max,
                u = d.x,
                f = d.y,
                E = d.z;
            W._tempV30.x = n > 0 ? _ : u, W._tempV30.y = s > 0 ? h : f, W._tempV30.z = o > 0 ? c : E,
                W._tempV31.x = n > 0 ? u : _, W._tempV31.y = s > 0 ? f : h, W._tempV31.z = o > 0 ? E : c;
            var T = a.dot(i, W._tempV30);
            return T + r > 0 ? G.PlaneIntersectionType_Front : (T = a.dot(i, W._tempV31)) + r < 0 ? G.PlaneIntersectionType_Back : G.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndSphere(e, t) {
            var r = t.radius,
                i = a.dot(e.normal, t.center) + e.distance;
            return i > r ? G.PlaneIntersectionType_Front : i < -r ? G.PlaneIntersectionType_Back : G.PlaneIntersectionType_Intersecting;
        }
        static intersectsBoxAndBox(e, t) {
            var r = e.min,
                i = e.max,
                n = t.min,
                a = t.max;
            return !(r.x > a.x || n.x > i.x) && (!(r.y > a.y || n.y > i.y) && !(r.z > a.z || n.z > i.z));
        }
        static intersectsBoxAndSphere(e, t) {
            var r = t.center,
                i = t.radius;
            return a.Clamp(r, e.min, e.max, W._tempV30), a.distanceSquared(r, W._tempV30) <= i * i;
        }
        static intersectsSphereAndSphere(e, t) {
            var r = e.radius + t.radius;
            return a.distanceSquared(e.center, t.center) <= r * r;
        }
        static boxContainsPoint(e, t) {
            var r = e.min,
                i = e.max;
            return r.x <= t.x && i.x >= t.x && r.y <= t.y && i.y >= t.y && r.z <= t.z && i.z >= t.z ? H.Contains : H.Disjoint;
        }
        static boxContainsBox(e, t) {
            var r = e.min,
                i = r.x,
                n = r.y,
                a = r.z,
                s = e.max,
                o = s.x,
                l = s.y,
                _ = s.z,
                h = t.min,
                c = h.x,
                d = h.y,
                u = h.z,
                f = t.max,
                E = f.x,
                T = f.y,
                m = f.z;
            return o < c || i > E ? H.Disjoint : l < d || n > T ? H.Disjoint : _ < u || a > m ? H.Disjoint : i <= c && E <= o && n <= d && T <= l && a <= u && m <= _ ? H.Contains : H.Intersects;
        }
        static boxContainsSphere(e, t) {
            var r = e.min,
                i = r.x,
                n = r.y,
                s = r.z,
                o = e.max,
                l = o.x,
                _ = o.y,
                h = o.z,
                c = t.center,
                d = c.x,
                u = c.y,
                f = c.z,
                E = t.radius;
            return a.Clamp(c, r, o, W._tempV30), a.distanceSquared(c, W._tempV30) > E * E ? H.Disjoint : i + E <= d && d <= l - E && l - i > E && n + E <= u && u <= _ - E && _ - n > E && s + E <= f && f <= h - E && h - s > E ? H.Contains : H.Intersects;
        }
        static sphereContainsPoint(e, t) {
            return a.distanceSquared(t, e.center) <= e.radius * e.radius ? H.Contains : H.Disjoint;
        }
        static sphereContainsTriangle(e, t, r, i) {
            var n = W.sphereContainsPoint(e, t),
                a = W.sphereContainsPoint(e, r),
                s = W.sphereContainsPoint(e, i);
            return n == H.Contains && a == H.Contains && s == H.Contains ? H.Contains : W.intersectsSphereAndTriangle(e, t, r, i) ? H.Intersects : H.Disjoint;
        }
        static sphereContainsBox(e, t) {
            var r = e.center,
                i = r.x,
                n = r.y,
                s = r.z,
                o = e.radius,
                l = t.min,
                _ = l.x,
                h = l.y,
                c = l.z,
                d = t.max,
                u = d.x,
                f = d.y,
                E = d.z,
                T = W._tempV30;
            T.x, T.y, T.z;
            if (!W.intersectsBoxAndSphere(t, e)) return H.Disjoint;
            var m = o * o;
            return i - _, n - f, s - E, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - u,
                n - f, s - E, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - u, n - h,
                    s - E, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - _, n - h, s - E,
                        a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - _, n - f, s - c, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - u,
                            n - f, s - c, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - u, n - h,
                                s - c, a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : (i - _, n - h, s - c,
                                    a.scalarLengthSquared(W._tempV30) > m ? H.Intersects : H.Contains)))))));
        }
        static sphereContainsSphere(e, t) {
            var r = e.radius,
                i = t.radius,
                n = a.distance(e.center, t.center);
            return r + i < n ? H.Disjoint : r - i < n ? H.Intersects : H.Contains;
        }
        static closestPointPointTriangle(e, t, r, i, n) {
            a.subtract(r, t, W._tempV30), a.subtract(i, t, W._tempV31), a.subtract(e, t, W._tempV32),
                a.subtract(e, r, W._tempV33), a.subtract(e, i, W._tempV34);
            var s = a.dot(W._tempV30, W._tempV32),
                o = a.dot(W._tempV31, W._tempV32),
                l = a.dot(W._tempV30, W._tempV33),
                _ = a.dot(W._tempV31, W._tempV33),
                h = a.dot(W._tempV30, W._tempV34),
                c = a.dot(W._tempV31, W._tempV34);
            if (s <= 0 && o <= 0) t.cloneTo(n);
            else if (l >= 0 && _ <= l) r.cloneTo(n);
            else {
                var d = s * _ - l * o;
                if (d <= 0 && s >= 0 && l <= 0) {
                    var u = s / (s - l);
                    return a.scale(W._tempV30, u, n), void a.add(t, n, n);
                }
                if (c >= 0 && h <= c) i.cloneTo(n);
                else {
                    var f = h * o - s * c;
                    if (f <= 0 && o >= 0 && c <= 0) {
                        var E = o / (o - c);
                        return a.scale(W._tempV31, E, n), void a.add(t, n, n);
                    }
                    var T = l * c - h * _;
                    if (T <= 0 && _ - l >= 0 && h - c >= 0) {
                        var m = (_ - l) / (_ - l + (h - c));
                        return a.subtract(i, r, n), a.scale(n, m, n), void a.add(r, n, n);
                    }
                    var p = 1 / (T + f + d),
                        g = f * p,
                        S = d * p;
                    a.scale(W._tempV30, g, W._tempV35), a.scale(W._tempV31, S, W._tempV36), a.add(W._tempV35, W._tempV36, n),
                        a.add(t, n, n);
                }
            }
        }
        static closestPointPlanePoint(e, t, r) {
            var i = e.normal,
                n = a.dot(i, t) - e.distance;
            a.scale(i, n, W._tempV30), a.subtract(t, W._tempV30, r);
        }
        static closestPointBoxPoint(e, t, r) {
            a.max(t, e.min, W._tempV30), a.min(W._tempV30, e.max, r);
        }
        static closestPointSpherePoint(e, t, r) {
            var i = e.center;
            a.subtract(t, i, r), a.normalize(r, r), a.scale(r, e.radius, r), a.add(r, i, r);
        }
        static closestPointSphereSphere(e, t, r) {
            var i = e.center;
            a.subtract(t.center, i, r), a.normalize(r, r), a.scale(r, e.radius, r), a.add(r, i, r);
        }
    }
    W._tempV30 = new a(), W._tempV31 = new a(), W._tempV32 = new a(), W._tempV33 = new a(),
        W._tempV34 = new a(), W._tempV35 = new a(), W._tempV36 = new a();
    class k {
        constructor(e) {
            this._matrix = e, this._near = new G(new a()), this._far = new G(new a()), this._left = new G(new a()),
                this._right = new G(new a()), this._top = new G(new a()), this._bottom = new G(new a()),
                k._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get matrix() {
            return this._matrix;
        }
        set matrix(e) {
            this._matrix = e, k._getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get near() {
            return this._near;
        }
        get far() {
            return this._far;
        }
        get left() {
            return this._left;
        }
        get right() {
            return this._right;
        }
        get top() {
            return this._top;
        }
        get bottom() {
            return this._bottom;
        }
        equalsBoundFrustum(e) {
            return this._matrix.equalsOtherMatrix(e.matrix);
        }
        equalsObj(e) {
            if (e instanceof k) {
                var t = e;
                return this.equalsBoundFrustum(t);
            }
            return !1;
        }
        getPlane(e) {
            switch (e) {
                case 0:
                    return this._near;

                case 1:
                    return this._far;

                case 2:
                    return this._left;

                case 3:
                    return this._right;

                case 4:
                    return this._top;

                case 5:
                    return this._bottom;

                default:
                    return null;
            }
        }
        static _getPlanesFromMatrix(e, t, r, i, n, a, s) {
            var o = e.elements,
                l = o[0],
                _ = o[1],
                h = o[2],
                c = o[3],
                d = o[4],
                u = o[5],
                f = o[6],
                E = o[7],
                T = o[8],
                m = o[9],
                p = o[10],
                g = o[11],
                S = o[12],
                v = o[13],
                R = o[14],
                A = o[15],
                D = t.normal;
            D.x = c + h, D.y = E + f, D.z = g + p, t.distance = A + R, t.normalize();
            var I = r.normal;
            I.x = c - h, I.y = E - f, I.z = g - p, r.distance = A - R, r.normalize();
            var x = i.normal;
            x.x = c + l, x.y = E + d, x.z = g + T, i.distance = A + S, i.normalize();
            var M = n.normal;
            M.x = c - l, M.y = E - d, M.z = g - T, n.distance = A - S, n.normalize();
            var L = a.normal;
            L.x = c - _, L.y = E - u, L.z = g - m, a.distance = A - v, a.normalize();
            var C = s.normal;
            C.x = c + _, C.y = E + u, C.z = g + m, s.distance = A + v, s.normalize();
        }
        static _get3PlaneInterPoint(e, t, r) {
            var i = e.normal,
                n = t.normal,
                s = r.normal;
            a.cross(n, s, k._tempV30), a.cross(s, i, k._tempV31), a.cross(i, n, k._tempV32);
            var o = a.dot(i, k._tempV30),
                l = a.dot(n, k._tempV31),
                _ = a.dot(s, k._tempV32);
            return a.scale(k._tempV30, -e.distance / o, k._tempV33), a.scale(k._tempV31, -t.distance / l, k._tempV34),
                a.scale(k._tempV32, -r.distance / _, k._tempV35), a.add(k._tempV33, k._tempV34, k._tempV36),
                a.add(k._tempV35, k._tempV36, k._tempV37), k._tempV37;
        }
        getCorners(e) {
            k._get3PlaneInterPoint(this._near, this._bottom, this._right).cloneTo(e[0]), k._get3PlaneInterPoint(this._near, this._top, this._right).cloneTo(e[1]),
                k._get3PlaneInterPoint(this._near, this._top, this._left).cloneTo(e[2]), k._get3PlaneInterPoint(this._near, this._bottom, this._left).cloneTo(e[3]),
                k._get3PlaneInterPoint(this._far, this._bottom, this._right).cloneTo(e[4]), k._get3PlaneInterPoint(this._far, this._top, this._right).cloneTo(e[5]),
                k._get3PlaneInterPoint(this._far, this._top, this._left).cloneTo(e[6]), k._get3PlaneInterPoint(this._far, this._bottom, this._left).cloneTo(e[7]);
        }
        containsPoint(e) {
            for (var t = G.PlaneIntersectionType_Front, r = G.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        r = W.intersectsPlaneAndPoint(this._near, e);
                        break;

                    case 1:
                        r = W.intersectsPlaneAndPoint(this._far, e);
                        break;

                    case 2:
                        r = W.intersectsPlaneAndPoint(this._left, e);
                        break;

                    case 3:
                        r = W.intersectsPlaneAndPoint(this._right, e);
                        break;

                    case 4:
                        r = W.intersectsPlaneAndPoint(this._top, e);
                        break;

                    case 5:
                        r = W.intersectsPlaneAndPoint(this._bottom, e);
                }
                switch (r) {
                    case G.PlaneIntersectionType_Back:
                        return H.Disjoint;

                    case G.PlaneIntersectionType_Intersecting:
                        t = G.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
                case G.PlaneIntersectionType_Intersecting:
                    return H.Intersects;

                default:
                    return H.Contains;
            }
        }
        intersects(e) {
            var t = e.min,
                r = e.max,
                i = t.x,
                n = t.y,
                a = t.z,
                s = r.x,
                o = r.y,
                l = r.z,
                _ = this._near.normal;
            if (this._near.distance + _.x * (_.x < 0 ? i : s) + _.y * (_.y < 0 ? n : o) + _.z * (_.z < 0 ? a : l) < 0) return !1;
            var h = this._left.normal;
            if (this._left.distance + h.x * (h.x < 0 ? i : s) + h.y * (h.y < 0 ? n : o) + h.z * (h.z < 0 ? a : l) < 0) return !1;
            var c = this._right.normal;
            if (this._right.distance + c.x * (c.x < 0 ? i : s) + c.y * (c.y < 0 ? n : o) + c.z * (c.z < 0 ? a : l) < 0) return !1;
            var d = this._bottom.normal;
            if (this._bottom.distance + d.x * (d.x < 0 ? i : s) + d.y * (d.y < 0 ? n : o) + d.z * (d.z < 0 ? a : l) < 0) return !1;
            var u = this._top.normal;
            if (this._top.distance + u.x * (u.x < 0 ? i : s) + u.y * (u.y < 0 ? n : o) + u.z * (u.z < 0 ? a : l) < 0) return !1;
            var f = this._far.normal;
            return !(this._far.distance + f.x * (f.x < 0 ? i : s) + f.y * (f.y < 0 ? n : o) + f.z * (f.z < 0 ? a : l) < 0);
        }
        containsBoundBox(e) {
            for (var t = k._tempV30, r = k._tempV31, i = e.min, n = e.max, a = H.Contains, s = 0; s < 6; s++) {
                var o = this.getPlane(s),
                    l = o.normal;
                if (l.x >= 0 ? (t.x = n.x, r.x = i.x) : (t.x = i.x, r.x = n.x), l.y >= 0 ? (t.y = n.y,
                        r.y = i.y) : (t.y = i.y, r.y = n.y), l.z >= 0 ? (t.z = n.z, r.z = i.z) : (t.z = i.z,
                        r.z = n.z), W.intersectsPlaneAndPoint(o, t) === G.PlaneIntersectionType_Back) return H.Disjoint;
                W.intersectsPlaneAndPoint(o, r) === G.PlaneIntersectionType_Back && (a = H.Intersects);
            }
            return a;
        }
        containsBoundSphere(e) {
            for (var t = G.PlaneIntersectionType_Front, r = G.PlaneIntersectionType_Front, i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        r = W.intersectsPlaneAndSphere(this._near, e);
                        break;

                    case 1:
                        r = W.intersectsPlaneAndSphere(this._far, e);
                        break;

                    case 2:
                        r = W.intersectsPlaneAndSphere(this._left, e);
                        break;

                    case 3:
                        r = W.intersectsPlaneAndSphere(this._right, e);
                        break;

                    case 4:
                        r = W.intersectsPlaneAndSphere(this._top, e);
                        break;

                    case 5:
                        r = W.intersectsPlaneAndSphere(this._bottom, e);
                }
                switch (r) {
                    case G.PlaneIntersectionType_Back:
                        return H.Disjoint;

                    case G.PlaneIntersectionType_Intersecting:
                        t = G.PlaneIntersectionType_Intersecting;
                }
            }
            switch (t) {
                case G.PlaneIntersectionType_Intersecting:
                    return H.Intersects;

                default:
                    return H.Contains;
            }
        }
    }
    k._tempV30 = new a(), k._tempV31 = new a(), k._tempV32 = new a(), k._tempV33 = new a(),
        k._tempV34 = new a(), k._tempV35 = new a(), k._tempV36 = new a(), k._tempV37 = new a();
    class X {
        constructor(e, t, r, i) {
            this.minDepth = 0, this.maxDepth = 1, this.x = e, this.y = t, this.width = r, this.height = i;
        }
        project(e, t, r) {
            a.transformV3ToV3(e, t, r);
            var i = t.elements,
                n = e.x * i[3] + e.y * i[7] + e.z * i[11] + i[15];
            1 !== n && (r.x = r.x / n, r.y = r.y / n, r.z = r.z / n), r.x = .5 * (r.x + 1) * this.width + this.x,
                r.y = .5 * (1 - r.y) * this.height + this.y, r.z = r.z * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(e, t, r) {
            var i = t.elements;
            r.x = (e.x - this.x) / this.width * 2 - 1, r.y = -((e.y - this.y) / this.height * 2 - 1);
            var n = (this.maxDepth - this.minDepth) / 2;
            r.z = (e.z - this.minDepth - n) / n;
            var s = r.x * i[3] + r.y * i[7] + r.z * i[11] + i[15];
            a.transformV3ToV3(r, t, r), 1 !== s && (r.x = r.x / s, r.y = r.y / s, r.z = r.z / s);
        }
        unprojectFromWVP(e, t, r, i, n) {
            T.multiply(t, r, X._tempMatrix4x4), i && T.multiply(X._tempMatrix4x4, i, X._tempMatrix4x4),
                X._tempMatrix4x4.invert(X._tempMatrix4x4), this.unprojectFromMat(e, X._tempMatrix4x4, n);
        }
        cloneTo(e) {
            e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e.minDepth = this.minDepth,
                e.maxDepth = this.maxDepth;
        }
    }
    X._tempMatrix4x4 = new T();
    class Y extends t.BaseTexture {
        constructor(e, r, i = t.BaseTexture.FORMAT_R8G8B8, n = t.BaseTexture.FORMAT_DEPTH_16) {
            super(i, !1), this._inPool = !1, this._glTextureType = t.LayaGL.instance.TEXTURE_2D,
                this._width = e, this._height = r, this._depthStencilFormat = n, this._create(e, r);
        }
        static get currentActive() {
            return Y._currentActive;
        }
        static createFromPool(e, r, i = t.BaseTexture.FORMAT_R8G8B8, n = t.BaseTexture.FORMAT_DEPTH_16, a = t.BaseTexture.FILTERMODE_BILINEAR) {
            for (var s, o = 0, l = Y._pool.length; o < l; o++)
                if ((s = Y._pool[o])._width == e && s._height == r && s._format == i && s._depthStencilFormat == n && s._filterMode == a) {
                    s._inPool = !1;
                    var _ = Y._pool[l - 1];
                    return Y._pool[o] = _, Y._pool.length -= 1, s;
                }
            return (s = new Y(e, r, i, n)).filterMode = a, s.lock = !0, s;
        }
        static recoverToPool(e) {
            e._inPool || (Y._pool.push(e), e._inPool = !0);
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaulteTexture() {
            return t.Texture2D.grayTexture;
        }
        _texImage2D(e, r, i, n) {
            switch (this._format) {
                case t.BaseTexture.FORMAT_R8G8B8:
                    e.texImage2D(r, 0, e.RGB, i, n, 0, e.RGB, e.UNSIGNED_BYTE, null);
                    break;

                case t.BaseTexture.FORMAT_R8G8B8A8:
                    e.texImage2D(r, 0, e.RGBA, i, n, 0, e.RGBA, e.UNSIGNED_BYTE, null);
                    break;

                case t.BaseTexture.FORMAT_ALPHA8:
                    e.texImage2D(r, 0, e.ALPHA, i, n, 0, e.ALPHA, e.UNSIGNED_BYTE, null);
                    break;

                case t.BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT:
                    t.LayaGL.layaGPUInstance._isWebGL2 ? e.texImage2D(this._glTextureType, 0, e.RGBA16F, i, n, 0, e.RGBA, e.HALF_FLOAT, null) : e.texImage2D(this._glTextureType, 0, e.RGBA, i, n, 0, e.RGBA, t.LayaGL.layaGPUInstance._oesTextureHalfFloat.HALF_FLOAT_OES, null);
            }
        }
        _create(e, r) {
            var i = t.LayaGL.instance;
            if (this._frameBuffer = i.createFramebuffer(), t.WebGLContext.bindTexture(i, this._glTextureType, this._glTexture),
                this._texImage2D(i, this._glTextureType, e, r), this._setGPUMemory(e * r * 4), i.bindFramebuffer(i.FRAMEBUFFER, this._frameBuffer),
                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, this._glTexture, 0),
                this._depthStencilFormat !== t.BaseTexture.FORMAT_DEPTHSTENCIL_NONE) switch (this._depthStencilBuffer = i.createRenderbuffer(),
                i.bindRenderbuffer(i.RENDERBUFFER, this._depthStencilBuffer), this._depthStencilFormat) {
                case t.BaseTexture.FORMAT_DEPTH_16:
                    i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_COMPONENT16, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                case t.BaseTexture.FORMAT_STENCIL_8:
                    i.renderbufferStorage(i.RENDERBUFFER, i.STENCIL_INDEX8, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                case t.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                    i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, e, r), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, this._depthStencilBuffer);
                    break;

                default:
                    throw "RenderTexture: unkonw depth format.";
            }
            i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindRenderbuffer(i.RENDERBUFFER, null),
                this._setWarpMode(i.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(i.TEXTURE_WRAP_T, this._wrapModeV),
                this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._readyed = !0,
                this._activeResource();
        }
        _start() {
            var e = t.LayaGL.instance;
            e.bindFramebuffer(e.FRAMEBUFFER, this._frameBuffer), Y._currentActive = this, this._readyed = !1;
        }
        _end() {
            var e = t.LayaGL.instance;
            e.bindFramebuffer(e.FRAMEBUFFER, null), Y._currentActive = null, this._readyed = !0;
        }
        getData(e, r, i, n, a) {
            if (t.Render.isConchApp && 2 == window.conchConfig.threadMode) throw "native 2 thread mode use getDataAsync";
            var s = t.LayaGL.instance;
            return s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.checkFramebufferStatus(s.FRAMEBUFFER) === s.FRAMEBUFFER_COMPLETE ? (s.readPixels(e, r, i, n, s.RGBA, s.UNSIGNED_BYTE, a),
                s.bindFramebuffer(s.FRAMEBUFFER, null), a) : (s.bindFramebuffer(s.FRAMEBUFFER, null),
                null);
        }
        getDataAsync(e, r, i, n, a) {
            var s = t.LayaGL.instance;
            s.bindFramebuffer(s.FRAMEBUFFER, this._frameBuffer), s.readPixelsAsync(e, r, i, n, s.RGBA, s.UNSIGNED_BYTE, function(e) {
                a(new Uint8Array(e));
            }), s.bindFramebuffer(s.FRAMEBUFFER, null);
        }
        _disposeResource() {
            if (this._frameBuffer) {
                var e = t.LayaGL.instance;
                e.deleteTexture(this._glTexture), e.deleteFramebuffer(this._frameBuffer), e.deleteRenderbuffer(this._depthStencilBuffer),
                    this._glTexture = null, this._frameBuffer = null, this._depthStencilBuffer = null,
                    this._setGPUMemory(0);
            }
        }
    }
    Y._pool = [];
    class Z {
        constructor() {}
        static calculateCursorRay(e, t, r, i, n, s) {
            var o = e.x,
                l = e.y,
                _ = Z._tempVector30,
                h = _;
            h.x = o, h.y = l, h.z = t.minDepth;
            var c = Z._tempVector31,
                d = c;
            d.x = o, d.y = l, d.z = t.maxDepth;
            var u = s.origin,
                f = Z._tempVector32;
            t.unprojectFromWVP(_, r, i, n, u), t.unprojectFromWVP(c, r, i, n, f);
            var E = s.direction;
            E.x = f.x - u.x, E.y = f.y - u.y, E.z = f.z - u.z, a.normalize(s.direction, s.direction);
        }
        static rayIntersectsTriangle(e, t, r, i) {
            var n = Z._tempVector30,
                s = Z._tempVector31;
            a.subtract(r, t, n), a.subtract(i, t, s);
            var o, l = Z._tempVector32;
            if (a.cross(e.direction, s, l), (o = a.dot(n, l)) > -Number.MIN_VALUE && o < Number.MIN_VALUE) return Number.NaN;
            var _, h = 1 / o,
                c = Z._tempVector33;
            if (a.subtract(e.origin, t, c), _ = a.dot(c, l), (_ *= h) < 0 || _ > 1) return Number.NaN;
            var d, u, f = Z._tempVector34;
            return a.cross(c, n, f), d = a.dot(e.direction, f), (d *= h) < 0 || _ + d > 1 ? Number.NaN : (u = a.dot(s, f),
                (u *= h) < 0 ? Number.NaN : u);
        }
    }
    Z._tempVector30 = new a(), Z._tempVector31 = new a(), Z._tempVector32 = new a(),
        Z._tempVector33 = new a(), Z._tempVector34 = new a();
    class j {
        constructor() {}
        _render(e) {}
    }
    class q extends j {
        static __init__() {
            q.instance = new q();
        }
        constructor() {
            super();
            var e = t.LayaGL.instance,
                r = new Float32Array([-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1]),
                i = new Uint8Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 0, 3, 7, 7, 4, 0, 1, 5, 6, 6, 2, 1, 3, 2, 6, 6, 7, 3, 0, 4, 5, 5, 1, 0]),
                n = v.getVertexDeclaration("POSITION");
            this._vertexBuffer = new d(8 * n.vertexStride, e.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = n,
                this._indexBuffer = new c(c.INDEXTYPE_UBYTE, 36, e.STATIC_DRAW, !1), this._vertexBuffer.setData(r.buffer),
                this._indexBuffer.setData(i);
            var a = new _();
            a.bind(), a.applyVertexBuffer(this._vertexBuffer), a.applyIndexBuffer(this._indexBuffer),
                a.unBind(), this._bufferState = a;
        }
        _render(e) {
            var r = t.LayaGL.instance;
            r.drawElements(r.TRIANGLES, 36, r.UNSIGNED_BYTE, 0), t.Stat.trianglesFaces += 12,
                t.Stat.renderBatches++;
        }
    }
    class K {
        constructor() {
            this._mesh = q.instance;
        }
        get material() {
            return this._material;
        }
        set material(e) {
            this._material !== e && (this._material && this._material._removeReference(), e && e._addReference(),
                this._material = e);
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            this._mesh !== e && (this._mesh = e);
        }
        _isAvailable() {
            return !(!this._material || !this._mesh);
        }
        _render(e) {
            if (this._material && this._mesh) {
                var r = t.LayaGL.instance,
                    i = e.scene,
                    n = e.camera,
                    a = p._SET_RUNTIME_VALUE_MODE_REFERENCE_;
                t.ILaya.Render.supportWebGLPlusRendering && p.setRuntimeValueMode(!1), t.WebGLContext.setCullFace(r, !1),
                    t.WebGLContext.setDepthFunc(r, r.LEQUAL), t.WebGLContext.setDepthMask(r, !1);
                var s = e.shader = this._material._shader.getSubShaderAt(0)._passes[0].withCompile(0, 0, this._material._shaderValues._defineDatas.value),
                    o = s.bind(),
                    l = t.Stat.loopCount !== s._uploadMark,
                    _ = s._uploadScene !== i || l;
                (_ || o) && (s.uploadUniforms(s._sceneUniformParamsMap, i._shaderValues, _), s._uploadScene = i);
                var h = n._renderTexture || n._offScreenRenderTexture,
                    c = s._uploadCamera !== n || l;
                if (c || o) {
                    var d = K._tempMatrix0,
                        u = n.projectionMatrix;
                    n.transform.worldMatrix.cloneTo(d), d.transpose(), n.orthographic && (u = K._tempMatrix1,
                            T.createPerspective(n.fieldOfView, n.aspectRatio, n.nearPlane, n.farPlane, u)),
                        n._applyViewProject(e, d, u, !!h), s.uploadUniforms(s._cameraUniformParamsMap, n._shaderValues, c),
                        s._uploadCamera = n;
                }
                var f = s._uploadMaterial !== this._material || l;
                (f || o) && (s.uploadUniforms(s._materialUniformParamsMap, this._material._shaderValues, f),
                    s._uploadMaterial = this._material), this._mesh._bufferState.bind(), this._mesh._render(e),
                    t.ILaya.Render.supportWebGLPlusRendering && p.setRuntimeValueMode(a), t.WebGLContext.setDepthFunc(r, r.LESS),
                    t.WebGLContext.setDepthMask(r, !0), n._applyViewProject(e, n.viewMatrix, n.projectionMatrix, !!h);
            }
        }
        destroy() {
            this._material && (this._material._removeReference(), this._material = null);
        }
    }
    K._tempMatrix0 = new T(), K._tempMatrix1 = new T();
    class Q extends b {
        constructor(e = .3, t = 1e3) {
            super(), this._skyRenderer = new K(), this._forward = new a(), this._up = new a(),
                this.clearColor = new n(100 / 255, 149 / 255, 237 / 255, 1), this._shaderValues = new p(null),
                this._fieldOfView = 60, this._useUserProjectionMatrix = !1, this._orthographic = !1,
                this._orthographicVerticalSize = 10, this.renderingOrder = 0, this._nearPlane = e,
                this._farPlane = t, this.cullingMask = 2147483647, this.clearFlag = Q.CLEARFLAG_SOLIDCOLOR,
                this.useOcclusionCulling = !0;
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get fieldOfView() {
            return this._fieldOfView;
        }
        set fieldOfView(e) {
            this._fieldOfView = e, this._calculateProjectionMatrix();
        }
        get nearPlane() {
            return this._nearPlane;
        }
        set nearPlane(e) {
            this._nearPlane = e, this._calculateProjectionMatrix();
        }
        get farPlane() {
            return this._farPlane;
        }
        set farPlane(e) {
            this._farPlane = e, this._calculateProjectionMatrix();
        }
        get orthographic() {
            return this._orthographic;
        }
        set orthographic(e) {
            this._orthographic = e, this._calculateProjectionMatrix();
        }
        get orthographicVerticalSize() {
            return this._orthographicVerticalSize;
        }
        set orthographicVerticalSize(e) {
            this._orthographicVerticalSize = e, this._calculateProjectionMatrix();
        }
        get renderingOrder() {
            return this._renderingOrder;
        }
        set renderingOrder(e) {
            this._renderingOrder = e, this._sortCamerasByRenderingOrder();
        }
        _sortCamerasByRenderingOrder() {
            if (this.displayedInStage)
                for (var e = this.scene._cameraPool, t = e.length - 1, r = 0; r < t; r++)
                    if (e[r].renderingOrder > e[t].renderingOrder) {
                        var i = e[r];
                        e[r] = e[t], e[t] = i;
                    }
        }
        _calculateProjectionMatrix() {}
        _onScreenSizeChanged() {
            this._calculateProjectionMatrix();
        }
        _prepareCameraToRender() {
            var e = this._shaderValues;
            this.transform.getForward(this._forward), this.transform.getUp(this._up), e.setVector3(Q.CAMERAPOS, this.transform.position),
                e.setVector3(Q.CAMERADIRECTION, this._forward), e.setVector3(Q.CAMERAUP, this._up);
        }
        render(e = null, t = null) {}
        addLayer(e) {
            this.cullingMask |= Math.pow(2, e);
        }
        removeLayer(e) {
            this.cullingMask &= ~Math.pow(2, e);
        }
        addAllLayers() {
            this.cullingMask = 2147483647;
        }
        removeAllLayers() {
            this.cullingMask = 0;
        }
        resetProjectionMatrix() {
            this._useUserProjectionMatrix = !1, this._calculateProjectionMatrix();
        }
        _onActive() {
            this._scene._addCamera(this), super._onActive();
        }
        _onInActive() {
            this._scene._removeCamera(this), super._onInActive();
        }
        _parse(e, r) {
            super._parse(e, r);
            var i = e.clearFlag;
            void 0 !== i && (this.clearFlag = i), this.orthographic = e.orthographic, void 0 !== e.orthographicVerticalSize && (this.orthographicVerticalSize = e.orthographicVerticalSize),
                void 0 !== e.fieldOfView && (this.fieldOfView = e.fieldOfView), this.nearPlane = e.nearPlane,
                this.farPlane = e.farPlane;
            var a = e.clearColor;
            this.clearColor = new n(a[0], a[1], a[2], a[3]);
            var s = e.skyboxMaterial;
            s && (this._skyRenderer.material = t.Loader.getRes(s.path));
        }
        destroy(e = !0) {
            this._skyRenderer.destroy(), this._skyRenderer = null, t.Laya.stage.off(t.Event.RESIZE, this, this._onScreenSizeChanged),
                super.destroy(e);
        }
        _create() {
            return new Q();
        }
    }
    Q._tempMatrix4x40 = new T(), Q.CAMERAPOS = L.propertyNameToID("u_CameraPos"), Q.VIEWMATRIX = L.propertyNameToID("u_View"),
        Q.PROJECTMATRIX = L.propertyNameToID("u_Projection"), Q.VIEWPROJECTMATRIX = L.propertyNameToID("u_ViewProjection"),
        Q.CAMERADIRECTION = L.propertyNameToID("u_CameraDirection"), Q.CAMERAUP = L.propertyNameToID("u_CameraUp"),
        Q.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING", Q.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING",
        Q.CLEARFLAG_SOLIDCOLOR = 0, Q.CLEARFLAG_SKY = 1, Q.CLEARFLAG_DEPTHONLY = 2, Q.CLEARFLAG_NONE = 3,
        Q._invertYScaleMatrix = new T(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        Q._invertYProjectionMatrix = new T(), Q._invertYProjectionViewMatrix = new T();
    class J {
        constructor() {}
    }
    J._instance = new J();
    class $ extends t.Resource {
        constructor() {
            super(), this._bufferState = new _(), this._bufferStateInvertUV = new _();
            var e = t.LayaGL.instance;
            this._vertexBuffer = new d(64, e.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = $._vertexDeclaration,
                this._vertexBuffer.setData($._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                this._bufferState.unBind(), this._vertexBufferInvertUV = new d(64, e.STATIC_DRAW, !1),
                this._vertexBufferInvertUV.vertexDeclaration = $._vertexDeclaration, this._vertexBufferInvertUV.setData($._verticesInvertUV.buffer),
                this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV),
                this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
        }
        static __init__() {
            $._vertexDeclaration = new g(16, [new S(0, u.Vector4, $.SCREENQUAD_POSITION_UV)]),
                $.instance = new $(), $.instance.lock = !0;
        }
        render() {
            var e = t.LayaGL.instance;
            this._bufferState.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
        }
        renderInvertUV() {
            var e = t.LayaGL.instance;
            this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLE_STRIP, 0, 4), t.Stat.renderBatches++;
        }
        destroy() {
            super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(),
                this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0);
        }
    }
    $.SCREENQUAD_POSITION_UV = 0, $._vertices = new Float32Array([1, 1, 1, 0, 1, -1, 1, 1, -1, 1, 0, 0, -1, -1, 0, 1]),
        $._verticesInvertUV = new Float32Array([1, 1, 1, 1, 1, -1, 1, 0, -1, 1, 0, 1, -1, -1, 0, 0]);
    class ee extends t.Resource {
        constructor() {
            super(), this._bufferState = new _(), this._bufferStateInvertUV = new _();
            var e = t.LayaGL.instance;
            this._vertexBuffer = new d(48, e.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = ee._vertexDeclaration,
                this._vertexBuffer.setData(ee._vertices.buffer), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                this._bufferState.unBind(), this._vertexBufferInvertUV = new d(48, e.STATIC_DRAW, !1),
                this._vertexBufferInvertUV.vertexDeclaration = ee._vertexDeclaration, this._vertexBufferInvertUV.setData(ee._verticesInvertUV.buffer),
                this._bufferStateInvertUV.bind(), this._bufferStateInvertUV.applyVertexBuffer(this._vertexBufferInvertUV),
                this._bufferStateInvertUV.unBind(), this._setGPUMemory(this._vertexBuffer._byteLength + this._vertexBufferInvertUV._byteLength);
        }
        static __init__() {
            ee._vertexDeclaration = new g(16, [new S(0, u.Vector4, ee.SCREENTRIANGLE_POSITION_UV)]),
                ee.instance = new ee(), ee.instance.lock = !0;
        }
        render() {
            var e = t.LayaGL.instance;
            this._bufferState.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
        }
        renderInvertUV() {
            var e = t.LayaGL.instance;
            this._bufferStateInvertUV.bind(), e.drawArrays(e.TRIANGLES, 0, 3), t.Stat.renderBatches++;
        }
        destroy() {
            super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(), this._bufferStateInvertUV.destroy(),
                this._vertexBufferInvertUV.destroy(), this._setGPUMemory(0);
        }
    }
    ee.SCREENTRIANGLE_POSITION_UV = 0, ee._vertices = new Float32Array([-1, -1, 0, 1, -1, 3, 0, -1, 3, -1, 2, 1]),
        ee._verticesInvertUV = new Float32Array([-1, -1, 0, 0, -1, 3, 0, 2, 3, -1, 2, 0]);
    class te {
        constructor() {
            this._commandBuffer = null;
        }
        static __init__() {
            te._screenShaderData = new p(), te._screenShader = L.find("BlitScreen");
        }
        run() {}
        recover() {
            this._commandBuffer = null;
        }
    }
    te.SCREENTEXTURE_NAME = "u_MainTex", te.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize",
        te.SCREENTEXTURE_ID = L.propertyNameToID(te.SCREENTEXTURE_NAME), te.MAINTEXTURE_TEXELSIZE_ID = L.propertyNameToID(te.MAINTEXTURE_TEXELSIZE_NAME);
    class re extends te {
        constructor() {
            super(...arguments), this._source = null, this._dest = null, this._shader = null,
                this._shaderData = null, this._subShader = 0, this._sourceTexelSize = new n(), this._screenType = 0;
        }
        static create(e, t, r = null, i = null, n = 0, a = re._SCREENTYPE_QUAD) {
            var s;
            return (s = re._pool.length > 0 ? re._pool.pop() : new re())._source = e, s._dest = t,
                s._shader = r, s._shaderData = i, s._subShader = n, s._screenType = a, s;
        }
        run() {
            var e = this._shader || te._screenShader,
                r = this._shaderData || te._screenShaderData,
                i = this._dest;
            t.LayaGL.instance.viewport(0, 0, i ? i.width : J.clientWidth, i ? i.height : J.clientHeight),
                r.setTexture(te.SCREENTEXTURE_ID, this._source), this._sourceTexelSize.setValue(1 / this._source.width, 1 / this._source.height, this._source.width, this._source.height),
                r.setVector(te.MAINTEXTURE_TEXELSIZE_ID, this._sourceTexelSize), i && i._start();
            for (var n = e.getSubShaderAt(this._subShader)._passes, a = 0, s = n.length; a < s; a++) {
                var o = n[a].withCompile(0, 0, r._defineDatas.value);
                switch (o.bind(), o.uploadUniforms(o._materialUniformParamsMap, r, !0), o.uploadRenderStateBlendDepth(r),
                    o.uploadRenderStateFrontFace(r, !1, null), this._screenType) {
                    case re._SCREENTYPE_QUAD:
                        i ? $.instance.renderInvertUV() : $.instance.render();
                        break;

                    case re._SCREENTYPE_TRIANGLE:
                        i ? ee.instance.renderInvertUV() : ee.instance.render();
                }
            }
            i && i._end();
        }
        recover() {
            re._pool.push(this), this._dest = null, this._shader = null, this._shaderData = null,
                super.recover();
        }
    }
    re._SCREENTYPE_QUAD = 0, re._SCREENTYPE_TRIANGLE = 1, re._pool = [];
    class ie extends te {
        constructor() {
            super(...arguments), this._renderTexture = null;
        }
        static create(e) {
            var t;
            return (t = ie._pool.length > 0 ? ie._pool.pop() : new ie())._renderTexture = e,
                t;
        }
        run() {
            this._renderTexture._start();
        }
        recover() {
            ie._pool.push(this), this._renderTexture = null;
        }
    }
    ie._pool = [];
    class ne extends te {
        constructor() {
            super(...arguments), this._shaderData = null, this._nameID = 0, this._texture = null;
        }
        static create(e, t, r) {
            var i;
            return (i = ne._pool.length > 0 ? ne._pool.pop() : new ne())._shaderData = e, i._nameID = t,
                i._texture = r, i;
        }
        run() {
            this._shaderData.setTexture(this._nameID, this._texture);
        }
        recover() {
            ne._pool.push(this), this._shaderData = null, this._nameID = 0, this._texture = null;
        }
    }
    ne._pool = [];
    class ae {
        constructor() {
            this._camera = null, this._commands = [];
        }
        _apply() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].run();
        }
        setShaderDataTexture(e, t, r) {
            this._commands.push(ne.create(e, t, r));
        }
        blitScreenQuad(e, t, r = null, i = null, n = 0) {
            this._commands.push(re.create(e, t, r, i, n, re._SCREENTYPE_QUAD));
        }
        blitScreenTriangle(e, t, r = null, i = null, n = 0) {
            this._commands.push(re.create(e, t, r, i, n, re._SCREENTYPE_TRIANGLE));
        }
        setRenderTarget(e) {
            this._commands.push(ie.create(e));
        }
        clear() {
            for (var e = 0, t = this._commands.length; e < t; e++) this._commands[e].recover();
            this._commands.length = 0;
        }
    }
    class se {}
    class oe extends Q {
        constructor(e = 0, r = .3, i = 1e3) {
            super(r, i), this._updateViewMatrix = !0, this._offScreenRenderTexture = null, this._postProcess = null,
                this._enableHDR = !1, this._renderTexture = null, this._postProcessCommandBuffers = [],
                this.enableRender = !0, this._viewMatrix = new T(), this._projectionMatrix = new T(),
                this._projectionViewMatrix = new T(), this._viewport = new X(0, 0, 0, 0), this._normalizedViewport = new X(0, 0, 1, 1),
                this._aspectRatio = e, this._boundFrustum = new k(T.DEFAULT), t.Render.supportWebGLPlusCulling && (this._boundFrustumBuffer = new Float32Array(24)),
                this._calculateProjectionMatrix(), t.Laya.stage.on(t.Event.RESIZE, this, this._onScreenSizeChanged),
                this.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        get aspectRatio() {
            if (0 === this._aspectRatio) {
                var e = this.viewport;
                return e.width / e.height;
            }
            return this._aspectRatio;
        }
        set aspectRatio(e) {
            if (e < 0) throw new Error("Camera: the aspect ratio has to be a positive real number.");
            this._aspectRatio = e, this._calculateProjectionMatrix();
        }
        get viewport() {
            return this._offScreenRenderTexture ? this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height) : this._calculationViewport(this._normalizedViewport, J.clientWidth, J.clientHeight),
                this._viewport;
        }
        set viewport(e) {
            var t, r;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = J.clientWidth,
                    r = J.clientHeight), this._normalizedViewport.x = e.x / t, this._normalizedViewport.y = e.y / r,
                this._normalizedViewport.width = e.width / t, this._normalizedViewport.height = e.height / r,
                this._calculationViewport(this._normalizedViewport, t, r), this._calculateProjectionMatrix();
        }
        get normalizedViewport() {
            return this._normalizedViewport;
        }
        set normalizedViewport(e) {
            var t, r;
            this._offScreenRenderTexture ? (t = this._offScreenRenderTexture.width, r = this._offScreenRenderTexture.height) : (t = J.clientWidth,
                    r = J.clientHeight), this._normalizedViewport !== e && e.cloneTo(this._normalizedViewport),
                this._calculationViewport(e, t, r), this._calculateProjectionMatrix();
        }
        get viewMatrix() {
            if (this._updateViewMatrix) {
                var e = this.transform.getWorldLossyScale(),
                    t = e.x,
                    r = e.y,
                    i = e.z,
                    n = this._viewMatrix.elements;
                this.transform.worldMatrix.cloneTo(this._viewMatrix), n[0] /= t, n[1] /= t, n[2] /= t,
                    n[4] /= r, n[5] /= r, n[6] /= r, n[8] /= i, n[9] /= i, n[10] /= i, this._viewMatrix.invert(this._viewMatrix),
                    this._updateViewMatrix = !1;
            }
            return this._viewMatrix;
        }
        get projectionMatrix() {
            return this._projectionMatrix;
        }
        set projectionMatrix(e) {
            this._projectionMatrix = e, this._useUserProjectionMatrix = !0;
        }
        get projectionViewMatrix() {
            return T.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix),
                this._projectionViewMatrix;
        }
        get boundFrustum() {
            if (this._boundFrustum.matrix = this.projectionViewMatrix, t.Render.supportWebGLPlusCulling) {
                var e = this._boundFrustum.near,
                    r = this._boundFrustum.far,
                    i = this._boundFrustum.left,
                    n = this._boundFrustum.right,
                    a = this._boundFrustum.top,
                    s = this._boundFrustum.bottom,
                    o = e.normal,
                    l = r.normal,
                    _ = i.normal,
                    h = n.normal,
                    c = a.normal,
                    d = s.normal,
                    u = this._boundFrustumBuffer;
                u[0] = o.x, u[1] = o.y, u[2] = o.z, u[3] = e.distance, u[4] = l.x, u[5] = l.y, u[6] = l.z,
                    u[7] = r.distance, u[8] = _.x, u[9] = _.y, u[10] = _.z, u[11] = i.distance, u[12] = h.x,
                    u[13] = h.y, u[14] = h.z, u[15] = n.distance, u[16] = c.x, u[17] = c.y, u[18] = c.z,
                    u[19] = a.distance, u[20] = d.x, u[21] = d.y, u[22] = d.z, u[23] = s.distance;
            }
            return this._boundFrustum;
        }
        get renderTarget() {
            return this._offScreenRenderTexture;
        }
        set renderTarget(e) {
            this._offScreenRenderTexture !== e && (this._offScreenRenderTexture = e, this._calculateProjectionMatrix());
        }
        get postProcess() {
            return this._postProcess;
        }
        set postProcess(e) {
            this._postProcess = e;
            var t = new ae();
            this.addCommandBuffer(oe.CAMERAEVENT_POSTPROCESS, t), e._init(this, t);
        }
        get enableHDR() {
            return this._enableHDR;
        }
        set enableHDR(e) {
            this._enableHDR = e;
        }
        _isLayerVisible(e) {
            return 0 != (Math.pow(2, e) & this.cullingMask);
        }
        _onTransformChanged(e) {
            (e &= w.TRANSFORM_WORLDMATRIX) && (this._updateViewMatrix = !0);
        }
        _calculationViewport(e, t, r) {
            var i = e.x * t,
                n = e.y * r,
                a = i + Math.max(e.width * t, 0),
                s = n + Math.max(e.height * r, 0),
                o = Math.ceil(i),
                l = Math.ceil(n),
                _ = Math.floor(a),
                h = Math.floor(s),
                c = o - i >= .5 ? Math.floor(i) : o,
                d = l - n >= .5 ? Math.floor(n) : l,
                u = a - _ >= .5 ? Math.ceil(a) : _,
                f = s - h >= .5 ? Math.ceil(s) : h;
            this._viewport.x = c, this._viewport.y = d, this._viewport.width = u - c, this._viewport.height = f - d;
        }
        _parse(e, t) {
            super._parse(e, t);
            var r = e.viewport;
            this.normalizedViewport = new X(r[0], r[1], r[2], r[3]);
            var i = e.enableHDR;
            void 0 !== i && (this.enableHDR = i);
        }
        _calculateProjectionMatrix() {
            if (!this._useUserProjectionMatrix)
                if (this._orthographic) {
                    var e = this.orthographicVerticalSize * this.aspectRatio * .5,
                        t = .5 * this.orthographicVerticalSize;
                    T.createOrthoOffCenter(-e, e, -t, t, this.nearPlane, this.farPlane, this._projectionMatrix);
                } else T.createPerspective(3.1416 * this.fieldOfView / 180, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
        }
        _getCanvasHeight() {
            return this._offScreenRenderTexture ? this._offScreenRenderTexture.height : J.clientHeight;
        }
        _applyPostProcessCommandBuffers() {
            for (var e = 0, t = this._postProcessCommandBuffers.length; e < t; e++) this._postProcessCommandBuffers[e]._apply();
        }
        _getRenderTextureFormat() {
            return this._enableHDR ? t.BaseTexture.RENDERTEXTURE_FORMAT_RGBA_HALF_FLOAT : t.BaseTexture.FORMAT_R8G8B8;
        }
        render(e = null, r = null) {
            if (this._scene) {
                var i = !(!this._postProcess && !this._enableHDR);
                i && (this._renderTexture = Y.createFromPool(J.clientWidth, J.clientHeight, this._getRenderTextureFormat(), t.BaseTexture.FORMAT_DEPTH_16, t.BaseTexture.FILTERMODE_BILINEAR));
                var n = t.LayaGL.instance,
                    a = J._instance,
                    s = a.scene = this._scene;
                if (s.parallelSplitShadowMaps[0]) {
                    p.setRuntimeValueMode(!1);
                    var o = s.parallelSplitShadowMaps[0];
                    o._calcAllLightCameraInfo(this), s._shaderValues.addDefine(se.SHADERDEFINE_CAST_SHADOW);
                    for (var l = 0, _ = o.shadowMapCount; l < _; l++) {
                        var h = o.cameras[l];
                        a.camera = h, U.renderObjectCulling(h, s, a, s._castShadowRenders, e, r);
                        var c = o.cameras[l + 1].renderTarget;
                        c._start(), a.camera = h, a.viewport = h.viewport, h._prepareCameraToRender(), h._applyViewProject(a, h.viewMatrix, h.projectionMatrix, !1),
                            s._clear(n, a), s._opaqueQueue._render(a, !1), c._end();
                    }
                    s._shaderValues.removeDefine(se.SHADERDEFINE_CAST_SHADOW), p.setRuntimeValueMode(!0);
                }
                a.camera = this, s._preRenderScript();
                var d = this._renderTexture || this._offScreenRenderTexture;
                if (d && d._start(), a.viewport = this.viewport, this._prepareCameraToRender(),
                    this._applyViewProject(a, this.viewMatrix, this._projectionMatrix, !!d), s._preCulling(a, this, e, r),
                    s._clear(n, a), s._renderScene(a), s._postRenderScript(), d && d._end(), i) {
                    if (this._postProcess) this._postProcess._render(), this._applyPostProcessCommandBuffers();
                    else if (this._enableHDR) {
                        var u = re.create(this._renderTexture, this._offScreenRenderTexture ? this._offScreenRenderTexture : null);
                        u.run(), u.recover();
                    }
                    Y.recoverToPool(this._renderTexture);
                }
            }
        }
        _applyViewProject(e, t, r, i) {
            var n, a = this._shaderValues;
            i ? (T.multiply(Q._invertYScaleMatrix, r, Q._invertYProjectionMatrix), T.multiply(Q._invertYProjectionMatrix, t, Q._invertYProjectionViewMatrix),
                    r = Q._invertYProjectionMatrix, n = Q._invertYProjectionViewMatrix) : (T.multiply(r, t, this._projectionViewMatrix),
                    n = this._projectionViewMatrix), e.viewMatrix = t, e.projectionMatrix = r, e.projectionViewMatrix = n,
                a.setMatrix4x4(Q.VIEWMATRIX, t), a.setMatrix4x4(Q.PROJECTMATRIX, r), a.setMatrix4x4(Q.VIEWPROJECTMATRIX, n);
        }
        viewportPointToRay(e, t) {
            Z.calculateCursorRay(e, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }
        normalizedViewportPointToRay(e, t) {
            var r = oe._tempVector20,
                i = this.viewport;
            r.x = e.x * i.width, r.y = e.y * i.height, Z.calculateCursorRay(r, this.viewport, this._projectionMatrix, this.viewMatrix, null, t);
        }
        worldToViewportPoint(e, r) {
            T.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                this.viewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                r.y = r.y / t.Laya.stage.clientScaleY;
        }
        worldToNormalizedViewportPoint(e, r) {
            T.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix),
                this.normalizedViewport.project(e, this._projectionViewMatrix, r), r.x = r.x / t.Laya.stage.clientScaleX,
                r.y = r.y / t.Laya.stage.clientScaleY;
        }
        convertScreenCoordToOrthographicCoord(e, t) {
            if (this._orthographic) {
                var r = J.clientWidth,
                    i = J.clientHeight,
                    n = this.orthographicVerticalSize * this.aspectRatio / r,
                    s = this.orthographicVerticalSize / i;
                return t.x = (-r / 2 + e.x) * n, t.y = (i / 2 - e.y) * s, t.z = (this.nearPlane - this.farPlane) * (e.z + 1) / 2 - this.nearPlane,
                    a.transformCoordinate(t, this.transform.worldMatrix, t), !0;
            }
            return !1;
        }
        destroy(e = !0) {
            this._offScreenRenderTexture = null, this.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged),
                super.destroy(e);
        }
        addCommandBuffer(e, t) {
            switch (e) {
                case oe.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.push(t), t._camera = this;
                    break;

                default:
                    throw "Camera:unknown event.";
            }
        }
        removeCommandBuffer(e, t) {
            switch (e) {
                case oe.CAMERAEVENT_POSTPROCESS:
                    var r = this._postProcessCommandBuffers.indexOf(t); -
                    1 !== r && this._postProcessCommandBuffers.splice(r, 1);
                    break;

                default:
                    throw "Camera:unknown event.";
            }
        }
        removeCommandBuffers(e) {
            switch (e) {
                case oe.CAMERAEVENT_POSTPROCESS:
                    this._postProcessCommandBuffers.length = 0;
                    break;

                default:
                    throw "Camera:unknown event.";
            }
        }
        _create() {
            return new oe();
        }
    }
    oe.CAMERAEVENT_POSTPROCESS = 0, oe._tempVector20 = new i(), oe._updateMark = 0;
    class le {
        constructor() {
            this.renderSubShader = null, this.renderType = le.RENDERTYPE_NORMAL;
        }
        getInvertFront() {
            return this._transform._isFrontFaceInvert;
        }
        setTransform(e) {
            this._transform = e;
        }
        setGeometry(e) {
            this._geometry = e;
        }
        addToOpaqueRenderQueue(e, t) {
            t.elements.add(this);
        }
        addToTransparentRenderQueue(e, t) {
            t.elements.add(this), t.lastTransparentBatched = !1, t.lastTransparentRenderElement = this;
        }
        _update(e, t, r, i) {
            if (this.material) {
                var n = this.material._shader.getSubShaderAt(0);
                if (this.renderSubShader = null, r)
                    if (i) {
                        var a = n.getFlag(i);
                        if (!a) return;
                        for (var s = r._subShaders, o = 0, l = s.length; o < l; o++) {
                            var _ = s[o];
                            if (a === _.getFlag(i)) {
                                this.renderSubShader = _;
                                break;
                            }
                        }
                        if (!this.renderSubShader) return;
                    } else this.renderSubShader = r.getSubShaderAt(0);
                else this.renderSubShader = n;
                var h = e._getRenderQueue(this.material.renderQueue);
                h.isTransparent ? this.addToTransparentRenderQueue(t, h) : this.addToOpaqueRenderQueue(t, h);
            }
        }
        _render(e, t) {
            var r, i, n, a = oe._updateMark,
                s = e.scene,
                o = e.camera,
                l = this._transform,
                _ = this._geometry;
            e.renderElement = this;
            var h = a !== this.render._updateMark || this.renderType !== this.render._updateRenderType;
            if (h && (this.render._renderUpdate(e, l), this.render._renderUpdateWithCamera(e, l),
                    this.render._updateMark = a, this.render._updateRenderType = this.renderType), _._prepareRender(e))
                for (var c = this.renderSubShader._passes, d = 0, u = c.length; d < u; d++) {
                    var f = e.shader = c[d].withCompile(s._shaderValues._defineDatas.value & ~this.material._disablePublicDefineDatas.value, this.render._shaderValues._defineDatas.value, this.material._shaderValues._defineDatas.value),
                        E = f.bind(),
                        T = a !== f._uploadMark,
                        m = f._uploadScene !== s || T;
                    (m || E) && (f.uploadUniforms(f._sceneUniformParamsMap, s._shaderValues, m), f._uploadScene = s);
                    var p = f._uploadRender !== this.render || f._uploadRenderType !== this.renderType || T;
                    (p || E) && (f.uploadUniforms(f._spriteUniformParamsMap, this.render._shaderValues, p),
                        f._uploadRender = this.render, f._uploadRenderType = this.renderType);
                    var g = f._uploadCamera !== o || T;
                    (g || E) && (f.uploadUniforms(f._cameraUniformParamsMap, o._shaderValues, g), f._uploadCamera = o);
                    var S = f._uploadMaterial !== this.material || T;
                    (S || E) && (f.uploadUniforms(f._materialUniformParamsMap, this.material._shaderValues, S),
                        f._uploadMaterial = this.material);
                    var v = this.material._shaderValues;
                    r !== this.material || i !== f ? (f.uploadRenderStateBlendDepth(v), f.uploadRenderStateFrontFace(v, t, this.getInvertFront()),
                        r = this.material, i = f, n = this.render) : n !== this.render && (f.uploadRenderStateFrontFace(v, t, this.getInvertFront()),
                        n = this.render), _._render(e), f._uploadMark = a;
                }
            h && this.renderType !== le.RENDERTYPE_NORMAL && this.render._revertBatchRenderUpdate(e),
                oe._updateMark++;
        }
        destroy() {
            this._transform = null, this._geometry = null, this.material = null, this.render = null;
        }
    }
    le.RENDERTYPE_NORMAL = 0, le.RENDERTYPE_STATICBATCH = 1, le.RENDERTYPE_INSTANCEBATCH = 2,
        le.RENDERTYPE_VERTEXBATCH = 3;
    class _e extends le {
        constructor() {
            super(), this._dynamicWorldPositionNormalNeedUpdate = !0;
        }
        _onWorldMatrixChanged() {
            this._dynamicWorldPositionNormalNeedUpdate = !0;
        }
        _computeWorldPositionsAndNormals(e, t, r, i) {
            if (this._dynamicWorldPositionNormalNeedUpdate) {
                for (var n = this._geometry, a = n._vertexBuffer, s = a.vertexDeclaration.vertexStride / 4, o = a.getFloat32Data(), l = this._transform.worldMatrix, _ = this._transform.rotation, h = n._indices, c = 0; c < i; c++) {
                    var d = (r ? h[c] : c) * s,
                        u = 3 * c;
                    M.transformVector3ArrayToVector3ArrayCoordinate(o, d + e, l, this._dynamicWorldPositions, u), -1 !== t && M.transformVector3ArrayByQuat(o, d + t, _, this._dynamicWorldNormals, u);
                }
                this._dynamicWorldPositionNormalNeedUpdate = !1;
            }
        }
        setTransform(e) {
            this._transform !== e && (this._transform && this._transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged),
                e && e.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged), this._dynamicWorldPositionNormalNeedUpdate = !0,
                this._transform = e);
        }
        setGeometry(e) {
            if (this._geometry !== e) {
                var t = e,
                    r = t._mesh;
                if (r) {
                    var i = r._subMeshes.length > 1,
                        n = i ? t._indexCount : r._vertexCount;
                    if (n <= o.SubMeshDynamicBatch.maxAllowVertexCount) {
                        var a = 3 * n;
                        this._dynamicVertexBatch = !0, this._dynamicWorldPositions = new Float32Array(a),
                            this._dynamicWorldNormals = new Float32Array(a), this._dynamicVertexCount = n, this._dynamicMultiSubMesh = i;
                    } else this._dynamicVertexBatch = !1;
                }
                this._geometry = e;
            }
        }
        addToOpaqueRenderQueue(e, r) {
            var i = this.staticBatch,
                n = r.elements,
                a = n.elements;
            if (i) {
                var s = o.MeshRenderStaticBatchManager.instance,
                    l = s.getBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, i._batchID);
                if (s._updateCountMark === l.updateMark) {
                    var _ = l.indexInList;
                    if (l.batched) a[_].staticBatchElementList.add(this);
                    else {
                        var h = a[_],
                            c = h.render,
                            d = s._getBatchRenderElementFromPool();
                        d.renderType = le.RENDERTYPE_STATICBATCH, d.setGeometry(i), d.material = h.material;
                        var u = i.batchOwner,
                            f = u ? u._transform : null;
                        d.setTransform(f), d.render = c, d.renderSubShader = h.renderSubShader;
                        var E = d.staticBatchElementList;
                        E.length = 0, E.add(h), E.add(this), a[_] = d, l.batched = !0;
                    }
                } else l.updateMark = s._updateCountMark, l.indexInList = n.length, l.batched = !1,
                    n.add(this);
            } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                var T = this._geometry,
                    m = o.MeshRenderDynamicBatchManager.instance,
                    p = m.getInstanceBatchOpaquaMark(this.render.receiveShadow, this.material.id, T._id, this._transform._isFrontFaceInvert);
                if (m._updateCountMark === p.updateMark) {
                    var g = p.indexInList;
                    if (p.batched) {
                        var S = a[g].instanceBatchElementList;
                        S.length === D.instance.maxInstanceCount ? (p.updateMark = m._updateCountMark, p.indexInList = n.length,
                            p.batched = !1, n.add(this)) : S.add(this);
                    } else {
                        var v = a[g],
                            R = v.render,
                            A = m._getBatchRenderElementFromPool();
                        A.renderType = le.RENDERTYPE_INSTANCEBATCH, A.setGeometry(D.instance), A.material = v.material,
                            A.setTransform(null), A.render = R, A.instanceSubMesh = T, A.renderSubShader = v.renderSubShader;
                        var I = A.instanceBatchElementList;
                        I.length = 0, I.add(v), I.add(this), a[g] = A, p.batched = !0;
                    }
                } else p.updateMark = m._updateCountMark, p.indexInList = n.length, p.batched = !1,
                    n.add(this);
            } else if (this._dynamicVertexBatch) {
                var x = this._geometry._vertexBuffer.vertexDeclaration,
                    M = o.MeshRenderDynamicBatchManager.instance,
                    L = M.getVertexBatchOpaquaMark(this.render.lightmapIndex + 1, this.render.receiveShadow, this.material.id, x.id);
                if (M._updateCountMark === L.updateMark) {
                    var C = L.indexInList;
                    if (L.batched) a[C].vertexBatchElementList.add(this);
                    else {
                        var y = a[C],
                            O = y.render,
                            N = M._getBatchRenderElementFromPool();
                        N.renderType = le.RENDERTYPE_VERTEXBATCH, N.setGeometry(o.SubMeshDynamicBatch.instance),
                            N.material = y.material, N.setTransform(null), N.render = O, N.vertexBatchVertexDeclaration = x,
                            N.renderSubShader = y.renderSubShader;
                        var P = N.vertexBatchElementList;
                        P.length = 0, P.add(y), P.add(this), a[C] = N, L.batched = !0;
                    }
                } else L.updateMark = M._updateCountMark, L.indexInList = n.length, L.batched = !1,
                    n.add(this);
            } else n.add(this);
        }
        addToTransparentRenderQueue(e, r) {
            var i = this.staticBatch,
                n = r.elements,
                a = n.elements;
            if (i) {
                var s = o.MeshRenderStaticBatchManager.instance,
                    l = r.lastTransparentRenderElement;
                if (l) {
                    var _ = l.render;
                    if (l._geometry._getType() !== this._geometry._getType() || l.staticBatch !== i || l.material !== this.material || _.receiveShadow !== this.render.receiveShadow || _.lightmapIndex !== this.render.lightmapIndex) n.add(this),
                        r.lastTransparentBatched = !1;
                    else {
                        if (r.lastTransparentBatched) a[n.length - 1].staticBatchElementList.add(this);
                        else {
                            var h = s._getBatchRenderElementFromPool();
                            h.renderType = le.RENDERTYPE_STATICBATCH, h.setGeometry(i), h.material = l.material;
                            var c = i.batchOwner,
                                d = c ? c._transform : null;
                            h.setTransform(d), h.render = this.render, h.renderSubShader = l.renderSubShader;
                            var u = h.staticBatchElementList;
                            u.length = 0, u.add(l), u.add(this), a[n.length - 1] = h;
                        }
                        r.lastTransparentBatched = !0;
                    }
                } else n.add(this), r.lastTransparentBatched = !1;
            } else if (this.renderSubShader._owner._enableInstancing && t.LayaGL.layaGPUInstance.supportInstance() && this.render.lightmapIndex < 0) {
                var f = this._geometry,
                    E = o.MeshRenderDynamicBatchManager.instance,
                    T = r.lastTransparentRenderElement;
                if (T) {
                    var m = T.render;
                    if (T._geometry._getType() !== this._geometry._getType() || T._geometry !== f || T.material !== this.material || m.receiveShadow !== this.render.receiveShadow) n.add(this),
                        r.lastTransparentBatched = !1;
                    else if (r.lastTransparentBatched) {
                        var p = a[n.length - 1].instanceBatchElementList;
                        p.length === D.instance.maxInstanceCount ? (n.add(this), r.lastTransparentBatched = !1) : (p.add(this),
                            r.lastTransparentBatched = !0);
                    } else {
                        var g = E._getBatchRenderElementFromPool();
                        g.renderType = le.RENDERTYPE_INSTANCEBATCH, g.setGeometry(D.instance), g.material = T.material,
                            g.setTransform(null), g.render = this.render, g.instanceSubMesh = f, g.renderSubShader = T.renderSubShader;
                        var S = g.instanceBatchElementList;
                        S.length = 0, S.add(T), S.add(this), a[n.length - 1] = g, r.lastTransparentBatched = !0;
                    }
                } else n.add(this), r.lastTransparentBatched = !1;
            } else if (this._dynamicVertexBatch) {
                var v = this._geometry._vertexBuffer.vertexDeclaration,
                    R = o.MeshRenderDynamicBatchManager.instance,
                    A = r.lastTransparentRenderElement;
                if (A) {
                    var I = A.render;
                    if (A._geometry._getType() !== this._geometry._getType() || A._geometry._vertexBuffer._vertexDeclaration !== v || A.material !== this.material || I.receiveShadow !== this.render.receiveShadow || I.lightmapIndex !== this.render.lightmapIndex) n.add(this),
                        r.lastTransparentBatched = !1;
                    else {
                        if (r.lastTransparentBatched) a[n.length - 1].vertexBatchElementList.add(this);
                        else {
                            var x = R._getBatchRenderElementFromPool();
                            x.renderType = le.RENDERTYPE_VERTEXBATCH, x.setGeometry(o.SubMeshDynamicBatch.instance),
                                x.material = A.material, x.setTransform(null), x.render = this.render, x.vertexBatchVertexDeclaration = v,
                                x.renderSubShader = A.renderSubShader;
                            var M = x.vertexBatchElementList;
                            M.length = 0, M.add(A), M.add(this), a[n.length - 1] = x;
                        }
                        r.lastTransparentBatched = !0;
                    }
                } else n.add(this), r.lastTransparentBatched = !1;
            } else n.add(this);
            r.lastTransparentRenderElement = this;
        }
        getInvertFront() {
            switch (this.renderType) {
                case le.RENDERTYPE_NORMAL:
                    return this._transform._isFrontFaceInvert;

                case le.RENDERTYPE_STATICBATCH:
                case le.RENDERTYPE_VERTEXBATCH:
                    return !1;

                case le.RENDERTYPE_INSTANCEBATCH:
                    return this.instanceBatchElementList.elements[0]._transform._isFrontFaceInvert;

                default:
                    throw "SubMeshRenderElement: unknown renderType";
            }
        }
        destroy() {
            super.destroy(), this._dynamicWorldPositions = null, this._dynamicWorldNormals = null,
                this.staticBatch = null, this.staticBatchElementList = null, this.vertexBatchElementList = null,
                this.vertexBatchVertexDeclaration = null;
        }
    }
    class he {
        constructor() {
            this.elements = [], this.length = 0;
        }
        _add(e) {
            this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e;
        }
        add(e) {
            this.length === this.elements.length ? this.elements.push(e) : this.elements[this.length] = e,
                this.length++;
        }
    }
    class ce extends l {
        constructor() {
            super(), this._instanceBatchOpaqueMarks = [], this._vertexBatchOpaqueMarks = [],
                this._cacheBufferStates = [], this._updateCountMark = 0;
        }
        getInstanceBatchOpaquaMark(e, t, r, i) {
            var n = this._instanceBatchOpaqueMarks[e ? 0 : 1] || (this._instanceBatchOpaqueMarks[e ? 0 : 1] = []),
                a = n[t] || (n[t] = []),
                s = a[r] || (a[r] = []);
            return s[i ? 1 : 0] || (s[i ? 1 : 0] = new A());
        }
        getVertexBatchOpaquaMark(e, t, r, i) {
            var n = this._vertexBatchOpaqueMarks[e] || (this._vertexBatchOpaqueMarks[e] = []),
                a = n[t ? 0 : 1] || (n[t ? 0 : 1] = []),
                s = a[r] || (a[r] = []);
            return s[i] || (s[i] = new A());
        }
        _getBufferState(e) {
            var t = this._cacheBufferStates[e.id];
            if (!t) {
                var r = R.instance;
                (t = new _()).bind();
                var i = r._vertexBuffer;
                i.vertexDeclaration = e, t.applyVertexBuffer(i), t.applyIndexBuffer(r._indexBuffer),
                    t.unBind(), this._cacheBufferStates[e.id] = t;
            }
            return t;
        }
        _getBatchRenderElementFromPool() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new _e(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                e.vertexBatchElementList = new he(), e.instanceBatchElementList = new he()), e;
        }
        _clear() {
            super._clear(), this._updateCountMark++;
        }
    }
    ce.instance = new ce();
    class de extends h {
        constructor(e, t, r) {
            super(), this._bufferState = new _(), this._batchID = de._batchIDCounter++, this._batchElements = [],
                this._currentBatchVertexCount = 0, this._currentBatchIndexCount = 0, this._vertexDeclaration = r,
                this.batchOwner = e, this.number = t;
        }
        _getStaticBatchBakedVertexs(e, t, r, i, n, a) {
            var s, o = a._vertexBuffer,
                l = o.vertexDeclaration,
                _ = l.getVertexElementByUsage(v.MESH_POSITION0)._offset / 4,
                h = l.getVertexElementByUsage(v.MESH_NORMAL0),
                c = h ? h._offset / 4 : -1,
                d = l.getVertexElementByUsage(v.MESH_COLOR0),
                u = d ? d._offset / 4 : -1,
                f = l.getVertexElementByUsage(v.MESH_TEXTURECOORDINATE0),
                E = f ? f._offset / 4 : -1,
                m = l.getVertexElementByUsage(v.MESH_TEXTURECOORDINATE1),
                p = m ? m._offset / 4 : -1,
                g = l.getVertexElementByUsage(v.MESH_TANGENT0),
                S = g ? g._offset / 4 : -1,
                R = l.vertexStride / 4,
                A = o.getFloat32Data();
            r ? (r.worldMatrix.invert(de._tempMatrix4x40), s = de._tempMatrix4x41, T.multiply(de._tempMatrix4x40, i.worldMatrix, s)) : s = i.worldMatrix;
            var D = de._tempQuaternion0;
            s.decomposeTransRotScale(de._tempVector30, D, de._tempVector31);
            for (var I = n.lightmapScaleOffset, x = a.vertexCount, L = 0; L < x; L++) {
                var C, y, O = L * R,
                    N = 18 * (L + t);
                M.transformVector3ArrayToVector3ArrayCoordinate(A, O + _, s, e, N + 0), -1 !== c && M.transformVector3ArrayByQuat(A, O + c, D, e, N + 3);
                var P = N + 6;
                if (-1 !== u) {
                    var V = O + u;
                    for (C = 0, y = 4; C < y; C++) e[P + C] = A[V + C];
                } else
                    for (C = 0, y = 4; C < y; C++) e[P + C] = 1;
                if (-1 !== E) {
                    var w = O + E;
                    e[N + 10] = A[w], e[N + 11] = A[w + 1];
                }
                if (I && (-1 !== p ? M.transformLightingMapTexcoordArray(A, O + p, I, e, N + 12) : M.transformLightingMapTexcoordArray(A, O + E, I, e, N + 12)), -1 !== S) {
                    var b = O + S;
                    e[N + 14] = A[b], e[N + 15] = A[b + 1], e[N + 16] = A[b + 2], e[N + 17] = A[b + 3];
                }
            }
            return x;
        }
        addTest(e) {
            var t = e.meshFilter.sharedMesh.vertexCount;
            return !(this._currentBatchVertexCount + t > de.maxBatchVertexCount);
        }
        add(e) {
            var t = e._render._staticBatch;
            t && t.remove(e);
            var r = e.meshFilter.sharedMesh,
                i = r.vertexCount;
            this._batchElements.push(e);
            var n = e._render;
            n._isPartOfStaticBatch = !0, n._staticBatch = this;
            for (var a = n._renderElements, s = 0, o = a.length; s < o; s++) a[s].staticBatch = this;
            this._currentBatchIndexCount += r._indexBuffer.indexCount, this._currentBatchVertexCount += i;
        }
        remove(e) {
            var t = e.meshFilter.sharedMesh,
                r = this._batchElements.indexOf(e);
            if (-1 !== r) {
                this._batchElements.splice(r, 1);
                e._render;
                for (var i = e._render._renderElements, n = 0, a = i.length; n < a; n++) i[n].staticBatch = null;
                var s = t.vertexCount;
                this._currentBatchIndexCount = this._currentBatchIndexCount - t._indexBuffer.indexCount,
                    this._currentBatchVertexCount = this._currentBatchVertexCount - s, e._render._isPartOfStaticBatch = !1;
            }
        }
        finishInit() {
            this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy(),
                t.Resource._addGPUMemory(-(this._vertexBuffer._byteLength + this._indexBuffer._byteLength)));
            var e = t.LayaGL.instance,
                r = 0,
                i = 0,
                n = this.batchOwner,
                a = this._vertexDeclaration.vertexStride / 4,
                s = new Float32Array(a * this._currentBatchVertexCount),
                o = new Uint16Array(this._currentBatchIndexCount);
            this._vertexBuffer = new d(this._vertexDeclaration.vertexStride * this._currentBatchVertexCount, e.STATIC_DRAW),
                this._vertexBuffer.vertexDeclaration = this._vertexDeclaration, this._indexBuffer = new c(c.INDEXTYPE_USHORT, this._currentBatchIndexCount, e.STATIC_DRAW);
            for (var l = 0, _ = this._batchElements.length; l < _; l++) {
                for (var h, u = this._batchElements[l], f = u.meshFilter.sharedMesh, E = this._getStaticBatchBakedVertexs(s, r, n ? n._transform : null, u._transform, u._render, f), T = f._indexBuffer.getData(), m = r, p = i + T.length, g = u._render._renderElements, S = 0, v = f.subMeshCount; S < v; S++) {
                    var R = f._subMeshes[S],
                        A = i + R._indexStart,
                        D = g[S];
                    D.staticBatchIndexStart = A, D.staticBatchIndexEnd = A + R._indexCount;
                }
                if (o.set(T, i), n ? u._transform._isFrontFaceInvert !== n.transform._isFrontFaceInvert : u._transform._isFrontFaceInvert)
                    for (h = i; h < p; h += 3) {
                        o[h] = m + o[h];
                        var I = o[h + 1],
                            x = o[h + 2];
                        o[h + 1] = m + x, o[h + 2] = m + I;
                    } else
                        for (h = i; h < p; h += 3) o[h] = m + o[h], o[h + 1] = m + o[h + 1], o[h + 2] = m + o[h + 2];
                i += T.length, r += E;
            }
            this._vertexBuffer.setData(s.buffer), this._indexBuffer.setData(o);
            var M = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addGPUMemory(M), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
        }
        _render(e) {
            this._bufferState.bind();
            for (var r = t.LayaGL.instance, i = e.renderElement.staticBatchElementList, n = i.elements, a = 0, s = 0, o = i.length, l = 1; l < o; l++) {
                if (n[l - 1].staticBatchIndexEnd !== n[l].staticBatchIndexStart) {
                    var _ = n[a].staticBatchIndexStart,
                        h = n[s].staticBatchIndexEnd - _;
                    r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _), a = ++s, t.Stat.trianglesFaces += h / 3;
                } else s++;
            }
            _ = n[a].staticBatchIndexStart, h = n[s].staticBatchIndexEnd - _, r.drawElements(r.TRIANGLES, h, r.UNSIGNED_SHORT, 2 * _),
                t.Stat.renderBatches++, t.Stat.savedRenderBatches += o - 1, t.Stat.trianglesFaces += h / 3;
        }
        dispose() {
            var e = this._vertexBuffer._byteLength + this._indexBuffer._byteLength;
            t.Resource._addGPUMemory(-e), this._batchElements = null, this.batchOwner = null,
                this._vertexDeclaration = null, this._bufferState.destroy(), this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(), this._vertexBuffer = null, this._indexBuffer = null,
                this._bufferState = null;
        }
    }
    de._tempVector30 = new a(), de._tempVector31 = new a(), de._tempQuaternion0 = new E(),
        de._tempMatrix4x40 = new T(), de._tempMatrix4x41 = new T(), de.maxBatchVertexCount = 65535,
        de._batchIDCounter = 0;
    class ue extends B {
        constructor() {
            super(), this._opaqueBatchMarks = [], this._updateCountMark = 0;
        }
        static __init__() {
            ue._verDec = v.getVertexDeclaration("POSITION,NORMAL,COLOR,UV,UV1,TANGENT");
        }
        _compare(e, t) {
            var r = e._render,
                i = t._render,
                n = e.meshFilter.sharedMesh,
                a = t.meshFilter.sharedMesh,
                s = r.lightmapIndex - i.lightmapIndex;
            if (0 === s) {
                var o = (r.receiveShadow ? 1 : 0) - (i.receiveShadow ? 1 : 0);
                if (0 === o) {
                    var l = r.sharedMaterial.id - i.sharedMaterial.id;
                    if (0 === l) {
                        var _ = n._vertexBuffer.vertexDeclaration.id - a._vertexBuffer.vertexDeclaration.id;
                        return 0 === _ ? a._indexBuffer.indexCount - n._indexBuffer.indexCount : _;
                    }
                    return l;
                }
                return o;
            }
            return s;
        }
        _getBatchRenderElementFromPool() {
            var e = this._batchRenderElementPool[this._batchRenderElementPoolIndex++];
            return e || (e = new _e(), this._batchRenderElementPool[this._batchRenderElementPoolIndex - 1] = e,
                e.staticBatchElementList = new he()), e;
        }
        _getStaticBatch(e, t) {
            var r = e ? e.id : 0,
                i = this._staticBatches[r];
            return i || (i = this._staticBatches[r] = []), i[t] || (i[t] = new de(e, t, ue._verDec));
        }
        _initStaticBatchs(e) {
            this._quickSort(this._initBatchSprites, 0, this._initBatchSprites.length - 1);
            for (var t, r = !1, i = 0, n = 0, a = this._initBatchSprites.length; n < a; n++) {
                var s = this._initBatchSprites[n];
                if (r) t.addTest(s) ? t.add(s) : (r = !1, i++);
                else n !== a - 1 && ((t = this._getStaticBatch(e, i)).add(s),
                    r = !0);
            }
            for (var o in this._staticBatches) {
                var l = this._staticBatches[o];
                for (n = 0, a = l.length; n < a; n++) l[n].finishInit();
            }
            this._initBatchSprites.length = 0;
        }
        _destroyRenderSprite(e) {
            var t = e._render._staticBatch;
            if (t.remove(e), 0 === t._batchElements.length) {
                var r = t.batchOwner,
                    i = r ? r.id : 0,
                    n = this._staticBatches[i];
                n[t.number] = null, t.dispose();
                for (var a = !0, s = 0; s < n.length; s++) n[s] && (a = !1);
                a && delete this._staticBatches[i];
            }
        }
        _clear() {
            super._clear(), this._updateCountMark++;
        }
        _garbageCollection() {
            for (var e in this._staticBatches)
                for (var t = this._staticBatches[e], r = 0, i = t.length; r < i; r++) {
                    var n = t[r];
                    0 === n._batchElements.length && (n.dispose(), t.splice(r, 1), r--, 0 === --i && delete this._staticBatches[e]);
                }
        }
        getBatchOpaquaMark(e, t, r, i) {
            var n = t ? 1 : 0,
                a = this._opaqueBatchMarks[e] || (this._opaqueBatchMarks[e] = []),
                s = a[n] || (a[n] = []),
                o = s[r] || (s[r] = []);
            return o[i] || (o[i] = new A());
        }
    }
    ue.instance = new ue();
    class fe {}
    fe._physics3D = null, fe._enbalePhysics = !1;
    class Ee {
        constructor() {}
        static setColliderCollision(e, t, r) {}
        static getIColliderCollision(e, t) {
            return !1;
        }
    }
    Ee.COLLISIONFILTERGROUP_DEFAULTFILTER = 1, Ee.COLLISIONFILTERGROUP_STATICFILTER = 2,
        Ee.COLLISIONFILTERGROUP_KINEMATICFILTER = 4, Ee.COLLISIONFILTERGROUP_DEBRISFILTER = 8,
        Ee.COLLISIONFILTERGROUP_SENSORTRIGGER = 16, Ee.COLLISIONFILTERGROUP_CHARACTERFILTER = 32,
        Ee.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 64, Ee.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 128,
        Ee.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 256, Ee.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 512,
        Ee.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 1024, Ee.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 2048,
        Ee.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 4096, Ee.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 8192,
        Ee.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 16384, Ee.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 32768,
        Ee.COLLISIONFILTERGROUP_ALLFILTER = -1, Ee.gravity = new a(0, -9.81, 0);
    class Te {
        constructor() {
            this._scale = new a(1, 1, 1), this._centerMatrix = new T(), this._attatched = !1,
                this._indexInCompound = -1, this._compoundParent = null, this._attatchedCollisionObject = null,
                this._referenceCount = 0, this._localOffset = new a(0, 0, 0), this._localRotation = new E(0, 0, 0, 1),
                this.needsCustomCollisionCallback = !1;
        }
        static __init__() {
            Te._nativeScale = new fe._physics3D.btVector3(1, 1, 1), Te._nativeVector30 = new fe._physics3D.btVector3(0, 0, 0),
                Te._nativQuaternion0 = new fe._physics3D.btQuaternion(0, 0, 0, 1), Te._nativeTransform0 = new fe._physics3D.btTransform();
        }
        static _createAffineTransformation(e, t, r) {
            var i = t.x,
                n = t.y,
                a = t.z,
                s = t.w,
                o = i + i,
                l = n + n,
                _ = a + a,
                h = i * o,
                c = i * l,
                d = i * _,
                u = n * l,
                f = n * _,
                E = a * _,
                T = s * o,
                m = s * l,
                p = s * _;
            r[0] = 1 - (u + E), r[1] = c + p, r[2] = d - m, r[3] = 0, r[4] = c - p, r[5] = 1 - (h + E),
                r[6] = f + T, r[7] = 0, r[8] = d + m, r[9] = f - T, r[10] = 1 - (h + u), r[11] = 0,
                r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1;
        }
        get type() {
            return this._type;
        }
        get localOffset() {
            return this._localOffset;
        }
        set localOffset(e) {
            this._localOffset = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }
        get localRotation() {
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation = e, this._compoundParent && this._compoundParent._updateChildTransform(this);
        }
        _setScale(e) {
            this._compoundParent ? this.updateLocalTransformations() : (Te._nativeScale.setValue(e.x, e.y, e.z),
                this._nativeShape.setLocalScaling(Te._nativeScale));
        }
        _addReference() {
            this._referenceCount++;
        }
        _removeReference() {
            this._referenceCount--;
        }
        updateLocalTransformations() {
            if (this._compoundParent) {
                var e = Te._tempVector30;
                a.multiply(this.localOffset, this._scale, e), Te._createAffineTransformation(e, this.localRotation, this._centerMatrix.elements);
            } else Te._createAffineTransformation(this.localOffset, this.localRotation, this._centerMatrix.elements);
        }
        cloneTo(e) {
            var t = e;
            this._localOffset.cloneTo(t.localOffset), this._localRotation.cloneTo(t.localRotation),
                t.localOffset = t.localOffset, t.localRotation = t.localRotation;
        }
        clone() {
            return null;
        }
        destroy() {
            this._nativeShape && (fe._physics3D.destroy(this._nativeShape), this._nativeShape = null);
        }
    }
    Te.SHAPEORIENTATION_UPX = 0, Te.SHAPEORIENTATION_UPY = 1, Te.SHAPEORIENTATION_UPZ = 2,
        Te.SHAPETYPES_BOX = 0, Te.SHAPETYPES_SPHERE = 1, Te.SHAPETYPES_CYLINDER = 2, Te.SHAPETYPES_CAPSULE = 3,
        Te.SHAPETYPES_CONVEXHULL = 4, Te.SHAPETYPES_COMPOUND = 5, Te.SHAPETYPES_STATICPLANE = 6,
        Te.SHAPETYPES_CONE = 7, Te._tempVector30 = new a();
    class me extends Te {
        static __init__() {
            me._nativeSize = new fe._physics3D.btVector3(0, 0, 0);
        }
        get sizeX() {
            return this._sizeX;
        }
        get sizeY() {
            return this._sizeY;
        }
        get sizeZ() {
            return this._sizeZ;
        }
        constructor(e = 1, t = 1, r = 1) {
            super(), this._sizeX = e, this._sizeY = t, this._sizeZ = r, this._type = Te.SHAPETYPES_BOX,
                me._nativeSize.setValue(e / 2, t / 2, r / 2), this._nativeShape = new fe._physics3D.btBoxShape(me._nativeSize);
        }
        clone() {
            var e = new me(this._sizeX, this._sizeY, this._sizeZ);
            return this.cloneTo(e), e;
        }
    }
    class pe extends Te {
        constructor(e = .5, t = 1.25, r = Te.SHAPEORIENTATION_UPY) {
            switch (super(), this._radius = e, this._length = t, this._orientation = r, this._type = Te.SHAPETYPES_CAPSULE,
                r) {
                case Te.SHAPEORIENTATION_UPX:
                    this._nativeShape = new fe._physics3D.btCapsuleShapeX(e, t - 2 * e);
                    break;

                case Te.SHAPEORIENTATION_UPY:
                    this._nativeShape = new fe._physics3D.btCapsuleShape(e, t - 2 * e);
                    break;

                case Te.SHAPEORIENTATION_UPZ:
                    this._nativeShape = new fe._physics3D.btCapsuleShapeZ(e, t - 2 * e);
                    break;

                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        get length() {
            return this._length;
        }
        get orientation() {
            return this._orientation;
        }
        _setScale(e) {
            var t = pe._tempVector30;
            switch (this.orientation) {
                case Te.SHAPEORIENTATION_UPX:
                    t.x = e.x, t.y = t.z = Math.max(e.y, e.z);
                    break;

                case Te.SHAPEORIENTATION_UPY:
                    t.y = e.y, t.x = t.z = Math.max(e.x, e.z);
                    break;

                case Te.SHAPEORIENTATION_UPZ:
                    t.z = e.z, t.x = t.y = Math.max(e.x, e.y);
                    break;

                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
            super._setScale(t);
        }
        clone() {
            var e = new pe(this._radius, this._length, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    pe._tempVector30 = new a();
    class ge extends Te {
        constructor() {
            super(), this._childColliderShapes = [], this._type = Te.SHAPETYPES_COMPOUND, this._nativeShape = new fe._physics3D.btCompoundShape();
        }
        static __init__() {
            ge._nativeVector3One = new fe._physics3D.btVector3(1, 1, 1), ge._nativeTransform = new fe._physics3D.btTransform(),
                ge._nativeOffset = new fe._physics3D.btVector3(0, 0, 0), ge._nativRotation = new fe._physics3D.btQuaternion(0, 0, 0, 1);
        }
        _clearChildShape(e) {
            e._attatched = !1, e._compoundParent = null, e._indexInCompound = -1;
        }
        _addReference() {}
        _removeReference() {}
        _updateChildTransform(e) {
            var t = e.localOffset,
                r = e.localRotation,
                i = Te._nativeVector30,
                n = Te._nativQuaternion0,
                a = Te._nativeTransform0;
            i.setValue(-t.x, t.y, t.z), n.setValue(-r.x, r.y, r.z, -r.w), a.setOrigin(i), a.setRotation(n),
                this._nativeShape.updateChildTransform(e._indexInCompound, a, !0);
        }
        addChildShape(e) {
            if (e._attatched) throw "CompoundColliderShape: this shape has attatched to other entity.";
            e._attatched = !0, e._compoundParent = this, e._indexInCompound = this._childColliderShapes.length,
                this._childColliderShapes.push(e);
            var t = e.localOffset,
                r = e.localRotation;
            ge._nativeOffset.setValue(-t.x, t.y, t.z), ge._nativRotation.setValue(-r.x, r.y, r.z, -r.w),
                ge._nativeTransform.setOrigin(ge._nativeOffset), ge._nativeTransform.setRotation(ge._nativRotation);
            var i = this._nativeShape.getLocalScaling();
            this._nativeShape.setLocalScaling(ge._nativeVector3One), this._nativeShape.addChildShape(ge._nativeTransform, e._nativeShape),
                this._nativeShape.setLocalScaling(i), this._attatchedCollisionObject && (this._attatchedCollisionObject.colliderShape = this);
        }
        removeChildShape(e) {
            if (e._compoundParent === this) {
                var t = e._indexInCompound;
                this._clearChildShape(e);
                var r = this._childColliderShapes[this._childColliderShapes.length - 1];
                r._indexInCompound = t, this._childColliderShapes[t] = r, this._childColliderShapes.pop(),
                    this._nativeShape.removeChildShapeByIndex(t);
            }
        }
        clearChildShape() {
            for (var e = 0, t = this._childColliderShapes.length; e < t; e++) this._clearChildShape(this._childColliderShapes[e]),
                this._nativeShape.removeChildShapeByIndex(0);
            this._childColliderShapes.length = 0;
        }
        getChildShapeCount() {
            return this._childColliderShapes.length;
        }
        cloneTo(e) {
            var t = e;
            t.clearChildShape();
            for (var r = 0, i = this._childColliderShapes.length; r < i; r++) t.addChildShape(this._childColliderShapes[r].clone());
        }
        clone() {
            var e = new ge();
            return this.cloneTo(e), e;
        }
        destroy() {
            super.destroy();
            for (var e = 0, t = this._childColliderShapes.length; e < t; e++) {
                var r = this._childColliderShapes[e];
                0 === r._referenceCount && r.destroy();
            }
        }
    }
    class Se extends Te {
        constructor(e = .5, t = 1, r = Te.SHAPEORIENTATION_UPY) {
            switch (super(), this._radius = 1, this._height = .5, this._radius = e, this._height = t,
                this._orientation = r, this._type = Te.SHAPETYPES_CYLINDER, r) {
                case Te.SHAPEORIENTATION_UPX:
                    this._nativeShape = new fe._physics3D.btConeShapeX(e, t);
                    break;

                case Te.SHAPEORIENTATION_UPY:
                    this._nativeShape = new fe._physics3D.btConeShape(e, t);
                    break;

                case Te.SHAPEORIENTATION_UPZ:
                    this._nativeShape = new fe._physics3D.btConeShapeZ(e, t);
                    break;

                default:
                    throw "ConeColliderShape:unknown orientation.";
            }
        }
        get radius() {
            return this._radius;
        }
        get height() {
            return this._height;
        }
        get orientation() {
            return this._orientation;
        }
        clone() {
            var e = new Se(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    class ve extends Te {
        constructor(e = .5, t = 1, r = Te.SHAPEORIENTATION_UPY) {
            switch (super(), this._radius = 1, this._height = .5, this._radius = e, this._height = t,
                this._orientation = r, this._type = Te.SHAPETYPES_CYLINDER, r) {
                case Te.SHAPEORIENTATION_UPX:
                    ve._nativeSize.setValue(t / 2, e, e), this._nativeShape = new fe._physics3D.btCylinderShapeX(ve._nativeSize);
                    break;

                case Te.SHAPEORIENTATION_UPY:
                    ve._nativeSize.setValue(e, t / 2, e), this._nativeShape = new fe._physics3D.btCylinderShape(ve._nativeSize);
                    break;

                case Te.SHAPEORIENTATION_UPZ:
                    ve._nativeSize.setValue(e, e, t / 2), this._nativeShape = new fe._physics3D.btCylinderShapeZ(ve._nativeSize);
                    break;

                default:
                    throw "CapsuleColliderShape:unknown orientation.";
            }
        }
        static __init__() {
            ve._nativeSize = new fe._physics3D.btVector3(0, 0, 0);
        }
        get radius() {
            return this._radius;
        }
        get height() {
            return this._height;
        }
        get orientation() {
            return this._orientation;
        }
        clone() {
            var e = new ve(this._radius, this._height, this._orientation);
            return this.cloneTo(e), e;
        }
    }
    class Re extends Te {
        constructor() {
            super(), this._mesh = null, this._convex = !1;
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            if (this._mesh !== e) {
                var t = fe._physics3D;
                this._mesh && t.destroy(this._nativeShape), e && (this._nativeShape = new fe._physics3D.btGImpactMeshShape(e._getPhysicMesh()),
                    this._nativeShape.updateBound()), this._mesh = e;
            }
        }
        get convex() {
            return this._convex;
        }
        set convex(e) {
            this._convex = e;
        }
        _setScale(e) {
            this._compoundParent ? this.updateLocalTransformations() : (Te._nativeScale.setValue(e.x, e.y, e.z),
                this._nativeShape.setLocalScaling(Te._nativeScale), this._nativeShape.updateBound());
        }
        cloneTo(e) {
            var t = e;
            t.convex = this._convex, t.mesh = this._mesh, super.cloneTo(e);
        }
        clone() {
            var e = new Re();
            return this.cloneTo(e), e;
        }
        destroy() {
            this._nativeShape && (fe._physics3D.destroy(this._nativeShape), this._nativeShape = null);
        }
    }
    class Ae extends Te {
        get radius() {
            return this._radius;
        }
        constructor(e = .5) {
            super(), this._radius = e, this._type = Te.SHAPETYPES_SPHERE, this._nativeShape = new fe._physics3D.btSphereShape(e);
        }
        clone() {
            var e = new Ae(this._radius);
            return this.cloneTo(e), e;
        }
    }
    class De extends t.Component {
        constructor(e, t) {
            super(), this._restitution = 0, this._friction = .5, this._rollingFriction = 0,
                this._ccdMotionThreshold = 0, this._ccdSweptSphereRadius = 0, this._collisionGroup = Ee.COLLISIONFILTERGROUP_DEFAULTFILTER,
                this._canCollideWith = Ee.COLLISIONFILTERGROUP_ALLFILTER, this._colliderShape = null,
                this._transformFlag = 2147483647, this._enableProcessCollisions = !0, this._inPhysicUpdateListIndex = -1,
                this.canScaleShape = !0, this._collisionGroup = e, this._canCollideWith = t, De._physicObjectsMap[this.id] = this;
        }
        static __init__() {
            De._nativeVector30 = new fe._physics3D.btVector3(0, 0, 0), De._nativeQuaternion0 = new fe._physics3D.btQuaternion(0, 0, 0, 1);
        }
        static _createAffineTransformationArray(e, t, r, i, n, a, s, o, l) {
            var _ = i + i,
                h = n + n,
                c = a + a,
                d = i * _,
                u = i * h,
                f = i * c,
                E = n * h,
                T = n * c,
                m = a * c,
                p = s * _,
                g = s * h,
                S = s * c,
                v = o[0],
                R = o[1],
                A = o[2];
            l[0] = (1 - (E + m)) * v, l[1] = (u + S) * v, l[2] = (f - g) * v, l[3] = 0, l[4] = (u - S) * R,
                l[5] = (1 - (d + m)) * R, l[6] = (T + p) * R, l[7] = 0, l[8] = (f + g) * A, l[9] = (T - p) * A,
                l[10] = (1 - (d + E)) * A, l[11] = 0, l[12] = e, l[13] = t, l[14] = r, l[15] = 1;
        }
        static _creatShape(e) {
            var r;
            switch (e.type) {
                case "BoxColliderShape":
                    var i = e.size;
                    r = i ? new me(i[0], i[1], i[2]) : new me();
                    break;

                case "SphereColliderShape":
                    r = new Ae(e.radius);
                    break;

                case "CapsuleColliderShape":
                    r = new pe(e.radius, e.height, e.orientation);
                    break;

                case "MeshColliderShape":
                    var n = new Re();
                    e.mesh && (n.mesh = t.Loader.getRes(e.mesh)), r = n;
                    break;

                case "ConeColliderShape":
                    r = new Se(e.radius, e.height, e.orientation);
                    break;

                case "CylinderColliderShape":
                    r = new ve(e.radius, e.height, e.orientation);
                    break;

                default:
                    throw "unknown shape type.";
            }
            if (e.center) {
                var a = r.localOffset;
                a.fromArray(e.center), r.localOffset = a;
            }
            return r;
        }
        static physicVector3TransformQuat(e, t, r, i, n, a) {
            var s = e.x,
                o = e.y,
                l = e.z,
                _ = n * s + r * l - i * o,
                h = n * o + i * s - t * l,
                c = n * l + t * o - r * s,
                d = -t * s - r * o - i * l;
            a.x = _ * n + d * -t + h * -i - c * -r, a.y = h * n + d * -r + c * -t - _ * -i,
                a.z = c * n + d * -i + _ * -r - h * -t;
        }
        static physicQuaternionMultiply(e, t, r, i, n, a) {
            var s = n.x,
                o = n.y,
                l = n.z,
                _ = n.w,
                h = t * l - r * o,
                c = r * s - e * l,
                d = e * o - t * s,
                u = e * s + t * o + r * l;
            a.x = e * _ + s * i + h, a.y = t * _ + o * i + c, a.z = r * _ + l * i + d, a.w = i * _ - u;
        }
        get restitution() {
            return this._restitution;
        }
        set restitution(e) {
            this._restitution = e, this._nativeColliderObject && this._nativeColliderObject.setRestitution(e);
        }
        get friction() {
            return this._friction;
        }
        set friction(e) {
            this._friction = e, this._nativeColliderObject && this._nativeColliderObject.setFriction(e);
        }
        get rollingFriction() {
            return this._nativeColliderObject.getRollingFriction();
        }
        set rollingFriction(e) {
            this._rollingFriction = e, this._nativeColliderObject && this._nativeColliderObject.setRollingFriction(e);
        }
        get ccdMotionThreshold() {
            return this._ccdMotionThreshold;
        }
        set ccdMotionThreshold(e) {
            this._ccdMotionThreshold = e, this._nativeColliderObject && this._nativeColliderObject.setCcdMotionThreshold(e);
        }
        get ccdSweptSphereRadius() {
            return this._ccdSweptSphereRadius;
        }
        set ccdSweptSphereRadius(e) {
            this._ccdSweptSphereRadius = e, this._nativeColliderObject && this._nativeColliderObject.setCcdSweptSphereRadius(e);
        }
        get isActive() {
            return !!this._nativeColliderObject && this._nativeColliderObject.isActive();
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(e) {
            this._enabled != e && (this._simulation && this._colliderShape && (e ? (this._derivePhysicsTransformation(!0),
                this._addToSimulation()) : this._removeFromSimulation()), super.enabled = e);
        }
        get colliderShape() {
            return this._colliderShape;
        }
        set colliderShape(e) {
            var t = this._colliderShape;
            if (t && (t._attatched = !1, t._attatchedCollisionObject = null), this._colliderShape = e,
                e) {
                if (e._attatched) throw "PhysicsComponent: this shape has attatched to other entity.";
                if (e._attatched = !0, e._attatchedCollisionObject = this, this._nativeColliderObject) {
                    this._nativeColliderObject.setCollisionShape(e._nativeShape);
                    var r = this._simulation && this._enabled;
                    r && t && this._removeFromSimulation(), this._onShapeChange(e), r && (this._derivePhysicsTransformation(!0),
                        this._addToSimulation());
                }
            } else this._simulation && this._enabled && t && this._removeFromSimulation();
        }
        get simulation() {
            return this._simulation;
        }
        get collisionGroup() {
            return this._collisionGroup;
        }
        set collisionGroup(e) {
            this._collisionGroup !== e && (this._collisionGroup = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                this._addToSimulation()));
        }
        get canCollideWith() {
            return this._canCollideWith;
        }
        set canCollideWith(e) {
            this._canCollideWith !== e && (this._canCollideWith = e, this._simulation && this._colliderShape && this._enabled && (this._removeFromSimulation(),
                this._addToSimulation()));
        }
        _isValid() {
            return this._simulation && this._colliderShape && this._enabled;
        }
        _parse(e) {
            null != e.collisionGroup && (this.collisionGroup = e.collisionGroup), null != e.canCollideWith && (this.canCollideWith = e.canCollideWith),
                null != e.ccdMotionThreshold && (this.ccdMotionThreshold = e.ccdMotionThreshold),
                null != e.ccdSweptSphereRadius && (this.ccdSweptSphereRadius = e.ccdSweptSphereRadius);
        }
        _parseShape(e) {
            var t = e.length;
            if (1 === t) {
                var r = De._creatShape(e[0]);
                this.colliderShape = r;
            } else {
                for (var i = new ge(), n = 0; n < t; n++) r = De._creatShape(e[n]), i.addChildShape(r);
                this.colliderShape = i;
            }
        }
        _onScaleChange(e) {
            this._colliderShape._setScale(e);
        }
        _setTransformFlag(e, t) {
            t ? this._transformFlag |= e : this._transformFlag &= ~e;
        }
        _getTransformFlag(e) {
            return 0 != (this._transformFlag & e);
        }
        _addToSimulation() {}
        _removeFromSimulation() {}
        _derivePhysicsTransformation(e) {
            this._innerDerivePhysicsTransformation(this._nativeColliderObject.getWorldTransform(), e);
        }
        _innerDerivePhysicsTransformation(e, t) {
            var r = this.owner._transform,
                i = r.rotation;
            if (t || this._getTransformFlag(w.TRANSFORM_WORLDPOSITION)) {
                var n = this._colliderShape.localOffset,
                    s = r.position,
                    o = De._nativeVector30;
                if (0 !== n.x || 0 !== n.y || 0 !== n.z) {
                    var l = De._tempVector30;
                    De.physicVector3TransformQuat(n, i.x, i.y, i.z, i.w, l), a.add(s, l, l), o.setValue(-l.x, l.y, l.z);
                } else o.setValue(-s.x, s.y, s.z);
                e.setOrigin(o), this._setTransformFlag(w.TRANSFORM_WORLDPOSITION, !1);
            }
            if (t || this._getTransformFlag(w.TRANSFORM_WORLDQUATERNION)) {
                var _ = this._colliderShape.localRotation,
                    h = De._nativeQuaternion0;
                if (0 !== _.x || 0 !== _.y || 0 !== _.z || 1 !== _.w) {
                    var c = De._tempQuaternion0;
                    De.physicQuaternionMultiply(i.x, i.y, i.z, i.w, _, c), h.setValue(-c.x, c.y, c.z, -c.w);
                } else h.setValue(-i.x, i.y, i.z, -i.w);
                e.setRotation(h), this._setTransformFlag(w.TRANSFORM_WORLDQUATERNION, !1);
            }
            (t || this._getTransformFlag(w.TRANSFORM_WORLDSCALE)) && (this._onScaleChange(r.getWorldLossyScale()),
                this._setTransformFlag(w.TRANSFORM_WORLDSCALE, !1));
        }
        _updateTransformComponent(e) {
            var t = this._colliderShape.localOffset,
                r = this._colliderShape.localRotation,
                i = this.owner._transform,
                n = i.position,
                a = i.rotation,
                s = e.getOrigin(),
                o = e.getRotation(),
                l = -o.x(),
                _ = o.y(),
                h = o.z(),
                c = -o.w();
            if (0 !== t.x || 0 !== t.y || 0 !== t.z) {
                var d = De._tempVector30;
                De.physicVector3TransformQuat(t, l, _, h, c, d), n.x = -s.x() - d.x, n.y = s.y() - d.y,
                    n.z = s.z() - d.z;
            } else n.x = -s.x(), n.y = s.y(), n.z = s.z();
            if (i.position = n, 0 !== r.x || 0 !== r.y || 0 !== r.z || 1 !== r.w) {
                var u = De._tempQuaternion0;
                r.invert(u), De.physicQuaternionMultiply(l, _, h, c, u, a);
            } else a.x = l, a.y = _, a.z = h, a.w = c;
            i.rotation = a;
        }
        _onEnable() {
            this._simulation = this.owner._scene.physicsSimulation, this._nativeColliderObject.setContactProcessingThreshold(1e30),
                this._colliderShape && this._enabled && (this._derivePhysicsTransformation(!0),
                    this._addToSimulation());
        }
        _onDisable() {
            this._colliderShape && this._enabled && (this._removeFromSimulation(), -1 !== this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.remove(this)),
                this._simulation = null;
        }
        _onShapeChange(e) {
            var t = this._nativeColliderObject,
                r = t.getCollisionFlags();
            e.needsCustomCollisionCallback ? 0 == (r & De.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) && t.setCollisionFlags(r | De.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) : (r & De.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK) > 0 && t.setCollisionFlags(r ^ De.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK);
        }
        _onAdded() {
            this.enabled = this._enabled, this.restitution = this._restitution, this.friction = this._friction,
                this.rollingFriction = this._rollingFriction, this.ccdMotionThreshold = this._ccdMotionThreshold,
                this.ccdSweptSphereRadius = this._ccdSweptSphereRadius, this.owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        _onDestroy() {
            var e = fe._physics3D;
            delete De._physicObjectsMap[this.id], e.destroy(this._nativeColliderObject), this._colliderShape.destroy(),
                super._onDestroy(), this._nativeColliderObject = null, this._colliderShape = null,
                this._simulation = null, this.owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
        }
        _onTransformChanged(e) {
            De._addUpdateList && (e &= w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
        }
        _cloneTo(e) {
            var t = e;
            t.restitution = this._restitution, t.friction = this._friction, t.rollingFriction = this._rollingFriction,
                t.ccdMotionThreshold = this._ccdMotionThreshold, t.ccdSweptSphereRadius = this._ccdSweptSphereRadius,
                t.collisionGroup = this._collisionGroup, t.canCollideWith = this._canCollideWith,
                t.canScaleShape = this.canScaleShape, this._colliderShape && (t.colliderShape = this._colliderShape.clone());
        }
    }
    De.ACTIVATIONSTATE_ACTIVE_TAG = 1, De.ACTIVATIONSTATE_ISLAND_SLEEPING = 2, De.ACTIVATIONSTATE_WANTS_DEACTIVATION = 3,
        De.ACTIVATIONSTATE_DISABLE_DEACTIVATION = 4, De.ACTIVATIONSTATE_DISABLE_SIMULATION = 5,
        De.COLLISIONFLAGS_STATIC_OBJECT = 1, De.COLLISIONFLAGS_KINEMATIC_OBJECT = 2, De.COLLISIONFLAGS_NO_CONTACT_RESPONSE = 4,
        De.COLLISIONFLAGS_CUSTOM_MATERIAL_CALLBACK = 8, De.COLLISIONFLAGS_CHARACTER_OBJECT = 16,
        De.COLLISIONFLAGS_DISABLE_VISUALIZE_OBJECT = 32, De.COLLISIONFLAGS_DISABLE_SPU_COLLISION_PROCESSING = 64,
        De._tempVector30 = new a(), De._tempQuaternion0 = new E(), De._tempQuaternion1 = new E(),
        De._tempMatrix4x40 = new T(), De._physicObjectsMap = {}, De._addUpdateList = !0;
    class Ie extends he {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._inPhysicUpdateListIndex) throw "PhysicsUpdateList:element has  in  PhysicsUpdateList.";
            this._add(e), e._inPhysicUpdateListIndex = this.length++;
        }
        remove(e) {
            var t = e._inPhysicUpdateListIndex;
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._inPhysicUpdateListIndex = t;
            }
            e._inPhysicUpdateListIndex = -1;
        }
    }
    class xe {
        constructor() {
            this._idCounter = 0, this.colliderA = null, this.colliderB = null, this.distance = 0,
                this.normal = new a(), this.positionOnA = new a(), this.positionOnB = new a(), this._id = ++this._idCounter;
        }
    }
    class Me {
        constructor() {
            this.succeeded = !1, this.collider = null, this.point = new a(), this.normal = new a(),
                this.hitFraction = 0;
        }
    }
    class Le {
        constructor() {
            this._lastUpdateFrame = -2147483648, this._updateFrame = -2147483648, this._isTrigger = !1,
                this.contacts = [];
        }
        _setUpdateFrame(e) {
            this._lastUpdateFrame = this._updateFrame, this._updateFrame = e;
        }
    }
    class Ce {
        constructor() {
            this._hitResultsPoolIndex = 0, this._hitResultsPool = [], this._contactPonintsPoolIndex = 0,
                this._contactPointsPool = [], this._collisionsPool = [], this._collisions = {};
        }
        getHitResult() {
            var e = this._hitResultsPool[this._hitResultsPoolIndex++];
            return e || (e = new Me(), this._hitResultsPool.push(e)), e;
        }
        recoverAllHitResultsPool() {
            this._hitResultsPoolIndex = 0;
        }
        getContactPoints() {
            var e = this._contactPointsPool[this._contactPonintsPoolIndex++];
            return e || (e = new xe(), this._contactPointsPool.push(e)), e;
        }
        recoverAllContactPointsPool() {
            this._contactPonintsPoolIndex = 0;
        }
        getCollision(e, t) {
            var r, i = e.id,
                n = t.id,
                a = this._collisions[i];
            return a && (r = a[n]), r || (a || (a = {}, this._collisions[i] = a), (r = 0 === this._collisionsPool.length ? new Le() : this._collisionsPool.pop())._colliderA = e,
                r._colliderB = t, a[n] = r), r;
        }
        recoverCollision(e) {
            var t = e._colliderA.id,
                r = e._colliderB.id;
            this._collisions[t][r] = null, this._collisionsPool.push(e);
        }
        garbageCollection() {
            for (var e in this._hitResultsPoolIndex = 0, this._hitResultsPool.length = 0, this._contactPonintsPoolIndex = 0,
                    this._contactPointsPool.length = 0, this._collisionsPool.length = 0, this._collisionsPool) {
                var t = this._collisionsPool[e],
                    r = !0;
                for (var i in t) t[i] ? r = !1 : delete t[i];
                r && delete this._collisionsPool[e];
            }
        }
    }
    class ye {
        constructor(e, t = 0) {
            this._gravity = new a(0, -10, 0), this._nativeVector3Zero = new fe._physics3D.btVector3(0, 0, 0),
                this._nativeDefaultQuaternion = new fe._physics3D.btQuaternion(0, 0, 0, -1), this._collisionsUtils = new Ce(),
                this._previousFrameCollisions = [], this._currentFrameCollisions = [], this._physicsUpdateList = new Ie(),
                this._characters = [], this._updatedRigidbodies = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60,
                this.maxSubSteps = e.maxSubSteps, this.fixedTimeStep = e.fixedTimeStep;
            var r = fe._physics3D;
            this._nativeCollisionConfiguration = new r.btDefaultCollisionConfiguration(), this._nativeDispatcher = new r.btCollisionDispatcher(this._nativeCollisionConfiguration),
                this._nativeBroadphase = new r.btDbvtBroadphase(), this._nativeBroadphase.getOverlappingPairCache().setInternalGhostPairCallback(new r.btGhostPairCallback());
            var i = e.flags;
            if (i & ye.PHYSICSENGINEFLAGS_COLLISIONSONLY) this._nativeCollisionWorld = new r.btCollisionWorld(this._nativeDispatcher, this._nativeBroadphase, this._nativeCollisionConfiguration);
            else {
                if (i & ye.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT) throw "PhysicsSimulation:SoftBody processing is not yet available";
                var n = new r.btSequentialImpulseConstraintSolver();
                this._nativeDiscreteDynamicsWorld = new r.btDiscreteDynamicsWorld(this._nativeDispatcher, this._nativeBroadphase, n, this._nativeCollisionConfiguration),
                    this._nativeCollisionWorld = this._nativeDiscreteDynamicsWorld;
            }
            this._nativeDiscreteDynamicsWorld && (this._nativeSolverInfo = this._nativeDiscreteDynamicsWorld.getSolverInfo(),
                    this._nativeDispatchInfo = this._nativeDiscreteDynamicsWorld.getDispatchInfo()),
                this._nativeClosestRayResultCallback = new r.ClosestRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                this._nativeAllHitsRayResultCallback = new r.AllHitsRayResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                this._nativeClosestConvexResultCallback = new r.ClosestConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                this._nativeAllConvexResultCallback = new r.AllConvexResultCallback(this._nativeVector3Zero, this._nativeVector3Zero),
                r._btGImpactCollisionAlgorithm_RegisterAlgorithm(this._nativeDispatcher.a);
        }
        static __init__() {
            ye._nativeTempVector30 = new fe._physics3D.btVector3(0, 0, 0), ye._nativeTempVector31 = new fe._physics3D.btVector3(0, 0, 0),
                ye._nativeTempQuaternion0 = new fe._physics3D.btQuaternion(0, 0, 0, 1), ye._nativeTempQuaternion1 = new fe._physics3D.btQuaternion(0, 0, 0, 1),
                ye._nativeTempTransform0 = new fe._physics3D.btTransform(), ye._nativeTempTransform1 = new fe._physics3D.btTransform();
        }
        static createConstraint() {}
        get continuousCollisionDetection() {
            return this._nativeDispatchInfo.get_m_useContinuous();
        }
        set continuousCollisionDetection(e) {
            this._nativeDispatchInfo.set_m_useContinuous(e);
        }
        get gravity() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._gravity;
        }
        set gravity(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._gravity = e;
            var t = ye._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeDiscreteDynamicsWorld.setGravity(t);
        }
        get speculativeContactRestitution() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            return this._nativeDiscreteDynamicsWorld.getApplySpeculativeContactRestitution();
        }
        set speculativeContactRestitution(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.setApplySpeculativeContactRestitution(e);
        }
        _simulate(e) {
            this._updatedRigidbodies = 0, this._nativeDiscreteDynamicsWorld ? this._nativeDiscreteDynamicsWorld.stepSimulation(e, this.maxSubSteps, this.fixedTimeStep) : this._nativeCollisionWorld.PerformDiscreteCollisionDetection();
        }
        _destroy() {
            var e = fe._physics3D;
            this._nativeDiscreteDynamicsWorld ? (e.destroy(this._nativeDiscreteDynamicsWorld),
                    this._nativeDiscreteDynamicsWorld = null) : (e.destroy(this._nativeCollisionWorld),
                    this._nativeCollisionWorld = null), e.destroy(this._nativeBroadphase), this._nativeBroadphase = null,
                e.destroy(this._nativeDispatcher), this._nativeDispatcher = null, e.destroy(this._nativeCollisionConfiguration),
                this._nativeCollisionConfiguration = null;
        }
        _addPhysicsCollider(e, t, r) {
            this._nativeCollisionWorld.addCollisionObject(e._nativeColliderObject, t, r);
        }
        _removePhysicsCollider(e) {
            this._nativeCollisionWorld.removeCollisionObject(e._nativeColliderObject);
        }
        _addRigidBody(e, t, r) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.addRigidBody(e._nativeColliderObject, t, r);
        }
        _removeRigidBody(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.removeRigidBody(e._nativeColliderObject);
        }
        _addCharacter(e, t, r) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.addCollisionObject(e._nativeColliderObject, t, r), this._nativeCollisionWorld.addAction(e._nativeKinematicCharacter);
        }
        _removeCharacter(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Simulation:Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeCollisionWorld.removeCollisionObject(e._nativeColliderObject), this._nativeCollisionWorld.removeAction(e._nativeKinematicCharacter);
        }
        raycastFromTo(e, t, r = null, i = Ee.COLLISIONFILTERGROUP_ALLFILTER, n = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            var a = this._nativeClosestRayResultCallback,
                s = ye._nativeTempVector30,
                o = ye._nativeTempVector31;
            if (s.setValue(-e.x, e.y, e.z), o.setValue(-t.x, t.y, t.z), a.set_m_rayFromWorld(s),
                a.set_m_rayToWorld(o), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(n),
                a.set_m_collisionObject(null), a.set_m_closestHitFraction(1), this._nativeCollisionWorld.rayTest(s, o, a),
                a.hasHit()) {
                if (r) {
                    r.succeeded = !0, r.collider = De._physicObjectsMap[a.get_m_collisionObject().getUserIndex()],
                        r.hitFraction = a.get_m_closestHitFraction();
                    var l = a.get_m_hitPointWorld(),
                        _ = r.point;
                    _.x = -l.x(), _.y = l.y(), _.z = l.z();
                    var h = a.get_m_hitNormalWorld(),
                        c = r.normal;
                    c.x = -h.x(), c.y = h.y(), c.z = h.z();
                }
                return !0;
            }
            return r && (r.succeeded = !1), !1;
        }
        raycastAllFromTo(e, t, r, i = Ee.COLLISIONFILTERGROUP_ALLFILTER, n = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            var a = this._nativeAllHitsRayResultCallback,
                s = ye._nativeTempVector30,
                o = ye._nativeTempVector31;
            r.length = 0, s.setValue(-e.x, e.y, e.z), o.setValue(-t.x, t.y, t.z), a.set_m_rayFromWorld(s),
                a.set_m_rayToWorld(o), a.set_m_collisionFilterGroup(i), a.set_m_collisionFilterMask(n);
            var l = a.get_m_collisionObjects(),
                _ = a.get_m_hitPointWorld(),
                h = a.get_m_hitNormalWorld(),
                c = a.get_m_hitFractions();
            l.clear(), _.clear(), h.clear(), c.clear(), this._nativeCollisionWorld.rayTest(s, o, a);
            var d = l.size();
            if (d > 0) {
                this._collisionsUtils.recoverAllHitResultsPool();
                for (var u = 0; u < d; u++) {
                    var f = this._collisionsUtils.getHitResult();
                    r.push(f), f.succeeded = !0, f.collider = De._physicObjectsMap[l.at(u).getUserIndex()],
                        f.hitFraction = c.at(u);
                    var E = _.at(u),
                        T = f.point;
                    T.x = -E.x(), T.y = E.y(), T.z = E.z();
                    var m = h.at(u),
                        p = f.normal;
                    p.x = -m.x(), p.y = m.y(), p.z = m.z();
                }
                return !0;
            }
            return !1;
        }
        rayCast(e, t = null, r = 2147483647, i = Ee.COLLISIONFILTERGROUP_ALLFILTER, n = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            var s = e.origin,
                o = ye._tempVector30;
            return a.normalize(e.direction, o), a.scale(o, r, o), a.add(s, o, o), this.raycastFromTo(s, o, t, i, n);
        }
        rayCastAll(e, t, r = 2147483647, i = Ee.COLLISIONFILTERGROUP_ALLFILTER, n = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            var s = e.origin,
                o = ye._tempVector30;
            return a.normalize(e.direction, o), a.scale(o, r, o), a.add(s, o, o), this.raycastAllFromTo(s, o, t, i, n);
        }
        shapeCast(e, t, r, i = null, n = null, a = null, s = Ee.COLLISIONFILTERGROUP_ALLFILTER, o = Ee.COLLISIONFILTERGROUP_ALLFILTER, l = 0) {
            var _ = this._nativeClosestConvexResultCallback,
                h = ye._nativeTempVector30,
                c = ye._nativeTempVector31,
                d = ye._nativeTempQuaternion0,
                u = ye._nativeTempQuaternion1,
                f = ye._nativeTempTransform0,
                E = ye._nativeTempTransform1,
                T = e._nativeShape;
            if (h.setValue(-t.x, t.y, t.z), c.setValue(-r.x, r.y, r.z), _.set_m_collisionFilterGroup(s),
                _.set_m_collisionFilterMask(o), f.setOrigin(h), E.setOrigin(c), n ? (d.setValue(-n.x, n.y, n.z, -n.w),
                    f.setRotation(d)) : f.setRotation(this._nativeDefaultQuaternion), a ? (u.setValue(-a.x, a.y, a.z, -a.w),
                    E.setRotation(u)) : E.setRotation(this._nativeDefaultQuaternion), _.set_m_hitCollisionObject(null),
                _.set_m_closestHitFraction(1), this._nativeCollisionWorld.convexSweepTest(T, f, E, _, l),
                _.hasHit()) {
                if (i) {
                    i.succeeded = !0, i.collider = De._physicObjectsMap[_.get_m_hitCollisionObject().getUserIndex()],
                        i.hitFraction = _.get_m_closestHitFraction();
                    var m = _.get_m_hitPointWorld(),
                        p = _.get_m_hitNormalWorld(),
                        g = i.point,
                        S = i.normal;
                    g.x = -m.x(), g.y = m.y(), g.z = m.z(), S.x = -p.x(), S.y = p.y(), S.z = p.z();
                }
                return !0;
            }
            return i && (i.succeeded = !1), !1;
        }
        shapeCastAll(e, t, r, i, n = null, a = null, s = Ee.COLLISIONFILTERGROUP_ALLFILTER, o = Ee.COLLISIONFILTERGROUP_ALLFILTER, l = 0) {
            var _ = this._nativeAllConvexResultCallback,
                h = ye._nativeTempVector30,
                c = ye._nativeTempVector31,
                d = ye._nativeTempQuaternion0,
                u = ye._nativeTempQuaternion1,
                f = ye._nativeTempTransform0,
                E = ye._nativeTempTransform1,
                T = e._nativeShape;
            i.length = 0, h.setValue(-t.x, t.y, t.z), c.setValue(-r.x, r.y, r.z), _.set_m_collisionFilterGroup(s),
                _.set_m_collisionFilterMask(o), f.setOrigin(h), E.setOrigin(c), n ? (d.setValue(-n.x, n.y, n.z, -n.w),
                    f.setRotation(d)) : f.setRotation(this._nativeDefaultQuaternion), a ? (u.setValue(-a.x, a.y, a.z, -a.w),
                    E.setRotation(u)) : E.setRotation(this._nativeDefaultQuaternion);
            var m = _.get_m_collisionObjects();
            m.clear(), this._nativeCollisionWorld.convexSweepTest(T, f, E, _, l);
            var p = m.size();
            if (p > 0) {
                for (var g = _.get_m_hitPointWorld(), S = _.get_m_hitNormalWorld(), v = _.get_m_hitFractions(), R = 0; R < p; R++) {
                    var A = this._collisionsUtils.getHitResult();
                    i.push(A), A.succeeded = !0, A.collider = De._physicObjectsMap[m.at(R).getUserIndex()],
                        A.hitFraction = v.at(R);
                    var D = g.at(R),
                        I = A.point;
                    I.x = -D.x(), I.y = D.y(), I.z = D.z();
                    var x = S.at(R),
                        M = A.normal;
                    M.x = -x.x(), M.y = x.y(), M.z = x.z();
                }
                return !0;
            }
            return !1;
        }
        addConstraint(e, t = !1) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.addConstraint(e._nativeConstraint, t), e._simulation = this;
        }
        removeConstraint(e) {
            if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.removeConstraint(e._nativeConstraint);
        }
        _updatePhysicsTransformFromRender() {
            for (var e = this._physicsUpdateList.elements, t = 0, r = this._physicsUpdateList.length; t < r; t++) {
                var i = e[t];
                i._derivePhysicsTransformation(!1), i._inPhysicUpdateListIndex = -1;
            }
            this._physicsUpdateList.length = 0;
        }
        _updateCharacters() {
            for (var e = 0, t = this._characters.length; e < t; e++) {
                var r = this._characters[e];
                r._updateTransformComponent(r._nativeColliderObject.getWorldTransform());
            }
        }
        _updateCollisions() {
            this._collisionsUtils.recoverAllContactPointsPool();
            var e = this._currentFrameCollisions;
            this._currentFrameCollisions = this._previousFrameCollisions, this._currentFrameCollisions.length = 0,
                this._previousFrameCollisions = e;
            for (var r = t.Stat.loopCount, i = this._nativeDispatcher.getNumManifolds(), n = 0; n < i; n++) {
                var a, s = this._nativeDispatcher.getManifoldByIndexInternal(n),
                    o = De._physicObjectsMap[s.getBody0().getUserIndex()],
                    l = De._physicObjectsMap[s.getBody1().getUserIndex()],
                    _ = null,
                    h = null;
                if ((o.isTrigger || l.isTrigger) && (o.owner._needProcessTriggers || l.owner._needProcessTriggers))
                    for (var c = s.getNumContacts(), d = 0; d < c; d++) {
                        var u = s.getContactPoint(d),
                            f = u.getDistance();
                        if (f <= 0) {
                            h = (_ = this._collisionsUtils.getCollision(o, l)).contacts, (a = _._updateFrame !== r) && (_._isTrigger = !0,
                                h.length = 0);
                            break;
                        }
                    } else if ((o.owner._needProcessCollisions || l.owner._needProcessCollisions) && (o._enableProcessCollisions || l._enableProcessCollisions))
                        for (c = s.getNumContacts(),
                            d = 0; d < c; d++)
                            if ((f = (u = s.getContactPoint(d)).getDistance()) <= 0) {
                                var E = this._collisionsUtils.getContactPoints();
                                E.colliderA = o, E.colliderB = l, E.distance = f;
                                var T = u.get_m_normalWorldOnB(),
                                    m = E.normal;
                                m.x = -T.x(), m.y = T.y(), m.z = T.z();
                                var p = u.get_m_positionWorldOnA(),
                                    g = E.positionOnA;
                                g.x = -p.x(), g.y = p.y(), g.z = p.z();
                                var S = u.get_m_positionWorldOnB(),
                                    v = E.positionOnB;
                                v.x = -S.x(), v.y = S.y(), v.z = S.z(), _ || (h = (_ = this._collisionsUtils.getCollision(o, l)).contacts,
                                    (a = _._updateFrame !== r) && (_._isTrigger = !1, h.length = 0)), h.push(E);
                            }
                _ && a && (this._currentFrameCollisions.push(_), _._setUpdateFrame(r));
            }
        }
        _eventScripts() {
            for (var e = t.Stat.loopCount, r = 0, i = this._currentFrameCollisions.length; r < i; r++) {
                var n = this._currentFrameCollisions[r],
                    a = n._colliderA,
                    s = n._colliderB;
                if (!a.destroyed && !s.destroyed)
                    if (e - n._lastUpdateFrame == 1) {
                        var o = a.owner,
                            l = o._scripts;
                        if (l)
                            if (n._isTrigger) {
                                if (o._needProcessTriggers)
                                    for (var _ = 0, h = l.length; _ < h; _++) l[_].onTriggerStay(s);
                            } else if (o._needProcessCollisions)
                            for (_ = 0, h = l.length; _ < h; _++) n.other = s,
                                l[_].onCollisionStay(n);
                        var c = s.owner,
                            d = c._scripts;
                        if (d)
                            if (n._isTrigger) {
                                if (c._needProcessTriggers)
                                    for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerStay(a);
                            } else if (c._needProcessCollisions)
                            for (_ = 0, h = d.length; _ < h; _++) n.other = a,
                                d[_].onCollisionStay(n);
                    } else {
                        if (l = (o = a.owner)._scripts)
                            if (n._isTrigger) {
                                if (o._needProcessTriggers)
                                    for (_ = 0, h = l.length; _ < h; _++) l[_].onTriggerEnter(s);
                            } else if (o._needProcessCollisions)
                            for (_ = 0, h = l.length; _ < h; _++) n.other = s,
                                l[_].onCollisionEnter(n);
                        if (d = (c = s.owner)._scripts)
                            if (n._isTrigger) {
                                if (c._needProcessTriggers)
                                    for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerEnter(a);
                            } else if (c._needProcessCollisions)
                            for (_ = 0, h = d.length; _ < h; _++) n.other = a,
                                d[_].onCollisionEnter(n);
                    }
            }
            for (r = 0, i = this._previousFrameCollisions.length; r < i; r++) {
                var u = this._previousFrameCollisions[r],
                    f = u._colliderA,
                    E = u._colliderB;
                if (!f.destroyed && !E.destroyed && e - u._updateFrame == 1) {
                    if (this._collisionsUtils.recoverCollision(u), l = (o = f.owner)._scripts)
                        if (u._isTrigger) {
                            if (o._needProcessTriggers)
                                for (_ = 0, h = l.length; _ < h; _++) l[_].onTriggerExit(E);
                        } else if (o._needProcessCollisions)
                        for (_ = 0, h = l.length; _ < h; _++) u.other = E,
                            l[_].onCollisionExit(u);
                    if (d = (c = E.owner)._scripts)
                        if (u._isTrigger) {
                            if (c._needProcessTriggers)
                                for (_ = 0, h = d.length; _ < h; _++) d[_].onTriggerExit(f);
                        } else if (c._needProcessCollisions)
                        for (_ = 0, h = d.length; _ < h; _++) u.other = f,
                            d[_].onCollisionExit(u);
                }
            }
        }
        clearForces() {
            if (!this._nativeDiscreteDynamicsWorld) throw "Cannot perform this action when the physics engine is set to CollisionsOnly";
            this._nativeDiscreteDynamicsWorld.clearForces();
        }
    }
    ye.PHYSICSENGINEFLAGS_NONE = 0, ye.PHYSICSENGINEFLAGS_COLLISIONSONLY = 1, ye.PHYSICSENGINEFLAGS_SOFTBODYSUPPORT = 2,
        ye.PHYSICSENGINEFLAGS_MULTITHREADED = 4, ye.PHYSICSENGINEFLAGS_USEHARDWAREWHENPOSSIBLE = 8,
        ye.SOLVERMODE_RANDMIZE_ORDER = 1, ye.SOLVERMODE_FRICTION_SEPARATE = 2, ye.SOLVERMODE_USE_WARMSTARTING = 4,
        ye.SOLVERMODE_USE_2_FRICTION_DIRECTIONS = 16, ye.SOLVERMODE_ENABLE_FRICTION_DIRECTION_CACHING = 32,
        ye.SOLVERMODE_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION = 64, ye.SOLVERMODE_CACHE_FRIENDLY = 128,
        ye.SOLVERMODE_SIMD = 256, ye.SOLVERMODE_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS = 512,
        ye.SOLVERMODE_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS = 1024, ye._tempVector30 = new a(),
        ye.disableSimulation = !1;
    class Oe {
        constructor(e, t) {
            this.min = e, this.max = t;
        }
        _rotateExtents(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.elements;
            r.x = Math.abs(s[0] * i) + Math.abs(s[4] * n) + Math.abs(s[8] * a), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * n) + Math.abs(s[9] * a),
                r.z = Math.abs(s[2] * i) + Math.abs(s[6] * n) + Math.abs(s[10] * a);
        }
        getCorners(e) {
            e.length = 8;
            var t = this.min.x,
                r = this.min.y,
                i = this.min.z,
                n = this.max.x,
                s = this.max.y,
                o = this.max.z;
            e[0] = new a(t, s, o), e[1] = new a(n, s, o), e[2] = new a(n, r, o), e[3] = new a(t, r, o),
                e[4] = new a(t, s, i), e[5] = new a(n, s, i), e[6] = new a(n, r, i), e[7] = new a(t, r, i);
        }
        getCenter(e) {
            a.add(this.min, this.max, e), a.scale(e, .5, e);
        }
        getExtent(e) {
            a.subtract(this.max, this.min, e), a.scale(e, .5, e);
        }
        setCenterAndExtent(e, t) {
            a.subtract(e, t, this.min), a.add(e, t, this.max);
        }
        tranform(e, t) {
            var r = Oe._tempVector30,
                i = Oe._tempVector31;
            this.getCenter(r), this.getExtent(i), a.transformCoordinate(r, e, r), this._rotateExtents(i, e, i),
                t.setCenterAndExtent(r, i);
        }
        toDefault() {
            this.min.toDefault(), this.max.toDefault();
        }
        static createfromPoints(e, t) {
            if (null == e) throw new Error("points");
            var r = t.min,
                i = t.max;
            r.x = Number.MAX_VALUE, r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, i.x = -Number.MAX_VALUE,
                i.y = -Number.MAX_VALUE, i.z = -Number.MAX_VALUE;
            for (var n = 0, s = e.length; n < s; ++n) a.min(r, e[n], r), a.max(i, e[n], i);
        }
        static merge(e, t, r) {
            a.min(e.min, t.min, r.min), a.max(e.max, t.max, r.max);
        }
        cloneTo(e) {
            var t = e;
            this.min.cloneTo(t.min), this.max.cloneTo(t.max);
        }
        clone() {
            var e = new Oe(new a(), new a());
            return this.cloneTo(e), e;
        }
    }
    Oe._tempVector30 = new a(), Oe._tempVector31 = new a();
    class Ne {
        constructor(e, t) {
            this.center = e, this.radius = t;
        }
        toDefault() {
            this.center.toDefault(), this.radius = 0;
        }
        static createFromSubPoints(e, t, r, i) {
            if (null == e) throw new Error("points");
            if (t < 0 || t >= e.length) throw new Error("start" + t + "Must be in the range [0, " + (e.length - 1) + "]");
            if (r < 0 || t + r > e.length) throw new Error("count" + r + "Must be in the range <= " + e.length + "}");
            var n = t + r,
                s = Ne._tempVector3;
            s.x = 0, s.y = 0, s.z = 0;
            for (var o = t; o < n; ++o) a.add(e[o], s, s);
            var l = i.center;
            a.scale(s, 1 / r, l);
            var _ = 0;
            for (o = t; o < n; ++o) {
                var h = a.distanceSquared(l, e[o]);
                h > _ && (_ = h);
            }
            i.radius = Math.sqrt(_);
        }
        static createfromPoints(e, t) {
            if (null == e) throw new Error("points");
            Ne.createFromSubPoints(e, 0, e.length, t);
        }
        intersectsRayDistance(e) {
            return W.intersectsRayAndSphereRD(e, this);
        }
        intersectsRayPoint(e, t) {
            return W.intersectsRayAndSphereRP(e, this, t);
        }
        cloneTo(e) {
            var t = e;
            this.center.cloneTo(t.center), t.radius = this.radius;
        }
        clone() {
            var e = new Ne(new a(), 0);
            return this.cloneTo(e), e;
        }
    }
    Ne._tempVector3 = new a();
    class Pe {
        constructor() {
            var e;
            for (this._spiltDistance = [], this._currentPSSM = -1, this._shadowMapCount = 3,
                this._maxDistance = 200, this._ratioOfDistance = 1 / this._shadowMapCount, this._globalParallelLightDir = new a(0, -1, 0),
                this._statesDirty = !0, this._shadowMapTextureSize = 1024, this._scene = null, this._boundingSphere = new Array(Pe.MAX_PSSM_COUNT + 1),
                this._boundingBox = new Array(Pe.MAX_PSSM_COUNT + 1), this._frustumPos = new Array(4 * (Pe.MAX_PSSM_COUNT + 1)),
                this._uniformDistance = new Array(Pe.MAX_PSSM_COUNT + 1), this._logDistance = new Array(Pe.MAX_PSSM_COUNT + 1),
                this._dimension = new Array(Pe.MAX_PSSM_COUNT + 1), this._PCFType = 0, this._tempLookAt3 = new a(),
                this._tempLookAt4 = new n(), this._tempValue = new n(), this._tempPos = new a(),
                this._tempLightUp = new a(), this._tempMin = new n(), this._tempMax = new n(), this._tempMatrix44 = new T(),
                this._splitFrustumCulling = new k(T.DEFAULT), this._tempScaleMatrix44 = new T(),
                this._shadowPCFOffset = new i(1 / 1024, 1 / 1024), this._shaderValueDistance = new n(),
                this._shaderValueLightVP = null, this.cameras = [], this._shaderValueVPs = [], e = 0; e < this._spiltDistance.length; e++) this._spiltDistance[e] = 0;
            for (e = 0; e < this._dimension.length; e++) this._dimension[e] = new i();
            for (e = 0; e < this._frustumPos.length; e++) this._frustumPos[e] = new a();
            for (e = 0; e < this._boundingBox.length; e++) this._boundingBox[e] = new Oe(new a(), new a());
            for (e = 0; e < this._boundingSphere.length; e++) this._boundingSphere[e] = new Ne(new a(), 0);
            T.createScaling(new a(.5, .5, 1), this._tempScaleMatrix44), this._tempScaleMatrix44.elements[12] = .5,
                this._tempScaleMatrix44.elements[13] = .5;
        }
        setInfo(e, t, r, i, n, a) {
            n > Pe.MAX_PSSM_COUNT && (this._shadowMapCount = Pe.MAX_PSSM_COUNT), this._scene = e,
                this._maxDistance = t, this.shadowMapCount = n, this._globalParallelLightDir = r,
                this._ratioOfDistance = 1 / this._shadowMapCount;
            for (var s = 0; s < this._spiltDistance.length; s++) this._spiltDistance[s] = 0;
            this._shadowMapTextureSize = i, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this.setPCFType(a), this._statesDirty = !0;
        }
        setPCFType(e) {
            this._PCFType = e;
            var t = this._scene._shaderValues;
            switch (this._PCFType) {
                case 0:
                    t.addDefine(se.SHADERDEFINE_SHADOW_PCF_NO), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF1),
                        t.removeDefine(se.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF3);
                    break;

                case 1:
                    t.addDefine(se.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF_NO),
                        t.removeDefine(se.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF3);
                    break;

                case 2:
                    t.addDefine(se.SHADERDEFINE_SHADOW_PCF2), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF_NO),
                        t.removeDefine(se.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF3);
                    break;

                case 3:
                    t.addDefine(se.SHADERDEFINE_SHADOW_PCF3), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF_NO),
                        t.removeDefine(se.SHADERDEFINE_SHADOW_PCF1), t.removeDefine(se.SHADERDEFINE_SHADOW_PCF2);
            }
        }
        getPCFType() {
            return this._PCFType;
        }
        setFarDistance(e) {
            this._maxDistance != e && (this._maxDistance = e, this._statesDirty = !0);
        }
        getFarDistance() {
            return this._maxDistance;
        }
        set shadowMapCount(e) {
            if (e = (e = e > 0 ? e : 1) <= Pe.MAX_PSSM_COUNT ? e : Pe.MAX_PSSM_COUNT, this._shadowMapCount != e) {
                this._shadowMapCount = e, this._ratioOfDistance = 1 / this._shadowMapCount, this._statesDirty = !0,
                    this._shaderValueLightVP = new Float32Array(16 * e), this._shaderValueVPs.length = e;
                for (var t = 0; t < e; t++) this._shaderValueVPs[t] = new Float32Array(this._shaderValueLightVP.buffer, 64 * t);
            }
        }
        get shadowMapCount() {
            return this._shadowMapCount;
        }
        _beginSampler(e, t) {
            if (e < 0 || e > this._shadowMapCount) throw new Error("ParallelSplitShadowMap: beginSample invalid index");
            this._currentPSSM = e, this._update(t);
        }
        endSampler(e) {
            this._currentPSSM = -1;
        }
        _calcAllLightCameraInfo(e) {
            if (1 === this._shadowMapCount) this._beginSampler(0, e), this.endSampler(e);
            else
                for (var t = 0, r = this._shadowMapCount + 1; t < r; t++) this._beginSampler(t, e),
                    this.endSampler(e);
        }
        _recalculate(e, t, r) {
            this._calcSplitDistance(e), this._calcBoundingBox(t, r), this._rebuildRenderInfo();
        }
        _update(e) {
            var t = e.nearPlane,
                r = e.fieldOfView,
                i = e.aspectRatio;
            (this._statesDirty || this.lastNearPlane !== t || this.lastFieldOfView !== r || this.lastAspectRatio !== i) && (this._recalculate(t, r, i),
                this._uploadShaderValue(), this._statesDirty = !1, this.lastNearPlane = t, this.lastFieldOfView = r,
                this.lastAspectRatio = i), this._calcLightViewProject(e);
        }
        _uploadShaderValue() {
            var e = this._scene._shaderValues;
            switch (this._shadowMapCount) {
                case 1:
                    e.addDefine(se.SHADERDEFINE_SHADOW_PSSM1), e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM2),
                        e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM3);
                    break;

                case 2:
                    e.addDefine(se.SHADERDEFINE_SHADOW_PSSM2), e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM1),
                        e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM3);
                    break;

                case 3:
                    e.addDefine(se.SHADERDEFINE_SHADOW_PSSM3), e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM1),
                        e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM2);
            }
            switch (e.setVector(o.Scene3D.SHADOWDISTANCE, this._shaderValueDistance), e.setBuffer(o.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP),
                e.setVector2(o.Scene3D.SHADOWMAPPCFOFFSET, this._shadowPCFOffset), this._shadowMapCount) {
                case 3:
                    e.setTexture(o.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(o.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget),
                        e.setTexture(o.Scene3D.SHADOWMAPTEXTURE3, this.cameras[3].renderTarget);
                    break;

                case 2:
                    e.setTexture(o.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget), e.setTexture(o.Scene3D.SHADOWMAPTEXTURE2, this.cameras[2].renderTarget);
                    break;

                case 1:
                    e.setTexture(o.Scene3D.SHADOWMAPTEXTURE1, this.cameras[1].renderTarget);
            }
        }
        _calcSplitDistance(e) {
            var t, r = this._maxDistance,
                i = 1 / this._shadowMapCount;
            for (t = 0; t <= this._shadowMapCount; t++) this._uniformDistance[t] = e + (r - e) * t * i;
            var n = r / e;
            for (t = 0; t <= this._shadowMapCount; t++) {
                var a = Math.pow(n, t * i);
                this._logDistance[t] = e * a;
            }
            for (t = 0; t <= this._shadowMapCount; t++) this._spiltDistance[t] = this._uniformDistance[t] * this._ratioOfDistance + this._logDistance[t] * (1 - this._ratioOfDistance);
            this._shaderValueDistance.x = null != this._spiltDistance[1] && this._spiltDistance[1],
                this._shaderValueDistance.y = null != this._spiltDistance[2] && this._spiltDistance[2],
                this._shaderValueDistance.z = null != this._spiltDistance[3] && this._spiltDistance[3],
                this._shaderValueDistance.w = null != this._spiltDistance[4] && this._spiltDistance[4];
        }
        _calcBoundingBox(e, t) {
            var r, i, n, a, s, o, l, _, h = 3.1415926 * e / 180,
                c = Math.tan(h / 2);
            for (a = 0; a <= this._shadowMapCount; a++) {
                i = (r = (n = this._spiltDistance[a]) * c) * t;
                var d = this._frustumPos[4 * a + 0];
                d.x = -i, d.y = -r, d.z = -n, (d = this._frustumPos[4 * a + 1]).x = i, d.y = -r,
                    d.z = -n, (d = this._frustumPos[4 * a + 2]).x = -i, d.y = r, d.z = -n, (d = this._frustumPos[4 * a + 3]).x = i,
                    d.y = r, d.z = -n, (d = this._dimension[a]).x = i, d.y = r;
            }
            for (a = 1; a <= this._shadowMapCount; a++) s = this._dimension[a], (o = this._boundingBox[a].min).x = -s.x,
                o.y = -s.y, o.z = -this._spiltDistance[a], (l = this._boundingBox[a].max).x = s.x,
                l.y = s.y, l.z = -this._spiltDistance[a - 1], (_ = this._boundingSphere[a].center).x = .5 * (o.x + l.x),
                _.y = .5 * (o.y + l.y), _.z = .5 * (o.z + l.z), this._boundingSphere[a].radius = .5 * Math.sqrt(Math.pow(l.x - o.x, 2) + Math.pow(l.y - o.y, 2) + Math.pow(l.z - o.z, 2));
            o = this._boundingBox[0].min, s = this._dimension[this._shadowMapCount], o.x = -s.x,
                o.y = -s.y, o.z = -this._spiltDistance[this._shadowMapCount], (l = this._boundingBox[0].max).x = s.x,
                l.y = s.y, l.z = -this._spiltDistance[0], (_ = this._boundingSphere[0].center).x = .5 * (o.x + l.x),
                _.y = .5 * (o.y + l.y), _.z = .5 * (o.z + l.z), this._boundingSphere[0].radius = .5 * Math.sqrt(Math.pow(l.x - o.x, 2) + Math.pow(l.y - o.y, 2) + Math.pow(l.z - o.z, 2));
        }
        calcSplitFrustum(e) {
            this._currentPSSM > 0 ? T.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[this._currentPSSM - 1], this._spiltDistance[this._currentPSSM], this._tempMatrix44) : T.createPerspective(3.1416 * e.fieldOfView / 180, e.aspectRatio, this._spiltDistance[0], this._spiltDistance[this._shadowMapCount], this._tempMatrix44),
                T.multiply(this._tempMatrix44, e.viewMatrix, this._tempMatrix44), this._splitFrustumCulling.matrix = this._tempMatrix44;
        }
        _rebuildRenderInfo() {
            var e, r = this._shadowMapCount + 1;
            for (this.cameras.length = r, e = 0; e < r; e++) {
                if (!this.cameras[e]) {
                    var i = new oe();
                    i.name = "lightCamera" + e, i.clearColor = new n(1, 1, 1, 1), this.cameras[e] = i;
                }
                var a = this.cameras[e].renderTarget;
                null != a && a.width == this._shadowMapTextureSize && a.height == this._shadowMapTextureSize || (a && a.destroy(),
                    (a = new Y(this._shadowMapTextureSize, this._shadowMapTextureSize, t.BaseTexture.FORMAT_R8G8B8A8, t.BaseTexture.FORMAT_DEPTH_16)).filterMode = t.BaseTexture.FILTERMODE_POINT,
                    this.cameras[e].renderTarget = a);
            }
        }
        _calcLightViewProject(e) {
            var t = this._boundingSphere[this._currentPSSM],
                r = e.transform.worldMatrix;
            t.radius;
            t.center.cloneTo(this._tempLookAt3), a.transformV3ToV4(this._tempLookAt3, r, this._tempLookAt4);
            var i = this._tempLookAt3,
                s = this._tempLookAt4;
            i.x = s.x, i.y = s.y, i.z = s.z;
            var l = this._tempLightUp;
            e.transform.worldMatrix.getForward(Pe._tempVector30);
            var _ = Pe._tempVector30;
            l.x = _.x, l.y = 1, l.z = _.z, a.normalize(this._tempLightUp, this._tempLightUp),
                a.scale(this._globalParallelLightDir, 4 * t.radius, this._tempPos), a.subtract(this._tempLookAt3, this._tempPos, this._tempPos);
            var h = this.cameras[this._currentPSSM];
            h.transform.position = this._tempPos, h.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1);
            var c = this._tempMax,
                d = this._tempMin;
            c.x = c.y = c.z = -1e5, c.w = 1, d.x = d.y = d.z = 1e5, d.w = 1, T.multiply(h.viewMatrix, r, this._tempMatrix44);
            var u = this._tempValue,
                f = [];
            f.length = 8, this._boundingBox[this._currentPSSM].getCorners(f);
            for (var E = 0; E < 8; E++) {
                var m = f[E];
                u.x = m.x, u.y = m.y, u.z = m.z, u.w = 1, n.transformByM4x4(this._tempValue, this._tempMatrix44, this._tempValue),
                    d.x = u.x < d.x ? u.x : d.x, d.y = u.y < d.y ? u.y : d.y, d.z = u.z < d.z ? u.z : d.z,
                    c.x = u.x > c.x ? u.x : c.x, c.y = u.y > c.y ? u.y : c.y, c.z = u.z > c.z ? u.z : c.z;
            }
            n.add(this._tempMax, this._tempMin, this._tempValue), u.x *= .5, u.y *= .5, u.z *= .5,
                u.w = 1, n.transformByM4x4(this._tempValue, h.transform.worldMatrix, this._tempValue);
            var p = Math.abs(-this._tempMax.z),
                g = p > this._maxDistance ? p : this._maxDistance;
            a.scale(this._globalParallelLightDir, g, this._tempPos);
            var S = this._tempPos;
            S.x = u.x - S.x, S.y = u.y - S.y, S.z = u.z - S.z, h.transform.position = this._tempPos,
                h.transform.lookAt(this._tempLookAt3, this._tempLightUp, !1), T.createOrthoOffCenter(d.x, c.x, d.y, c.y, 1, g + .5 * (c.z - d.z), h.projectionMatrix);
            var v = h.projectionViewMatrix;
            Pe.multiplyMatrixOutFloat32Array(this._tempScaleMatrix44, v, this._shaderValueVPs[this._currentPSSM]),
                this._scene._shaderValues.setBuffer(o.Scene3D.SHADOWLIGHTVIEWPROJECT, this._shaderValueLightVP);
        }
        static multiplyMatrixOutFloat32Array(e, t, r) {
            var i, n, a, s, o, l, _;
            for (n = e.elements, a = t.elements, i = 0; i < 4; i++) s = n[i], o = n[i + 4],
                l = n[i + 8], _ = n[i + 12], r[i] = s * a[0] + o * a[1] + l * a[2] + _ * a[3], r[i + 4] = s * a[4] + o * a[5] + l * a[6] + _ * a[7],
                r[i + 8] = s * a[8] + o * a[9] + l * a[10] + _ * a[11], r[i + 12] = s * a[12] + o * a[13] + l * a[14] + _ * a[15];
        }
        setShadowMapTextureSize(e) {
            e !== this._shadowMapTextureSize && (this._shadowMapTextureSize = e, this._shadowPCFOffset.x = 1 / this._shadowMapTextureSize,
                this._shadowPCFOffset.y = 1 / this._shadowMapTextureSize, this._statesDirty = !0);
        }
        disposeAllRenderTarget() {
            for (var e = 0, t = this._shadowMapCount + 1; e < t; e++) this.cameras[e].renderTarget && (this.cameras[e].renderTarget.destroy(),
                this.cameras[e].renderTarget = null);
        }
    }
    Pe.MAX_PSSM_COUNT = 3, Pe._tempVector30 = new a();
    class Ve extends b {
        constructor() {
            super(), this._intensity = 1, this._intensityColor = new a(), this.color = new a(1, 1, 1),
                this._shadow = !1, this._shadowFarPlane = 8, this._shadowMapSize = 512, this._shadowMapCount = 1,
                this._shadowMapPCFType = 0, this._lightmapBakedType = Ve.LIGHTMAPBAKEDTYPE_REALTIME;
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(e) {
            this._intensity = e;
        }
        get shadow() {
            return this._shadow;
        }
        set shadow(e) {
            throw new Error("LightSprite: must override it.");
        }
        get shadowDistance() {
            return this._shadowFarPlane;
        }
        set shadowDistance(e) {
            this._shadowFarPlane = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setFarDistance(e);
        }
        get shadowResolution() {
            return this._shadowMapSize;
        }
        set shadowResolution(e) {
            this._shadowMapSize = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setShadowMapTextureSize(e);
        }
        get shadowPSSMCount() {
            return this._shadowMapCount;
        }
        set shadowPSSMCount(e) {
            this._shadowMapCount = e, this._parallelSplitShadowMap && (this._parallelSplitShadowMap.shadowMapCount = e);
        }
        get shadowPCFType() {
            return this._shadowMapPCFType;
        }
        set shadowPCFType(e) {
            this._shadowMapPCFType = e, this._parallelSplitShadowMap && this._parallelSplitShadowMap.setPCFType(e);
        }
        get lightmapBakedType() {
            return this._lightmapBakedType;
        }
        set lightmapBakedType(e) {
            this._lightmapBakedType !== e && (this._lightmapBakedType = e, this.activeInHierarchy && (e !== Ve.LIGHTMAPBAKEDTYPE_BAKED ? this._scene._addLight(this) : this._scene._removeLight(this)));
        }
        _parse(e, t) {
            super._parse(e, t);
            var r = e.color;
            this.color.fromArray(r), this.intensity = e.intensity, this.lightmapBakedType = e.lightmapBakedType;
        }
        _onActive() {
            super._onActive(), this.lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._addLight(this);
        }
        _onInActive() {
            super._onInActive(), this.lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._removeLight(this);
        }
        _prepareToScene() {
            return !1;
        }
        _create() {
            return new Ve();
        }
        get diffuseColor() {
            return console.log("LightSprite: discard property,please use color property instead."),
                this.color;
        }
        set diffuseColor(e) {
            console.log("LightSprite: discard property,please use color property instead."),
                this.color = e;
        }
    }
    Ve.LIGHTMAPBAKEDTYPE_REALTIME = 0, Ve.LIGHTMAPBAKEDTYPE_MIXED = 1, Ve.LIGHTMAPBAKEDTYPE_BAKED = 2;
    class we extends Ve {
        set shadow(e) {
            this._shadow !== e && (this._shadow = e, this.scene && this._initShadow());
        }
        constructor() {
            super(), this._direction = new a();
        }
        _initShadow() {
            if (this._shadow) this._parallelSplitShadowMap = new Pe(), this.scene.parallelSplitShadowMaps.push(this._parallelSplitShadowMap),
                this.transform.worldMatrix.getForward(this._direction), a.normalize(this._direction, this._direction),
                this._parallelSplitShadowMap.setInfo(this.scene, this._shadowFarPlane, this._direction, this._shadowMapSize, this._shadowMapCount, this._shadowMapPCFType);
            else {
                var e = this._scene._shaderValues,
                    t = this.scene.parallelSplitShadowMaps;
                t.splice(t.indexOf(this._parallelSplitShadowMap), 1), this._parallelSplitShadowMap.disposeAllRenderTarget(),
                    this._parallelSplitShadowMap = null, e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM1),
                    e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM2), e.removeDefine(se.SHADERDEFINE_SHADOW_PSSM3);
            }
        }
        _onActive() {
            super._onActive(), this._shadow && this._initShadow(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.addDefine(se.SHADERDEFINE_DIRECTIONLIGHT);
        }
        _onInActive() {
            super._onInActive(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.removeDefine(se.SHADERDEFINE_DIRECTIONLIGHT);
        }
        _prepareToScene() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                var t = e._shaderValues;
                return a.scale(this.color, this._intensity, this._intensityColor), t.setVector3(o.Scene3D.LIGHTDIRCOLOR, this._intensityColor),
                    this.transform.worldMatrix.getForward(this._direction), a.normalize(this._direction, this._direction),
                    t.setVector3(o.Scene3D.LIGHTDIRECTION, this._direction), !0;
            }
            return !1;
        }
    }
    class be extends Ve {
        constructor() {
            super(), this._lightMatrix = new T(), this._range = 6;
        }
        get range() {
            return this._range;
        }
        set range(e) {
            this._range = e;
        }
        _onActive() {
            super._onActive(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.addDefine(se.SHADERDEFINE_POINTLIGHT);
        }
        _onInActive() {
            super._onInActive(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this._scene._shaderValues.removeDefine(se.SHADERDEFINE_POINTLIGHT);
        }
        _prepareToScene() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                var t = e._shaderValues;
                a.scale(this.color, this._intensity, this._intensityColor), t.setVector3(o.Scene3D.POINTLIGHTCOLOR, this._intensityColor),
                    t.setVector3(o.Scene3D.POINTLIGHTPOS, this.transform.position), t.setNumber(o.Scene3D.POINTLIGHTRANGE, this.range);
                var r = this._lightMatrix,
                    i = r.elements;
                r.identity(), i[0] = i[5] = i[10] = 1 / this._range;
                var n = be._tempMatrix0;
                return this.transform.worldMatrix.invert(n), T.multiply(r, n, r), t.setMatrix4x4(o.Scene3D.POINTLIGHTMATRIX, r), !0;
            }
            return !1;
        }
        _parse(e, t) {
            super._parse(e, t), this.range = e.range;
        }
    }
    be._tempMatrix0 = new T();
    class Fe extends Ve {
        constructor() {
            super(), this._spotAngle = 30, this._range = 10, this._direction = new a();
        }
        get spotAngle() {
            return this._spotAngle;
        }
        set spotAngle(e) {
            this._spotAngle = Math.max(Math.min(e, 180), 0);
        }
        get range() {
            return this._range;
        }
        set range(e) {
            this._range = e;
        }
        _onActive() {
            super._onActive(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this.scene._shaderValues.addDefine(se.SHADERDEFINE_SPOTLIGHT);
        }
        _onInActive() {
            super._onInActive(), this._lightmapBakedType !== Ve.LIGHTMAPBAKEDTYPE_BAKED && this.scene._shaderValues.removeDefine(se.SHADERDEFINE_SPOTLIGHT);
        }
        _prepareToScene() {
            var e = this._scene;
            if (e.enableLight && this.activeInHierarchy) {
                var t = e._shaderValues;
                return a.scale(this.color, this._intensity, this._intensityColor), t.setVector3(o.Scene3D.SPOTLIGHTCOLOR, this._intensityColor),
                    t.setVector3(o.Scene3D.SPOTLIGHTPOS, this.transform.position), this.transform.worldMatrix.getForward(this._direction),
                    a.normalize(this._direction, this._direction), t.setVector3(o.Scene3D.SPOTLIGHTDIRECTION, this._direction),
                    t.setNumber(o.Scene3D.SPOTLIGHTRANGE, this.range), t.setNumber(o.Scene3D.SPOTLIGHTSPOTANGLE, this.spotAngle * Math.PI / 180), !0;
            }
            return !1;
        }
        _parse(e, t) {
            super._parse(e, t), this.range = e.range, this.spotAngle = e.spotAngle;
        }
    }
    Fe._tempMatrix0 = new T(), Fe._tempMatrix1 = new T();
    class Be {}
    class Ue {
        get sharedMesh() {
            return this._sharedMesh;
        }
        set sharedMesh(e) {
            if (this._sharedMesh !== e) {
                var t = this._owner._render._shaderValues,
                    r = this._sharedMesh;
                r && (r._removeReference(), t.removeDefine(this._getMeshDefine(r))), e && (e._addReference(),
                    t.addDefine(this._getMeshDefine(e))), this._owner._render._onMeshChange(e), this._sharedMesh = e;
            }
        }
        constructor(e) {
            this._owner = e;
        }
        _getMeshDefine(e) {
            for (var t, r = 0, i = e._subMeshes.length; r < i; r++)
                for (var n = e.getSubMesh(r)._vertexBuffer._vertexDeclaration._vertexElements, a = 0, s = n.length; a < s; a++) {
                    switch (n[a]._elementUsage) {
                        case v.MESH_COLOR0:
                            t |= Be.SHADERDEFINE_COLOR;
                            break;

                        case v.MESH_TEXTURECOORDINATE0:
                            t |= Be.SHADERDEFINE_UV0;
                            break;

                        case v.MESH_TEXTURECOORDINATE1:
                            t |= Be.SHADERDEFINE_UV1;
                    }
                }
            return t;
        }
        destroy() {
            this._owner = null, this._sharedMesh && (this._sharedMesh._removeReference(), this._sharedMesh = null);
        }
    }
    class Ge extends t.Resource {
        constructor() {
            super(), this._shaderValues = null, this._disablePublicDefineDatas = new m(), this._shaderValues = new p(this),
                this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this._alphaTest = !1;
        }
        static load(e, r) {
            t.Laya.loader.create(e, r, null, Ge.MATERIAL);
        }
        static __initDefine__() {
            Ge.shaderDefines = new C(), Ge.SHADERDEFINE_ALPHATEST = Ge.shaderDefines.registerDefine("ALPHATEST");
        }
        static _parse(e, r = null, s = null) {
            var o, l = e,
                _ = l.props,
                h = _.type,
                c = t.ClassUtils.getRegClass(h);
            if (!c) throw "_getSprite3DHierarchyInnerUrls 错误: " + e.type + " 不是类";
            switch (o = new c(), l.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    var d, u;
                    for (var f in _) switch (f) {
                        case "vectors":
                            var E = _[f];
                            for (d = 0, u = E.length; d < u; d++) {
                                var T = E[d],
                                    m = T.value;
                                switch (m.length) {
                                    case 2:
                                        o[T.name] = new i(m[0], m[1]);
                                        break;

                                    case 3:
                                        o[T.name] = new a(m[0], m[1], m[2]);
                                        break;

                                    case 4:
                                        o[T.name] = new n(m[0], m[1], m[2], m[3]);
                                        break;

                                    default:
                                        throw new Error("BaseMaterial:unkonwn color length.");
                                }
                            }
                            break;

                        case "textures":
                            var p = _[f];
                            for (d = 0, u = p.length; d < u; d++) {
                                var g = p[d],
                                    S = g.path;
                                S && (o[g.name] = t.Loader.getRes(S));
                            }
                            break;

                        case "defines":
                            var v = _[f];
                            for (d = 0, u = v.length; d < u; d++) {
                                var R = o._shader.getSubShaderAt(0).getMaterialDefineByName(v[d]);
                                o._shaderValues.addDefine(R);
                            }
                            break;

                        case "renderStates":
                            var A = _[f][0],
                                D = o;
                            D.blend = A.blend, D.cull = A.cull, D.depthTest = A.depthTest, D.depthWrite = A.depthWrite,
                                D.blendSrc = A.srcBlend, D.blendDst = A.dstBlend;
                            break;

                        case "cull":
                            o.cull = _[f];
                            break;

                        case "blend":
                            o.blend = _[f];
                            break;

                        case "depthWrite":
                            o.depthWrite = _[f];
                            break;

                        case "srcBlend":
                            o.blendSrc = _[f];
                            break;

                        case "dstBlend":
                            o.blendDst = _[f];
                            break;

                        default:
                            o[f] = _[f];
                    }
                    break;

                default:
                    throw new Error("BaseMaterial:unkonwn version.");
            }
            return o;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Ge.ALPHATESTVALUE);
        }
        set alphaTestValue(e) {
            this._shaderValues.setNumber(Ge.ALPHATESTVALUE, e);
        }
        get alphaTest() {
            return this._alphaTest;
        }
        set alphaTest(e) {
            this._alphaTest = e, e ? this._shaderValues.addDefine(Ge.SHADERDEFINE_ALPHATEST) : this._shaderValues.removeDefine(Ge.SHADERDEFINE_ALPHATEST);
        }
        _removeTetxureReference() {
            var e = this._shaderValues.getData();
            for (var r in e) {
                var i = e[r];
                i && i instanceof t.BaseTexture && i._removeReference();
            }
        }
        _addReference(e = 1) {
            super._addReference(e);
            var r = this._shaderValues.getData();
            for (var i in r) {
                var n = r[i];
                n && n instanceof t.BaseTexture && n._addReference();
            }
        }
        _removeReference(e = 1) {
            super._removeReference(e), this._removeTetxureReference();
        }
        _disposeResource() {
            this._referenceCount > 0 && this._removeTetxureReference(), this._shaderValues = null;
        }
        setShaderName(e) {
            if (this._shader = L.find(e), !this._shader) throw new Error("BaseMaterial: unknown shader name.");
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name, t.renderQueue = this.renderQueue, this._disablePublicDefineDatas.cloneTo(t._disablePublicDefineDatas),
                this._shaderValues.cloneTo(t._shaderValues);
        }
        clone() {
            var e = new Ge();
            return this.cloneTo(e), e;
        }
        get _defineDatas() {
            return this._shaderValues._defineDatas;
        }
    }
    Ge.MATERIAL = "MATERIAL", Ge.RENDERQUEUE_OPAQUE = 2e3, Ge.RENDERQUEUE_ALPHATEST = 2450,
        Ge.RENDERQUEUE_TRANSPARENT = 3e3, Ge.ALPHATESTVALUE = L.propertyNameToID("u_AlphaTestValue"),
        Ge.shaderDefines = null;
    class ze {
        constructor() {
            this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.srcBlend = ze.BLENDPARAM_ONE,
                this.dstBlend = ze.BLENDPARAM_ZERO, this.srcBlendRGB = ze.BLENDPARAM_ONE, this.dstBlendRGB = ze.BLENDPARAM_ZERO,
                this.srcBlendAlpha = ze.BLENDPARAM_ONE, this.dstBlendAlpha = ze.BLENDPARAM_ZERO,
                this.blendConstColor = new n(1, 1, 1, 1), this.blendEquation = ze.BLENDEQUATION_ADD,
                this.blendEquationRGB = ze.BLENDEQUATION_ADD, this.blendEquationAlpha = ze.BLENDEQUATION_ADD,
                this.depthTest = ze.DEPTHTEST_LEQUAL, this.depthWrite = !0;
        }
        cloneTo(e) {
            var t = e;
            t.cull = this.cull, t.blend = this.blend, t.srcBlend = this.srcBlend, t.dstBlend = this.dstBlend,
                t.srcBlendRGB = this.srcBlendRGB, t.dstBlendRGB = this.dstBlendRGB, t.srcBlendAlpha = this.srcBlendAlpha,
                t.dstBlendAlpha = this.dstBlendAlpha, this.blendConstColor.cloneTo(t.blendConstColor),
                t.blendEquation = this.blendEquation, t.blendEquationRGB = this.blendEquationRGB,
                t.blendEquationAlpha = this.blendEquationAlpha, t.depthTest = this.depthTest, t.depthWrite = this.depthWrite;
        }
        clone() {
            var e = new ze();
            return this.cloneTo(e), e;
        }
    }
    ze.CULL_NONE = 0, ze.CULL_FRONT = 1, ze.CULL_BACK = 2, ze.BLEND_DISABLE = 0, ze.BLEND_ENABLE_ALL = 1,
        ze.BLEND_ENABLE_SEPERATE = 2, ze.BLENDPARAM_ZERO = 0, ze.BLENDPARAM_ONE = 1, ze.BLENDPARAM_SRC_COLOR = 768,
        ze.BLENDPARAM_ONE_MINUS_SRC_COLOR = 769, ze.BLENDPARAM_DST_COLOR = 774, ze.BLENDPARAM_ONE_MINUS_DST_COLOR = 775,
        ze.BLENDPARAM_SRC_ALPHA = 770, ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA = 771, ze.BLENDPARAM_DST_ALPHA = 772,
        ze.BLENDPARAM_ONE_MINUS_DST_ALPHA = 773, ze.BLENDPARAM_SRC_ALPHA_SATURATE = 776,
        ze.BLENDEQUATION_ADD = 0, ze.BLENDEQUATION_SUBTRACT = 1, ze.BLENDEQUATION_REVERSE_SUBTRACT = 2,
        ze.DEPTHTEST_OFF = 0, ze.DEPTHTEST_NEVER = 512, ze.DEPTHTEST_LESS = 513, ze.DEPTHTEST_EQUAL = 514,
        ze.DEPTHTEST_LEQUAL = 515, ze.DEPTHTEST_GREATER = 516, ze.DEPTHTEST_NOTEQUAL = 517,
        ze.DEPTHTEST_GEQUAL = 518, ze.DEPTHTEST_ALWAYS = 519;
    class He extends Ge {
        constructor() {
            super(), this._enableVertexColor = !1, this.setShaderName("BLINNPHONG"), this._albedoIntensity = 1,
                this._albedoColor = new n(1, 1, 1, 1);
            var e = this._shaderValues;
            e.setVector(He.ALBEDOCOLOR, new n(1, 1, 1, 1)), e.setVector(He.MATERIALSPECULAR, new n(1, 1, 1, 1)),
                e.setNumber(He.SHININESS, .078125), e.setNumber(Ge.ALPHATESTVALUE, .5), e.setVector(He.TILINGOFFSET, new n(1, 1, 0, 0)),
                this._enableLighting = !0, this.renderMode = He.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            He.shaderDefines = new C(Ge.shaderDefines), He.SHADERDEFINE_DIFFUSEMAP = He.shaderDefines.registerDefine("DIFFUSEMAP"),
                He.SHADERDEFINE_NORMALMAP = He.shaderDefines.registerDefine("NORMALMAP"), He.SHADERDEFINE_SPECULARMAP = He.shaderDefines.registerDefine("SPECULARMAP"),
                He.SHADERDEFINE_TILINGOFFSET = He.shaderDefines.registerDefine("TILINGOFFSET"),
                He.SHADERDEFINE_ENABLEVERTEXCOLOR = He.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _SpecColorR() {
            return this._shaderValues.getVector(He.MATERIALSPECULAR).x;
        }
        set _SpecColorR(e) {
            this._shaderValues.getVector(He.MATERIALSPECULAR).x = e;
        }
        get _SpecColorG() {
            return this._shaderValues.getVector(He.MATERIALSPECULAR).y;
        }
        set _SpecColorG(e) {
            this._shaderValues.getVector(He.MATERIALSPECULAR).y = e;
        }
        get _SpecColorB() {
            return this._shaderValues.getVector(He.MATERIALSPECULAR).z;
        }
        set _SpecColorB(e) {
            this._shaderValues.getVector(He.MATERIALSPECULAR).z = e;
        }
        get _SpecColorA() {
            return this._shaderValues.getVector(He.MATERIALSPECULAR).w;
        }
        set _SpecColorA(e) {
            this._shaderValues.getVector(He.MATERIALSPECULAR).w = e;
        }
        get _AlbedoIntensity() {
            return this._albedoIntensity;
        }
        set _AlbedoIntensity(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(He.ALBEDOCOLOR);
                n.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(He.ALBEDOCOLOR, t);
            }
        }
        get _Shininess() {
            return this._shaderValues.getNumber(He.SHININESS);
        }
        set _Shininess(e) {
            e = Math.max(0, Math.min(1, e)), this._shaderValues.setNumber(He.SHININESS, e);
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(He.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(He.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(He.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(He.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(He.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(He.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(He.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(He.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        set renderMode(e) {
            switch (e) {
                case He.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                case He.RENDERMODE_CUTOUT:
                    this.renderQueue = Ge.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                case He.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                default:
                    throw new Error("Material:renderMode value error.");
            }
        }
        get enableVertexColor() {
            return this._enableVertexColor;
        }
        set enableVertexColor(e) {
            this._enableVertexColor = e, e ? this._shaderValues.addDefine(He.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(He.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(He.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(He.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(He.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(He.TILINGOFFSET, e);
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            var t = this._shaderValues.getVector(He.ALBEDOCOLOR);
            n.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(He.ALBEDOCOLOR, t);
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(e) {
            this._AlbedoIntensity = e;
        }
        get specularColorR() {
            return this._SpecColorR;
        }
        set specularColorR(e) {
            this._SpecColorR = e;
        }
        get specularColorG() {
            return this._SpecColorG;
        }
        set specularColorG(e) {
            this._SpecColorG = e;
        }
        get specularColorB() {
            return this._SpecColorB;
        }
        set specularColorB(e) {
            this._SpecColorB = e;
        }
        get specularColorA() {
            return this._SpecColorA;
        }
        set specularColorA(e) {
            this._SpecColorA = e;
        }
        get specularColor() {
            return this._shaderValues.getVector(He.MATERIALSPECULAR);
        }
        set specularColor(e) {
            this._shaderValues.setVector(He.MATERIALSPECULAR, e);
        }
        get shininess() {
            return this._Shininess;
        }
        set shininess(e) {
            this._Shininess = e;
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(He.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(He.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(He.SHADERDEFINE_DIFFUSEMAP),
                this._shaderValues.setTexture(He.ALBEDOTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(He.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(He.SHADERDEFINE_NORMALMAP) : this._shaderValues.removeDefine(He.SHADERDEFINE_NORMALMAP),
                this._shaderValues.setTexture(He.NORMALTEXTURE, e);
        }
        get specularTexture() {
            return this._shaderValues.getTexture(He.SPECULARTEXTURE);
        }
        set specularTexture(e) {
            e ? this._shaderValues.addDefine(He.SHADERDEFINE_SPECULARMAP) : this._shaderValues.removeDefine(He.SHADERDEFINE_SPECULARMAP),
                this._shaderValues.setTexture(He.SPECULARTEXTURE, e);
        }
        get enableLighting() {
            return this._enableLighting;
        }
        set enableLighting(e) {
            this._enableLighting !== e && (e ? this._disablePublicDefineDatas.remove(se.SHADERDEFINE_POINTLIGHT | se.SHADERDEFINE_SPOTLIGHT | se.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(se.SHADERDEFINE_POINTLIGHT | se.SHADERDEFINE_SPOTLIGHT | se.SHADERDEFINE_DIRECTIONLIGHT),
                this._enableLighting = e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(He.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(He.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(He.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(He.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(He.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(He.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(He.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(He.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(He.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(He.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(He.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(He.DEPTH_TEST);
        }
        clone() {
            var e = new He();
            return this.cloneTo(e), e;
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t._enableLighting = this._enableLighting, t._albedoIntensity = this._albedoIntensity,
                t._enableVertexColor = this._enableVertexColor, this._albedoColor.cloneTo(t._albedoColor);
        }
    }
    He.RENDERMODE_OPAQUE = 0, He.RENDERMODE_CUTOUT = 1, He.RENDERMODE_TRANSPARENT = 2,
        He.ALBEDOTEXTURE = L.propertyNameToID("u_DiffuseTexture"), He.NORMALTEXTURE = L.propertyNameToID("u_NormalTexture"),
        He.SPECULARTEXTURE = L.propertyNameToID("u_SpecularTexture"), He.ALBEDOCOLOR = L.propertyNameToID("u_DiffuseColor"),
        He.MATERIALSPECULAR = L.propertyNameToID("u_MaterialSpecular"), He.SHININESS = L.propertyNameToID("u_Shininess"),
        He.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"), He.CULL = L.propertyNameToID("s_Cull"),
        He.BLEND = L.propertyNameToID("s_Blend"), He.BLEND_SRC = L.propertyNameToID("s_BlendSrc"),
        He.BLEND_DST = L.propertyNameToID("s_BlendDst"), He.DEPTH_TEST = L.propertyNameToID("s_DepthTest"),
        He.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"), He.shaderDefines = null;
    class We {
        constructor(e, t) {
            this._updateFlag = 0, this._center = new a(), this._extent = new a(), this._boundBox = new Oe(new a(), new a()),
                e.cloneTo(this._boundBox.min), t.cloneTo(this._boundBox.max), this._setUpdateFlag(We._UPDATE_CENTER | We._UPDATE_EXTENT, !0);
        }
        setMin(e) {
            var t = this._boundBox.min;
            e !== t && e.cloneTo(t), this._setUpdateFlag(We._UPDATE_CENTER | We._UPDATE_EXTENT, !0),
                this._setUpdateFlag(We._UPDATE_MIN, !1);
        }
        getMin() {
            var e = this._boundBox.min;
            return this._getUpdateFlag(We._UPDATE_MIN) && (this._getMin(this.getCenter(), this.getExtent(), e),
                this._setUpdateFlag(We._UPDATE_MIN, !1)), e;
        }
        setMax(e) {
            var t = this._boundBox.max;
            e !== t && e.cloneTo(t), this._setUpdateFlag(We._UPDATE_CENTER | We._UPDATE_EXTENT, !0),
                this._setUpdateFlag(We._UPDATE_MAX, !1);
        }
        getMax() {
            var e = this._boundBox.max;
            return this._getUpdateFlag(We._UPDATE_MAX) && (this._getMax(this.getCenter(), this.getExtent(), e),
                this._setUpdateFlag(We._UPDATE_MAX, !1)), e;
        }
        setCenter(e) {
            e !== this._center && e.cloneTo(this._center), this._setUpdateFlag(We._UPDATE_MIN | We._UPDATE_MAX, !0),
                this._setUpdateFlag(We._UPDATE_CENTER, !1);
        }
        getCenter() {
            return this._getUpdateFlag(We._UPDATE_CENTER) && (this._getCenter(this.getMin(), this.getMax(), this._center),
                this._setUpdateFlag(We._UPDATE_CENTER, !1)), this._center;
        }
        setExtent(e) {
            e !== this._extent && e.cloneTo(this._extent), this._setUpdateFlag(We._UPDATE_MIN | We._UPDATE_MAX, !0),
                this._setUpdateFlag(We._UPDATE_EXTENT, !1);
        }
        getExtent() {
            return this._getUpdateFlag(We._UPDATE_EXTENT) && (this._getExtent(this.getMin(), this.getMax(), this._extent),
                this._setUpdateFlag(We._UPDATE_EXTENT, !1)), this._extent;
        }
        _getUpdateFlag(e) {
            return 0 != (this._updateFlag & e);
        }
        _setUpdateFlag(e, t) {
            t ? this._updateFlag |= e : this._updateFlag &= ~e;
        }
        _getCenter(e, t, r) {
            a.add(e, t, r), a.scale(r, .5, r);
        }
        _getExtent(e, t, r) {
            a.subtract(t, e, r), a.scale(r, .5, r);
        }
        _getMin(e, t, r) {
            a.subtract(e, t, r);
        }
        _getMax(e, t, r) {
            a.add(e, t, r);
        }
        _rotateExtents(e, t, r) {
            var i = e.x,
                n = e.y,
                a = e.z,
                s = t.elements;
            r.x = Math.abs(s[0] * i) + Math.abs(s[4] * n) + Math.abs(s[8] * a), r.y = Math.abs(s[1] * i) + Math.abs(s[5] * n) + Math.abs(s[9] * a),
                r.z = Math.abs(s[2] * i) + Math.abs(s[6] * n) + Math.abs(s[10] * a);
        }
        _tranform(e, t) {
            var r = t._center,
                i = t._extent;
            a.transformCoordinate(this.getCenter(), e, r), this._rotateExtents(this.getExtent(), e, i),
                t._boundBox.setCenterAndExtent(r, i), t._updateFlag = 0;
        }
        _getBoundBox() {
            if (this._updateFlag & We._UPDATE_MIN) {
                var e = this._boundBox.min;
                this._getMin(this.getCenter(), this.getExtent(), e), this._setUpdateFlag(We._UPDATE_MIN, !1);
            }
            if (this._updateFlag & We._UPDATE_MAX) {
                var t = this._boundBox.max;
                this._getMax(this.getCenter(), this.getExtent(), t), this._setUpdateFlag(We._UPDATE_MAX, !1);
            }
            return this._boundBox;
        }
        cloneTo(e) {
            var t = e;
            this.getMin().cloneTo(t._boundBox.min), this.getMax().cloneTo(t._boundBox.max),
                this.getCenter().cloneTo(t._center), this.getExtent().cloneTo(t._extent), t._updateFlag = 0;
        }
        clone() {
            var e = new We(new a(), new a());
            return this.cloneTo(e), e;
        }
    }
    We._UPDATE_MIN = 1, We._UPDATE_MAX = 2, We._UPDATE_CENTER = 4, We._UPDATE_EXTENT = 8;
    class ke extends t.EventDispatcher {
        constructor(e) {
            if (super(), this._indexInList = -1, this._indexInCastShadowList = -1, this._boundsChange = !0,
                this._supportOctree = !0, this._sharedMaterials = [], this._visible = !0, this._indexInOctreeMotionList = -1,
                this._updateMark = -1, this._updateRenderType = -1, this._isPartOfStaticBatch = !1,
                this._staticBatch = null, this._id = ++ke._uniqueIDCounter, this._indexInCastShadowList = -1,
                this._bounds = new We(a._ZERO, a._ZERO), t.Render.supportWebGLPlusCulling) {
                var r = U._cullingBufferLength;
                this._cullingBufferIndex = r;
                var i = U._cullingBuffer,
                    n = r + 7;
                if (n >= i.length) {
                    var s = i;
                    (i = U._cullingBuffer = new Float32Array(i.length + 4096)).set(s, 0);
                }
                i[r] = 2, U._cullingBufferLength = n;
            }
            this._renderElements = [], this._owner = e, this._enable = !0, this._materialsInstance = [],
                this._shaderValues = new p(null), this.lightmapIndex = -1, this._castShadow = !1,
                this.receiveShadow = !1, this.sortingFudge = 0, e && this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
        }
        get id() {
            return this._id;
        }
        get lightmapIndex() {
            return this._lightmapIndex;
        }
        set lightmapIndex(e) {
            this._lightmapIndex !== e && (this._lightmapIndex = e, this._applyLightMapParams());
        }
        get lightmapScaleOffset() {
            return this._lightmapScaleOffset;
        }
        set lightmapScaleOffset(e) {
            this._lightmapScaleOffset = e, this._shaderValues.setVector(F.LIGHTMAPSCALEOFFSET, e),
                this._shaderValues.addDefine(F.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
        }
        get enable() {
            return this._enable;
        }
        set enable(e) {
            this._enable = !!e;
        }
        get material() {
            var e = this._sharedMaterials[0];
            if (e && !this._materialsInstance[0]) {
                var t = this._getInstanceMaterial(e, 0),
                    r = this._renderElements[0];
                r && (r.material = t);
            }
            return this._sharedMaterials[0];
        }
        set material(e) {
            this.sharedMaterial = e;
        }
        get materials() {
            for (var e = 0, t = this._sharedMaterials.length; e < t; e++)
                if (!this._materialsInstance[e]) {
                    var r = this._getInstanceMaterial(this._sharedMaterials[e], e),
                        i = this._renderElements[e];
                    i && (i.material = r);
                }
            return this._sharedMaterials.slice();
        }
        set materials(e) {
            this.sharedMaterials = e;
        }
        get sharedMaterial() {
            return this._sharedMaterials[0];
        }
        set sharedMaterial(e) {
            var t = this._sharedMaterials[0];
            if (t !== e) {
                this._sharedMaterials[0] = e, this._materialsInstance[0] = !1, this._changeMaterialReference(t, e);
                var r = this._renderElements[0];
                r && (r.material = e);
            }
        }
        get sharedMaterials() {
            return this._sharedMaterials.slice();
        }
        set sharedMaterials(e) {
            for (var t = this._materialsInstance, r = this._sharedMaterials, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                a && a._removeReference();
            }
            if (!e) throw new Error("BaseRender: shadredMaterials value can't be null.");
            var s = e.length;
            for (t.length = s, r.length = s, i = 0; i < s; i++) {
                a = r[i];
                var o = e[i];
                if (a !== o) {
                    t[i] = !1;
                    var l = this._renderElements[i];
                    l && (l.material = o);
                }
                o && o._addReference(), r[i] = o;
            }
        }
        get bounds() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                this._bounds;
        }
        set receiveShadow(e) {
            this._receiveShadow !== e && (this._receiveShadow = e, e ? this._shaderValues.addDefine(F.SHADERDEFINE_RECEIVE_SHADOW) : this._shaderValues.removeDefine(F.SHADERDEFINE_RECEIVE_SHADOW));
        }
        get receiveShadow() {
            return this._receiveShadow;
        }
        get castShadow() {
            return this._castShadow;
        }
        set castShadow(e) {
            this._castShadow !== e && (this._owner.activeInHierarchy && (e ? this._scene._addShadowCastRenderObject(this) : this._scene._removeShadowCastRenderObject(this)),
                this._castShadow = e);
        }
        get isPartOfStaticBatch() {
            return this._isPartOfStaticBatch;
        }
        _getOctreeNode() {
            return this._octreeNode;
        }
        _setOctreeNode(e) {
            this._octreeNode = e;
        }
        _getIndexInMotionList() {
            return this._indexInOctreeMotionList;
        }
        _setIndexInMotionList(e) {
            this._indexInOctreeMotionList = e;
        }
        _changeMaterialReference(e, t) {
            e && e._removeReference(), t._addReference();
        }
        _getInstanceMaterial(e, t) {
            var r = e.clone();
            return r.name = r.name + "(Instance)", this._materialsInstance[t] = !0, this._changeMaterialReference(this._sharedMaterials[t], r),
                this._sharedMaterials[t] = r, r;
        }
        _applyLightMapParams() {
            if (this._scene && this._lightmapIndex >= 0) {
                var e = this._scene.getlightmaps();
                this._lightmapIndex < e.length ? (this._shaderValues.addDefine(F.SAHDERDEFINE_LIGHTMAP),
                    this._shaderValues.setTexture(F.LIGHTMAP, e[this._lightmapIndex])) : this._shaderValues.removeDefine(F.SAHDERDEFINE_LIGHTMAP);
            } else this._shaderValues.removeDefine(F.SAHDERDEFINE_LIGHTMAP);
        }
        _onWorldMatNeedChange(e) {
            this._boundsChange = !0, this._octreeNode && (e &= w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this);
        }
        _calculateBoundingBox() {
            throw "BaseRender: must override it.";
        }
        _getIndexInList() {
            return this._indexInList;
        }
        _setIndexInList(e) {
            this._indexInList = e;
        }
        _setBelongScene(e) {
            this._scene !== e && (this._scene = e, this._applyLightMapParams());
        }
        _needRender(e, t) {
            return !0;
        }
        _renderUpdate(e, t) {}
        _renderUpdateWithCamera(e, t) {}
        _revertBatchRenderUpdate(e) {}
        _destroy() {
            -1 !== this._indexInOctreeMotionList && this._octreeNode._octree.removeMotionObject(this),
                this.offAll();
            var e = 0,
                t = 0;
            for (e = 0, t = this._renderElements.length; e < t; e++) this._renderElements[e].destroy();
            for (e = 0, t = this._sharedMaterials.length; e < t; e++) this._sharedMaterials[e].destroyed || this._sharedMaterials[e]._removeReference();
            this._renderElements = null, this._owner = null, this._sharedMaterials = null, this._bounds = null,
                this._lightmapScaleOffset = null;
        }
    }
    ke._tempBoundBoxCorners = [new a(), new a(), new a(), new a(), new a(), new a(), new a(), new a()],
        ke._uniqueIDCounter = 0;
    class Xe extends ke {
        constructor(e) {
            super(e), this._projectionViewWorldMatrix = new T();
        }
        _createRenderElement() {
            return new _e();
        }
        _onMeshChange(e) {
            if (e) {
                var t = e.subMeshCount;
                this._renderElements.length = t;
                for (var r = 0; r < t; r++) {
                    var i = this._renderElements[r];
                    if (!i) {
                        var n = this.sharedMaterials[r];
                        (i = this._renderElements[r] = this._createRenderElement()).setTransform(this._owner._transform),
                            i.render = this, i.material = n || He.defaultMaterial;
                    }
                    i.setGeometry(e.getSubMesh(r));
                }
            } else this._renderElements.length = 0;
            this._boundsChange = !0;
        }
        _calculateBoundingBox() {
            var e = this._owner.meshFilter.sharedMesh;
            if (e) {
                var r = this._owner.transform.worldMatrix;
                e.bounds._tranform(r, this._bounds);
            }
            if (t.Render.supportWebGLPlusCulling) {
                var i = this._bounds.getMin(),
                    n = this._bounds.getMax(),
                    a = U._cullingBuffer;
                a[this._cullingBufferIndex + 1] = i.x, a[this._cullingBufferIndex + 2] = i.y, a[this._cullingBufferIndex + 3] = i.z,
                    a[this._cullingBufferIndex + 4] = n.x, a[this._cullingBufferIndex + 5] = n.y, a[this._cullingBufferIndex + 6] = n.z;
            }
        }
        _needRender(e, t) {
            if (e) {
                let t;
                return t = this.fastRender && this.tempBoundBox ? this.tempBoundBox : this.bounds._getBoundBox(),
                    e.intersects(t);
            }
            return !0;
        }
        _renderUpdate(e, t) {
            var r = e.renderElement;
            switch (r.renderType) {
                case le.RENDERTYPE_NORMAL:
                    this._shaderValues.setMatrix4x4(b.WORLDMATRIX, t.worldMatrix);
                    break;

                case le.RENDERTYPE_STATICBATCH:
                    this._oriDefineValue = this._shaderValues._defineDatas.value, t ? this._shaderValues.setMatrix4x4(b.WORLDMATRIX, t.worldMatrix) : this._shaderValues.setMatrix4x4(b.WORLDMATRIX, T.DEFAULT),
                        this._shaderValues.addDefine(Be.SHADERDEFINE_UV1), this._shaderValues.removeDefine(F.SHADERDEFINE_SCALEOFFSETLIGHTINGMAPUV);
                    break;

                case le.RENDERTYPE_VERTEXBATCH:
                    this._shaderValues.setMatrix4x4(b.WORLDMATRIX, T.DEFAULT);
                    break;

                case le.RENDERTYPE_INSTANCEBATCH:
                    for (var i = D.instance.instanceWorldMatrixData, n = r.instanceBatchElementList, a = n.elements, s = n.length, o = 0; o < s; o++) i.set(a[o]._transform.worldMatrix.elements, 16 * o);
                    D.instance.instanceWorldMatrixBuffer.setData(i.buffer, 0, 0, 16 * s * 4), this._shaderValues.addDefine(Be.SHADERDEFINE_GPU_INSTANCE);
            }
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix,
                i = e.renderElement;
            switch (i.renderType) {
                case le.RENDERTYPE_NORMAL:
                case le.RENDERTYPE_STATICBATCH:
                case le.RENDERTYPE_VERTEXBATCH:
                    t ? (T.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(b.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(b.MVPMATRIX, r);
                    break;

                case le.RENDERTYPE_INSTANCEBATCH:
                    for (var n = D.instance.instanceMVPMatrixData, a = i.instanceBatchElementList, s = a.elements, o = a.length, l = 0; l < o; l++) {
                        var _ = s[l]._transform.worldMatrix;
                        M.mulMatrixByArray(r.elements, 0, _.elements, 0, n, 16 * l);
                    }
                    D.instance.instanceMVPMatrixBuffer.setData(n.buffer, 0, 0, 16 * o * 4);
            }
        }
        _revertBatchRenderUpdate(e) {
            switch (e.renderElement.renderType) {
                case le.RENDERTYPE_STATICBATCH:
                    this._shaderValues._defineDatas.value = this._oriDefineValue;
                    break;

                case le.RENDERTYPE_INSTANCEBATCH:
                    this._shaderValues.removeDefine(Be.SHADERDEFINE_GPU_INSTANCE);
            }
        }
        _destroy() {
            this._isPartOfStaticBatch && ue.instance._destroyRenderSprite(this._owner), super._destroy();
        }
    }
    class Ye extends F {
        static __init__() {
            Ye.shaderDefines = new C(F.shaderDefines), Be.SHADERDEFINE_UV0 = Ye.shaderDefines.registerDefine("UV"),
                Be.SHADERDEFINE_COLOR = Ye.shaderDefines.registerDefine("COLOR"), Be.SHADERDEFINE_UV1 = Ye.shaderDefines.registerDefine("UV1"),
                Be.SHADERDEFINE_GPU_INSTANCE = Ye.shaderDefines.registerDefine("GPU_INSTANCE"),
                B._registerManager(ue.instance), l._registerManager(ce.instance);
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get meshRenderer() {
            return this._render;
        }
        constructor(e = null, t = null) {
            super(t), this._meshFilter = new Ue(this), this._render = new Xe(this), e && (this._meshFilter.sharedMesh = e);
        }
        _parse(e, r) {
            super._parse(e, r);
            var i = this.meshRenderer,
                a = e.lightmapIndex;
            null != a && (i.lightmapIndex = a);
            var s = e.lightmapScaleOffset;
            s && (i.lightmapScaleOffset = new n(s[0], s[1], s[2], s[3])), null != e.meshPath && (this.meshFilter.sharedMesh = t.Loader.getRes(e.meshPath)),
                null != e.enableRender && (this.meshRenderer.enable = e.enableRender);
            var o = e.materials;
            if (o) {
                var l = i.sharedMaterials,
                    _ = o.length;
                l.length = _;
                for (var h = 0; h < _; h++) l[h] = t.Loader.getRes(o[h].path);
                i.sharedMaterials = l;
            }
        }
        _addToInitStaticBatchManager() {
            this.meshFilter.sharedMesh && ue.instance._addBatchSprite(this);
        }
        _cloneTo(e, t, r) {
            var i = e;
            i._meshFilter.sharedMesh = this._meshFilter.sharedMesh;
            var n = this._render,
                a = i._render;
            a.enable = n.enable, a.sharedMaterials = n.sharedMaterials, a.castShadow = n.castShadow;
            var s = n.lightmapScaleOffset;
            s && (a.lightmapScaleOffset = s.clone()), a.lightmapIndex = n.lightmapIndex, a.receiveShadow = n.receiveShadow,
                a.sortingFudge = n.sortingFudge, super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._meshFilter.destroy());
        }
        _create() {
            return new Ye();
        }
    }
    class Ze {}
    Ze.Blend = 0, Ze.Fixed = 1;
    class je {
        constructor(e, t) {
            this._mode = 0, this._maxColorRGBKeysCount = 0, this._maxColorAlphaKeysCount = 0,
                this._colorRGBKeysCount = 0, this._colorAlphaKeysCount = 0, this._alphaElements = null,
                this._rgbElements = null, this._maxColorRGBKeysCount = e, this._maxColorAlphaKeysCount = t,
                this._rgbElements = new Float32Array(4 * e), this._alphaElements = new Float32Array(2 * t);
        }
        get mode() {
            return this._mode;
        }
        set mode(e) {
            this._mode = e;
        }
        get colorRGBKeysCount() {
            return this._colorRGBKeysCount;
        }
        get colorAlphaKeysCount() {
            return this._colorAlphaKeysCount;
        }
        get maxColorRGBKeysCount() {
            return this._maxColorRGBKeysCount;
        }
        get maxColorAlphaKeysCount() {
            return this._maxColorAlphaKeysCount;
        }
        addColorRGB(e, t) {
            if (this._colorRGBKeysCount < this._maxColorRGBKeysCount) {
                var r = 4 * this._colorRGBKeysCount;
                this._rgbElements[r] = e, this._rgbElements[r + 1] = t.r, this._rgbElements[r + 2] = t.g,
                    this._rgbElements[r + 3] = t.b, this._colorRGBKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorRGBKeysCount);
        }
        addColorAlpha(e, t) {
            if (this._colorAlphaKeysCount < this._maxColorAlphaKeysCount) {
                var r = 2 * this._colorAlphaKeysCount;
                this._alphaElements[r] = e, this._alphaElements[r + 1] = t, this._colorAlphaKeysCount++;
            } else console.warn("Gradient:warning:data count must lessEqual than " + this._maxColorAlphaKeysCount);
        }
        updateColorRGB(e, t, r) {
            if (e < this._colorRGBKeysCount) {
                var i = 4 * e;
                this._rgbElements[i] = t, this._rgbElements[i + 1] = r.r, this._rgbElements[i + 2] = r.g,
                    this._rgbElements[i + 3] = r.b;
            } else console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
        }
        updateColorAlpha(e, t, r) {
            if (e < this._colorAlphaKeysCount) {
                var i = 2 * e;
                this._alphaElements[i] = t, this._alphaElements[i + 1] = r;
            } else console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
        }
        evaluateColorRGB(e, t, r = 0, i = !1) {
            e = Math.min(Math.max(e, 0), 1);
            var n = this._rgbElements,
                a = r;
            if (i)
                for (var s = a; s >= 0; s--) {
                    var o = 4 * s;
                    if (e === (u = n[o])) return t.r = n[o + 1], t.g = n[o + 2], t.b = n[o + 3], a;
                    switch (this._mode) {
                        case Ze.Blend:
                            if (e > u) {
                                if (e > (d = n[o + 4])) throw "Gradient:wrong startSearchIndex.";
                                var l = d - u,
                                    _ = d - e,
                                    h = e - u;
                                return t.r = (_ * n[o + 1] + h * n[o + 5]) / l, t.g = (_ * n[o + 2] + h * n[o + 6]) / l,
                                    t.b = (_ * n[o + 3] + h * n[o + 7]) / l, a;
                            }
                            a--;
                            continue;

                        case Ze.Fixed:
                            if (e > u) {
                                if (e > n[o + 4]) throw "Gradient:wrong startSearchIndex.";
                                return t.r = n[o + 5], t.g = n[o + 6], t.b = n[o + 7], a;
                            }
                            a--;
                            continue;

                        default:
                            throw "Gradient:unknown mode.";
                    }
                } else {
                    s = 0;
                    for (var c = this._rgbElements.length; s < c; s++) {
                        var d;
                        if (e === (d = n[o = 4 * s])) return t.r = n[o + 1], t.g = n[o + 2], t.b = n[o + 3],
                            a;
                        switch (this._mode) {
                            case Ze.Blend:
                                if (e < d) {
                                    var u;
                                    if (e < (u = n[o - 4])) throw "Gradient:wrong startSearchIndex.";
                                    l = d - u, _ = d - e, h = e - u;
                                    return t.r = (_ * n[o - 3] + h * n[o + 1]) / l, t.g = (_ * n[o - 2] + h * n[o + 2]) / l,
                                        t.b = (_ * n[o - 1] + h * n[o + 3]) / l, a;
                                }
                                a++;
                                continue;

                            case Ze.Fixed:
                                if (e < d) {
                                    if (e < n[o - 4]) throw "Gradient:wrong startSearchIndex.";
                                    return t.r = n[o + 1], t.g = n[o + 2], t.b = n[o + 3], a;
                                }
                                a++;
                                continue;

                            default:
                                throw "Gradient:unknown mode.";
                        }
                    }
                }
            return a;
        }
        evaluateColorAlpha(e, t, r = 0, i = !1) {
            e = Math.min(Math.max(e, 0), 1);
            var n = this._alphaElements,
                a = r;
            if (i)
                for (var s = a; s >= 0; s--) {
                    if (e === (u = n[c = 2 * s])) return t.a = n[c + 1], a;
                    switch (this._mode) {
                        case Ze.Blend:
                            if (e > u) {
                                if (e > (d = n[c + 2])) throw "Gradient:wrong startSearchIndex.";
                                var o = d - u,
                                    l = d - e,
                                    _ = e - u;
                                return t.a = (l * n[c + 1] + _ * n[c + 3]) / o, a;
                            }
                            a--;
                            continue;

                        case Ze.Fixed:
                            if (e > u) {
                                if (e > n[c + 2]) throw "Gradient:wrong startSearchIndex.";
                                return t.a = n[c + 3], a;
                            }
                            a--;
                            continue;

                        default:
                            throw "Gradient:unknown mode.";
                    }
                } else {
                    s = a;
                    for (var h = this._alphaElements.length; s < h; s++) {
                        var c, d;
                        if (e === (d = n[c = 2 * s])) return t.a = n[c + 1], a;
                        switch (this._mode) {
                            case Ze.Blend:
                                if (e < d) {
                                    var u;
                                    if (e < (u = n[c - 2])) throw "Gradient:wrong startSearchIndex.";
                                    o = d - u, l = d - e, _ = e - u;
                                    return t.a = (l * n[c - 1] + _ * n[c + 1]) / o, a;
                                }
                                a++;
                                continue;

                            case Ze.Fixed:
                                if (e < d) {
                                    if (e < n[c - 2]) throw "Gradient:wrong startSearchIndex.";
                                    return t.a = n[c + 1], a;
                                }
                                a++;
                                continue;

                            default:
                                throw "Gradient:unknown mode.";
                        }
                    }
                }
            return a;
        }
        cloneTo(e) {
            var t, r, i = e;
            i._colorAlphaKeysCount = this._colorAlphaKeysCount;
            var n = i._alphaElements;
            for (t = 0, r = this._alphaElements.length; t < r; t++) n[t] = this._alphaElements[t];
            i._colorRGBKeysCount = this._colorRGBKeysCount;
            var a = i._rgbElements;
            for (t = 0, r = this._rgbElements.length; t < r; t++) a[t] = this._rgbElements[t];
        }
        clone() {
            var e = new je(this._maxColorRGBKeysCount, this._maxColorAlphaKeysCount);
            return this.cloneTo(e), e;
        }
    }
    class qe extends Ge {
        constructor() {
            super(), this.setShaderName("PARTICLESHURIKEN"), this._color = new n(1, 1, 1, 1),
                this.renderMode = qe.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            qe.shaderDefines = new C(Ge.shaderDefines), qe.SHADERDEFINE_DIFFUSEMAP = qe.shaderDefines.registerDefine("DIFFUSEMAP"),
                qe.SHADERDEFINE_TINTCOLOR = qe.shaderDefines.registerDefine("TINTCOLOR"), qe.SHADERDEFINE_ADDTIVEFOG = qe.shaderDefines.registerDefine("ADDTIVEFOG"),
                qe.SHADERDEFINE_TILINGOFFSET = qe.shaderDefines.registerDefine("TILINGOFFSET");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(qe.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(qe.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(qe.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(qe.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(qe.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(qe.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(qe.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(qe.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
                case qe.RENDERMODE_ADDTIVE:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = ze.CULL_NONE,
                        this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA, this.blendDst = ze.BLENDPARAM_ONE,
                        this.alphaTest = !1, this._shaderValues.addDefine(qe.SHADERDEFINE_ADDTIVEFOG);
                    break;

                case qe.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.depthWrite = !1, this.cull = ze.CULL_NONE,
                        this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA, this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                        this.alphaTest = !1, this._shaderValues.removeDefine(qe.SHADERDEFINE_ADDTIVEFOG);
                    break;

                default:
                    throw new Error("ShurikenParticleMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(qe.TINTCOLOR);
        }
        set color(e) {
            e ? this._shaderValues.addDefine(qe.SHADERDEFINE_TINTCOLOR) : this._shaderValues.removeDefine(qe.SHADERDEFINE_TINTCOLOR),
                this._shaderValues.setVector(qe.TINTCOLOR, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(qe.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(qe.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(qe.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(qe.TILINGOFFSET, e);
        }
        get texture() {
            return this._shaderValues.getTexture(qe.DIFFUSETEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(qe.SHADERDEFINE_DIFFUSEMAP) : this._shaderValues.removeDefine(qe.SHADERDEFINE_DIFFUSEMAP),
                this._shaderValues.setTexture(qe.DIFFUSETEXTURE, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(qe.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(qe.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(qe.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(qe.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(qe.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(qe.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(qe.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(qe.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(qe.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(qe.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(qe.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(qe.DEPTH_TEST);
        }
        clone() {
            var e = new qe();
            return this.cloneTo(e), e;
        }
    }
    qe.RENDERMODE_ALPHABLENDED = 0, qe.RENDERMODE_ADDTIVE = 1, qe.DIFFUSETEXTURE = L.propertyNameToID("u_texture"),
        qe.TINTCOLOR = L.propertyNameToID("u_Tintcolor"), qe.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"),
        qe.CULL = L.propertyNameToID("s_Cull"), qe.BLEND = L.propertyNameToID("s_Blend"),
        qe.BLEND_SRC = L.propertyNameToID("s_BlendSrc"), qe.BLEND_DST = L.propertyNameToID("s_BlendDst"),
        qe.DEPTH_TEST = L.propertyNameToID("s_DepthTest"), qe.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"),
        qe.shaderDefines = null;
    class Ke {}
    Ke.WORLDPOSITION = L.propertyNameToID("u_WorldPosition"), Ke.WORLDROTATION = L.propertyNameToID("u_WorldRotation"),
        Ke.POSITIONSCALE = L.propertyNameToID("u_PositionScale"), Ke.SIZESCALE = L.propertyNameToID("u_SizeScale"),
        Ke.SCALINGMODE = L.propertyNameToID("u_ScalingMode"), Ke.GRAVITY = L.propertyNameToID("u_Gravity"),
        Ke.THREEDSTARTROTATION = L.propertyNameToID("u_ThreeDStartRotation"), Ke.STRETCHEDBILLBOARDLENGTHSCALE = L.propertyNameToID("u_StretchedBillboardLengthScale"),
        Ke.STRETCHEDBILLBOARDSPEEDSCALE = L.propertyNameToID("u_StretchedBillboardSpeedScale"),
        Ke.SIMULATIONSPACE = L.propertyNameToID("u_SimulationSpace"), Ke.CURRENTTIME = L.propertyNameToID("u_CurrentTime"),
        Ke.VOLVELOCITYCONST = L.propertyNameToID("u_VOLVelocityConst"), Ke.VOLVELOCITYGRADIENTX = L.propertyNameToID("u_VOLVelocityGradientX"),
        Ke.VOLVELOCITYGRADIENTY = L.propertyNameToID("u_VOLVelocityGradientY"), Ke.VOLVELOCITYGRADIENTZ = L.propertyNameToID("u_VOLVelocityGradientZ"),
        Ke.VOLVELOCITYCONSTMAX = L.propertyNameToID("u_VOLVelocityConstMax"), Ke.VOLVELOCITYGRADIENTXMAX = L.propertyNameToID("u_VOLVelocityGradientMaxX"),
        Ke.VOLVELOCITYGRADIENTYMAX = L.propertyNameToID("u_VOLVelocityGradientMaxY"), Ke.VOLVELOCITYGRADIENTZMAX = L.propertyNameToID("u_VOLVelocityGradientMaxZ"),
        Ke.VOLSPACETYPE = L.propertyNameToID("u_VOLSpaceType"), Ke.COLOROVERLIFEGRADIENTALPHAS = L.propertyNameToID("u_ColorOverLifeGradientAlphas"),
        Ke.COLOROVERLIFEGRADIENTCOLORS = L.propertyNameToID("u_ColorOverLifeGradientColors"),
        Ke.MAXCOLOROVERLIFEGRADIENTALPHAS = L.propertyNameToID("u_MaxColorOverLifeGradientAlphas"),
        Ke.MAXCOLOROVERLIFEGRADIENTCOLORS = L.propertyNameToID("u_MaxColorOverLifeGradientColors"),
        Ke.SOLSIZEGRADIENT = L.propertyNameToID("u_SOLSizeGradient"), Ke.SOLSIZEGRADIENTX = L.propertyNameToID("u_SOLSizeGradientX"),
        Ke.SOLSIZEGRADIENTY = L.propertyNameToID("u_SOLSizeGradientY"), Ke.SOLSizeGradientZ = L.propertyNameToID("u_SOLSizeGradientZ"),
        Ke.SOLSizeGradientMax = L.propertyNameToID("u_SOLSizeGradientMax"), Ke.SOLSIZEGRADIENTXMAX = L.propertyNameToID("u_SOLSizeGradientMaxX"),
        Ke.SOLSIZEGRADIENTYMAX = L.propertyNameToID("u_SOLSizeGradientMaxY"), Ke.SOLSizeGradientZMAX = L.propertyNameToID("u_SOLSizeGradientMaxZ"),
        Ke.ROLANGULARVELOCITYCONST = L.propertyNameToID("u_ROLAngularVelocityConst"), Ke.ROLANGULARVELOCITYCONSTSEPRARATE = L.propertyNameToID("u_ROLAngularVelocityConstSeprarate"),
        Ke.ROLANGULARVELOCITYGRADIENT = L.propertyNameToID("u_ROLAngularVelocityGradient"),
        Ke.ROLANGULARVELOCITYGRADIENTX = L.propertyNameToID("u_ROLAngularVelocityGradientX"),
        Ke.ROLANGULARVELOCITYGRADIENTY = L.propertyNameToID("u_ROLAngularVelocityGradientY"),
        Ke.ROLANGULARVELOCITYGRADIENTZ = L.propertyNameToID("u_ROLAngularVelocityGradientZ"),
        Ke.ROLANGULARVELOCITYCONSTMAX = L.propertyNameToID("u_ROLAngularVelocityConstMax"),
        Ke.ROLANGULARVELOCITYCONSTMAXSEPRARATE = L.propertyNameToID("u_ROLAngularVelocityConstMaxSeprarate"),
        Ke.ROLANGULARVELOCITYGRADIENTMAX = L.propertyNameToID("u_ROLAngularVelocityGradientMax"),
        Ke.ROLANGULARVELOCITYGRADIENTXMAX = L.propertyNameToID("u_ROLAngularVelocityGradientMaxX"),
        Ke.ROLANGULARVELOCITYGRADIENTYMAX = L.propertyNameToID("u_ROLAngularVelocityGradientMaxY"),
        Ke.ROLANGULARVELOCITYGRADIENTZMAX = L.propertyNameToID("u_ROLAngularVelocityGradientMaxZ"),
        Ke.ROLANGULARVELOCITYGRADIENTWMAX = L.propertyNameToID("u_ROLAngularVelocityGradientMaxW"),
        Ke.TEXTURESHEETANIMATIONCYCLES = L.propertyNameToID("u_TSACycles"), Ke.TEXTURESHEETANIMATIONSUBUVLENGTH = L.propertyNameToID("u_TSASubUVLength"),
        Ke.TEXTURESHEETANIMATIONGRADIENTUVS = L.propertyNameToID("u_TSAGradientUVs"), Ke.TEXTURESHEETANIMATIONGRADIENTMAXUVS = L.propertyNameToID("u_TSAMaxGradientUVs");
    class Qe extends ke {
        constructor(e) {
            super(e), this._finalGravity = new a(), this._tempRotationMatrix = new T(), this._renderMode = 0,
                this._mesh = null, this.stretchedBillboardCameraSpeedScale = 0, this.stretchedBillboardSpeedScale = 0,
                this.stretchedBillboardLengthScale = 0, this._defaultBoundBox = new Oe(new a(), new a()),
                this._renderMode = -1, this.stretchedBillboardCameraSpeedScale = 0, this.stretchedBillboardSpeedScale = 0,
                this.stretchedBillboardLengthScale = 1, this._supportOctree = !1;
        }
        get renderMode() {
            return this._renderMode;
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(e) {
            this._mesh !== e && (this._mesh && this._mesh._removeReference(), this._mesh = e,
                e && e._addReference(), this._owner.particleSystem._initBufferDatas());
        }
        set renderMode(e) {
            if (this._renderMode !== e) {
                var t = this._shaderValues;
                switch (this._renderMode) {
                    case 0:
                        t.removeDefine(Ke.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;

                    case 1:
                        t.removeDefine(Ke.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;

                    case 2:
                        t.removeDefine(Ke.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;

                    case 3:
                        t.removeDefine(Ke.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;

                    case 4:
                        t.removeDefine(Ke.SHADERDEFINE_RENDERMODE_MESH);
                }
                switch (this._renderMode = e, e) {
                    case 0:
                        t.addDefine(Ke.SHADERDEFINE_RENDERMODE_BILLBOARD);
                        break;

                    case 1:
                        t.addDefine(Ke.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD);
                        break;

                    case 2:
                        t.addDefine(Ke.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD);
                        break;

                    case 3:
                        t.addDefine(Ke.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD);
                        break;

                    case 4:
                        t.addDefine(Ke.SHADERDEFINE_RENDERMODE_MESH);
                        break;

                    default:
                        throw new Error("ShurikenParticleRender: unknown renderMode Value.");
                }
                this._owner.particleSystem._initBufferDatas();
            }
        }
        _calculateBoundingBox() {
            if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE,
                e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (r = this._bounds.getMax()).x = Number.MAX_VALUE,
                r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, this._bounds.setMax(r), t.Render.supportWebGLPlusCulling) {
                var e = this._bounds.getMin(),
                    r = this._bounds.getMax(),
                    i = U._cullingBuffer;
                i[this._cullingBufferIndex + 1] = e.x, i[this._cullingBufferIndex + 2] = e.y, i[this._cullingBufferIndex + 3] = e.z,
                    i[this._cullingBufferIndex + 4] = r.x, i[this._cullingBufferIndex + 5] = r.y, i[this._cullingBufferIndex + 6] = r.z;
            }
        }
        _needRender(e, t) {
            return !e || !!e.intersects(this.bounds._getBoundBox()) && !!this._owner.particleSystem.isAlive;
        }
        _renderUpdate(e, t) {
            var r = this._owner.particleSystem,
                i = this._shaderValues,
                n = this._owner.transform;
            switch (r.simulationSpace) {
                case 0:
                    break;

                case 1:
                    i.setVector3(Ke.WORLDPOSITION, n.position), i.setQuaternion(Ke.WORLDROTATION, n.rotation);
                    break;

                default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
            switch (r.scaleMode) {
                case 0:
                    var s = n.getWorldLossyScale();
                    i.setVector3(Ke.POSITIONSCALE, s), i.setVector3(Ke.SIZESCALE, s);
                    break;

                case 1:
                    var o = n.localScale;
                    i.setVector3(Ke.POSITIONSCALE, o), i.setVector3(Ke.SIZESCALE, o);
                    break;

                case 2:
                    i.setVector3(Ke.POSITIONSCALE, n.getWorldLossyScale()), i.setVector3(Ke.SIZESCALE, a._ONE);
            }
            a.scale(Ee.gravity, r.gravityModifier, this._finalGravity), i.setVector3(Ke.GRAVITY, this._finalGravity),
                i.setInt(Ke.SIMULATIONSPACE, r.simulationSpace), i.setBool(Ke.THREEDSTARTROTATION, r.threeDStartRotation),
                i.setInt(Ke.SCALINGMODE, r.scaleMode), i.setNumber(Ke.STRETCHEDBILLBOARDLENGTHSCALE, this.stretchedBillboardLengthScale),
                i.setNumber(Ke.STRETCHEDBILLBOARDSPEEDSCALE, this.stretchedBillboardSpeedScale),
                i.setNumber(Ke.CURRENTTIME, r._currentTime);
        }
        get bounds() {
            return this._boundsChange && (this._calculateBoundingBox(), this._boundsChange = !1),
                this._bounds;
        }
        _destroy() {
            super._destroy(), this._mesh && (this._mesh._removeReference(), this._mesh = null);
        }
    }
    class Je {
        constructor() {}
        static _getStartLifetimeFromGradient(e, r) {
            for (var i = 1, n = e.gradientCount; i < n; i++) {
                var a = e.getKeyByIndex(i);
                if (a >= r) {
                    var s = e.getKeyByIndex(i - 1),
                        o = (r - s) / (a - s);
                    return t.MathUtil.lerp(e.getValueByIndex(i - 1), e.getValueByIndex(i), o);
                }
            }
            throw new Error("ShurikenParticleData: can't get value foam startLifeTimeGradient.");
        }
        static _randomInvertRoationArray(e, t, r, i, n) {
            var a;
            i ? (i.seed = n[6], a = i.getFloat(), n[6] = i.seed) : a = Math.random(), a < r ? (t.x = -e.x,
                t.y = -e.y, t.z = -e.z) : (t.x = e.x, t.y = e.y, t.z = e.z);
        }
        static _randomInvertRoation(e, t, r, i) {
            var n;
            return r ? (r.seed = i[6], n = r.getFloat(), i[6] = r.seed) : n = Math.random(),
                n < t && (e = -e), e;
        }
        static create(e, r, i) {
            var a = e.autoRandomSeed,
                s = e._rand,
                o = e._randomSeeds;
            switch (e.startColorType) {
                case 0:
                    var l = e.startColorConstant;
                    Je.startColor.x = l.x, Je.startColor.y = l.y, Je.startColor.z = l.z, Je.startColor.w = l.w;
                    break;

                case 2:
                    a ? n.lerp(e.startColorConstantMin, e.startColorConstantMax, Math.random(), Je.startColor) : (s.seed = o[3],
                        n.lerp(e.startColorConstantMin, e.startColorConstantMax, s.getFloat(), Je.startColor),
                        o[3] = s.seed);
            }
            var _ = e.colorOverLifetime;
            if (_ && _.enbale) {
                var h = _.color;
                switch (h.type) {
                    case 0:
                        Je.startColor.x = Je.startColor.x * h.constant.x, Je.startColor.y = Je.startColor.y * h.constant.y,
                            Je.startColor.z = Je.startColor.z * h.constant.z, Je.startColor.w = Je.startColor.w * h.constant.w;
                        break;

                    case 2:
                        var c;
                        a ? c = Math.random() : (s.seed = o[10], c = s.getFloat(), o[10] = s.seed);
                        var d = h.constantMin,
                            u = h.constantMax;
                        Je.startColor.x = Je.startColor.x * t.MathUtil.lerp(d.x, u.x, c), Je.startColor.y = Je.startColor.y * t.MathUtil.lerp(d.y, u.y, c),
                            Je.startColor.z = Je.startColor.z * t.MathUtil.lerp(d.z, u.z, c), Je.startColor.w = Je.startColor.w * t.MathUtil.lerp(d.w, u.w, c);
                }
            }
            var f = Je.startSize;
            switch (e.startSizeType) {
                case 0:
                    if (e.threeDStartSize) {
                        var E = e.startSizeConstantSeparate;
                        f[0] = E.x, f[1] = E.y, f[2] = E.z;
                    } else f[0] = f[1] = f[2] = e.startSizeConstant;
                    break;

                case 2:
                    if (e.threeDStartSize) {
                        var T = e.startSizeConstantMinSeparate,
                            m = e.startSizeConstantMaxSeparate;
                        a ? (f[0] = t.MathUtil.lerp(T.x, m.x, Math.random()), f[1] = t.MathUtil.lerp(T.y, m.y, Math.random()),
                            f[2] = t.MathUtil.lerp(T.z, m.z, Math.random())) : (s.seed = o[4], f[0] = t.MathUtil.lerp(T.x, m.x, s.getFloat()),
                            f[1] = t.MathUtil.lerp(T.y, m.y, s.getFloat()), f[2] = t.MathUtil.lerp(T.z, m.z, s.getFloat()),
                            o[4] = s.seed);
                    } else a ? f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, Math.random()) : (s.seed = o[4],
                        f[0] = f[1] = f[2] = t.MathUtil.lerp(e.startSizeConstantMin, e.startSizeConstantMax, s.getFloat()),
                        o[4] = s.seed);
            }
            var p = e.sizeOverLifetime;
            if (p && p.enbale && 1 === p.size.type) {
                var g, S = p.size;
                if (S.separateAxes) a ? (f[0] = f[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, Math.random()),
                    f[1] = f[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, Math.random()),
                    f[2] = f[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, Math.random())) : (s.seed = o[11],
                    f[0] = f[0] * t.MathUtil.lerp(S.constantMinSeparate.x, S.constantMaxSeparate.x, s.getFloat()),
                    f[1] = f[1] * t.MathUtil.lerp(S.constantMinSeparate.y, S.constantMaxSeparate.y, s.getFloat()),
                    f[2] = f[2] * t.MathUtil.lerp(S.constantMinSeparate.z, S.constantMaxSeparate.z, s.getFloat()),
                    o[11] = s.seed);
                else a ? g = t.MathUtil.lerp(S.constantMin, S.constantMax, Math.random()) : (s.seed = o[11],
                        g = t.MathUtil.lerp(S.constantMin, S.constantMax, s.getFloat()), o[11] = s.seed),
                    f[0] = f[0] * g, f[1] = f[1] * g, f[2] = f[2] * g;
            }
            var v = r.renderMode;
            if (1 !== v) switch (e.startRotationType) {
                case 0:
                    if (e.threeDStartRotation) {
                        var R = e.startRotationConstantSeparate,
                            A = Je._tempVector30;
                        Je._randomInvertRoationArray(R, A, e.randomizeRotationDirection, a ? null : s, o),
                            Je.startRotation[0] = A.x, Je.startRotation[1] = A.y, Je.startRotation[2] = 4 !== v ? -A.z : A.z;
                    } else Je.startRotation[0] = Je._randomInvertRoation(e.startRotationConstant, e.randomizeRotationDirection, a ? null : s, o),
                        Je.startRotation[1] = 0, Je.startRotation[2] = 0;
                    break;

                case 2:
                    if (e.threeDStartRotation) {
                        var D = e.startRotationConstantMinSeparate,
                            I = e.startRotationConstantMaxSeparate,
                            x = Je._tempVector30;
                        a ? (x.x = t.MathUtil.lerp(D.x, I.x, Math.random()), x.y = t.MathUtil.lerp(D.y, I.y, Math.random()),
                                x.z = t.MathUtil.lerp(D.z, I.z, Math.random())) : (s.seed = o[5], x.x = t.MathUtil.lerp(D.x, I.x, s.getFloat()),
                                x.y = t.MathUtil.lerp(D.y, I.y, s.getFloat()), x.z = t.MathUtil.lerp(D.z, I.z, s.getFloat()),
                                o[5] = s.seed), Je._randomInvertRoationArray(x, x, e.randomizeRotationDirection, a ? null : s, o),
                            Je.startRotation[0] = x.x, Je.startRotation[1] = x.y, Je.startRotation[2] = 4 !== v ? -x.z : x.z;
                    } else a ? Je.startRotation[0] = Je._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, Math.random()), e.randomizeRotationDirection, a ? null : s, o) : (s.seed = o[5],
                        Je.startRotation[0] = Je._randomInvertRoation(t.MathUtil.lerp(e.startRotationConstantMin, e.startRotationConstantMax, s.getFloat()), e.randomizeRotationDirection, a ? null : s, o),
                        o[5] = s.seed);
            }
            switch (e.startLifetimeType) {
                case 0:
                    Je.startLifeTime = e.startLifetimeConstant;
                    break;

                case 1:
                    Je.startLifeTime = Je._getStartLifetimeFromGradient(e.startLifeTimeGradient, e.emissionTime);
                    break;

                case 2:
                    a ? Je.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, Math.random()) : (s.seed = o[7],
                        Je.startLifeTime = t.MathUtil.lerp(e.startLifetimeConstantMin, e.startLifetimeConstantMax, s.getFloat()),
                        o[7] = s.seed);
                    break;

                case 3:
                    var M = e.emissionTime;
                    a ? Je.startLifeTime = t.MathUtil.lerp(Je._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, M), Je._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, M), Math.random()) : (s.seed = o[7],
                        Je.startLifeTime = t.MathUtil.lerp(Je._getStartLifetimeFromGradient(e.startLifeTimeGradientMin, M), Je._getStartLifetimeFromGradient(e.startLifeTimeGradientMax, M), s.getFloat()),
                        o[7] = s.seed);
            }
            switch (e.startSpeedType) {
                case 0:
                    Je.startSpeed = e.startSpeedConstant;
                    break;

                case 2:
                    a ? Je.startSpeed = t.MathUtil.lerp(e.startSpeedConstantMin, e.startSpeedConstantMax, Math.random()) : (s.seed = o[8],
                        Je.startSpeed = t.MathUtil.lerp(e.startSpeedConstantMin, e.startSpeedConstantMax, s.getFloat()),
                        o[8] = s.seed);
            }
            var L = e.textureSheetAnimation;
            if (L && L.enable) {
                var C, y = L.tiles,
                    O = y.x,
                    N = y.y,
                    P = 1 / O,
                    V = 1 / N,
                    w = L.startFrame;
                switch (w.type) {
                    case 0:
                        C = w.constant;
                        break;

                    case 1:
                        a ? C = t.MathUtil.lerp(w.constantMin, w.constantMax, Math.random()) : (s.seed = o[14],
                            C = t.MathUtil.lerp(w.constantMin, w.constantMax, s.getFloat()), o[14] = s.seed);
                }
                var b = L.frame;
                switch (b.type) {
                    case 0:
                        C += b.constant;
                        break;

                    case 2:
                        a ? C += t.MathUtil.lerp(b.constantMin, b.constantMax, Math.random()) : (s.seed = o[15],
                            C += t.MathUtil.lerp(b.constantMin, b.constantMax, s.getFloat()), o[15] = s.seed);
                }
                var F = 0;
                switch (L.type) {
                    case 0:
                        F = Math.floor(C / O);
                        break;

                    case 1:
                        L.randomRow ? a ? F = Math.floor(Math.random() * N) : (s.seed = o[13], F = Math.floor(s.getFloat() * N),
                            o[13] = s.seed) : F = L.rowIndex;
                }
                var B = Math.floor(C % O);
                Je.startUVInfo = Je.startUVInfo, Je.startUVInfo[0] = P, Je.startUVInfo[1] = V, Je.startUVInfo[2] = B * P,
                    Je.startUVInfo[3] = F * V;
            } else Je.startUVInfo = Je.startUVInfo, Je.startUVInfo[0] = 1, Je.startUVInfo[1] = 1,
                Je.startUVInfo[2] = 0, Je.startUVInfo[3] = 0;
            switch (e.simulationSpace) {
                case 0:
                    var U = i.position;
                    Je.simulationWorldPostion[0] = U.x, Je.simulationWorldPostion[1] = U.y, Je.simulationWorldPostion[2] = U.z;
                    var G = i.rotation;
                    Je.simulationWorldRotation[0] = G.x, Je.simulationWorldRotation[1] = G.y, Je.simulationWorldRotation[2] = G.z,
                        Je.simulationWorldRotation[3] = G.w;
                    break;

                case 1:
                    break;

                default:
                    throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
            }
        }
    }
    Je._tempVector30 = new a(), Je._tempQuaternion = new E(), Je.startColor = new n(),
        Je.startSize = new Float32Array(3), Je.startRotation = new Float32Array(3), Je.startUVInfo = new Float32Array(4),
        Je.simulationWorldPostion = new Float32Array(3), Je.simulationWorldRotation = new Float32Array(4);
    class $e {
        set emissionRate(e) {
            if (e < 0) throw new Error("ParticleBaseShape:emissionRate value must large or equal than 0.");
            this._emissionRate = e;
        }
        get emissionRate() {
            return this._emissionRate;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor() {
            this._destroyed = !1, this.emissionRate = 10, this._bursts = [];
        }
        destroy() {
            this._bursts = null, this._destroyed = !0;
        }
        getBurstsCount() {
            return this._bursts.length;
        }
        getBurstByIndex(e) {
            return this._bursts[e];
        }
        addBurst(e) {
            var t = this._bursts.length;
            if (t > 0)
                for (var r = 0; r < t; r++) this._bursts[r].time > e.time && this._bursts.splice(r, 0, e);
            this._bursts.push(e);
        }
        removeBurst(e) {
            var t = this._bursts.indexOf(e); -
            1 !== t && this._bursts.splice(t, 1);
        }
        removeBurstByIndex(e) {
            this._bursts.splice(e, 1);
        }
        clearBurst() {
            this._bursts.length = 0;
        }
        cloneTo(e) {
            var t = e,
                r = t._bursts;
            r.length = this._bursts.length;
            for (var i = 0, n = this._bursts.length; i < n; i++) {
                var a = r[i];
                a ? this._bursts[i].cloneTo(a) : r[i] = this._bursts[i].clone();
            }
            t._emissionRate = this._emissionRate, t.enbale = this.enbale;
        }
        clone() {
            var e = new $e();
            return this.cloneTo(e), e;
        }
    }
    class et {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataNumber warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("GradientDataNumber warning:data count must lessEqual than 4");
        }
        getKeyByIndex(e) {
            return this._elements[2 * e];
        }
        getValueByIndex(e) {
            return this._elements[2 * e + 1];
        }
        getAverageValue() {
            for (var e = 0, t = this._currentLength - 2; e < t; e += 2) {
                this._elements[e + 1];
                this._elements[e + 3], this._elements[e + 2] - this._elements[e];
            }
            return 0;
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, n = this._elements.length; i < n; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new et();
            return this.cloneTo(e), e;
        }
    }
    class tt {
        constructor() {}
    }
    tt.PARTICLE_CORNERTEXTURECOORDINATE0 = 0, tt.PARTICLE_POSITION0 = 1, tt.PARTICLE_COLOR0 = 2,
        tt.PARTICLE_TEXTURECOORDINATE0 = 3, tt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME = 4,
        tt.PARTICLE_DIRECTIONTIME = 5, tt.PARTICLE_STARTCOLOR0 = 6, tt.PARTICLE_ENDCOLOR0 = 7,
        tt.PARTICLE_STARTSIZE = 8, tt.PARTICLE_STARTROTATION = 9, tt.PARTICLE_STARTSPEED = 10,
        tt.PARTICLE_RANDOM0 = 11, tt.PARTICLE_RANDOM1 = 12, tt.PARTICLE_SIMULATIONWORLDPOSTION = 13,
        tt.PARTICLE_SIMULATIONWORLDROTATION = 14;
    class rt extends tt {
        static get vertexDeclaration() {
            return rt._vertexDeclaration;
        }
        static __init__() {
            rt._vertexDeclaration = new g(152, [new S(0, u.Vector4, tt.PARTICLE_CORNERTEXTURECOORDINATE0), new S(16, u.Vector4, tt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new S(32, u.Vector4, tt.PARTICLE_DIRECTIONTIME), new S(48, u.Vector4, tt.PARTICLE_STARTCOLOR0), new S(64, u.Vector3, tt.PARTICLE_STARTSIZE), new S(76, u.Vector3, tt.PARTICLE_STARTROTATION), new S(88, u.Single, tt.PARTICLE_STARTSPEED), new S(92, u.Vector4, tt.PARTICLE_RANDOM0), new S(108, u.Vector4, tt.PARTICLE_RANDOM1), new S(124, u.Vector3, tt.PARTICLE_SIMULATIONWORLDPOSTION), new S(136, u.Vector4, tt.PARTICLE_SIMULATIONWORLDROTATION)]);
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get positionStartLifeTime() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
        constructor(e, t, r, i, n, a, s, o, l, _, h, c, d, u) {
            super(), this._cornerTextureCoordinate = e, this._positionStartLifeTime = t, this._velocity = r,
                this._startColor = i, this._startSize = n, this._startRotation0 = a, this._startRotation1 = s,
                this._startRotation2 = o, this._startLifeTime = l, this._time = _, this._startSpeed = h,
                this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = u;
        }
    }
    class it extends tt {
        static __init__() {
            it._vertexDeclaration = new g(172, [new S(0, u.Vector3, tt.PARTICLE_POSITION0), new S(12, u.Vector4, tt.PARTICLE_COLOR0), new S(28, u.Vector2, tt.PARTICLE_TEXTURECOORDINATE0), new S(36, u.Vector4, tt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME), new S(52, u.Vector4, tt.PARTICLE_DIRECTIONTIME), new S(68, u.Vector4, tt.PARTICLE_STARTCOLOR0), new S(84, u.Vector3, tt.PARTICLE_STARTSIZE), new S(96, u.Vector3, tt.PARTICLE_STARTROTATION), new S(108, u.Single, tt.PARTICLE_STARTSPEED), new S(112, u.Vector4, tt.PARTICLE_RANDOM0), new S(128, u.Vector4, tt.PARTICLE_RANDOM1), new S(144, u.Vector3, tt.PARTICLE_SIMULATIONWORLDPOSTION), new S(156, u.Vector4, tt.PARTICLE_SIMULATIONWORLDROTATION)]);
        }
        static get vertexDeclaration() {
            return it._vertexDeclaration;
        }
        get cornerTextureCoordinate() {
            return this._cornerTextureCoordinate;
        }
        get position() {
            return this._positionStartLifeTime;
        }
        get velocity() {
            return this._velocity;
        }
        get startColor() {
            return this._startColor;
        }
        get startSize() {
            return this._startSize;
        }
        get startRotation0() {
            return this._startRotation0;
        }
        get startRotation1() {
            return this._startRotation1;
        }
        get startRotation2() {
            return this._startRotation2;
        }
        get startLifeTime() {
            return this._startLifeTime;
        }
        get time() {
            return this._time;
        }
        get startSpeed() {
            return this._startSpeed;
        }
        get random0() {
            return this._randoms0;
        }
        get random1() {
            return this._randoms1;
        }
        get simulationWorldPostion() {
            return this._simulationWorldPostion;
        }
        constructor(e, t, r, i, n, a, s, o, l, _, h, c, d, u) {
            super(), this._cornerTextureCoordinate = e, this._positionStartLifeTime = t, this._velocity = r,
                this._startColor = i, this._startSize = n, this._startRotation0 = a, this._startRotation1 = s,
                this._startRotation2 = o, this._startLifeTime = l, this._time = _, this._startSpeed = h,
                this._randoms0 = this.random0, this._randoms1 = this.random1, this._simulationWorldPostion = u;
        }
    }
    class nt {
        constructor(e) {
            this._temp = new Uint32Array(1), this.seeds = new Uint32Array(4), this.seeds[0] = e,
                this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        static getFloatFromInt(e) {
            return 1 / 8388607 * (8388607 & e);
        }
        static getByteFromInt(e) {
            return (8388607 & e) >>> 15;
        }
        get seed() {
            return this.seeds[0];
        }
        set seed(e) {
            this.seeds[0] = e, this.seeds[1] = 1812433253 * this.seeds[0] + 1, this.seeds[2] = 1812433253 * this.seeds[1] + 1,
                this.seeds[3] = 1812433253 * this.seeds[2] + 1;
        }
        getUint() {
            return this._temp[0] = this.seeds[0] ^ this.seeds[0] << 11, this.seeds[0] = this.seeds[1],
                this.seeds[1] = this.seeds[2], this.seeds[2] = this.seeds[3], this.seeds[3] = this.seeds[3] ^ this.seeds[3] >>> 19 ^ this._temp[0] ^ this._temp[0] >>> 8,
                this.seeds[3];
        }
        getFloat() {
            return this.getUint(), (8388607 & this.seeds[3]) * (1 / 8388607);
        }
        getSignedFloat() {
            return 2 * this.getFloat() - 1;
        }
    }
    class at extends h {
        constructor(e) {
            super(), this._tempRotationMatrix = new T(), this._boundingSphere = null, this._boundingBox = null,
                this._boundingBoxCorners = null, this._owner = null, this._ownerRender = null, this._vertices = null,
                this._floatCountPerVertex = 0, this._startLifeTimeIndex = 0, this._timeIndex = 0,
                this._simulateUpdate = !1, this._firstActiveElement = 0, this._firstNewElement = 0,
                this._firstFreeElement = 0, this._firstRetiredElement = 0, this._drawCounter = 0,
                this._bufferMaxParticles = 0, this._emission = null, this._shape = null, this._isEmitting = !1,
                this._isPlaying = !1, this._isPaused = !1, this._playStartDelay = 0, this._frameRateTime = 0,
                this._emissionTime = 0, this._totalDelayTime = 0, this._burstsIndex = 0, this._velocityOverLifetime = null,
                this._colorOverLifetime = null, this._sizeOverLifetime = null, this._rotationOverLifetime = null,
                this._textureSheetAnimation = null, this._startLifetimeType = 0, this._startLifetimeConstant = 0,
                this._startLifeTimeGradient = null, this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 0,
                this._startLifeTimeGradientMin = null, this._startLifeTimeGradientMax = null, this._maxStartLifetime = 0,
                this._uvLength = new i(), this._vertexStride = 0, this._indexStride = 0, this._vertexBuffer = null,
                this._indexBuffer = null, this._bufferState = new _(), this._currentTime = 0, this._startUpdateLoopCount = 0,
                this._rand = null, this._randomSeeds = null, this.duration = 0, this.looping = !1,
                this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0,
                this.startDelayMax = 0, this.startSpeedType = 0, this.startSpeedConstant = 0, this.startSpeedConstantMin = 0,
                this.startSpeedConstantMax = 0, this.threeDStartSize = !1, this.startSizeType = 0,
                this.startSizeConstant = 0, this.startSizeConstantSeparate = null, this.startSizeConstantMin = 0,
                this.startSizeConstantMax = 0, this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null,
                this.threeDStartRotation = !1, this.startRotationType = 0, this.startRotationConstant = 0,
                this.startRotationConstantSeparate = null, this.startRotationConstantMin = 0, this.startRotationConstantMax = 0,
                this.startRotationConstantMinSeparate = null, this.startRotationConstantMaxSeparate = null,
                this.randomizeRotationDirection = 0, this.startColorType = 0, this.startColorConstant = null,
                this.startColorConstantMin = null, this.startColorConstantMax = null, this.gravityModifier = 0,
                this.simulationSpace = 0, this.scaleMode = 0, this.playOnAwake = !1, this.randomSeed = null,
                this.autoRandomSeed = !1, this.isPerformanceMode = !1, this._firstActiveElement = 0,
                this._firstNewElement = 0, this._firstFreeElement = 0, this._firstRetiredElement = 0,
                this._owner = e, this._ownerRender = e.particleRenderer, this._boundingBoxCorners = [],
                this._boundingSphere = new Ne(new a(), Number.MAX_VALUE), this._boundingBox = new Oe(new a(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), new a(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)),
                this._currentTime = 0, this._isEmitting = !1, this._isPlaying = !1, this._isPaused = !1,
                this._burstsIndex = 0, this._frameRateTime = 0, this._emissionTime = 0, this._totalDelayTime = 0,
                this._simulateUpdate = !1, this._bufferMaxParticles = 1, this.duration = 5, this.looping = !0,
                this.prewarm = !1, this.startDelayType = 0, this.startDelay = 0, this.startDelayMin = 0,
                this.startDelayMax = 0, this._startLifetimeType = 0, this._startLifetimeConstant = 5,
                this._startLifeTimeGradient = new et(), this._startLifetimeConstantMin = 0, this._startLifetimeConstantMax = 5,
                this._startLifeTimeGradientMin = new et(), this._startLifeTimeGradientMax = new et(),
                this._maxStartLifetime = 5, this.startSpeedType = 0, this.startSpeedConstant = 5,
                this.startSpeedConstantMin = 0, this.startSpeedConstantMax = 5, this.threeDStartSize = !1,
                this.startSizeType = 0, this.startSizeConstant = 1, this.startSizeConstantSeparate = new a(1, 1, 1),
                this.startSizeConstantMin = 0, this.startSizeConstantMax = 1, this.startSizeConstantMinSeparate = new a(0, 0, 0),
                this.startSizeConstantMaxSeparate = new a(1, 1, 1), this.threeDStartRotation = !1,
                this.startRotationType = 0, this.startRotationConstant = 0, this.startRotationConstantSeparate = new a(0, 0, 0),
                this.startRotationConstantMin = 0, this.startRotationConstantMax = 0, this.startRotationConstantMinSeparate = new a(0, 0, 0),
                this.startRotationConstantMaxSeparate = new a(0, 0, 0), this.randomizeRotationDirection = 0,
                this.startColorType = 0, this.startColorConstant = new n(1, 1, 1, 1), this.startColorConstantMin = new n(1, 1, 1, 1),
                this.startColorConstantMax = new n(1, 1, 1, 1), this.gravityModifier = 0, this.simulationSpace = 1,
                this.scaleMode = 0, this.playOnAwake = !0, this._rand = new nt(0), this.autoRandomSeed = !0,
                this.randomSeed = new Uint32Array(1), this._randomSeeds = new Uint32Array(at._RANDOMOFFSET.length),
                this.isPerformanceMode = !0, this._emission = new $e(), this._emission.enbale = !0;
        }
        get maxParticles() {
            return this._bufferMaxParticles - 1;
        }
        set maxParticles(e) {
            var t = e + 1;
            t !== this._bufferMaxParticles && (this._bufferMaxParticles = t, this._initBufferDatas());
        }
        get emission() {
            return this._emission;
        }
        get aliveParticleCount() {
            return this._firstNewElement >= this._firstRetiredElement ? this._firstNewElement - this._firstRetiredElement : this._bufferMaxParticles - this._firstRetiredElement + this._firstNewElement;
        }
        get emissionTime() {
            return this._emissionTime > this.duration ? this.duration : this._emissionTime;
        }
        get shape() {
            return this._shape;
        }
        set shape(e) {
            this._shape !== e && (e && e.enable ? this._owner._render._shaderValues.addDefine(Ke.SHADERDEFINE_SHAPE) : this._owner._render._shaderValues.removeDefine(Ke.SHADERDEFINE_SHAPE),
                this._shape = e);
        }
        get isAlive() {
            return !!(this._isPlaying || this.aliveParticleCount > 0);
        }
        get isEmitting() {
            return this._isEmitting;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        get isPaused() {
            return this._isPaused;
        }
        get startLifetimeType() {
            return this._startLifetimeType;
        }
        set startLifetimeType(e) {
            var t, r;
            switch (this.startLifetimeType) {
                case 0:
                    this._maxStartLifetime = this.startLifetimeConstant;
                    break;

                case 1:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var i = i;
                    for (t = 0, r = i.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, i.getValueByIndex(t));
                    break;

                case 2:
                    this._maxStartLifetime = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;

                case 3:
                    this._maxStartLifetime = -Number.MAX_VALUE;
                    var n = n;
                    for (t = 0, r = n.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, n.getValueByIndex(t));
                    var a = a;
                    for (t = 0, r = a.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, a.getValueByIndex(t));
            }
            this._startLifetimeType = e;
        }
        get startLifetimeConstant() {
            return this._startLifetimeConstant;
        }
        set startLifetimeConstant(e) {
            0 === this._startLifetimeType && (this._maxStartLifetime = e), this._startLifetimeConstant = e;
        }
        get startLifeTimeGradient() {
            return this._startLifeTimeGradient;
        }
        set startLifeTimeGradient(e) {
            if (1 === this._startLifetimeType) {
                this._maxStartLifetime = -Number.MAX_VALUE;
                for (var t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradient = e;
        }
        get startLifetimeConstantMin() {
            return this._startLifetimeConstantMin;
        }
        set startLifetimeConstantMin(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(e, this._startLifetimeConstantMax)),
                this._startLifetimeConstantMin = e;
        }
        get startLifetimeConstantMax() {
            return this._startLifetimeConstantMax;
        }
        set startLifetimeConstantMax(e) {
            2 === this._startLifetimeType && (this._maxStartLifetime = Math.max(this._startLifetimeConstantMin, e)),
                this._startLifetimeConstantMax = e;
        }
        get startLifeTimeGradientMin() {
            return this._startLifeTimeGradientMin;
        }
        set startLifeTimeGradientMin(e) {
            if (3 === this._startLifetimeType) {
                var t, r;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
                for (t = 0, r = this._startLifeTimeGradientMax.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMax.getValueByIndex(t));
            }
            this._startLifeTimeGradientMin = e;
        }
        get startLifeTimeGradientMax() {
            return this._startLifeTimeGradientMax;
        }
        set startLifeTimeGradientMax(e) {
            if (3 === this._startLifetimeType) {
                var t, r;
                for (this._maxStartLifetime = -Number.MAX_VALUE, t = 0, r = this._startLifeTimeGradientMin.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, this._startLifeTimeGradientMin.getValueByIndex(t));
                for (t = 0, r = e.gradientCount; t < r; t++) this._maxStartLifetime = Math.max(this._maxStartLifetime, e.getValueByIndex(t));
            }
            this._startLifeTimeGradientMax = e;
        }
        get velocityOverLifetime() {
            return this._velocityOverLifetime;
        }
        set velocityOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.velocity,
                    i = r.type;
                if (e.enbale) switch (i) {
                    case 0:
                        t.addDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT);
                        break;

                    case 1:
                        t.addDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE);
                        break;

                    case 2:
                        t.addDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT);
                        break;

                    case 3:
                        t.addDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                } else t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                    t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE);
                switch (i) {
                    case 0:
                        t.setVector3(Ke.VOLVELOCITYCONST, r.constant);
                        break;

                    case 1:
                        t.setBuffer(Ke.VOLVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Ke.VOLVELOCITYGRADIENTY, r.gradientY._elements),
                            t.setBuffer(Ke.VOLVELOCITYGRADIENTZ, r.gradientZ._elements);
                        break;

                    case 2:
                        t.setVector3(Ke.VOLVELOCITYCONST, r.constantMin), t.setVector3(Ke.VOLVELOCITYCONSTMAX, r.constantMax);
                        break;

                    case 3:
                        t.setBuffer(Ke.VOLVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Ke.VOLVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                            t.setBuffer(Ke.VOLVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Ke.VOLVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                            t.setBuffer(Ke.VOLVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Ke.VOLVELOCITYGRADIENTZMAX, r.gradientZMax._elements);
                }
                t.setInt(Ke.VOLSPACETYPE, e.space);
            } else t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT), t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE),
                t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT), t.removeDefine(Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE),
                t.setVector(Ke.VOLVELOCITYCONST, null), t.setBuffer(Ke.VOLVELOCITYGRADIENTX, null),
                t.setBuffer(Ke.VOLVELOCITYGRADIENTY, null), t.setBuffer(Ke.VOLVELOCITYGRADIENTZ, null),
                t.setVector(Ke.VOLVELOCITYCONST, null), t.setVector(Ke.VOLVELOCITYCONSTMAX, null),
                t.setBuffer(Ke.VOLVELOCITYGRADIENTX, null), t.setBuffer(Ke.VOLVELOCITYGRADIENTXMAX, null),
                t.setBuffer(Ke.VOLVELOCITYGRADIENTY, null), t.setBuffer(Ke.VOLVELOCITYGRADIENTYMAX, null),
                t.setBuffer(Ke.VOLVELOCITYGRADIENTZ, null), t.setBuffer(Ke.VOLVELOCITYGRADIENTZMAX, null),
                t.setInt(Ke.VOLSPACETYPE, void 0);
            this._velocityOverLifetime = e;
        }
        get colorOverLifetime() {
            return this._colorOverLifetime;
        }
        set colorOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.color;
                if (e.enbale) switch (r.type) {
                    case 1:
                        t.addDefine(Ke.SHADERDEFINE_COLOROVERLIFETIME);
                        break;

                    case 3:
                        t.addDefine(Ke.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                } else t.removeDefine(Ke.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Ke.SHADERDEFINE_RANDOMCOLOROVERLIFETIME);
                switch (r.type) {
                    case 1:
                        var i = r.gradient;
                        t.setBuffer(Ke.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Ke.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements);
                        break;

                    case 3:
                        var n = r.gradientMin,
                            a = r.gradientMax;
                        t.setBuffer(Ke.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Ke.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements),
                            t.setBuffer(Ke.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Ke.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
                }
            } else t.removeDefine(Ke.SHADERDEFINE_COLOROVERLIFETIME), t.removeDefine(Ke.SHADERDEFINE_RANDOMCOLOROVERLIFETIME),
                t.setBuffer(Ke.COLOROVERLIFEGRADIENTALPHAS, i._alphaElements), t.setBuffer(Ke.COLOROVERLIFEGRADIENTCOLORS, i._rgbElements),
                t.setBuffer(Ke.COLOROVERLIFEGRADIENTALPHAS, n._alphaElements), t.setBuffer(Ke.COLOROVERLIFEGRADIENTCOLORS, n._rgbElements),
                t.setBuffer(Ke.MAXCOLOROVERLIFEGRADIENTALPHAS, a._alphaElements), t.setBuffer(Ke.MAXCOLOROVERLIFEGRADIENTCOLORS, a._rgbElements);
            this._colorOverLifetime = e;
        }
        get sizeOverLifetime() {
            return this._sizeOverLifetime;
        }
        set sizeOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.size,
                    i = r.separateAxes,
                    n = r.type;
                if (e.enbale) switch (n) {
                    case 0:
                        i ? t.addDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE) : t.addDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVE);
                        break;

                    case 2:
                        i ? t.addDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE) : t.addDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES);
                } else t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                    t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE);
                switch (n) {
                    case 0:
                        i ? (t.setBuffer(Ke.SOLSIZEGRADIENTX, r.gradientX._elements), t.setBuffer(Ke.SOLSIZEGRADIENTY, r.gradientY._elements),
                            t.setBuffer(Ke.SOLSizeGradientZ, r.gradientZ._elements)) : t.setBuffer(Ke.SOLSIZEGRADIENT, r.gradient._elements);
                        break;

                    case 2:
                        i ? (t.setBuffer(Ke.SOLSIZEGRADIENTX, r.gradientXMin._elements), t.setBuffer(Ke.SOLSIZEGRADIENTXMAX, r.gradientXMax._elements),
                            t.setBuffer(Ke.SOLSIZEGRADIENTY, r.gradientYMin._elements), t.setBuffer(Ke.SOLSIZEGRADIENTYMAX, r.gradientYMax._elements),
                            t.setBuffer(Ke.SOLSizeGradientZ, r.gradientZMin._elements), t.setBuffer(Ke.SOLSizeGradientZMAX, r.gradientZMax._elements)) : (t.setBuffer(Ke.SOLSIZEGRADIENT, r.gradientMin._elements),
                            t.setBuffer(Ke.SOLSizeGradientMax, r.gradientMax._elements));
                }
            } else t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVE), t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE),
                t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES), t.removeDefine(Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE),
                t.setBuffer(Ke.SOLSIZEGRADIENTX, null), t.setBuffer(Ke.SOLSIZEGRADIENTXMAX, null),
                t.setBuffer(Ke.SOLSIZEGRADIENTY, null), t.setBuffer(Ke.SOLSIZEGRADIENTYMAX, null),
                t.setBuffer(Ke.SOLSizeGradientZ, null), t.setBuffer(Ke.SOLSizeGradientZMAX, null),
                t.setBuffer(Ke.SOLSIZEGRADIENT, null), t.setBuffer(Ke.SOLSizeGradientMax, null);
            this._sizeOverLifetime = e;
        }
        get rotationOverLifetime() {
            return this._rotationOverLifetime;
        }
        set rotationOverLifetime(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.angularVelocity;
                if (!r) return;
                var i = r.separateAxes,
                    n = r.type;
                if (e.enbale) switch (i ? t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE) : t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIME),
                    n) {
                    case 0:
                        t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT);
                        break;

                    case 1:
                        t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE);
                        break;

                    case 2:
                        t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS);
                        break;

                    case 3:
                        t.addDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                } else t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                    t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                    t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES);
                switch (n) {
                    case 0:
                        i ? t.setVector3(Ke.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantSeparate) : t.setNumber(Ke.ROLANGULARVELOCITYCONST, r.constant);
                        break;

                    case 1:
                        i ? (t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTX, r.gradientX._elements), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTY, r.gradientY._elements),
                            t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTZ, r.gradientZ._elements)) : t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENT, r.gradient._elements);
                        break;

                    case 2:
                        i ? (t.setVector3(Ke.ROLANGULARVELOCITYCONSTSEPRARATE, r.constantMinSeparate), t.setVector3(Ke.ROLANGULARVELOCITYCONSTMAXSEPRARATE, r.constantMaxSeparate)) : (t.setNumber(Ke.ROLANGULARVELOCITYCONST, r.constantMin),
                            t.setNumber(Ke.ROLANGULARVELOCITYCONSTMAX, r.constantMax));
                        break;

                    case 3:
                        i ? (t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTX, r.gradientXMin._elements), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTXMAX, r.gradientXMax._elements),
                            t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTY, r.gradientYMin._elements), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTYMAX, r.gradientYMax._elements),
                            t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTZ, r.gradientZMin._elements), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTZMAX, r.gradientZMax._elements)) : (t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENT, r.gradientMin._elements),
                            t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTMAX, r.gradientMax._elements));
                }
            } else t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIME), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE),
                t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE),
                t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS), t.removeDefine(Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES),
                t.setVector(Ke.ROLANGULARVELOCITYCONSTSEPRARATE, null), t.setVector(Ke.ROLANGULARVELOCITYCONSTMAXSEPRARATE, null),
                t.setNumber(Ke.ROLANGULARVELOCITYCONST, void 0), t.setNumber(Ke.ROLANGULARVELOCITYCONSTMAX, void 0),
                t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTX, null), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTXMAX, null),
                t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTY, null), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTYMAX, null),
                t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTZ, null), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTZMAX, null),
                t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTWMAX, null), t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENT, null),
                t.setBuffer(Ke.ROLANGULARVELOCITYGRADIENTMAX, null);
            this._rotationOverLifetime = e;
        }
        get textureSheetAnimation() {
            return this._textureSheetAnimation;
        }
        set textureSheetAnimation(e) {
            var t = this._owner._render._shaderValues;
            if (e) {
                var r = e.frame,
                    i = r.type;
                if (e.enable) switch (i) {
                    case 1:
                        t.addDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE);
                        break;

                    case 3:
                        t.addDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                } else t.removeDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE);
                if (1 === i || 3 === i) {
                    t.setNumber(Ke.TEXTURESHEETANIMATIONCYCLES, e.cycles);
                    var n = e.tiles,
                        a = this._uvLength;
                    a.x = 1 / n.x, a.y = 1 / n.y, t.setVector2(Ke.TEXTURESHEETANIMATIONSUBUVLENGTH, this._uvLength);
                }
                switch (i) {
                    case 1:
                        t.setBuffer(Ke.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeData._elements);
                        break;

                    case 3:
                        t.setBuffer(Ke.TEXTURESHEETANIMATIONGRADIENTUVS, r.frameOverTimeDataMin._elements),
                            t.setBuffer(Ke.TEXTURESHEETANIMATIONGRADIENTMAXUVS, r.frameOverTimeDataMax._elements);
                }
            } else t.removeDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE), t.removeDefine(Ke.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE),
                t.setNumber(Ke.TEXTURESHEETANIMATIONCYCLES, void 0), t.setVector(Ke.TEXTURESHEETANIMATIONSUBUVLENGTH, null),
                t.setBuffer(Ke.TEXTURESHEETANIMATIONGRADIENTUVS, null), t.setBuffer(Ke.TEXTURESHEETANIMATIONGRADIENTMAXUVS, null);
            this._textureSheetAnimation = e;
        }
        _getVertexBuffer(e = 0) {
            return 0 === e ? this._vertexBuffer : null;
        }
        _getIndexBuffer() {
            return this._indexBuffer;
        }
        _generateBoundingSphere() {
            var e = this._boundingSphere.center;
            e.x = 0, e.y = 0, e.z = 0, this._boundingSphere.radius = Number.MAX_VALUE;
        }
        _generateBoundingBox() {
            var e, t, r, i, n, s, o, l, _, h = this._owner.particleRenderer,
                c = this._boundingBox.min,
                d = this._boundingBox.max;
            switch (this.startLifetimeType) {
                case 0:
                    r = this.startLifetimeConstant;
                    break;

                case 1:
                    r = -Number.MAX_VALUE;
                    var u = u;
                    for (e = 0, t = u.gradientCount; e < t; e++) r = Math.max(r, u.getValueByIndex(e));
                    break;

                case 2:
                    r = Math.max(this.startLifetimeConstantMin, this.startLifetimeConstantMax);
                    break;

                case 3:
                    r = -Number.MAX_VALUE;
                    var f = f;
                    for (e = 0, t = f.gradientCount; e < t; e++) r = Math.max(r, f.getValueByIndex(e));
                    var E = E;
                    for (e = 0, t = E.gradientCount; e < t; e++) r = Math.max(r, E.getValueByIndex(e));
            }
            switch (this.startSpeedType) {
                case 0:
                    i = n = this.startSpeedConstant;
                    break;

                case 1:
                    break;

                case 2:
                    i = this.startLifetimeConstantMin, n = this.startLifetimeConstantMax;
            }
            this._shape && this._shape.enable || (s = o = a._ZERO, l = a._ZERO, _ = a._UnitZ);
            var T, m, p = new a(l.x * i, l.y * i, l.z * i),
                g = new a(_.x * n, _.y * n, _.z * n);
            if (this._velocityOverLifetime && this._velocityOverLifetime.enbale) {
                var S = this._velocityOverLifetime.velocity;
                switch (S.type) {
                    case 0:
                        S.constant;
                        break;

                    case 1:
                        new a(S.gradientX.getAverageValue(), S.gradientY.getAverageValue(), S.gradientZ.getAverageValue());
                        break;

                    case 2:
                        S.constantMin, S.constantMax;
                        break;

                    case 3:
                        new a(S.gradientXMin.getAverageValue(), S.gradientYMin.getAverageValue(), S.gradientZMin.getAverageValue()),
                            new a(S.gradientXMax.getAverageValue(), S.gradientYMax.getAverageValue(), S.gradientZMax.getAverageValue());
                }
            }
            var v, R, A, D, I = this._owner.transform,
                x = I.position,
                M = at._tempVector39,
                L = h.renderMode;
            switch (this.scaleMode) {
                case 0:
                    var C = I.getWorldLossyScale();
                    T = C, M.x = C.x, M.y = C.z, M.z = C.y, 1 === L && (m = C);
                    break;

                case 1:
                    var y = I.localScale;
                    T = y, M.x = y.x, M.y = y.z, M.z = y.y, 1 === L && (m = y);
                    break;

                case 2:
                    T = I.getWorldLossyScale(), M.x = M.y = M.z = 1, 1 === L && (m = a._ONE);
            }
            switch (this._velocityOverLifetime && this._velocityOverLifetime.enbale || (v = new a(p.x * r, p.y * r, p.z * r),
                R = new a(g.x * r, g.y * r, g.z * r), 2 != this.scaleMode ? (a.add(s, v, c), a.multiply(T, c, c),
                    a.add(o, R, d), a.multiply(T, d, d)) : (a.multiply(T, s, c), a.add(c, v, c), a.multiply(T, o, d),
                    a.add(d, R, d))), this.simulationSpace) {
                case 0:
                    break;

                case 1:
                    a.add(c, x, c), a.add(d, x, d);
            }
            switch (this.startSizeType) {
                case 0:
                    if (this.threeDStartSize) {
                        var O = O;
                        A = Math.max(O.x, O.y), 1 === L && (D = O.y);
                    } else A = this.startSizeConstant, 1 === L && (D = this.startSizeConstant);
                    break;

                case 1:
                    break;

                case 2:
                    if (this.threeDStartSize) {
                        var N = N;
                        A = Math.max(N.x, N.y), 1 === L && (D = N.y);
                    } else A = this.startSizeConstantMax, 1 === L && (D = this.startSizeConstantMax);
            }
            if (this._sizeOverLifetime && this._sizeOverLifetime.enbale) {
                this._sizeOverLifetime.size;
                A *= this._sizeOverLifetime.size.getMaxSizeInGradient();
            }
            var P, V, w = at._tempVector30;
            switch (L) {
                case 0:
                    P = A * at.halfKSqrtOf2, a.scale(M, A, w), a.subtract(c, w, c), a.add(d, w, d);
                    break;

                case 1:
                    var b = at._tempVector31,
                        F = at._tempVector32,
                        B = at._tempVector33,
                        U = at._tempVector34;
                    this._velocityOverLifetime && this._velocityOverLifetime.enbale || (a.multiply(m, g, F),
                        a.multiply(m, p, B));
                    var G = D * h.stretchedBillboardLengthScale,
                        z = a.scalarLength(F) * h.stretchedBillboardSpeedScale + G,
                        H = a.scalarLength(B) * h.stretchedBillboardSpeedScale + G,
                        W = at._tempVector35,
                        k = at._tempVector36;
                    a.normalize(F, W), a.scale(W, z, U), a.subtract(R, U, U), a.normalize(B, k), a.scale(k, H, b),
                        a.add(v, b, b), P = A * at.halfKSqrtOf2, a.scale(M, P, w);
                    var X = at._tempVector37,
                        Y = at._tempVector38;
                    a.scale(W, .5, X), a.scale(k, .5, Y), a.multiply(X, M, X), a.multiply(Y, M, Y),
                        a.add(c, Y, c), a.min(c, U, c), a.subtract(c, w, c), a.subtract(d, X, d), a.max(d, b, d),
                        a.add(d, w, d);
                    break;

                case 2:
                    V = .5 * (A *= Math.cos(.7853981633974483)), w.x = M.x * V, w.y = M.z * V, a.subtract(c, w, c),
                        a.add(d, w, d);
                    break;

                case 3:
                    V = .5 * (A *= Math.cos(.7853981633974483)), a.scale(M, V, w), a.subtract(c, w, c),
                        a.add(d, w, d);
            }
            this._boundingBox.getCorners(this._boundingBoxCorners);
        }
        _updateEmission() {
            if (this.isAlive)
                if (this._simulateUpdate) this._simulateUpdate = !1;
                else {
                    var e = this._startUpdateLoopCount === t.Stat.loopCount || this._isPaused ? 0 : this._owner._scene.timer._delta / 1e3;
                    e = Math.min(at._maxElapsedTime, e), this._updateParticles(e);
                }
        }
        _updateParticles(e) {
            (4 !== this._ownerRender.renderMode || this._ownerRender.mesh) && (this._currentTime += e,
                this._retireActiveParticles(), this._freeRetiredParticles(), this._totalDelayTime += e,
                this._totalDelayTime < this._playStartDelay || this._emission.enbale && this._isEmitting && !this._isPaused && this._advanceTime(e, this._currentTime));
        }
        _updateParticlesSimulationRestart(e) {
            this._firstActiveElement = 0, this._firstNewElement = 0, this._firstFreeElement = 0,
                this._firstRetiredElement = 0, this._burstsIndex = 0, this._frameRateTime = e, this._emissionTime = 0,
                this._totalDelayTime = 0, this._currentTime = e;
            var t = e;
            t < this._playStartDelay ? this._totalDelayTime = t : this._emission.enbale && this._advanceTime(e, e);
        }
        _retireActiveParticles() {
            for (; this._firstActiveElement != this._firstNewElement;) {
                var e = this._firstActiveElement * this._floatCountPerVertex * this._vertexStride,
                    t = e + this._timeIndex;
                if (this._currentTime - this._vertices[t] + 1e-4 < this._vertices[e + this._startLifeTimeIndex]) break;
                this._vertices[t] = this._drawCounter, this._firstActiveElement++, this._firstActiveElement >= this._bufferMaxParticles && (this._firstActiveElement = 0);
            }
        }
        _freeRetiredParticles() {
            for (; this._firstRetiredElement != this._firstActiveElement;) {
                var e = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * this._vertexStride + this._timeIndex];
                if (this.isPerformanceMode && e < 3) break;
                this._firstRetiredElement++, this._firstRetiredElement >= this._bufferMaxParticles && (this._firstRetiredElement = 0);
            }
        }
        _burst(e, r) {
            for (var i = 0, n = this._emission._bursts, a = n.length; this._burstsIndex < a; this._burstsIndex++) {
                var s, o = n[this._burstsIndex],
                    l = o.time;
                if (!(e <= l && l < r)) break;
                this.autoRandomSeed ? s = t.MathUtil.lerp(o.minCount, o.maxCount, Math.random()) : (this._rand.seed = this._randomSeeds[0],
                        s = t.MathUtil.lerp(o.minCount, o.maxCount, this._rand.getFloat()), this._randomSeeds[0] = this._rand.seed),
                    i += s;
            }
            return i;
        }
        _advanceTime(e, t) {
            var r, i = this._emissionTime;
            this._emissionTime += e;
            var n = 0;
            if (this._emissionTime > this.duration) {
                if (!this.looping) {
                    for (n = Math.min(this.maxParticles - this.aliveParticleCount, n), r = 0; r < n; r++) this.emit(t);
                    return this._isPlaying = !1, void this.stop();
                }
                n += this._burst(i, this._emissionTime), this._emissionTime -= this.duration, this._burstsIndex = 0,
                    n += this._burst(0, this._emissionTime);
            } else n += this._burst(i, this._emissionTime);
            for (n = Math.min(this.maxParticles - this.aliveParticleCount, n), r = 0; r < n; r++) this.emit(t);
            var a = this.emission.emissionRate;
            if (a > 0) {
                var s = 1 / a;
                for (this._frameRateTime += s, this._frameRateTime = this._currentTime - (this._currentTime - this._frameRateTime) % this._maxStartLifetime; this._frameRateTime <= t && this.emit(this._frameRateTime);) this._frameRateTime += s;
                this._frameRateTime = Math.floor(t / s) * s;
            }
        }
        _initBufferDatas() {
            this._vertexBuffer && (this._vertexBuffer.destroy(), this._indexBuffer.destroy());
            var e = t.LayaGL.instance,
                r = this._ownerRender,
                i = r.renderMode;
            if (-1 !== i && this.maxParticles > 0) {
                var n, a, s, o, l, _, h, u = 0,
                    f = 0,
                    E = r.mesh;
                if (4 === i) {
                    if (E) {
                        h = it.vertexDeclaration, this._floatCountPerVertex = h.vertexStride / 4, this._startLifeTimeIndex = 12,
                            this._timeIndex = 16, this._vertexStride = E._vertexBuffer.vertexCount;
                        var T = this._bufferMaxParticles * this._vertexStride,
                            m = T % 65535;
                        if (Math.floor(T / 65535) + 1 > 1) throw new Error("ShurikenParticleSystem:the maxParticleCount multiply mesh vertexCount is large than 65535.");
                        u = h.vertexStride * m, this._vertexBuffer = new d(u, e.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = h,
                            this._vertices = new Float32Array(this._floatCountPerVertex * m), this._indexStride = E._indexBuffer.indexCount;
                        var p = E._indexBuffer.getData(),
                            g = this._bufferMaxParticles * this._indexStride;
                        for (this._indexBuffer = new c(c.INDEXTYPE_USHORT, g, e.STATIC_DRAW), n = new Uint16Array(g),
                            f = u + 2 * g, l = 0, a = 0; a < this._bufferMaxParticles; a++) {
                            var S = a * this._vertexStride;
                            for (s = 0, o = p.length; s < o; s++) n[l++] = S + p[s];
                        }
                        this._indexBuffer.setData(n), this._bufferState.bind(), this._bufferState.applyVertexBuffer(this._vertexBuffer),
                            this._bufferState.applyIndexBuffer(this._indexBuffer), this._bufferState.unBind();
                    }
                } else {
                    for (h = rt.vertexDeclaration, this._floatCountPerVertex = h.vertexStride / 4, this._startLifeTimeIndex = 7,
                        this._timeIndex = 11, this._vertexStride = 4, u = h.vertexStride * this._bufferMaxParticles * this._vertexStride,
                        this._vertexBuffer = new d(u, e.DYNAMIC_DRAW), this._vertexBuffer.vertexDeclaration = h,
                        this._vertices = new Float32Array(this._floatCountPerVertex * this._bufferMaxParticles * this._vertexStride),
                        a = 0; a < this._bufferMaxParticles; a++) _ = a * this._floatCountPerVertex * this._vertexStride,
                        this._vertices[_] = -.5, this._vertices[_ + 1] = -.5, this._vertices[_ + 2] = 0,
                        this._vertices[_ + 3] = 1, _ += this._floatCountPerVertex, this._vertices[_] = .5,
                        this._vertices[_ + 1] = -.5, this._vertices[_ + 2] = 1, this._vertices[_ + 3] = 1,
                        _ += this._floatCountPerVertex, this._vertices[_] = .5, this._vertices[_ + 1] = .5,
                        this._vertices[_ + 2] = 1, this._vertices[_ + 3] = 0, _ += this._floatCountPerVertex,
                        this._vertices[_] = -.5, this._vertices[_ + 1] = .5, this._vertices[_ + 2] = 0,
                        this._vertices[_ + 3] = 0;
                    for (this._indexStride = 6, this._indexBuffer = new c(c.INDEXTYPE_USHORT, 6 * this._bufferMaxParticles, e.STATIC_DRAW),
                        n = new Uint16Array(6 * this._bufferMaxParticles), a = 0; a < this._bufferMaxParticles; a++) {
                        l = 6 * a;
                        var v = a * this._vertexStride,
                            R = v + 2;
                        n[l++] = v, n[l++] = R, n[l++] = v + 1, n[l++] = v, n[l++] = v + 3, n[l++] = R;
                    }
                    this._indexBuffer.setData(n), f = u + 6 * this._bufferMaxParticles * 2, this._bufferState.bind(),
                        this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.applyIndexBuffer(this._indexBuffer),
                        this._bufferState.unBind();
                }
                t.Resource._addMemory(f, f);
            }
        }
        destroy() {
            super.destroy();
            var e = this._vertexBuffer._byteLength + 2 * this._indexBuffer.indexCount;
            t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer.destroy(),
                this._indexBuffer.destroy(), this._emission.destroy(), this._bufferState = null,
                this._vertexBuffer = null, this._indexBuffer = null, this._owner = null, this._vertices = null,
                this._indexBuffer = null, this._emission = null, this._shape = null, this.startLifeTimeGradient = null,
                this.startLifeTimeGradientMin = null, this.startLifeTimeGradientMax = null, this.startSizeConstantSeparate = null,
                this.startSizeConstantMinSeparate = null, this.startSizeConstantMaxSeparate = null,
                this.startRotationConstantSeparate = null, this.startRotationConstantMinSeparate = null,
                this.startRotationConstantMaxSeparate = null, this.startColorConstant = null, this.startColorConstantMin = null,
                this.startColorConstantMax = null, this._velocityOverLifetime = null, this._colorOverLifetime = null,
                this._sizeOverLifetime = null, this._rotationOverLifetime = null, this._textureSheetAnimation = null;
        }
        emit(e) {
            var t = at._tempPosition,
                r = at._tempDirection;
            return this._shape && this._shape.enable ? this.autoRandomSeed ? this._shape.generatePositionAndDirection(t, r) : this._shape.generatePositionAndDirection(t, r, this._rand, this._randomSeeds) : (t.x = t.y = t.z = 0,
                r.x = r.y = 0, r.z = 1), this.addParticle(t, r, e);
        }
        addParticle(e, t, r) {
            a.normalize(t, t);
            var i, n, s, o, l, _, h, c = this._firstFreeElement + 1;
            if (c >= this._bufferMaxParticles && (c = 0), c === this._firstRetiredElement) return !1;
            if (Je.create(this, this._ownerRender, this._owner.transform), this._currentTime - r >= Je.startLifeTime) return !0;
            var d = this._velocityOverLifetime && this._velocityOverLifetime.enbale;
            if (d) {
                var u = this._velocityOverLifetime.velocity.type;
                2 === u || 3 === u ? this.autoRandomSeed ? (i = Math.random(), n = Math.random(),
                    s = Math.random()) : (this._rand.seed = this._randomSeeds[9], i = this._rand.getFloat(),
                    n = this._rand.getFloat(), s = this._rand.getFloat(), this._randomSeeds[9] = this._rand.seed) : d = !1;
            } else d = !1;
            var f = this._colorOverLifetime && this._colorOverLifetime.enbale;
            f ? 3 === this._colorOverLifetime.color.type ? this.autoRandomSeed ? o = Math.random() : (this._rand.seed = this._randomSeeds[10],
                o = this._rand.getFloat(), this._randomSeeds[10] = this._rand.seed) : f = !1 : f = !1;
            var E = this._sizeOverLifetime && this._sizeOverLifetime.enbale;
            E ? 3 === this._sizeOverLifetime.size.type ? this.autoRandomSeed ? l = Math.random() : (this._rand.seed = this._randomSeeds[11],
                l = this._rand.getFloat(), this._randomSeeds[11] = this._rand.seed) : E = !1 : E = !1;
            var T = this._rotationOverLifetime && this._rotationOverLifetime.enbale;
            if (T) {
                var m = this._rotationOverLifetime.angularVelocity.type;
                2 === m || 3 === m ? this.autoRandomSeed ? _ = Math.random() : (this._rand.seed = this._randomSeeds[12],
                    _ = this._rand.getFloat(), this._randomSeeds[12] = this._rand.seed) : T = !1;
            } else T = !1;
            var p = this._textureSheetAnimation && this._textureSheetAnimation.enable;
            p ? 3 === this._textureSheetAnimation.frame.type ? this.autoRandomSeed ? h = Math.random() : (this._rand.seed = this._randomSeeds[15],
                h = this._rand.getFloat(), this._randomSeeds[15] = this._rand.seed) : p = !1 : p = !1;
            var g, S, R, A, D, I, x = this._firstFreeElement * this._floatCountPerVertex * this._vertexStride,
                M = Je.startUVInfo[0],
                L = Je.startUVInfo[1],
                C = Je.startUVInfo[2],
                y = Je.startUVInfo[3],
                O = this._ownerRender;
            if (4 === O.renderMode) {
                var N = O.mesh._vertexBuffer;
                g = N.getFloat32Data();
                var P = N.vertexDeclaration;
                R = P.getVertexElementByUsage(v.MESH_POSITION0)._offset / 4;
                var V = P.getVertexElementByUsage(v.MESH_COLOR0);
                A = V ? V._offset / 4 : -1;
                var w = P.getVertexElementByUsage(v.MESH_TEXTURECOORDINATE0);
                D = w ? w._offset / 4 : -1, S = P.vertexStride / 4, I = 0;
            } else {
                this._vertices[x + 2] = C, this._vertices[x + 3] = y + L;
                var b = x + this._floatCountPerVertex;
                this._vertices[b + 2] = C + M, this._vertices[b + 3] = y + L;
                var F = b + this._floatCountPerVertex;
                this._vertices[F + 2] = C + M, this._vertices[F + 3] = y;
                var B = F + this._floatCountPerVertex;
                this._vertices[B + 2] = C, this._vertices[B + 3] = y;
            }
            for (var U = x, G = x + this._floatCountPerVertex * this._vertexStride; U < G; U += this._floatCountPerVertex) {
                var z;
                if (4 === O.renderMode) {
                    z = U;
                    var H = S * I++,
                        W = H + R;
                    this._vertices[z++] = g[W++], this._vertices[z++] = g[W++], this._vertices[z++] = g[W], -1 === A ? (this._vertices[z++] = 1, this._vertices[z++] = 1, this._vertices[z++] = 1,
                        this._vertices[z++] = 1) : (W = H + A, this._vertices[z++] = g[W++], this._vertices[z++] = g[W++],
                        this._vertices[z++] = g[W++], this._vertices[z++] = g[W]), -1 === D ? (this._vertices[z++] = 0,
                        this._vertices[z++] = 0) : (W = H + D, this._vertices[z++] = C + g[W++] * M, this._vertices[z++] = y + g[W] * L);
                } else z = U + 4;
                switch (this._vertices[z++] = e.x, this._vertices[z++] = e.y, this._vertices[z++] = e.z,
                    this._vertices[z++] = Je.startLifeTime, this._vertices[z++] = t.x, this._vertices[z++] = t.y,
                    this._vertices[z++] = t.z, this._vertices[z++] = r, this._vertices[z++] = Je.startColor.x,
                    this._vertices[z++] = Je.startColor.y, this._vertices[z++] = Je.startColor.z, this._vertices[z++] = Je.startColor.w,
                    this._vertices[z++] = Je.startSize[0], this._vertices[z++] = Je.startSize[1], this._vertices[z++] = Je.startSize[2],
                    this._vertices[z++] = Je.startRotation[0], this._vertices[z++] = Je.startRotation[1],
                    this._vertices[z++] = Je.startRotation[2], this._vertices[z++] = Je.startSpeed,
                    f && (this._vertices[z + 1] = o), E && (this._vertices[z + 2] = l), T && (this._vertices[z + 3] = _),
                    p && (this._vertices[z + 4] = h), d && (this._vertices[z + 5] = i, this._vertices[z + 6] = n,
                        this._vertices[z + 7] = s), this.simulationSpace) {
                    case 0:
                        z += 8, this._vertices[z++] = Je.simulationWorldPostion[0], this._vertices[z++] = Je.simulationWorldPostion[1],
                            this._vertices[z++] = Je.simulationWorldPostion[2], this._vertices[z++] = Je.simulationWorldRotation[0],
                            this._vertices[z++] = Je.simulationWorldRotation[1], this._vertices[z++] = Je.simulationWorldRotation[2],
                            this._vertices[z++] = Je.simulationWorldRotation[3];
                        break;

                    case 1:
                        break;

                    default:
                        throw new Error("ShurikenParticleMaterial: SimulationSpace value is invalid.");
                }
            }
            return this._firstFreeElement = c, !0;
        }
        addNewParticlesToVertexBuffer() {
            var e, t = this._vertexStride * this._floatCountPerVertex * 4;
            this._firstNewElement < this._firstFreeElement ? (e = this._firstNewElement * t,
                    this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._firstFreeElement - this._firstNewElement) * t)) : (e = this._firstNewElement * t,
                    this._vertexBuffer.setData(this._vertices.buffer, e, e, (this._bufferMaxParticles - this._firstNewElement) * t),
                    this._firstFreeElement > 0 && this._vertexBuffer.setData(this._vertices.buffer, 0, 0, this._firstFreeElement * t)),
                this._firstNewElement = this._firstFreeElement;
        }
        _getType() {
            return at._type;
        }
        _prepareRender(e) {
            return this._updateEmission(), this._firstNewElement != this._firstFreeElement && this.addNewParticlesToVertexBuffer(),
                this._drawCounter++, this._firstActiveElement != this._firstFreeElement;
        }
        _render(e) {
            var r;
            this._bufferState.bind();
            var i = t.LayaGL.instance;
            this._firstActiveElement < this._firstFreeElement ? (r = (this._firstFreeElement - this._firstActiveElement) * this._indexStride,
                i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++) : (r = (this._bufferMaxParticles - this._firstActiveElement) * this._indexStride,
                i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 2 * this._firstActiveElement * this._indexStride),
                t.Stat.trianglesFaces += r / 3, t.Stat.renderBatches++, this._firstFreeElement > 0 && (r = this._firstFreeElement * this._indexStride,
                    i.drawElements(i.TRIANGLES, r, i.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += r / 3,
                    t.Stat.renderBatches++));
        }
        play() {
            if (this._burstsIndex = 0, this._isEmitting = !0, this._isPlaying = !0, this._isPaused = !1,
                this._emissionTime = 0, this._totalDelayTime = 0, !this.autoRandomSeed)
                for (var e = 0, r = this._randomSeeds.length; e < r; e++) this._randomSeeds[e] = this.randomSeed[0] + at._RANDOMOFFSET[e];
            switch (this.startDelayType) {
                case 0:
                    this._playStartDelay = this.startDelay;
                    break;

                case 1:
                    this.autoRandomSeed ? this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, Math.random()) : (this._rand.seed = this._randomSeeds[2],
                        this._playStartDelay = t.MathUtil.lerp(this.startDelayMin, this.startDelayMax, this._rand.getFloat()),
                        this._randomSeeds[2] = this._rand.seed);
                    break;

                default:
                    throw new Error("Utils3D: startDelayType is invalid.");
            }
            this._frameRateTime = this._currentTime + this._playStartDelay, this._startUpdateLoopCount = t.Stat.loopCount;
        }
        pause() {
            this._isPaused = !0;
        }
        simulate(e, t = !0) {
            this._simulateUpdate = !0, t ? this._updateParticlesSimulationRestart(e) : (this._isPaused = !1,
                this._updateParticles(e)), this.pause();
        }
        stop() {
            this._burstsIndex = 0, this._isEmitting = !1, this._emissionTime = 0;
        }
        cloneTo(e) {
            var t = e;
            t.duration = this.duration, t.looping = this.looping, t.prewarm = this.prewarm,
                t.startDelayType = this.startDelayType, t.startDelay = this.startDelay, t.startDelayMin = this.startDelayMin,
                t.startDelayMax = this.startDelayMax, t._maxStartLifetime = this._maxStartLifetime,
                t.startLifetimeType = this.startLifetimeType, t.startLifetimeConstant = this.startLifetimeConstant,
                this.startLifeTimeGradient.cloneTo(t.startLifeTimeGradient), t.startLifetimeConstantMin = this.startLifetimeConstantMin,
                t.startLifetimeConstantMax = this.startLifetimeConstantMax, this.startLifeTimeGradientMin.cloneTo(t.startLifeTimeGradientMin),
                this.startLifeTimeGradientMax.cloneTo(t.startLifeTimeGradientMax), t.startSpeedType = this.startSpeedType,
                t.startSpeedConstant = this.startSpeedConstant, t.startSpeedConstantMin = this.startSpeedConstantMin,
                t.startSpeedConstantMax = this.startSpeedConstantMax, t.threeDStartSize = this.threeDStartSize,
                t.startSizeType = this.startSizeType, t.startSizeConstant = this.startSizeConstant,
                this.startSizeConstantSeparate.cloneTo(t.startSizeConstantSeparate), t.startSizeConstantMin = this.startSizeConstantMin,
                t.startSizeConstantMax = this.startSizeConstantMax, this.startSizeConstantMinSeparate.cloneTo(t.startSizeConstantMinSeparate),
                this.startSizeConstantMaxSeparate.cloneTo(t.startSizeConstantMaxSeparate), t.threeDStartRotation = this.threeDStartRotation,
                t.startRotationType = this.startRotationType, t.startRotationConstant = this.startRotationConstant,
                this.startRotationConstantSeparate.cloneTo(t.startRotationConstantSeparate), t.startRotationConstantMin = this.startRotationConstantMin,
                t.startRotationConstantMax = this.startRotationConstantMax, this.startRotationConstantMinSeparate.cloneTo(t.startRotationConstantMinSeparate),
                this.startRotationConstantMaxSeparate.cloneTo(t.startRotationConstantMaxSeparate),
                t.randomizeRotationDirection = this.randomizeRotationDirection, t.startColorType = this.startColorType,
                this.startColorConstant.cloneTo(t.startColorConstant), this.startColorConstantMin.cloneTo(t.startColorConstantMin),
                this.startColorConstantMax.cloneTo(t.startColorConstantMax), t.gravityModifier = this.gravityModifier,
                t.simulationSpace = this.simulationSpace, t.scaleMode = this.scaleMode, t.playOnAwake = this.playOnAwake,
                t.autoRandomSeed = this.autoRandomSeed, t.randomSeed[0] = this.randomSeed[0], t.maxParticles = this.maxParticles,
                this._emission && (t._emission = this._emission.clone()), this.shape && (t.shape = this.shape.clone()),
                this.velocityOverLifetime && (t.velocityOverLifetime = this.velocityOverLifetime.clone()),
                this.colorOverLifetime && (t.colorOverLifetime = this.colorOverLifetime.clone()),
                this.sizeOverLifetime && (t.sizeOverLifetime = this.sizeOverLifetime.clone()), this.rotationOverLifetime && (t.rotationOverLifetime = this.rotationOverLifetime.clone()),
                this.textureSheetAnimation && (t.textureSheetAnimation = this.textureSheetAnimation.clone()),
                t.isPerformanceMode = this.isPerformanceMode, t._isEmitting = this._isEmitting,
                t._isPlaying = this._isPlaying, t._isPaused = this._isPaused, t._playStartDelay = this._playStartDelay,
                t._frameRateTime = this._frameRateTime, t._emissionTime = this._emissionTime, t._totalDelayTime = this._totalDelayTime,
                t._burstsIndex = this._burstsIndex;
        }
        clone() {
            var e = new at(null);
            return this.cloneTo(e), e;
        }
    }
    at._RANDOMOFFSET = new Uint32Array([592910910, 3276756734, 322376503, 306581307, 1793934638, 3737431713, 2527743459, 2368504881, 4085612399, 3774601268, 326370691, 1494990940, 1089181156, 3159510623, 2941263940, 2786374529, 271901988, 4233252447]),
        at.halfKSqrtOf2 = .71, at._maxElapsedTime = 1 / 3, at._tempVector30 = new a(), at._tempVector31 = new a(),
        at._tempVector32 = new a(), at._tempVector33 = new a(), at._tempVector34 = new a(),
        at._tempVector35 = new a(), at._tempVector36 = new a(), at._tempVector37 = new a(),
        at._tempVector38 = new a(), at._tempVector39 = new a(), at._tempPosition = new a(),
        at._tempDirection = new a(), at._type = h._typeCounter++;
    class st {
        get time() {
            return this._time;
        }
        get minCount() {
            return this._minCount;
        }
        get maxCount() {
            return this._maxCount;
        }
        constructor(e, t, r) {
            this._time = e, this._minCount = t, this._maxCount = r;
        }
        cloneTo(e) {
            var t = e;
            t._time = this._time, t._minCount = this._minCount, t._maxCount = this._maxCount;
        }
        clone() {
            var e = new st(this._time, this._minCount, this._maxCount);
            return this.cloneTo(e), e;
        }
    }
    class ot {
        constructor() {
            this._type = 0, this._constant = null, this._constantMin = null, this._constantMax = null,
                this._gradient = null, this._gradientMin = null, this._gradientMax = null;
        }
        static createByConstant(e) {
            var t = new ot();
            return t._type = 0, t._constant = e, t;
        }
        static createByGradient(e) {
            var t = new ot();
            return t._type = 1, t._gradient = e, t;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new ot();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new ot();
            return r._type = 3, r._gradientMin = e, r._gradientMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._constantMin.cloneTo(t._constantMin),
                this._constantMax.cloneTo(t._constantMax), this._gradient.cloneTo(t._gradient),
                this._gradientMin.cloneTo(t._gradientMin), this._gradientMax.cloneTo(t._gradientMax);
        }
        clone() {
            var e = new ot();
            return this.cloneTo(e), e;
        }
    }
    class lt {
        get color() {
            return this._color;
        }
        constructor(e) {
            this._color = e;
        }
        cloneTo(e) {
            var t = e;
            this._color.cloneTo(t._color), t.enbale = this.enbale;
        }
        clone() {
            var e;
            switch (this._color.type) {
                case 0:
                    e = ot.createByConstant(this._color.constant.clone());
                    break;

                case 1:
                    e = ot.createByGradient(this._color.gradient.clone());
                    break;

                case 2:
                    e = ot.createByRandomTwoConstant(this._color.constantMin.clone(), this._color.constantMax.clone());
                    break;

                case 3:
                    e = ot.createByRandomTwoGradient(this._color.gradientMin.clone(), this._color.gradientMax.clone());
            }
            var t = new lt(e);
            return t.enbale = this.enbale, t;
        }
    }
    class _t {
        constructor() {
            this._type = 0, this._constant = 0, this._overTime = null, this._constantMin = 0,
                this._constantMax = 0, this._overTimeMin = null, this._overTimeMax = null;
        }
        static createByConstant(e) {
            var t = new _t();
            return t._type = 0, t._constant = e, t;
        }
        static createByOverTime(e) {
            var t = new _t();
            return t._type = 1, t._overTime = e, t;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new _t();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoOverTime(e, t) {
            var r = new _t();
            return r._type = 3, r._overTimeMin = e, r._overTimeMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get frameOverTimeData() {
            return this._overTime;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get frameOverTimeDataMin() {
            return this._overTimeMin;
        }
        get frameOverTimeDataMax() {
            return this._overTimeMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, this._overTime && this._overTime.cloneTo(t._overTime),
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._overTimeMin && this._overTimeMin.cloneTo(t._overTimeMin),
                this._overTimeMax && this._overTimeMax.cloneTo(t._overTimeMax);
        }
        clone() {
            var e = new _t();
            return this.cloneTo(e), e;
        }
    }
    class ht {
        constructor() {
            this._type = 0, this._separateAxes = !1, this._constant = 0, this._constantSeparate = null,
                this._gradient = null, this._gradientX = null, this._gradientY = null, this._gradientZ = null,
                this._gradientW = null, this._constantMin = 0, this._constantMax = 0, this._constantMinSeparate = null,
                this._constantMaxSeparate = null, this._gradientMin = null, this._gradientMax = null,
                this._gradientXMin = null, this._gradientXMax = null, this._gradientYMin = null,
                this._gradientYMax = null, this._gradientZMin = null, this._gradientZMax = null,
                this._gradientWMin = null, this._gradientWMax = null;
        }
        static createByConstant(e) {
            var t = new ht();
            return t._type = 0, t._separateAxes = !1, t._constant = e, t;
        }
        static createByConstantSeparate(e) {
            var t = new ht();
            return t._type = 0, t._separateAxes = !0, t._constantSeparate = e, t;
        }
        static createByGradient(e) {
            var t = new ht();
            return t._type = 1, t._separateAxes = !1, t._gradient = e, t;
        }
        static createByGradientSeparate(e, t, r) {
            var i = new ht();
            return i._type = 1, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r,
                i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new ht();
            return r._type = 2, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                r;
        }
        static createByRandomTwoConstantSeparate(e, t) {
            var r = new ht();
            return r._type = 2, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new ht();
            return r._type = 3, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                r;
        }
        static createByRandomTwoGradientSeparate(e, t, r, i, n, a, s, o) {
            var l = new ht();
            return l._type = 3, l._separateAxes = !0, l._gradientXMin = e, l._gradientXMax = t,
                l._gradientYMin = r, l._gradientYMax = i, l._gradientZMin = n, l._gradientZMax = a,
                l._gradientWMin = s, l._gradientWMax = o, l;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get constant() {
            return this._constant;
        }
        get constantSeparate() {
            return this._constantSeparate;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get gradientW() {
            return this._gradientW;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        get gradientWMin() {
            return this._gradientWMin;
        }
        get gradientWMax() {
            return this._gradientWMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, t._constant = this._constant,
                this._constantSeparate.cloneTo(t._constantSeparate), this._gradient.cloneTo(t._gradient),
                this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new ht();
            return this.cloneTo(e), e;
        }
    }
    class ct {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(8);
        }
        get gradientCount() {
            return this._currentLength / 2;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("Warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t) : console.log("Warning:data count must lessEqual than 4");
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, n = this._elements.length; i < n; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new ct();
            return this.cloneTo(e), e;
        }
    }
    class dt {
        constructor() {
            this._type = 0, this._separateAxes = !1, this._gradient = null, this._gradientX = null,
                this._gradientY = null, this._gradientZ = null, this._constantMin = 0, this._constantMax = 0,
                this._constantMinSeparate = null, this._constantMaxSeparate = null, this._gradientMin = null,
                this._gradientMax = null, this._gradientXMin = null, this._gradientXMax = null,
                this._gradientYMin = null, this._gradientYMax = null, this._gradientZMin = null,
                this._gradientZMax = null;
        }
        static createByGradient(e) {
            var t = new dt();
            return t._type = 0, t._separateAxes = !1, t._gradient = e, t;
        }
        static createByGradientSeparate(e, t, r) {
            var i = new dt();
            return i._type = 0, i._separateAxes = !0, i._gradientX = e, i._gradientY = t, i._gradientZ = r,
                i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new dt();
            return r._type = 1, r._separateAxes = !1, r._constantMin = e, r._constantMax = t,
                r;
        }
        static createByRandomTwoConstantSeparate(e, t) {
            var r = new dt();
            return r._type = 1, r._separateAxes = !0, r._constantMinSeparate = e, r._constantMaxSeparate = t,
                r;
        }
        static createByRandomTwoGradient(e, t) {
            var r = new dt();
            return r._type = 2, r._separateAxes = !1, r._gradientMin = e, r._gradientMax = t,
                r;
        }
        static createByRandomTwoGradientSeparate(e, t, r, i, n, a) {
            var s = new dt();
            return s._type = 2, s._separateAxes = !0, s._gradientXMin = e, s._gradientXMax = t,
                s._gradientYMin = r, s._gradientYMax = i, s._gradientZMin = n, s._gradientZMax = a,
                s;
        }
        get type() {
            return this._type;
        }
        get separateAxes() {
            return this._separateAxes;
        }
        get gradient() {
            return this._gradient;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get constantMinSeparate() {
            return this._constantMinSeparate;
        }
        get constantMaxSeparate() {
            return this._constantMaxSeparate;
        }
        get gradientMin() {
            return this._gradientMin;
        }
        get gradientMax() {
            return this._gradientMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        getMaxSizeInGradient() {
            var e, t, r = -Number.MAX_VALUE;
            switch (this._type) {
                case 0:
                    if (this._separateAxes) {
                        for (e = 0, t = this._gradientX.gradientCount; e < t; e++) r = Math.max(r, this._gradientX.getValueByIndex(e));
                        for (e = 0, t = this._gradientY.gradientCount; e < t; e++) r = Math.max(r, this._gradientY.getValueByIndex(e));
                    } else
                        for (e = 0, t = this._gradient.gradientCount; e < t; e++) r = Math.max(r, this._gradient.getValueByIndex(e));
                    break;

                case 1:
                    this._separateAxes ? (r = Math.max(this._constantMinSeparate.x, this._constantMaxSeparate.x),
                        r = Math.max(r, this._constantMinSeparate.y), r = Math.max(r, this._constantMaxSeparate.y)) : r = Math.max(this._constantMin, this._constantMax);
                    break;

                case 2:
                    if (this._separateAxes) {
                        for (e = 0, t = this._gradientXMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientXMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientXMax.getValueByIndex(e));
                        for (e = 0, t = this._gradientYMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientYMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientZMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientZMax.getValueByIndex(e));
                    } else {
                        for (e = 0, t = this._gradientMin.gradientCount; e < t; e++) r = Math.max(r, this._gradientMin.getValueByIndex(e));
                        for (e = 0, t = this._gradientMax.gradientCount; e < t; e++) r = Math.max(r, this._gradientMax.getValueByIndex(e));
                    }
            }
            return r;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._separateAxes = this._separateAxes, this._gradient.cloneTo(t._gradient),
                this._gradientX.cloneTo(t._gradientX), this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ),
                t._constantMin = this._constantMin, t._constantMax = this._constantMax, this._constantMinSeparate.cloneTo(t._constantMinSeparate),
                this._constantMaxSeparate.cloneTo(t._constantMaxSeparate), this._gradientMin.cloneTo(t._gradientMin),
                this._gradientMax.cloneTo(t._gradientMax), this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new dt();
            return this.cloneTo(e), e;
        }
    }
    class ut {
        constructor() {
            this._type = 0, this._constant = null, this._gradientX = null, this._gradientY = null,
                this._gradientZ = null, this._constantMin = null, this._constantMax = null, this._gradientXMin = null,
                this._gradientXMax = null, this._gradientYMin = null, this._gradientYMax = null,
                this._gradientZMin = null, this._gradientZMax = null;
        }
        static createByConstant(e) {
            var t = new ut();
            return t._type = 0, t._constant = e, t;
        }
        static createByGradient(e, t, r) {
            var i = new ut();
            return i._type = 1, i._gradientX = e, i._gradientY = t, i._gradientZ = r, i;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new ut();
            return r._type = 2, r._constantMin = e, r._constantMax = t, r;
        }
        static createByRandomTwoGradient(e, t, r, i, n, a) {
            var s = new ut();
            return s._type = 3, s._gradientXMin = e, s._gradientXMax = t, s._gradientYMin = r,
                s._gradientYMax = i, s._gradientZMin = n, s._gradientZMax = a, s;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get gradientX() {
            return this._gradientX;
        }
        get gradientY() {
            return this._gradientY;
        }
        get gradientZ() {
            return this._gradientZ;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        get gradientXMin() {
            return this._gradientXMin;
        }
        get gradientXMax() {
            return this._gradientXMax;
        }
        get gradientYMin() {
            return this._gradientYMin;
        }
        get gradientYMax() {
            return this._gradientYMax;
        }
        get gradientZMin() {
            return this._gradientZMin;
        }
        get gradientZMax() {
            return this._gradientZMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, this._constant.cloneTo(t._constant), this._gradientX.cloneTo(t._gradientX),
                this._gradientY.cloneTo(t._gradientY), this._gradientZ.cloneTo(t._gradientZ), this._constantMin.cloneTo(t._constantMin),
                this._constantMax.cloneTo(t._constantMax), this._gradientXMin.cloneTo(t._gradientXMin),
                this._gradientXMax.cloneTo(t._gradientXMax), this._gradientYMin.cloneTo(t._gradientYMin),
                this._gradientYMax.cloneTo(t._gradientYMax), this._gradientZMin.cloneTo(t._gradientZMin),
                this._gradientZMax.cloneTo(t._gradientZMax);
        }
        clone() {
            var e = new ut();
            return this.cloneTo(e), e;
        }
    }
    class ft {
        get angularVelocity() {
            return this._angularVelocity;
        }
        constructor(e) {
            this._angularVelocity = e;
        }
        cloneTo(e) {
            var t = e;
            this._angularVelocity.cloneTo(t._angularVelocity), t.enbale = this.enbale;
        }
        clone() {
            var e;
            switch (this._angularVelocity.type) {
                case 0:
                    e = this._angularVelocity.separateAxes ? ht.createByConstantSeparate(this._angularVelocity.constantSeparate.clone()) : ht.createByConstant(this._angularVelocity.constant);
                    break;

                case 1:
                    e = this._angularVelocity.separateAxes ? ht.createByGradientSeparate(this._angularVelocity.gradientX.clone(), this._angularVelocity.gradientY.clone(), this._angularVelocity.gradientZ.clone()) : ht.createByGradient(this._angularVelocity.gradient.clone());
                    break;

                case 2:
                    e = this._angularVelocity.separateAxes ? ht.createByRandomTwoConstantSeparate(this._angularVelocity.constantMinSeparate.clone(), this._angularVelocity.constantMaxSeparate.clone()) : ht.createByRandomTwoConstant(this._angularVelocity.constantMin, this._angularVelocity.constantMax);
                    break;

                case 3:
                    e = this._angularVelocity.separateAxes ? ht.createByRandomTwoGradientSeparate(this._angularVelocity.gradientXMin.clone(), this._angularVelocity.gradientYMin.clone(), this._angularVelocity.gradientZMin.clone(), this._angularVelocity.gradientWMin.clone(), this._angularVelocity.gradientXMax.clone(), this._angularVelocity.gradientYMax.clone(), this._angularVelocity.gradientZMax.clone(), this._angularVelocity.gradientWMax.clone()) : ht.createByRandomTwoGradient(this._angularVelocity.gradientMin.clone(), this._angularVelocity.gradientMax.clone());
            }
            var t = new ft(e);
            return t.enbale = this.enbale, t;
        }
    }
    class Et {
        constructor() {}
        _getShapeBoundBox(e) {
            throw new Error("BaseShape: must override it.");
        }
        _getSpeedBoundBox(e) {
            throw new Error("BaseShape: must override it.");
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            throw new Error("BaseShape: must override it.");
        }
        _calculateProceduralBounds(e, t, r) {
            this._getShapeBoundBox(e);
            var i = e.min,
                n = e.max;
            a.multiply(i, t, i), a.multiply(n, t, n);
            var s = new Oe(new a(), new a());
            this.randomDirection ? (s.min = new a(-1, -1, -1), s.max = new a(1, 1, 1)) : this._getSpeedBoundBox(s);
            var o = new Oe(new a(), new a()),
                l = o.min,
                _ = o.max;
            a.scale(s.min, r.y, l), a.scale(s.max, r.y, _), a.add(e.min, l, l), a.add(e.max, _, _),
                a.min(e.min, l, e.min), a.max(e.max, l, e.max);
            var h = new Oe(new a(), new a()),
                c = h.min,
                d = h.max;
            a.scale(s.min, r.x, c), a.scale(s.max, r.x, d), a.min(h.min, d, l), a.max(h.min, d, _),
                a.min(e.min, l, e.min), a.max(e.max, l, e.max);
        }
        cloneTo(e) {
            e.enable = this.enable;
        }
        clone() {
            var e = new Et();
            return this.cloneTo(e), e;
        }
    }
    class Tt {
        static _randomPointUnitArcCircle(e, t, r = null) {
            var i;
            i = r ? r.getFloat() * e : Math.random() * e, t.x = Math.cos(i), t.y = Math.sin(i);
        }
        static _randomPointInsideUnitArcCircle(e, t, r = null) {
            var i;
            Tt._randomPointUnitArcCircle(e, t, r), i = r ? Math.pow(r.getFloat(), .5) : Math.pow(Math.random(), .5),
                t.x = t.x * i, t.y = t.y * i;
        }
        static _randomPointUnitCircle(e, t = null) {
            var r;
            r = t ? t.getFloat() * Math.PI * 2 : Math.random() * Math.PI * 2, e.x = Math.cos(r),
                e.y = Math.sin(r);
        }
        static _randomPointInsideUnitCircle(e, t = null) {
            var r;
            Tt._randomPointUnitCircle(e), r = t ? Math.pow(t.getFloat(), .5) : Math.pow(Math.random(), .5),
                e.x = e.x * r, e.y = e.y * r;
        }
        static _randomPointUnitSphere(e, t = null) {
            var r, i;
            t ? (r = e.z = 2 * t.getFloat() - 1, i = t.getFloat() * Math.PI * 2) : (r = e.z = 2 * Math.random() - 1,
                i = Math.random() * Math.PI * 2);
            var n = Math.sqrt(1 - r * r);
            e.x = n * Math.cos(i), e.y = n * Math.sin(i);
        }
        static _randomPointInsideUnitSphere(e, t = null) {
            var r;
            Tt._randomPointUnitSphere(e), r = t ? Math.pow(t.getFloat(), 1 / 3) : Math.pow(Math.random(), 1 / 3),
                e.x = e.x * r, e.y = e.y * r, e.z = e.z * r;
        }
        static _randomPointInsideHalfUnitBox(e, t = null) {
            t ? (e.x = t.getFloat() - .5, e.y = t.getFloat() - .5, e.z = t.getFloat() - .5) : (e.x = Math.random() - .5,
                e.y = Math.random() - .5, e.z = Math.random() - .5);
        }
        constructor() {}
    }
    class mt extends Et {
        constructor() {
            super(), this.x = 1, this.y = 1, this.z = 1, this.randomDirection = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = .5 * -this.x, t.y = .5 * -this.y, t.z = .5 * -this.z;
            var r = e.max;
            r.x = .5 * this.x, r.y = .5 * this.y, r.z = .5 * this.z;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = 0, t.y = 0, t.z = 0;
            var r = e.max;
            r.x = 0, r.y = 1, r.z = 0;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], Tt._randomPointInsideHalfUnitBox(e, r), i[16] = r.seed) : Tt._randomPointInsideHalfUnitBox(e),
                e.x = this.x * e.x, e.y = this.y * e.y, e.z = this.z * e.z, this.randomDirection ? r ? (r.seed = i[17],
                    Tt._randomPointUnitSphere(t, r), i[17] = r.seed) : Tt._randomPointUnitSphere(t) : (t.x = 0,
                    t.y = 0, t.z = 1);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.x = this.x, t.y = this.y, t.z = this.z, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new mt();
            return this.cloneTo(e), e;
        }
    }
    class pt extends Et {
        constructor() {
            super(), this.radius = 1, this.arc = 2 * Math.PI, this.emitFromEdge = !1, this.randomDirection = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.z = -this.radius, t.y = 0;
            var r = e.max;
            r.x = r.z = this.radius, r.y = 0;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var r = e.max;
            r.x = r.y = 1, r.z = 0;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            var n = pt._tempPositionPoint;
            r ? (r.seed = i[16], this.emitFromEdge ? Tt._randomPointUnitArcCircle(this.arc, pt._tempPositionPoint, r) : Tt._randomPointInsideUnitArcCircle(this.arc, pt._tempPositionPoint, r),
                    i[16] = r.seed) : this.emitFromEdge ? Tt._randomPointUnitArcCircle(this.arc, pt._tempPositionPoint) : Tt._randomPointInsideUnitArcCircle(this.arc, pt._tempPositionPoint),
                e.x = -n.x, e.y = n.y, e.z = 0, a.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17],
                    Tt._randomPointUnitSphere(t, r), i[17] = r.seed) : Tt._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.arc = this.arc, t.emitFromEdge = this.emitFromEdge, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new pt();
            return this.cloneTo(e), e;
        }
    }
    pt._tempPositionPoint = new i();
    class gt extends Et {
        constructor() {
            super(), this.angle = 25 / 180 * Math.PI, this.radius = 1, this.length = 5, this.emitType = 0,
                this.randomDirection = !1;
        }
        _getShapeBoundBox(e) {
            const t = this.radius + this.length * Math.sin(this.angle),
                r = this.length * Math.cos(this.angle);
            var i = e.min;
            i.x = i.y = -t, i.z = 0;
            var n = e.max;
            n.x = n.y = t, n.z = r;
        }
        _getSpeedBoundBox(e) {
            const t = Math.sin(this.angle);
            var r = e.min;
            r.x = r.y = -t, r.z = 0;
            var i = e.max;
            i.x = i.y = t, i.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            var n, s, o, l = gt._tempPositionPoint,
                _ = Math.cos(this.angle),
                h = Math.sin(this.angle);
            switch (this.emitType) {
                case 0:
                    r ? (r.seed = i[16], Tt._randomPointInsideUnitCircle(gt._tempPositionPoint, r),
                            i[16] = r.seed) : Tt._randomPointInsideUnitCircle(gt._tempPositionPoint), n = l.x,
                        s = l.y, e.x = n * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17],
                                Tt._randomPointInsideUnitCircle(gt._tempDirectionPoint, r), i[17] = r.seed) : Tt._randomPointInsideUnitCircle(gt._tempDirectionPoint),
                            o = gt._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = n * h, t.y = s * h),
                        t.z = _;
                    break;

                case 1:
                    r ? (r.seed = i[16], Tt._randomPointUnitCircle(gt._tempPositionPoint, r), i[16] = r.seed) : Tt._randomPointUnitCircle(gt._tempPositionPoint),
                        n = l.x, s = l.y, e.x = n * this.radius, e.y = s * this.radius, e.z = 0, this.randomDirection ? (r ? (r.seed = i[17],
                                Tt._randomPointInsideUnitCircle(gt._tempDirectionPoint, r), i[17] = r.seed) : Tt._randomPointInsideUnitCircle(gt._tempDirectionPoint),
                            o = gt._tempDirectionPoint, t.x = o.x * h, t.y = o.y * h) : (t.x = n * h, t.y = s * h),
                        t.z = _;
                    break;

                case 2:
                    r ? (r.seed = i[16], Tt._randomPointInsideUnitCircle(gt._tempPositionPoint, r)) : Tt._randomPointInsideUnitCircle(gt._tempPositionPoint),
                        n = l.x, s = l.y, e.x = n * this.radius, e.y = s * this.radius, e.z = 0, t.x = n * h,
                        t.y = s * h, t.z = _, a.normalize(t, t), r ? (a.scale(t, this.length * r.getFloat(), t),
                            i[16] = r.seed) : a.scale(t, this.length * Math.random(), t), a.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17],
                            Tt._randomPointUnitSphere(t, r), i[17] = r.seed) : Tt._randomPointUnitSphere(t));
                    break;

                case 3:
                    r ? (r.seed = i[16], Tt._randomPointUnitCircle(gt._tempPositionPoint, r)) : Tt._randomPointUnitCircle(gt._tempPositionPoint),
                        n = l.x, s = l.y, e.x = n * this.radius, e.y = s * this.radius, e.z = 0, t.x = n * h,
                        t.y = s * h, t.z = _, a.normalize(t, t), r ? (a.scale(t, this.length * r.getFloat(), t),
                            i[16] = r.seed) : a.scale(t, this.length * Math.random(), t), a.add(e, t, e), this.randomDirection && (r ? (r.seed = i[17],
                            Tt._randomPointUnitSphere(t, r), i[17] = r.seed) : Tt._randomPointUnitSphere(t));
                    break;

                default:
                    throw new Error("ConeShape:emitType is invalid.");
            }
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.angle = this.angle, t.radius = this.radius, t.length = this.length, t.emitType = this.emitType,
                t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new gt();
            return this.cloneTo(e), e;
        }
    }
    gt._tempPositionPoint = new i(), gt._tempDirectionPoint = new i();
    class St extends Et {
        constructor() {
            super(), this.radius = 1, this.emitFromShell = !1, this.randomDirection = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var r = e.max;
            r.x = r.y = this.radius, r.z = 0;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = -1, t.z = 0;
            var r = e.max;
            r.x = r.y = r.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], this.emitFromShell ? Tt._randomPointUnitSphere(e, r) : Tt._randomPointInsideUnitSphere(e, r),
                    i[16] = r.seed) : this.emitFromShell ? Tt._randomPointUnitSphere(e) : Tt._randomPointInsideUnitSphere(e),
                a.scale(e, this.radius, e);
            var n = e.z;
            n < 0 && (e.z = -1 * n), this.randomDirection ? r ? (r.seed = i[17], Tt._randomPointUnitSphere(t, r),
                i[17] = r.seed) : Tt._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new St();
            return this.cloneTo(e), e;
        }
    }
    class vt extends Et {
        constructor() {
            super(), this.radius = 1, this.emitFromShell = !1, this.randomDirection = !1;
        }
        _getShapeBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -this.radius;
            var r = e.max;
            r.x = r.y = r.z = this.radius;
        }
        _getSpeedBoundBox(e) {
            var t = e.min;
            t.x = t.y = t.z = -1;
            var r = e.max;
            r.x = r.y = r.z = 1;
        }
        generatePositionAndDirection(e, t, r = null, i = null) {
            r ? (r.seed = i[16], this.emitFromShell ? Tt._randomPointUnitSphere(e, r) : Tt._randomPointInsideUnitSphere(e, r),
                    i[16] = r.seed) : this.emitFromShell ? Tt._randomPointUnitSphere(e) : Tt._randomPointInsideUnitSphere(e),
                a.scale(e, this.radius, e), this.randomDirection ? r ? (r.seed = i[17], Tt._randomPointUnitSphere(t, r),
                    i[17] = r.seed) : Tt._randomPointUnitSphere(t) : e.cloneTo(t);
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.radius = this.radius, t.emitFromShell = this.emitFromShell, t.randomDirection = this.randomDirection;
        }
        clone() {
            var e = new vt();
            return this.cloneTo(e), e;
        }
    }
    class Rt {
        get size() {
            return this._size;
        }
        constructor(e) {
            this._size = e;
        }
        cloneTo(e) {
            var t = e;
            this._size.cloneTo(t._size), t.enbale = this.enbale;
        }
        clone() {
            var e;
            switch (this._size.type) {
                case 0:
                    e = this._size.separateAxes ? dt.createByGradientSeparate(this._size.gradientX.clone(), this._size.gradientY.clone(), this._size.gradientZ.clone()) : dt.createByGradient(this._size.gradient.clone());
                    break;

                case 1:
                    e = this._size.separateAxes ? dt.createByRandomTwoConstantSeparate(this._size.constantMinSeparate.clone(), this._size.constantMaxSeparate.clone()) : dt.createByRandomTwoConstant(this._size.constantMin, this._size.constantMax);
                    break;

                case 2:
                    e = this._size.separateAxes ? dt.createByRandomTwoGradientSeparate(this._size.gradientXMin.clone(), this._size.gradientYMin.clone(), this._size.gradientZMin.clone(), this._size.gradientXMax.clone(), this._size.gradientYMax.clone(), this._size.gradientZMax.clone()) : dt.createByRandomTwoGradient(this._size.gradientMin.clone(), this._size.gradientMax.clone());
            }
            var t = new Rt(e);
            return t.enbale = this.enbale, t;
        }
    }
    class At {
        constructor() {
            this._type = 0, this._constant = 0, this._constantMin = 0, this._constantMax = 0;
        }
        static createByConstant(e) {
            var t = new At();
            return t._type = 0, t._constant = e, t;
        }
        static createByRandomTwoConstant(e, t) {
            var r = new At();
            return r._type = 1, r._constantMin = e, r._constantMax = t, r;
        }
        get type() {
            return this._type;
        }
        get constant() {
            return this._constant;
        }
        get constantMin() {
            return this._constantMin;
        }
        get constantMax() {
            return this._constantMax;
        }
        cloneTo(e) {
            var t = e;
            t._type = this._type, t._constant = this._constant, t._constantMin = this._constantMin,
                t._constantMax = this._constantMax;
        }
        clone() {
            var e = new At();
            return this.cloneTo(e), e;
        }
    }
    class Dt {
        constructor(e, t) {
            this.type = 0, this.randomRow = !1, this.rowIndex = 0, this.cycles = 0, this.enableUVChannels = 0,
                this.enable = !1, this.tiles = new i(1, 1), this.type = 0, this.randomRow = !0,
                this.rowIndex = 0, this.cycles = 1, this.enableUVChannels = 1, this._frame = e,
                this._startFrame = t;
        }
        get frame() {
            return this._frame;
        }
        get startFrame() {
            return this._startFrame;
        }
        cloneTo(e) {
            var t = e;
            this.tiles.cloneTo(t.tiles), t.type = this.type, t.randomRow = this.randomRow, t.rowIndex = this.rowIndex,
                t.cycles = this.cycles, t.enableUVChannels = this.enableUVChannels, t.enable = this.enable,
                this._frame.cloneTo(t._frame), this._startFrame.cloneTo(t._startFrame);
        }
        clone() {
            var e, t;
            switch (this._frame.type) {
                case 0:
                    e = _t.createByConstant(this._frame.constant);
                    break;

                case 1:
                    e = _t.createByOverTime(this._frame.frameOverTimeData.clone());
                    break;

                case 2:
                    e = _t.createByRandomTwoConstant(this._frame.constantMin, this._frame.constantMax);
                    break;

                case 3:
                    e = _t.createByRandomTwoOverTime(this._frame.frameOverTimeDataMin.clone(), this._frame.frameOverTimeDataMax.clone());
            }
            switch (this._startFrame.type) {
                case 0:
                    t = At.createByConstant(this._startFrame.constant);
                    break;

                case 1:
                    t = At.createByRandomTwoConstant(this._startFrame.constantMin, this._startFrame.constantMax);
            }
            var r = new Dt(e, t);
            return this.cloneTo(r), r;
        }
    }
    class It {
        constructor(e) {
            this.enbale = !1, this.space = 0, this._velocity = e;
        }
        get velocity() {
            return this._velocity;
        }
        cloneTo(e) {
            var t = e;
            this._velocity.cloneTo(t._velocity), t.enbale = this.enbale, t.space = this.space;
        }
        clone() {
            var e;
            switch (this._velocity.type) {
                case 0:
                    e = ut.createByConstant(this._velocity.constant.clone());
                    break;

                case 1:
                    e = ut.createByGradient(this._velocity.gradientX.clone(), this._velocity.gradientY.clone(), this._velocity.gradientZ.clone());
                    break;

                case 2:
                    e = ut.createByRandomTwoConstant(this._velocity.constantMin.clone(), this._velocity.constantMax.clone());
                    break;

                case 3:
                    e = ut.createByRandomTwoGradient(this._velocity.gradientXMin.clone(), this._velocity.gradientYMin.clone(), this._velocity.gradientZMin.clone(), this._velocity.gradientXMax.clone(), this._velocity.gradientYMax.clone(), this._velocity.gradientZMax.clone());
            }
            var t = new It(e);
            return t.enbale = this.enbale, t.space = this.space, t;
        }
    }
    class xt extends F {
        static __init__() {
            xt.shaderDefines = new C(F.shaderDefines), Ke.SHADERDEFINE_RENDERMODE_BILLBOARD = xt.shaderDefines.registerDefine("SPHERHBILLBOARD"),
                Ke.SHADERDEFINE_RENDERMODE_STRETCHEDBILLBOARD = xt.shaderDefines.registerDefine("STRETCHEDBILLBOARD"),
                Ke.SHADERDEFINE_RENDERMODE_HORIZONTALBILLBOARD = xt.shaderDefines.registerDefine("HORIZONTALBILLBOARD"),
                Ke.SHADERDEFINE_RENDERMODE_VERTICALBILLBOARD = xt.shaderDefines.registerDefine("VERTICALBILLBOARD"),
                Ke.SHADERDEFINE_COLOROVERLIFETIME = xt.shaderDefines.registerDefine("COLOROVERLIFETIME"),
                Ke.SHADERDEFINE_RANDOMCOLOROVERLIFETIME = xt.shaderDefines.registerDefine("RANDOMCOLOROVERLIFETIME"),
                Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECONSTANT = xt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECONSTANT"),
                Ke.SHADERDEFINE_VELOCITYOVERLIFETIMECURVE = xt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMECURVE"),
                Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCONSTANT = xt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCONSTANT"),
                Ke.SHADERDEFINE_VELOCITYOVERLIFETIMERANDOMCURVE = xt.shaderDefines.registerDefine("VELOCITYOVERLIFETIMERANDOMCURVE"),
                Ke.SHADERDEFINE_TEXTURESHEETANIMATIONCURVE = xt.shaderDefines.registerDefine("TEXTURESHEETANIMATIONCURVE"),
                Ke.SHADERDEFINE_TEXTURESHEETANIMATIONRANDOMCURVE = xt.shaderDefines.registerDefine("TEXTURESHEETANIMATIONRANDOMCURVE"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIME = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIME"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIMESEPERATE = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMESEPERATE"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECONSTANT = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECONSTANT"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIMECURVE = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMECURVE"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCONSTANTS = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCONSTANTS"),
                Ke.SHADERDEFINE_ROTATIONOVERLIFETIMERANDOMCURVES = xt.shaderDefines.registerDefine("ROTATIONOVERLIFETIMERANDOMCURVES"),
                Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVE = xt.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVE"),
                Ke.SHADERDEFINE_SIZEOVERLIFETIMECURVESEPERATE = xt.shaderDefines.registerDefine("SIZEOVERLIFETIMECURVESEPERATE"),
                Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVES = xt.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVES"),
                Ke.SHADERDEFINE_SIZEOVERLIFETIMERANDOMCURVESSEPERATE = xt.shaderDefines.registerDefine("SIZEOVERLIFETIMERANDOMCURVESSEPERATE"),
                Ke.SHADERDEFINE_RENDERMODE_MESH = xt.shaderDefines.registerDefine("RENDERMODE_MESH"),
                Ke.SHADERDEFINE_SHAPE = xt.shaderDefines.registerDefine("SHAPE");
        }
        get particleSystem() {
            return this._particleSystem;
        }
        get particleRenderer() {
            return this._render;
        }
        constructor() {
            super(null), this._render = new Qe(this), this._particleSystem = new at(this);
            var e = this._render._renderElements[0] = new le();
            e.setTransform(this._transform), e.render = this._render, e.setGeometry(this._particleSystem),
                e.material = qe.defaultMaterial;
        }
        static _initStartLife(e) {
            for (var t = new et(), r = e.startLifetimes, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                t.add(a.key, a.value);
            }
            return t;
        }
        _initParticleVelocity(e) {
            for (var t = new et(), r = e.velocitys, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                t.add(a.key, a.value);
            }
            return t;
        }
        _initParticleColor(e) {
            var t, r, i = new je(4, 4),
                n = e.alphas;
            for (t = 0, r = n.length; t < r; t++) {
                var a = n[t];
                3 === t && 1 !== a.key && (a.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")),
                    i.addColorAlpha(a.key, a.value);
            }
            var s = e.rgbs;
            for (t = 0, r = s.length; t < r; t++) {
                var o = s[t],
                    l = o.value;
                3 === t && 1 !== o.key && (o.key = 1, console.log("GradientDataColor warning:the forth key is  be force set to 1.")),
                    i.addColorRGB(o.key, new I(l[0], l[1], l[2], 1));
            }
            return i;
        }
        _initParticleSize(e) {
            for (var t = new et(), r = e.sizes, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                t.add(a.key, a.value);
            }
            return t;
        }
        _initParticleRotation(e) {
            for (var t = new et(), r = e.angularVelocitys, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                t.add(a.key, a.value / 180 * Math.PI);
            }
            return t;
        }
        _initParticleFrame(e) {
            for (var t = new ct(), r = e.frames, i = 0, n = r.length; i < n; i++) {
                var a = r[i];
                t.add(a.key, a.value);
            }
            return t;
        }
        _parse(e, r) {
            super._parse(e, r);
            const s = Math.PI / 180;
            var o, l, _, h = this.particleRenderer,
                c = e.material;
            c && (_ = t.Loader.getRes(c.path)), h.sharedMaterial = _;
            var d = e.meshPath;
            d && (h.mesh = t.Loader.getRes(d)), h.renderMode = e.renderMode, h.stretchedBillboardCameraSpeedScale = e.stretchedBillboardCameraSpeedScale,
                h.stretchedBillboardSpeedScale = e.stretchedBillboardSpeedScale, h.stretchedBillboardLengthScale = e.stretchedBillboardLengthScale,
                h.sortingFudge = e.sortingFudge ? e.sortingFudge : 0;
            var u = this.particleSystem;
            u.isPerformanceMode = e.isPerformanceMode, u.duration = e.duration, u.looping = e.looping,
                u.prewarm = e.prewarm, u.startDelayType = e.startDelayType, u.startDelay = e.startDelay,
                u.startDelayMin = e.startDelayMin, u.startDelayMax = e.startDelayMax, u.startLifetimeType = e.startLifetimeType,
                u.startLifetimeConstant = e.startLifetimeConstant, u.startLifeTimeGradient = xt._initStartLife(e.startLifetimeGradient),
                u.startLifetimeConstantMin = e.startLifetimeConstantMin, u.startLifetimeConstantMax = e.startLifetimeConstantMax,
                u.startLifeTimeGradientMin = xt._initStartLife(e.startLifetimeGradientMin), u.startLifeTimeGradientMax = xt._initStartLife(e.startLifetimeGradientMax),
                u.startSpeedType = e.startSpeedType, u.startSpeedConstant = e.startSpeedConstant,
                u.startSpeedConstantMin = e.startSpeedConstantMin, u.startSpeedConstantMax = e.startSpeedConstantMax,
                u.threeDStartSize = e.threeDStartSize, u.startSizeType = e.startSizeType, u.startSizeConstant = e.startSizeConstant;
            var f = e.startSizeConstantSeparate,
                E = u.startSizeConstantSeparate;
            E.x = f[0], E.y = f[1], E.z = f[2], u.startSizeConstantMin = e.startSizeConstantMin,
                u.startSizeConstantMax = e.startSizeConstantMax;
            var T = e.startSizeConstantMinSeparate,
                m = u.startSizeConstantMinSeparate;
            m.x = T[0], m.y = T[1], m.z = T[2];
            var p = e.startSizeConstantMaxSeparate,
                g = u.startSizeConstantMaxSeparate;
            g.x = p[0], g.y = p[1], g.z = p[2], u.threeDStartRotation = e.threeDStartRotation,
                u.startRotationType = e.startRotationType, u.startRotationConstant = e.startRotationConstant * s;
            var S = e.startRotationConstantSeparate,
                v = u.startRotationConstantSeparate;
            v.x = S[0] * s, v.y = S[1] * s, v.z = S[2] * s, u.startRotationConstantMin = e.startRotationConstantMin * s,
                u.startRotationConstantMax = e.startRotationConstantMax * s;
            var R = e.startRotationConstantMinSeparate,
                A = u.startRotationConstantMinSeparate;
            A.x = R[0] * s, A.y = R[1] * s, A.z = R[2] * s;
            var D = e.startRotationConstantMaxSeparate,
                I = u.startRotationConstantMaxSeparate;
            I.x = D[0] * s, I.y = D[1] * s, I.z = D[2] * s, u.randomizeRotationDirection = e.randomizeRotationDirection,
                u.startColorType = e.startColorType;
            var x = e.startColorConstant,
                M = u.startColorConstant;
            M.x = x[0], M.y = x[1], M.z = x[2], M.w = x[3];
            var L = e.startColorConstantMin,
                C = u.startColorConstantMin;
            C.x = L[0], C.y = L[1], C.z = L[2], C.w = L[3];
            var y = e.startColorConstantMax,
                O = u.startColorConstantMax;
            O.x = y[0], O.y = y[1], O.z = y[2], O.w = y[3], u.gravityModifier = e.gravityModifier,
                u.simulationSpace = e.simulationSpace, u.scaleMode = e.scaleMode, u.playOnAwake = e.playOnAwake,
                u.maxParticles = e.maxParticles;
            var N = e.autoRandomSeed;
            null != N && (u.autoRandomSeed = N);
            var P = e.randomSeed;
            null != P && (u.randomSeed[0] = P);
            var V = e.emission,
                w = u.emission;
            if (V) {
                w.emissionRate = V.emissionRate;
                var b = V.bursts;
                if (b)
                    for (o = 0, l = b.length; o < l; o++) {
                        var F = b[o];
                        w.addBurst(new st(F.time, F.min, F.max));
                    }
                w.enbale = V.enable;
            } else w.enbale = !1;
            var B = e.shape;
            if (B) {
                var U;
                switch (B.shapeType) {
                    case 0:
                        var G;
                        U = G = new vt(), G.radius = B.sphereRadius, G.emitFromShell = B.sphereEmitFromShell,
                            G.randomDirection = B.sphereRandomDirection;
                        break;

                    case 1:
                        var z;
                        U = z = new St(), z.radius = B.hemiSphereRadius, z.emitFromShell = B.hemiSphereEmitFromShell,
                            z.randomDirection = B.hemiSphereRandomDirection;
                        break;

                    case 2:
                        var H;
                        U = H = new gt(), H.angle = B.coneAngle * s, H.radius = B.coneRadius, H.length = B.coneLength,
                            H.emitType = B.coneEmitType, H.randomDirection = B.coneRandomDirection;
                        break;

                    case 3:
                        var W;
                        U = W = new mt(), W.x = B.boxX, W.y = B.boxY, W.z = B.boxZ, W.randomDirection = B.boxRandomDirection;
                        break;

                    case 7:
                        var k;
                        U = k = new pt(), k.radius = B.circleRadius, k.arc = B.circleArc * s, k.emitFromEdge = B.circleEmitFromEdge,
                            k.randomDirection = B.circleRandomDirection;
                        break;

                    default:
                        var X;
                        U = X = new pt(), X.radius = B.circleRadius, X.arc = B.circleArc * s, X.emitFromEdge = B.circleEmitFromEdge,
                            X.randomDirection = B.circleRandomDirection;
                }
                U.enable = B.enable, u.shape = U;
            }
            var Y = e.velocityOverLifetime;
            if (Y) {
                var Z, j = Y.velocity;
                switch (j.type) {
                    case 0:
                        var q = j.constant;
                        Z = ut.createByConstant(new a(q[0], q[1], q[2]));
                        break;

                    case 1:
                        Z = ut.createByGradient(this._initParticleVelocity(j.gradientX), this._initParticleVelocity(j.gradientY), this._initParticleVelocity(j.gradientZ));
                        break;

                    case 2:
                        var K = j.constantMin,
                            Q = j.constantMax;
                        Z = ut.createByRandomTwoConstant(new a(K[0], K[1], K[2]), new a(Q[0], Q[1], Q[2]));
                        break;

                    case 3:
                        Z = ut.createByRandomTwoGradient(this._initParticleVelocity(j.gradientXMin), this._initParticleVelocity(j.gradientXMax), this._initParticleVelocity(j.gradientYMin), this._initParticleVelocity(j.gradientYMax), this._initParticleVelocity(j.gradientZMin), this._initParticleVelocity(j.gradientZMax));
                }
                var J = new It(Z);
                J.space = Y.space, J.enbale = Y.enable, u.velocityOverLifetime = J;
            }
            var $ = e.colorOverLifetime;
            if ($) {
                var ee, te = $.color;
                switch (te.type) {
                    case 0:
                        var re = te.constant;
                        ee = ot.createByConstant(new n(re[0], re[1], re[2], re[3]));
                        break;

                    case 1:
                        ee = ot.createByGradient(this._initParticleColor(te.gradient));
                        break;

                    case 2:
                        var ie = te.constantMin,
                            ne = te.constantMax;
                        ee = ot.createByRandomTwoConstant(new n(ie[0], ie[1], ie[2], ie[3]), new n(ne[0], ne[1], ne[2], ne[3]));
                        break;

                    case 3:
                        ee = ot.createByRandomTwoGradient(this._initParticleColor(te.gradientMin), this._initParticleColor(te.gradientMax));
                }
                var ae = new lt(ee);
                ae.enbale = $.enable, u.colorOverLifetime = ae;
            }
            var se = e.sizeOverLifetime;
            if (se) {
                var oe, le = se.size;
                switch (le.type) {
                    case 0:
                        oe = le.separateAxes ? dt.createByGradientSeparate(this._initParticleSize(le.gradientX), this._initParticleSize(le.gradientY), this._initParticleSize(le.gradientZ)) : dt.createByGradient(this._initParticleSize(le.gradient));
                        break;

                    case 1:
                        if (le.separateAxes) {
                            var _e = le.constantMinSeparate,
                                he = le.constantMaxSeparate;
                            oe = dt.createByRandomTwoConstantSeparate(new a(_e[0], _e[1], _e[2]), new a(he[0], he[1], he[2]));
                        } else oe = dt.createByRandomTwoConstant(le.constantMin, le.constantMax);
                        break;

                    case 2:
                        oe = le.separateAxes ? dt.createByRandomTwoGradientSeparate(this._initParticleSize(le.gradientXMin), this._initParticleSize(le.gradientYMin), this._initParticleSize(le.gradientZMin), this._initParticleSize(le.gradientXMax), this._initParticleSize(le.gradientYMax), this._initParticleSize(le.gradientZMax)) : dt.createByRandomTwoGradient(this._initParticleSize(le.gradientMin), this._initParticleSize(le.gradientMax));
                }
                var ce = new Rt(oe);
                ce.enbale = se.enable, u.sizeOverLifetime = ce;
            }
            var de = e.rotationOverLifetime;
            if (de) {
                var ue, fe = de.angularVelocity;
                switch (fe.type) {
                    case 0:
                        if (fe.separateAxes) {
                            var Ee = fe.constantSeparate;
                            ue = ht.createByConstantSeparate(new a(Ee[0] * s, Ee[1] * s, Ee[2] * s));
                        } else ue = ht.createByConstant(fe.constant * s);
                        break;

                    case 1:
                        ue = fe.separateAxes ? ht.createByGradientSeparate(this._initParticleRotation(fe.gradientX), this._initParticleRotation(fe.gradientY), this._initParticleRotation(fe.gradientZ)) : ht.createByGradient(this._initParticleRotation(fe.gradient));
                        break;

                    case 2:
                        if (fe.separateAxes) {
                            var Te = fe.constantMinSeparate,
                                me = fe.constantMaxSeparate;
                            ue = ht.createByRandomTwoConstantSeparate(new a(Te[0] * s, Te[1] * s, Te[2] * s), new a(me[0] * s, me[1] * s, me[2] * s));
                        } else ue = ht.createByRandomTwoConstant(fe.constantMin * s, fe.constantMax * s);
                        break;

                    case 3:
                        fe.separateAxes || (ue = ht.createByRandomTwoGradient(this._initParticleRotation(fe.gradientMin), this._initParticleRotation(fe.gradientMax)));
                }
                var pe = new ft(ue);
                pe.enbale = de.enable, u.rotationOverLifetime = pe;
            }
            var ge = e.textureSheetAnimation;
            if (ge) {
                var Se, ve = ge.frame;
                switch (ve.type) {
                    case 0:
                        Se = _t.createByConstant(ve.constant);
                        break;

                    case 1:
                        Se = _t.createByOverTime(this._initParticleFrame(ve.overTime));
                        break;

                    case 2:
                        Se = _t.createByRandomTwoConstant(ve.constantMin, ve.constantMax);
                        break;

                    case 3:
                        Se = _t.createByRandomTwoOverTime(this._initParticleFrame(ve.overTimeMin), this._initParticleFrame(ve.overTimeMax));
                }
                var Re, Ae = ge.startFrame;
                switch (Ae.type) {
                    case 0:
                        Re = At.createByConstant(Ae.constant);
                        break;

                    case 1:
                        Re = At.createByRandomTwoConstant(Ae.constantMin, Ae.constantMax);
                }
                var De = new Dt(Se, Re);
                De.enable = ge.enable;
                var Ie = ge.tiles;
                De.tiles = new i(Ie[0], Ie[1]), De.type = ge.type, De.randomRow = ge.randomRow;
                var xe = ge.rowIndex;
                void 0 !== xe && (De.rowIndex = xe), De.cycles = ge.cycles, u.textureSheetAnimation = De;
            }
        }
        _activeHierarchy(e) {
            super._activeHierarchy(e), this.particleSystem.playOnAwake && this.particleSystem.play();
        }
        _inActiveHierarchy(e) {
            super._inActiveHierarchy(e), this.particleSystem.isAlive && this.particleSystem.simulate(0, !0);
        }
        _cloneTo(e, t, r) {
            var i = e,
                n = i._particleSystem;
            this._particleSystem.cloneTo(n);
            var a = i._render,
                s = this._render;
            a.sharedMaterials = s.sharedMaterials, a.enable = s.enable, a.renderMode = s.renderMode,
                a.mesh = s.mesh, a.stretchedBillboardCameraSpeedScale = s.stretchedBillboardCameraSpeedScale,
                a.stretchedBillboardSpeedScale = s.stretchedBillboardSpeedScale, a.stretchedBillboardLengthScale = s.stretchedBillboardLengthScale,
                a.sortingFudge = s.sortingFudge, super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._particleSystem.destroy(), this._particleSystem = null);
        }
        _create() {
            return new xt();
        }
    }
    class Mt extends he {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._indexInCastShadowList) throw "CastShadowList:element has  in  CastShadowList.";
            this._add(e), e._indexInCastShadowList = this.length++;
        }
        remove(e) {
            var t = e._indexInCastShadowList;
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._indexInCastShadowList = t;
            }
            e._indexInCastShadowList = -1;
        }
    }
    class Lt extends he {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._getIndexInList()) throw "SimpleSingletonList:" + e + " has  in  SingletonList.";
            this._add(e), e._setIndexInList(this.length++);
        }
        remove(e) {
            var t = e._getIndexInList();
            if (-1 !== t) {
                if (this.length--, t !== this.length) {
                    var r = this.elements[this.length];
                    this.elements[t] = r, r._setIndexInList(t);
                }
                this.elements.length = this.length, e._setIndexInList(-1);
            }
        }
    }
    class Ct {
        constructor() {
            this._pressedSprite = null, this._pressedLoopCount = -1, this.sprite = null, this.mousePositionX = 0,
                this.mousePositionY = 0;
        }
    }
    class yt {
        constructor() {
            this._indexInList = -1, this._identifier = -1, this._position = new i();
        }
        get identifier() {
            return this._identifier;
        }
        get position() {
            return this._position;
        }
        _getIndexInList() {
            return this._indexInList;
        }
        _setIndexInList(e) {
            this._indexInList = e;
        }
    }
    class Ot {
        constructor() {
            this._eventList = [], this._mouseTouch = new Ct(), this._touchPool = [], this._touches = new Lt(),
                this._multiTouchEnabled = !0, this._pushEventList = (e => {
                    e.preventDefault(), this._eventList.push(e);
                }).bind(this);
        }
        __init__(e, t) {
            this._scene = t, e.oncontextmenu = function(e) {
                return !1;
            };
        }
        _onCanvasEvent(e) {
            e.addEventListener("mousedown", this._pushEventList), e.addEventListener("mouseup", this._pushEventList, !0),
                e.addEventListener("mousemove", this._pushEventList, !0), e.addEventListener("touchstart", this._pushEventList),
                e.addEventListener("touchend", this._pushEventList, !0), e.addEventListener("touchmove", this._pushEventList, !0),
                e.addEventListener("touchcancel", this._pushEventList, !0);
        }
        _offCanvasEvent(e) {
            e.removeEventListener("mousedown", this._pushEventList), e.removeEventListener("mouseup", this._pushEventList, !0),
                e.removeEventListener("mousemove", this._pushEventList, !0), e.removeEventListener("touchstart", this._pushEventList),
                e.removeEventListener("touchend", this._pushEventList, !0), e.removeEventListener("touchmove", this._pushEventList, !0),
                e.removeEventListener("touchcancel", this._pushEventList, !0), this._eventList.length = 0,
                this._touches.length = 0;
        }
        touchCount() {
            return this._touches.length;
        }
        get multiTouchEnabled() {
            return this._multiTouchEnabled;
        }
        set multiTouchEnabled(e) {
            this._multiTouchEnabled = e;
        }
        _getTouch(e) {
            var t = this._touchPool[e];
            return t || (t = new yt(), this._touchPool[e] = t, t._identifier = e), t;
        }
        _mouseTouchDown() {
            var e = this._mouseTouch,
                r = e.sprite;
            if (e._pressedSprite = r, e._pressedLoopCount = t.Stat.loopCount, r) {
                var i = r._scripts;
                if (i)
                    for (var n = 0, a = i.length; n < a; n++) i[n].onMouseDown();
            }
        }
        _mouseTouchUp() {
            var e, t, r = this._mouseTouch,
                i = r._pressedSprite;
            r._pressedSprite = null, r._pressedLoopCount = -1;
            var n = r.sprite;
            if (n && n === i) {
                var a = n._scripts;
                if (a)
                    for (e = 0, t = a.length; e < t; e++) a[e].onMouseClick();
            }
            if (i) {
                var s = i._scripts;
                if (s)
                    for (e = 0, t = s.length; e < t; e++) s[e].onMouseUp();
            }
        }
        _mouseTouchRayCast(e) {
            var t = Ot._tempHitResult0,
                r = Ot._tempVector20,
                i = Ot._tempRay0;
            t.succeeded = !1;
            var n = this._mouseTouch.mousePositionX,
                a = this._mouseTouch.mousePositionY;
            r.x = n, r.y = a;
            for (var s = e.length - 1; s >= 0; s--) {
                var o = e[s],
                    l = o.viewport;
                if (r.x >= l.x && r.y >= l.y && r.x <= l.width && r.y <= l.height)
                    if (o.viewportPointToRay(r, i),
                        this._scene._physicsSimulation.rayCast(i, t) || o.clearFlag === Q.CLEARFLAG_SOLIDCOLOR || o.clearFlag === Q.CLEARFLAG_SKY) break;
            }
            var _ = this._mouseTouch,
                h = _.sprite;
            if (t.succeeded) {
                var c = t.collider.owner;
                _.sprite = c;
                var d = c._scripts;
                if (h !== c && d)
                    for (var u = 0, f = d.length; u < f; u++) d[u].onMouseEnter();
            } else _.sprite = null;
            if (h && h !== c) {
                var E = h._scripts;
                if (E)
                    for (u = 0, f = E.length; u < f; u++) E[u].onMouseOut();
            }
        }
        _changeTouches(e, r) {
            for (var i = 0, n = 0, a = this._touches.length, s = 0, o = e.length; s < o; s++) {
                var l = e[s],
                    _ = l.identifier;
                if (this._multiTouchEnabled || 0 === _) {
                    var h = this._getTouch(_),
                        c = h._position,
                        d = Ot._tempPoint;
                    d.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(d);
                    var u = d.x,
                        f = d.y;
                    switch (r) {
                        case 0:
                            this._touches.add(h), i += u, n += f;
                            break;

                        case 1:
                            this._touches.remove(h), i -= u, n -= f;
                            break;

                        case 2:
                            i = u - c.x, n = f - c.y;
                    }
                    c.x = u, c.y = f;
                }
            }
            var E = this._touches.length;
            0 === E ? (this._mouseTouch.mousePositionX = 0, this._mouseTouch.mousePositionY = 0) : (this._mouseTouch.mousePositionX = (this._mouseTouch.mousePositionX * a + i) / E,
                this._mouseTouch.mousePositionY = (this._mouseTouch.mousePositionY * a + n) / E);
        }
        _update() {
            var e, r, i, n, a = fe._enbalePhysics && !ye.disableSimulation;
            r = this._eventList.length;
            var s = this._scene._cameraPool;
            if (r > 0) {
                var o = !1;
                for (e = 0; e < r; e++) {
                    var l = this._eventList[e];
                    switch (l.type) {
                        case "mousedown":
                            a && this._mouseTouchDown();
                            break;

                        case "mouseup":
                            a && this._mouseTouchUp();
                            break;

                        case "mousemove":
                            var _ = Ot._tempPoint;
                            _.setTo(l.pageX, l.pageY), t.ILaya.stage._canvasTransform.invertTransformPoint(_),
                                this._mouseTouch.mousePositionX = _.x, this._mouseTouch.mousePositionY = _.y, a && (o = !0);
                            break;

                        case "touchstart":
                            var h = this._touches.length;
                            this._changeTouches(l.changedTouches, 0), a && (o = !0, 0 === h && this._mouseTouchDown());
                            break;

                        case "touchend":
                        case "touchcancel":
                            this._changeTouches(l.changedTouches, 1), a && 0 === this._touches.length && this._mouseTouchUp();
                            break;

                        case "touchmove":
                            this._changeTouches(l.changedTouches, 2), a && (o = !0);
                            break;

                        default:
                            throw "Input3D:unkonwn event type.";
                    }
                }
                o && this._mouseTouchRayCast(s), this._eventList.length = 0;
            }
            if (a) {
                var c = this._mouseTouch,
                    d = c._pressedSprite;
                if (d && t.Stat.loopCount > c._pressedLoopCount) {
                    var u = d._scripts;
                    if (u)
                        for (i = 0, n = u.length; i < n; i++) u[i].onMouseDrag();
                }
                var f = c.sprite;
                if (f) {
                    var E = f._scripts;
                    if (E)
                        for (i = 0, n = E.length; i < n; i++) E[i].onMouseOver();
                }
            }
        }
        getTouch(e) {
            return e < this._touches.length ? this._touches.elements[e] : null;
        }
    }
    Ot._tempPoint = new t.Point(), Ot._tempVector20 = new i(), Ot._tempRay0 = new z(new a(), new a()),
        Ot._tempHitResult0 = new Me();
    class Nt {
        constructor() {
            this.flags = 0, this.maxSubSteps = 1, this.fixedTimeStep = 1 / 60;
        }
    }
    class Pt {
        static get vertexDeclaration() {
            return Pt._vertexDeclaration;
        }
        static __init__() {
            Pt._vertexDeclaration = new g(20, [new S(0, u.Vector3, v.MESH_POSITION0), new S(12, u.Vector2, v.MESH_TEXTURECOORDINATE0)]);
        }
        get position() {
            return this._position;
        }
        get textureCoordinate0() {
            return this._textureCoordinate0;
        }
        get vertexDeclaration() {
            return Pt._vertexDeclaration;
        }
        constructor(e, t) {
            this._position = e, this._textureCoordinate0 = t;
        }
    }
    class Vt extends j {
        constructor(e = 48, r = 48) {
            super();
            var i = t.LayaGL.instance;
            this._stacks = e, this._slices = r;
            for (var n = Pt.vertexDeclaration, a = n.vertexStride / 4, s = (this._stacks + 1) * (this._slices + 1), o = 3 * this._stacks * (this._slices + 1) * 2, l = new Float32Array(s * a), h = new Uint16Array(o), u = Math.PI / this._stacks, f = 2 * Math.PI / this._slices, E = 0, T = 0, m = 0, p = 0; p < this._stacks + 1; p++)
                for (var g = Math.sin(p * u), S = Math.cos(p * u), v = 0; v < this._slices + 1; v++) {
                    var R = g * Math.sin(v * f),
                        A = g * Math.cos(v * f);
                    l[T + 0] = R * Vt._radius, l[T + 1] = S * Vt._radius, l[T + 2] = A * Vt._radius,
                        l[T + 3] = -v / this._slices + .75, l[T + 4] = p / this._stacks, T += a, p != this._stacks - 1 && (h[m++] = E + 1,
                            h[m++] = E, h[m++] = E + (this._slices + 1), h[m++] = E + (this._slices + 1), h[m++] = E,
                            h[m++] = E + this._slices, E++);
                }
            this._vertexBuffer = new d(4 * l.length, i.STATIC_DRAW, !1), this._vertexBuffer.vertexDeclaration = n,
                this._indexBuffer = new c(c.INDEXTYPE_USHORT, h.length, i.STATIC_DRAW, !1), this._vertexBuffer.setData(l.buffer),
                this._indexBuffer.setData(h);
            var D = new _();
            D.bind(), D.applyVertexBuffer(this._vertexBuffer), D.applyIndexBuffer(this._indexBuffer),
                D.unBind(), this._bufferState = D;
        }
        static __init__() {
            Vt.instance = new Vt();
        }
        get stacks() {
            return this._stacks;
        }
        get slices() {
            return this._slices;
        }
        _render(e) {
            var r = t.LayaGL.instance,
                i = this._indexBuffer.indexCount;
            r.drawElements(r.TRIANGLES, i, r.UNSIGNED_SHORT, 0), t.Stat.trianglesFaces += i / 3,
                t.Stat.renderBatches++;
        }
    }
    Vt._radius = 1;
    class wt {
        constructor() {
            this.source = null, this.destination = null, this.camera = null, this.compositeShaderData = null,
                this.command = null, this.deferredReleaseTextures = [];
        }
    }
    class bt {
        constructor() {
            this._compositeShader = L.find("PostProcessComposite"), this._compositeShaderData = new p(),
                this._context = null, this._effects = [], this._context = new wt(), this._context.compositeShaderData = this._compositeShaderData;
        }
        static __init__() {
            bt.SHADERDEFINE_BLOOM_LOW = bt.shaderDefines.registerDefine("BLOOM_LOW"), bt.SHADERDEFINE_BLOOM = bt.shaderDefines.registerDefine("BLOOM"),
                bt.SHADERDEFINE_FINALPASS = bt.shaderDefines.registerDefine("FINALPASS");
        }
        _init(e, t) {
            this._context.camera = e, this._context.command = t;
        }
        _render() {
            var e = p._SET_RUNTIME_VALUE_MODE_REFERENCE_;
            t.ILaya.Render.supportWebGLPlusRendering && p.setRuntimeValueMode(!1);
            var r = this._context.camera,
                i = Y.createFromPool(J.clientWidth, J.clientHeight, r._getRenderTextureFormat(), t.BaseTexture.FORMAT_DEPTHSTENCIL_NONE),
                n = r._renderTexture;
            this._context.command.clear(), this._context.source = i, this._context.destination = n,
                this._context.compositeShaderData.clearDefine(), this._context.command.blitScreenTriangle(n, i),
                this._context.compositeShaderData.setTexture(bt.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
            for (var a = 0, s = this._effects.length; a < s; a++) this._effects[a].render(this._context);
            this._compositeShaderData.addDefine(bt.SHADERDEFINE_FINALPASS);
            var o = r.renderTarget,
                l = o || null;
            this._context.destination = l, this._context.command.blitScreenTriangle(this._context.source, l, this._compositeShader, this._compositeShaderData),
                Y.recoverToPool(i);
            var _ = this._context.deferredReleaseTextures;
            for (a = 0, s = _.length; a < s; a++) Y.recoverToPool(_[a]);
            _.length = 0, t.ILaya.Render.supportWebGLPlusRendering && p.setRuntimeValueMode(e);
        }
        addEffect(e) {
            this._effects.push(e);
        }
        removeEffect(e) {
            var t = this._effects.indexOf(e); -
            1 !== t && this._effects.splice(t, 1);
        }
    }
    bt.SHADERVALUE_MAINTEX = L.propertyNameToID("u_MainTex"), bt.SHADERVALUE_BLOOMTEX = L.propertyNameToID("u_BloomTex"),
        bt.SHADERVALUE_AUTOEXPOSURETEX = L.propertyNameToID("u_AutoExposureTex"), bt.SHADERVALUE_BLOOM_DIRTTEX = L.propertyNameToID("u_Bloom_DirtTex"),
        bt.SHADERVALUE_BLOOMTEX_TEXELSIZE = L.propertyNameToID("u_BloomTex_TexelSize"),
        bt.SHADERVALUE_BLOOM_DIRTTILEOFFSET = L.propertyNameToID("u_Bloom_DirtTileOffset"),
        bt.SHADERVALUE_BLOOM_SETTINGS = L.propertyNameToID("u_Bloom_Settings"), bt.SHADERVALUE_BLOOM_COLOR = L.propertyNameToID("u_Bloom_Color"),
        bt.shaderDefines = new C();
    class Ft extends Ge {
        constructor() {
            super(), this.setShaderName("Effect"), this._color = new n(1, 1, 1, 1), this._shaderValues.setVector(Ft.TINTCOLOR, new n(1, 1, 1, 1)),
                this.renderMode = Ft.RENDERMODE_ADDTIVE;
        }
        static __initDefine__() {
            Ft.shaderDefines = new C(Ge.shaderDefines), Ft.SHADERDEFINE_MAINTEXTURE = Ft.shaderDefines.registerDefine("MAINTEXTURE"),
                Ft.SHADERDEFINE_TILINGOFFSET = Ft.shaderDefines.registerDefine("TILINGOFFSET"),
                Ft.SHADERDEFINE_ADDTIVEFOG = Ft.shaderDefines.registerDefine("ADDTIVEFOG");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Ft.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Ft.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Ft.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Ft.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Ft.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Ft.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Ft.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Ft.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
                case Ft.RENDERMODE_ADDTIVE:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_NONE, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE, this.depthTest = ze.DEPTHTEST_LESS, this._shaderValues.addDefine(Ft.SHADERDEFINE_ADDTIVEFOG);
                    break;

                case Ft.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_NONE, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Ft.SHADERDEFINE_ADDTIVEFOG);
                    break;

                default:
                    throw new Error("MeshEffectMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(Ft.TINTCOLOR);
        }
        set color(e) {
            this._shaderValues.setVector(Ft.TINTCOLOR, e);
        }
        get texture() {
            return this._shaderValues.getTexture(Ft.MAINTEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(Ft.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(Ft.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(Ft.MAINTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Ft.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Ft.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Ft.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(Ft.TILINGOFFSET, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Ft.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Ft.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Ft.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Ft.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Ft.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Ft.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Ft.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Ft.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Ft.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Ft.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Ft.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Ft.DEPTH_TEST);
        }
        clone() {
            var e = new Ft();
            return this.cloneTo(e), e;
        }
    }
    Ft.RENDERMODE_ADDTIVE = 0, Ft.RENDERMODE_ALPHABLENDED = 1, Ft.MAINTEXTURE = L.propertyNameToID("u_AlbedoTexture"),
        Ft.TINTCOLOR = L.propertyNameToID("u_AlbedoColor"), Ft.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"),
        Ft.CULL = L.propertyNameToID("s_Cull"), Ft.BLEND = L.propertyNameToID("s_Blend"),
        Ft.BLEND_SRC = L.propertyNameToID("s_BlendSrc"), Ft.BLEND_DST = L.propertyNameToID("s_BlendDst"),
        Ft.DEPTH_TEST = L.propertyNameToID("s_DepthTest"), Ft.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"),
        Ft.shaderDefines = null;
    class Bt extends Ge {
        constructor() {
            super(), this._enableLighting = !0, this.setShaderName("ExtendTerrain"), this.renderMode = Bt.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            Bt.shaderDefines = new C(Ge.shaderDefines), Bt.SHADERDEFINE_DETAIL_NUM1 = Bt.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM1"),
                Bt.SHADERDEFINE_DETAIL_NUM2 = Bt.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM2"),
                Bt.SHADERDEFINE_DETAIL_NUM3 = Bt.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM3"),
                Bt.SHADERDEFINE_DETAIL_NUM4 = Bt.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM4"),
                Bt.SHADERDEFINE_DETAIL_NUM5 = Bt.shaderDefines.registerDefine("ExtendTerrain_DETAIL_NUM5");
        }
        get splatAlphaTexture() {
            return this._shaderValues.getTexture(Bt.SPLATALPHATEXTURE);
        }
        set splatAlphaTexture(e) {
            this._shaderValues.setTexture(Bt.SPLATALPHATEXTURE, e);
        }
        set diffuseTexture1(e) {
            this._shaderValues.setTexture(Bt.DIFFUSETEXTURE1, e), this._setDetailNum(1);
        }
        get diffuseTexture2() {
            return this._shaderValues.getTexture(Bt.DIFFUSETEXTURE2);
        }
        set diffuseTexture2(e) {
            this._shaderValues.setTexture(Bt.DIFFUSETEXTURE2, e), this._setDetailNum(2);
        }
        get diffuseTexture3() {
            return this._shaderValues.getTexture(Bt.DIFFUSETEXTURE3);
        }
        set diffuseTexture3(e) {
            this._shaderValues.setTexture(Bt.DIFFUSETEXTURE3, e), this._setDetailNum(3);
        }
        get diffuseTexture4() {
            return this._shaderValues.getTexture(Bt.DIFFUSETEXTURE4);
        }
        set diffuseTexture4(e) {
            this._shaderValues.setTexture(Bt.DIFFUSETEXTURE4, e), this._setDetailNum(4);
        }
        get diffuseTexture5() {
            return this._shaderValues.getTexture(Bt.DIFFUSETEXTURE5);
        }
        set diffuseTexture5(e) {
            this._shaderValues.setTexture(Bt.DIFFUSETEXTURE5, e), this._setDetailNum(5);
        }
        _setDetailNum(e) {
            switch (e) {
                case 1:
                    this._shaderValues.addDefine(Bt.SHADERDEFINE_DETAIL_NUM1), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM2),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM4),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM5);
                    break;

                case 2:
                    this._shaderValues.addDefine(Bt.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM1),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM4),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM5);
                    break;

                case 3:
                    this._shaderValues.addDefine(Bt.SHADERDEFINE_DETAIL_NUM3), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM1),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM4),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM5);
                    break;

                case 4:
                    this._shaderValues.addDefine(Bt.SHADERDEFINE_DETAIL_NUM4), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM1),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM3),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM5);
                    break;

                case 5:
                    this._shaderValues.addDefine(Bt.SHADERDEFINE_DETAIL_NUM5), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM1),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM2), this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM3),
                        this._shaderValues.removeDefine(Bt.SHADERDEFINE_DETAIL_NUM4);
            }
        }
        set diffuseScaleOffset1(e) {
            this._shaderValues.setVector(Bt.DIFFUSESCALEOFFSET1, e);
        }
        set diffuseScaleOffset2(e) {
            this._shaderValues.setVector(Bt.DIFFUSESCALEOFFSET2, e);
        }
        set diffuseScaleOffset3(e) {
            this._shaderValues.setVector(Bt.DIFFUSESCALEOFFSET3, e);
        }
        set diffuseScaleOffset4(e) {
            this._shaderValues.setVector(Bt.DIFFUSESCALEOFFSET4, e);
        }
        set diffuseScaleOffset5(e) {
            this._shaderValues.setVector(Bt.DIFFUSESCALEOFFSET5, e);
        }
        get enableLighting() {
            return this._enableLighting;
        }
        set enableLighting(e) {
            this._enableLighting !== e && (e ? this._disablePublicDefineDatas.remove(se.SHADERDEFINE_POINTLIGHT | se.SHADERDEFINE_SPOTLIGHT | se.SHADERDEFINE_DIRECTIONLIGHT) : this._disablePublicDefineDatas.add(se.SHADERDEFINE_POINTLIGHT | se.SHADERDEFINE_SPOTLIGHT | se.SHADERDEFINE_DIRECTIONLIGHT),
                this._enableLighting = e);
        }
        set renderMode(e) {
            switch (e) {
                case Bt.RENDERMODE_OPAQUE:
                    this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !0, this.cull = ze.CULL_BACK,
                        this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                case Bt.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !1, this.cull = ze.CULL_BACK,
                        this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA, this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA,
                        this.depthTest = ze.DEPTHTEST_LEQUAL;
                    break;

                default:
                    throw new Error("ExtendTerrainMaterial:renderMode value error.");
            }
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Bt.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Bt.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Bt.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Bt.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Bt.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Bt.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Bt.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Bt.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Bt.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Bt.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Bt.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Bt.DEPTH_TEST);
        }
        clone() {
            var e = new Bt();
            return this.cloneTo(e), e;
        }
    }
    Bt.RENDERMODE_OPAQUE = 1, Bt.RENDERMODE_TRANSPARENT = 2, Bt.SPLATALPHATEXTURE = L.propertyNameToID("u_SplatAlphaTexture"),
        Bt.DIFFUSETEXTURE1 = L.propertyNameToID("u_DiffuseTexture1"), Bt.DIFFUSETEXTURE2 = L.propertyNameToID("u_DiffuseTexture2"),
        Bt.DIFFUSETEXTURE3 = L.propertyNameToID("u_DiffuseTexture3"), Bt.DIFFUSETEXTURE4 = L.propertyNameToID("u_DiffuseTexture4"),
        Bt.DIFFUSETEXTURE5 = L.propertyNameToID("u_DiffuseTexture5"), Bt.DIFFUSESCALEOFFSET1 = L.propertyNameToID("u_DiffuseScaleOffset1"),
        Bt.DIFFUSESCALEOFFSET2 = L.propertyNameToID("u_DiffuseScaleOffset2"), Bt.DIFFUSESCALEOFFSET3 = L.propertyNameToID("u_DiffuseScaleOffset3"),
        Bt.DIFFUSESCALEOFFSET4 = L.propertyNameToID("u_DiffuseScaleOffset4"), Bt.DIFFUSESCALEOFFSET5 = L.propertyNameToID("u_DiffuseScaleOffset5"),
        Bt.CULL = L.propertyNameToID("s_Cull"), Bt.BLEND = L.propertyNameToID("s_Blend"),
        Bt.BLEND_SRC = L.propertyNameToID("s_BlendSrc"), Bt.BLEND_DST = L.propertyNameToID("s_BlendDst"),
        Bt.DEPTH_TEST = L.propertyNameToID("s_DepthTest"), Bt.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"),
        Bt.shaderDefines = null;
    class Ut extends Ge {
        constructor() {
            super(), this.setShaderName("PBRSpecular"), this._albedoColor = new n(1, 1, 1, 1),
                this._shaderValues.setVector(Ut.ALBEDOCOLOR, new n(1, 1, 1, 1)), this._emissionColor = new n(0, 0, 0, 0),
                this._shaderValues.setVector(Ut.EMISSIONCOLOR, new n(0, 0, 0, 0)), this._specularColor = new n(.2, .2, .2, .2),
                this._shaderValues.setVector(Ut.SPECULARCOLOR, new n(.2, .2, .2, .2)), this._shaderValues.setNumber(Ut.SMOOTHNESS, .5),
                this._shaderValues.setNumber(Ut.SMOOTHNESSSCALE, 1), this._shaderValues.setNumber(Ut.SMOOTHNESSSOURCE, 0),
                this._shaderValues.setNumber(Ut.OCCLUSIONSTRENGTH, 1), this._shaderValues.setNumber(Ut.NORMALSCALE, 1),
                this._shaderValues.setNumber(Ut.PARALLAXSCALE, .001), this._shaderValues.setBool(Ut.ENABLEEMISSION, !1),
                this._shaderValues.setNumber(Ge.ALPHATESTVALUE, .5), this.renderMode = Ut.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            Ut.shaderDefines = new C(Ge.shaderDefines), Ut.SHADERDEFINE_ALBEDOTEXTURE = Ut.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                Ut.SHADERDEFINE_SPECULARTEXTURE = Ut.shaderDefines.registerDefine("SPECULARTEXTURE"),
                Ut.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = Ut.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"),
                Ut.SHADERDEFINE_NORMALTEXTURE = Ut.shaderDefines.registerDefine("NORMALTEXTURE"),
                Ut.SHADERDEFINE_PARALLAXTEXTURE = Ut.shaderDefines.registerDefine("PARALLAXTEXTURE"),
                Ut.SHADERDEFINE_OCCLUSIONTEXTURE = Ut.shaderDefines.registerDefine("OCCLUSIONTEXTURE"),
                Ut.SHADERDEFINE_EMISSION = Ut.shaderDefines.registerDefine("EMISSION"), Ut.SHADERDEFINE_EMISSIONTEXTURE = Ut.shaderDefines.registerDefine("EMISSIONTEXTURE"),
                Ut.SHADERDEFINE_TILINGOFFSET = Ut.shaderDefines.registerDefine("TILINGOFFSET"),
                Ut.SHADERDEFINE_ALPHAPREMULTIPLY = Ut.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _SpecColorR() {
            return this._specularColor.x;
        }
        set _SpecColorR(e) {
            this._specularColor.x = e, this.specularColor = this._specularColor;
        }
        get _SpecColorG() {
            return this._specularColor.y;
        }
        set _SpecColorG(e) {
            this._specularColor.y = e, this.specularColor = this._specularColor;
        }
        get _SpecColorB() {
            return this._specularColor.z;
        }
        set _SpecColorB(e) {
            this._specularColor.z = e, this.specularColor = this._specularColor;
        }
        get _SpecColorA() {
            return this._specularColor.w;
        }
        set _SpecColorA(e) {
            this._specularColor.w = e, this.specularColor = this._specularColor;
        }
        get _Glossiness() {
            return this._shaderValues.getNumber(Ut.SMOOTHNESS);
        }
        set _Glossiness(e) {
            this._shaderValues.setNumber(Ut.SMOOTHNESS, e);
        }
        get _GlossMapScale() {
            return this._shaderValues.getNumber(Ut.SMOOTHNESSSCALE);
        }
        set _GlossMapScale(e) {
            this._shaderValues.setNumber(Ut.SMOOTHNESSSCALE, e);
        }
        get _BumpScale() {
            return this._shaderValues.getNumber(Ut.NORMALSCALE);
        }
        set _BumpScale(e) {
            this._shaderValues.setNumber(Ut.NORMALSCALE, e);
        }
        get _Parallax() {
            return this._shaderValues.getNumber(Ut.PARALLAXSCALE);
        }
        set _Parallax(e) {
            this._shaderValues.setNumber(Ut.PARALLAXSCALE, e);
        }
        get _OcclusionStrength() {
            return this._shaderValues.getNumber(Ut.OCCLUSIONSTRENGTH);
        }
        set _OcclusionStrength(e) {
            this._shaderValues.setNumber(Ut.OCCLUSIONSTRENGTH, e);
        }
        get _EmissionColorR() {
            return this._emissionColor.x;
        }
        set _EmissionColorR(e) {
            this._emissionColor.x = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorG() {
            return this._emissionColor.y;
        }
        set _EmissionColorG(e) {
            this._emissionColor.y = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorB() {
            return this._emissionColor.z;
        }
        set _EmissionColorB(e) {
            this._emissionColor.z = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorA() {
            return this._emissionColor.w;
        }
        set _EmissionColorA(e) {
            this._emissionColor.w = e, this.emissionColor = this._emissionColor;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Ut.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Ut.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Ut.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Ut.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Ut.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Ut.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Ut.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Ut.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            this._albedoColor = e, this._shaderValues.setVector(Ut.ALBEDOCOLOR, e);
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(Ut.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_ALBEDOTEXTURE),
                this._shaderValues.setTexture(Ut.ALBEDOTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(Ut.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_NORMALTEXTURE),
                this._shaderValues.setTexture(Ut.NORMALTEXTURE, e);
        }
        get normalTextureScale() {
            return this._BumpScale;
        }
        set normalTextureScale(e) {
            this._BumpScale = e;
        }
        get parallaxTexture() {
            return this._shaderValues.getTexture(Ut.PARALLAXTEXTURE);
        }
        set parallaxTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_PARALLAXTEXTURE),
                this._shaderValues.setTexture(Ut.PARALLAXTEXTURE, e);
        }
        get parallaxTextureScale() {
            return this._Parallax;
        }
        set parallaxTextureScale(e) {
            this._Parallax = Math.max(.005, Math.min(.08, e));
        }
        get occlusionTexture() {
            return this._shaderValues.getTexture(Ut.OCCLUSIONTEXTURE);
        }
        set occlusionTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_OCCLUSIONTEXTURE),
                this._shaderValues.setTexture(Ut.OCCLUSIONTEXTURE, e);
        }
        get occlusionTextureStrength() {
            return this._OcclusionStrength;
        }
        set occlusionTextureStrength(e) {
            this._OcclusionStrength = Math.max(0, Math.min(1, e));
        }
        get specularTexture() {
            return this._shaderValues.getTexture(Ut.SPECULARTEXTURE);
        }
        set specularTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_SPECULARTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_SPECULARTEXTURE),
                this._shaderValues.setTexture(Ut.SPECULARTEXTURE, e);
        }
        get specularColorR() {
            return this._SpecColorR;
        }
        set specularColorR(e) {
            this._SpecColorR = e;
        }
        get specularColorG() {
            return this._SpecColorG;
        }
        set specularColorG(e) {
            this._SpecColorG = e;
        }
        get specularColorB() {
            return this._SpecColorB;
        }
        set specularColorB(e) {
            this._SpecColorB = e;
        }
        get specularColorA() {
            return this._SpecColorA;
        }
        set specularColorA(e) {
            this._SpecColorA = e;
        }
        get specularColor() {
            return this._shaderValues.getVector(Ut.SPECULARCOLOR);
        }
        set specularColor(e) {
            this._shaderValues.setVector(Ut.SPECULARCOLOR, e);
        }
        get smoothness() {
            return this._Glossiness;
        }
        set smoothness(e) {
            this._Glossiness = Math.max(0, Math.min(1, e));
        }
        get smoothnessTextureScale() {
            return this._GlossMapScale;
        }
        set smoothnessTextureScale(e) {
            this._GlossMapScale = Math.max(0, Math.min(1, e));
        }
        get smoothnessSource() {
            return this._shaderValues.getInt(Ut.SMOOTHNESSSOURCE);
        }
        set smoothnessSource(e) {
            e ? (this._shaderValues.addDefine(Ut.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                this._shaderValues.setInt(Ut.SMOOTHNESSSOURCE, 1)) : (this._shaderValues.removeDefine(Ut.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                this._shaderValues.setInt(Ut.SMOOTHNESSSOURCE, 0));
        }
        get enableEmission() {
            return this._shaderValues.getBool(Ut.ENABLEEMISSION);
        }
        set enableEmission(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_EMISSION),
                this._shaderValues.setBool(Ut.ENABLEEMISSION, e);
        }
        get emissionColor() {
            return this._shaderValues.getVector(Ut.EMISSIONCOLOR);
        }
        set emissionColor(e) {
            this._shaderValues.setVector(Ut.EMISSIONCOLOR, e);
        }
        get emissionTexture() {
            return this._shaderValues.getTexture(Ut.EMISSIONTEXTURE);
        }
        set emissionTexture(e) {
            e ? this._shaderValues.addDefine(Ut.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_EMISSIONTEXTURE),
                this._shaderValues.setTexture(Ut.EMISSIONTEXTURE, e);
        }
        get enableReflection() {
            return this._shaderValues.getBool(Ut.ENABLEREFLECT);
        }
        set enableReflection(e) {
            this._shaderValues.setBool(Ut.ENABLEREFLECT, !0), e ? this._disablePublicDefineDatas.remove(se.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(se.SHADERDEFINE_REFLECTMAP);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Ut.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Ut.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Ut.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(Ut.TILINGOFFSET, e);
        }
        set renderMode(e) {
            switch (e) {
                case Ut.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Ut.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Ut.RENDERMODE_CUTOUT:
                    this.renderQueue = Ge.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Ut.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Ut.RENDERMODE_FADE:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Ut.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Ut.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_ONE,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.addDefine(Ut.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                default:
                    throw new Error("PBRSpecularMaterial : renderMode value error.");
            }
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Ut.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Ut.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Ut.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Ut.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Ut.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Ut.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Ut.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Ut.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Ut.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Ut.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Ut.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Ut.DEPTH_TEST);
        }
        clone() {
            var e = new Ut();
            return this.cloneTo(e), e;
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this._albedoColor.cloneTo(t._albedoColor), this._specularColor.cloneTo(t._specularColor),
                this._emissionColor.cloneTo(t._emissionColor);
        }
    }
    Ut.SmoothnessSource_SpecularTexture_Alpha = 0, Ut.SmoothnessSource_AlbedoTexture_Alpha = 1,
        Ut.RENDERMODE_OPAQUE = 0, Ut.RENDERMODE_CUTOUT = 1, Ut.RENDERMODE_FADE = 2, Ut.RENDERMODE_TRANSPARENT = 3,
        Ut.ALBEDOTEXTURE = L.propertyNameToID("u_AlbedoTexture"), Ut.SPECULARTEXTURE = L.propertyNameToID("u_SpecularTexture"),
        Ut.NORMALTEXTURE = L.propertyNameToID("u_NormalTexture"), Ut.PARALLAXTEXTURE = L.propertyNameToID("u_ParallaxTexture"),
        Ut.OCCLUSIONTEXTURE = L.propertyNameToID("u_OcclusionTexture"), Ut.EMISSIONTEXTURE = L.propertyNameToID("u_EmissionTexture"),
        Ut.ALBEDOCOLOR = L.propertyNameToID("u_AlbedoColor"), Ut.SPECULARCOLOR = L.propertyNameToID("u_SpecularColor"),
        Ut.EMISSIONCOLOR = L.propertyNameToID("u_EmissionColor"), Ut.SMOOTHNESS = L.propertyNameToID("u_smoothness"),
        Ut.SMOOTHNESSSCALE = L.propertyNameToID("u_smoothnessScale"), Ut.SMOOTHNESSSOURCE = -1,
        Ut.OCCLUSIONSTRENGTH = L.propertyNameToID("u_occlusionStrength"), Ut.NORMALSCALE = L.propertyNameToID("u_normalScale"),
        Ut.PARALLAXSCALE = L.propertyNameToID("u_parallaxScale"), Ut.ENABLEEMISSION = -1,
        Ut.ENABLEREFLECT = -1, Ut.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"), Ut.CULL = L.propertyNameToID("s_Cull"),
        Ut.BLEND = L.propertyNameToID("s_Blend"), Ut.BLEND_SRC = L.propertyNameToID("s_BlendSrc"),
        Ut.BLEND_DST = L.propertyNameToID("s_BlendDst"), Ut.DEPTH_TEST = L.propertyNameToID("s_DepthTest"),
        Ut.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"), Ut.shaderDefines = null;
    class Gt extends Ge {
        constructor() {
            super(), this.setShaderName("PBRStandard"), this._albedoColor = new n(1, 1, 1, 1),
                this._shaderValues.setVector(Gt.ALBEDOCOLOR, new n(1, 1, 1, 1)), this._emissionColor = new n(0, 0, 0, 0),
                this._shaderValues.setVector(Gt.EMISSIONCOLOR, new n(0, 0, 0, 0)), this._shaderValues.setNumber(Gt.METALLIC, 0),
                this._shaderValues.setNumber(Gt.SMOOTHNESS, .5), this._shaderValues.setNumber(Gt.SMOOTHNESSSCALE, 1),
                this._shaderValues.setNumber(Gt.SMOOTHNESSSOURCE, 0), this._shaderValues.setNumber(Gt.OCCLUSIONSTRENGTH, 1),
                this._shaderValues.setNumber(Gt.NORMALSCALE, 1), this._shaderValues.setNumber(Gt.PARALLAXSCALE, .001),
                this._shaderValues.setBool(Gt.ENABLEEMISSION, !1), this._shaderValues.setBool(Gt.ENABLEREFLECT, !0),
                this._shaderValues.setNumber(Ge.ALPHATESTVALUE, .5), this._disablePublicDefineDatas.remove(se.SHADERDEFINE_REFLECTMAP),
                this.renderMode = Gt.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            Gt.shaderDefines = new C(Ge.shaderDefines), Gt.SHADERDEFINE_ALBEDOTEXTURE = Gt.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                Gt.SHADERDEFINE_METALLICGLOSSTEXTURE = Gt.shaderDefines.registerDefine("METALLICGLOSSTEXTURE"),
                Gt.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = Gt.shaderDefines.registerDefine("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA"),
                Gt.SHADERDEFINE_NORMALTEXTURE = Gt.shaderDefines.registerDefine("NORMALTEXTURE"),
                Gt.SHADERDEFINE_PARALLAXTEXTURE = Gt.shaderDefines.registerDefine("PARALLAXTEXTURE"),
                Gt.SHADERDEFINE_OCCLUSIONTEXTURE = Gt.shaderDefines.registerDefine("OCCLUSIONTEXTURE"),
                Gt.SHADERDEFINE_EMISSION = Gt.shaderDefines.registerDefine("EMISSION"), Gt.SHADERDEFINE_EMISSIONTEXTURE = Gt.shaderDefines.registerDefine("EMISSIONTEXTURE"),
                Gt.SHADERDEFINE_REFLECTMAP = Gt.shaderDefines.registerDefine("REFLECTMAP"), Gt.SHADERDEFINE_TILINGOFFSET = Gt.shaderDefines.registerDefine("TILINGOFFSET"),
                Gt.SHADERDEFINE_ALPHAPREMULTIPLY = Gt.shaderDefines.registerDefine("ALPHAPREMULTIPLY");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _Metallic() {
            return this._shaderValues.getNumber(Gt.METALLIC);
        }
        set _Metallic(e) {
            this._shaderValues.setNumber(Gt.METALLIC, e);
        }
        get _Glossiness() {
            return this._shaderValues.getNumber(Gt.SMOOTHNESS);
        }
        set _Glossiness(e) {
            this._shaderValues.setNumber(Gt.SMOOTHNESS, e);
        }
        get _GlossMapScale() {
            return this._shaderValues.getNumber(Gt.SMOOTHNESSSCALE);
        }
        set _GlossMapScale(e) {
            this._shaderValues.setNumber(Gt.SMOOTHNESSSCALE, e);
        }
        get _BumpScale() {
            return this._shaderValues.getNumber(Gt.NORMALSCALE);
        }
        set _BumpScale(e) {
            this._shaderValues.setNumber(Gt.NORMALSCALE, e);
        }
        get _Parallax() {
            return this._shaderValues.getNumber(Gt.PARALLAXSCALE);
        }
        set _Parallax(e) {
            this._shaderValues.setNumber(Gt.PARALLAXSCALE, e);
        }
        get _OcclusionStrength() {
            return this._shaderValues.getNumber(Gt.OCCLUSIONSTRENGTH);
        }
        set _OcclusionStrength(e) {
            this._shaderValues.setNumber(Gt.OCCLUSIONSTRENGTH, e);
        }
        get _EmissionColorR() {
            return this._emissionColor.x;
        }
        set _EmissionColorR(e) {
            this._emissionColor.x = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorG() {
            return this._emissionColor.y;
        }
        set _EmissionColorG(e) {
            this._emissionColor.y = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorB() {
            return this._emissionColor.z;
        }
        set _EmissionColorB(e) {
            this._emissionColor.z = e, this.emissionColor = this._emissionColor;
        }
        get _EmissionColorA() {
            return this._emissionColor.w;
        }
        set _EmissionColorA(e) {
            this._emissionColor.w = e, this.emissionColor = this._emissionColor;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Gt.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Gt.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Gt.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Gt.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Gt.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Gt.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Gt.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Gt.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            this._albedoColor = e, this._shaderValues.setVector(Gt.ALBEDOCOLOR, e);
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(Gt.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_ALBEDOTEXTURE),
                this._shaderValues.setTexture(Gt.ALBEDOTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(Gt.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_NORMALTEXTURE),
                this._shaderValues.setTexture(Gt.NORMALTEXTURE, e);
        }
        get normalTextureScale() {
            return this._BumpScale;
        }
        set normalTextureScale(e) {
            this._BumpScale = e;
        }
        get parallaxTexture() {
            return this._shaderValues.getTexture(Gt.PARALLAXTEXTURE);
        }
        set parallaxTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_PARALLAXTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_PARALLAXTEXTURE),
                this._shaderValues.setTexture(Gt.PARALLAXTEXTURE, e);
        }
        get parallaxTextureScale() {
            return this._Parallax;
        }
        set parallaxTextureScale(e) {
            this._Parallax = Math.max(.005, Math.min(.08, e));
        }
        get occlusionTexture() {
            return this._shaderValues.getTexture(Gt.OCCLUSIONTEXTURE);
        }
        set occlusionTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_OCCLUSIONTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_OCCLUSIONTEXTURE),
                this._shaderValues.setTexture(Gt.OCCLUSIONTEXTURE, e);
        }
        get occlusionTextureStrength() {
            return this._OcclusionStrength;
        }
        set occlusionTextureStrength(e) {
            this._OcclusionStrength = Math.max(0, Math.min(1, e));
        }
        get metallicGlossTexture() {
            return this._shaderValues.getTexture(Gt.METALLICGLOSSTEXTURE);
        }
        set metallicGlossTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_METALLICGLOSSTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_METALLICGLOSSTEXTURE),
                this._shaderValues.setTexture(Gt.METALLICGLOSSTEXTURE, e);
        }
        get metallic() {
            return this._Metallic;
        }
        set metallic(e) {
            this._Metallic = Math.max(0, Math.min(1, e));
        }
        get smoothness() {
            return this._Glossiness;
        }
        set smoothness(e) {
            this._Glossiness = Math.max(0, Math.min(1, e));
        }
        get smoothnessTextureScale() {
            return this._GlossMapScale;
        }
        set smoothnessTextureScale(e) {
            this._GlossMapScale = Math.max(0, Math.min(1, e));
        }
        get smoothnessSource() {
            return this._shaderValues.getInt(Gt.SMOOTHNESSSOURCE);
        }
        set smoothnessSource(e) {
            e ? (this._shaderValues.addDefine(Gt.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                this._shaderValues.setInt(Gt.SMOOTHNESSSOURCE, 1)) : (this._shaderValues.removeDefine(Gt.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA),
                this._shaderValues.setInt(Gt.SMOOTHNESSSOURCE, 0));
        }
        get enableEmission() {
            return this._shaderValues.getBool(Gt.ENABLEEMISSION);
        }
        set enableEmission(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_EMISSION) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_EMISSION),
                this._shaderValues.setBool(Gt.ENABLEEMISSION, e);
        }
        get emissionColorR() {
            return this._EmissionColorR;
        }
        set emissionColorR(e) {
            this._EmissionColorR = e;
        }
        get emissionColorG() {
            return this._EmissionColorG;
        }
        set emissionColorG(e) {
            this._EmissionColorG = e;
        }
        get emissionColorB() {
            return this._EmissionColorB;
        }
        set emissionColorB(e) {
            this._EmissionColorB = e;
        }
        get emissionColorA() {
            return this._EmissionColorA;
        }
        set emissionColorA(e) {
            this._EmissionColorA = e;
        }
        get emissionColor() {
            return this._shaderValues.getVector(Gt.EMISSIONCOLOR);
        }
        set emissionColor(e) {
            this._shaderValues.setVector(Gt.EMISSIONCOLOR, e);
        }
        get emissionTexture() {
            return this._shaderValues.getTexture(Gt.EMISSIONTEXTURE);
        }
        set emissionTexture(e) {
            e ? this._shaderValues.addDefine(Gt.SHADERDEFINE_EMISSIONTEXTURE) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_EMISSIONTEXTURE),
                this._shaderValues.setTexture(Gt.EMISSIONTEXTURE, e);
        }
        get enableReflection() {
            return this._shaderValues.getBool(Gt.ENABLEREFLECT);
        }
        set enableReflection(e) {
            this._shaderValues.setBool(Gt.ENABLEREFLECT, !0), e ? this._disablePublicDefineDatas.remove(se.SHADERDEFINE_REFLECTMAP) : this._disablePublicDefineDatas.add(se.SHADERDEFINE_REFLECTMAP);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Gt.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Gt.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Gt.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(Gt.TILINGOFFSET, e);
        }
        set renderMode(e) {
            switch (e) {
                case Gt.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Gt.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Gt.RENDERMODE_CUTOUT:
                    this.renderQueue = Ge.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Gt.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Gt.RENDERMODE_FADE:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Gt.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                case Gt.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_ONE,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.addDefine(Gt.SHADERDEFINE_ALPHAPREMULTIPLY);
                    break;

                default:
                    throw new Error("PBRSpecularMaterial : renderMode value error.");
            }
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Gt.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Gt.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Gt.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Gt.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Gt.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Gt.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Gt.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Gt.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Gt.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Gt.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Gt.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Gt.DEPTH_TEST);
        }
        clone() {
            var e = new Gt();
            return this.cloneTo(e), e;
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this._albedoColor.cloneTo(t._albedoColor), this._emissionColor.cloneTo(t._emissionColor);
        }
    }
    Gt.SmoothnessSource_MetallicGlossTexture_Alpha = 0, Gt.SmoothnessSource_AlbedoTexture_Alpha = 1,
        Gt.RENDERMODE_OPAQUE = 0, Gt.RENDERMODE_CUTOUT = 1, Gt.RENDERMODE_FADE = 2, Gt.RENDERMODE_TRANSPARENT = 3,
        Gt.ALBEDOTEXTURE = L.propertyNameToID("u_AlbedoTexture"), Gt.METALLICGLOSSTEXTURE = L.propertyNameToID("u_MetallicGlossTexture"),
        Gt.NORMALTEXTURE = L.propertyNameToID("u_NormalTexture"), Gt.PARALLAXTEXTURE = L.propertyNameToID("u_ParallaxTexture"),
        Gt.OCCLUSIONTEXTURE = L.propertyNameToID("u_OcclusionTexture"), Gt.EMISSIONTEXTURE = L.propertyNameToID("u_EmissionTexture"),
        Gt.ALBEDOCOLOR = L.propertyNameToID("u_AlbedoColor"), Gt.EMISSIONCOLOR = L.propertyNameToID("u_EmissionColor"),
        Gt.METALLIC = L.propertyNameToID("u_metallic"), Gt.SMOOTHNESS = L.propertyNameToID("u_smoothness"),
        Gt.SMOOTHNESSSCALE = L.propertyNameToID("u_smoothnessScale"), Gt.SMOOTHNESSSOURCE = -1,
        Gt.OCCLUSIONSTRENGTH = L.propertyNameToID("u_occlusionStrength"), Gt.NORMALSCALE = L.propertyNameToID("u_normalScale"),
        Gt.PARALLAXSCALE = L.propertyNameToID("u_parallaxScale"), Gt.ENABLEEMISSION = -1,
        Gt.ENABLEREFLECT = -1, Gt.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"), Gt.CULL = L.propertyNameToID("s_Cull"),
        Gt.BLEND = L.propertyNameToID("s_Blend"), Gt.BLEND_SRC = L.propertyNameToID("s_BlendSrc"),
        Gt.BLEND_DST = L.propertyNameToID("s_BlendDst"), Gt.DEPTH_TEST = L.propertyNameToID("s_DepthTest"),
        Gt.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"), Gt.shaderDefines = null;
    class zt extends Ge {
        constructor() {
            super(), this.setShaderName("SkyBoxProcedural"), this.sunDisk = zt.SUN_HIGH_QUALITY,
                this.sunSize = .04, this.sunSizeConvergence = 5, this.atmosphereThickness = 1, this.skyTint = new n(.5, .5, .5, 1),
                this.groundTint = new n(.369, .349, .341, 1), this.exposure = 1.3;
        }
        static __initDefine__() {
            zt.shaderDefines = new C(Ge.shaderDefines), zt.SHADERDEFINE_SUN_HIGH_QUALITY = zt.shaderDefines.registerDefine("SUN_HIGH_QUALITY"),
                zt.SHADERDEFINE_SUN_SIMPLE = zt.shaderDefines.registerDefine("SUN_SIMPLE");
        }
        get sunDisk() {
            return this._sunDisk;
        }
        set sunDisk(e) {
            switch (e) {
                case zt.SUN_HIGH_QUALITY:
                    this._shaderValues.removeDefine(zt.SHADERDEFINE_SUN_SIMPLE), this._shaderValues.addDefine(zt.SHADERDEFINE_SUN_HIGH_QUALITY);
                    break;

                case zt.SUN_SIMPLE:
                    this._shaderValues.removeDefine(zt.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.addDefine(zt.SHADERDEFINE_SUN_SIMPLE);
                    break;

                case zt.SUN_NODE:
                    this._shaderValues.removeDefine(zt.SHADERDEFINE_SUN_HIGH_QUALITY), this._shaderValues.removeDefine(zt.SHADERDEFINE_SUN_SIMPLE);
                    break;

                default:
                    throw "SkyBoxProceduralMaterial: unknown sun value.";
            }
            this._sunDisk = e;
        }
        get sunSize() {
            return this._shaderValues.getNumber(zt.SUNSIZE);
        }
        set sunSize(e) {
            e = Math.min(Math.max(0, e), 1), this._shaderValues.setNumber(zt.SUNSIZE, e);
        }
        get sunSizeConvergence() {
            return this._shaderValues.getNumber(zt.SUNSIZECONVERGENCE);
        }
        set sunSizeConvergence(e) {
            e = Math.min(Math.max(0, e), 20), this._shaderValues.setNumber(zt.SUNSIZECONVERGENCE, e);
        }
        get atmosphereThickness() {
            return this._shaderValues.getNumber(zt.ATMOSPHERETHICKNESS);
        }
        set atmosphereThickness(e) {
            e = Math.min(Math.max(0, e), 5), this._shaderValues.setNumber(zt.ATMOSPHERETHICKNESS, e);
        }
        get skyTint() {
            return this._shaderValues.getVector(zt.SKYTINT);
        }
        set skyTint(e) {
            this._shaderValues.setVector(zt.SKYTINT, e);
        }
        get groundTint() {
            return this._shaderValues.getVector(zt.GROUNDTINT);
        }
        set groundTint(e) {
            this._shaderValues.setVector(zt.GROUNDTINT, e);
        }
        get exposure() {
            return this._shaderValues.getNumber(zt.EXPOSURE);
        }
        set exposure(e) {
            e = Math.min(Math.max(0, e), 8), this._shaderValues.setNumber(zt.EXPOSURE, e);
        }
        clone() {
            var e = new zt();
            return this.cloneTo(e), e;
        }
    }
    zt.SUN_NODE = 0, zt.SUN_SIMPLE = 1, zt.SUN_HIGH_QUALITY = 2, zt.SUNSIZE = L.propertyNameToID("u_SunSize"),
        zt.SUNSIZECONVERGENCE = L.propertyNameToID("u_SunSizeConvergence"), zt.ATMOSPHERETHICKNESS = L.propertyNameToID("u_AtmosphereThickness"),
        zt.SKYTINT = L.propertyNameToID("u_SkyTint"), zt.GROUNDTINT = L.propertyNameToID("u_GroundTint"),
        zt.EXPOSURE = L.propertyNameToID("u_Exposure"), zt.shaderDefines = null;
    class Ht extends Ge {
        constructor() {
            super(), this._albedoColor = new n(1, 1, 1, 1), this._albedoIntensity = 1, this._enableVertexColor = !1,
                this.setShaderName("Unlit"), this._shaderValues.setVector(Ht.ALBEDOCOLOR, new n(1, 1, 1, 1)),
                this.renderMode = Ht.RENDERMODE_OPAQUE;
        }
        static __initDefine__() {
            Ht.shaderDefines = new C(Ge.shaderDefines), Ht.SHADERDEFINE_ALBEDOTEXTURE = Ht.shaderDefines.registerDefine("ALBEDOTEXTURE"),
                Ht.SHADERDEFINE_TILINGOFFSET = Ht.shaderDefines.registerDefine("TILINGOFFSET"),
                Ht.SHADERDEFINE_ENABLEVERTEXCOLOR = Ht.shaderDefines.registerDefine("ENABLEVERTEXCOLOR");
        }
        get _ColorR() {
            return this._albedoColor.x;
        }
        set _ColorR(e) {
            this._albedoColor.x = e, this.albedoColor = this._albedoColor;
        }
        get _ColorG() {
            return this._albedoColor.y;
        }
        set _ColorG(e) {
            this._albedoColor.y = e, this.albedoColor = this._albedoColor;
        }
        get _ColorB() {
            return this._albedoColor.z;
        }
        set _ColorB(e) {
            this._albedoColor.z = e, this.albedoColor = this._albedoColor;
        }
        get _ColorA() {
            return this._albedoColor.w;
        }
        set _ColorA(e) {
            this._albedoColor.w = e, this.albedoColor = this._albedoColor;
        }
        get _AlbedoIntensity() {
            return this._albedoIntensity;
        }
        set _AlbedoIntensity(e) {
            if (this._albedoIntensity !== e) {
                var t = this._shaderValues.getVector(Ht.ALBEDOCOLOR);
                n.scale(this._albedoColor, e, t), this._albedoIntensity = e, this._shaderValues.setVector(Ht.ALBEDOCOLOR, t);
            }
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Ht.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Ht.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Ht.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Ht.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Ht.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Ht.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Ht.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Ht.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        get _Cutoff() {
            return this.alphaTestValue;
        }
        set _Cutoff(e) {
            this.alphaTestValue = e;
        }
        get albedoColorR() {
            return this._ColorR;
        }
        set albedoColorR(e) {
            this._ColorR = e;
        }
        get albedoColorG() {
            return this._ColorG;
        }
        set albedoColorG(e) {
            this._ColorG = e;
        }
        get albedoColorB() {
            return this._ColorB;
        }
        set albedoColorB(e) {
            this._ColorB = e;
        }
        get albedoColorA() {
            return this._ColorA;
        }
        set albedoColorA(e) {
            this._ColorA = e;
        }
        get albedoColor() {
            return this._albedoColor;
        }
        set albedoColor(e) {
            var t = this._shaderValues.getVector(Ht.ALBEDOCOLOR);
            n.scale(e, this._albedoIntensity, t), this._albedoColor = e, this._shaderValues.setVector(Ht.ALBEDOCOLOR, t);
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(e) {
            this._AlbedoIntensity = e;
        }
        get albedoTexture() {
            return this._shaderValues.getTexture(Ht.ALBEDOTEXTURE);
        }
        set albedoTexture(e) {
            e ? this._shaderValues.addDefine(Ht.SHADERDEFINE_ALBEDOTEXTURE) : this._shaderValues.removeDefine(Ht.SHADERDEFINE_ALBEDOTEXTURE),
                this._shaderValues.setTexture(Ht.ALBEDOTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Ht.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Ht.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Ht.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(Ht.TILINGOFFSET, e);
        }
        get enableVertexColor() {
            return this._enableVertexColor;
        }
        set enableVertexColor(e) {
            this._enableVertexColor = e, e ? this._shaderValues.addDefine(Ht.SHADERDEFINE_ENABLEVERTEXCOLOR) : this._shaderValues.removeDefine(Ht.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set renderMode(e) {
            switch (e) {
                case Ht.RENDERMODE_OPAQUE:
                    this.alphaTest = !1, this.renderQueue = Ge.RENDERQUEUE_OPAQUE, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                case Ht.RENDERMODE_CUTOUT:
                    this.renderQueue = Ge.RENDERQUEUE_ALPHATEST, this.alphaTest = !0, this.depthWrite = !0,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_DISABLE, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                case Ht.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_BACK, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS;
                    break;

                default:
                    throw new Error("UnlitMaterial : renderMode value error.");
            }
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Ht.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Ht.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Ht.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Ht.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Ht.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Ht.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Ht.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Ht.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Ht.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Ht.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Ht.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Ht.DEPTH_TEST);
        }
        clone() {
            var e = new Ht();
            return this.cloneTo(e), e;
        }
    }
    Ht.RENDERMODE_OPAQUE = 0, Ht.RENDERMODE_CUTOUT = 1, Ht.RENDERMODE_TRANSPARENT = 2,
        Ht.RENDERMODE_ADDTIVE = 3, Ht.ALBEDOTEXTURE = L.propertyNameToID("u_AlbedoTexture"),
        Ht.ALBEDOCOLOR = L.propertyNameToID("u_AlbedoColor"), Ht.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"),
        Ht.CULL = L.propertyNameToID("s_Cull"), Ht.BLEND = L.propertyNameToID("s_Blend"),
        Ht.BLEND_SRC = L.propertyNameToID("s_BlendSrc"), Ht.BLEND_DST = L.propertyNameToID("s_BlendDst"),
        Ht.DEPTH_TEST = L.propertyNameToID("s_DepthTest"), Ht.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"),
        Ht.shaderDefines = null;
    class Wt extends Ge {
        constructor() {
            super(), this.setShaderName("WaterPrimary"), this._shaderValues.setVector(Wt.HORIZONCOLOR, new n(.172, .463, .435, 0)),
                this._shaderValues.setNumber(Wt.WAVESCALE, .15), this._shaderValues.setVector(Wt.WAVESPEED, new n(19, 9, -16, -7));
        }
        static __initDefine__() {
            Wt.shaderDefines = new C(Ge.shaderDefines), Wt.SHADERDEFINE_MAINTEXTURE = Wt.shaderDefines.registerDefine("MAINTEXTURE"),
                Wt.SHADERDEFINE_NORMALTEXTURE = Wt.shaderDefines.registerDefine("NORMALTEXTURE");
        }
        get horizonColor() {
            return this._shaderValues.getVector(Wt.HORIZONCOLOR);
        }
        set horizonColor(e) {
            this._shaderValues.setVector(Wt.HORIZONCOLOR, e);
        }
        get mainTexture() {
            return this._shaderValues.getTexture(Wt.MAINTEXTURE);
        }
        set mainTexture(e) {
            e ? this._shaderValues.addDefine(Wt.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(Wt.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(Wt.MAINTEXTURE, e);
        }
        get normalTexture() {
            return this._shaderValues.getTexture(Wt.NORMALTEXTURE);
        }
        set normalTexture(e) {
            e ? this._shaderValues.addDefine(Wt.SHADERDEFINE_NORMALTEXTURE) : this._shaderValues.removeDefine(Wt.SHADERDEFINE_NORMALTEXTURE),
                this._shaderValues.setTexture(Wt.NORMALTEXTURE, e);
        }
        get waveScale() {
            return this._shaderValues.getNumber(Wt.WAVESCALE);
        }
        set waveScale(e) {
            this._shaderValues.setNumber(Wt.WAVESCALE, e);
        }
        get waveSpeed() {
            return this._shaderValues.getVector(Wt.WAVESPEED);
        }
        set waveSpeed(e) {
            this._shaderValues.setVector(Wt.WAVESPEED, e);
        }
        clone() {
            var e = new Wt();
            return this.cloneTo(e), e;
        }
    }
    Wt.HORIZONCOLOR = L.propertyNameToID("u_HorizonColor"), Wt.MAINTEXTURE = L.propertyNameToID("u_MainTexture"),
        Wt.NORMALTEXTURE = L.propertyNameToID("u_NormalTexture"), Wt.WAVESCALE = L.propertyNameToID("u_WaveScale"),
        Wt.WAVESPEED = L.propertyNameToID("u_WaveSpeed"), Wt.shaderDefines = null;
    class kt {}
    class Xt extends Xe {
        constructor(e) {
            super(e), this._bones = [], this._skinnedDataLoopMarks = [], this._localBounds = new We(a._ZERO, a._ZERO),
                this._cacheAnimationNode = [];
        }
        get localBounds() {
            return this._localBounds;
        }
        set localBounds(e) {
            this._localBounds = e;
        }
        get rootBone() {
            return this._cacheRootBone;
        }
        set rootBone(e) {
            this._cacheRootBone != e && (this._cacheRootBone ? this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                e ? e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                this._cacheRootBone = e, this._onWorldMatNeedChange(w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE));
        }
        get bones() {
            return this._bones;
        }
        _computeSkinnedData() {
            if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                for (var e = this._cacheMesh._inverseBindPoses, t = this._cacheMesh._bindPoseIndices, r = this._cacheMesh._skinDataPathMarks, i = 0, n = this._cacheMesh.subMeshCount; i < n; i++)
                    for (var a = this._cacheMesh.getSubMesh(i)._boneIndicesList, s = this._skinnedData[i], o = 0, l = a.length; o < l; o++) {
                        var _ = a[o];
                        this._computeSubSkinnedData(e, _, t, s[o], r);
                    }
        }
        _computeSubSkinnedData(e, r, i, n, a) {
            for (var s = 0, o = r.length; s < o; s++) {
                var l = r[s];
                if (this._skinnedDataLoopMarks[l] === t.Stat.loopCount)
                    for (var _ = a[l], h = this._skinnedData[_[0]][_[1]], c = 16 * _[2], d = 16 * s, u = 0; u < 16; u++) n[d + u] = h[c + u];
                else {
                    if (this._cacheAvatar) M._mulMatrixArray(this._cacheAnimationNode[l].transform.getWorldMatrix(), e[i[l]], n, 16 * s);
                    else {
                        var f = i[l];
                        M._mulMatrixArray(this._bones[f].transform.worldMatrix.elements, e[f], n, 16 * s);
                    }
                    this._skinnedDataLoopMarks[l] = t.Stat.loopCount;
                }
            }
        }
        _onWorldMatNeedChange(e) {
            this._boundsChange = !0, this._octreeNode && (this._cacheAvatar ? -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this) : (e &= w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE) && -1 === this._indexInOctreeMotionList && this._octreeNode._octree.addMotionObject(this));
        }
        _createRenderElement() {
            return new le();
        }
        _onMeshChange(e) {
            super._onMeshChange(e), this._cacheMesh = e;
            var t = e.subMeshCount;
            this._skinnedData = [], this._skinnedDataLoopMarks.length = e._bindPoseIndices.length;
            for (var r = 0; r < t; r++)
                for (var i = e.getSubMesh(r)._boneIndicesList, n = i.length, a = this._skinnedData[r] = [], s = 0; s < n; s++) a[s] = new Float32Array(16 * i[s].length);
            this._cacheAvatar && e && this._getCacheAnimationNodes();
        }
        _setCacheAnimator(e) {
            this._cacheAnimator = e, this._shaderValues.addDefine(kt.SHADERDEFINE_BONE), this._setRootNode();
        }
        _calculateBoundingBox() {
            if (this._cacheAvatar)
                if (this._cacheAnimator && this._rootBone) {
                    var e = Xt._tempMatrix4x4;
                    M.matrix4x4MultiplyMFM(this._cacheAnimator.owner.transform.worldMatrix, this._cacheRootAnimationNode.transform.getWorldMatrix(), e),
                        this._localBounds._tranform(e, this._bounds);
                } else super._calculateBoundingBox();
            else this._cacheRootBone ? this._localBounds._tranform(this._cacheRootBone.transform.worldMatrix, this._bounds) : this._localBounds._tranform(this._owner.transform.worldMatrix, this._bounds);
            if (t.Render.supportWebGLPlusCulling) {
                var r = this._bounds.getMin(),
                    i = this._bounds.getMax(),
                    n = U._cullingBuffer;
                n[this._cullingBufferIndex + 1] = r.x, n[this._cullingBufferIndex + 2] = r.y, n[this._cullingBufferIndex + 3] = r.z,
                    n[this._cullingBufferIndex + 4] = i.x, n[this._cullingBufferIndex + 5] = i.y, n[this._cullingBufferIndex + 6] = i.z;
            }
        }
        _renderUpdate(e, t) {
            if (this._cacheAnimator)
                if (this._computeSkinnedData(), this._cacheAvatar) {
                    var r = this._cacheAnimator.owner._transform;
                    this._shaderValues.setMatrix4x4(b.WORLDMATRIX, r.worldMatrix);
                } else this._shaderValues.setMatrix4x4(b.WORLDMATRIX, T.DEFAULT);
            else this._shaderValues.setMatrix4x4(b.WORLDMATRIX, t.worldMatrix);
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix;
            if (this._cacheAnimator)
                if (this._cacheAvatar) {
                    var i = this._cacheAnimator.owner._transform;
                    T.multiply(r, i.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(b.MVPMATRIX, this._projectionViewWorldMatrix);
                } else this._shaderValues.setMatrix4x4(b.MVPMATRIX, r);
            else T.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix),
                this._shaderValues.setMatrix4x4(b.MVPMATRIX, this._projectionViewWorldMatrix);
        }
        _destroy() {
            super._destroy(), this._cacheAvatar ? this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._cacheRootBone ? !this._cacheRootBone.destroyed && this._cacheRootBone.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange) : this._owner && !this._owner.destroyed && this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
        }
        get bounds() {
            return (this._boundsChange || this._cacheAvatar) && (this._calculateBoundingBox(),
                this._boundsChange = !1), this._bounds;
        }
        _setRootBone(e) {
            this._rootBone = e, this._setRootNode();
        }
        _setRootNode() {
            var e;
            e = this._cacheAnimator && this._rootBone && this._cacheAvatar ? this._cacheAnimator._avatarNodeMap[this._rootBone] : null,
                this._cacheRootAnimationNode != e && (this._onWorldMatNeedChange(w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE),
                    this._owner.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                    this._cacheRootAnimationNode && this._cacheRootAnimationNode.transform.off(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                    e && e.transform.on(t.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange),
                    this._cacheRootAnimationNode = e);
        }
        _getCacheAnimationNodes() {
            var e = this._cacheMesh._boneNames,
                r = this._cacheMesh._bindPoseIndices,
                i = r.length;
            if (t.Render.supportWebGLPlusAnimation) {
                this._cacheAnimationNodeIndices = new Uint16Array(i);
                var n = this._cacheAnimator._avatarNodeMap;
                for (o = 0; o < i; o++) {
                    var a = n[e[r[o]]];
                    this._cacheAnimationNodeIndices[o] = a._worldMatrixIndex;
                }
            } else {
                this._cacheAnimationNode.length = i;
                for (var s = this._cacheAnimator._avatarNodeMap, o = 0; o < i; o++) {
                    var l = s[e[r[o]]];
                    this._cacheAnimationNode[o] = l;
                }
            }
        }
        _setCacheAvatar(e) {
            this._cacheAvatar !== e && (this._cacheMesh ? (this._cacheAvatar = e, e && (this._shaderValues.addDefine(kt.SHADERDEFINE_BONE),
                this._getCacheAnimationNodes())) : this._cacheAvatar = e, this._setRootNode());
        }
        _computeSubSkinnedDataNative(e, r, i, n, a, s) {
            t.LayaGL.instance.computeSubSkinnedData(e, r, i, n, a, s);
        }
        _computeSkinnedDataForNative() {
            if (this._cacheMesh && this._cacheAvatar || this._cacheMesh && !this._cacheAvatar)
                for (var e = this._cacheMesh._inverseBindPoses, r = this._cacheMesh._bindPoseIndices, i = this._cacheMesh._skinDataPathMarks, n = 0, a = this._cacheMesh.subMeshCount; n < a; n++)
                    for (var s = this._cacheMesh.getSubMesh(n)._boneIndicesList, o = this._skinnedData[n], l = 0, _ = s.length; l < _; l++) {
                        var h = s[l];
                        this._cacheAvatar && t.Render.supportWebGLPlusAnimation ? this._computeSubSkinnedDataNative(this._cacheAnimator._animationNodeWorldMatrixs, this._cacheAnimationNodeIndices, this._cacheMesh._inverseBindPosesBuffer, h, r, o[l]) : this._computeSubSkinnedData(e, h, r, o[l], i);
                    }
        }
    }
    Xt._tempMatrix4x4 = new T();
    class Yt extends F {
        constructor(e = null, t = null) {
            super(t), this._meshFilter = new Ue(this), this._render = new Xt(this), e && (this._meshFilter.sharedMesh = e);
        }
        static __init__() {
            Yt.shaderDefines = new C(Ye.shaderDefines), kt.SHADERDEFINE_BONE = Yt.shaderDefines.registerDefine("BONE");
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get skinnedMeshRenderer() {
            return this._render;
        }
        _parse(e, r) {
            super._parse(e, r);
            var i = this.skinnedMeshRenderer,
                s = e.lightmapIndex;
            null != s && (i.lightmapIndex = s);
            var o, l = e.lightmapScaleOffset;
            if (l && (i.lightmapScaleOffset = new n(l[0], l[1], l[2], l[3])), o = e.meshPath) {
                var _ = t.Loader.getRes(o);
                _ && (this.meshFilter.sharedMesh = _);
            }
            var h = e.materials;
            if (h) {
                var c = i.sharedMaterials,
                    d = h.length;
                c.length = d;
                for (var u = 0; u < d; u++) c[u] = t.Loader.getRes(h[u].path);
                i.sharedMaterials = c;
            }
            var f = e.boundBox,
                E = f.min,
                T = f.max;
            if (i.localBounds.setMin(new a(E[0], E[1], E[2])), i.localBounds.setMax(new a(T[0], T[1], T[2])),
                r) {
                var m = e.rootBone;
                i.rootBone = r[m];
                var p, g = e.bones;
                for (u = 0, p = g.length; u < p; u++) i.bones.push(r[g[u]]);
            } else e.rootBone && i._setRootBone(e.rootBone);
        }
        _changeHierarchyAnimator(e) {
            super._changeHierarchyAnimator(e), this.skinnedMeshRenderer._setCacheAnimator(e);
        }
        _changeAnimatorAvatar(e) {
            this.skinnedMeshRenderer._setCacheAvatar(e);
        }
        _cloneTo(e, t, r) {
            var i = e;
            i.meshFilter.sharedMesh = this.meshFilter.sharedMesh;
            var n = this._render,
                a = i._render;
            a.enable = n.enable, a.sharedMaterials = n.sharedMaterials, a.castShadow = n.castShadow;
            var s = n.lightmapScaleOffset;
            s && (a.lightmapScaleOffset = s.clone()), a.receiveShadow = n.receiveShadow, a.sortingFudge = n.sortingFudge,
                a._rootBone = n._rootBone;
            var o = n.bones,
                l = a.bones,
                _ = o.length;
            l.length = _;
            var h = n.rootBone;
            if (h) {
                var c = M._getHierarchyPath(t, h, Yt._tempArray0);
                a.rootBone = c ? M._getNodeByHierarchyPath(r, c) : h;
            }
            for (var d = 0; d < o.length; d++) c = M._getHierarchyPath(t, o[d], Yt._tempArray0),
                l[d] = c ? M._getNodeByHierarchyPath(r, c) : o[d];
            var u = n.localBounds;
            u && u.cloneTo(a.localBounds), super._cloneTo(e, t, r);
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._meshFilter.destroy());
        }
        _create() {
            return new Yt();
        }
    }
    Yt._tempArray0 = [], Yt.BONES = L.propertyNameToID("u_Bones"), Yt.shaderDefines = null;
    class Zt extends Ge {
        constructor() {
            super(), this.setShaderName("Trail"), this._color = new n(1, 1, 1, 1), this._shaderValues.setVector(Zt.TINTCOLOR, new n(1, 1, 1, 1)),
                this.renderMode = Zt.RENDERMODE_ALPHABLENDED;
        }
        static __initDefine__() {
            Zt.shaderDefines = new C(Ge.shaderDefines), Zt.SHADERDEFINE_MAINTEXTURE = Zt.shaderDefines.registerDefine("MAINTEXTURE"),
                Zt.SHADERDEFINE_TILINGOFFSET = Zt.shaderDefines.registerDefine("TILINGOFFSET"),
                Zt.SHADERDEFINE_ADDTIVEFOG = Zt.shaderDefines.registerDefine("ADDTIVEFOG");
        }
        get _TintColorR() {
            return this._color.x;
        }
        set _TintColorR(e) {
            this._color.x = e, this.color = this._color;
        }
        get _TintColorG() {
            return this._color.y;
        }
        set _TintColorG(e) {
            this._color.y = e, this.color = this._color;
        }
        get _TintColorB() {
            return this._color.z;
        }
        set _TintColorB(e) {
            this._color.z = e, this.color = this._color;
        }
        get _TintColorA() {
            return this._color.w;
        }
        set _TintColorA(e) {
            this._color.w = e, this.color = this._color;
        }
        get _MainTex_STX() {
            return this._shaderValues.getVector(Zt.TILINGOFFSET).x;
        }
        set _MainTex_STX(e) {
            var t = this._shaderValues.getVector(Zt.TILINGOFFSET);
            t.x = e, this.tilingOffset = t;
        }
        get _MainTex_STY() {
            return this._shaderValues.getVector(Zt.TILINGOFFSET).y;
        }
        set _MainTex_STY(e) {
            var t = this._shaderValues.getVector(Zt.TILINGOFFSET);
            t.y = e, this.tilingOffset = t;
        }
        get _MainTex_STZ() {
            return this._shaderValues.getVector(Zt.TILINGOFFSET).z;
        }
        set _MainTex_STZ(e) {
            var t = this._shaderValues.getVector(Zt.TILINGOFFSET);
            t.z = e, this.tilingOffset = t;
        }
        get _MainTex_STW() {
            return this._shaderValues.getVector(Zt.TILINGOFFSET).w;
        }
        set _MainTex_STW(e) {
            var t = this._shaderValues.getVector(Zt.TILINGOFFSET);
            t.w = e, this.tilingOffset = t;
        }
        set renderMode(e) {
            switch (e) {
                case Zt.RENDERMODE_ADDTIVE:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_NONE, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE, this.depthTest = ze.DEPTHTEST_LESS, this._shaderValues.addDefine(Zt.SHADERDEFINE_ADDTIVEFOG);
                    break;

                case Zt.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, this.alphaTest = !1, this.depthWrite = !1,
                        this.cull = ze.CULL_NONE, this.blend = ze.BLEND_ENABLE_ALL, this.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                        this.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, this.depthTest = ze.DEPTHTEST_LESS,
                        this._shaderValues.removeDefine(Zt.SHADERDEFINE_ADDTIVEFOG);
                    break;

                default:
                    throw new Error("TrailMaterial : renderMode value error.");
            }
        }
        get colorR() {
            return this._TintColorR;
        }
        set colorR(e) {
            this._TintColorR = e;
        }
        get colorG() {
            return this._TintColorG;
        }
        set colorG(e) {
            this._TintColorG = e;
        }
        get colorB() {
            return this._TintColorB;
        }
        set colorB(e) {
            this._TintColorB = e;
        }
        get colorA() {
            return this._TintColorA;
        }
        set colorA(e) {
            this._TintColorA = e;
        }
        get color() {
            return this._shaderValues.getVector(Zt.TINTCOLOR);
        }
        set color(e) {
            this._shaderValues.setVector(Zt.TINTCOLOR, e);
        }
        get texture() {
            return this._shaderValues.getTexture(Zt.MAINTEXTURE);
        }
        set texture(e) {
            e ? this._shaderValues.addDefine(Zt.SHADERDEFINE_MAINTEXTURE) : this._shaderValues.removeDefine(Zt.SHADERDEFINE_MAINTEXTURE),
                this._shaderValues.setTexture(Zt.MAINTEXTURE, e);
        }
        get tilingOffsetX() {
            return this._MainTex_STX;
        }
        set tilingOffsetX(e) {
            this._MainTex_STX = e;
        }
        get tilingOffsetY() {
            return this._MainTex_STY;
        }
        set tilingOffsetY(e) {
            this._MainTex_STY = e;
        }
        get tilingOffsetZ() {
            return this._MainTex_STZ;
        }
        set tilingOffsetZ(e) {
            this._MainTex_STZ = e;
        }
        get tilingOffsetW() {
            return this._MainTex_STW;
        }
        set tilingOffsetW(e) {
            this._MainTex_STW = e;
        }
        get tilingOffset() {
            return this._shaderValues.getVector(Zt.TILINGOFFSET);
        }
        set tilingOffset(e) {
            e && (1 != e.x || 1 != e.y || 0 != e.z || 0 != e.w) ? this._shaderValues.addDefine(Zt.SHADERDEFINE_TILINGOFFSET) : this._shaderValues.removeDefine(Zt.SHADERDEFINE_TILINGOFFSET),
                this._shaderValues.setVector(Zt.TILINGOFFSET, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Zt.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Zt.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Zt.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Zt.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Zt.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Zt.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Zt.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Zt.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Zt.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Zt.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Zt.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Zt.DEPTH_TEST);
        }
        clone() {
            var e = new Zt();
            return this.cloneTo(e), e;
        }
    }
    Zt.RENDERMODE_ALPHABLENDED = 0, Zt.RENDERMODE_ADDTIVE = 1, Zt.MAINTEXTURE = L.propertyNameToID("u_MainTexture"),
        Zt.TINTCOLOR = L.propertyNameToID("u_MainColor"), Zt.TILINGOFFSET = L.propertyNameToID("u_TilingOffset"),
        Zt.CULL = L.propertyNameToID("s_Cull"), Zt.BLEND = L.propertyNameToID("s_Blend"),
        Zt.BLEND_SRC = L.propertyNameToID("s_BlendSrc"), Zt.BLEND_DST = L.propertyNameToID("s_BlendDst"),
        Zt.DEPTH_TEST = L.propertyNameToID("s_DepthTest"), Zt.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite"),
        Zt.shaderDefines = null;
    class jt {
        constructor() {}
        cloneTo(e) {
            e.time = this.time;
        }
        clone() {
            var e = new jt();
            return this.cloneTo(e), e;
        }
    }
    class qt extends jt {
        constructor() {
            super();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            t.inTangent = this.inTangent, t.outTangent = this.outTangent, t.value = this.value;
        }
    }
    window.conch && window.conchFloatKeyframe && (qt = window.conchFloatKeyframe);
    class Kt {}
    var Qt;
    Kt.Stretch = 0, Kt.Tile = 1, (Qt = e.TrailAlignment || (e.TrailAlignment = {}))[Qt.View = 0] = "View",
        Qt[Qt.TransformZ = 1] = "TransformZ";
    class Jt {
        constructor() {}
        static get vertexDeclaration1() {
            return Jt._vertexDeclaration1;
        }
        static get vertexDeclaration2() {
            return Jt._vertexDeclaration2;
        }
        get vertexDeclaration() {
            return Jt._vertexDeclaration1;
        }
        static __init__() {
            Jt._vertexDeclaration1 = new g(32, [new S(0, u.Vector3, Jt.TRAIL_POSITION0), new S(12, u.Vector3, Jt.TRAIL_OFFSETVECTOR), new S(24, u.Single, Jt.TRAIL_TIME0), new S(28, u.Single, Jt.TRAIL_TEXTURECOORDINATE0Y)]),
                Jt._vertexDeclaration2 = new g(20, [new S(0, u.Single, Jt.TRAIL_TEXTURECOORDINATE0X), new S(4, u.Color, Jt.TRAIL_COLOR)]);
        }
    }
    Jt.TRAIL_POSITION0 = 0, Jt.TRAIL_OFFSETVECTOR = 1, Jt.TRAIL_TIME0 = 2, Jt.TRAIL_TEXTURECOORDINATE0Y = 3,
        Jt.TRAIL_TEXTURECOORDINATE0X = 4, Jt.TRAIL_COLOR = 5;
    class $t extends h {
        constructor(e) {
            super(), this._floatCountPerVertices1 = 8, this._floatCountPerVertices2 = 5, this._increaseSegementCount = 16,
                this._activeIndex = 0, this._endIndex = 0, this._needAddFirstVertex = !1, this._isTempEndVertex = !1,
                this._vertices1 = null, this._vertices2 = null, this._lastFixedVertexPosition = new a(),
                this._bufferState = new _(), this.tmpColor = new I(), this._disappearBoundsMode = !1,
                this._owner = e, this._segementCount = this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState);
            var r = this._owner._owner.trailRenderer.bounds,
                i = r.getMin(),
                n = r.getMax();
            i.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),
                r.setMin(i), r.setMax(n), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
        }
        _resizeData(e, r) {
            this._subBirthTime = new Float32Array(e), this._subDistance = new Float64Array(e);
            var i = t.LayaGL.instance,
                n = 2 * e,
                a = Jt.vertexDeclaration1,
                s = Jt.vertexDeclaration2,
                o = [],
                l = n * a.vertexStride,
                _ = n * s.vertexStride,
                h = l + _;
            this._vertices1 = new Float32Array(n * this._floatCountPerVertices1), this._vertices2 = new Float32Array(n * this._floatCountPerVertices2),
                this._vertexBuffer1 = new d(l, i.STATIC_DRAW, !1), this._vertexBuffer1.vertexDeclaration = a,
                this._vertexBuffer2 = new d(_, i.DYNAMIC_DRAW, !1), this._vertexBuffer2.vertexDeclaration = s,
                o.push(this._vertexBuffer1), o.push(this._vertexBuffer2), r.bind(), r.applyVertexBuffers(o),
                r.unBind(), t.Resource._addMemory(h, h);
        }
        _resetData() {
            var e = this._endIndex - this._activeIndex,
                t = new Float32Array(this._vertices1.buffer, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e),
                r = new Float32Array(this._vertices2.buffer, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e),
                i = new Float64Array(this._subDistance.buffer, 8 * this._activeIndex, e),
                n = new Float32Array(this._subBirthTime.buffer, 4 * this._activeIndex, e);
            e === this._segementCount && (this._vertexBuffer1.destroy(), this._vertexBuffer2.destroy(),
                    this._segementCount += this._increaseSegementCount, this._resizeData(this._segementCount, this._bufferState)),
                this._vertices1.set(t, 0), this._vertices2.set(r, 0), this._subDistance.set(i, 0),
                this._subBirthTime.set(n, 0), this._endIndex = e, this._activeIndex = 0, this._vertexBuffer1.setData(this._vertices1.buffer, 0, 2 * this._floatCountPerVertices1 * this._activeIndex * 4, 2 * this._floatCountPerVertices1 * e * 4),
                this._vertexBuffer2.setData(this._vertices2.buffer, 0, 2 * this._floatCountPerVertices2 * this._activeIndex * 4, 2 * this._floatCountPerVertices2 * e * 4);
        }
        _updateTrail(e, t, r) {
            a.equals(t, r) || (this._endIndex - this._activeIndex == 0 ? this._addTrailByFirstPosition(e, r) : this._addTrailByNextPosition(e, r));
        }
        _addTrailByFirstPosition(e, t) {
            this._endIndex === this._segementCount && this._resetData(), this._subDistance[this._endIndex] = 0,
                this._subBirthTime[this._endIndex] = this._owner._curtime, this._endIndex++, t.cloneTo(this._lastFixedVertexPosition),
                this._needAddFirstVertex = !0;
        }
        _addTrailByNextPosition(t, i) {
            var n = t.viewMatrix;
            a.transformCoordinate(i, n, $t._tempVector33);
            var s = $t._tempVector30,
                o = $t._tempVector31;
            switch (a.transformCoordinate(this._lastFixedVertexPosition, n, $t._tempVector34),
                a.subtract($t._tempVector33, $t._tempVector34, s), this._owner.alignment) {
                case e.TrailAlignment.View:
                    a.cross($t._tempVector33, s, o);
                    break;

                case e.TrailAlignment.TransformZ:
                    var l = $t._tempVector32;
                    this._owner._owner.transform.getForward(l), a.cross(s, l, o);
            }
            a.normalize(o, o), a.scale(o, this._owner.widthMultiplier / 2, o);
            var _, h, c = a.scalarLength(s);
            this._needAddFirstVertex && (this._updateVerticesByPositionData(i, o, this._endIndex - 1),
                this._needAddFirstVertex = !1), c - this._owner.minVertexDistance >= r.zeroTolerance ? (this._isTempEndVertex ? (_ = this._endIndex - 1,
                h = c - this._subDistance[_], this._updateVerticesByPosition(i, o, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(),
                this._updateVerticesByPosition(i, o, c, this._endIndex), this._owner._totalLength += c,
                this._endIndex++), i.cloneTo(this._lastFixedVertexPosition), this._isTempEndVertex = !1) : (this._isTempEndVertex ? (_ = this._endIndex - 1,
                h = c - this._subDistance[_], this._updateVerticesByPosition(i, o, c, _), this._owner._totalLength += h) : (this._endIndex === this._segementCount && this._resetData(),
                this._updateVerticesByPosition(i, o, c, this._endIndex), this._owner._totalLength += c,
                this._endIndex++), this._isTempEndVertex = !0);
        }
        _updateVerticesByPositionData(e, r, i) {
            var n = 2 * this._floatCountPerVertices1 * i,
                s = this._owner._curtime;
            this._vertices1[n] = e.x, this._vertices1[n + 1] = e.y, this._vertices1[n + 2] = e.z,
                this._vertices1[n + 3] = -r.x, this._vertices1[n + 4] = -r.y, this._vertices1[n + 5] = -r.z,
                this._vertices1[n + 6] = s, this._vertices1[n + 7] = 1, this._vertices1[n + 8] = e.x,
                this._vertices1[n + 9] = e.y, this._vertices1[n + 10] = e.z, this._vertices1[n + 11] = r.x,
                this._vertices1[n + 12] = r.y, this._vertices1[n + 13] = r.z, this._vertices1[n + 14] = s,
                this._vertices1[n + 15] = 0;
            var o = this._owner._owner.trailRenderer.bounds,
                l = o.getMin(),
                _ = o.getMax(),
                h = $t._tempVector35,
                c = $t._tempVector36,
                d = $t._tempVector32;
            a.add(e, r, h), a.subtract(e, r, c), a.min(c, h, d), a.min(l, d, l), o.setMin(l),
                a.max(h, c, d), a.max(_, d, _), o.setMax(_), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative();
            var u = 2 * this._floatCountPerVertices1;
            this._vertexBuffer1.setData(this._vertices1.buffer, 4 * n, 4 * n, 4 * u);
        }
        _updateVerticesByPosition(e, t, r, i) {
            this._updateVerticesByPositionData(e, t, i), this._subDistance[i] = r, this._subBirthTime[i] = this._owner._curtime;
        }
        _updateVertexBufferUV() {
            var e, r, i;
            this._disappearBoundsMode && (r = (e = this._owner._owner.trailRenderer.bounds).getMin(),
                i = e.getMax(), r.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
                i.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE), t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
            for (var n = this._endIndex, s = 0, o = this._owner.colorGradient, l = o.colorAlphaKeysCount - 1, _ = o.colorRGBKeysCount - 1, h = this._owner._totalLength, c = 2 * this._floatCountPerVertices2, d = this._activeIndex; d < n; d++) {
                var u, f;
                d !== this._activeIndex && (s += this._subDistance[d]), this._owner.textureMode == Kt.Stretch ? f = u = 1 - s / h : (f = 1 - s / h,
                    u = 1 - (h - s)), _ = o.evaluateColorRGB(f, this.tmpColor, _, !0), l = o.evaluateColorAlpha(f, this.tmpColor, l, !0);
                var E = d * c;
                if (this._vertices2[E + 0] = u, this._vertices2[E + 1] = this.tmpColor.r, this._vertices2[E + 2] = this.tmpColor.g,
                    this._vertices2[E + 3] = this.tmpColor.b, this._vertices2[E + 4] = this.tmpColor.a,
                    this._vertices2[E + 5] = u, this._vertices2[E + 6] = this.tmpColor.r, this._vertices2[E + 7] = this.tmpColor.g,
                    this._vertices2[E + 8] = this.tmpColor.b, this._vertices2[E + 9] = this.tmpColor.a,
                    this._disappearBoundsMode) {
                    var T = 2 * this._floatCountPerVertices1 * d,
                        m = $t._tempVector32,
                        p = $t._tempVector33,
                        g = $t._tempVector34;
                    m.setValue(this._vertices1[T + 0], this._vertices1[T + 1], this._vertices1[T + 2]),
                        p.setValue(this._vertices1[T + 3], this._vertices1[T + 4], this._vertices1[T + 5]),
                        a.add(m, p, g), a.min(g, r, r), a.max(g, i, i), a.subtract(m, p, g), a.min(g, r, r),
                        a.max(g, i, i);
                }
            }
            this._disappearBoundsMode && (e.setMin(r), e.setMax(i), this._disappearBoundsMode = !1,
                t.Render.supportWebGLPlusCulling && this._calculateBoundingBoxForNative());
            var S = this._activeIndex * c;
            this._vertexBuffer2.setData(this._vertices2.buffer, 4 * S, 4 * S, 4 * (n * c - S));
        }
        _updateDisappear() {
            for (var e = this._endIndex, t = this._activeIndex; t < e && this._owner._curtime - this._subBirthTime[t] >= this._owner.time + r.zeroTolerance; t++) {
                var i = t + 1;
                if (i !== e && (this._owner._totalLength -= this._subDistance[i]), this._isTempEndVertex && i === e - 1) {
                    this._floatCountPerVertices1;
                    var n = this._lastFixedVertexPosition;
                    n.x = this._vertices1[0], n.y = this._vertices1[1], n.z = this._vertices1[2], this._isTempEndVertex = !1;
                }
                this._activeIndex++, this._disappearBoundsMode = !0;
            }
        }
        _getType() {
            return $t._type;
        }
        _prepareRender(e) {
            return this._endIndex - this._activeIndex > 1;
        }
        _render(e) {
            this._bufferState.bind();
            var r = t.LayaGL.instance,
                i = 2 * this._activeIndex,
                n = 2 * this._endIndex - i;
            r.drawArrays(r.TRIANGLE_STRIP, i, n), t.Stat.renderBatches++, t.Stat.trianglesFaces += n - 2;
        }
        destroy() {
            super.destroy();
            var e = this._vertexBuffer1._byteLength + this._vertexBuffer2._byteLength;
            t.Resource._addMemory(-e, -e), this._bufferState.destroy(), this._vertexBuffer1.destroy(),
                this._vertexBuffer2.destroy(), this._bufferState = null, this._vertices1 = null,
                this._vertexBuffer1 = null, this._vertices2 = null, this._vertexBuffer2 = null,
                this._subBirthTime = null, this._subDistance = null, this._lastFixedVertexPosition = null,
                this._disappearBoundsMode = !1;
        }
        _calculateBoundingBoxForNative() {
            var e = this._owner._owner.trailRenderer,
                t = e.bounds,
                r = t.getMin(),
                i = t.getMax(),
                n = U._cullingBuffer;
            n[e._cullingBufferIndex + 1] = r.x, n[e._cullingBufferIndex + 2] = r.y, n[e._cullingBufferIndex + 3] = r.z,
                n[e._cullingBufferIndex + 4] = i.x, n[e._cullingBufferIndex + 5] = i.y, n[e._cullingBufferIndex + 6] = i.z;
        }
    }
    $t.ALIGNMENT_VIEW = 0, $t.ALIGNMENT_TRANSFORM_Z = 1, $t._tempVector30 = new a(),
        $t._tempVector31 = new a(), $t._tempVector32 = new a(), $t._tempVector33 = new a(),
        $t._tempVector34 = new a(), $t._tempVector35 = new a(), $t._tempVector36 = new a(),
        $t._type = h._typeCounter++;
    class er {
        constructor(e) {
            this._totalLength = 0, this._lastPosition = new a(), this._curtime = 0, this.alignment = er.ALIGNMENT_VIEW,
                this._owner = e, this._initDefaultData(), this.addRenderElement();
        }
        get time() {
            return this._time;
        }
        set time(e) {
            this._time = e, this._owner._render._shaderValues.setNumber(er.LIFETIME, e);
        }
        get minVertexDistance() {
            return this._minVertexDistance;
        }
        set minVertexDistance(e) {
            this._minVertexDistance = e;
        }
        get widthMultiplier() {
            return this._widthMultiplier;
        }
        set widthMultiplier(e) {
            this._widthMultiplier = e;
        }
        get widthCurve() {
            return this._widthCurve;
        }
        set widthCurve(e) {
            this._widthCurve = e;
            var t, r, i = new Float32Array(4 * e.length),
                n = 0;
            for (t = 0, r = e.length; t < r; t++) i[n++] = e[t].time, i[n++] = e[t].inTangent,
                i[n++] = e[t].outTangent, i[n++] = e[t].value;
            this._owner._render._shaderValues.setBuffer(er.WIDTHCURVE, i), this._owner._render._shaderValues.setInt(er.WIDTHCURVEKEYLENGTH, e.length);
        }
        get colorGradient() {
            return this._colorGradient;
        }
        set colorGradient(e) {
            this._colorGradient = e;
        }
        get textureMode() {
            return this._textureMode;
        }
        set textureMode(e) {
            this._textureMode = e;
        }
        addRenderElement() {
            var e = this._owner._render,
                t = e._renderElements,
                r = e.sharedMaterials[0];
            r || (r = Zt.defaultMaterial);
            var i = new le();
            i.setTransform(this._owner._transform), i.render = e, i.material = r, this._trialGeometry = new $t(this),
                i.setGeometry(this._trialGeometry), t.push(i);
        }
        _update(e) {
            var t = this._owner._render;
            this._curtime += e.scene.timer._delta / 1e3, t._shaderValues.setNumber(er.CURTIME, this._curtime);
            var r = this._owner.transform.position,
                i = t._renderElements[0]._geometry;
            i._updateDisappear(), i._updateTrail(e.camera, this._lastPosition, r), i._updateVertexBufferUV(),
                r.cloneTo(this._lastPosition);
        }
        _initDefaultData() {
            this.time = 5, this.minVertexDistance = .1, this.widthMultiplier = 1, this.textureMode = Kt.Stretch;
            var e = [],
                t = new qt();
            t.time = 0, t.inTangent = 0, t.outTangent = 0, t.value = 1, e.push(t);
            var r = new qt();
            r.time = 1, r.inTangent = 0, r.outTangent = 0, r.value = 1, e.push(r), this.widthCurve = e;
            var i = new je(2, 2);
            i.mode = Ze.Blend, i.addColorRGB(0, I.WHITE), i.addColorRGB(1, I.WHITE), i.addColorAlpha(0, 1),
                i.addColorAlpha(1, 1), this.colorGradient = i;
        }
        destroy() {
            this._trialGeometry.destroy(), this._trialGeometry = null, this._widthCurve = null,
                this._colorGradient = null;
        }
    }
    er.CURTIME = L.propertyNameToID("u_CurTime"), er.LIFETIME = L.propertyNameToID("u_LifeTime"),
        er.WIDTHCURVE = L.propertyNameToID("u_WidthCurve"), er.WIDTHCURVEKEYLENGTH = L.propertyNameToID("u_WidthCurveKeyLength"),
        er.ALIGNMENT_VIEW = 0, er.ALIGNMENT_TRANSFORM_Z = 1;
    class tr extends ke {
        constructor(e) {
            super(e), this._projectionViewWorldMatrix = new T();
        }
        _calculateBoundingBox() {}
        _needRender(e, t) {
            return this._owner.trailFilter._update(t), !e || e.intersects(this.bounds._getBoundBox());
        }
        _updateForNative(e) {
            this._owner.trailFilter._update(e);
        }
        _renderUpdate(e, t) {
            super._renderUpdate(e, t);
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix;
            t ? (T.multiply(r, t.worldMatrix, this._projectionViewWorldMatrix), this._shaderValues.setMatrix4x4(b.MVPMATRIX, this._projectionViewWorldMatrix)) : this._shaderValues.setMatrix4x4(b.MVPMATRIX, r);
        }
    }
    class rr extends F {
        static __init__() {
            rr.shaderDefines = new C(F.shaderDefines);
        }
        get trailFilter() {
            return this._geometryFilter;
        }
        get trailRenderer() {
            return this._render;
        }
        constructor(e = null) {
            super(e), this._render = new tr(this), this._geometryFilter = new er(this);
        }
        _parse(e, r) {
            super._parse(e, r);
            var i, n, a = this._render,
                s = this._geometryFilter,
                o = e.materials;
            if (o) {
                var l = a.sharedMaterials,
                    _ = o.length;
                for (l.length = _, i = 0; i < _; i++) l[i] = t.Loader.getRes(o[i].path);
                a.sharedMaterials = l;
            }
            s.time = e.time, s.minVertexDistance = e.minVertexDistance, s.widthMultiplier = e.widthMultiplier,
                s.textureMode = e.textureMode, null != e.alignment && (s.alignment = e.alignment);
            var h = [],
                c = e.widthCurve;
            for (i = 0, n = c.length; i < n; i++) {
                var d = new qt();
                d.time = c[i].time, d.inTangent = c[i].inTangent, d.outTangent = c[i].outTangent,
                    d.value = c[i].value, h.push(d);
            }
            s.widthCurve = h;
            var u = e.colorGradient,
                f = u.colorKeys,
                E = u.alphaKeys,
                T = new je(f.length, E.length);
            for (T.mode = u.mode, i = 0, n = f.length; i < n; i++) {
                var m = f[i];
                T.addColorRGB(m.time, new I(m.value[0], m.value[1], m.value[2], 1));
            }
            for (i = 0, n = E.length; i < n; i++) {
                var p = E[i];
                T.addColorAlpha(p.time, p.value);
            }
            s.colorGradient = T;
        }
        _onActive() {
            super._onActive(), this._transform.position.cloneTo(this._geometryFilter._lastPosition);
        }
        _cloneTo(e, t, r) {
            var i, n;
            super._cloneTo(e, t, r);
            var a = e,
                s = a.trailFilter;
            s.time = this.trailFilter.time, s.minVertexDistance = this.trailFilter.minVertexDistance,
                s.widthMultiplier = this.trailFilter.widthMultiplier, s.textureMode = this.trailFilter.textureMode;
            var o = this.trailFilter.widthCurve,
                l = [];
            for (i = 0, n = o.length; i < n; i++) {
                var _ = new qt();
                o[i].cloneTo(_), l.push(_);
            }
            s.widthCurve = l;
            var h = new je(this.trailFilter.colorGradient.maxColorRGBKeysCount, this.trailFilter.colorGradient.maxColorAlphaKeysCount);
            this.trailFilter.colorGradient.cloneTo(h), s.colorGradient = h, a.trailRenderer.sharedMaterial = this.trailRenderer.sharedMaterial;
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._geometryFilter.destroy(), this._geometryFilter = null);
        }
        _create() {
            return new rr();
        }
    }
    class ir {
        constructor() {
            this.textureID = -1;
        }
    }
    class nr extends t.Resource {
        constructor(e, t, r, i, n) {
            super(), this._stateParamsMap = [], this._uploadMark = -1, this._uploadRenderType = -1,
                this._vs = e, this._ps = t, this._attributeMap = r, this._uniformMap = i, this._shaderPass = n,
                this._create(), this.lock = !0;
        }
        _create() {
            var e = t.LayaGL.instance;
            for (var r in this._program = e.createProgram(), this._vshader = this._createShader(e, this._vs, e.VERTEX_SHADER),
                    this._pshader = this._createShader(e, this._ps, e.FRAGMENT_SHADER), e.attachShader(this._program, this._vshader),
                    e.attachShader(this._program, this._pshader), this._attributeMap) e.bindAttribLocation(this._program, this._attributeMap[r], r);
            if (e.linkProgram(this._program), !t.Render.isConchApp && L.debugMode && !e.getProgramParameter(this._program, e.LINK_STATUS)) throw e.getProgramInfoLog(this._program);
            var i = [],
                n = [],
                a = [],
                s = [],
                o = [];
            this._customUniformParamsMap = [];
            var l, _, h, c = e.getProgramParameter(this._program, e.ACTIVE_UNIFORMS);
            for (t.WebGLContext.useProgram(e, this._program), this._curActTexIndex = 0, _ = 0; _ < c; _++) {
                var d = e.getActiveUniform(this._program, _),
                    u = d.name;
                (l = new ir()).location = e.getUniformLocation(this._program, u), u.indexOf("[0]") > 0 ? (l.name = u = u.substr(0, u.length - 3),
                    l.isArray = !0) : (l.name = u, l.isArray = !1), l.type = d.type, this._addShaderUnifiormFun(l);
                var f = this._uniformMap[u];
                if (null != f) switch (l.dataOffset = L.propertyNameToID(u), f) {
                    case L.PERIOD_CUSTOM:
                        o.push(l);
                        break;

                    case L.PERIOD_MATERIAL:
                        s.push(l);
                        break;

                    case L.PERIOD_SPRITE:
                        a.push(l);
                        break;

                    case L.PERIOD_CAMERA:
                        n.push(l);
                        break;

                    case L.PERIOD_SCENE:
                        i.push(l);
                        break;

                    default:
                        throw new Error("Shader3D: period is unkonw.");
                }
            }
            for (this._sceneUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * i.length * 5 + 4, 64, !0),
                _ = 0, h = i.length; _ < h; _++) this._sceneUniformParamsMap.addShaderUniform(i[_]);
            for (this._cameraUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * n.length * 5 + 4, 64, !0),
                _ = 0, h = n.length; _ < h; _++) this._cameraUniformParamsMap.addShaderUniform(n[_]);
            for (this._spriteUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * a.length * 5 + 4, 64, !0),
                _ = 0, h = a.length; _ < h; _++) this._spriteUniformParamsMap.addShaderUniform(a[_]);
            for (this._materialUniformParamsMap = t.LayaGL.instance.createCommandEncoder(4 * s.length * 5 + 4, 64, !0),
                _ = 0, h = s.length; _ < h; _++) this._materialUniformParamsMap.addShaderUniform(s[_]);
            for (this._customUniformParamsMap.length = o.length, _ = 0, h = o.length; _ < h; _++) {
                var E = o[_];
                this._customUniformParamsMap[E.dataOffset] = E;
            }
            var T = this._shaderPass._stateMap;
            for (var m in T) this._stateParamsMap[T[m]] = L.propertyNameToID(m);
        }
        _getRenderState(e, t) {
            var r = this._stateParamsMap[t];
            return null == r ? null : e[r];
        }
        _disposeResource() {
            t.LayaGL.instance.deleteShader(this._vshader), t.LayaGL.instance.deleteShader(this._pshader),
                t.LayaGL.instance.deleteProgram(this._program), this._vshader = this._pshader = this._program = null,
                this._setGPUMemory(0), this._curActTexIndex = 0;
        }
        _addShaderUnifiormFun(e) {
            var r = t.LayaGL.instance;
            e.caller = this;
            var i = e.isArray;
            switch (e.type) {
                case r.BOOL:
                    e.fun = this._uniform1i, e.uploadedValue = new Array(1);
                    break;

                case r.INT:
                    e.fun = i ? this._uniform1iv : this._uniform1i, e.uploadedValue = new Array(1);
                    break;

                case r.FLOAT:
                    e.fun = i ? this._uniform1fv : this._uniform1f, e.uploadedValue = new Array(1);
                    break;

                case r.FLOAT_VEC2:
                    e.fun = i ? this._uniform_vec2v : this._uniform_vec2, e.uploadedValue = new Array(2);
                    break;

                case r.FLOAT_VEC3:
                    e.fun = i ? this._uniform_vec3v : this._uniform_vec3, e.uploadedValue = new Array(3);
                    break;

                case r.FLOAT_VEC4:
                    e.fun = i ? this._uniform_vec4v : this._uniform_vec4, e.uploadedValue = new Array(4);
                    break;

                case r.FLOAT_MAT2:
                    e.fun = this._uniformMatrix2fv;
                    break;

                case r.FLOAT_MAT3:
                    e.fun = this._uniformMatrix3fv;
                    break;

                case r.FLOAT_MAT4:
                    e.fun = i ? this._uniformMatrix4fv : this._uniformMatrix4f;
                    break;

                case r.SAMPLER_2D:
                    r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                        e.fun = this._uniform_sampler2D;
                    break;

                case 35679:
                    r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                        e.fun = this._uniform_sampler3D;
                    break;

                case r.SAMPLER_CUBE:
                    r.uniform1i(e.location, this._curActTexIndex), e.textureID = t.WebGLContext._glTextureIDs[this._curActTexIndex++],
                        e.fun = this._uniform_samplerCube;
                    break;

                default:
                    throw new Error("compile shader err!");
            }
        }
        _createShader(e, t, r) {
            var i = e.createShader(r);
            if (e.shaderSource(i, t), e.compileShader(i), L.debugMode && !e.getShaderParameter(i, e.COMPILE_STATUS)) throw e.getShaderInfoLog(i);
            return i;
        }
        _uniform1f(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r ? (t.LayaGL.instance.uniform1f(e.location, i[0] = r), 1) : 0;
        }
        _uniform1fv(e, r) {
            if (r.length < 4) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform1fv(e.location, r),
                    i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
            }
            return t.LayaGL.instance.uniform1fv(e.location, r), 1;
        }
        _uniform_vec2(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y ? (t.LayaGL.instance.uniform2f(e.location, i[0] = r.x, i[1] = r.y),
                1) : 0;
        }
        _uniform_vec2v(e, r) {
            if (r.length < 2) {
                var i = e.uploadedValue;
                return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform2fv(e.location, r),
                    i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], 1) : 0;
            }
            return t.LayaGL.instance.uniform2fv(e.location, r), 1;
        }
        _uniform_vec3(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z ? (t.LayaGL.instance.uniform3f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z),
                1) : 0;
        }
        _uniform_vec3v(e, r) {
            return t.LayaGL.instance.uniform3fv(e.location, r), 1;
        }
        _uniform_vec4(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r.x || i[1] !== r.y || i[2] !== r.z || i[3] !== r.w ? (t.LayaGL.instance.uniform4f(e.location, i[0] = r.x, i[1] = r.y, i[2] = r.z, i[3] = r.w),
                1) : 0;
        }
        _uniform_vec4v(e, r) {
            return t.LayaGL.instance.uniform4fv(e.location, r), 1;
        }
        _uniformMatrix2fv(e, r) {
            return t.LayaGL.instance.uniformMatrix2fv(e.location, !1, r), 1;
        }
        _uniformMatrix3fv(e, r) {
            return t.LayaGL.instance.uniformMatrix3fv(e.location, !1, r), 1;
        }
        _uniformMatrix4f(e, r) {
            var i = r.elements;
            return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, i), 1;
        }
        _uniformMatrix4fv(e, r) {
            return t.LayaGL.instance.uniformMatrix4fv(e.location, !1, r), 1;
        }
        _uniform1i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r ? (t.LayaGL.instance.uniform1i(e.location, i[0] = r), 1) : 0;
        }
        _uniform1iv(e, r) {
            return t.LayaGL.instance.uniform1iv(e.location, r), 1;
        }
        _uniform_ivec2(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] ? (t.LayaGL.instance.uniform2i(e.location, i[0] = r[0], i[1] = r[1]),
                1) : 0;
        }
        _uniform_ivec2v(e, r) {
            return t.LayaGL.instance.uniform2iv(e.location, r), 1;
        }
        _uniform_vec3i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] ? (t.LayaGL.instance.uniform3i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2]),
                1) : 0;
        }
        _uniform_vec3vi(e, r) {
            return t.LayaGL.instance.uniform3iv(e.location, r), 1;
        }
        _uniform_vec4i(e, r) {
            var i = e.uploadedValue;
            return i[0] !== r[0] || i[1] !== r[1] || i[2] !== r[2] || i[3] !== r[3] ? (t.LayaGL.instance.uniform4i(e.location, i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3]),
                1) : 0;
        }
        _uniform_vec4vi(e, r) {
            return t.LayaGL.instance.uniform4iv(e.location, r), 1;
        }
        _uniform_sampler2D(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(),
                n = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(n, e.textureID), t.WebGLContext.bindTexture(n, n.TEXTURE_2D, i),
                0;
        }
        _uniform_sampler3D(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(),
                n = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(n, e.textureID), t.WebGLContext.bindTexture(n, WebGL2RenderingContext.TEXTURE_3D, i),
                0;
        }
        _uniform_samplerCube(e, r) {
            var i = r._getSource() || r.defaulteTexture._getSource(),
                n = t.LayaGL.instance;
            return t.WebGLContext.activeTexture(n, e.textureID), t.WebGLContext.bindTexture(n, n.TEXTURE_CUBE_MAP, i),
                0;
        }
        bind() {
            return t.WebGLContext.useProgram(t.LayaGL.instance, this._program);
        }
        uploadUniforms(e, r, i) {
            t.Stat.shaderCall += t.LayaGLRunner.uploadShaderUniforms(t.LayaGL.instance, e, r, i);
        }
        uploadRenderStateBlendDepth(e) {
            var r = t.LayaGL.instance,
                i = this._shaderPass.renderState,
                n = e.getData(),
                a = this._getRenderState(n, L.RENDER_STATE_DEPTH_WRITE),
                s = this._getRenderState(n, L.RENDER_STATE_DEPTH_TEST),
                o = this._getRenderState(n, L.RENDER_STATE_BLEND);
            switch (null == a && (a = i.depthWrite), null == s && (s = i.depthTest), null == o && (o = i.blend),
                t.WebGLContext.setDepthMask(r, a), s === ze.DEPTHTEST_OFF ? t.WebGLContext.setDepthTest(r, !1) : (t.WebGLContext.setDepthTest(r, !0),
                    t.WebGLContext.setDepthFunc(r, s)), o) {
                case ze.BLEND_DISABLE:
                    t.WebGLContext.setBlend(r, !1);
                    break;

                case ze.BLEND_ENABLE_ALL:
                    t.WebGLContext.setBlend(r, !0);
                    var l = this._getRenderState(n, L.RENDER_STATE_BLEND_SRC);
                    null == l && (l = i.srcBlend);
                    var _ = this._getRenderState(n, L.RENDER_STATE_BLEND_DST);
                    null == _ && (_ = i.dstBlend), t.WebGLContext.setBlendFunc(r, l, _);
                    break;

                case ze.BLEND_ENABLE_SEPERATE:
                    t.WebGLContext.setBlend(r, !0);
                    var h = this._getRenderState(n, L.RENDER_STATE_BLEND_SRC_RGB);
                    null == h && (h = i.srcBlendRGB);
                    var c = this._getRenderState(n, L.RENDER_STATE_BLEND_DST_RGB);
                    null == c && (c = i.dstBlendRGB);
                    var d = this._getRenderState(n, L.RENDER_STATE_BLEND_SRC_ALPHA);
                    null == d && (d = i.srcBlendAlpha);
                    var u = this._getRenderState(n, L.RENDER_STATE_BLEND_DST_ALPHA);
                    null == u && (u = i.dstBlendAlpha), t.WebGLContext.setBlendFuncSeperate(r, h, c, d, u);
            }
        }
        uploadRenderStateFrontFace(e, r, i) {
            var n, a = t.LayaGL.instance,
                s = this._shaderPass.renderState,
                o = e.getData(),
                l = this._getRenderState(o, L.RENDER_STATE_CULL);
            switch (null == l && (l = s.cull), l) {
                case ze.CULL_NONE:
                    t.WebGLContext.setCullFace(a, !1);
                    break;

                case ze.CULL_FRONT:
                    t.WebGLContext.setCullFace(a, !0), n = r ? i ? a.CCW : a.CW : i ? a.CW : a.CCW,
                        t.WebGLContext.setFrontFace(a, n);
                    break;

                case ze.CULL_BACK:
                    t.WebGLContext.setCullFace(a, !0), n = r ? i ? a.CW : a.CCW : i ? a.CCW : a.CW,
                        t.WebGLContext.setFrontFace(a, n);
            }
        }
        uploadCustomUniform(e, r) {
            t.Stat.shaderCall += t.LayaGLRunner.uploadCustomUniform(t.LayaGL.instance, this._customUniformParamsMap, e, r);
        }
        _uniformMatrix2fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix2fvEx(e.location, !1, r), 1;
        }
        _uniformMatrix3fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix3fvEx(e.location, !1, r), 1;
        }
        _uniformMatrix4fvForNative(e, r) {
            return t.LayaGL.instance.uniformMatrix4fvEx(e.location, !1, r), 1;
        }
    }
    class ar extends t.ShaderCompile {
        constructor(e, t, r, i) {
            super(t, r, null), this._renderState = new ze(), this._owner = e, this._cacheSharders = [],
                this._publicValidDefine = 0, this._spriteValidDefine = 0, this._materialValidDefine = 0;
            var n = this._owner._publicDefinesMap,
                a = this._owner._spriteDefinesMap,
                s = this._owner._materialDefinesMap;
            for (var o in this.defs) null != n[o] ? this._publicValidDefine |= n[o] : null != a[o] ? this._spriteValidDefine |= a[o] : null != s[o] && (this._materialValidDefine |= s[o]);
            this._stateMap = i;
        }
        get renderState() {
            return this._renderState;
        }
        _definesToNameDic(e, t) {
            for (var r = {}, i = 1, n = 0; n < 32 && !((i = 1 << n) > e); n++) {
                e & i && (r[t[i]] = "");
            }
            return r;
        }
        _compileToTree(e, r, i, n, a) {
            var s, o, l, _, h, c, d, u, f, E, T;
            for (f = i; f < r.length; f++)
                if (!((l = r[f]).length < 1) && 0 !== (c = l.indexOf("//"))) {
                    if (c >= 0 && (l = l.substr(0, c)), s = u || new t.ShaderNode(n), u = null, s.text = l,
                        (c = l.indexOf("#")) >= 0) {
                        for (_ = "#", T = c + 1, E = l.length; T < E; T++) {
                            var m = l.charAt(T);
                            if (" " === m || "\t" === m || "?" === m) break;
                            _ += m;
                        }
                        switch (s.name = _, _) {
                            case "#ifdef":
                            case "#ifndef":
                                if (s.setParent(e), e = s, a)
                                    for (d = l.substr(T).split(t.ShaderCompile._splitToWordExps3),
                                        T = 0; T < d.length; T++)(l = d[T]).length && (a[l] = !0);
                                continue;

                            case "#if":
                            case "#elif":
                                if (s.setParent(e), e = s, a)
                                    for (d = l.substr(T).split(t.ShaderCompile._splitToWordExps3),
                                        T = 0; T < d.length; T++)(l = d[T]).length && "defined" != l && (a[l] = !0);
                                continue;

                            case "#else":
                                o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e), e = s;
                                continue;

                            case "#endif":
                                o = (e = e.parent).childs[e.childs.length - 1], s.setParent(e);
                                continue;

                            case "#include":
                                d = t.ShaderCompile.splitToWords(l, null);
                                var p = t.ShaderCompile.includes[d[1]];
                                if (!p) throw "ShaderCompile error no this include file:" + d[1];
                                if ((c = d[0].indexOf("?")) < 0) {
                                    s.setParent(e), l = p.getWith("with" == d[2] ? d[3] : null), this._compileToTree(s, l.split("\n"), 0, n, a),
                                        s.text = "";
                                    continue;
                                }
                                s.setCondition(d[0].substr(c + 1), t.ShaderCompile.IFDEF_YES), s.text = p.getWith("with" == d[2] ? d[3] : null);
                                break;

                            case "#import":
                                h = (d = t.ShaderCompile.splitToWords(l, null))[1], n.push({
                                    node: s,
                                    file: t.ShaderCompile.includes[h],
                                    ofs: s.text.length
                                });
                                continue;
                        }
                    } else {
                        if ((o = e.childs[e.childs.length - 1]) && !o.name) {
                            n.length > 0 && t.ShaderCompile.splitToWords(l, o), u = s, o.text += "\n" + l;
                            continue;
                        }
                        n.length > 0 && t.ShaderCompile.splitToWords(l, s);
                    }
                    s.setParent(e);
                }
        }
        withCompile(e, r, i) {
            var n, a, s;
            if (e &= this._publicValidDefine, r &= this._spriteValidDefine, i &= this._materialValidDefine,
                a = this._cacheSharders[e])
                if (s = a[r]) {
                    if (n = s[i]) return n;
                } else s = a[r] = [];
            else s = (a = this._cacheSharders[e] = [])[r] = [];
            var o, l = this._definesToNameDic(e, this._owner._publicDefines),
                _ = this._definesToNameDic(r, this._owner._spriteDefines),
                h = this._definesToNameDic(i, this._owner._materialDefines);
            if (L.debugMode) {
                var c = "";
                for (o in l) c += o + " ";
                var d = "";
                for (o in _) d += o + " ";
                var u = "";
                for (o in h) u += o + " ";
                t.WebGL.shaderHighPrecision || (e += L.SHADERDEFINE_HIGHPRECISION), console.log("%cShader3DDebugMode---(Name:" + this._owner._owner._name + " SubShaderIndex:" + this._owner._owner._subShaders.indexOf(this._owner) + " PassIndex:" + this._owner._passes.indexOf(this) + " PublicDefine:" + e + " SpriteDefine:" + r + " MaterialDefine:" + i + " PublicDefineGroup:" + c + " SpriteDefineGroup:" + d + "MaterialDefineGroup: " + u + ")---ShaderCompile3DDebugMode", "color:green");
            }
            var f = {},
                E = "";
            if (l)
                for (o in l) E += "#define " + o + "\n", f[o] = !0;
            if (_)
                for (o in _) E += "#define " + o + "\n", f[o] = !0;
            if (h)
                for (o in h) E += "#define " + o + "\n", f[o] = !0;
            var T = this._VS.toscript(f, []),
                m = "";
            0 == T[0].indexOf("#version") && (m = T[0] + "\n", T.shift());
            var p = this._PS.toscript(f, []),
                g = "";
            return 0 == p[0].indexOf("#version") && (g = p[0] + "\n", p.shift()), n = new nr(m + E + T.join("\n"), g + E + p.join("\n"), this._owner._attributeMap || this._owner._owner._attributeMap, this._owner._uniformMap || this._owner._owner._uniformMap, this),
                s[i] = n, n;
        }
    }
    class sr {
        constructor(e, t, r = null, i = null) {
            this._flags = {}, this._passes = [], this._publicDefines = [], this._publicDefinesMap = {},
                this._spriteDefines = [], this._spriteDefinesMap = {}, this._materialDefines = [],
                this._materialDefinesMap = {}, this._addDefines(this._publicDefines, this._publicDefinesMap, L._globleDefines),
                r && this._addDefines(this._spriteDefines, this._spriteDefinesMap, r.defines), i && this._addDefines(this._materialDefines, this._materialDefinesMap, i.defines),
                this._attributeMap = e, this._uniformMap = t;
        }
        _addDefines(e, t, r) {
            for (var i in r) {
                var n = r[i],
                    a = parseInt(i);
                e[a] = n, t[n] = a;
            }
        }
        getMaterialDefineByName(e) {
            return this._materialDefinesMap[e];
        }
        setFlag(e, t) {
            t ? this._flags[e] = t : delete this._flags[e];
        }
        getFlag(e) {
            return this._flags[e];
        }
        addShaderPass(e, t, r = null) {
            var i = new ar(this, e, t, r);
            return this._passes.push(i), i;
        }
    }
    var or = "#ifdef FSHIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTex;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_FragColor = texture2D(u_MainTex, v_Texcoord0);\r\n}\r\n\r\n",
        lr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        _r = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  2.0 * u_AlbedoColor;\r\n\t#ifdef COLOR\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t#ifdef MAINTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}\r\n\r\n",
        hr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec4 a_Color;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tvarying vec4 v_Color;\r\n#endif\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\t\t\r\n\t#ifdef COLOR\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        cr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_Normal;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\nvarying float v_posViewZ;\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\nuniform sampler2D u_SplatAlphaTexture;\r\n\r\nuniform sampler2D u_DiffuseTexture1;\r\nuniform sampler2D u_DiffuseTexture2;\r\nuniform sampler2D u_DiffuseTexture3;\r\nuniform sampler2D u_DiffuseTexture4;\r\nuniform sampler2D u_DiffuseTexture5;\r\n\r\nuniform vec4 u_DiffuseScaleOffset1;\r\nuniform vec4 u_DiffuseScaleOffset2;\r\nuniform vec4 u_DiffuseScaleOffset3;\r\nuniform vec4 u_DiffuseScaleOffset4;\r\nuniform vec4 u_DiffuseScaleOffset5;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform sampler2D u_LightMap;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 splatAlpha = vec4(1.0);\r\n\t#ifdef ExtendTerrain_DETAIL_NUM1\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r;\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM2\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r + color2.xyz * (1.0 - splatAlpha.r);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM3\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * (1.0 - splatAlpha.r - splatAlpha.g);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM4\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b);\r\n\t#endif\r\n\t#ifdef ExtendTerrain_DETAIL_NUM5\r\n\t\tsplatAlpha = texture2D(u_SplatAlphaTexture, v_Texcoord0);\r\n\t\tvec4 color1 = texture2D(u_DiffuseTexture1, v_Texcoord0 * u_DiffuseScaleOffset1.xy);\r\n\t\tvec4 color2 = texture2D(u_DiffuseTexture2, v_Texcoord0 * u_DiffuseScaleOffset2.xy);\r\n\t\tvec4 color3 = texture2D(u_DiffuseTexture3, v_Texcoord0 * u_DiffuseScaleOffset3.xy);\r\n\t\tvec4 color4 = texture2D(u_DiffuseTexture4, v_Texcoord0 * u_DiffuseScaleOffset4.xy);\r\n\t\tvec4 color5 = texture2D(u_DiffuseTexture5, v_Texcoord0 * u_DiffuseScaleOffset5.xy);\r\n\t\tgl_FragColor.xyz = color1.xyz * splatAlpha.r  + color2.xyz * splatAlpha.g + color3.xyz * splatAlpha.b + color4.xyz * splatAlpha.a + color5.xyz * (1.0 - splatAlpha.r - splatAlpha.g - splatAlpha.b - splatAlpha.a);\r\n\t#endif\r\n\t\tgl_FragColor.w = splatAlpha.a;\r\n\t\t\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n    vec3 normal = v_Normal;\r\n\tvec3 dif, spe;\r\n#endif\r\n\r\nvec3 diffuse = vec3(0.0);\r\nvec3 specular= vec3(0.0);\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)\r\n\tvec3 toEye;\r\n\t#ifdef FOG\r\n\t\ttoEye=u_CameraPos-v_PositionWorld;\r\n\t\tfloat toEyeLength=length(toEye);\r\n\t\ttoEye/=toEyeLength;\r\n\t#else\r\n\t\ttoEye=normalize(u_CameraPos-v_PositionWorld);\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tLayaAirBlinnPhongDiectionLight(vec3(0.0), 1.0, normal, vec3(1.0), toEye,u_DirectionLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n \r\n#ifdef POINTLIGHT\r\n\tLayaAirBlinnPhongPointLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_PointLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tLayaAirBlinnPhongSpotLight(v_PositionWorld, vec3(0.0), 1.0, normal, vec3(1.0), toEye, u_SpotLight, dif, spe);\r\n\tdiffuse+=dif;\r\n\tspecular+=spe;\r\n#endif\r\n\r\nvec3 globalDiffuse = u_AmbientColor;\r\n#ifdef LIGHTMAP\r\n\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tfloat shadowValue = 1.0;\r\n\t#ifdef SHADOWMAP_PSSM3\r\n\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM2\r\n\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t#endif \r\n\t#ifdef SHADOWMAP_PSSM1\r\n\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t#endif\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse) * shadowValue, gl_FragColor.a);\r\n#else\r\n\tgl_FragColor = vec4(gl_FragColor.rgb * (globalDiffuse + diffuse), gl_FragColor.a);\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t#ifdef RECEIVESHADOW\r\n\t\tgl_FragColor.rgb += specular * shadowValue;\r\n\t#else\r\n\t\tgl_FragColor.rgb += specular;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tfloat lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n#endif\r\n}\r\n\r\n\r\n\r\n\r\n\r\n',
        dr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec2 a_Texcoord0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(LIGHTMAP)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\tuniform mat4 u_WorldMat;\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n#endif\r\n\r\n#ifdef RECEIVESHADOW\r\n\tvarying float v_posViewZ;\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n  \r\n\tv_Texcoord0 = a_Texcoord0;\r\n  \r\n\t#ifdef LIGHTMAP\r\n\t\tv_LightMapUV = vec2(a_Texcoord0.x, 1.0 - a_Texcoord0.y) * u_LightmapScaleOffset.xy + u_LightmapScaleOffset.zw;\r\n\t\tv_LightMapUV.y = 1.0 - v_LightMapUV.y;\r\n\t#endif\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_Normal = a_Normal;\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(FOG)||(defined(RECEIVESHADOW)&&defined(SHADOWMAP_PSSM1))\r\n\t\tv_PositionWorld=(u_WorldMat*a_Position).xyz;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        ur = "\r\nstruct DirectionLight {\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight {\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat Spot;\r\n\tfloat Range;\r\n};\r\n\r\n// Laya中使用衰减纹理\r\nfloat LayaAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat fRatio = clamp(length(L) * invLightRadius,0.0,1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio)* clamp(4.0*(1.0 - fRatio),0.0,1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\n// Same as Just Cause 2 and Crysis 2 (you can read GPU Pro 1 book for more information)\r\nfloat BasicAttenuation(in vec3 L,in float invLightRadius) {\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = clamp(1.0 - dot(distance, distance),0.0,1.0); // Equals float attenuation = saturate(1.0f - dot(L, L) / (lightRadius *  lightRadius));\r\n\treturn attenuation * attenuation;\r\n}\r\n\r\n// Inspired on http://fools.slindev.com/viewtopic.php?f=11&t=21&view=unread#unread\r\nfloat NaturalAttenuation(in vec3 L,in float invLightRadius) {\r\n\tfloat attenuationFactor = 30.0;\r\n\tvec3 distance = L * invLightRadius;\r\n\tfloat attenuation = dot(distance, distance); // Equals float attenuation = dot(L, L) / (lightRadius *  lightRadius);\r\n\tattenuation = 1.0 / (attenuation * attenuationFactor + 1.0);\r\n\t// Second we move down the function therewith it reaches zero at abscissa 1:\r\n\tattenuationFactor = 1.0 / (attenuationFactor + 1.0); //attenuationFactor contains now the value we have to subtract\r\n\tattenuation = max(attenuation - attenuationFactor, 0.0); // The max fixes a bug.\r\n\t// Finally we expand the equation along the y-axis so that it starts with a function value of 1 again.\r\n\tattenuation /= 1.0 - attenuationFactor;\r\n\treturn attenuation;\r\n}\r\n\r\nvoid LayaAirBlinnPhongLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir,in vec3 lightColor, in vec3 lightVec,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tmediump vec3 h = normalize(viewDir-lightVec);\r\n\tlowp float ln = max (0.0, dot (-lightVec,normal));\r\n\tfloat nh = max (0.0, dot (h,normal));\r\n\tdiffuseColor=lightColor * ln;\r\n\tspecularColor=lightColor *specColor*pow (nh, specColorIntensity*128.0) * gloss;\r\n}\r\n\r\nvoid LayaAirBlinnPhongDiectionLight (in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in DirectionLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec=normalize(light.Direction);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec,diffuseColor,specularColor);\r\n}\r\n\r\nvoid LayaAirBlinnPhongPointLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in PointLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range )\r\n\t//\treturn;\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,lightVec/length(lightVec),diffuseColor,specularColor);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range);\r\n\tdiffuseColor *= attenuate;\r\n\tspecularColor*= attenuate;\r\n}\r\n\r\nvoid LayaAirBlinnPhongSpotLight (in vec3 pos,in vec3 specColor,in float specColorIntensity,in vec3 normal,in vec3 gloss, in vec3 viewDir, in SpotLight light,out vec3 diffuseColor,out vec3 specularColor) {\r\n\tvec3 lightVec =  pos-light.Position;\r\n\t//if( length(lightVec) > light.Range)\r\n\t//\treturn;\r\n\r\n\tvec3 normalLightVec=lightVec/length(lightVec);\r\n\tLayaAirBlinnPhongLight(specColor,specColorIntensity,normal,gloss,viewDir,light.Color,normalLightVec,diffuseColor,specularColor);\r\n\tvec2 cosAngles=cos(vec2(light.Spot,light.Spot*0.5)*0.5);//ConeAttenuation\r\n\tfloat dl=dot(normalize(light.Direction),normalLightVec);\r\n\tdl*=smoothstep(cosAngles[0],cosAngles[1],dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range)*dl;\r\n\tdiffuseColor *=attenuate;\r\n\tspecularColor *=attenuate;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace(vec3 normalMapSample, vec3 unitNormal, vec3 tangent,vec3 binormal) {\r\n\tvec3 normalT =vec3(2.0*normalMapSample.x - 1.0,1.0-2.0*normalMapSample.y,2.0*normalMapSample.z - 1.0);\r\n\r\n\t// Build orthonormal basis.\r\n\tvec3 N = normalize(unitNormal);\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN*normalT;\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 NormalSampleToWorldSpace1(vec4 normalMapSample, vec3 tangent, vec3 binormal, vec3 unitNormal) {\r\n\tvec3 normalT;\r\n\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\r\n\tvec3 T = normalize(tangent);\r\n\tvec3 B = normalize(binormal);\r\n\tvec3 N = normalize(unitNormal);\r\n\tmat3 TBN = mat3(T, B, N);\r\n\r\n\t// Transform from tangent space to world space.\r\n\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\r\n\treturn bumpedNormal;\r\n}\r\n\r\nvec3 DecodeLightmap(vec4 color) {\r\n\treturn color.rgb*color.a*5.0;\r\n}\r\n\r\nvec2 TransformUV(vec2 texcoord,vec4 tilingOffset) {\r\n\tvec2 transTexcoord=vec2(texcoord.x,texcoord.y-1.0)*tilingOffset.xy+vec2(tilingOffset.z,-tilingOffset.w);\r\n\ttransTexcoord.y+=1.0;\r\n\treturn transTexcoord;\r\n}\r\n\r\nvec4 remapGLPositionZ(vec4 position) {\r\n\tposition.z=position.z * 2.0 - position.w;\r\n\treturn position;\r\n}\r\n\r\nmat3 inverse(mat3 m) {\r\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\r\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\r\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\r\n\r\n  float b01 = a22 * a11 - a12 * a21;\r\n  float b11 = -a22 * a10 + a12 * a20;\r\n  float b21 = a21 * a10 - a11 * a20;\r\n\r\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\r\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\r\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\r\n}\r\n\r\n",
        fr = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec4 v_Color;\r\nuniform vec4 u_Color;\r\n\r\nvoid main()\r\n{\r\n  gl_FragColor = v_Color * u_Color; \r\n}\r\n\r\n",
        Er = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_MvpMatrix;\r\nuniform vec4 u_Color;\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\n\r\n\r\nvoid main()\r\n{\r\n\tgl_Position = u_MvpMatrix * a_Position;\r\n\tv_Color=a_Color*u_Color;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        Tr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nuniform vec4 u_DiffuseColor;\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef DIFFUSEMAP\r\n\tuniform sampler2D u_DiffuseTexture;\r\n#endif\r\n\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tvarying vec2 v_LightMapUV;\r\n\tuniform sampler2D u_LightMap;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tuniform vec3 u_MaterialSpecular;\r\n\tuniform float u_Shininess;\r\n\t#ifdef SPECULARMAP \r\n\t\tuniform sampler2D u_SpecularTexture;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tvarying vec3 v_Normal;\r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tuniform sampler2D u_NormalTexture;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\nuniform vec3 u_AmbientColor;\r\n\r\n\r\n#if defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#include "ShadowHelper.glsl"\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\t//gl_FragColor=vec4(v_posViewZ,0.0,0.0,1.0);\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_DiffuseTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\nvoid main_normal()\r\n{\r\n\tvec3 globalDiffuse=u_AmbientColor;\r\n\t#ifdef LIGHTMAP\t\r\n\t\tglobalDiffuse += DecodeLightmap(texture2D(u_LightMap, v_LightMapUV));\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 normal;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tvec3 normalMapSample = texture2D(u_NormalTexture, v_Texcoord0).rgb;\r\n\t\t\tnormal = normalize(NormalSampleToWorldSpace(normalMapSample, v_Normal, v_Tangent,v_Binormal));\r\n\t\t#else\r\n\t\t\tnormal = normalize(v_Normal);\r\n\t\t#endif\r\n\t\tvec3 viewDir= normalize(v_ViewDir);\r\n\t#endif\r\n\t\r\n\tvec4 mainColor=u_DiffuseColor;\r\n\t#ifdef DIFFUSEMAP\r\n\t\tvec4 difTexColor=texture2D(u_DiffuseTexture, v_Texcoord0);\r\n\t\tmainColor=mainColor*difTexColor;\r\n\t#endif \r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tmainColor=mainColor*v_Color;\r\n\t#endif \r\n    \r\n\t#ifdef ALPHATEST\r\n\t\tif(mainColor.a<u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\t\r\n\tvec3 diffuse = vec3(0.0);\r\n\tvec3 specular= vec3(0.0);\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tvec3 dif,spe;\r\n\t\t#ifdef SPECULARMAP\r\n\t\t\tvec3 gloss=texture2D(u_SpecularTexture, v_Texcoord0).rgb;\r\n\t\t#else\r\n\t\t\t#ifdef DIFFUSEMAP\r\n\t\t\t\tvec3 gloss=vec3(difTexColor.a);\r\n\t\t\t#else\r\n\t\t\t\tvec3 gloss=vec3(1.0);\r\n\t\t\t#endif\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tLayaAirBlinnPhongDiectionLight(u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_DirectionLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tLayaAirBlinnPhongPointLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_PointLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef SPOTLIGHT\r\n\t\tLayaAirBlinnPhongSpotLight(v_PositionWorld,u_MaterialSpecular,u_Shininess,normal,gloss,viewDir,u_SpotLight,dif,spe);\r\n\t\tdiffuse+=dif;\r\n\t\tspecular+=spe;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3(u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2(u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1(u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse*shadowValue),mainColor.a);\r\n\t#else\r\n\t\tgl_FragColor =vec4(mainColor.rgb*(globalDiffuse + diffuse),mainColor.a);\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\t#ifdef RECEIVESHADOW\r\n\t\t\tgl_FragColor.rgb+=specular*shadowValue;\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb+=specular;\r\n\t\t#endif\r\n\t#endif\r\n\t  \r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n',
        mr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n\r\n#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))||(defined(LIGHTMAP)&&defined(UV))\r\n\tattribute vec2 a_Texcoord0;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\n#if defined(LIGHTMAP)&&defined(UV1)\r\n\tattribute vec2 a_Texcoord1;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\n\tuniform vec4 u_LightmapScaleOffset;\r\n\tvarying vec2 v_LightMapUV;\r\n#endif\r\n\r\n#ifdef COLOR\r\n\tattribute vec4 a_Color;\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\tattribute vec3 a_Normal;\r\n\tvarying vec3 v_Normal; \r\n\tuniform vec3 u_CameraPos;\r\n\tvarying vec3 v_ViewDir; \r\n#endif\r\n\r\n#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\tattribute vec4 a_Tangent0;\r\n\tvarying vec3 v_Tangent;\r\n\tvarying vec3 v_Binormal;\r\n#endif\r\n\r\n#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t#ifdef GPU_INSTANCE\r\n\t\tattribute mat4 a_WorldMat;\r\n\t#else\r\n\t\tuniform mat4 u_WorldMat;\r\n\t#endif\r\n\tvarying vec3 v_PositionWorld;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n  varying vec4 v_lightMVPPos;\r\n  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&defined(NORMALMAP)\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#if defined(DIFFUSEMAP)||((defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))&&(defined(SPECULARMAP)||defined(NORMALMAP)))\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t\t#else\r\n\t\t\tv_Texcoord0=a_Texcoord0;\r\n\t\t#endif\r\n\t#endif\r\n\r\n\t#ifdef LIGHTMAP\r\n\t\t#ifdef SCALEOFFSETLIGHTINGMAPUV\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord1.x,1.0-a_Texcoord1.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=vec2(a_Texcoord0.x,1.0-a_Texcoord0.y)*u_LightmapScaleOffset.xy+u_LightmapScaleOffset.zw;\r\n\t\t\t#endif \r\n\t\t\tv_LightMapUV.y=1.0-v_LightMapUV.y;\r\n\t\t#else\r\n\t\t\t#ifdef UV1\r\n\t\t\t\tv_LightMapUV=a_Texcoord1;\r\n\t\t\t#else\r\n\t\t\t\tv_LightMapUV=a_Texcoord0;\r\n\t\t\t#endif \r\n\t\t#endif \r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color=a_Color;\r\n\t#endif\r\n\r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
        pr = "#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_TextureCoordinate;\r\nuniform sampler2D u_texture;\r\nuniform vec4 u_Tintcolor;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n\t//uniform vec3 u_CameraPos;\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_MeshColor;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\t\t\r\n\t#ifdef DIFFUSEMAP\r\n\t\tif(v_Discard!=0.0)\r\n\t\t\tdiscard;\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=texture2D(u_texture,v_TextureCoordinate)*v_Color;\r\n\t\t#endif\r\n\t#else\r\n\t\t#ifdef TINTCOLOR\r\n\t\t\tgl_FragColor*=u_Tintcolor*2.0*v_Color;\r\n\t\t#else\r\n\t\t\tgl_FragColor*=v_Color;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\t//vec3 toEye=u_CameraPos-v_PositionWorld;\r\n\t\t//float toEyeLength=length(toEye);\r\n\t\t//toEye/=toEyeLength;\r\n\t\t\r\n\t\t//float lerpFact=clamp((toEyeLength-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\t//gl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact=clamp((1.0/gl_FragCoord.w-u_FogStart)/u_FogRange,0.0,1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,vec3(0.0,0.0,0.0),lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb=mix(gl_FragColor.rgb,u_FogColor,lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n}",
        gr = '#include "Lighting.glsl";\r\n\r\n#ifdef HIGHPRECISION\r\n  precision highp float;\r\n#else\r\n  precision mediump float;\r\n#endif\r\n\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec4 a_CornerTextureCoordinate;\r\n#endif\r\n#ifdef RENDERMODE_MESH\r\n\tattribute vec3 a_MeshPosition;\r\n\tattribute vec4 a_MeshColor;\r\n\tattribute vec2 a_MeshTextureCoordinate;\r\n\tvarying vec4 v_MeshColor;\r\n#endif\r\n\r\nattribute vec4 a_ShapePositionStartLifeTime;\r\nattribute vec4 a_DirectionTime;\r\nattribute vec4 a_StartColor;\r\nattribute vec3 a_StartSize;\r\nattribute vec3 a_StartRotation0;\r\nattribute float a_StartSpeed;\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n  attribute vec4 a_Random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONRANDOMCURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  attribute vec4 a_Random1;\r\n#endif\r\nattribute vec3 a_SimulationWorldPostion;\r\nattribute vec4 a_SimulationWorldRotation;\r\n\r\nvarying float v_Discard;\r\nvarying vec4 v_Color;\r\n#ifdef DIFFUSEMAP\r\n\tvarying vec2 v_TextureCoordinate;\r\n#endif\r\n\r\nuniform float u_CurrentTime;\r\nuniform vec3 u_Gravity;\r\n\r\nuniform vec3 u_WorldPosition;\r\nuniform vec4 u_WorldRotation;\r\nuniform bool u_ThreeDStartRotation;\r\nuniform int u_ScalingMode;\r\nuniform vec3 u_PositionScale;\r\nuniform vec3 u_SizeScale;\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\n#ifdef STRETCHEDBILLBOARD\r\n\tuniform vec3 u_CameraPos;\r\n#endif\r\nuniform vec3 u_CameraDirection;//TODO:只有几种广告牌模式需要用\r\nuniform vec3 u_CameraUp;\r\n\r\nuniform  float u_StretchedBillboardLengthScale;\r\nuniform  float u_StretchedBillboardSpeedScale;\r\nuniform int u_SimulationSpace;\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  int  u_VOLSpaceType;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)\r\n  uniform  vec3 u_VOLVelocityConst;\r\n#endif\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n  uniform  vec2 u_VOLVelocityGradientX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientZ[4];//x为key,y为速度\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n  uniform  vec3 u_VOLVelocityConstMax;\r\n#endif\r\n#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n  uniform  vec2 u_VOLVelocityGradientMaxX[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxY[4];//x为key,y为速度\r\n  uniform  vec2 u_VOLVelocityGradientMaxZ[4];//x为key,y为速度\r\n#endif\r\n\r\n#ifdef COLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n#ifdef RANDOMCOLOROVERLIFETIME\r\n  uniform  vec4 u_ColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_ColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n  uniform  vec4 u_MaxColorOverLifeGradientColors[4];//x为key,yzw为Color\r\n  uniform  vec2 u_MaxColorOverLifeGradientAlphas[4];//x为key,y为Alpha\r\n#endif\r\n\r\n\r\n#if defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMERANDOMCURVES)\r\n  uniform  vec2 u_SOLSizeGradient[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n  uniform  vec2 u_SOLSizeGradientMax[4];//x为key,y为尺寸\r\n#endif\r\n#if defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\n  uniform  vec2 u_SOLSizeGradientX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientZ[4];//x为key,y为尺寸\r\n#endif\r\n#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n  uniform  vec2 u_SOLSizeGradientMaxX[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxY[4];//x为key,y为尺寸\r\n  uniform  vec2 u_SOLSizeGradientMaxZ[4];//x为key,y为尺寸\r\n#endif\r\n\r\n\r\n#ifdef ROTATIONOVERLIFETIME\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  float u_ROLAngularVelocityConst;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  float u_ROLAngularVelocityConstMax;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradient[4];//x为key,y为旋转\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMax[4];//x为key,y为旋转\r\n  #endif\r\n#endif\r\n#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n  #if defined(ROTATIONOVERLIFETIMECONSTANT)||defined(ROTATIONOVERLIFETIMERANDOMCONSTANTS)\r\n    uniform  vec3 u_ROLAngularVelocityConstSeprarate;\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n    uniform  vec3 u_ROLAngularVelocityConstMaxSeprarate;\r\n  #endif\r\n  #if defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\n    uniform  vec2 u_ROLAngularVelocityGradientX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientZ[4];\r\n  #endif\r\n  #ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxX[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxY[4];\r\n    uniform  vec2 u_ROLAngularVelocityGradientMaxZ[4];\r\n\tuniform  vec2 u_ROLAngularVelocityGradientMaxW[4];\r\n  #endif\r\n#endif\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\n  uniform  float u_TSACycles;\r\n  uniform  vec2 u_TSASubUVLength;\r\n  uniform  vec2 u_TSAGradientUVs[4];//x为key,y为frame\r\n#endif\r\n#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n  uniform  vec2 u_TSAMaxGradientUVs[4];//x为key,y为frame\r\n#endif\r\n\r\n#ifdef FOG\r\n\t//varying vec3 v_PositionWorld;\r\n#endif\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvec3 rotationByEuler(in vec3 vector,in vec3 rot)\r\n{\r\n\tfloat halfRoll = rot.z * 0.5;\r\n    float halfPitch = rot.x * 0.5;\r\n\tfloat halfYaw = rot.y * 0.5;\r\n\r\n\tfloat sinRoll = sin(halfRoll);\r\n\tfloat cosRoll = cos(halfRoll);\r\n\tfloat sinPitch = sin(halfPitch);\r\n\tfloat cosPitch = cos(halfPitch);\r\n\tfloat sinYaw = sin(halfYaw);\r\n\tfloat cosYaw = cos(halfYaw);\r\n\r\n\tfloat quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\r\n\tfloat quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\r\n\tfloat quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\r\n\tfloat quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\n//假定axis已经归一化\r\nvec3 rotationByAxis(in vec3 vector,in vec3 axis, in float angle)\r\n{\r\n\tfloat halfAngle = angle * 0.5;\r\n\tfloat sin = sin(halfAngle);\r\n\t\r\n\tfloat quaX = axis.x * sin;\r\n\tfloat quaY = axis.y * sin;\r\n\tfloat quaZ = axis.z * sin;\r\n\tfloat quaW = cos(halfAngle);\r\n\t\r\n\t//vec4 q=vec4(quaX,quaY,quaZ,quaW);\r\n\t//vec3 temp = cross(q.xyz, vector) + q.w * vector;\r\n\t//return (cross(temp, -q.xyz) + dot(q.xyz,vector) * q.xyz + q.w * temp);\r\n\t\r\n\tfloat x = quaX + quaX;\r\n    float y = quaY + quaY;\r\n    float z = quaZ + quaZ;\r\n    float wx = quaW * x;\r\n    float wy = quaW * y;\r\n    float wz = quaW * z;\r\n\tfloat xx = quaX * x;\r\n    float xy = quaX * y;\r\n\tfloat xz = quaX * z;\r\n    float yy = quaY * y;\r\n    float yz = quaY * z;\r\n    float zz = quaZ * z;\r\n\r\n    return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\r\n                ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\r\n                ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\r\n\t\r\n}\r\n\r\nvec3 rotationByQuaternions(in vec3 v,in vec4 q) \r\n{\r\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\n \r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(SIZEOVERLIFETIMECURVE)||defined(SIZEOVERLIFETIMECURVESEPERATE)||defined(SIZEOVERLIFETIMERANDOMCURVES)||defined(SIZEOVERLIFETIMERANDOMCURVESSEPERATE)\r\nfloat getCurValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat curValue;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\tcurValue=mix(lastGradientNumber.y,gradientNumber.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn curValue;\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)||defined(ROTATIONOVERLIFETIMECURVE)||defined(ROTATIONOVERLIFETIMERANDOMCURVES)\r\nfloat getTotalValueFromGradientFloat(in vec2 gradientNumbers[4],in float normalizedAge)\r\n{\r\n\tfloat totalValue=0.0;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientNumber=gradientNumbers[i];\r\n\t\tfloat key=gradientNumber.x;\r\n\t\tvec2 lastGradientNumber=gradientNumbers[i-1];\r\n\t\tfloat lastValue=lastGradientNumber.y;\r\n\t\t\r\n\t\tif(key>=normalizedAge){\r\n\t\t\tfloat lastKey=lastGradientNumber.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\ttotalValue+=(lastValue+mix(lastValue,gradientNumber.y,age))/2.0*a_ShapePositionStartLifeTime.w*(normalizedAge-lastKey);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse{\r\n\t\t\ttotalValue+=(lastValue+gradientNumber.y)/2.0*a_ShapePositionStartLifeTime.w*(key-lastGradientNumber.x);\r\n\t\t}\r\n\t}\r\n\treturn totalValue;\r\n}\r\n#endif\r\n\r\n#if defined(COLOROVERLIFETIME)||defined(RANDOMCOLOROVERLIFETIME)\r\nvec4 getColorFromGradient(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float normalizedAge)\r\n{\r\n\tvec4 overTimeColor;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientAlpha=gradientAlphas[i];\r\n\t\tfloat alphaKey=gradientAlpha.x;\r\n\t\tif(alphaKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientAlpha=gradientAlphas[i-1];\r\n\t\t\tfloat lastAlphaKey=lastGradientAlpha.x;\r\n\t\t\tfloat age=(normalizedAge-lastAlphaKey)/(alphaKey-lastAlphaKey);\r\n\t\t\toverTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec4 gradientColor=gradientColors[i];\r\n\t\tfloat colorKey=gradientColor.x;\r\n\t\tif(colorKey>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec4 lastGradientColor=gradientColors[i-1];\r\n\t\t\tfloat lastColorKey=lastGradientColor.x;\r\n\t\t\tfloat age=(normalizedAge-lastColorKey)/(colorKey-lastColorKey);\r\n\t\t\toverTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn overTimeColor;\r\n}\r\n#endif\r\n\r\n\r\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONRANDOMCURVE)\r\nfloat getFrameFromGradient(in vec2 gradientFrames[4],in float normalizedAge)\r\n{\r\n\tfloat overTimeFrame;\r\n\tfor(int i=1;i<4;i++)\r\n\t{\r\n\t\tvec2 gradientFrame=gradientFrames[i];\r\n\t\tfloat key=gradientFrame.x;\r\n\t\tif(key>=normalizedAge)\r\n\t\t{\r\n\t\t\tvec2 lastGradientFrame=gradientFrames[i-1];\r\n\t\t\tfloat lastKey=lastGradientFrame.x;\r\n\t\t\tfloat age=(normalizedAge-lastKey)/(key-lastKey);\r\n\t\t\toverTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn floor(overTimeFrame);\r\n}\r\n#endif\r\n\r\n#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\nvec3 computeParticleLifeVelocity(in float normalizedAge)\r\n{\r\n  vec3 outLifeVelocity;\r\n  #ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t outLifeVelocity=u_VOLVelocityConst; \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMECURVE\r\n     outLifeVelocity= vec3(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t outLifeVelocity=mix(u_VOLVelocityConst,u_VOLVelocityConstMax,vec3(a_Random1.y,a_Random1.z,a_Random1.w)); \r\n  #endif\r\n  #ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n     outLifeVelocity=vec3(mix(getCurValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y),\r\n\t                 mix(getCurValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z),\r\n\t\t\t\t\t mix(getCurValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getCurValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n  #endif\r\n\t\t\t\t\t\r\n  return outLifeVelocity;\r\n} \r\n#endif\r\n\r\nvec3 computeParticlePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float normalizedAge,vec3 gravityVelocity,vec4 worldRotation)\r\n{\r\n   vec3 startPosition;\r\n   vec3 lifePosition;\r\n   #if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t#ifdef VELOCITYOVERLIFETIMECONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMECURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCONSTANT\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=lifeVelocity*age;\r\n\t#endif\r\n\t#ifdef VELOCITYOVERLIFETIMERANDOMCURVE\r\n\t\t  startPosition=startVelocity*age;\r\n\t\t  lifePosition=vec3(mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxX,normalizedAge),a_Random1.y)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxY,normalizedAge),a_Random1.z)\r\n\t      ,mix(getTotalValueFromGradientFloat(u_VOLVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_VOLVelocityGradientMaxZ,normalizedAge),a_Random1.w));\r\n\t#endif\r\n\t\r\n\tvec3 finalPosition;\r\n\tif(u_VOLSpaceType==0){\r\n\t  if(u_ScalingMode!=2)\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition),worldRotation);\r\n\t  else\r\n\t   finalPosition =rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition+lifePosition,worldRotation);\r\n\t}\r\n\telse{\r\n\t  if(u_ScalingMode!=2)\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation)+lifePosition;\r\n\t  else\r\n\t    finalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation)+lifePosition;\r\n\t}\r\n  #else\r\n\t startPosition=startVelocity*age;\r\n\t vec3 finalPosition;\r\n\t if(u_ScalingMode!=2)\r\n\t\t\tfinalPosition = rotationByQuaternions(u_PositionScale*(a_ShapePositionStartLifeTime.xyz+startPosition),worldRotation);\r\n\t else\r\n\t   \tfinalPosition = rotationByQuaternions(u_PositionScale*a_ShapePositionStartLifeTime.xyz+startPosition,worldRotation);\r\n  #endif\r\n  \r\n  if(u_SimulationSpace==0)\r\n    finalPosition=finalPosition+a_SimulationWorldPostion;\r\n  else if(u_SimulationSpace==1) \r\n    finalPosition=finalPosition+u_WorldPosition;\r\n  \r\n  finalPosition+=0.5*gravityVelocity*age;\r\n \r\n  return  finalPosition;\r\n}\r\n\r\n\r\nvec4 computeParticleColor(in vec4 color,in float normalizedAge)\r\n{\r\n\t#ifdef COLOROVERLIFETIME\r\n\t  color*=getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge);\r\n\t#endif\r\n\t\r\n\t#ifdef RANDOMCOLOROVERLIFETIME\r\n\t  color*=mix(getColorFromGradient(u_ColorOverLifeGradientAlphas,u_ColorOverLifeGradientColors,normalizedAge),getColorFromGradient(u_MaxColorOverLifeGradientAlphas,u_MaxColorOverLifeGradientColors,normalizedAge),a_Random0.y);\r\n\t#endif\r\n\r\n    return color;\r\n}\r\n\r\nvec2 computeParticleSizeBillbard(in vec2 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec2(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec2(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n\r\n#ifdef RENDERMODE_MESH\r\nvec3 computeParticleSizeMesh(in vec3 size,in float normalizedAge)\r\n{\r\n\t#ifdef SIZEOVERLIFETIMECURVE\r\n\t\tsize*=getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge);\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVES\r\n\t    size*=mix(getCurValueFromGradientFloat(u_SOLSizeGradient,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMax,normalizedAge),a_Random0.z); \r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMECURVESEPERATE\r\n\t\tsize*=vec3(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge));\r\n\t#endif\r\n\t#ifdef SIZEOVERLIFETIMERANDOMCURVESSEPERATE\r\n\t    size*=vec3(mix(getCurValueFromGradientFloat(u_SOLSizeGradientX,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxX,normalizedAge),a_Random0.z)\r\n\t    ,mix(getCurValueFromGradientFloat(u_SOLSizeGradientY,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxY,normalizedAge),a_Random0.z)\r\n\t\t,mix(getCurValueFromGradientFloat(u_SOLSizeGradientZ,normalizedAge),getCurValueFromGradientFloat(u_SOLSizeGradientMaxZ,normalizedAge),a_Random0.z));\r\n\t#endif\r\n\treturn size;\r\n}\r\n#endif\r\n\r\nfloat computeParticleRotationFloat(in float rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConstSeprarate.z*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConstSeprarate.z,u_ROLAngularVelocityConstMaxSeprarate.z,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n\r\n#if defined(RENDERMODE_MESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE))\r\nvec3 computeParticleRotationVec3(in vec3 rotation,in float age,in float normalizedAge)\r\n{ \r\n\t#ifdef ROTATIONOVERLIFETIME\r\n\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tfloat ageRot=u_ROLAngularVelocityConst*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tfloat ageRot=mix(u_ROLAngularVelocityConst,u_ROLAngularVelocityConstMax,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradient,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMax,normalizedAge),a_Random0.w);\r\n\t\t#endif\r\n\t#endif\r\n\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t#ifdef ROTATIONOVERLIFETIMECONSTANT\r\n\t\t\tvec3 ageRot=u_ROLAngularVelocityConstSeprarate*age;\r\n\t        rotation+=ageRot;\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMECURVE\r\n\t\t\trotation+=vec3(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge));\r\n\t\t#endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCONSTANTS\r\n\t\t\tvec3 ageRot=mix(u_ROLAngularVelocityConstSeprarate,u_ROLAngularVelocityConstMaxSeprarate,a_Random0.w)*age;\r\n\t        rotation+=ageRot;\r\n\t    #endif\r\n\t\t#ifdef ROTATIONOVERLIFETIMERANDOMCURVES\r\n\t\t\trotation+=vec3(mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientX,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxX,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientY,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxY,normalizedAge),a_Random0.w)\r\n\t        ,mix(getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientZ,normalizedAge),getTotalValueFromGradientFloat(u_ROLAngularVelocityGradientMaxZ,normalizedAge),a_Random0.w));\r\n\t\t#endif\r\n\t#endif\r\n\treturn rotation;\r\n}\r\n#endif\r\n\r\nvec2 computeParticleUV(in vec2 uv,in float normalizedAge)\r\n{ \r\n\t#ifdef TEXTURESHEETANIMATIONCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat frame=getFrameFromGradient(u_TSAGradientUVs,cycleNormalizedAge-floor(cycleNormalizedAge));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\t#ifdef TEXTURESHEETANIMATIONRANDOMCURVE\r\n\t\tfloat cycleNormalizedAge=normalizedAge*u_TSACycles;\r\n\t\tfloat uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\r\n\t    float frame=floor(mix(getFrameFromGradient(u_TSAGradientUVs,uvNormalizedAge),getFrameFromGradient(u_TSAMaxGradientUVs,uvNormalizedAge),a_Random1.x));\r\n\t\tfloat totalULength=frame*u_TSASubUVLength.x;\r\n\t\tfloat floorTotalULength=floor(totalULength);\r\n\t    uv.x+=totalULength-floorTotalULength;\r\n\t\tuv.y+=floorTotalULength*u_TSASubUVLength.y;\r\n    #endif\r\n\treturn uv;\r\n}\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_CurrentTime - a_DirectionTime.w;\r\n\tfloat normalizedAge = age/a_ShapePositionStartLifeTime.w;\r\n\tvec3 lifeVelocity;\r\n\tif(normalizedAge<1.0){ \r\n\tvec3 startVelocity=a_DirectionTime.xyz*a_StartSpeed;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t\tlifeVelocity= computeParticleLifeVelocity(normalizedAge);//计算粒子生命周期速度\r\n\t#endif \r\n\tvec3 gravityVelocity=u_Gravity*age;\r\n\t\r\n\tvec4 worldRotation;\r\n\tif(u_SimulationSpace==0)\r\n\t\tworldRotation=a_SimulationWorldRotation;\r\n\telse\r\n\t\tworldRotation=u_WorldRotation;\r\n\t\r\n\tvec3 center=computeParticlePosition(startVelocity, lifeVelocity, age, normalizedAge,gravityVelocity,worldRotation);//计算粒子位置\r\n   \r\n   \r\n   #ifdef SPHERHBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        vec3 cameraUpVector =normalize(u_CameraUp);//TODO:是否外面归一化\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n        vec3 upVector = normalize(cross(sideVector,u_CameraDirection));\r\n\t    corner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z,age,normalizedAge));\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,rotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\tfloat c = cos(rot);\r\n\t\t\t\tfloat s = sin(rot);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter += u_SizeScale.xzy*rotationByEuler(corner.x*sideVector+corner.y*upVector,a_StartRotation0);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tfloat c = cos(a_StartRotation0.x);\r\n\t\t\t\tfloat s = sin(a_StartRotation0.x);\r\n\t\t\t\tmat2 rotation= mat2(c, -s, s, c);\r\n\t\t\t\tcorner=rotation*corner;\r\n\t\t\t\tcenter += u_SizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\r\n\t\t\t}\r\n\t\t#endif\r\n   #endif\r\n   \r\n   #ifdef STRETCHEDBILLBOARD\r\n\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n\tvec3 velocity;\r\n\t#if defined(VELOCITYOVERLIFETIMECONSTANT)||defined(VELOCITYOVERLIFETIMECURVE)||defined(VELOCITYOVERLIFETIMERANDOMCONSTANT)||defined(VELOCITYOVERLIFETIMERANDOMCURVE)\r\n\t    if(u_VOLSpaceType==0)\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*(startVelocity+lifeVelocity),worldRotation)+gravityVelocity;\r\n\t    else\r\n\t\t  velocity=rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+lifeVelocity+gravityVelocity;\r\n    #else\r\n\t    velocity= rotationByQuaternions(u_SizeScale*startVelocity,worldRotation)+gravityVelocity;\r\n    #endif\t\r\n\t\tvec3 cameraUpVector = normalize(velocity);\r\n\t\tvec3 direction = normalize(center-u_CameraPos);\r\n        vec3 sideVector = normalize(cross(direction,normalize(velocity)));\r\n\t\t\r\n\t\tsideVector=u_SizeScale.xzy*sideVector;\r\n\t\tcameraUpVector=length(vec3(u_SizeScale.x,0.0,0.0))*cameraUpVector;\r\n\t\t\r\n\t    vec2 size=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n\t\t\r\n\t    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\r\n\t    corner=rotaionZHalfPI*corner;\r\n\t    corner.y=corner.y-abs(corner.y);\r\n\t\t\r\n\t    float speed=length(velocity);//TODO:\r\n\t    center +=sign(u_SizeScale.x)*(sign(u_StretchedBillboardLengthScale)*size.x*corner.x*sideVector+(speed*u_StretchedBillboardSpeedScale+size.y*u_StretchedBillboardLengthScale)*corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef HORIZONTALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\r\n\t    const vec3 sideVector = vec3(-1.0,0.0,0.0);\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef VERTICALBILLBOARD\r\n\t\tvec2 corner=a_CornerTextureCoordinate.xy;//Billboard模式z轴无效\r\n        const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\r\n        vec3 sideVector = normalize(cross(u_CameraDirection,cameraUpVector));\r\n\t\t\r\n\t\tfloat rot = computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n        float c = cos(rot);\r\n        float s = sin(rot);\r\n        mat2 rotation= mat2(c, -s, s, c);\r\n\t    corner=rotation*corner*cos(0.78539816339744830961566084581988);//TODO:临时缩小cos45,不确定U3D原因\r\n\t\tcorner*=computeParticleSizeBillbard(a_StartSize.xy,normalizedAge);\r\n        center +=u_SizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\r\n   #endif\r\n   \r\n   #ifdef RENDERMODE_MESH\r\n\t    vec3 size=computeParticleSizeMesh(a_StartSize,normalizedAge);\r\n\t\t#if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONOVERLIFETIMESEPERATE)\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tvec3 rotation=vec3(a_StartRotation0.xy,computeParticleRotationFloat(a_StartRotation0.z, age,normalizedAge));\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,rotation),worldRotation);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIME\r\n\t\t\t\t\tfloat angle=computeParticleRotationFloat(a_StartRotation0.x, age,normalizedAge);\r\n\t\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),angle),worldRotation));//已验证\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse{\r\n\t\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale.xzy*(rotationByQuaternions(rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\r\n\t\t\t\t\t\t#else\r\n\t\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle);//已验证\r\n\t\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\t\tcenter+=rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),angle),worldRotation);//已验证\r\n\t\t\t\t\t\t#endif\r\n\t\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t#ifdef ROTATIONOVERLIFETIMESEPERATE\r\n\t\t\t\t\t//TODO:是否应合并if(u_ThreeDStartRotation)分支代码,待测试\r\n\t\t\t\t\tvec3 angle=computeParticleRotationVec3(vec3(0.0,0.0,-a_StartRotation0.x), age,normalizedAge);\r\n\t\t\t\t\tcenter+= (rotationByQuaternions(rotationByEuler(u_SizeScale*a_MeshPosition*size,vec3(angle.x,angle.y,angle.z)),worldRotation));//已验证\r\n\t\t\t\t#endif\t\t\r\n\t\t\t}\r\n\t\t#else\r\n\t\t\tif(u_ThreeDStartRotation){\r\n\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByEuler(a_MeshPosition*size,a_StartRotation0),worldRotation);//已验证\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tif(a_ShapePositionStartLifeTime.x!=0.0||a_ShapePositionStartLifeTime.y!=0.0){\r\n\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x);\r\n\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\tcenter+= (rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(a_ShapePositionStartLifeTime.xy,0.0))),a_StartRotation0.x),worldRotation));//已验证\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\t#ifdef SHAPE\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,-1.0,0.0),a_StartRotation0.x),worldRotation);\t\r\n\t\t\t\t\t#else\r\n\t\t\t\t\t\tif(u_SimulationSpace==0)\r\n\t\t\t\t\t\t\tcenter+= rotationByAxis(u_SizeScale*a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x);\r\n\t\t\t\t\t\telse if(u_SimulationSpace==1)\r\n\t\t\t\t\t\t\tcenter+= rotationByQuaternions(u_SizeScale*rotationByAxis(a_MeshPosition*size,vec3(0.0,0.0,-1.0),a_StartRotation0.x),worldRotation);//已验证\r\n\t\t\t\t\t#endif\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t#endif\r\n\t\tv_MeshColor=a_MeshColor;\r\n   #endif\r\n   \r\n    gl_Position=u_Projection*u_View*vec4(center,1.0);\r\n    v_Color = computeParticleColor(a_StartColor, normalizedAge);\r\n\t#ifdef DIFFUSEMAP\r\n\t\t#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_CornerTextureCoordinate.zw, normalizedAge);\r\n\t\t#endif\r\n\t\t#ifdef RENDERMODE_MESH\r\n\t\t\tv_TextureCoordinate =computeParticleUV(a_MeshTextureCoordinate, normalizedAge);\r\n\t\t#endif\r\n\t\t\r\n\t\t#ifdef TILINGOFFSET\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y)*u_TilingOffset.xy+vec2(u_TilingOffset.z,-u_TilingOffset.w);//需要特殊处理\r\n\t\t\tv_TextureCoordinate=vec2(v_TextureCoordinate.x,1.0-v_TextureCoordinate.y);//需要特殊处理\r\n\t\t#endif\r\n\t#endif\r\n    v_Discard=0.0;\r\n\t  \r\n\t#ifdef FOG\r\n\t\t//v_PositionWorld=center;\r\n\t#endif\r\n   }\r\n   else\r\n\t{\r\n\t\tv_Discard=1.0;\r\n\t}\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\n',
        Sr = "struct LayaGI\r\n{\r\n\tvec3 diffuse;\r\n\tvec3 specular;\r\n};\r\n\r\nvec4 LayaAirBRDF(in vec3 diffuseColor, in vec3 specularColor, in float oneMinusReflectivity, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tvec3 halfDir = SafeNormalize(viewDir - lightDir);\r\n\t\r\n\tfloat nv = abs(dot(normal, viewDir));\r\n\t\r\n\tfloat nl = clamp(dot(normal,   -lightDir),  0.0, 1.0);\r\n\tfloat nh = clamp(dot(normal,     halfDir),  0.0, 1.0);\r\n\tfloat lv = clamp(dot(lightDir,   viewDir),  0.0, 1.0);\r\n\tfloat lh = clamp(dot(lightDir,  -halfDir),  0.0, 1.0);\r\n\t\r\n\tfloat diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl;\r\n\t\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\t\r\n\t//#if UNITY_BRDF_GGX\r\n\t // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\r\n\troughness = max(roughness,0.014);\r\n\tfloat V = SmithJointGGXVisibilityTerm(nl, nv, roughness);\r\n\tfloat D = GGXTerm(nh, roughness);\r\n\t\r\n\tfloat specularTerm = V * D * PI;\r\n\t\r\n\tspecularTerm = sqrt(max(0.0001, specularTerm));\r\n\tspecularTerm = max(0.0, specularTerm * nl);\r\n\t\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tfloat grazingTerm = clamp(smoothness + (1.0 - oneMinusReflectivity), 0.0, 1.0);\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = diffuseColor * (gi.diffuse+lightColor * diffuseTerm) \r\n\t\t\t  + specularTerm * lightColor * FresnelTerm (specularColor, lh);\r\n\t\t\t  //+ surfaceReduction * gi.specular * FresnelLerp(specularColor, vec3(grazingTerm), nv);\r\n\t\r\n\treturn color;\r\n}\r\nvec4 LayaAirStandardReflect(in vec4 albedoColor,in float metallic,in float smoothness,in LayaGI gi)\r\n{\r\n\tvec3 diffuseColor;\r\n\tvec3 specularColor;\r\n\tfloat alpha;\r\n\tfloat oneMinusReflectivity;\r\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tvec4 color;\r\n\tcolor.rgb = surfaceReduction * gi.specular;\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n\r\n}\r\n\r\nvec4 LayaAirSpecularReflect(in vec4 albedoColor,in vec3 specularColor,in float smoothness,in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\r\n\tfloat perceptualRoughness = SmoothnessToPerceptualRoughness(smoothness);\r\n\tfloat roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat surfaceReduction = 1.0 - 0.28 * roughness * perceptualRoughness;\r\n\tvec4 color;\r\n\tcolor.rgb = surfaceReduction * gi.specular;\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}",
        vr = '#include "PBRUtils.glsl"\r\n#include "BRDF.glsl"\r\n\r\nvec4 PBRSpecularLight(in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = EnergyConservationBetweenDiffuseAndSpecular (albedoColor.rgb, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRSpecularDiectionLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n#ifdef POINTLIGHT\r\nvec4 PBRSpecularPointLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n#endif\r\nvec4 PBRSpecularSpotLight (in vec4 albedoColor, in vec3 specularColor, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRSpecularLight(albedoColor, specularColor, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec4 SpecularGloss(float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n    vec4 sg;\r\n\t\r\n\t#ifdef SPECULARTEXTURE\r\n\t\tvec4 specularTextureColor = texture2D(u_SpecularTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.rgb = specularTextureColor.rgb;\r\n\t\t\tsg.a = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t\tsg = specularTextureColor;\r\n\t\t#endif\r\n\t\tsg.a *= u_smoothnessScale;\r\n\t#else\r\n\t\tsg.rgb = u_SpecularColor.rgb;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tsg.a = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tsg.a = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n    return sg;\r\n}\r\n\r\n',
        Rr = '#include "PBRUtils.glsl"\r\n#include "BRDF.glsl"\r\n\r\nvec4 PBRStandardLight(in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in vec3 lightDir, in vec3 lightColor, in LayaGI gi)\r\n{\r\n\tfloat oneMinusReflectivity;\r\n\tvec3 diffuseColor;\r\n\tvec3 specularColor;\r\n\tfloat alpha;\r\n\t\r\n\tdiffuseColor = DiffuseAndSpecularFromMetallic (albedoColor.rgb, metallic, specularColor, oneMinusReflectivity);\r\n\t\r\n\tdiffuseColor = LayaPreMultiplyAlpha(diffuseColor, albedoColor.a, oneMinusReflectivity, alpha);\r\n\t\r\n\tvec4 color = LayaAirBRDF(diffuseColor, specularColor, oneMinusReflectivity, smoothness, normal, viewDir, lightDir, lightColor, gi);\r\n\tcolor.a = alpha;\r\n\treturn color;\r\n}\r\n\r\nvec4 PBRStandardDiectionLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in DirectionLight light, in LayaGI gi)\r\n{\r\n\tvec3 lightVec = normalize(light.Direction);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi);\r\n}\r\n#ifdef POINTLIGHT\r\nvec4 PBRStandardPointLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in PointLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightCoord = (u_PointLightMatrix * vec4(pos, 1.0)).xyz;\r\n\tfloat distance = dot(lightCoord, lightCoord);\r\n\tfloat attenuate = texture2D(u_RangeTexture, vec2(distance)).w;\r\n\tvec3 lightVec = normalize(pos - light.Position);\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n#endif\r\nvec4 PBRStandardSpotLight (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n{\r\n\tvec3 lightVec =  pos - light.Position;\r\n\tvec3 normalLightVec = normalize(lightVec);\r\n\tvec2 cosAngles = cos(vec2(light.SpotAngle, light.SpotAngle*0.5) * 0.5);//ConeAttenuation\r\n\tfloat dl = dot(normalize(light.Direction), normalLightVec);\r\n\tdl *= smoothstep(cosAngles[0], cosAngles[1], dl);\r\n\tfloat attenuate = LayaAttenuation(lightVec, 1.0/light.Range) * dl;\r\n\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n}\r\n\r\n//vec4 PBRStandardSpotLight1 (in vec4 albedoColor, in float metallic, in float smoothness, in vec3 normal, in vec3 viewDir, in SpotLight light, in vec3 pos, in LayaGI gi)\r\n//{\r\n//\tvec4 lightCoord = u_SpotLightMatrix * vec4(pos, 1.0);\r\n//\t\r\n//\tfloat distance = dot(lightCoord, lightCoord);\r\n//\tfloat attenuate = (lightCoord.z < 0.0) ? texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//float attenuate = (lightCoord.z < 0.0) ? texture2D(u_AngleTexture, vec2(lightCoord.x / lightCoord.w + 0.5, lightCoord.y / lightCoord.w + 0.5)).r * texture2D(u_RangeTexture, vec2(distance)).w : 0.0;\r\n//\t//vec2 _uv = vec2(pos.x * 180.0/(2.0 * pos.z) + 0.5, pos.y * 180.0/(2.0 * pos.z) + 0.5);\r\n//\tvec3 lightVec = normalize(pos - light.Position);\r\n//\treturn PBRStandardLight(albedoColor, metallic, smoothness, normal, viewDir, lightVec, light.Color, gi) * attenuate;\r\n//}\r\n\r\nvec2 MetallicGloss(in float albedoTextureAlpha, in vec2 uv0)\r\n{\r\n\tvec2 mg;\r\n\t\r\n\t#ifdef METALLICGLOSSTEXTURE\r\n\t\tvec4 metallicGlossTextureColor = texture2D(u_MetallicGlossTexture, uv0);\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.r = metallicGlossTextureColor.r;\r\n\t\t\tmg.g = albedoTextureAlpha;\r\n\t\t#else\r\n\t\t    mg = metallicGlossTextureColor.ra;\r\n\t\t#endif\r\n\t\tmg.g *= u_smoothnessScale;\r\n\t#else\r\n\t\tmg.r = u_metallic;\r\n\t\t#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\r\n\t\t\tmg.g = albedoTextureAlpha * u_smoothnessScale;\r\n\t\t#else\r\n\t\t\tmg.g = u_smoothness;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\treturn mg;\r\n}\r\n\r\n',
        Ar = "struct DirectionLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Direction;\r\n};\r\n\r\nstruct PointLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tfloat Range;\r\n};\r\n\r\nstruct SpotLight\r\n{\r\n\tvec3 Color;\r\n\tvec3 Position;\r\n\tvec3 Direction;\r\n\tfloat SpotAngle;\r\n\tfloat Range;\r\n};\r\n\r\nvec3 UnpackScaleNormal(in vec2 uv0)\r\n{\r\n\t#ifdef NORMALTEXTURE\r\n\t\tvec3 normalT;\r\n\t\tvec4 normalMapSample = texture2D(u_NormalTexture, uv0);\r\n\t\tnormalT.x = 2.0 * normalMapSample.x - 1.0;\r\n\t\tnormalT.y = 1.0 - 2.0 * normalMapSample.y;\r\n\t\tnormalT.xy *= u_normalScale;\r\n\t\tnormalT.z = sqrt(1.0 - clamp(dot(normalT.xy, normalT.xy), 0.0, 1.0));\r\n\t\t\r\n\t\tvec3 T = normalize(v_Tangent);\r\n\t\tvec3 B = normalize(v_Binormal);\r\n\t\tvec3 N = normalize(v_Normal);\r\n\t\tmat3 TBN = mat3(T, B, N);\r\n\t\t\r\n\t\tvec3 bumpedNormal = TBN * normalize(normalT);\r\n\t\treturn bumpedNormal;\r\n\t#else\r\n\t\treturn normalize(v_Normal);\r\n\t#endif\r\n}\r\n\r\nvec4 DielectricSpecularColor = vec4(0.220916301, 0.220916301, 0.220916301, 1.0 - 0.220916301);\r\n\r\nfloat PI = 3.14159265359;\r\n\r\nvec3 FresnelTerm (in vec3 F0, in float cosA)\r\n{\r\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosA, 5.0);\r\n}\r\n\r\nvec3 FresnelLerp (in vec3 F0, in vec3 F90, float cosA)\r\n{\r\n    float t = pow(1.0 - cosA, 5.0);\r\n    return mix(F0, F90, t);\r\n}\r\n\r\nfloat PerceptualRoughnessToRoughness(in float perceptualRoughness)\r\n{\r\n\treturn perceptualRoughness * perceptualRoughness;\r\n}\r\n\r\nfloat PerceptualRoughnessToSpecularPower(in float perceptualRoughness)\r\n{\r\n\tfloat m = PerceptualRoughnessToRoughness(perceptualRoughness);\r\n\tfloat sq = max(0.0001, m * m);\r\n\tfloat n = (2.0 / sq) - 2.0;\r\n\tn = max(n, 0.0001);\r\n\treturn n;\r\n}\r\n\r\nfloat RoughnessToPerceptualRoughness(in float roughness)\r\n{\r\n\treturn sqrt(roughness);\r\n}\r\n\r\nfloat SmoothnessToRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness) * (1.0 - smoothness);\r\n}\r\n\r\nfloat SmoothnessToPerceptualRoughness(in float smoothness)\r\n{\r\n\treturn (1.0 - smoothness);\r\n}\r\n\r\nvec3 SafeNormalize(in vec3 inVec)\r\n{\r\n\tfloat dp3 = max(0.001,dot(inVec,inVec));\r\n\treturn inVec * (1.0 / sqrt(dp3));\r\n}\r\n\r\nfloat DisneyDiffuse(in float NdotV, in float NdotL, in float LdotH, in float perceptualRoughness)\r\n{\r\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\r\n\tfloat lightScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotL,5.0));\r\n\tfloat viewScatter\t= (1.0 + (fd90 - 1.0) * pow(1.0 - NdotV,5.0));\r\n\r\n\treturn lightScatter * viewScatter;\r\n}\r\n\r\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\r\n{\r\n\tfloat a = roughness;\r\n\tfloat lambdaV = NdotL * (NdotV * (1.0 - a) + a);\r\n\tfloat lambdaL = NdotV * (NdotL * (1.0 - a) + a);\r\n\r\n\treturn 0.5 / (lambdaV + lambdaL + 0.00001);\r\n}\r\n\r\nfloat GGXTerm (float NdotH, float roughness)\r\n{\r\n\tfloat a2 = roughness * roughness;\r\n\tfloat d = (NdotH * a2 - NdotH) * NdotH + 1.0;\r\n\treturn 0.31830988618 * a2 / (d * d + 0.0000001);\r\n}\r\n\r\nfloat OneMinusReflectivityFromMetallic(in float metallic)\r\n{\r\n\tfloat oneMinusDielectricSpec = DielectricSpecularColor.a;\r\n\treturn oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\r\n}\r\n\r\nfloat SpecularStrength(vec3 specular)\r\n{\r\n    //(SHADER_TARGET < 30)return specular.r; \r\n    return max (max (specular.r, specular.g), specular.b);\r\n}\r\n\r\nvec3 DiffuseAndSpecularFromMetallic(in vec3 diffuseColor, in float metallic, out vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\tspecularColor = mix(DielectricSpecularColor.rgb, diffuseColor, metallic);\r\n\toneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec3 EnergyConservationBetweenDiffuseAndSpecular(in vec3 diffuseColor, in vec3 specularColor, out float oneMinusReflectivity)\r\n{\r\n\toneMinusReflectivity = 1.0 - SpecularStrength(specularColor);\r\n\treturn diffuseColor * oneMinusReflectivity;\r\n}\r\n\r\nvec4 Occlusion(in vec2 uv0){\r\n\t#ifdef OCCLUSIONTEXTURE\r\n\t\tvec4 occlusionTextureColor = texture2D(u_OcclusionTexture, uv0);\r\n\t\tfloat occ = occlusionTextureColor.g;\r\n\t\tfloat oneMinusT = 1.0 - u_occlusionStrength;\r\n\t\tfloat lerpOneTo = oneMinusT + occ * u_occlusionStrength;\r\n\t\treturn occlusionTextureColor * lerpOneTo;\r\n\t#else\r\n\t\treturn vec4(1.0);\r\n\t#endif\r\n}\r\n\r\nvec2 ParallaxOffset(in vec3 viewDir){\r\n\t#ifdef PARALLAXTEXTURE\r\n\t\tfloat h = texture2D(u_ParallaxTexture, v_Texcoord0).g;\r\n\t\th = h * u_parallaxScale - u_parallaxScale / 2.0;\r\n\t\tvec3 v = viewDir;\r\n\t\tv.z += 0.42;\r\n\t\tvec2 offset = h * (v.xy / v.z);\r\n\t\treturn v_Texcoord0 + offset;\r\n\t#else\r\n\t\treturn v_Texcoord0;\r\n\t#endif\r\n}\r\n\r\nvec3 ReflectCubeMap(in vec3 viewDir, in vec3 normal){\r\n\t#ifdef REFLECTMAP\r\n\t\tvec3 incident = -viewDir;\r\n\t\tvec3 reflectionVector = reflect(incident, normal);\r\n\t\tvec3 reflectionColor = textureCube(u_ReflectTexture, vec3(-reflectionVector.x, reflectionVector.yz)).rgb;\r\n\t\treturn reflectionColor * u_ReflectIntensity;\r\n\t#else\r\n\t\treturn vec3(0.0);\r\n\t#endif\r\n}\r\n\r\nfloat LayaAttenuation(in vec3 L, in float invLightRadius)\r\n{\r\n\tfloat fRatio = clamp(length(L) * invLightRadius, 0.0, 1.0);\r\n\tfRatio *= fRatio;\r\n\treturn 1.0 / (1.0 + 25.0 * fRatio) * clamp(4.0*(1.0 - fRatio), 0.0, 1.0); //fade to black as if 4 pixel texture\r\n}\r\n\r\nvec3 LayaPreMultiplyAlpha(vec3 diffColor, float alpha, float oneMinusReflectivity, out float outModifiedAlpha)\r\n{\r\n\t#ifdef ALPHAPREMULTIPLY\r\n\t\tdiffColor *= alpha;\r\n\t\toutModifiedAlpha = 1.0 - oneMinusReflectivity + alpha * oneMinusReflectivity;\r\n\t#else\r\n\t\toutModifiedAlpha = alpha;\r\n\t#endif\r\n\treturn diffColor;\r\n}\r\n\r\n",
        Dr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\nuniform vec4 u_SpecularColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef SPECULARTEXTURE\r\n\tuniform sampler2D u_SpecularTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\n#ifdef POINTLIGHT\r\n\tuniform mat4 u_PointLightMatrix;\r\n#endif\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include "PBRSpecularLighting.glsl"\r\n#include "ShadowHelper.glsl"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec4 sg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 albedoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = albedoTextureColor * u_AlbedoColor;\r\n\t\tsg = SpecularGloss(albedoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tsg = SpecularGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n  \r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n\t\r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n\t\r\n\t//float a = (sg.r+sg.g+sg.b) / 3.0;\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRSpecularDiectionLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularPointLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRSpecularSpotLight(albedoColor, sg.rgb, sg.a, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\r\n\t#ifdef REFLECTMAP\r\n\t \tcolor += LayaAirSpecularReflect(albedoColor,sg.rgb,sg.a,gi);\r\n\t#endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}\r\n\r\n',
        Ir = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
        xr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\nuniform vec3 u_AmbientColor;\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n#endif\r\n#ifdef METALLICGLOSSTEXTURE\r\n\tuniform sampler2D u_MetallicGlossTexture;\r\n#endif\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n\tuniform float u_normalScale;\r\n#endif\r\n#ifdef PARALLAXTEXTURE\r\n\tuniform sampler2D u_ParallaxTexture;\r\n\tuniform float u_parallaxScale;\r\n#endif\r\n#ifdef OCCLUSIONTEXTURE\r\n\tuniform sampler2D u_OcclusionTexture;\r\n\tuniform float u_occlusionStrength;\r\n#endif\r\n#ifdef EMISSION\r\n\t#ifdef EMISSIONTEXTURE\r\n\t\tuniform sampler2D u_EmissionTexture;\r\n\t#endif\r\n\tuniform vec4 u_EmissionColor;\r\n#endif\r\n#ifdef REFLECTMAP\r\n\tuniform samplerCube u_ReflectTexture;\r\n\tuniform float u_ReflectIntensity;\r\n#endif\r\n\r\nuniform float u_AlphaTestValue;\r\nuniform float u_metallic;\r\nuniform float u_smoothness;\r\nuniform float u_smoothnessScale;\r\n\r\nuniform sampler2D u_RangeTexture;\r\n//uniform sampler2D u_AngleTexture;\r\n#ifdef POINTLIGHT\r\n\tuniform mat4 u_PointLightMatrix;\r\n#endif\r\n//uniform mat4 u_SpotLightMatrix;\r\n\r\n#include "PBRStandardLighting.glsl"\r\n#include "ShadowHelper.glsl"\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n\t#if defined(SHADOWMAP_PSSM2)||defined(SHADOWMAP_PSSM3)\r\n\t\tuniform mat4 u_lightShadowVP[4];\r\n\t#endif\r\n\t#ifdef SHADOWMAP_PSSM1 \r\n\t\tvarying vec4 v_lightMVPPos;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef DIRECTIONLIGHT\r\n\tuniform DirectionLight u_DirectionLight;\r\n#endif\r\n#ifdef POINTLIGHT\r\n\tuniform PointLight u_PointLight;\r\n#endif\r\n#ifdef SPOTLIGHT\r\n\tuniform SpotLight u_SpotLight;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\tuniform vec3 u_FogColor;\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tgl_FragColor=packDepth(v_posViewZ);\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tfloat alpha = texture2D(u_AlbedoTexture,v_Texcoord0).w;\r\n\t\tif( alpha < u_AlphaTestValue )\r\n\t\t{\r\n\t\t\tdiscard;\r\n\t\t}\r\n\t#endif\r\n}\r\n\r\nvoid main_normal()\r\n{\t\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\t\r\n\tvec2 uv0 = ParallaxOffset(viewDir);\r\n\t\r\n\tvec2 mg;\r\n\tvec4 albedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tvec4 abledoTextureColor = texture2D(u_AlbedoTexture, uv0);\r\n\t\talbedoColor = abledoTextureColor * u_AlbedoColor;\r\n\t\tmg = MetallicGloss(abledoTextureColor.a, uv0);\r\n\t#else\r\n\t\talbedoColor = u_AlbedoColor;\r\n\t\tmg = MetallicGloss(1.0, uv0);\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(albedoColor.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tvec3 normal = UnpackScaleNormal(uv0);\r\n  \r\n\tLayaGI gi;\r\n\tgi.diffuse = u_AmbientColor * Occlusion(uv0).rgb;\r\n\tgi.specular = ReflectCubeMap(viewDir, normal);\r\n  \r\n\tvec4 color = vec4(0.0);\r\n\t\r\n\t#ifdef DIRECTIONLIGHT\r\n\t\tcolor += PBRStandardDiectionLight(albedoColor, mg.r, mg.g, normal, viewDir, u_DirectionLight, gi);\r\n\t#endif\r\n \r\n\t#ifdef POINTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardPointLight(albedoColor, mg.r, mg.g, normal, viewDir, u_PointLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef SPOTLIGHT\r\n\t\tcolor.a = 0.0;\r\n\t\tcolor += PBRStandardSpotLight(albedoColor, mg.r, mg.g, normal, viewDir, u_SpotLight, v_PositionWorld, gi);\r\n\t#endif\r\n\t\r\n\t#ifdef REFLECTMAP\r\n\t \tcolor += LayaAirStandardReflect(albedoColor,mg.r,mg.g,gi);\r\n\t#endif\r\n\r\n\t#ifdef EMISSION\r\n\t\tvec4 emissionColor = u_EmissionColor;\r\n\t\t#ifdef EMISSIONTEXTURE\r\n\t\t\temissionColor *=  texture2D(u_EmissionTexture, uv0);\r\n\t\t#endif\r\n\t\tcolor.rgb += emissionColor.rgb;\r\n\t#endif\r\n\t\r\n\t#ifdef RECEIVESHADOW\r\n\t\tfloat shadowValue = 1.0;\r\n\t\t#ifdef SHADOWMAP_PSSM3\r\n\t\t\tshadowValue = getShadowPSSM3( u_shadowMap1,u_shadowMap2,u_shadowMap3,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\t#ifdef SHADOWMAP_PSSM2\r\n\t\t\tshadowValue = getShadowPSSM2( u_shadowMap1,u_shadowMap2,u_lightShadowVP,u_shadowPSSMDistance,u_shadowPCFoffset,v_PositionWorld,v_posViewZ,0.001);\r\n\t\t#endif \r\n\t\t#ifdef SHADOWMAP_PSSM1\r\n\t\t\tshadowValue = getShadowPSSM1( u_shadowMap1,v_lightMVPPos,u_shadowPSSMDistance,u_shadowPCFoffset,v_posViewZ,0.001);\r\n\t\t#endif\r\n\t\tgl_FragColor = vec4(color.rgb * shadowValue, color.a);\r\n\t#else\r\n\t\tgl_FragColor = color;\r\n\t#endif\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t#endif\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\t\t\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif  \r\n}',
        Mr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_WorldMat;\r\n#else\r\n\tuniform mat4 u_WorldMat;\r\n#endif\r\n\r\nuniform vec3 u_CameraPos;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec3 v_PositionWorld;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\nvarying float v_posViewZ;\r\n#ifdef RECEIVESHADOW\r\n  #ifdef SHADOWMAP_PSSM1 \r\n\t  varying vec4 v_lightMVPPos;\r\n\t  uniform mat4 u_lightShadowVP[4];\r\n  #endif\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main_castShadow()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t \r\n\t//TODO没考虑UV动画呢\r\n\t#if defined(DIFFUSEMAP)&&defined(ALPHATEST)\r\n\t\tv_Texcoord0 = a_Texcoord0;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n\tv_posViewZ = gl_Position.z;\r\n}\r\n\r\nvoid main_normal()\r\n{\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tmat4 worldMat;\r\n\t\t#ifdef GPU_INSTANCE\r\n\t\t\tworldMat = a_WorldMat;\r\n\t\t#else\r\n\t\t\tworldMat = u_WorldMat;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)\r\n\t\tmat3 worldInvMat;\r\n\t\t#ifdef BONE\r\n\t\t\tworldInvMat=inverse(mat3(worldMat*skinTransform));\r\n\t\t#else\r\n\t\t\tworldInvMat=inverse(mat3(worldMat));\r\n\t\t#endif  \r\n\t\tv_Normal=a_Normal*worldInvMat;\r\n\t\t#if (defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT))\r\n\t\t\tv_Tangent=a_Tangent0.xyz*worldInvMat;\r\n\t\t\tv_Binormal=cross(v_Normal,v_Tangent)*a_Tangent0.w;\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n\t\r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(RECEIVESHADOW)||defined(REFLECTMAP)\r\n\t\tv_PositionWorld=(worldMat*position).xyz;\r\n\t#endif\r\n\t\r\n  \r\n\t#if defined(DIRECTIONLIGHT)||defined(POINTLIGHT)||defined(SPOTLIGHT)||defined(REFLECTMAP)||defined(REFLECTMAP)\r\n\t\tv_ViewDir=u_CameraPos-v_PositionWorld;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n  \r\n\t#ifdef RECEIVESHADOW\r\n\t\tv_posViewZ = gl_Position.w;\r\n\t\t#ifdef SHADOWMAP_PSSM1 \r\n\t\t\tv_lightMVPPos = u_lightShadowVP[0] * vec4(v_PositionWorld,1.0);\r\n\t\t#endif\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef CASTSHADOW\r\n\t\tmain_castShadow();\r\n\t#else\r\n\t\tmain_normal();\r\n\t#endif\r\n}',
        Lr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        Cr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample13();\r\n}',
        yr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\n\r\nvoid fragDownsample4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = color;\r\n}\r\n\r\nvoid main() {\r\n\tfragDownsample4();\r\n}',
        Or = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter13() {\r\n\tmediump vec4 color = downsampleBox13Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter13();\r\n}',
        Nr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform vec4 u_Threshold; // x: threshold value (linear), y: threshold - knee, z: knee * 2, w: 0.25 / knee\r\nuniform vec4 u_Params; // x: clamp, yzw: unused\r\n\r\nmediump vec4 prefilter(mediump vec4 color, vec2 uv) {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, uv).r;\r\n\tcolor *= autoExposure;\r\n\tcolor = min(vec4(u_Params.x), color); // clamp to max\r\n\tcolor = quadraticThreshold(color, u_Threshold.x, u_Threshold.yzw);\r\n\treturn color;\r\n}\r\n\r\nvoid fragPrefilter4() {\r\n\tmediump vec4 color = downsampleBox4Tap(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy);\r\n\tgl_FragColor = prefilter(safeHDR(color), v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragPrefilter4();\r\n}',
        Pr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleBox() {\r\n\tmediump vec4 bloom = upsampleBox(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleBox();\r\n}',
        Vr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform vec4 u_MainTex_TexelSize;\r\nuniform float u_SampleScale;\r\n\r\nmediump vec4 combine(mediump vec4 bloom, vec2 uv) {\r\n\tmediump vec4 color = texture2D(u_BloomTex, uv);\r\n\treturn bloom + color;\r\n}\r\n\r\nvoid fragUpsampleTent() {\r\n\tmediump vec4 bloom = upsampleTent(u_MainTex, v_Texcoord0, u_MainTex_TexelSize.xy, vec4(u_SampleScale));\r\n\tgl_FragColor = combine(bloom, v_Texcoord0);\r\n}\r\n\r\nvoid main() {\r\n\tfragUpsampleTent();\r\n}',
        wr = '#include "StdLib.glsl";\r\n\r\n#define EPSILON 1.0e-4\r\n\r\n// Quadratic color thresholding\r\n// curve = (threshold - knee, knee * 2, 0.25 / knee)\r\nmediump vec4 quadraticThreshold(mediump vec4 color, mediump float threshold, mediump vec3 curve) {\r\n\t// Pixel brightness\r\n\tmediump float br = max3(color.r, color.g, color.b);\r\n\r\n\t// Under-threshold part: quadratic curve\r\n\tmediump float rq = clamp(br - curve.x, 0.0, curve.y);\r\n\trq = curve.z * rq * rq;\r\n\r\n\t// Combine and apply the brightness response curve.\r\n\tcolor *= max(rq, br - threshold) / max(br, EPSILON);\r\n\r\n\treturn color;\r\n}\r\n\r\n\r\n\r\n//\r\n// sRGB transfer functions\r\n// Fast path ref: http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1\r\n//\r\nmediump vec3 sRGBToLinear(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn c * c;\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn c * (c * (c * 0.305306011 + 0.682171111) + 0.012522878);\r\n\t#else\r\n\t\tmediump vec3 linearRGBLo = c / 12.92;\r\n\t\tmediump vec3 power=vec3(2.4, 2.4, 2.4);\r\n\t\tmediump vec3 linearRGBHi = positivePow((c + 0.055) / 1.055, power);\r\n\t\tmediump vec3 linearRGB =vec3((c.r<=0.04045) ? linearRGBLo.r : linearRGBHi.r,(c.g<=0.04045) ? linearRGBLo.g : linearRGBHi.g,(c.b<=0.04045) ? linearRGBLo.b : linearRGBHi.b);\r\n\t\treturn linearRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 sRGBToLinear(mediump vec4 c){\r\n    return vec4(sRGBToLinear(c.rgb), c.a);\r\n}\r\n\r\n\r\n\r\nmediump vec3 linearToSRGB(mediump vec3 c) {\r\n\t#ifdef USE_VERY_FAST_SRGB\r\n\t\treturn sqrt(c);\r\n\t#elif defined(USE_FAST_SRGB)\r\n\t\treturn max(1.055 * PositivePow(c, 0.416666667) - 0.055, 0.0);\r\n\t#else\r\n\t\tmediump vec3 sRGBLo = c * 12.92;\r\n\t\tmediump vec3 power=vec3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4);\r\n\t\tmediump vec3 sRGBHi = (positivePow(c, power) * 1.055) - 0.055;\r\n\t\tmediump vec3 sRGB =vec3((c.r<=0.0031308) ? sRGBLo.r : sRGBHi.r,(c.g<=0.0031308) ? sRGBLo.g : sRGBHi.g,(c.b<=0.0031308) ? sRGBLo.b : sRGBHi.b);\r\n\t\treturn sRGB;\r\n\t#endif\r\n}\r\n\r\nmediump vec4 linearToSRGB(mediump vec4 c){\r\n    return vec4(linearToSRGB(c.rgb), c.a);\r\n}',
        br = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Colors.glsl";\r\n#include "Sampling.glsl";\r\n\r\nvarying vec2 v_Texcoord0;\r\n\r\nuniform sampler2D u_MainTex;\r\nuniform sampler2D u_BloomTex;\r\n\r\nuniform sampler2D u_AutoExposureTex;\r\nuniform sampler2D u_Bloom_DirtTex;\r\nuniform vec4 u_BloomTex_TexelSize;\r\nuniform vec4 u_Bloom_DirtTileOffset; // xy: tiling, zw: offset\r\nuniform mediump vec3 u_Bloom_Settings;// x: sampleScale, y: intensity, z: dirt intensity\r\nuniform mediump vec3 u_Bloom_Color;\r\n\r\nvoid main() {\r\n\tmediump float autoExposure = texture2D(u_AutoExposureTex, v_Texcoord0).r;\r\n\tmediump vec4 color=vec4(0.0);\r\n\tcolor = texture2D(u_MainTex, v_Texcoord0);\r\n\t\r\n\tcolor = sRGBToLinear(color);\r\n\tcolor.rgb *= autoExposure;\r\n\t\r\n\t#if defined(BLOOM)||defined(BLOOM_LOW)\r\n\t\t#ifdef BLOOM\r\n\t\t\tmediump vec4 bloom = upsampleTent(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#else\r\n\t\t\tmediump vec4 bloom = upsampleBox(u_BloomTex, v_Texcoord0, u_BloomTex_TexelSize.xy, vec4(u_Bloom_Settings.x));\r\n\t\t#endif\r\n\r\n\t\t// UVs should be Distort(uv * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw)\r\n\t\t// but considering we use a cover-style scale on the dirt texture the difference\r\n\t\t// isn\'t massive so we chose to save a few ALUs here instead in case lens distortion\r\n\t\t// is active\r\n\t\tmediump vec4 dirt =vec4(texture2D(u_Bloom_DirtTex, v_Texcoord0 * u_Bloom_DirtTileOffset.xy + u_Bloom_DirtTileOffset.zw).rgb, 0.0);\r\n\r\n\t\t// Additive bloom (artist friendly)\r\n\t\tbloom *= u_Bloom_Settings.y;\r\n\t\tdirt *= u_Bloom_Settings.z;\r\n\t\tmediump vec4 bloomColor=vec4(u_Bloom_Color, 1.0);\r\n\t\tcolor += bloom * bloomColor;\r\n\t\tcolor += dirt * bloom;\r\n\t#endif\r\n\t\r\n\tmediump vec4 finalColor = color;\r\n\tfinalColor = linearToSRGB(finalColor);\r\n\t//finalColor.rgb = Dither(finalColor.rgb, v_Texcoord0);//TODO:抖动\r\n\tgl_FragColor = finalColor;\r\n}',
        Fr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_PositionTexcoord;\r\nvarying vec2 v_Texcoord0;\r\n\r\nvoid main() {\r\n\tgl_Position = vec4(a_PositionTexcoord.xy, 0.0, 1.0);\r\n\tv_Texcoord0 = a_PositionTexcoord.zw;\r\n\tgl_Position = remapGLPositionZ(gl_Position);\r\n}',
        Br = "// Better, temporally stable box filtering\r\n// [Jimenez14] http://goo.gl/eomGso\r\n// . . . . . . .\r\n// . A . B . C .\r\n// . . D . E . .\r\n// . F . G . H .\r\n// . . I . J . .\r\n// . K . L . M .\r\n// . . . . . . .\r\nmediump vec4 downsampleBox13Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    mediump vec4 A = texture2D(tex, uv + texelSize * vec2(-1.0, -1.0));\r\n    mediump vec4 B = texture2D(tex, uv + texelSize * vec2( 0.0, -1.0));\r\n    mediump vec4 C = texture2D(tex, uv + texelSize * vec2( 1.0, -1.0));\r\n    mediump vec4 D = texture2D(tex, uv + texelSize * vec2(-0.5, -0.5));\r\n    mediump vec4 E = texture2D(tex, uv + texelSize * vec2( 0.5, -0.5));\r\n    mediump vec4 F = texture2D(tex, uv + texelSize * vec2(-1.0,  0.0));\r\n    mediump vec4 G = texture2D(tex, uv);\r\n    mediump vec4 H = texture2D(tex, uv + texelSize * vec2( 1.0,  0.0));\r\n    mediump vec4 I = texture2D(tex, uv + texelSize * vec2(-0.5,  0.5));\r\n    mediump vec4 J = texture2D(tex, uv + texelSize * vec2( 0.5,  0.5));\r\n    mediump vec4 K = texture2D(tex, uv + texelSize * vec2(-1.0,  1.0));\r\n    mediump vec4 L = texture2D(tex, uv + texelSize * vec2( 0.0,  1.0));\r\n    mediump vec4 M = texture2D(tex, uv + texelSize * vec2( 1.0,  1.0));\r\n\r\n\tmediump vec2 scale= vec2(0.5, 0.125);\r\n    mediump vec2 div = (1.0 / 4.0) * scale;\r\n\r\n    mediump vec4 o = (D + E + I + J) * div.x;\r\n    o += (A + B + G + F) * div.y;\r\n    o += (B + C + H + G) * div.y;\r\n    o += (F + G + L + K) * div.y;\r\n    o += (G + H + M + L) * div.y;\r\n\r\n    return o;\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 downsampleBox4Tap(sampler2D tex, vec2 uv, vec2 texelSize)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0);\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}\r\n\r\n// 9-tap bilinear upsampler (tent filter)\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\n// . 2 . 4 . 2 .\r\n// . . . . . . .\r\n// . 1 . 2 . 1 .\r\n// . . . . . . .\r\nmediump vec4 upsampleTent(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(1.0, 1.0, -1.0, 0.0) * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv - d.xy);\r\n    s += texture2D(tex, uv - d.wy) * 2.0;\r\n    s += texture2D(tex, uv - d.zy);\r\n\r\n    s += texture2D(tex, uv + d.zw) * 2.0;\r\n    s += texture2D(tex, uv) * 4.0;\r\n    s += texture2D(tex,\tuv + d.xw) * 2.0;\r\n\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.wy) * 2.0;\r\n    s += texture2D(tex, uv + d.xy);\r\n\r\n    return s * (1.0 / 16.0);\r\n}\r\n\r\n// Standard box filtering\r\nmediump vec4 upsampleBox(sampler2D tex, vec2 uv, vec2 texelSize, vec4 sampleScale)\r\n{\r\n    vec4 d = texelSize.xyxy * vec4(-1.0, -1.0, 1.0, 1.0) * 0.5 * sampleScale;\r\n\r\n    mediump vec4 s =  texture2D(tex, uv + d.xy);\r\n    s += texture2D(tex, uv + d.zy);\r\n    s += texture2D(tex, uv + d.xw);\r\n    s += texture2D(tex, uv + d.zw);\r\n\r\n    return s * (1.0 / 4.0);\r\n}",
        Ur = "#define HALF_MAX       65504.0 // (2 - 2^-10) * 2^15\r\n\r\n#define FLT_EPSILON    1.192092896e-07 // Smallest positive number, such that 1.0 + FLT_EPSILON != 1.0\r\n\r\nmediump vec4 safeHDR(mediump vec4 c)\r\n{\r\n    return min(c, HALF_MAX);\r\n}\r\n\r\nfloat max3(float a, float b, float c)\r\n{\r\n    return max(max(a, b), c);\r\n}\r\n\r\nvec3 positivePow(vec3 base, vec3 power)\r\n{\r\n    return pow(max(abs(base), vec3(FLT_EPSILON, FLT_EPSILON, FLT_EPSILON)), power);\r\n}",
        Gr = "uniform sampler2D u_shadowMap1;\r\nuniform sampler2D u_shadowMap2;\r\nuniform sampler2D u_shadowMap3;\r\nuniform vec2\t  u_shadowPCFoffset;\r\nuniform vec4     u_shadowPSSMDistance;\r\nvec4 packDepth(const in float depth)\r\n{\r\n\tconst vec4 bitShift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);\r\n\tconst vec4 bitMask\t= vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);\r\n\tvec4 res = mod(depth*bitShift*vec4(255), vec4(256))/vec4(255);\r\n\tres -= res.xxyz * bitMask;\r\n\treturn res;\r\n}\r\nfloat unpackDepth(const in vec4 rgbaDepth)\r\n{\r\n\tconst vec4 bitShift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);\r\n\tfloat depth = dot(rgbaDepth, bitShift);\r\n\treturn depth;\r\n}\r\nfloat tex2DPCF( sampler2D shadowMap,vec2 texcoord,vec2 invsize,float zRef )\r\n{\r\n\tvec2 texelpos =texcoord / invsize;\r\n\tvec2 lerps = fract( texelpos );\r\n\tfloat sourcevals[4];\r\n\tsourcevals[0] = float( unpackDepth(texture2D(shadowMap,texcoord)) > zRef );\r\n\tsourcevals[1] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x,0))) > zRef );\r\n\tsourcevals[2] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(0,invsize.y))) > zRef );\r\n\tsourcevals[3] = float( unpackDepth(texture2D(shadowMap,texcoord + vec2(invsize.x, invsize.y) )) > zRef );\r\n\treturn mix( mix(sourcevals[0],sourcevals[2],lerps.y),mix(sourcevals[1],sourcevals[3],lerps.y),lerps.x );\r\n}\r\nfloat getShadowPSSM3( sampler2D shadowMap1,sampler2D shadowMap2,sampler2D shadowMap3,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\tnPSNum += int(posViewZ>pssmDistance.z);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\telse if( nPSNum == 2 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[3];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t} \r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap3,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 2 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap3,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM2( sampler2D shadowMap1,sampler2D shadowMap2,mat4 lightShadowVP[4],vec4 pssmDistance,vec2 shadowPCFOffset,vec3 worldPos,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tint nPSNum = int(posViewZ>pssmDistance.x);\r\n\tnPSNum += int(posViewZ>pssmDistance.y);\r\n\t//真SB,webgl不支持在PS中直接访问数组\r\n\tmat4 lightVP;\r\n\tif( nPSNum == 0 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[1];\r\n\t}\r\n\telse if( nPSNum == 1 )\r\n\t{\r\n\t\tlightVP = lightShadowVP[2];\r\n\t}\r\n\tvec4 vLightMVPPos = lightVP * vec4(worldPos,1.0);\r\n\t//为了效率，在CPU计算/2.0 + 0.5\r\n\t//vec3 vText = (vLightMVPPos.xyz / vLightMVPPos.w)/2.0 + 0.5;\r\n\tvec3 vText = vLightMVPPos.xyz / vLightMVPPos.w;\r\n\tfloat fMyZ = vText.z - zBias;\r\n\t/*\r\n\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\tbool bInFrustum = all( bInFrustumVec );\r\n\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\tbool bFrustumTest = all( bFrustumTestVec );\r\n\tif ( bFrustumTest ) \r\n\t*/\r\n\tif( fMyZ <= 1.0 )\r\n\t{\r\n\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,\tfMyZ );\r\n\t\t\tvalue = value/4.0;\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap2,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tvec4 color = texture2D( shadowMap2,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n\t\t}\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\r\n\t\tvec4 color;\r\n\t\tif ( nPSNum == 0 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap1,vText.xy );\r\n\t\t}\r\n\t\telse if( nPSNum == 1 )\r\n\t\t{\r\n\t\t\tcolor = texture2D( shadowMap2,vText.xy );\r\n\t\t}\r\n\t\tzdepth = unpackDepth(color);\r\n\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t}\r\n\treturn value;\r\n}\r\nfloat getShadowPSSM1( sampler2D shadowMap1,vec4 lightMVPPos,vec4 pssmDistance,vec2 shadowPCFOffset,float posViewZ,float zBias )\r\n{\r\n\tfloat value = 1.0;\r\n\tif( posViewZ < pssmDistance.x )\r\n\t{\r\n\t\tvec3 vText = lightMVPPos.xyz / lightMVPPos.w;\r\n\t\tfloat fMyZ = vText.z - zBias;\r\n\t\t/*\r\n\t\tbvec4 bInFrustumVec = bvec4 ( vText.x >= 0.0, vText.x <= 1.0, vText.y >= 0.0, vText.y <= 1.0 );\r\n\t\tbool bInFrustum = all( bInFrustumVec );\r\n\t\tbvec2 bFrustumTestVec = bvec2( bInFrustum, fMyZ <= 1.0 );\r\n\t\tbool bFrustumTest = all( bFrustumTestVec );\r\n\t\t*/\r\n\t\tif ( fMyZ <= 1.0 ) \r\n\t\t{\r\n\t\t\tfloat zdepth=0.0;\r\n#ifdef SHADOWMAP_PCF3\r\n\t\t\tvalue =  tex2DPCF( shadowMap1, vText.xy,shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.xy),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(shadowPCFOffset.x,0),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue += tex2DPCF( shadowMap1, vText.xy+vec2(0,shadowPCFOffset.y),shadowPCFOffset,fMyZ );\r\n\t\t\tvalue = value/4.0;\r\n#endif\r\n#ifdef SHADOWMAP_PCF2\t\t\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF1\r\n\t\t\tvalue = tex2DPCF( shadowMap1,vText.xy,shadowPCFOffset,fMyZ);\r\n#endif\r\n#ifdef SHADOWMAP_PCF_NO\t\t\r\n\t\t\tvec4 color = texture2D( shadowMap1,vText.xy );\r\n\t\t\tzdepth = unpackDepth(color);\r\n\t\t\tvalue = float(fMyZ < zdepth);\r\n#endif\r\n\t\t}\r\n\t}\r\n\treturn value;\r\n}",
        zr = "#ifdef HIGHPRECISION\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\nvarying vec3 v_Texcoord;\r\n\r\nuniform samplerCube u_CubeTexture;\r\nuniform float u_Exposure;\r\nuniform vec4 u_TintColor;\r\n\r\n\r\nvoid main()\r\n{\t\r\n\tvec3 color=textureCube(u_CubeTexture, v_Texcoord).rgb*u_TintColor.rgb*u_Exposure*2.0;\r\n\tgl_FragColor=vec4(color,1.0);\r\n}\r\n\r\n",
        Hr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nuniform mat4 u_ViewProjection;\r\nuniform float u_Rotation;\r\nvarying vec3 v_Texcoord;\r\n\r\n\r\nvec4 rotateAroundYInDegrees (vec4 vertex, float degrees)\r\n{\r\n\tfloat angle = degrees * 3.141593 / 180.0;\r\n\tfloat sina=sin(angle);\r\n\tfloat cosa=cos(angle);\r\n\tmat2 m = mat2(cosa, -sina, sina, cosa);\r\n\treturn vec4(m*vertex.xz, vertex.yw).xzyw;\r\n}\r\n\t\t\r\nvoid main()\r\n{\r\n\tvec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);\r\n\tgl_Position = (u_ViewProjection*position).xyww;\r\n\tv_Texcoord=vec3(-a_Position.x,a_Position.yz);//转换坐标系\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
        Wr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include "Lighting.glsl";\r\n\r\nconst float MIE_G = -0.990;\r\nconst float MIE_G2 = 0.9801;\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\n\r\nuniform float u_SunSize;\r\nuniform float u_SunSizeConvergence;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Mie phase function\r\nfloat getMiePhase(float eyeCos, float eyeCos2) {\r\n\tfloat temp = 1.0 + MIE_G2 - 2.0 * MIE_G * eyeCos;\r\n\ttemp = pow(temp, pow(u_SunSize,0.65) * 10.0);\r\n\ttemp = max(temp,1.0e-4); // prevent division by zero, esp. in half precision\r\n\ttemp = 1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + eyeCos2) / temp;\r\n\treturn temp;\r\n}\r\n\r\n// Calculates the sun shape\r\nfloat calcSunAttenuation(vec3 lightPos, vec3 ray) {\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tfloat focusedEyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), u_SunSizeConvergence);\r\n\t\treturn getMiePhase(-focusedEyeCos, focusedEyeCos * focusedEyeCos);\r\n\t#else //SUN_SIMPLE\r\n\t\tvec3 delta = lightPos - ray;\r\n\t\tfloat dist = length(delta);\r\n\t\tfloat spot = 1.0 - smoothstep(0.0, u_SunSize, dist);\r\n\t\treturn spot * spot;\r\n\t#endif\r\n}\r\n\r\nvoid main() {\r\n\t// if y > 1 [eyeRay.y < -SKY_GROUND_THRESHOLD] - ground\r\n\t// if y >= 0 and < 1 [eyeRay.y <= 0 and > -SKY_GROUND_THRESHOLD] - horizon\r\n\t// if y < 0 [eyeRay.y > 0] - sky\r\n\tvec3 col = vec3(0.0, 0.0, 0.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tvec3 ray = normalize(v_Vertex);\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tvec3 ray = v_RayDir;\r\n\t\tfloat y = ray.y / SKY_GROUND_THRESHOLD;\t\r\n\t#else\r\n\t\tfloat y = v_SkyGroundFactor;\r\n\t#endif\r\n\r\n\t// if we did precalculate color in vprog: just do lerp between them\r\n\tcol = mix(v_SkyColor, v_GroundColor, clamp(y,0.0,1.0));\r\n\r\n\t#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\t\tif (y < 0.0)\r\n\t\t\tcol += v_SunColor * calcSunAttenuation(-u_DirectionLight.Direction, -ray);\r\n\t#endif\r\n\r\n\tcol = sqrt(col);//linear space convert to gamma space\r\n\tgl_FragColor=vec4(col,1.0);\r\n}\r\n\r\n',
        kr = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#include \"Lighting.glsl\";\r\n\r\n#define OUTER_RADIUS 1.025\r\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))// Rayleigh constant Rayleigh为夜空光和极光亮度单位\r\n#define MIE 0.0010             // Mie constant 米氏散射\r\n#define SUN_BRIGHTNESS 20.0    // Sun brightness\r\n#define MAX_SCATTER 50.0 // Maximum scattering value, to prevent math overflows on Adrenos\r\n\r\nconst float SKY_GROUND_THRESHOLD = 0.02;\r\nconst float outerRadius = OUTER_RADIUS;\r\nconst float outerRadius2 = OUTER_RADIUS*OUTER_RADIUS;\r\nconst float innerRadius = 1.0;\r\nconst float innerRadius2 = 1.0;\r\nconst float cameraHeight = 0.0001;\r\n\r\nconst float HDSundiskIntensityFactor = 15.0;\r\nconst float simpleSundiskIntensityFactor = 27.0;\r\n\r\nconst float sunScale = 400.0 * SUN_BRIGHTNESS;\r\nconst float kmESun = MIE * SUN_BRIGHTNESS;\r\nconst float km4PI = MIE * 4.0 * 3.14159265;\r\nconst float scale = 1.0 / (OUTER_RADIUS - 1.0);\r\nconst float scaleDepth = 0.25;\r\nconst float scaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\r\nconst float samples = 2.0; // THIS IS UNROLLED MANUALLY, DON'T TOUCH\r\n\r\n// RGB wavelengths        .35 (.62=158), .43 (.68=174), .525 (.75=190)\r\nconst vec3 c_DefaultScatteringWavelength = vec3(0.65, 0.57, 0.475);//默认散射波长\r\nconst vec3 c_VariableRangeForScatteringWavelength = vec3(0.15, 0.15, 0.15);//散射播放的可变范围\r\n\r\nattribute vec4 a_Position;\r\n\r\nuniform mat4 u_ViewProjection;\r\nuniform vec3 u_SkyTint;\r\nuniform vec3 u_GroundTint;\r\nuniform float u_Exposure;\r\nuniform float u_AtmosphereThickness;\r\nuniform DirectionLight u_DirectionLight;\r\n\r\nvarying vec3 v_GroundColor;\r\nvarying vec3 v_SkyColor;\r\n\r\n#ifdef SUN_HIGH_QUALITY\r\n\tvarying vec3 v_Vertex;\r\n#elif defined(SUN_SIMPLE)\r\n\tvarying vec3 v_RayDir;\r\n#else\r\n\tvarying float v_SkyGroundFactor;\r\n#endif\r\n\r\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\r\n\tvarying vec3 v_SunColor;\r\n#endif\r\n\r\n// Calculates the Rayleigh phase function\r\nfloat getRayleighPhase(vec3 light, vec3 ray) \r\n{\r\n\tfloat eyeCos = dot(light, ray);\r\n\treturn 0.75 + 0.75*eyeCos*eyeCos;\r\n}\r\n\r\nfloat scaleAngle(float inCos)\r\n{\r\n\tfloat x = 1.0 - inCos;\r\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\r\n}\r\n\r\n\r\nvoid main () {\r\n\tgl_Position = (u_ViewProjection*a_Position).xyww;\r\n\r\n\tvec3 skyTintInGammaSpace = u_SkyTint;//支持非GAMMA空间后要调整\r\n\tvec3 scatteringWavelength = mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0) - skyTintInGammaSpace); // using Tint in sRGB+ gamma allows for more visually linear interpolation and to keep (0.5) at (128, gray in sRGB) point\r\n\tvec3 invWavelength = 1.0 / pow(scatteringWavelength, vec3(4.0));\r\n\r\n\tfloat krESun = RAYLEIGH * SUN_BRIGHTNESS;\r\n\tfloat kr4PI = RAYLEIGH * 4.0 * 3.14159265;\r\n\r\n\tvec3 cameraPos = vec3(0.0,innerRadius + cameraHeight,0.0); // The camera's current position\r\n\r\n\t// Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\r\n\tvec3 eyeRay = normalize(a_Position.xyz);\r\n\r\n\tfloat far = 0.0;\r\n\tvec3 cIn, cOut;\r\n\tif (eyeRay.y >= 0.0) {// Sky\r\n\t\t// Calculate the length of the \"atmosphere\"\r\n\t\tfar = sqrt(outerRadius2 + innerRadius2 * eyeRay.y * eyeRay.y - innerRadius2) - innerRadius * eyeRay.y;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat height = innerRadius + cameraHeight;\r\n\t\tfloat depth = exp(scaleOverScaleDepth * -cameraHeight);\r\n\t\tfloat startAngle = dot(eyeRay, cameraPos) / height;\r\n\t\tfloat startOffset = depth*scaleAngle(startAngle);\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\tvec3 frontColor = vec3(0.0);\r\n\t\t//unrolling this manually to avoid some platform for loop slow\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, samplePoint) / height;\r\n\t\t\tfloat cameraAngle = dot(eyeRay, samplePoint) / height;\r\n\t\t\tfloat scatter = (startOffset + depth*(scaleAngle(lightAngle) - scaleAngle(cameraAngle)));\r\n\t\t\tvec3 attenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\t// Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\r\n\t\tcIn = frontColor * (invWavelength * krESun);\r\n\t\tcOut = frontColor * kmESun;\r\n\t} else {// Ground\r\n\t\tfar = (-cameraHeight) / (min(-0.001, eyeRay.y));\r\n\t\tvec3 pos = cameraPos + far * eyeRay;\r\n\r\n\t\t// Calculate the ray's starting position, then calculate its scattering offset\r\n\t\tfloat depth = exp((-cameraHeight) * (1.0/scaleDepth));\r\n\t\tfloat cameraAngle = dot(-eyeRay, pos);\r\n\t\tfloat lightAngle = dot(-u_DirectionLight.Direction, pos);\r\n\t\tfloat cameraScale = scaleAngle(cameraAngle);\r\n\t\tfloat lightScale = scaleAngle(lightAngle);\r\n\t\tfloat cameraOffset = depth*cameraScale;\r\n\t\tfloat temp = lightScale + cameraScale;\r\n\r\n\t\t// Initialize the scattering loop variables\r\n\t\tfloat sampleLength = far / samples;\r\n\t\tfloat scaledLength = sampleLength * scale;\r\n\t\tvec3 sampleRay = eyeRay * sampleLength;\r\n\t\tvec3 samplePoint = cameraPos + sampleRay * 0.5;\r\n\r\n\t\t// Now loop through the sample rays\r\n\t\tvec3 frontColor = vec3(0.0, 0.0, 0.0);\r\n\t\tvec3 attenuate;\r\n\r\n\t\t// Loop removed because we kept hitting SM2.0 temp variable limits. Doesn't affect the image too much.\r\n\t\t{\r\n\t\t\tfloat height = length(samplePoint);\r\n\t\t\tfloat depth = exp(scaleOverScaleDepth * (innerRadius - height));\r\n\t\t\tfloat scatter = depth*temp - cameraOffset;\r\n\t\t\tattenuate = exp(-clamp(scatter, 0.0, MAX_SCATTER) * (invWavelength * kr4PI + km4PI));\r\n\t\t\tfrontColor += attenuate * (depth * scaledLength);\r\n\t\t\tsamplePoint += sampleRay;\r\n\t\t}\r\n\r\n\t\tcIn = frontColor * (invWavelength * krESun + kmESun);\r\n\t\tcOut = clamp(attenuate, 0.0, 1.0);\r\n\t}\r\n\r\n\t#ifdef SUN_HIGH_QUALITY\r\n\t\tv_Vertex = -a_Position.xyz;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_RayDir = -eyeRay;\r\n\t#else\r\n\t\tv_SkyGroundFactor = -eyeRay.y / SKY_GROUND_THRESHOLD;\r\n\t#endif\r\n\r\n\t// if we want to calculate color in vprog:\r\n\t// in case of linear: multiply by _Exposure in here (even in case of lerp it will be common multiplier, so we can skip mul in fshader)\r\n\tv_GroundColor = u_Exposure * (cIn + u_GroundTint*u_GroundTint * cOut);//u_GroundColor*u_GroundColor is gamma space convert to linear space\r\n\tv_SkyColor    = u_Exposure * (cIn * getRayleighPhase(-u_DirectionLight.Direction, -eyeRay));\r\n\r\n\t\r\n\t// The sun should have a stable intensity in its course in the sky. Moreover it should match the highlight of a purely specular material.\r\n\t// This matching was done using the Unity3D standard shader BRDF1 on the 5/31/2017\r\n\t// Finally we want the sun to be always bright even in LDR thus the normalization of the lightColor for low intensity.\r\n\tfloat lightColorIntensity = clamp(length(u_DirectionLight.Color), 0.25, 1.0);\r\n\r\n\t#ifdef SUN_HIGH_QUALITY \r\n\t\tv_SunColor = HDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#elif defined(SUN_SIMPLE) \r\n\t\tv_SunColor = simpleSundiskIntensityFactor * clamp(cOut * sunScale,0.0,1.0) * u_DirectionLight.Color / lightColorIntensity;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n",
        Xr = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\nuniform sampler2D u_MainTexture;\r\nuniform vec4 u_MainColor;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nvoid main()\r\n{\r\n\tvec4 color = 2.0 * u_MainColor * v_Color;\r\n\t#ifdef MAINTEXTURE\r\n\t\tvec4 mainTextureColor = texture2D(u_MainTexture, v_Texcoord0);\r\n\t\tcolor *= mainTextureColor;\r\n\t#endif\r\n\tgl_FragColor = color;\r\n}\r\n\r\n     ",
        Yr = '#include "Lighting.glsl";\r\n\r\nattribute vec3 a_Position;\r\nattribute vec3 a_OffsetVector;\r\nattribute vec4 a_Color;\r\nattribute float a_Texcoord0X;\r\nattribute float a_Texcoord0Y;\r\nattribute float a_BirthTime;\r\n\r\nuniform mat4 u_View;\r\nuniform mat4 u_Projection;\r\n\r\nuniform vec4 u_TilingOffset;\r\n\r\nuniform float u_CurTime;\r\nuniform float u_LifeTime;\r\nuniform vec4 u_WidthCurve[10];\r\nuniform int u_WidthCurveKeyLength;\r\n\r\nvarying vec2 v_Texcoord0;\r\nvarying vec4 v_Color;\r\n\r\nfloat hermiteInterpolate(float t, float outTangent, float inTangent, float duration, float value1, float value2)\r\n{\r\n\tfloat t2 = t * t;\r\n\tfloat t3 = t2 * t;\r\n\tfloat a = 2.0 * t3 - 3.0 * t2 + 1.0;\r\n\tfloat b = t3 - 2.0 * t2 + t;\r\n\tfloat c = t3 - t2;\r\n\tfloat d = -2.0 * t3 + 3.0 * t2;\r\n\treturn a * value1 + b * outTangent * duration + c * inTangent * duration + d * value2;\r\n}\r\n\r\nfloat getCurWidth(in float normalizeTime)\r\n{\r\n\tfloat width;\r\n\tif(normalizeTime == 0.0){\r\n\t\twidth=u_WidthCurve[0].w;\r\n\t}\r\n\telse if(normalizeTime >= 1.0){\r\n\t\twidth=u_WidthCurve[u_WidthCurveKeyLength - 1].w;\r\n\t}\r\n\telse{\r\n\t\tfor(int i = 0; i < 10; i ++ )\r\n\t\t{\r\n\t\t\tif(normalizeTime == u_WidthCurve[i].x){\r\n\t\t\t\twidth=u_WidthCurve[i].w;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvec4 lastFrame = u_WidthCurve[i];\r\n\t\t\tvec4 nextFrame = u_WidthCurve[i + 1];\r\n\t\t\tif(normalizeTime > lastFrame.x && normalizeTime < nextFrame.x)\r\n\t\t\t{\r\n\t\t\t\tfloat duration = nextFrame.x - lastFrame.x;\r\n\t\t\t\tfloat t = (normalizeTime - lastFrame.x) / duration;\r\n\t\t\t\tfloat outTangent = lastFrame.z;\r\n\t\t\t\tfloat inTangent = nextFrame.y;\r\n\t\t\t\tfloat value1 = lastFrame.w;\r\n\t\t\t\tfloat value2 = nextFrame.w;\r\n\t\t\t\twidth=hermiteInterpolate(t, outTangent, inTangent, duration, value1, value2);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn width;\r\n}\t\r\n\r\nvoid main()\r\n{\r\n\tfloat normalizeTime = (u_CurTime - a_BirthTime) / u_LifeTime;\r\n\t\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, 1.0 - a_Texcoord0Y) * u_TilingOffset.xy + u_TilingOffset.zw;\r\n\t#else\r\n\t\tv_Texcoord0 = vec2(a_Texcoord0X, a_Texcoord0Y);\r\n\t#endif\r\n\t\r\n\tv_Color = a_Color;\r\n\t\r\n\tgl_Position = u_Projection * u_View * vec4(a_Position + a_OffsetVector * getCurWidth(normalizeTime),1.0);\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}\r\n',
        Zr = "#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\tvarying vec4 v_Color;\r\n#endif\r\n\r\n#ifdef ALBEDOTEXTURE\r\n\tuniform sampler2D u_AlbedoTexture;\r\n\tvarying vec2 v_Texcoord0;\r\n#endif\r\n\r\nuniform vec4 u_AlbedoColor;\r\n\r\n#ifdef ALPHATEST\r\n\tuniform float u_AlphaTestValue;\r\n#endif\r\n\r\n#ifdef FOG\r\n\tuniform float u_FogStart;\r\n\tuniform float u_FogRange;\r\n\t#ifdef ADDTIVEFOG\r\n\t#else\r\n\t\tuniform vec3 u_FogColor;\r\n\t#endif\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\tvec4 color =  u_AlbedoColor;\r\n\t#ifdef ALBEDOTEXTURE\r\n\t\tcolor *= texture2D(u_AlbedoTexture, v_Texcoord0);\r\n\t#endif\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tcolor *= v_Color;\r\n\t#endif\r\n\t\r\n\t#ifdef ALPHATEST\r\n\t\tif(color.a < u_AlphaTestValue)\r\n\t\t\tdiscard;\r\n\t#endif\r\n\t\r\n\tgl_FragColor = color;\r\n\t\r\n\t#ifdef FOG\r\n\t\tfloat lerpFact = clamp((1.0 / gl_FragCoord.w - u_FogStart) / u_FogRange, 0.0, 1.0);\r\n\t\t#ifdef ADDTIVEFOG\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.0), lerpFact);\r\n\t\t#else\r\n\t\t\tgl_FragColor.rgb = mix(gl_FragColor.rgb, u_FogColor, lerpFact);\r\n\t\t#endif\r\n\t#endif\r\n\t\r\n}\r\n\r\n",
        jr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\n\r\nattribute vec2 a_Texcoord0;\r\n\r\n#ifdef GPU_INSTANCE\r\n\tattribute mat4 a_MvpMatrix;\r\n#else\r\n\tuniform mat4 u_MvpMatrix;\r\n#endif\r\n\r\nattribute vec4 a_Color;\r\nvarying vec4 v_Color;\r\nvarying vec2 v_Texcoord0;\r\n\r\n#ifdef TILINGOFFSET\r\n\tuniform vec4 u_TilingOffset;\r\n#endif\r\n\r\n#ifdef BONE\r\n\tconst int c_MaxBoneCount = 24;\r\n\tattribute vec4 a_BoneIndices;\r\n\tattribute vec4 a_BoneWeights;\r\n\tuniform mat4 u_Bones[c_MaxBoneCount];\r\n#endif\r\n\r\nvoid main() {\r\n\tvec4 position;\r\n\t#ifdef BONE\r\n\t\tmat4 skinTransform = u_Bones[int(a_BoneIndices.x)] * a_BoneWeights.x;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.y)] * a_BoneWeights.y;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.z)] * a_BoneWeights.z;\r\n\t\tskinTransform += u_Bones[int(a_BoneIndices.w)] * a_BoneWeights.w;\r\n\t\tposition=skinTransform*a_Position;\r\n\t#else\r\n\t\tposition=a_Position;\r\n\t#endif\r\n\t#ifdef GPU_INSTANCE\r\n\t\tgl_Position = a_MvpMatrix * position;\r\n\t#else\r\n\t\tgl_Position = u_MvpMatrix * position;\r\n\t#endif\r\n\r\n\t#ifdef TILINGOFFSET\r\n\t\tv_Texcoord0=TransformUV(a_Texcoord0,u_TilingOffset);\r\n\t#else\r\n\t\tv_Texcoord0=a_Texcoord0;\r\n\t#endif\r\n\r\n\t#if defined(COLOR)&&defined(ENABLEVERTEXCOLOR)\r\n\t\tv_Color = a_Color;\r\n\t#endif\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}',
        qr = '#ifdef HIGHPRECISION\r\n\tprecision highp float;\r\n#else\r\n\tprecision mediump float;\r\n#endif\r\n\r\n#ifdef MAINTEXTURE\r\n\tuniform sampler2D u_MainTexture;\r\n#endif\r\n\r\n#ifdef NORMALTEXTURE\r\n\tuniform sampler2D u_NormalTexture;\r\n#endif\r\n\r\nuniform vec4 u_HorizonColor;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\n#include "Lighting.glsl"\r\n\r\nvoid main()\r\n{\r\n\tvec4 bumpColor1 = texture2D(u_NormalTexture, v_Texcoord0);\r\n\tvec4 bumpColor2 = texture2D(u_NormalTexture, v_Texcoord1);\r\n\t\r\n\tvec3 normal1 = NormalSampleToWorldSpace1(bumpColor1, v_Tangent, v_Binormal, v_Normal);\r\n\tvec3 normal2 = NormalSampleToWorldSpace1(bumpColor2, v_Tangent, v_Binormal, v_Normal);\r\n\t\r\n\tvec3 normal = normalize((normal1 + normal2) * 0.5);\r\n\tvec3 viewDir = normalize(v_ViewDir);\r\n\tfloat fresnel = dot(viewDir, normal);\r\n\t\r\n\tvec4 waterColor = texture2D(u_MainTexture, vec2(fresnel, fresnel));\r\n\t\r\n\tvec4 color;\r\n\tcolor.rgb = mix(waterColor.rgb, u_HorizonColor.rgb, vec3(waterColor.a));\r\n\tcolor.a = u_HorizonColor.a;\r\n\t\r\n\tgl_FragColor = color;\r\n}\r\n\r\n',
        Kr = '#include "Lighting.glsl";\r\n\r\nattribute vec4 a_Position;\r\nattribute vec3 a_Normal;\r\nattribute vec4 a_Tangent0;\r\n\r\nuniform mat4 u_MvpMatrix;\r\nuniform mat4 u_WorldMat;\r\nuniform vec3 u_CameraPos;\r\nuniform float u_WaveScale;\r\nuniform vec4 u_WaveSpeed;\r\nuniform float u_Time;\r\n\r\nvarying vec3 v_Normal;\r\nvarying vec3 v_Tangent;\r\nvarying vec3 v_Binormal;\r\nvarying vec3 v_ViewDir;\r\nvarying vec2 v_Texcoord0;\r\nvarying vec2 v_Texcoord1;\r\n\r\nvoid main()\r\n{\r\n\tvec4 positionWorld = u_WorldMat * a_Position;\r\n\tvec4 position = u_MvpMatrix * a_Position;\r\n\t\r\n\tvec4 temp = vec4(positionWorld.x, positionWorld.z, positionWorld.x, positionWorld.z) * u_WaveScale + u_WaveSpeed * u_WaveScale * u_Time;\r\n\t\r\n\tv_Texcoord0 = temp.xy * vec2(0.4, 0.45);\r\n\tv_Texcoord1 = temp.wz;\r\n\t\r\n\tmat3 worldMat = mat3(u_WorldMat);\r\n\tv_Normal = worldMat * a_Normal;\r\n\tv_Tangent = worldMat * a_Tangent0.xyz;\r\n\tv_Binormal = cross(v_Normal, v_Tangent) * a_Tangent0.w;\r\n\t\r\n\tv_ViewDir = u_CameraPos - positionWorld.xyz;\r\n\tgl_Position = position;\r\n\tgl_Position=remapGLPositionZ(gl_Position);\r\n}';
    class Qr {
        constructor() {}
        static __init__() {
            Qr._rangeAttenTex = M._buildTexture2D(1024, 1, t.BaseTexture.FORMAT_ALPHA8, x.lightAttenTexture),
                Qr._rangeAttenTex.wrapModeU = t.BaseTexture.WARPMODE_CLAMP, Qr._rangeAttenTex.wrapModeV = t.BaseTexture.WARPMODE_CLAMP,
                Qr._rangeAttenTex.lock = !0, L.SHADERDEFINE_HIGHPRECISION = L.registerPublicDefine("HIGHPRECISION"),
                L.addInclude("Lighting.glsl", ur), L.addInclude("ShadowHelper.glsl", Gr), L.addInclude("BRDF.glsl", Sr),
                L.addInclude("PBRUtils.glsl", Ar), L.addInclude("PBRStandardLighting.glsl", Rr),
                L.addInclude("PBRSpecularLighting.glsl", vr), L.addInclude("Colors.glsl", wr), L.addInclude("Sampling.glsl", Br),
                L.addInclude("StdLib.glsl", Ur);
            var e = {
                    a_Position: v.MESH_POSITION0,
                    a_Color: v.MESH_COLOR0,
                    a_Normal: v.MESH_NORMAL0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0,
                    a_Texcoord1: v.MESH_TEXTURECOORDINATE1,
                    a_BoneWeights: v.MESH_BLENDWEIGHT0,
                    a_BoneIndices: v.MESH_BLENDINDICES0,
                    a_Tangent0: v.MESH_TANGENT0,
                    a_MvpMatrix: v.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: v.MESH_WORLDMATRIX_ROW0
                },
                r = {
                    u_Bones: L.PERIOD_CUSTOM,
                    u_DiffuseTexture: L.PERIOD_MATERIAL,
                    u_SpecularTexture: L.PERIOD_MATERIAL,
                    u_NormalTexture: L.PERIOD_MATERIAL,
                    u_AlphaTestValue: L.PERIOD_MATERIAL,
                    u_DiffuseColor: L.PERIOD_MATERIAL,
                    u_MaterialSpecular: L.PERIOD_MATERIAL,
                    u_Shininess: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    u_WorldMat: L.PERIOD_SPRITE,
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_LightmapScaleOffset: L.PERIOD_SPRITE,
                    u_LightMap: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_ReflectTexture: L.PERIOD_SCENE,
                    u_ReflectIntensity: L.PERIOD_SCENE,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE,
                    "u_DirectionLight.Color": L.PERIOD_SCENE,
                    "u_DirectionLight.Direction": L.PERIOD_SCENE,
                    "u_PointLight.Position": L.PERIOD_SCENE,
                    "u_PointLight.Range": L.PERIOD_SCENE,
                    "u_PointLight.Color": L.PERIOD_SCENE,
                    "u_SpotLight.Position": L.PERIOD_SCENE,
                    "u_SpotLight.Direction": L.PERIOD_SCENE,
                    "u_SpotLight.Range": L.PERIOD_SCENE,
                    "u_SpotLight.Spot": L.PERIOD_SCENE,
                    "u_SpotLight.Color": L.PERIOD_SCENE,
                    u_AmbientColor: L.PERIOD_SCENE,
                    u_shadowMap1: L.PERIOD_SCENE,
                    u_shadowMap2: L.PERIOD_SCENE,
                    u_shadowMap3: L.PERIOD_SCENE,
                    u_shadowPSSMDistance: L.PERIOD_SCENE,
                    u_lightShadowVP: L.PERIOD_SCENE,
                    u_shadowPCFoffset: L.PERIOD_SCENE
                },
                i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                },
                n = L.add("BLINNPHONG", null, null, !0),
                a = new sr(e, r, Yt.shaderDefines, He.shaderDefines);
            n.addSubShader(a), a.addShaderPass(mr, Tr, i), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Color: v.MESH_COLOR0
                }, r = {
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_Color: L.PERIOD_MATERIAL
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("LineShader"), a = new sr(e, r), n.addSubShader(a), a.addShaderPass(Er, fr, i),
                e = {
                    a_Position: v.MESH_POSITION0,
                    a_Normal: v.MESH_NORMAL0,
                    a_Tangent0: v.MESH_TANGENT0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: v.MESH_BLENDWEIGHT0,
                    a_BoneIndices: v.MESH_BLENDINDICES0,
                    a_MvpMatrix: v.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: v.MESH_WORLDMATRIX_ROW0
                }, r = {
                    u_Bones: L.PERIOD_CUSTOM,
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_WorldMat: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_AlphaTestValue: L.PERIOD_MATERIAL,
                    u_AlbedoColor: L.PERIOD_MATERIAL,
                    u_EmissionColor: L.PERIOD_MATERIAL,
                    u_AlbedoTexture: L.PERIOD_MATERIAL,
                    u_NormalTexture: L.PERIOD_MATERIAL,
                    u_ParallaxTexture: L.PERIOD_MATERIAL,
                    u_MetallicGlossTexture: L.PERIOD_MATERIAL,
                    u_OcclusionTexture: L.PERIOD_MATERIAL,
                    u_EmissionTexture: L.PERIOD_MATERIAL,
                    u_metallic: L.PERIOD_MATERIAL,
                    u_smoothness: L.PERIOD_MATERIAL,
                    u_smoothnessScale: L.PERIOD_MATERIAL,
                    u_occlusionStrength: L.PERIOD_MATERIAL,
                    u_normalScale: L.PERIOD_MATERIAL,
                    u_parallaxScale: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    "u_DirectionLight.Direction": L.PERIOD_SCENE,
                    "u_DirectionLight.Color": L.PERIOD_SCENE,
                    u_PointLightMatrix: L.PERIOD_SCENE,
                    "u_PointLight.Position": L.PERIOD_SCENE,
                    "u_PointLight.Range": L.PERIOD_SCENE,
                    "u_PointLight.Color": L.PERIOD_SCENE,
                    "u_SpotLight.Position": L.PERIOD_SCENE,
                    "u_SpotLight.Direction": L.PERIOD_SCENE,
                    "u_SpotLight.Range": L.PERIOD_SCENE,
                    "u_SpotLight.SpotAngle": L.PERIOD_SCENE,
                    "u_SpotLight.Color": L.PERIOD_SCENE,
                    u_RangeTexture: L.PERIOD_SCENE,
                    u_ReflectTexture: L.PERIOD_SCENE,
                    u_ReflectIntensity: L.PERIOD_SCENE,
                    u_AmbientColor: L.PERIOD_SCENE,
                    u_shadowMap1: L.PERIOD_SCENE,
                    u_shadowMap2: L.PERIOD_SCENE,
                    u_shadowMap3: L.PERIOD_SCENE,
                    u_shadowPSSMDistance: L.PERIOD_SCENE,
                    u_lightShadowVP: L.PERIOD_SCENE,
                    u_shadowPCFoffset: L.PERIOD_SCENE,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("PBRStandard", null, null, !0), a = new sr(e, r, Yt.shaderDefines, Gt.shaderDefines),
                n.addSubShader(a), a.addShaderPass(Mr, xr, i), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Normal: v.MESH_NORMAL0,
                    a_Tangent0: v.MESH_TANGENT0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: v.MESH_BLENDWEIGHT0,
                    a_BoneIndices: v.MESH_BLENDINDICES0,
                    a_MvpMatrix: v.MESH_MVPMATRIX_ROW0,
                    a_WorldMat: v.MESH_WORLDMATRIX_ROW0
                }, r = {
                    u_Bones: L.PERIOD_CUSTOM,
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_WorldMat: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_AlphaTestValue: L.PERIOD_MATERIAL,
                    u_AlbedoColor: L.PERIOD_MATERIAL,
                    u_SpecularColor: L.PERIOD_MATERIAL,
                    u_EmissionColor: L.PERIOD_MATERIAL,
                    u_AlbedoTexture: L.PERIOD_MATERIAL,
                    u_NormalTexture: L.PERIOD_MATERIAL,
                    u_ParallaxTexture: L.PERIOD_MATERIAL,
                    u_SpecularTexture: L.PERIOD_MATERIAL,
                    u_OcclusionTexture: L.PERIOD_MATERIAL,
                    u_EmissionTexture: L.PERIOD_MATERIAL,
                    u_smoothness: L.PERIOD_MATERIAL,
                    u_smoothnessScale: L.PERIOD_MATERIAL,
                    u_occlusionStrength: L.PERIOD_MATERIAL,
                    u_normalScale: L.PERIOD_MATERIAL,
                    u_parallaxScale: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    "u_DirectionLight.Direction": L.PERIOD_SCENE,
                    "u_DirectionLight.Color": L.PERIOD_SCENE,
                    u_PointLightMatrix: L.PERIOD_SCENE,
                    "u_PointLight.Position": L.PERIOD_SCENE,
                    "u_PointLight.Range": L.PERIOD_SCENE,
                    "u_PointLight.Color": L.PERIOD_SCENE,
                    "u_SpotLight.Position": L.PERIOD_SCENE,
                    "u_SpotLight.Direction": L.PERIOD_SCENE,
                    "u_SpotLight.Range": L.PERIOD_SCENE,
                    "u_SpotLight.SpotAngle": L.PERIOD_SCENE,
                    "u_SpotLight.Color": L.PERIOD_SCENE,
                    u_RangeTexture: L.PERIOD_SCENE,
                    u_ReflectTexture: L.PERIOD_SCENE,
                    u_ReflectIntensity: L.PERIOD_SCENE,
                    u_AmbientColor: L.PERIOD_SCENE,
                    u_shadowMap1: L.PERIOD_SCENE,
                    u_shadowMap2: L.PERIOD_SCENE,
                    u_shadowMap3: L.PERIOD_SCENE,
                    u_shadowPSSMDistance: L.PERIOD_SCENE,
                    u_lightShadowVP: L.PERIOD_SCENE,
                    u_shadowPCFoffset: L.PERIOD_SCENE,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("PBRSpecular", null, null, !0), a = new sr(e, r, Yt.shaderDefines, Ut.shaderDefines),
                n.addSubShader(a), a.addShaderPass(Ir, Dr, i), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Color: v.MESH_COLOR0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: v.MESH_BLENDWEIGHT0,
                    a_BoneIndices: v.MESH_BLENDINDICES0,
                    a_MvpMatrix: v.MESH_MVPMATRIX_ROW0
                }, r = {
                    u_Bones: L.PERIOD_CUSTOM,
                    u_AlbedoTexture: L.PERIOD_MATERIAL,
                    u_AlbedoColor: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    u_AlphaTestValue: L.PERIOD_MATERIAL,
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("Unlit", null, null, !0), a = new sr(e, r, Yt.shaderDefines, Ht.shaderDefines),
                n.addSubShader(a), a.addShaderPass(jr, Zr, i), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0,
                    a_BoneWeights: v.MESH_BLENDWEIGHT0,
                    a_BoneIndices: v.MESH_BLENDINDICES0,
                    a_MvpMatrix: v.MESH_MVPMATRIX_ROW0
                }, r = {
                    u_Bones: L.PERIOD_CUSTOM,
                    u_AlbedoTexture: L.PERIOD_MATERIAL,
                    u_AlbedoColor: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    u_AlphaTestValue: L.PERIOD_MATERIAL,
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("Effect", null, null, !0), a = new sr(e, r, Yt.shaderDefines, Ft.shaderDefines),
                n.addSubShader(a), a.addShaderPass(hr, _r, i), e = {
                    a_CornerTextureCoordinate: tt.PARTICLE_CORNERTEXTURECOORDINATE0,
                    a_MeshPosition: tt.PARTICLE_POSITION0,
                    a_MeshColor: tt.PARTICLE_COLOR0,
                    a_MeshTextureCoordinate: tt.PARTICLE_TEXTURECOORDINATE0,
                    a_ShapePositionStartLifeTime: tt.PARTICLE_SHAPEPOSITIONSTARTLIFETIME,
                    a_DirectionTime: tt.PARTICLE_DIRECTIONTIME,
                    a_StartColor: tt.PARTICLE_STARTCOLOR0,
                    a_EndColor: tt.PARTICLE_ENDCOLOR0,
                    a_StartSize: tt.PARTICLE_STARTSIZE,
                    a_StartRotation0: tt.PARTICLE_STARTROTATION,
                    a_StartSpeed: tt.PARTICLE_STARTSPEED,
                    a_Random0: tt.PARTICLE_RANDOM0,
                    a_Random1: tt.PARTICLE_RANDOM1,
                    a_SimulationWorldPostion: tt.PARTICLE_SIMULATIONWORLDPOSTION,
                    a_SimulationWorldRotation: tt.PARTICLE_SIMULATIONWORLDROTATION
                }, r = {
                    u_Tintcolor: L.PERIOD_MATERIAL,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    u_texture: L.PERIOD_MATERIAL,
                    u_WorldPosition: L.PERIOD_SPRITE,
                    u_WorldRotation: L.PERIOD_SPRITE,
                    u_PositionScale: L.PERIOD_SPRITE,
                    u_SizeScale: L.PERIOD_SPRITE,
                    u_ScalingMode: L.PERIOD_SPRITE,
                    u_Gravity: L.PERIOD_SPRITE,
                    u_ThreeDStartRotation: L.PERIOD_SPRITE,
                    u_StretchedBillboardLengthScale: L.PERIOD_SPRITE,
                    u_StretchedBillboardSpeedScale: L.PERIOD_SPRITE,
                    u_SimulationSpace: L.PERIOD_SPRITE,
                    u_CurrentTime: L.PERIOD_SPRITE,
                    u_ColorOverLifeGradientAlphas: L.PERIOD_SPRITE,
                    u_ColorOverLifeGradientColors: L.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientAlphas: L.PERIOD_SPRITE,
                    u_MaxColorOverLifeGradientColors: L.PERIOD_SPRITE,
                    u_VOLVelocityConst: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientX: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientY: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientZ: L.PERIOD_SPRITE,
                    u_VOLVelocityConstMax: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxX: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxY: L.PERIOD_SPRITE,
                    u_VOLVelocityGradientMaxZ: L.PERIOD_SPRITE,
                    u_VOLSpaceType: L.PERIOD_SPRITE,
                    u_SOLSizeGradient: L.PERIOD_SPRITE,
                    u_SOLSizeGradientX: L.PERIOD_SPRITE,
                    u_SOLSizeGradientY: L.PERIOD_SPRITE,
                    u_SOLSizeGradientZ: L.PERIOD_SPRITE,
                    u_SOLSizeGradientMax: L.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxX: L.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxY: L.PERIOD_SPRITE,
                    u_SOLSizeGradientMaxZ: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityConst: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstSeprarate: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradient: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientX: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientY: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientZ: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMax: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityConstMaxSeprarate: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMax: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxX: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxY: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxZ: L.PERIOD_SPRITE,
                    u_ROLAngularVelocityGradientMaxW: L.PERIOD_SPRITE,
                    u_TSACycles: L.PERIOD_SPRITE,
                    u_TSASubUVLength: L.PERIOD_SPRITE,
                    u_TSAGradientUVs: L.PERIOD_SPRITE,
                    u_TSAMaxGradientUVs: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_CameraDirection: L.PERIOD_CAMERA,
                    u_CameraUp: L.PERIOD_CAMERA,
                    u_View: L.PERIOD_CAMERA,
                    u_Projection: L.PERIOD_CAMERA,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("PARTICLESHURIKEN"), a = new sr(e, r, xt.shaderDefines, qe.shaderDefines),
                n.addSubShader(a), a.addShaderPass(gr, pr, i), e = {
                    a_Position: v.MESH_POSITION0
                }, r = {
                    u_TintColor: L.PERIOD_MATERIAL,
                    u_Exposure: L.PERIOD_MATERIAL,
                    u_Rotation: L.PERIOD_MATERIAL,
                    u_CubeTexture: L.PERIOD_MATERIAL,
                    u_ViewProjection: L.PERIOD_CAMERA
                }, n = L.add("SkyBox"), a = new sr(e, r), n.addSubShader(a), a.addShaderPass(Hr, zr),
                e = {
                    a_Position: v.MESH_POSITION0
                }, r = {
                    u_SunSize: L.PERIOD_MATERIAL,
                    u_SunSizeConvergence: L.PERIOD_MATERIAL,
                    u_AtmosphereThickness: L.PERIOD_MATERIAL,
                    u_SkyTint: L.PERIOD_MATERIAL,
                    u_GroundTint: L.PERIOD_MATERIAL,
                    u_Exposure: L.PERIOD_MATERIAL,
                    u_ViewProjection: L.PERIOD_CAMERA,
                    "u_DirectionLight.Direction": L.PERIOD_SCENE,
                    "u_DirectionLight.Color": L.PERIOD_SCENE
                }, n = L.add("SkyBoxProcedural"), a = new sr(e, r, null, zt.shaderDefines), n.addSubShader(a),
                a.addShaderPass(kr, Wr), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Normal: v.MESH_NORMAL0,
                    a_Texcoord0: v.MESH_TEXTURECOORDINATE0
                }, r = {
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_WorldMat: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_LightmapScaleOffset: L.PERIOD_SPRITE,
                    u_LightMap: L.PERIOD_SPRITE,
                    u_SplatAlphaTexture: L.PERIOD_MATERIAL,
                    u_DiffuseTexture1: L.PERIOD_MATERIAL,
                    u_DiffuseTexture2: L.PERIOD_MATERIAL,
                    u_DiffuseTexture3: L.PERIOD_MATERIAL,
                    u_DiffuseTexture4: L.PERIOD_MATERIAL,
                    u_DiffuseTexture5: L.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset1: L.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset2: L.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset3: L.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset4: L.PERIOD_MATERIAL,
                    u_DiffuseScaleOffset5: L.PERIOD_MATERIAL,
                    u_FogStart: L.PERIOD_SCENE,
                    u_FogRange: L.PERIOD_SCENE,
                    u_FogColor: L.PERIOD_SCENE,
                    "u_DirectionLight.Direction": L.PERIOD_SCENE,
                    "u_DirectionLight.Color": L.PERIOD_SCENE,
                    "u_PointLight.Position": L.PERIOD_SCENE,
                    "u_PointLight.Range": L.PERIOD_SCENE,
                    "u_PointLight.Attenuation": L.PERIOD_SCENE,
                    "u_PointLight.Color": L.PERIOD_SCENE,
                    "u_SpotLight.Position": L.PERIOD_SCENE,
                    "u_SpotLight.Direction": L.PERIOD_SCENE,
                    "u_SpotLight.Range": L.PERIOD_SCENE,
                    "u_SpotLight.Spot": L.PERIOD_SCENE,
                    "u_SpotLight.Color": L.PERIOD_SCENE,
                    u_AmbientColor: L.PERIOD_SCENE,
                    u_shadowMap1: L.PERIOD_SCENE,
                    u_shadowMap2: L.PERIOD_SCENE,
                    u_shadowMap3: L.PERIOD_SCENE,
                    u_shadowPSSMDistance: L.PERIOD_SCENE,
                    u_lightShadowVP: L.PERIOD_SCENE,
                    u_shadowPCFoffset: L.PERIOD_SCENE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("ExtendTerrain"), a = new sr(e, r, F.shaderDefines, Bt.shaderDefines),
                n.addSubShader(a), a.addShaderPass(dr, cr, i), e = {
                    a_Position: Jt.TRAIL_POSITION0,
                    a_OffsetVector: Jt.TRAIL_OFFSETVECTOR,
                    a_Texcoord0X: Jt.TRAIL_TEXTURECOORDINATE0X,
                    a_Texcoord0Y: Jt.TRAIL_TEXTURECOORDINATE0Y,
                    a_BirthTime: Jt.TRAIL_TIME0,
                    a_Color: Jt.TRAIL_COLOR
                }, r = {
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_View: L.PERIOD_CAMERA,
                    u_Projection: L.PERIOD_CAMERA,
                    u_TilingOffset: L.PERIOD_MATERIAL,
                    u_MainTexture: L.PERIOD_MATERIAL,
                    u_MainColor: L.PERIOD_MATERIAL,
                    u_CurTime: L.PERIOD_SPRITE,
                    u_LifeTime: L.PERIOD_SPRITE,
                    u_WidthCurve: L.PERIOD_SPRITE,
                    u_WidthCurveKeyLength: L.PERIOD_SPRITE,
                    u_GradientColorkey: L.PERIOD_SPRITE,
                    u_GradientAlphakey: L.PERIOD_SPRITE
                }, i = {
                    s_Cull: L.RENDER_STATE_CULL,
                    s_Blend: L.RENDER_STATE_BLEND,
                    s_BlendSrc: L.RENDER_STATE_BLEND_SRC,
                    s_BlendDst: L.RENDER_STATE_BLEND_DST,
                    s_DepthTest: L.RENDER_STATE_DEPTH_TEST,
                    s_DepthWrite: L.RENDER_STATE_DEPTH_WRITE
                }, n = L.add("Trail"), a = new sr(e, r, rr.shaderDefines, Zt.shaderDefines), n.addSubShader(a),
                a.addShaderPass(Yr, Xr, i), e = {
                    a_Position: v.MESH_POSITION0,
                    a_Normal: v.MESH_NORMAL0,
                    a_Tangent0: v.MESH_TANGENT0
                }, r = {
                    u_MvpMatrix: L.PERIOD_SPRITE,
                    u_WorldMat: L.PERIOD_SPRITE,
                    u_CameraPos: L.PERIOD_CAMERA,
                    u_Time: L.PERIOD_SCENE,
                    u_MainTexture: L.PERIOD_MATERIAL,
                    u_NormalTexture: L.PERIOD_MATERIAL,
                    u_HorizonColor: L.PERIOD_MATERIAL,
                    u_WaveScale: L.PERIOD_MATERIAL,
                    u_WaveSpeed: L.PERIOD_MATERIAL
                }, n = L.add("WaterPrimary"), a = new sr(e, r, null, Wt.shaderDefines), n.addSubShader(a),
                a.addShaderPass(Kr, qr), e = {
                    a_PositionTexcoord: v.MESH_POSITION0
                }, r = {
                    u_MainTex: L.PERIOD_MATERIAL
                }, n = L.add("BlitScreen"), a = new sr(e, r, null, null), n.addSubShader(a);
            var s = a.addShaderPass(lr, or),
                o = s.renderState;
            o.depthTest = ze.DEPTHTEST_ALWAYS, o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE,
                e = {
                    a_PositionTexcoord: v.MESH_POSITION0
                }, r = {
                    u_MainTex: L.PERIOD_MATERIAL,
                    u_BloomTex: L.PERIOD_MATERIAL,
                    u_AutoExposureTex: L.PERIOD_MATERIAL,
                    u_MainTex_TexelSize: L.PERIOD_MATERIAL,
                    u_SampleScale: L.PERIOD_MATERIAL,
                    u_Threshold: L.PERIOD_MATERIAL,
                    u_Params: L.PERIOD_MATERIAL
                }, n = L.add("PostProcessBloom", e, r), a = new sr(null, null, null, null), n.addSubShader(a),
                (o = (s = a.addShaderPass(Lr, Or)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, a = new sr(null, null, null, null),
                n.addSubShader(a), (o = (s = a.addShaderPass(Lr, Nr)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, a = new sr(null, null, null, null),
                n.addSubShader(a), (o = (s = a.addShaderPass(Lr, Cr)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, a = new sr(null, null, null, null),
                n.addSubShader(a), (o = (s = a.addShaderPass(Lr, yr)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, a = new sr(null, null, null, null),
                n.addSubShader(a), (o = (s = a.addShaderPass(Lr, Vr)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, a = new sr(null, null, null, null),
                n.addSubShader(a), (o = (s = a.addShaderPass(Lr, Pr)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE, e = {
                    a_PositionTexcoord: v.MESH_POSITION0
                }, r = {
                    u_MainTex: L.PERIOD_MATERIAL,
                    u_BloomTex: L.PERIOD_MATERIAL,
                    u_AutoExposureTex: L.PERIOD_MATERIAL,
                    u_Bloom_DirtTileOffset: L.PERIOD_MATERIAL,
                    u_Bloom_DirtTex: L.PERIOD_MATERIAL,
                    u_BloomTex_TexelSize: L.PERIOD_MATERIAL,
                    u_Bloom_Settings: L.PERIOD_MATERIAL,
                    u_Bloom_Color: L.PERIOD_MATERIAL
                }, n = L.add("PostProcessComposite", e, r), a = new sr(null, null, null, bt.shaderDefines),
                n.addSubShader(a), (o = (s = a.addShaderPass(Fr, br)).renderState).depthTest = ze.DEPTHTEST_ALWAYS,
                o.depthWrite = !1, o.cull = ze.CULL_NONE, o.blend = ze.BLEND_DISABLE;
        }
    }
    class Jr extends Ge {
        constructor() {
            super(), this.setShaderName("LineShader"), this._shaderValues.setVector(Jr.COLOR, new n(1, 1, 1, 1));
        }
        static __initDefine__() {
            Jr.shaderDefines = new C(Ge.shaderDefines);
        }
        get color() {
            return this._shaderValues.getVector(Jr.COLOR);
        }
        set color(e) {
            this._shaderValues.setVector(Jr.COLOR, e);
        }
        set depthWrite(e) {
            this._shaderValues.setBool(Jr.DEPTH_WRITE, e);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Jr.DEPTH_WRITE);
        }
        set cull(e) {
            this._shaderValues.setInt(Jr.CULL, e);
        }
        get cull() {
            return this._shaderValues.getInt(Jr.CULL);
        }
        set blend(e) {
            this._shaderValues.setInt(Jr.BLEND, e);
        }
        get blend() {
            return this._shaderValues.getInt(Jr.BLEND);
        }
        set blendSrc(e) {
            this._shaderValues.setInt(Jr.BLEND_SRC, e);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Jr.BLEND_SRC);
        }
        set blendDst(e) {
            this._shaderValues.setInt(Jr.BLEND_DST, e);
        }
        get blendDst() {
            return this._shaderValues.getInt(Jr.BLEND_DST);
        }
        set depthTest(e) {
            this._shaderValues.setInt(Jr.DEPTH_TEST, e);
        }
        get depthTest() {
            return this._shaderValues.getInt(Jr.DEPTH_TEST);
        }
        clone() {
            var e = new Jr();
            return this.cloneTo(e), e;
        }
    }
    Jr.COLOR = L.propertyNameToID("u_Color"), Jr.shaderDefines = null, Jr.CULL = L.propertyNameToID("s_Cull"),
        Jr.BLEND = L.propertyNameToID("s_Blend"), Jr.BLEND_SRC = L.propertyNameToID("s_BlendSrc"),
        Jr.BLEND_DST = L.propertyNameToID("s_BlendDst"), Jr.DEPTH_TEST = L.propertyNameToID("s_DepthTest"),
        Jr.DEPTH_WRITE = L.propertyNameToID("s_DepthWrite");
    class $r {
        static get vertexDeclaration() {
            return $r._vertexDeclaration;
        }
        static __init__() {
            $r._vertexDeclaration = new g(28, [new S(0, u.Vector3, v.MESH_POSITION0), new S(12, u.Vector4, v.MESH_COLOR0)]);
        }
        get vertexDeclaration() {
            return $r._vertexDeclaration;
        }
        constructor() {}
    }
    class ei extends h {
        constructor(e, r) {
            super(), this._floatCountPerVertices = 7, this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE,
                this._bufferState = new _(), this._maxLineCount = 0, this._lineCount = 0;
            var i = 2 * r;
            this._owner = e, this._maxLineCount = r, this._vertices = new Float32Array(i * this._floatCountPerVertices),
                this._vertexBuffer = new d($r.vertexDeclaration.vertexStride * i, t.LayaGL.instance.STATIC_DRAW, !1),
                this._vertexBuffer.vertexDeclaration = $r.vertexDeclaration, this._bufferState.bind(),
                this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
        }
        _getType() {
            return ei._type;
        }
        _resizeLineData(e) {
            var r = 2 * e,
                i = this._vertices;
            this._vertexBuffer.destroy(), this._maxLineCount = e;
            var n = r * this._floatCountPerVertices;
            this._vertices = new Float32Array(n), this._vertexBuffer = new d($r.vertexDeclaration.vertexStride * r, t.LayaGL.instance.STATIC_DRAW, !1),
                this._vertexBuffer.vertexDeclaration = $r.vertexDeclaration, n < i.length ? (this._vertices.set(new Float32Array(i.buffer, 0, n)),
                    this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * n)) : (this._vertices.set(i),
                    this._vertexBuffer.setData(this._vertices.buffer, 0, 0, 4 * i.length)), this._bufferState.bind(),
                this._bufferState.applyVertexBuffer(this._vertexBuffer), this._bufferState.unBind();
        }
        _updateLineVertices(e, t, r, i, n) {
            t && (this._vertices[e + 0] = t.x, this._vertices[e + 1] = t.y, this._vertices[e + 2] = t.z),
                i && (this._vertices[e + 3] = i.r, this._vertices[e + 4] = i.g, this._vertices[e + 5] = i.b,
                    this._vertices[e + 6] = i.a), r && (this._vertices[e + 7] = r.x, this._vertices[e + 8] = r.y,
                    this._vertices[e + 9] = r.z), n && (this._vertices[e + 10] = n.r, this._vertices[e + 11] = n.g,
                    this._vertices[e + 12] = n.b, this._vertices[e + 13] = n.a), this._minUpdate = Math.min(this._minUpdate, e),
                this._maxUpdate = Math.max(this._maxUpdate, e + 2 * this._floatCountPerVertices);
        }
        _removeLineData(e) {
            var t = 2 * this._floatCountPerVertices,
                r = e + 1,
                i = e * t,
                n = new Float32Array(this._vertices.buffer, r * t * 4, (this._lineCount - r) * t);
            this._vertices.set(n, i), this._minUpdate = Math.min(this._minUpdate, i), this._maxUpdate = Math.max(this._maxUpdate, i + n.length),
                this._lineCount--;
        }
        _updateLineData(e, t, r, i, n) {
            var a = e * (2 * this._floatCountPerVertices);
            this._updateLineVertices(a, t, r, i, n);
        }
        _updateLineDatas(e, t) {
            for (var r = 2 * this._floatCountPerVertices, i = t.length, n = 0; n < i; n++) {
                var a = t[n];
                this._updateLineVertices((e + n) * r, a.startPosition, a.endPosition, a.startColor, a.endColor);
            }
        }
        _getLineData(e, t) {
            var r = t.startPosition,
                i = t.startColor,
                n = t.endPosition,
                a = t.endColor,
                s = this._vertices,
                o = e * this._floatCountPerVertices * 2;
            r.x = s[o + 0], r.y = s[o + 1], r.z = s[o + 2], i.r = s[o + 3], i.g = s[o + 4],
                i.b = s[o + 5], i.a = s[o + 6], n.x = s[o + 7], n.y = s[o + 8], n.z = s[o + 9],
                a.r = s[o + 10], a.g = s[o + 11], a.b = s[o + 12], a.a = s[o + 13];
        }
        _prepareRender(e) {
            return !0;
        }
        _render(e) {
            if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE && (this._vertexBuffer.setData(this._vertices.buffer, 4 * this._minUpdate, 4 * this._minUpdate, 4 * (this._maxUpdate - this._minUpdate)),
                    this._minUpdate = Number.MAX_VALUE, this._maxUpdate = Number.MIN_VALUE), this._lineCount > 0) {
                this._bufferState.bind();
                var r = t.LayaGL.instance;
                r.drawArrays(r.LINES, 0, 2 * this._lineCount), t.Stat.renderBatches++;
            }
        }
        destroy() {
            this._destroyed || (super.destroy(), this._bufferState.destroy(), this._vertexBuffer.destroy(),
                this._bufferState = null, this._vertexBuffer = null, this._vertices = null);
        }
    }
    ei._type = h._typeCounter++;
    class ti extends ke {
        constructor(e) {
            super(e), this._projectionViewWorldMatrix = new T(), this._supportOctree = !1;
        }
        _calculateBoundingBox() {
            if ((e = this._bounds.getMin()).x = -Number.MAX_VALUE, e.y = -Number.MAX_VALUE,
                e.z = -Number.MAX_VALUE, this._bounds.setMin(e), (r = this._bounds.getMax()).x = Number.MAX_VALUE,
                r.y = Number.MAX_VALUE, r.z = Number.MAX_VALUE, this._bounds.setMax(r), t.Render.supportWebGLPlusCulling) {
                var e = this._bounds.getMin(),
                    r = this._bounds.getMax(),
                    i = U._cullingBuffer;
                i[this._cullingBufferIndex + 1] = e.x, i[this._cullingBufferIndex + 2] = e.y, i[this._cullingBufferIndex + 3] = e.z,
                    i[this._cullingBufferIndex + 4] = r.x, i[this._cullingBufferIndex + 5] = r.y, i[this._cullingBufferIndex + 6] = r.z;
            }
        }
        _renderUpdateWithCamera(e, t) {
            var r = e.projectionViewMatrix,
                i = this._shaderValues;
            if (t) {
                var n = t.worldMatrix;
                i.setMatrix4x4(b.WORLDMATRIX, n), T.multiply(r, n, this._projectionViewWorldMatrix),
                    i.setMatrix4x4(b.MVPMATRIX, this._projectionViewWorldMatrix);
            } else i.setMatrix4x4(b.WORLDMATRIX, T.DEFAULT), i.setMatrix4x4(b.MVPMATRIX, r);
        }
    }
    class ri extends F {
        get maxLineCount() {
            return this._geometryFilter._maxLineCount;
        }
        set maxLineCount(e) {
            this._geometryFilter._resizeLineData(e), this._geometryFilter._lineCount = Math.min(this._geometryFilter._lineCount, e);
        }
        get lineCount() {
            return this._geometryFilter._lineCount;
        }
        set lineCount(e) {
            if (e > this.maxLineCount) throw "PixelLineSprite3D: lineCount can't large than maxLineCount";
            this._geometryFilter._lineCount = e;
        }
        get pixelLineRenderer() {
            return this._render;
        }
        constructor(e = 2, t = null) {
            super(t), this._geometryFilter = new ei(this, e), this._render = new ti(this), this._changeRenderObjects(this._render, 0, Jr.defaultMaterial);
        }
        _changeRenderObjects(e, t, r) {
            var i = this._render._renderElements;
            r || (r = Jr.defaultMaterial);
            var n = i[t];
            n || (n = i[t] = new le()), n.setTransform(this._transform), n.setGeometry(this._geometryFilter),
                n.render = this._render, n.material = r;
        }
        addLine(e, t, r, i) {
            if (this._geometryFilter._lineCount === this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount has equal with maxLineCount.";
            this._geometryFilter._updateLineData(this._geometryFilter._lineCount++, e, t, r, i);
        }
        addLines(e) {
            var t = this._geometryFilter._lineCount,
                r = e.length;
            if (t + r > this._geometryFilter._maxLineCount) throw "PixelLineSprite3D: lineCount plus lines count must less than maxLineCount.";
            this._geometryFilter._updateLineDatas(t, e), this._geometryFilter._lineCount += r;
        }
        removeLine(e) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._removeLineData(e);
        }
        setLine(e, t, r, i, n) {
            if (!(e < this._geometryFilter._lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._updateLineData(e, t, r, i, n);
        }
        getLine(e, t) {
            if (!(e < this.lineCount)) throw "PixelLineSprite3D: index must less than lineCount.";
            this._geometryFilter._getLineData(e, t);
        }
        clear() {
            this._geometryFilter._lineCount = 0;
        }
        _create() {
            return new ri();
        }
    }
    class ii {
        constructor(e = !1) {
            this.isTransparent = !1, this.elements = new he(), this.lastTransparentRenderElement = null,
                this.lastTransparentBatched = !1, this.isTransparent = e;
        }
        _compare(e, t) {
            var r = e.material.renderQueue - t.material.renderQueue;
            return 0 === r ? (this.isTransparent ? t.render._distanceForSort - e.render._distanceForSort : e.render._distanceForSort - t.render._distanceForSort) + t.render.sortingFudge - e.render.sortingFudge : r;
        }
        _partitionRenderObject(e, t) {
            for (var r = this.elements.elements, i = r[Math.floor((t + e) / 2)]; e <= t;) {
                for (; this._compare(r[e], i) < 0;) e++;
                for (; this._compare(r[t], i) > 0;) t--;
                if (e < t) {
                    var n = r[e];
                    r[e] = r[t], r[t] = n, e++, t--;
                } else if (e === t) {
                    e++;
                    break;
                }
            }
            return e;
        }
        _quickSort(e, t) {
            if (this.elements.length > 1) {
                var r = this._partitionRenderObject(e, t),
                    i = r - 1;
                e < i && this._quickSort(e, i), r < t && this._quickSort(r, t);
            }
        }
        _render(e, t) {
            for (var r = this.elements.elements, i = 0, n = this.elements.length; i < n; i++) r[i]._render(e, t);
        }
        clear() {
            this.elements.length = 0, this.lastTransparentRenderElement = null, this.lastTransparentBatched = !1;
        }
    }
    class ni {
        constructor(e, t, r, i) {
            this._bounds = new Oe(new a(), new a()), this._objects = [], this._isContaion = !1,
                this.center = new a(), this.baseLength = 0, this._setValues(e, t, r, i);
        }
        static _encapsulates(e, t) {
            return W.boxContainsBox(e, t) == H.Contains;
        }
        _setValues(e, t, r, i) {
            this._octree = e, this._parent = t, this.baseLength = r, i.cloneTo(this.center);
            var n = this._bounds.min,
                a = this._bounds.max,
                s = e._looseness * r / 2;
            n.setValue(i.x - s, i.y - s, i.z - s), a.setValue(i.x + s, i.y + s, i.z + s);
        }
        _getChildBound(e) {
            if (null != this._children && this._children[e]) return this._children[e]._bounds;
            var t = this.baseLength / 4,
                r = this.baseLength / 2 * this._octree._looseness / 2,
                i = ni._tempBoundBox,
                n = i.min,
                a = i.max;
            switch (e) {
                case 0:
                    n.x = this.center.x - t - r, n.y = this.center.y + t - r, n.z = this.center.z - t - r,
                        a.x = this.center.x - t + r, a.y = this.center.y + t + r, a.z = this.center.z - t + r;
                    break;

                case 1:
                    n.x = this.center.x + t - r, n.y = this.center.y + t - r, n.z = this.center.z - t - r,
                        a.x = this.center.x + t + r, a.y = this.center.y + t + r, a.z = this.center.z - t + r;
                    break;

                case 2:
                    n.x = this.center.x - t - r, n.y = this.center.y + t - r, n.z = this.center.z + t - r,
                        a.x = this.center.x - t + r, a.y = this.center.y + t + r, a.z = this.center.z + t + r;
                    break;

                case 3:
                    n.x = this.center.x + t - r, n.y = this.center.y + t - r, n.z = this.center.z + t - r,
                        a.x = this.center.x + t + r, a.y = this.center.y + t + r, a.z = this.center.z + t + r;
                    break;

                case 4:
                    n.x = this.center.x - t - r, n.y = this.center.y - t - r, n.z = this.center.z - t - r,
                        a.x = this.center.x - t + r, a.y = this.center.y - t + r, a.z = this.center.z - t + r;
                    break;

                case 5:
                    n.x = this.center.x + t - r, n.y = this.center.y - t - r, n.z = this.center.z - t - r,
                        a.x = this.center.x + t + r, a.y = this.center.y - t + r, a.z = this.center.z - t + r;
                    break;

                case 6:
                    n.x = this.center.x - t - r, n.y = this.center.y - t - r, n.z = this.center.z + t - r,
                        a.x = this.center.x - t + r, a.y = this.center.y - t + r, a.z = this.center.z + t + r;
                    break;

                case 7:
                    n.x = this.center.x + t - r, n.y = this.center.y - t - r, n.z = this.center.z + t - r,
                        a.x = this.center.x + t + r, a.y = this.center.y - t + r, a.z = this.center.z + t + r;
            }
            return i;
        }
        _getChildCenter(e) {
            if (null != this._children) return this._children[e].center;
            var t = this.baseLength / 4,
                r = ni._tempVector30;
            switch (e) {
                case 0:
                    r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z - t;
                    break;

                case 1:
                    r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z - t;
                    break;

                case 2:
                    r.x = this.center.x - t, r.y = this.center.y + t, r.z = this.center.z + t;
                    break;

                case 3:
                    r.x = this.center.x + t, r.y = this.center.y + t, r.z = this.center.z + t;
                    break;

                case 4:
                    r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z - t;
                    break;

                case 5:
                    r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z - t;
                    break;

                case 6:
                    r.x = this.center.x - t, r.y = this.center.y - t, r.z = this.center.z + t;
                    break;

                case 7:
                    r.x = this.center.x + t, r.y = this.center.y - t, r.z = this.center.z + t;
            }
            return r;
        }
        _getChild(e) {
            var t = this.baseLength / 4;
            switch (this._children || (this._children = []), e) {
                case 0:
                    return this._children[0] || (this._children[0] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x + -t, this.center.y + t, this.center.z - t)));

                case 1:
                    return this._children[1] || (this._children[1] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x + t, this.center.y + t, this.center.z - t)));

                case 2:
                    return this._children[2] || (this._children[2] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x - t, this.center.y + t, this.center.z + t)));

                case 3:
                    return this._children[3] || (this._children[3] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x + t, this.center.y + t, this.center.z + t)));

                case 4:
                    return this._children[4] || (this._children[4] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x - t, this.center.y - t, this.center.z - t)));

                case 5:
                    return this._children[5] || (this._children[5] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x + t, this.center.y - t, this.center.z - t)));

                case 6:
                    return this._children[6] || (this._children[6] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x - t, this.center.y - t, this.center.z + t)));

                case 7:
                    return this._children[7] || (this._children[7] = new ni(this._octree, this, this.baseLength / 2, new a(this.center.x + t, this.center.y - t, this.center.z + t)));

                default:
                    throw "BoundsOctreeNode: unknown index.";
            }
        }
        _shouldMerge() {
            for (var e = this._objects.length, t = 0; t < 8; t++) {
                var r = this._children[t];
                if (r) {
                    if (null != r._children) return !1;
                    e += r._objects.length;
                }
            }
            return e <= ni._NUM_OBJECTS_ALLOWED;
        }
        _mergeChildren() {
            for (var e = 0; e < 8; e++) {
                var t = this._children[e];
                if (t) {
                    t._parent = null;
                    for (var r = t._objects, i = r.length - 1; i >= 0; i--) {
                        var n = r[i];
                        this._objects.push(n), n._setOctreeNode(this);
                    }
                }
            }
            this._children = null;
        }
        _merge() {
            if (null === this._children) {
                var e = this._parent;
                e && e._shouldMerge() && (e._mergeChildren(), e._merge());
            }
        }
        _checkAddNode(e) {
            if (null == this._children) {
                if (this._objects.length < ni._NUM_OBJECTS_ALLOWED || this.baseLength / 2 < this._octree._minSize) return this;
                for (var t = this._objects.length - 1; t >= 0; t--) {
                    var r = this._objects[t],
                        i = this._bestFitChild(r.bounds.getCenter());
                    ni._encapsulates(this._getChildBound(i), r.bounds._getBoundBox()) && (this._objects.splice(this._objects.indexOf(r), 1),
                        this._getChild(i)._add(r));
                }
            }
            var n = this._bestFitChild(e.bounds.getCenter());
            return ni._encapsulates(this._getChildBound(n), e.bounds._getBoundBox()) ? this._getChild(n)._checkAddNode(e) : this;
        }
        _add(e) {
            var t = this._checkAddNode(e);
            t._objects.push(e), e._setOctreeNode(t);
        }
        _remove(e) {
            var t = this._objects.indexOf(e);
            this._objects.splice(t, 1), e._setOctreeNode(null), this._merge();
        }
        _addUp(e) {
            return W.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === H.Contains ? (this._add(e), !0) : !!this._parent && this._parent._addUp(e);
        }
        _getCollidingWithFrustum(e, r, i, n, s, o) {
            if (i) {
                var l = r.containsBoundBox(this._bounds);
                if (t.Stat.octreeNodeCulling++, l === H.Disjoint) return;
                i = l === H.Intersects;
            }
            this._isContaion = !i;
            for (var _ = e.camera, h = e.scene, c = 0, d = this._objects.length; c < d; c++) {
                var u = this._objects[c];
                if (_._isLayerVisible(u._owner.layer) && u._enable) {
                    if (i && (t.Stat.frustumCulling++, !u._needRender(r, e))) continue;
                    u._distanceForSort = a.distance(u.bounds.getCenter(), n);
                    for (var f = u._renderElements, E = 0, T = f.length; E < T; E++) {
                        f[E]._update(h, e, s, o);
                    }
                }
            }
            if (null != this._children)
                for (c = 0; c < 8; c++) {
                    var m = this._children[c];
                    m && m._getCollidingWithFrustum(e, r, i, n, s, o);
                }
        }
        _getCollidingWithBoundBox(e, t, r) {
            if (t) {
                var i = W.boxContainsBox(this._bounds, e);
                if (i === H.Disjoint) return;
                t = i === H.Intersects;
            }
            if (t)
                for (var n = 0, a = this._objects.length; n < a; n++) {
                    var s = this._objects[n];
                    W.intersectsBoxAndBox(s.bounds._getBoundBox(), e) && r.push(s);
                }
            if (null != this._children)
                for (n = 0; n < 8; n++) {
                    this._children[n]._getCollidingWithBoundBox(e, t, r);
                }
        }
        _bestFitChild(e) {
            return (e.x <= this.center.x ? 0 : 1) + (e.y >= this.center.y ? 0 : 4) + (e.z <= this.center.z ? 0 : 2);
        }
        _update(e) {
            if (W.boxContainsBox(this._bounds, e.bounds._getBoundBox()) === H.Contains) {
                var t = this._checkAddNode(e);
                if (t !== e._getOctreeNode()) {
                    t._objects.push(e), e._setOctreeNode(t);
                    var r = this._objects.indexOf(e);
                    this._objects.splice(r, 1), this._merge();
                }
                return !0;
            }
            if (this._parent) {
                var i = this._parent._addUp(e);
                return i && (r = this._objects.indexOf(e), this._objects.splice(r, 1), this._merge()),
                    i;
            }
            return !1;
        }
        add(e) {
            return !!ni._encapsulates(this._bounds, e.bounds._getBoundBox()) && (this._add(e), !0);
        }
        remove(e) {
            return e._getOctreeNode() === this && (this._remove(e), !0);
        }
        update(e) {
            return e._getOctreeNode() === this && this._update(e);
        }
        shrinkIfPossible(e) {
            if (this.baseLength < 2 * e) return this;
            for (var t = -1, r = 0, i = this._objects.length; r < i; r++) {
                var n = this._objects[r],
                    a = this._bestFitChild(n.bounds.getCenter());
                if (0 != r && a != t) return this;
                var s = this._getChildBound(a);
                if (!ni._encapsulates(s, n.bounds._getBoundBox())) return this;
                0 == r && (t = a);
            }
            if (null == this._children) {
                if (-1 != t) {
                    var o = this._getChildCenter(t);
                    this._setValues(this._octree, null, this.baseLength / 2, o);
                }
                return this;
            }
            var l = !1;
            for (r = 0, i = this._children.length; r < i; r++) {
                var _ = this._children[r];
                if (_ && _.hasAnyObjects()) {
                    if (l) return this;
                    if (t >= 0 && t != r) return this;
                    l = !0, t = r;
                }
            }
            if (-1 != t) {
                var h = this._children[t];
                return h._parent = null, h;
            }
            return this;
        }
        hasAnyObjects() {
            if (this._objects.length > 0) return !0;
            if (null != this._children)
                for (var e = 0; e < 8; e++) {
                    var t = this._children[e];
                    if (t && t.hasAnyObjects()) return !0;
                }
            return !1;
        }
        getCollidingWithBoundBox(e, t) {
            this._getCollidingWithBoundBox(e, !0, t);
        }
        getCollidingWithRay(e, t, r = Number.MAX_VALUE) {
            var i = W.intersectsRayAndBoxRD(e, this._bounds);
            if (!(-1 == i || i > r)) {
                for (var n = 0, a = this._objects.length; n < a; n++) {
                    var s = this._objects[n]; -
                    1 !== (i = W.intersectsRayAndBoxRD(e, s.bounds._getBoundBox())) && i <= r && t.push(s);
                }
                if (null != this._children)
                    for (n = 0; n < 8; n++) {
                        this._children[n].getCollidingWithRay(e, t, r);
                    }
            }
        }
        getCollidingWithFrustum(e, t, r) {
            var i = e.camera.transform.position,
                n = e.camera.boundFrustum;
            this._getCollidingWithFrustum(e, n, !0, i, t, r);
        }
        isCollidingWithBoundBox(e) {
            if (!W.intersectsBoxAndBox(this._bounds, e)) return !1;
            for (var t = 0, r = this._objects.length; t < r; t++) {
                var i = this._objects[t];
                if (W.intersectsBoxAndBox(i.bounds._getBoundBox(), e)) return !0;
            }
            if (null != this._children)
                for (t = 0; t < 8; t++) {
                    if (this._children[t].isCollidingWithBoundBox(e)) return !0;
                }
            return !1;
        }
        isCollidingWithRay(e, t = Number.MAX_VALUE) {
            var r = W.intersectsRayAndBoxRD(e, this._bounds);
            if (-1 == r || r > t) return !1;
            for (var i = 0, n = this._objects.length; i < n; i++) {
                var a = this._objects[i];
                if (-1 !== (r = W.intersectsRayAndBoxRD(e, a.bounds._getBoundBox())) && r <= t) return !0;
            }
            if (null != this._children)
                for (i = 0; i < 8; i++) {
                    if (this._children[i].isCollidingWithRay(e, t)) return !0;
                }
            return !1;
        }
        getBound() {
            return this._bounds;
        }
        drawAllBounds(e, t, r) {
            if (null !== this._children || 0 != this._objects.length) {
                t++;
                var i = ni._tempColor0;
                if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
                else {
                    var n = r ? t / r : 0;
                    i.r = 1 - n, i.g = n, i.b = 0;
                }
                if (i.a = .3, M._drawBound(e, this._bounds, i), null != this._children)
                    for (var a = 0; a < 8; a++) {
                        var s = this._children[a];
                        s && s.drawAllBounds(e, t, r);
                    }
            }
        }
        drawAllObjects(e, t, r) {
            t++;
            var i = ni._tempColor0;
            if (this._isContaion) i.r = 0, i.g = 0, i.b = 1;
            else {
                var n = r ? t / r : 0;
                i.r = 1 - n, i.g = n, i.b = 0;
            }
            i.a = 1;
            for (var a = 0, s = this._objects.length; a < s; a++) M._drawBound(e, this._objects[a].bounds._getBoundBox(), i);
            if (null != this._children)
                for (a = 0; a < 8; a++) {
                    var o = this._children[a];
                    o && o.drawAllObjects(e, t, r);
                }
        }
    }
    ni._tempVector3 = new a(), ni._tempVector30 = new a(), ni._tempVector31 = new a(),
        ni._tempColor0 = new I(), ni._tempBoundBox = new Oe(new a(), new a()), ni._NUM_OBJECTS_ALLOWED = 8;
    class ai extends he {
        constructor() {
            super();
        }
        add(e) {
            if (-1 !== e._getIndexInMotionList()) throw "OctreeMotionList:element has  in  PhysicsUpdateList.";
            this._add(e), e._setIndexInMotionList(this.length++);
        }
        remove(e) {
            var t = e._getIndexInMotionList();
            if (this.length--, t !== this.length) {
                var r = this.elements[this.length];
                this.elements[t] = r, r._setIndexInMotionList(t);
            }
            e._setIndexInMotionList(-1);
        }
    }
    class si {
        constructor(e, t, r, i) {
            this._motionObjects = new ai(), this.count = 0, r > e && (console.warn("Minimum node size must be at least as big as the initial world size. Was: " + r + " Adjusted to: " + e),
                    r = e), this._initialSize = e, this._minSize = r, this._looseness = Math.min(Math.max(i, 1), 2),
                this._rootNode = new ni(this, null, e, t);
        }
        _getMaxDepth(e, t) {
            t++;
            var r = e._children;
            if (null != r)
                for (var i = t, n = 0, a = r.length; n < a; n++) {
                    var s = r[n];
                    s && (t = Math.max(this._getMaxDepth(s, i), t));
                }
            return t;
        }
        _grow(e) {
            var t = e.x >= 0 ? 1 : -1,
                r = e.y >= 0 ? 1 : -1,
                i = e.z >= 0 ? 1 : -1,
                n = this._rootNode,
                s = this._rootNode.baseLength / 2,
                o = 2 * this._rootNode.baseLength,
                l = this._rootNode.center,
                _ = new a(l.x + t * s, l.y + r * s, l.z + i * s);
            if (this._rootNode = new ni(this, null, o, _), n.hasAnyObjects()) {
                for (var h = this._rootNode._bestFitChild(n.center), c = [], d = 0; d < 8; d++) d == h && (n._parent = this._rootNode,
                    c[d] = n);
                this._rootNode._children = c;
            }
        }
        add(e) {
            for (var t = 0; !this._rootNode.add(e);) {
                var r = si._tempVector30;
                if (a.subtract(e.bounds.getCenter(), this._rootNode.center, r), this._grow(r), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
            }
            this.count++;
        }
        remove(e) {
            var t = e._getOctreeNode().remove(e);
            return t && this.count--, t;
        }
        update(e) {
            var t = 0,
                r = e._getOctreeNode();
            if (r) {
                for (; !r._update(e);) {
                    var i = si._tempVector30;
                    if (a.subtract(e.bounds.getCenter(), this._rootNode.center, i), this._grow(i), ++t > 20) throw "Aborted Add operation as it seemed to be going on forever (" + (t - 1) + ") attempts at growing the octree.";
                }
                return !0;
            }
            return !1;
        }
        shrinkRootIfPossible() {
            this._rootNode = this._rootNode.shrinkIfPossible(this._initialSize);
        }
        addMotionObject(e) {
            this._motionObjects.add(e);
        }
        removeMotionObject(e) {
            this._motionObjects.remove(e);
        }
        updateMotionObjects() {
            for (var e = this._motionObjects.elements, t = 0, r = this._motionObjects.length; t < r; t++) {
                var i = e[t];
                this.update(i), i._setIndexInMotionList(-1);
            }
            this._motionObjects.length = 0;
        }
        isCollidingWithBoundBox(e) {
            return this._rootNode.isCollidingWithBoundBox(e);
        }
        isCollidingWithRay(e, t = Number.MAX_VALUE) {
            return this._rootNode.isCollidingWithRay(e, t);
        }
        getCollidingWithBoundBox(e, t) {
            this._rootNode.getCollidingWithBoundBox(e, t);
        }
        getCollidingWithRay(e, t, r = Number.MAX_VALUE) {
            this._rootNode.getCollidingWithRay(e, t, r);
        }
        getCollidingWithFrustum(e, t, r) {
            this._rootNode.getCollidingWithFrustum(e, t, r);
        }
        getMaxBounds() {
            return this._rootNode.getBound();
        }
        drawAllBounds(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllBounds(e, -1, t);
        }
        drawAllObjects(e) {
            var t = this._getMaxDepth(this._rootNode, -1);
            this._rootNode.drawAllObjects(e, -1, t);
        }
    }
    si._tempVector30 = new a();
    class oi extends t.Sprite {
        constructor() {
            if (super(), this._lights = [], this._lightmaps = [], this._skyRenderer = new K(),
                this._reflectionMode = 1, this._enableLightCount = 3, this._input = new Ot(), this._timer = t.ILaya.timer,
                this._collsionTestList = [], this._renders = new Lt(), this._opaqueQueue = new ii(!1),
                this._transparentQueue = new ii(!0), this._cameraPool = [], this._animatorPool = new Lt(),
                this._scriptPool = new Array(), this._tempScriptPool = new Array(), this._needClearScriptPool = !1,
                this._castShadowRenders = new Mt(), this.currentCreationLayer = Math.pow(2, 0),
                this.enableLight = !0, this._key = new t.SubmitKey(), this._time = 0, this._pickIdToSprite = new Object(),
                fe._enbalePhysics && (this._physicsSimulation = new ye(oi.physicsSettings)), this._shaderValues = new p(null),
                this.parallelSplitShadowMaps = [], this.enableFog = !1, this.fogStart = 300, this.fogRange = 1e3,
                this.fogColor = new a(.7, .7, .7), this.ambientColor = new a(.212, .227, .259),
                this.reflectionIntensity = 1, t.WebGL.shaderHighPrecision && this._shaderValues.addDefine(L.SHADERDEFINE_HIGHPRECISION),
                t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices = new Int32Array(1024),
                    this._cullingBufferResult = new Int32Array(1024)), this._shaderValues.setTexture(oi.RANGEATTENUATIONTEXTURE, Qr._rangeAttenTex),
                this._scene = this, this._input.__init__(t.Render.canvas, this), oi.octreeCulling && (this._octree = new si(oi.octreeInitialSize, oi.octreeInitialCenter, oi.octreeMinNodeSize, oi.octreeLooseness)),
                U.debugFrustumCulling) {
                this._debugTool = new ri();
                var e = new Jr();
                e.renderQueue = Ge.RENDERQUEUE_TRANSPARENT, e.alphaTest = !1, e.depthWrite = !1,
                    e.cull = ze.CULL_BACK, e.blend = ze.BLEND_ENABLE_ALL, e.blendSrc = ze.BLENDPARAM_SRC_ALPHA,
                    e.blendDst = ze.BLENDPARAM_ONE_MINUS_SRC_ALPHA, e.depthTest = ze.DEPTHTEST_LESS,
                    this._debugTool.pixelLineRenderer.sharedMaterial = e;
            }
        }
        static __init__() {
            se.SHADERDEFINE_FOG = L.registerPublicDefine("FOG"), se.SHADERDEFINE_DIRECTIONLIGHT = L.registerPublicDefine("DIRECTIONLIGHT"),
                se.SHADERDEFINE_POINTLIGHT = L.registerPublicDefine("POINTLIGHT"), se.SHADERDEFINE_SPOTLIGHT = L.registerPublicDefine("SPOTLIGHT"),
                se.SHADERDEFINE_CAST_SHADOW = L.registerPublicDefine("CASTSHADOW"), se.SHADERDEFINE_SHADOW_PSSM1 = L.registerPublicDefine("SHADOWMAP_PSSM1"),
                se.SHADERDEFINE_SHADOW_PSSM2 = L.registerPublicDefine("SHADOWMAP_PSSM2"), se.SHADERDEFINE_SHADOW_PSSM3 = L.registerPublicDefine("SHADOWMAP_PSSM3"),
                se.SHADERDEFINE_SHADOW_PCF_NO = L.registerPublicDefine("SHADOWMAP_PCF_NO"), se.SHADERDEFINE_SHADOW_PCF1 = L.registerPublicDefine("SHADOWMAP_PCF1"),
                se.SHADERDEFINE_SHADOW_PCF2 = L.registerPublicDefine("SHADOWMAP_PCF2"), se.SHADERDEFINE_SHADOW_PCF3 = L.registerPublicDefine("SHADOWMAP_PCF3"),
                se.SHADERDEFINE_REFLECTMAP = L.registerPublicDefine("REFLECTMAP");
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, oi.HIERARCHY);
        }
        _allotPickColorByID(e, t) {
            var r = Math.floor(e / 65025);
            e -= 255 * r * 255;
            var i = Math.floor(e / 255),
                n = e -= 255 * i;
            t.x = r / 255, t.y = i / 255, t.z = n / 255, t.w = 1;
        }
        _searchIDByPickColor(e) {
            return 255 * e.x * 255 + 255 * e.y + e.z;
        }
        get url() {
            return this._url;
        }
        get enableFog() {
            return this._enableFog;
        }
        set enableFog(e) {
            this._enableFog !== e && (this._enableFog = e, e ? this._shaderValues.addDefine(se.SHADERDEFINE_FOG) : this._shaderValues.removeDefine(se.SHADERDEFINE_FOG));
        }
        get fogColor() {
            return this._shaderValues.getVector3(oi.FOGCOLOR);
        }
        set fogColor(e) {
            this._shaderValues.setVector3(oi.FOGCOLOR, e);
        }
        get fogStart() {
            return this._shaderValues.getNumber(oi.FOGSTART);
        }
        set fogStart(e) {
            this._shaderValues.setNumber(oi.FOGSTART, e);
        }
        get fogRange() {
            return this._shaderValues.getNumber(oi.FOGRANGE);
        }
        set fogRange(e) {
            this._shaderValues.setNumber(oi.FOGRANGE, e);
        }
        get ambientColor() {
            return this._shaderValues.getVector3(oi.AMBIENTCOLOR);
        }
        set ambientColor(e) {
            this._shaderValues.setVector3(oi.AMBIENTCOLOR, e);
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get customReflection() {
            return this._shaderValues.getTexture(oi.REFLECTIONTEXTURE);
        }
        set customReflection(e) {
            this._shaderValues.setTexture(oi.REFLECTIONTEXTURE, e), e ? this._shaderValues.addDefine(se.SHADERDEFINE_REFLECTMAP) : this._shaderValues.removeDefine(se.SHADERDEFINE_REFLECTMAP);
        }
        get reflectionIntensity() {
            return this._shaderValues.getNumber(oi.REFLETIONINTENSITY);
        }
        set reflectionIntensity(e) {
            e = Math.max(Math.min(e, 1), 0), this._shaderValues.setNumber(oi.REFLETIONINTENSITY, e);
        }
        get physicsSimulation() {
            return this._physicsSimulation;
        }
        get reflectionMode() {
            return this._reflectionMode;
        }
        set reflectionMode(e) {
            this._reflectionMode = e;
        }
        get timer() {
            return this._timer;
        }
        set timer(e) {
            this._timer = e;
        }
        get input() {
            return this._input;
        }
        _setLightmapToChildNode(e) {
            e instanceof F && e._render._applyLightMapParams();
            for (var t = e._children, r = 0, i = t.length; r < i; r++) this._setLightmapToChildNode(t[r]);
        }
        _update() {
            var e = this.timer._delta / 1e3;
            this._time += e, this._shaderValues.setNumber(oi.TIME, this._time);
            var t = this._physicsSimulation;
            fe._enbalePhysics && !ye.disableSimulation && (t._updatePhysicsTransformFromRender(),
                    De._addUpdateList = !1, t._simulate(e), t._updateCharacters(), De._addUpdateList = !0,
                    t._updateCollisions(), t._eventScripts()), this._input._update(), this._clearScript(),
                this._updateScript(), V._update(this), this._lateUpdateScript();
        }
        _binarySearchIndexInCameraPool(e) {
            for (var t, r = 0, i = this._cameraPool.length - 1; r <= i;) {
                t = Math.floor((r + i) / 2);
                var n = this._cameraPool[t]._renderingOrder;
                if (n == e._renderingOrder) return t;
                n > e._renderingOrder ? i = t - 1 : r = t + 1;
            }
            return r;
        }
        onEnable() {
            this._input._onCanvasEvent(t.Render.canvas);
        }
        onDisable() {
            this._input._offCanvasEvent(t.Render.canvas);
        }
        _setCreateURL(e) {
            this._url = t.URL.formatURL(e);
        }
        _getGroup() {
            return this._group;
        }
        _setGroup(e) {
            this._group = e;
        }
        _clearScript() {
            if (this._needClearScriptPool) {
                for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                    var i = e[t];
                    i && (i._indexInPool = this._tempScriptPool.length, this._tempScriptPool.push(i));
                }
                this._scriptPool = this._tempScriptPool, e.length = 0, this._tempScriptPool = e,
                    this._needClearScriptPool = !1;
            }
        }
        _updateScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onUpdate();
            }
        }
        _lateUpdateScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onLateUpdate();
            }
        }
        _addScript(e) {
            var t = this._scriptPool;
            e._indexInPool = t.length, t.push(e);
        }
        _removeScript(e) {
            this._scriptPool[e._indexInPool] = null, e._indexInPool = -1, this._needClearScriptPool = !0;
        }
        _preRenderScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onPreRender();
            }
        }
        _postRenderScript() {
            for (var e = this._scriptPool, t = 0, r = e.length; t < r; t++) {
                var i = e[t];
                i && i.enabled && i.onPostRender();
            }
        }
        _prepareSceneToRender() {
            var e = this._lights.length;
            if (e > 0)
                for (var t = 0, r = 0; r < e && !(this._lights[r]._prepareToScene() && ++t >= this._enableLightCount); r++);
        }
        _addCamera(e) {
            for (var t = this._binarySearchIndexInCameraPool(e), r = e._renderingOrder, i = this._cameraPool.length; t < i && this._cameraPool[t]._renderingOrder <= r;) t++;
            this._cameraPool.splice(t, 0, e);
        }
        _removeCamera(e) {
            this._cameraPool.splice(this._cameraPool.indexOf(e), 1);
        }
        _preCulling(e, t, r, i) {
            U.renderObjectCulling(t, this, e, this._renders, r, i);
        }
        _clear(e, r) {
            var i, n = r.viewport,
                a = r.camera,
                s = a._renderTexture || a._offScreenRenderTexture,
                o = n.width,
                l = n.height,
                _ = n.x,
                h = a._getCanvasHeight() - n.y - l;
            e.viewport(_, h, o, l);
            var c = a.clearFlag;
            switch (c !== Q.CLEARFLAG_SKY || a.skyRenderer._isAvailable() || this._skyRenderer._isAvailable() || (c = Q.CLEARFLAG_SOLIDCOLOR),
                c) {
                case Q.CLEARFLAG_SOLIDCOLOR:
                    var d = a.clearColor;
                    if (e.enable(e.SCISSOR_TEST), e.scissor(_, h, o, l), d ? e.clearColor(d.x, d.y, d.z, d.w) : e.clearColor(0, 0, 0, 0),
                        s) switch (i = e.COLOR_BUFFER_BIT, s.depthStencilFormat) {
                        case t.BaseTexture.FORMAT_DEPTH_16:
                            i |= e.DEPTH_BUFFER_BIT;
                            break;

                        case t.BaseTexture.FORMAT_STENCIL_8:
                            i |= e.STENCIL_BUFFER_BIT;
                            break;

                        case t.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                            i |= e.DEPTH_BUFFER_BIT, i |= e.STENCIL_BUFFER_BIT;
                    } else i = e.COLOR_BUFFER_BIT | e.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(e, !0), e.clear(i), e.disable(e.SCISSOR_TEST);
                    break;

                case Q.CLEARFLAG_SKY:
                case Q.CLEARFLAG_DEPTHONLY:
                    if (e.enable(e.SCISSOR_TEST), e.scissor(_, h, o, l), s) switch (s.depthStencilFormat) {
                        case t.BaseTexture.FORMAT_DEPTH_16:
                            i = e.DEPTH_BUFFER_BIT;
                            break;

                        case t.BaseTexture.FORMAT_STENCIL_8:
                            i = e.STENCIL_BUFFER_BIT;
                            break;

                        case t.BaseTexture.FORMAT_DEPTHSTENCIL_16_8:
                            i = e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT;
                    } else i = e.DEPTH_BUFFER_BIT;
                    t.WebGLContext.setDepthMask(e, !0), e.clear(i), e.disable(e.SCISSOR_TEST);
                    break;

                case Q.CLEARFLAG_NONE:
                    break;

                default:
                    throw new Error("BaseScene:camera clearFlag invalid.");
            }
        }
        _renderScene(e) {
            var t = e.camera,
                r = t._renderTexture || t._offScreenRenderTexture;
            if (r ? this._opaqueQueue._render(e, !0) : this._opaqueQueue._render(e, !1), t.clearFlag === Q.CLEARFLAG_SKY && (t.skyRenderer._isAvailable() ? t.skyRenderer._render(e) : this._skyRenderer._isAvailable() && this._skyRenderer._render(e)),
                r ? this._transparentQueue._render(e, !0) : this._transparentQueue._render(e, !1),
                U.debugFrustumCulling)
                for (var i = this._debugTool._render._renderElements, n = 0, a = i.length; n < a; n++) i[n]._update(this, e, null, null),
                    i[n]._render(e, !1);
        }
        _parse(e, r) {
            var i = e.lightmaps;
            if (i) {
                for (var n = i.length, a = [], s = 0; s < n; s++) a[s] = t.Loader.getRes(i[s].path);
                this.setlightmaps(a);
            }
            var o = e.ambientColor;
            if (o) {
                var l = this.ambientColor;
                l.fromArray(o), this.ambientColor = l;
            }
            var _ = e.sky;
            if (_) switch (this._skyRenderer.material = t.Loader.getRes(_.material.path), _.mesh) {
                case "SkyBox":
                    this._skyRenderer.mesh = q.instance;
                    break;

                case "SkyDome":
                    this._skyRenderer.mesh = Vt.instance;
                    break;

                default:
                    this.skyRenderer.mesh = q.instance;
            }
            var h = e.reflectionTexture;
            h && (this.customReflection = t.Loader.getRes(h)), this.enableFog = e.enableFog,
                this.fogStart = e.fogStart, this.fogRange = e.fogRange;
            var c = e.fogColor;
            if (c) {
                var d = this.fogColor;
                d.fromArray(c), this.fogColor = d;
            }
        }
        _onActive() {
            super._onActive(), t.ILaya.stage._scene3Ds.push(this);
        }
        _onInActive() {
            super._onInActive();
            var e = t.ILaya.stage._scene3Ds;
            e.splice(e.indexOf(this), 1);
        }
        _addLight(e) {
            this._lights.indexOf(e) < 0 && this._lights.push(e);
        }
        _removeLight(e) {
            var t = this._lights.indexOf(e);
            t >= 0 && this._lights.splice(t, 1);
        }
        _addRenderObject(e) {
            if (this._octree && e._supportOctree) this._octree.add(e);
            else if (this._renders.add(e),
                t.Render.supportWebGLPlusCulling) {
                var r = e._getIndexInList(),
                    i = this._cullingBufferIndices.length;
                if (r >= i) {
                    var n = this._cullingBufferIndices,
                        a = this._cullingBufferResult;
                    this._cullingBufferIndices = new Int32Array(i + 1024), this._cullingBufferResult = new Int32Array(i + 1024),
                        this._cullingBufferIndices.set(n, 0), this._cullingBufferResult.set(a, 0);
                }
                this._cullingBufferIndices[r] = e._cullingBufferIndex;
            }
        }
        _removeRenderObject(e) {
            var r;
            this._octree && e._supportOctree ? this._octree.remove(e) : (t.Render.supportWebGLPlusCulling && (r = this._renders.elements[this._renders.length - 1]),
                this._renders.remove(e), t.Render.supportWebGLPlusCulling && (this._cullingBufferIndices[r._getIndexInList()] = r._cullingBufferIndex));
        }
        _addShadowCastRenderObject(e) {
            this._octree || this._castShadowRenders.add(e);
        }
        _removeShadowCastRenderObject(e) {
            this._octree || this._castShadowRenders.remove(e);
        }
        _getRenderQueue(e) {
            return e <= 2500 ? this._opaqueQueue : this._transparentQueue;
        }
        setlightmaps(e) {
            for (var t = this._lightmaps, r = 0, i = t.length; r < i; r++) t[r]._removeReference();
            if (!e) throw new Error("Scene3D: value value can't be null.");
            var n = e.length;
            for (t.length = n, r = 0; r < n; r++) {
                var a = e[r];
                a._addReference(), t[r] = a;
            }
            for (r = 0, i = this._children.length; r < i; r++) this._setLightmapToChildNode(this._children[r]);
        }
        getlightmaps() {
            return this._lightmaps.slice();
        }
        destroy(e = !0) {
            this.destroyed || (super.destroy(e), this._skyRenderer.destroy(), this._skyRenderer = null,
                this._lights = null, this._lightmaps = null, this._renderTargetTexture = null, this._shaderValues = null,
                this._renders = null, this._castShadowRenders = null, this._cameraPool = null, this._octree = null,
                this.parallelSplitShadowMaps = null, this._physicsSimulation && this._physicsSimulation._destroy(),
                t.Loader.clearRes(this.url));
        }
        render(e, r, i) {
            e._curSubmit = t.SubmitBase.RENDERBASE, this._children.length > 0 && e.addRenderObject(this);
        }
        renderSubmit() {
            var e, r, i;
            t.LayaGL.instance;
            for (this._prepareSceneToRender(), e = 0, i = (r = this._cameraPool.length) - 1; e < r; e++) {
                t.Render.supportWebGLPlusRendering && p.setRuntimeValueMode(e == i);
                var n = this._cameraPool[e];
                n.enableRender && n.render();
            }
            return t.Context.set2DRenderConfig(), 1;
        }
        getRenderType() {
            return 0;
        }
        releaseRender() {}
        reUse(e, t) {
            return 0;
        }
    }
    oi.HIERARCHY = "HIERARCHY", oi.physicsSettings = new Nt(), oi.octreeCulling = !1,
        oi.octreeInitialSize = 64, oi.octreeInitialCenter = new a(0, 0, 0), oi.octreeMinNodeSize = 2,
        oi.octreeLooseness = 1.25, oi.REFLECTIONMODE_SKYBOX = 0, oi.REFLECTIONMODE_CUSTOM = 1,
        oi.FOGCOLOR = L.propertyNameToID("u_FogColor"), oi.FOGSTART = L.propertyNameToID("u_FogStart"),
        oi.FOGRANGE = L.propertyNameToID("u_FogRange"), oi.LIGHTDIRECTION = L.propertyNameToID("u_DirectionLight.Direction"),
        oi.LIGHTDIRCOLOR = L.propertyNameToID("u_DirectionLight.Color"), oi.POINTLIGHTPOS = L.propertyNameToID("u_PointLight.Position"),
        oi.POINTLIGHTRANGE = L.propertyNameToID("u_PointLight.Range"), oi.POINTLIGHTATTENUATION = L.propertyNameToID("u_PointLight.Attenuation"),
        oi.POINTLIGHTCOLOR = L.propertyNameToID("u_PointLight.Color"), oi.SPOTLIGHTPOS = L.propertyNameToID("u_SpotLight.Position"),
        oi.SPOTLIGHTDIRECTION = L.propertyNameToID("u_SpotLight.Direction"), oi.SPOTLIGHTSPOTANGLE = L.propertyNameToID("u_SpotLight.Spot"),
        oi.SPOTLIGHTRANGE = L.propertyNameToID("u_SpotLight.Range"), oi.SPOTLIGHTCOLOR = L.propertyNameToID("u_SpotLight.Color"),
        oi.SHADOWDISTANCE = L.propertyNameToID("u_shadowPSSMDistance"), oi.SHADOWLIGHTVIEWPROJECT = L.propertyNameToID("u_lightShadowVP"),
        oi.SHADOWMAPPCFOFFSET = L.propertyNameToID("u_shadowPCFoffset"), oi.SHADOWMAPTEXTURE1 = L.propertyNameToID("u_shadowMap1"),
        oi.SHADOWMAPTEXTURE2 = L.propertyNameToID("u_shadowMap2"), oi.SHADOWMAPTEXTURE3 = L.propertyNameToID("u_shadowMap3"),
        oi.AMBIENTCOLOR = L.propertyNameToID("u_AmbientColor"), oi.REFLECTIONTEXTURE = L.propertyNameToID("u_ReflectTexture"),
        oi.REFLETIONINTENSITY = L.propertyNameToID("u_ReflectIntensity"), oi.TIME = L.propertyNameToID("u_Time"),
        oi.ANGLEATTENUATIONTEXTURE = L.propertyNameToID("u_AngleTexture"), oi.RANGEATTENUATIONTEXTURE = L.propertyNameToID("u_RangeTexture"),
        oi.POINTLIGHTMATRIX = L.propertyNameToID("u_PointLightMatrix"), oi.SPOTLIGHTMATRIX = L.propertyNameToID("u_SpotLightMatrix");
    class li {
        static _createSprite3DInstance(e, t, r) {
            var i;
            switch (e.type) {
                case "Scene3D":
                    i = new oi();
                    break;

                case "Sprite3D":
                    i = new b();
                    break;

                case "MeshSprite3D":
                    i = new Ye(), r && r.push(i);
                    break;

                case "SkinnedMeshSprite3D":
                    i = new Yt();
                    break;

                case "ShuriKenParticle3D":
                    i = new xt();
                    break;

                case "Camera":
                    i = new oe();
                    break;

                case "DirectionLight":
                    i = new we();
                    break;

                case "PointLight":
                    i = new be();
                    break;

                case "SpotLight":
                    i = new Fe();
                    break;

                case "TrailSprite3D":
                    i = new rr();
                    break;

                default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var n = e.child;
            if (n)
                for (var a = 0, s = n.length; a < s; a++) {
                    var o = li._createSprite3DInstance(n[a], t, r);
                    i.addChild(o);
                }
            return t[e.instanceID] = i, i;
        }
        static _createComponentInstance(e, r) {
            var i = r[e.instanceID];
            i._parse(e.props, r);
            var n = e.child;
            if (n)
                for (var a = 0, s = n.length; a < s; a++) li._createComponentInstance(n[a], r);
            var o = e.components;
            if (o)
                for (var l = 0, _ = o.length; l < _; l++) {
                    var h = o[l],
                        c = t.ClassUtils.getRegClass(h.type);
                    if (c) i.addComponent(c)._parse(h);
                    else console.warn("Unkown component type.");
                }
        }
        static _createNodeByJson02(e, t) {
            var r = {},
                i = li._createSprite3DInstance(e, r, t);
            return li._createComponentInstance(e, r), i;
        }
        static _parse(e, t = null, r = null) {
            var i, n = e.data,
                a = [];
            switch (e.version) {
                case "LAYAHIERARCHY:02":
                    i = li._createNodeByJson02(n, a);
                    break;

                default:
                    i = li._createNodeByJson(n, a);
            }
            return B.combine(i, a), i;
        }
        static _parseScene(e, t = null, r = null) {
            var i, n = e.data,
                a = [];
            switch (e.version) {
                case "LAYASCENE3D:02":
                    i = li._createNodeByJson02(n, a);
                    break;

                default:
                    i = li._createNodeByJson(n, a);
            }
            return B.combine(null, a), i;
        }
        static _createNodeByJson(e, r) {
            var i;
            switch (e.type) {
                case "Scene3D":
                    i = new oi();
                    break;

                case "Sprite3D":
                    i = new b();
                    break;

                case "MeshSprite3D":
                    i = new Ye(), r && r.push(i);
                    break;

                case "SkinnedMeshSprite3D":
                    i = new Yt();
                    break;

                case "ShuriKenParticle3D":
                    i = new xt();
                    break;

                case "Camera":
                    i = new oe();
                    break;

                case "DirectionLight":
                    i = new we();
                    break;

                case "PointLight":
                    i = new be();
                    break;

                case "SpotLight":
                    i = new Fe();
                    break;

                case "TrailSprite3D":
                    i = new rr();
                    break;

                default:
                    throw new Error("Utils3D:unidentified class type in (.lh) file.");
            }
            var n = e.child;
            if (n)
                for (var a = 0, s = n.length; a < s; a++) {
                    var o = li._createNodeByJson(n[a], r);
                    i.addChild(o);
                }
            var l = e.components;
            if (l)
                for (var _ = 0, h = l.length; _ < h; _++) {
                    var c = l[_],
                        d = t.ClassUtils.getRegClass(c.type);
                    if (d) i.addComponent(d)._parse(c);
                    else console.warn("Unkown component type.");
                }
            return i._parse(e.props, null), i;
        }
    }
    class _i {
        constructor() {
            this._ownerPath = [], this._propertys = [], this._keyFrames = [];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(e) {
            this._ownerPath.length = e;
        }
        _setOwnerPathByIndex(e, t) {
            this._ownerPath[e] = t;
        }
        _joinOwnerPath(e) {
            return this._ownerPath.join(e);
        }
        _setPropertyCount(e) {
            this._propertys.length = e;
        }
        _setPropertyByIndex(e, t) {
            this._propertys[e] = t;
        }
        _joinProperty(e) {
            return this._propertys.join(e);
        }
        _setKeyframeCount(e) {
            this._keyFrames.length = e;
        }
        _setKeyframeByIndex(e, t) {
            this._keyFrames[e] = t;
        }
        getOwnerPathByIndex(e) {
            return this._ownerPath[e];
        }
        getPropertyByIndex(e) {
            return this._propertys[e];
        }
        getKeyframeByIndex(e) {
            return this._keyFrames[e];
        }
    }
    window.conch && window.conchKeyframeNode && (_i = window.conchKeyframeNode);
    class hi {
        constructor() {}
    }
    class ci extends jt {
        constructor() {
            super(), this.inTangent = new n(), this.outTangent = new n(), this.value = new E();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
        }
    }
    window.conch && window.conchFloatArrayKeyframe && (ci = window.conchFloatArrayKeyframe);
    class di extends jt {
        constructor() {
            super(), this.inTangent = new a(), this.outTangent = new a(), this.value = new a();
        }
        cloneTo(e) {
            super.cloneTo(e);
            var t = e;
            this.inTangent.cloneTo(t.inTangent), this.outTangent.cloneTo(t.outTangent), this.value.cloneTo(t.value);
        }
    }
    window.conch && window.conchFloatArrayKeyframe && (di = window.conchFloatArrayKeyframe);
    class ui {
        constructor(e = 0, t = 0, r = 0, i = 0) {
            var n = this.elements = new Float32Array(4);
            n[0] = e, n[1] = t, n[2] = r, n[3] = i;
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        get w() {
            return this.elements[3];
        }
        set w(e) {
            this.elements[3] = e;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                this.elements[3] = e[t + 3];
        }
        cloneTo(e) {
            var t = e.elements,
                r = this.elements;
            t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3];
        }
        clone() {
            var e = new ui();
            return this.cloneTo(e), e;
        }
        static lerp(e, t, r, i) {
            var n = i.elements,
                a = e.elements,
                s = t.elements,
                o = a[0],
                l = a[1],
                _ = a[2],
                h = a[3];
            n[0] = o + r * (s[0] - o), n[1] = l + r * (s[1] - l), n[2] = _ + r * (s[2] - _),
                n[3] = h + r * (s[3] - h);
        }
        static transformByM4x4(e, t, r) {
            var i = e.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = t.elements,
                _ = r.elements;
            _[0] = n * l[0] + a * l[4] + s * l[8] + o * l[12], _[1] = n * l[1] + a * l[5] + s * l[9] + o * l[13],
                _[2] = n * l[2] + a * l[6] + s * l[10] + o * l[14], _[3] = n * l[3] + a * l[7] + s * l[11] + o * l[15];
        }
        static equals(e, t) {
            var i = e.elements,
                n = t.elements;
            return r.nearEqual(Math.abs(i[0]), Math.abs(n[0])) && r.nearEqual(Math.abs(i[1]), Math.abs(n[1])) && r.nearEqual(Math.abs(i[2]), Math.abs(n[2])) && r.nearEqual(Math.abs(i[3]), Math.abs(n[3]));
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(e, t) {
            var r = e.elements,
                i = t.elements,
                n = e.length();
            n > 0 && (i[0] = r[0] * n, i[1] = r[1] * n, i[2] = r[2] * n, i[3] = r[3] * n);
        }
        static add(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] + a[0], i[1] = n[1] + a[1], i[2] = n[2] + a[2], i[3] = n[3] + a[3];
        }
        static subtract(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] - a[0], i[1] = n[1] - a[1], i[2] = n[2] - a[2], i[3] = n[3] - a[3];
        }
        static multiply(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] * a[0], i[1] = n[1] * a[1], i[2] = n[2] * a[2], i[3] = n[3] * a[3];
        }
        static scale(e, t, r) {
            var i = r.elements,
                n = e.elements;
            i[0] = n[0] * t, i[1] = n[1] * t, i[2] = n[2] * t, i[3] = n[3] * t;
        }
        static Clamp(e, t, r, i) {
            var n = e.elements,
                a = n[0],
                s = n[1],
                o = n[2],
                l = n[3],
                _ = t.elements,
                h = _[0],
                c = _[1],
                d = _[2],
                u = _[3],
                f = r.elements,
                E = f[0],
                T = f[1],
                m = f[2],
                p = f[3],
                g = i.elements;
            a = (a = a > E ? E : a) < h ? h : a, s = (s = s > T ? T : s) < c ? c : s, o = (o = o > m ? m : o) < d ? d : o,
                l = (l = l > p ? p : l) < u ? u : l, g[0] = a, g[1] = s, g[2] = o, g[3] = l;
        }
        static distanceSquared(e, t) {
            var r = e.elements,
                i = t.elements,
                n = r[0] - i[0],
                a = r[1] - i[1],
                s = r[2] - i[2],
                o = r[3] - i[3];
            return n * n + a * a + s * s + o * o;
        }
        static distance(e, t) {
            var r = e.elements,
                i = t.elements,
                n = r[0] - i[0],
                a = r[1] - i[1],
                s = r[2] - i[2],
                o = r[3] - i[3];
            return Math.sqrt(n * n + a * a + s * s + o * o);
        }
        static dot(e, t) {
            var r = e.elements,
                i = t.elements;
            return r[0] * i[0] + r[1] * i[1] + r[2] * i[2] + r[3] * i[3];
        }
        static min(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = Math.min(n[0], a[0]), i[1] = Math.min(n[1], a[1]), i[2] = Math.min(n[2], a[2]),
                i[3] = Math.min(n[3], a[3]);
        }
        static max(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = Math.max(n[0], a[0]), i[1] = Math.max(n[1], a[1]), i[2] = Math.max(n[2], a[2]),
                i[3] = Math.max(n[3], a[3]);
        }
    }
    ui.ZERO = new ui(), ui.ONE = new ui(1, 1, 1, 1), ui.UnitX = new ui(1, 0, 0, 0),
        ui.UnitY = new ui(0, 1, 0, 0), ui.UnitZ = new ui(0, 0, 1, 0), ui.UnitW = new ui(0, 0, 0, 1);
    class fi {
        constructor(e = 0, t = 0, r = 0, i = null) {
            var n;
            n = i || new Float32Array(3), this.elements = n, n[0] = e, n[1] = t, n[2] = r;
        }
        static distanceSquared(e, t) {
            var r = e.elements,
                i = t.elements,
                n = r[0] - i[0],
                a = r[1] - i[1],
                s = r[2] - i[2];
            return n * n + a * a + s * s;
        }
        static distance(e, t) {
            var r = e.elements,
                i = t.elements,
                n = r[0] - i[0],
                a = r[1] - i[1],
                s = r[2] - i[2];
            return Math.sqrt(n * n + a * a + s * s);
        }
        static min(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = Math.min(n[0], a[0]), i[1] = Math.min(n[1], a[1]), i[2] = Math.min(n[2], a[2]);
        }
        static max(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = Math.max(n[0], a[0]), i[1] = Math.max(n[1], a[1]), i[2] = Math.max(n[2], a[2]);
        }
        static transformQuat(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements,
                s = n[0],
                o = n[1],
                l = n[2],
                _ = a[0],
                h = a[1],
                c = a[2],
                d = a[3],
                u = d * s + h * l - c * o,
                f = d * o + c * s - _ * l,
                E = d * l + _ * o - h * s,
                T = -_ * s - h * o - c * l;
            i[0] = u * d + T * -_ + f * -c - E * -h, i[1] = f * d + T * -h + E * -_ - u * -c,
                i[2] = E * d + T * -c + u * -h - f * -_;
        }
        static scalarLength(e) {
            var t = e.elements,
                r = t[0],
                i = t[1],
                n = t[2];
            return Math.sqrt(r * r + i * i + n * n);
        }
        static scalarLengthSquared(e) {
            var t = e.elements,
                r = t[0],
                i = t[1],
                n = t[2];
            return r * r + i * i + n * n;
        }
        static normalize(e, t) {
            var r = e.elements,
                i = t.elements,
                n = r[0],
                a = r[1],
                s = r[2],
                o = n * n + a * a + s * s;
            o > 0 && (o = 1 / Math.sqrt(o), i[0] = r[0] * o, i[1] = r[1] * o, i[2] = r[2] * o);
        }
        static multiply(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] * a[0], i[1] = n[1] * a[1], i[2] = n[2] * a[2];
        }
        static scale(e, t, r) {
            var i = r.elements,
                n = e.elements;
            i[0] = n[0] * t, i[1] = n[1] * t, i[2] = n[2] * t;
        }
        static lerp(e, t, r, i) {
            var n = i.elements,
                a = e.elements,
                s = t.elements,
                o = a[0],
                l = a[1],
                _ = a[2];
            n[0] = o + r * (s[0] - o), n[1] = l + r * (s[1] - l), n[2] = _ + r * (s[2] - _);
        }
        static transformV3ToV3(e, t, r) {
            var i = fi._tempVector4;
            fi.transformV3ToV4(e, t, i);
            var n = i.elements,
                a = r.elements;
            a[0] = n[0], a[1] = n[1], a[2] = n[2];
        }
        static transformV3ToV4(e, t, r) {
            var i = e.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = t.elements,
                l = r.elements;
            l[0] = n * o[0] + a * o[4] + s * o[8] + o[12], l[1] = n * o[1] + a * o[5] + s * o[9] + o[13],
                l[2] = n * o[2] + a * o[6] + s * o[10] + o[14], l[3] = n * o[3] + a * o[7] + s * o[11] + o[15];
        }
        static TransformNormal(e, t, r) {
            var i = e.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = t.elements,
                l = r.elements;
            l[0] = n * o[0] + a * o[4] + s * o[8], l[1] = n * o[1] + a * o[5] + s * o[9], l[2] = n * o[2] + a * o[6] + s * o[10];
        }
        static transformCoordinate(e, t, r) {
            var i = e.elements,
                n = i[0],
                a = i[1],
                s = i[2],
                o = t.elements,
                l = n * o[3] + a * o[7] + s * o[11] + o[15],
                _ = r.elements;
            _[0] = n * o[0] + a * o[4] + s * o[8] + o[12] / l, _[1] = n * o[1] + a * o[5] + s * o[9] + o[13] / l,
                _[2] = n * o[2] + a * o[6] + s * o[10] + o[14] / l;
        }
        static Clamp(e, t, r, i) {
            var n = e.elements,
                a = n[0],
                s = n[1],
                o = n[2],
                l = t.elements,
                _ = l[0],
                h = l[1],
                c = l[2],
                d = r.elements,
                u = d[0],
                f = d[1],
                E = d[2],
                T = i.elements;
            a = (a = a > u ? u : a) < _ ? _ : a, s = (s = s > f ? f : s) < h ? h : s, o = (o = o > E ? E : o) < c ? c : o,
                T[0] = a, T[1] = s, T[2] = o;
        }
        static add(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] + a[0], i[1] = n[1] + a[1], i[2] = n[2] + a[2];
        }
        static subtract(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] - a[0], i[1] = n[1] - a[1], i[2] = n[2] - a[2];
        }
        static cross(e, t, r) {
            var i = e.elements,
                n = t.elements,
                a = r.elements,
                s = i[0],
                o = i[1],
                l = i[2],
                _ = n[0],
                h = n[1],
                c = n[2];
            a[0] = o * c - l * h, a[1] = l * _ - s * c, a[2] = s * h - o * _;
        }
        static dot(e, t) {
            var r = e.elements,
                i = t.elements;
            return r[0] * i[0] + r[1] * i[1] + r[2] * i[2];
        }
        static equals(e, t) {
            var i = e.elements,
                n = t.elements;
            return r.nearEqual(i[0], n[0]) && r.nearEqual(i[1], n[1]) && r.nearEqual(i[2], n[2]);
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        setValue(e, t, r) {
            this.elements[0] = e, this.elements[1] = t, this.elements[2] = r;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2];
        }
        cloneTo(e) {
            var t = e.elements,
                r = this.elements;
            t[0] = r[0], t[1] = r[1], t[2] = r[2];
        }
        clone() {
            var e = new fi();
            return this.cloneTo(e), e;
        }
        toDefault() {
            this.elements[0] = 0, this.elements[1] = 0, this.elements[2] = 0;
        }
    }
    fi._tempVector4 = new ui(), fi.ZERO = new fi(0, 0, 0), fi.ONE = new fi(1, 1, 1),
        fi.NegativeUnitX = new fi(-1, 0, 0), fi.UnitX = new fi(1, 0, 0), fi.UnitY = new fi(0, 1, 0),
        fi.UnitZ = new fi(0, 0, 1), fi.ForwardRH = new fi(0, 0, -1), fi.ForwardLH = new fi(0, 0, 1),
        fi.Up = new fi(0, 1, 0), fi.NAN = new fi(NaN, NaN, NaN);
    class Ei {
        constructor(e = 0, t = 0, r = 0, i = 1, n = null) {
            var a;
            (a = n || new Float32Array(4))[0] = e, a[1] = t, a[2] = r, a[3] = i, this.elements = a;
        }
        static _dotArray(e, t) {
            return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        }
        static _normalizeArray(e, t) {
            var r = e[0],
                i = e[1],
                n = e[2],
                a = e[3],
                s = r * r + i * i + n * n + a * a;
            s > 0 && (s = 1 / Math.sqrt(s), t[0] = r * s, t[1] = i * s, t[2] = n * s, t[3] = a * s);
        }
        static _lerpArray(e, t, r, i) {
            var n = 1 - r;
            Ei._dotArray(e, t) >= 0 ? (i[0] = n * e[0] + r * t[0], i[1] = n * e[1] + r * t[1],
                    i[2] = n * e[2] + r * t[2], i[3] = n * e[3] + r * t[3]) : (i[0] = n * e[0] - r * t[0],
                    i[1] = n * e[1] - r * t[1], i[2] = n * e[2] - r * t[2], i[3] = n * e[3] - r * t[3]),
                Ei._normalizeArray(i, i);
        }
        static createFromYawPitchRoll(e, t, r, i) {
            var n = .5 * r,
                a = .5 * t,
                s = .5 * e,
                o = Math.sin(n),
                l = Math.cos(n),
                _ = Math.sin(a),
                h = Math.cos(a),
                c = Math.sin(s),
                d = Math.cos(s),
                u = i.elements;
            u[0] = d * _ * l + c * h * o, u[1] = c * h * l - d * _ * o, u[2] = d * h * o - c * _ * l,
                u[3] = d * h * l + c * _ * o;
        }
        static multiply(e, t, r) {
            var i = e.elements,
                n = t.elements,
                a = r.elements,
                s = i[0],
                o = i[1],
                l = i[2],
                _ = i[3],
                h = n[0],
                c = n[1],
                d = n[2],
                u = n[3],
                f = o * d - l * c,
                E = l * h - s * d,
                T = s * c - o * h,
                m = s * h + o * c + l * d;
            a[0] = s * u + h * _ + f, a[1] = o * u + c * _ + E, a[2] = l * u + d * _ + T, a[3] = _ * u - m;
        }
        static arcTanAngle(e, t) {
            return 0 == e ? 1 == t ? Math.PI / 2 : -Math.PI / 2 : e > 0 ? Math.atan(t / e) : e < 0 ? t > 0 ? Math.atan(t / e) + Math.PI : Math.atan(t / e) - Math.PI : 0;
        }
        static angleTo(e, t, r) {
            fi.subtract(t, e, Ei.TEMPVector30), fi.normalize(Ei.TEMPVector30, Ei.TEMPVector30),
                r.elements[0] = Math.asin(Ei.TEMPVector30.y), r.elements[1] = Ei.arcTanAngle(-Ei.TEMPVector30.z, -Ei.TEMPVector30.x);
        }
        static createFromAxisAngle(e, t, r) {
            var i = r.elements,
                n = e.elements;
            t *= .5;
            var a = Math.sin(t);
            i[0] = a * n[0], i[1] = a * n[1], i[2] = a * n[2], i[3] = Math.cos(t);
        }
        static createFromMatrix3x3(e, t) {
            var r, i = t.elements,
                n = e.elements,
                a = n[0] + n[4] + n[8];
            if (a > 0) r = Math.sqrt(a + 1), i[3] = .5 * r, r = .5 / r, i[0] = (n[5] - n[7]) * r,
                i[1] = (n[6] - n[2]) * r, i[2] = (n[1] - n[3]) * r;
            else {
                var s = 0;
                n[4] > n[0] && (s = 1), n[8] > n[3 * s + s] && (s = 2);
                var o = (s + 1) % 3,
                    l = (s + 2) % 3;
                r = Math.sqrt(n[3 * s + s] - n[3 * o + o] - n[3 * l + l] + 1), i[s] = .5 * r, r = .5 / r,
                    i[3] = (n[3 * o + l] - n[3 * l + o]) * r, i[o] = (n[3 * o + s] + n[3 * s + o]) * r,
                    i[l] = (n[3 * l + s] + n[3 * s + l]) * r;
            }
        }
        static createFromMatrix4x4(e, t) {
            var r, i, n = e.elements,
                a = t.elements,
                s = n[0] + n[5] + n[10];
            s > 0 ? (r = Math.sqrt(s + 1), a[3] = .5 * r, r = .5 / r, a[0] = (n[6] - n[9]) * r,
                a[1] = (n[8] - n[2]) * r, a[2] = (n[1] - n[4]) * r) : n[0] >= n[5] && n[0] >= n[10] ? (i = .5 / (r = Math.sqrt(1 + n[0] - n[5] - n[10])),
                a[0] = .5 * r, a[1] = (n[1] + n[4]) * i, a[2] = (n[2] + n[8]) * i, a[3] = (n[6] - n[9]) * i) : n[5] > n[10] ? (i = .5 / (r = Math.sqrt(1 + n[5] - n[0] - n[10])),
                a[0] = (n[4] + n[1]) * i, a[1] = .5 * r, a[2] = (n[9] + n[6]) * i, a[3] = (n[8] - n[2]) * i) : (i = .5 / (r = Math.sqrt(1 + n[10] - n[0] - n[5])),
                a[0] = (n[8] + n[2]) * i, a[1] = (n[9] + n[6]) * i, a[2] = .5 * r, a[3] = (n[1] - n[4]) * i);
        }
        static slerp(e, t, r, i) {
            var n, a, s, o, l, _ = e.elements,
                h = t.elements,
                c = i.elements,
                d = _[0],
                u = _[1],
                f = _[2],
                E = _[3],
                T = h[0],
                m = h[1],
                p = h[2],
                g = h[3];
            return (a = d * T + u * m + f * p + E * g) < 0 && (a = -a, T = -T, m = -m, p = -p,
                    g = -g), 1 - a > 1e-6 ? (n = Math.acos(a), s = Math.sin(n), o = Math.sin((1 - r) * n) / s,
                    l = Math.sin(r * n) / s) : (o = 1 - r, l = r), c[0] = o * d + l * T, c[1] = o * u + l * m,
                c[2] = o * f + l * p, c[3] = o * E + l * g, c;
        }
        static lerp(e, t, r, i) {
            Ei._lerpArray(e.elements, t.elements, r, i.elements);
        }
        static add(e, t, r) {
            var i = r.elements,
                n = e.elements,
                a = t.elements;
            i[0] = n[0] + a[0], i[1] = n[1] + a[1], i[2] = n[2] + a[2], i[3] = n[3] + a[3];
        }
        static dot(e, t) {
            return Ei._dotArray(e.elements, t.elements);
        }
        get x() {
            return this.elements[0];
        }
        set x(e) {
            this.elements[0] = e;
        }
        get y() {
            return this.elements[1];
        }
        set y(e) {
            this.elements[1] = e;
        }
        get z() {
            return this.elements[2];
        }
        set z(e) {
            this.elements[2] = e;
        }
        get w() {
            return this.elements[3];
        }
        set w(e) {
            this.elements[3] = e;
        }
        scaling(e, t) {
            var r = t.elements,
                i = this.elements;
            r[0] = i[0] * e, r[1] = i[1] * e, r[2] = i[2] * e, r[3] = i[3] * e;
        }
        normalize(e) {
            Ei._normalizeArray(this.elements, e.elements);
        }
        length() {
            var e = this.elements,
                t = e[0],
                r = e[1],
                i = e[2],
                n = e[3];
            return Math.sqrt(t * t + r * r + i * i + n * n);
        }
        rotateX(e, t) {
            var r = t.elements,
                i = this.elements;
            e *= .5;
            var n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = Math.sin(e),
                _ = Math.cos(e);
            r[0] = n * _ + o * l, r[1] = a * _ + s * l, r[2] = s * _ - a * l, r[3] = o * _ - n * l;
        }
        rotateY(e, t) {
            var r = t.elements,
                i = this.elements;
            e *= .5;
            var n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = Math.sin(e),
                _ = Math.cos(e);
            r[0] = n * _ - s * l, r[1] = a * _ + o * l, r[2] = s * _ + n * l, r[3] = o * _ - a * l;
        }
        rotateZ(e, t) {
            var r = t.elements,
                i = this.elements;
            e *= .5;
            var n = i[0],
                a = i[1],
                s = i[2],
                o = i[3],
                l = Math.sin(e),
                _ = Math.cos(e);
            r[0] = n * _ + a * l, r[1] = a * _ - n * l, r[2] = s * _ + o * l, r[3] = o * _ - s * l;
        }
        getYawPitchRoll(e) {
            fi.transformQuat(fi.ForwardRH, this, Ei.TEMPVector31), fi.transformQuat(fi.Up, this, Ei.TEMPVector32);
            var t = Ei.TEMPVector32.elements;
            Ei.angleTo(fi.ZERO, Ei.TEMPVector31, Ei.TEMPVector33);
            var r = Ei.TEMPVector33.elements;
            r[0] == Math.PI / 2 ? (r[1] = Ei.arcTanAngle(t[2], t[0]), r[2] = 0) : r[0] == -Math.PI / 2 ? (r[1] = Ei.arcTanAngle(-t[2], -t[0]),
                    r[2] = 0) : (T.createRotationY(-r[1], Ei.TEMPMatrix0), T.createRotationX(-r[0], Ei.TEMPMatrix1),
                    fi.transformCoordinate(Ei.TEMPVector32, Ei.TEMPMatrix0, Ei.TEMPVector32), fi.transformCoordinate(Ei.TEMPVector32, Ei.TEMPMatrix1, Ei.TEMPVector32),
                    r[2] = Ei.arcTanAngle(t[1], -t[0])), r[1] <= -Math.PI && (r[1] = Math.PI), r[2] <= -Math.PI && (r[2] = Math.PI),
                r[1] >= Math.PI && r[2] >= Math.PI && (r[1] = 0, r[2] = 0, r[0] = Math.PI - r[0]);
            var i = e.elements;
            i[0] = r[1], i[1] = r[0], i[2] = r[2];
        }
        invert(e) {
            var t = e.elements,
                r = this.elements,
                i = r[0],
                n = r[1],
                a = r[2],
                s = r[3],
                o = i * i + n * n + a * a + s * s,
                l = o ? 1 / o : 0;
            t[0] = -i * l, t[1] = -n * l, t[2] = -a * l, t[3] = s * l;
        }
        identity() {
            var e = this.elements;
            e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1;
        }
        fromArray(e, t = 0) {
            this.elements[0] = e[t + 0], this.elements[1] = e[t + 1], this.elements[2] = e[t + 2],
                this.elements[3] = e[t + 3];
        }
        cloneTo(e) {
            var t, r, i;
            if ((r = this.elements) !== (i = e.elements))
                for (t = 0; t < 4; ++t) i[t] = r[t];
        }
        clone() {
            var e = new Ei();
            return this.cloneTo(e), e;
        }
        equals(e) {
            var t = this.elements,
                i = e.elements;
            return r.nearEqual(t[0], i[0]) && r.nearEqual(t[1], i[1]) && r.nearEqual(t[2], i[2]) && r.nearEqual(t[3], i[3]);
        }
        static rotationLookAt(e, t, r) {
            Ei.lookAt(fi.ZERO, e, t, r);
        }
        static lookAt(e, t, r, i) {
            f.lookAt(e, t, r, Ei._tempMatrix3x3), Ei.rotationMatrix(Ei._tempMatrix3x3, i);
        }
        lengthSquared() {
            var e = this.elements[0],
                t = this.elements[1],
                r = this.elements[2],
                i = this.elements[3];
            return e * e + t * t + r * r + i * i;
        }
        static invert(e, t) {
            var i = e.elements,
                n = t.elements,
                a = e.lengthSquared();
            r.isZero(a) || (a = 1 / a, n[0] = -i[0] * a, n[1] = -i[1] * a, n[2] = -i[2] * a,
                n[3] = i[3] * a);
        }
        static rotationMatrix(e, t) {
            var r, i, n = e.elements,
                a = n[0],
                s = n[1],
                o = n[2],
                l = n[3],
                _ = n[4],
                h = n[5],
                c = n[6],
                d = n[7],
                u = n[8],
                f = t.elements,
                E = a + _ + u;
            E > 0 ? (r = Math.sqrt(E + 1), f[3] = .5 * r, r = .5 / r, f[0] = (h - d) * r, f[1] = (c - o) * r,
                f[2] = (s - l) * r) : a >= _ && a >= u ? (i = .5 / (r = Math.sqrt(1 + a - _ - u)),
                f[0] = .5 * r, f[1] = (s + l) * i, f[2] = (o + c) * i, f[3] = (h - d) * i) : _ > u ? (i = .5 / (r = Math.sqrt(1 + _ - a - u)),
                f[0] = (l + s) * i, f[1] = .5 * r, f[2] = (d + h) * i, f[3] = (c - o) * i) : (i = .5 / (r = Math.sqrt(1 + u - a - _)),
                f[0] = (c + o) * i, f[1] = (d + h) * i, f[2] = .5 * r, f[3] = (s - l) * i);
        }
    }
    Ei.TEMPVector30 = new fi(), Ei.TEMPVector31 = new fi(), Ei.TEMPVector32 = new fi(),
        Ei.TEMPVector33 = new fi(), Ei.TEMPMatrix0 = new T(), Ei.TEMPMatrix1 = new T(),
        Ei._tempMatrix3x3 = new f(), Ei.DEFAULT = new Ei(), Ei.NAN = new Ei(NaN, NaN, NaN, NaN);
    class Ti {
        static READ_DATA() {
            Ti._DATA.offset = Ti._reader.getUint32(), Ti._DATA.size = Ti._reader.getUint32();
        }
        static READ_BLOCK() {
            for (var e = Ti._BLOCK.count = Ti._reader.getUint16(), t = Ti._BLOCK.blockStarts = [], r = Ti._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(Ti._reader.getUint32()),
                r.push(Ti._reader.getUint32());
        }
        static READ_STRINGS() {
            var e = Ti._reader.getUint32(),
                t = Ti._reader.getUint16(),
                r = Ti._reader.pos;
            Ti._reader.pos = e + Ti._DATA.offset;
            for (var i = 0; i < t; i++) Ti._strings[i] = Ti._reader.readUTFString();
            Ti._reader.pos = r;
        }
        static parse(e, t) {
            Ti._animationClip = e, Ti._reader = t;
            t.__getBuffer();
            Ti.READ_DATA(), Ti.READ_BLOCK(), Ti.READ_STRINGS();
            for (var r = 0, i = Ti._BLOCK.count; r < i; r++) {
                var n = t.getUint16(),
                    a = Ti._strings[n],
                    s = Ti["READ_" + a];
                if (null == s) throw new Error("model file err,no this function:" + n + " " + a);
                s.call(null);
            }
        }
        static READ_ANIMATIONS() {
            var e, r, i, n = Ti._reader,
                s = (n.__getBuffer(), []),
                o = n.getUint16();
            for (s.length = o, e = 0; e < o; e++) s[e] = n.getFloat32();
            var l = Ti._animationClip;
            l.name = Ti._strings[n.getUint16()];
            var _ = l._duration = n.getFloat32();
            l.islooping = !!n.getByte(), l._frameRate = n.getInt16();
            var h = n.getInt16(),
                c = l._nodes;
            c.count = h;
            var d = l._nodesMap = {},
                u = l._nodesDic = {};
            for (e = 0; e < h; e++) {
                i = new _i(), c.setNodeByIndex(e, i), i._indexInList = e;
                var f = i.type = n.getUint8(),
                    T = n.getUint16();
                for (i._setOwnerPathCount(T), r = 0; r < T; r++) i._setOwnerPathByIndex(r, Ti._strings[n.getUint16()]);
                var m = i._joinOwnerPath("/"),
                    p = d[m];
                p || (d[m] = p = []), p.push(i), i.propertyOwner = Ti._strings[n.getUint16()];
                var g = n.getUint16();
                for (i._setPropertyCount(g), r = 0; r < g; r++) i._setPropertyByIndex(r, Ti._strings[n.getUint16()]);
                var S = m + "." + i.propertyOwner + "." + i._joinProperty(".");
                u[S] = i, i.fullPath = S;
                var v = n.getUint16();
                switch (i._setKeyframeCount(v), f) {
                    case 0:
                        break;

                    case 1:
                    case 3:
                    case 4:
                        i.data = t.Render.supportWebGLPlusAnimation ? new fi() : new a();
                        break;

                    case 2:
                        i.data = t.Render.supportWebGLPlusAnimation ? new Ei() : new E();
                        break;

                    default:
                        throw "AnimationClipParser03:unknown type.";
                }
                for (r = 0; r < v; r++) switch (f) {
                    case 0:
                        var R = new qt();
                        i._setKeyframeByIndex(r, R), R.time = s[n.getUint16()], R.inTangent = n.getFloat32(),
                            R.outTangent = n.getFloat32(), R.value = n.getFloat32();
                        break;

                    case 1:
                    case 3:
                    case 4:
                        var A = new di();
                        if (i._setKeyframeByIndex(r, A), A.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (var D = A.data = new Float32Array(9), I = 0; I < 3; I++) D[I] = n.getFloat32();
                            for (I = 0; I < 3; I++) D[3 + I] = n.getFloat32();
                            for (I = 0; I < 3; I++) D[6 + I] = n.getFloat32();
                        } else {
                            var x = A.inTangent,
                                M = A.outTangent,
                                L = A.value;
                            x.x = n.getFloat32(), x.y = n.getFloat32(), x.z = n.getFloat32(), M.x = n.getFloat32(),
                                M.y = n.getFloat32(), M.z = n.getFloat32(), L.x = n.getFloat32(), L.y = n.getFloat32(),
                                L.z = n.getFloat32();
                        }
                        break;

                    case 2:
                        var C = new ci();
                        if (i._setKeyframeByIndex(r, C), C.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                            for (D = C.data = new Float32Array(12), I = 0; I < 4; I++) D[I] = n.getFloat32();
                            for (I = 0; I < 4; I++) D[4 + I] = n.getFloat32();
                            for (I = 0; I < 4; I++) D[8 + I] = n.getFloat32();
                        } else {
                            var y = C.inTangent,
                                O = C.outTangent,
                                N = C.value;
                            y.x = n.getFloat32(), y.y = n.getFloat32(), y.z = n.getFloat32(), y.w = n.getFloat32(),
                                O.x = n.getFloat32(), O.y = n.getFloat32(), O.z = n.getFloat32(), O.w = n.getFloat32(),
                                N.x = n.getFloat32(), N.y = n.getFloat32(), N.z = n.getFloat32(), N.w = n.getFloat32();
                        }
                        break;

                    default:
                        throw "AnimationClipParser03:unknown type.";
                }
            }
            var P = n.getUint16();
            for (e = 0; e < P; e++) {
                var V, w = new hi();
                w.time = Math.min(_, n.getFloat32()), w.eventName = Ti._strings[n.getUint16()];
                var b = n.getUint16();
                for (b > 0 && (w.params = V = []), r = 0; r < b; r++) {
                    switch (n.getByte()) {
                        case 0:
                            V.push(!!n.getByte());
                            break;

                        case 1:
                            V.push(n.getInt32());
                            break;

                        case 2:
                            V.push(n.getFloat32());
                            break;

                        case 3:
                            V.push(Ti._strings[n.getUint16()]);
                            break;

                        default:
                            throw new Error("unknown type.");
                    }
                }
                l.addEvent(w);
            }
        }
    }
    Ti._strings = [], Ti._BLOCK = {
        count: 0
    }, Ti._DATA = {
        offset: 0,
        size: 0
    };
    class mi {
        static __init__() {
            for (var e = 0; e < 256; ++e) {
                var t = e - 127;
                t < -27 ? (mi._baseTable[0 | e] = 0, mi._baseTable[256 | e] = 32768, mi._shiftTable[0 | e] = 24,
                    mi._shiftTable[256 | e] = 24) : t < -14 ? (mi._baseTable[0 | e] = 1024 >> -t - 14,
                    mi._baseTable[256 | e] = 1024 >> -t - 14 | 32768, mi._shiftTable[0 | e] = -t - 1,
                    mi._shiftTable[256 | e] = -t - 1) : t <= 15 ? (mi._baseTable[0 | e] = t + 15 << 10,
                    mi._baseTable[256 | e] = t + 15 << 10 | 32768, mi._shiftTable[0 | e] = 13, mi._shiftTable[256 | e] = 13) : t < 128 ? (mi._baseTable[0 | e] = 31744,
                    mi._baseTable[256 | e] = 64512, mi._shiftTable[0 | e] = 24, mi._shiftTable[256 | e] = 24) : (mi._baseTable[0 | e] = 31744,
                    mi._baseTable[256 | e] = 64512, mi._shiftTable[0 | e] = 13, mi._shiftTable[256 | e] = 13);
            }
            for (mi._mantissaTable[0] = 0, e = 1; e < 1024; ++e) {
                var r = e << 13;
                for (t = 0; 0 == (8388608 & r);) t -= 8388608, r <<= 1;
                r &= -8388609, t += 947912704, mi._mantissaTable[e] = r | t;
            }
            for (e = 1024; e < 2048; ++e) mi._mantissaTable[e] = 939524096 + (e - 1024 << 13);
            for (mi._exponentTable[0] = 0, e = 1; e < 31; ++e) mi._exponentTable[e] = e << 23;
            for (mi._exponentTable[31] = 1199570944, mi._exponentTable[32] = 2147483648, e = 33; e < 63; ++e) mi._exponentTable[e] = 2147483648 + (e - 32 << 23);
            for (mi._exponentTable[63] = 3347054592, mi._offsetTable[0] = 0, e = 1; e < 64; ++e) mi._offsetTable[e] = 32 === e ? 0 : 1024;
        }
        static roundToFloat16Bits(e) {
            mi._floatView[0] = e;
            var t = mi._uint32View[0],
                r = t >> 23 & 511;
            return mi._baseTable[r] + ((8388607 & t) >> mi._shiftTable[r]);
        }
        static convertToNumber(e) {
            var t = e >> 10;
            return mi._uint32View[0] = mi._mantissaTable[mi._offsetTable[t] + (1023 & e)] + mi._exponentTable[t],
                mi._floatView[0];
        }
    }
    mi._buffer = new ArrayBuffer(4), mi._floatView = new Float32Array(mi._buffer), mi._uint32View = new Uint32Array(mi._buffer),
        mi._baseTable = new Uint32Array(512), mi._shiftTable = new Uint32Array(512), mi._mantissaTable = new Uint32Array(2048),
        mi._exponentTable = new Uint32Array(64), mi._offsetTable = new Uint32Array(64);
    class pi {
        static READ_DATA() {
            pi._DATA.offset = pi._reader.getUint32(), pi._DATA.size = pi._reader.getUint32();
        }
        static READ_BLOCK() {
            for (var e = pi._BLOCK.count = pi._reader.getUint16(), t = pi._BLOCK.blockStarts = [], r = pi._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(pi._reader.getUint32()),
                r.push(pi._reader.getUint32());
        }
        static READ_STRINGS() {
            var e = pi._reader.getUint32(),
                t = pi._reader.getUint16(),
                r = pi._reader.pos;
            pi._reader.pos = e + pi._DATA.offset;
            for (var i = 0; i < t; i++) pi._strings[i] = pi._reader.readUTFString();
            pi._reader.pos = r;
        }
        static parse(e, t, r) {
            pi._animationClip = e, pi._reader = t, pi._version = r, pi.READ_DATA(), pi.READ_BLOCK(),
                pi.READ_STRINGS();
            for (var i = 0, n = pi._BLOCK.count; i < n; i++) {
                var a = t.getUint16(),
                    s = pi._strings[a],
                    o = pi["READ_" + s];
                if (null == o) throw new Error("model file err,no this function:" + a + " " + s);
                o.call(null);
            }
            pi._version = null, pi._reader = null, pi._animationClip = null;
        }
        static READ_ANIMATIONS() {
            var e, r, i, n = pi._reader,
                s = (n.__getBuffer(), []),
                o = n.getUint16();
            for (s.length = o, e = 0; e < o; e++) s[e] = n.getFloat32();
            var l = pi._animationClip;
            l.name = pi._strings[n.getUint16()];
            var _ = l._duration = n.getFloat32();
            l.islooping = !!n.getByte(), l._frameRate = n.getInt16();
            var h = n.getInt16(),
                c = l._nodes;
            c.count = h;
            var d = l._nodesMap = {},
                u = l._nodesDic = {};
            for (e = 0; e < h; e++) {
                i = new _i(), c.setNodeByIndex(e, i), i._indexInList = e;
                var f = i.type = n.getUint8(),
                    T = n.getUint16();
                for (i._setOwnerPathCount(T), r = 0; r < T; r++) i._setOwnerPathByIndex(r, pi._strings[n.getUint16()]);
                var m = i._joinOwnerPath("/"),
                    p = d[m];
                p || (d[m] = p = []), p.push(i), i.propertyOwner = pi._strings[n.getUint16()];
                var g = n.getUint16();
                for (i._setPropertyCount(g), r = 0; r < g; r++) i._setPropertyByIndex(r, pi._strings[n.getUint16()]);
                var S = m + "." + i.propertyOwner + "." + i._joinProperty(".");
                u[S] = i, i.fullPath = S;
                var v = n.getUint16();
                switch (i._setKeyframeCount(v), f) {
                    case 0:
                        break;

                    case 1:
                    case 3:
                    case 4:
                        i.data = t.Render.supportWebGLPlusAnimation ? new fi() : new a();
                        break;

                    case 2:
                        i.data = t.Render.supportWebGLPlusAnimation ? new Ei() : new E();
                        break;

                    default:
                        throw "AnimationClipParser04:unknown type.";
                }
                switch (pi._version) {
                    case "LAYAANIMATION:04":
                        for (r = 0; r < v; r++) switch (f) {
                            case 0:
                                var R = new qt();
                                i._setKeyframeByIndex(r, R), R.time = s[n.getUint16()], R.inTangent = n.getFloat32(),
                                    R.outTangent = n.getFloat32(), R.value = n.getFloat32();
                                break;

                            case 1:
                            case 3:
                            case 4:
                                var A = new di();
                                if (i._setKeyframeByIndex(r, A), A.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (var D = A.data = new Float32Array(9), I = 0; I < 3; I++) D[I] = n.getFloat32();
                                    for (I = 0; I < 3; I++) D[3 + I] = n.getFloat32();
                                    for (I = 0; I < 3; I++) D[6 + I] = n.getFloat32();
                                } else {
                                    var x = A.inTangent,
                                        M = A.outTangent,
                                        L = A.value;
                                    x.x = n.getFloat32(), x.y = n.getFloat32(), x.z = n.getFloat32(), M.x = n.getFloat32(),
                                        M.y = n.getFloat32(), M.z = n.getFloat32(), L.x = n.getFloat32(), L.y = n.getFloat32(),
                                        L.z = n.getFloat32();
                                }
                                break;

                            case 2:
                                var C = new ci();
                                if (i._setKeyframeByIndex(r, C), C.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (D = C.data = new Float32Array(12), I = 0; I < 4; I++) D[I] = n.getFloat32();
                                    for (I = 0; I < 4; I++) D[4 + I] = n.getFloat32();
                                    for (I = 0; I < 4; I++) D[8 + I] = n.getFloat32();
                                } else {
                                    var y = C.inTangent,
                                        O = C.outTangent,
                                        N = C.value;
                                    y.x = n.getFloat32(), y.y = n.getFloat32(), y.z = n.getFloat32(), y.w = n.getFloat32(),
                                        O.x = n.getFloat32(), O.y = n.getFloat32(), O.z = n.getFloat32(), O.w = n.getFloat32(),
                                        N.x = n.getFloat32(), N.y = n.getFloat32(), N.z = n.getFloat32(), N.w = n.getFloat32();
                                }
                                break;

                            default:
                                throw "AnimationClipParser04:unknown type.";
                        }
                        break;

                    case "LAYAANIMATION:COMPRESSION_04":
                        for (r = 0; r < v; r++) switch (f) {
                            case 0:
                                R = new qt(), i._setKeyframeByIndex(r, R), R.time = s[n.getUint16()], R.inTangent = mi.convertToNumber(n.getUint16()),
                                    R.outTangent = mi.convertToNumber(n.getUint16()), R.value = mi.convertToNumber(n.getUint16());
                                break;

                            case 1:
                            case 3:
                            case 4:
                                if (A = new di(), i._setKeyframeByIndex(r, A), A.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (D = A.data = new Float32Array(9), I = 0; I < 3; I++) D[I] = mi.convertToNumber(n.getUint16());
                                    for (I = 0; I < 3; I++) D[3 + I] = mi.convertToNumber(n.getUint16());
                                    for (I = 0; I < 3; I++) D[6 + I] = mi.convertToNumber(n.getUint16());
                                } else x = A.inTangent, M = A.outTangent, L = A.value, x.x = mi.convertToNumber(n.getUint16()),
                                    x.y = mi.convertToNumber(n.getUint16()), x.z = mi.convertToNumber(n.getUint16()),
                                    M.x = mi.convertToNumber(n.getUint16()), M.y = mi.convertToNumber(n.getUint16()),
                                    M.z = mi.convertToNumber(n.getUint16()), L.x = mi.convertToNumber(n.getUint16()),
                                    L.y = mi.convertToNumber(n.getUint16()), L.z = mi.convertToNumber(n.getUint16());
                                break;

                            case 2:
                                if (C = new ci(), i._setKeyframeByIndex(r, C), C.time = s[n.getUint16()], t.Render.supportWebGLPlusAnimation) {
                                    for (D = C.data = new Float32Array(12), I = 0; I < 4; I++) D[I] = mi.convertToNumber(n.getUint16());
                                    for (I = 0; I < 4; I++) D[4 + I] = mi.convertToNumber(n.getUint16());
                                    for (I = 0; I < 4; I++) D[8 + I] = mi.convertToNumber(n.getUint16());
                                } else y = C.inTangent, O = C.outTangent, N = C.value, y.x = mi.convertToNumber(n.getUint16()),
                                    y.y = mi.convertToNumber(n.getUint16()), y.z = mi.convertToNumber(n.getUint16()),
                                    y.w = mi.convertToNumber(n.getUint16()), O.x = mi.convertToNumber(n.getUint16()),
                                    O.y = mi.convertToNumber(n.getUint16()), O.z = mi.convertToNumber(n.getUint16()),
                                    O.w = mi.convertToNumber(n.getUint16()), N.x = mi.convertToNumber(n.getUint16()),
                                    N.y = mi.convertToNumber(n.getUint16()), N.z = mi.convertToNumber(n.getUint16()),
                                    N.w = mi.convertToNumber(n.getUint16());
                                break;

                            default:
                                throw "AnimationClipParser04:unknown type.";
                        }
                }
            }
            var P = n.getUint16();
            for (e = 0; e < P; e++) {
                var V, w = new hi();
                w.time = Math.min(_, n.getFloat32()), w.eventName = pi._strings[n.getUint16()];
                var b = n.getUint16();
                for (b > 0 && (w.params = V = []), r = 0; r < b; r++) {
                    switch (n.getByte()) {
                        case 0:
                            V.push(!!n.getByte());
                            break;

                        case 1:
                            V.push(n.getInt32());
                            break;

                        case 2:
                            V.push(n.getFloat32());
                            break;

                        case 3:
                            V.push(pi._strings[n.getUint16()]);
                            break;

                        default:
                            throw new Error("unknown type.");
                    }
                }
                l.addEvent(w);
            }
        }
    }
    pi._strings = [], pi._BLOCK = {
        count: 0
    }, pi._DATA = {
        offset: 0,
        size: 0
    };
    class gi {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(e) {
            this._nodes.length = e;
        }
        getNodeByIndex(e) {
            return this._nodes[e];
        }
        setNodeByIndex(e, t) {
            this._nodes[e] = t;
        }
    }
    window.conch && window.conchKeyframeNodeList && (gi = window.conchKeyframeNodeList);
    class Si extends t.Resource {
        constructor() {
            super(), this._nodes = new gi(), this._animationEvents = [];
        }
        static _parse(e, r = null, i = null) {
            var n = new Si(),
                a = new t.Byte(e),
                s = a.readUTFString();
            switch (s) {
                case "LAYAANIMATION:03":
                    Ti.parse(n, a);
                    break;

                case "LAYAANIMATION:04":
                case "LAYAANIMATION:COMPRESSION_04":
                    pi.parse(n, a, s);
                    break;

                default:
                    throw "unknown animationClip version.";
            }
            return n;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, Si.ANIMATIONCLIP);
        }
        duration() {
            return this._duration;
        }
        _hermiteInterpolate(e, t, r, i) {
            var n = e.outTangent,
                a = t.inTangent;
            if (Number.isFinite(n) && Number.isFinite(a)) {
                var s = r * r,
                    o = s * r,
                    l = o - 2 * s + r,
                    _ = o - s,
                    h = -2 * o + 3 * s;
                return (2 * o - 3 * s + 1) * e.value + l * n * i + _ * a * i + h * t.value;
            }
            return e.value;
        }
        _hermiteInterpolateVector3(e, t, r, i, n) {
            var a = e.value,
                s = e.outTangent,
                o = t.value,
                l = t.inTangent,
                _ = r * r,
                h = _ * r,
                c = 2 * h - 3 * _ + 1,
                d = h - 2 * _ + r,
                u = h - _,
                f = -2 * h + 3 * _,
                E = s.x,
                T = l.x;
            Number.isFinite(E) && Number.isFinite(T) ? n.x = c * a.x + d * E * i + u * T * i + f * o.x : n.x = a.x,
                E = s.y, T = l.y, Number.isFinite(E) && Number.isFinite(T) ? n.y = c * a.y + d * E * i + u * T * i + f * o.y : n.y = a.y,
                E = s.z, T = l.z, Number.isFinite(E) && Number.isFinite(T) ? n.z = c * a.z + d * E * i + u * T * i + f * o.z : n.z = a.z;
        }
        _hermiteInterpolateQuaternion(e, t, r, i, n) {
            var a = e.value,
                s = e.outTangent,
                o = t.value,
                l = t.inTangent,
                _ = r * r,
                h = _ * r,
                c = 2 * h - 3 * _ + 1,
                d = h - 2 * _ + r,
                u = h - _,
                f = -2 * h + 3 * _,
                E = s.x,
                T = l.x;
            Number.isFinite(E) && Number.isFinite(T) ? n.x = c * a.x + d * E * i + u * T * i + f * o.x : n.x = a.x,
                E = s.y, T = l.y, Number.isFinite(E) && Number.isFinite(T) ? n.y = c * a.y + d * E * i + u * T * i + f * o.y : n.y = a.y,
                E = s.z, T = l.z, Number.isFinite(E) && Number.isFinite(T) ? n.z = c * a.z + d * E * i + u * T * i + f * o.z : n.z = a.z,
                E = s.w, T = l.w, Number.isFinite(E) && Number.isFinite(T) ? n.w = c * a.w + d * E * i + u * T * i + f * o.w : n.w = a.w;
        }
        _evaluateClipDatasRealTime(e, t, r, i, n) {
            for (var a = 0, s = e.count; a < s; a++) {
                var o, l = e.getNodeByIndex(a),
                    _ = l.type,
                    h = l._keyFrames,
                    c = h.length,
                    d = r[a];
                if (n)
                    for (-1 !== d && t < h[d].time && (d = -1, r[a] = d), o = d + 1; o < c && !(h[o].time > t);) d++,
                        o++, r[a] = d;
                else
                    for ((o = d + 1) !== c && t > h[o].time && (d = c - 1, r[a] = d),
                        o = d + 1; d > -1 && !(h[d].time < t);) d--, o--, r[a] = d;
                var u = o === c;
                switch (_) {
                    case 0:
                        if (-1 !== d) {
                            var f = h[d];
                            if (u) l.data = f.value;
                            else {
                                var T, m = h[o],
                                    p = m.time - f.time;
                                T = 0 !== p ? (t - f.time) / p : 0, l.data = this._hermiteInterpolate(f, m, T, p);
                            }
                        } else l.data = h[0].value;
                        i && (l.data -= h[0].value);
                        break;

                    case 1:
                    case 4:
                        var g = l.data;
                        if (this._evaluateFrameNodeVector3DatasRealTime(h, d, u, t, g), i) {
                            var S = h[0].value;
                            g.x -= S.x, g.y -= S.y, g.z -= S.z;
                        }
                        break;

                    case 2:
                        var v = l.data;
                        if (this._evaluateFrameNodeQuaternionDatasRealTime(h, d, u, t, v), i) {
                            var R = Si._tempQuaternion0,
                                A = h[0].value;
                            M.quaternionConjugate(A, R), E.multiply(R, v, v);
                        }
                        break;

                    case 3:
                        g = l.data, this._evaluateFrameNodeVector3DatasRealTime(h, d, u, t, g), i && (S = h[0].value,
                            g.x /= S.x, g.y /= S.y, g.z /= S.z);
                        break;

                    default:
                        throw "AnimationClip:unknown node type.";
                }
            }
        }
        _evaluateClipDatasRealTimeForNative(e, r, i, n) {
            t.LayaGL.instance.evaluateClipDatasRealTime(e._nativeObj, r, i, n);
        }
        _evaluateFrameNodeVector3DatasRealTime(e, t, r, i, n) {
            if (-1 !== t) {
                var a = e[t];
                if (r) {
                    var s = a.value;
                    n.x = s.x, n.y = s.y, n.z = s.z;
                } else {
                    var o, l = e[t + 1],
                        _ = a.time,
                        h = l.time - _;
                    o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateVector3(a, l, o, h, n);
                }
            } else {
                var c = e[0].value;
                n.x = c.x, n.y = c.y, n.z = c.z;
            }
        }
        _evaluateFrameNodeQuaternionDatasRealTime(e, t, r, i, n) {
            if (-1 !== t) {
                var a = e[t];
                if (r) {
                    var s = a.value;
                    n.x = s.x, n.y = s.y, n.z = s.z, n.w = s.w;
                } else {
                    var o, l = e[t + 1],
                        _ = a.time,
                        h = l.time - _;
                    o = 0 !== h ? (i - _) / h : 0, this._hermiteInterpolateQuaternion(a, l, o, h, n);
                }
            } else {
                var c = e[0].value;
                n.x = c.x, n.y = c.y, n.z = c.z, n.w = c.w;
            }
        }
        _binarySearchEventIndex(e) {
            for (var t, r = 0, i = this._animationEvents.length - 1; r <= i;) {
                t = Math.floor((r + i) / 2);
                var n = this._animationEvents[t].time;
                if (n == e) return t;
                n > e ? i = t - 1 : r = t + 1;
            }
            return r;
        }
        addEvent(e) {
            var t = this._binarySearchEventIndex(e.time);
            this._animationEvents.splice(t, 0, e);
        }
        _disposeResource() {
            this._nodes = null, this._nodesMap = null;
        }
    }
    Si.ANIMATIONCLIP = "ANIMATIONCLIP", Si._tempQuaternion0 = new E();
    class vi extends t.EventDispatcher {
        constructor(e, r = null, i = null, n = null, s = null) {
            super(), this._owner = e, this._children = [], this._localMatrix = new Float32Array(16),
                t.Render.supportWebGLPlusAnimation ? (this._localPosition = new fi(0, 0, 0, r),
                    this._localRotation = new Ei(0, 0, 0, 1, i), this._localScale = new fi(0, 0, 0, n),
                    this._worldMatrix = s) : (this._localPosition = new a(), this._localRotation = new E(),
                    this._localScale = new a(), this._worldMatrix = new Float32Array(16)), this._localQuaternionUpdate = !1,
                this._locaEulerlUpdate = !1, this._localUpdate = !1, this._worldUpdate = !0;
        }
        _getlocalMatrix() {
            return this._localUpdate && (M._createAffineTransformationArray(this._localPosition, this._localRotation, this._localScale, this._localMatrix),
                this._localUpdate = !1), this._localMatrix;
        }
        _onWorldTransform() {
            if (!this._worldUpdate) {
                this._worldUpdate = !0, this.event(t.Event.TRANSFORM_CHANGED);
                for (var e = 0, r = this._children.length; e < r; e++) this._children[e]._onWorldTransform();
            }
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(e) {
            this._localPosition = e, this._localUpdate = !0, this._onWorldTransform();
        }
        get localRotation() {
            if (this._localQuaternionUpdate) {
                var e = this._localRotationEuler;
                E.createFromYawPitchRoll(e.y / vi._angleToRandin, e.x / vi._angleToRandin, e.z / vi._angleToRandin, this._localRotation),
                    this._localQuaternionUpdate = !1;
            }
            return this._localRotation;
        }
        set localRotation(e) {
            this._localRotation = e, this._locaEulerlUpdate = !0, this._localQuaternionUpdate = !1,
                this._localUpdate = !0, this._onWorldTransform();
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(e) {
            this._localScale = e, this._localUpdate = !0, this._onWorldTransform();
        }
        get localRotationEuler() {
            if (this._locaEulerlUpdate) {
                this._localRotation.getYawPitchRoll(vi._tempVector3);
                var e = vi._tempVector3,
                    t = this._localRotationEuler;
                t.x = e.y * vi._angleToRandin, t.y = e.x * vi._angleToRandin, t.z = e.z * vi._angleToRandin,
                    this._locaEulerlUpdate = !1;
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(e) {
            this._localRotationEuler = e, this._locaEulerlUpdate = !1, this._localQuaternionUpdate = !0,
                this._localUpdate = !0, this._onWorldTransform();
        }
        getWorldMatrix() {
            if (!t.Render.supportWebGLPlusAnimation && this._worldUpdate) {
                if (null != this._parent) M.matrix4x4MultiplyFFF(this._parent.getWorldMatrix(), this._getlocalMatrix(), this._worldMatrix);
                else {
                    var e = this._worldMatrix;
                    e[1] = e[2] = e[3] = e[4] = e[6] = e[7] = e[8] = e[9] = e[11] = e[12] = e[13] = e[14] = 0,
                        e[0] = e[5] = e[10] = e[15] = 1;
                }
                this._worldUpdate = !1;
            }
            return t.Render.supportWebGLPlusAnimation && this._worldUpdate && (this._worldUpdate = !1),
                this._worldMatrix;
        }
        setParent(e) {
            if (this._parent !== e) {
                if (this._parent) {
                    var t = this._parent._children,
                        r = t.indexOf(this);
                    t.splice(r, 1);
                }
                e && (e._children.push(this), e && this._onWorldTransform()), this._parent = e;
            }
        }
    }
    vi._tempVector3 = new a(), vi._angleToRandin = 180 / Math.PI;
    class Ri {
        constructor(e = null, t = null, r = null, i = null) {
            this._children = [], this.transform = new vi(this, e, t, r, i);
        }
        addChild(e) {
            e._parent = this, e.transform.setParent(this.transform), this._children.push(e);
        }
        removeChild(e) {
            var t = this._children.indexOf(e); -
            1 !== t && this._children.splice(t, 1);
        }
        getChildByName(e) {
            for (var t = 0, r = this._children.length; t < r; t++) {
                var i = this._children[t];
                if (i.name === e) return i;
            }
            return null;
        }
        getChildByIndex(e) {
            return this._children[e];
        }
        getChildCount() {
            return this._children.length;
        }
        cloneTo(e) {
            var t = e;
            t.name = this.name;
            for (var r = 0, i = this._children.length; r < i; r++) {
                var n = this._children[r],
                    a = n.clone();
                t.addChild(a);
                var s = n.transform,
                    o = a.transform,
                    l = o.localPosition,
                    _ = o.localRotation,
                    h = o.localScale;
                s.localPosition.cloneTo(l), s.localRotation.cloneTo(_), s.localScale.cloneTo(h),
                    o.localPosition = l, o.localRotation = _, o.localScale = h;
            }
        }
        clone() {
            var e = new Ri();
            return this.cloneTo(e), e;
        }
        _cloneNative(e, t, r, i, n, a, s) {
            var o = s._nativeCurCloneCount;
            n[o] = a;
            var l = new Float32Array(e.buffer, 3 * o * 4, 3),
                _ = new Float32Array(t.buffer, 4 * o * 4, 4),
                h = new Float32Array(r.buffer, 3 * o * 4, 3),
                c = new Float32Array(i.buffer, 16 * o * 4, 16),
                d = new Ri(l, _, h, c);
            return d._worldMatrixIndex = o, this._cloneToNative(d, e, t, r, i, n, o, s), d;
        }
        _cloneToNative(e, t, r, i, n, a, s, o) {
            var l = e;
            l.name = this.name;
            for (var _ = 0, h = this._children.length; _ < h; _++) {
                var c = this._children[_];
                o._nativeCurCloneCount++;
                var d = c._cloneNative(t, r, i, n, a, s, o);
                l.addChild(d);
                var u = c.transform,
                    f = d.transform,
                    E = f.localPosition,
                    T = f.localRotation,
                    m = f.localScale;
                u.localPosition.cloneTo(E), u.localRotation.cloneTo(T), u.localScale.cloneTo(m),
                    f.localPosition = E, f.localRotation = T, f.localScale = m;
            }
        }
    }
    class Ai extends t.Resource {
        constructor() {
            super(), this._nativeNodeCount = 0, this._nativeCurCloneCount = 0;
        }
        static _parse(e, r = null, i = null) {
            var n = new Ai();
            if (n._rootNode = new Ri(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16)),
                t.Render.supportWebGLPlusAnimation && n._nativeNodeCount++, e.version) {
                var a = e.rootNode;
                a && n._parseNode(a, n._rootNode);
            }
            return n;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, Ai.AVATAR);
        }
        _initCloneToAnimator(e, t) {
            t._avatarNodeMap[e.name] = e;
            for (var r = 0, i = e.getChildCount(); r < i; r++) this._initCloneToAnimator(e.getChildByIndex(r), t);
        }
        _parseNode(e, r) {
            var i = e.props.name;
            r.name = i;
            var n = e.props,
                a = r.transform,
                s = a.localPosition,
                o = a.localRotation,
                l = a.localScale;
            s.fromArray(n.translate), o.fromArray(n.rotation), l.fromArray(n.scale), a.localPosition = s,
                a.localRotation = o, a.localScale = l;
            for (var _ = e.child, h = 0, c = _.length; h < c; h++) {
                var d = _[h],
                    u = new Ri(new Float32Array(3), new Float32Array(4), new Float32Array(3), new Float32Array(16));
                r.addChild(u), t.Render.supportWebGLPlusAnimation && this._nativeNodeCount++, this._parseNode(d, u);
            }
        }
        _cloneDatasToAnimator(e) {
            var t;
            t = this._rootNode.clone();
            var r = this._rootNode.transform,
                i = t.transform,
                n = i.localPosition,
                a = i.localRotation,
                s = i.localScale;
            r.localPosition.cloneTo(n), r.localRotation.cloneTo(a), r.localScale.cloneTo(s),
                i.localPosition = n, i.localRotation = a, i.localScale = s, e._avatarNodeMap = {},
                this._initCloneToAnimator(t, e);
        }
        cloneTo(e) {
            var t = e,
                r = this._rootNode.clone();
            t._rootNode = r;
        }
        clone() {
            var e = new Ai();
            return this.cloneTo(e), e;
        }
        _cloneDatasToAnimatorNative(e) {
            var t = new Float32Array(3 * this._nativeNodeCount),
                r = new Float32Array(4 * this._nativeNodeCount),
                i = new Float32Array(3 * this._nativeNodeCount),
                n = new Float32Array(16 * this._nativeNodeCount),
                a = new Int16Array(this._nativeNodeCount);
            e._animationNodeLocalPositions = t, e._animationNodeLocalRotations = r, e._animationNodeLocalScales = i,
                e._animationNodeWorldMatrixs = n, e._animationNodeParentIndices = a, this._nativeCurCloneCount = 0;
            var s = this._rootNode._cloneNative(t, r, i, n, a, -1, this),
                o = this._rootNode.transform,
                l = s.transform,
                _ = l.localPosition,
                h = l.localRotation,
                c = l.localScale;
            o.localPosition.cloneTo(_), o.localRotation.cloneTo(h), o.localScale.cloneTo(c),
                l.localPosition = _, l.localRotation = h, l.localScale = c, e._avatarNodeMap = {},
                this._initCloneToAnimator(s, e);
        }
    }
    Ai.AVATAR = "AVATAR";
    class Di extends Ge {
        constructor() {
            super(), this.setShaderName("SkyBox"), this.tintColor = new n(.5, .5, .5, .5), this.exposure = 1,
                this.rotation = 0;
        }
        static __initDefine__() {}
        get tintColor() {
            return this._shaderValues.getVector(Di.TINTCOLOR);
        }
        set tintColor(e) {
            this._shaderValues.setVector(Di.TINTCOLOR, e);
        }
        get exposure() {
            return this._shaderValues.getNumber(Di.EXPOSURE);
        }
        set exposure(e) {
            this._shaderValues.setNumber(Di.EXPOSURE, e);
        }
        get rotation() {
            return this._shaderValues.getNumber(Di.ROTATION);
        }
        set rotation(e) {
            this._shaderValues.setNumber(Di.ROTATION, e);
        }
        get textureCube() {
            return this._shaderValues.getTexture(Di.TEXTURECUBE);
        }
        set textureCube(e) {
            this._shaderValues.setTexture(Di.TEXTURECUBE, e);
        }
        clone() {
            var e = new Di();
            return this.cloneTo(e), e;
        }
    }
    Di.TINTCOLOR = L.propertyNameToID("u_TintColor"), Di.EXPOSURE = L.propertyNameToID("u_Exposure"),
        Di.ROTATION = L.propertyNameToID("u_Rotation"), Di.TEXTURECUBE = L.propertyNameToID("u_CubeTexture");
    class Ii extends h {
        constructor(e) {
            super(), this._id = ++Ii._uniqueIDCounter, this._mesh = e, this._boneIndicesList = [],
                this._subIndexBufferStart = [], this._subIndexBufferCount = [];
        }
        get indexCount() {
            return this._indexCount;
        }
        _setIndexRange(e, t) {
            this._indexStart = e, this._indexCount = t, this._indices = new Uint16Array(this._indexBuffer.getData().buffer, 2 * e, t);
        }
        _getType() {
            return Ii._type;
        }
        _prepareRender(e) {
            return this._mesh._uploadVerticesData(), !0;
        }
        _render(e) {
            var r = t.LayaGL.instance;
            this._mesh._bufferState.bind();
            var i = e.renderElement.render._skinnedData;
            if (i)
                for (var n = i[this._indexInMesh], a = this._boneIndicesList.length, s = 0; s < a; s++) e.shader.uploadCustomUniform(Yt.BONES, n[s]),
                    r.drawElements(r.TRIANGLES, this._subIndexBufferCount[s], r.UNSIGNED_SHORT, 2 * this._subIndexBufferStart[s]);
            else r.drawElements(r.TRIANGLES, this._indexCount, r.UNSIGNED_SHORT, 2 * this._indexStart);
            t.Stat.trianglesFaces += this._indexCount / 3, t.Stat.renderBatches++;
        }
        getIndices() {
            if (this._mesh._isReadable) return this._indices.slice();
            throw "SubMesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(e) {
            this._indexBuffer.setData(e, this._indexStart, 0, this._indexCount);
        }
        destroy() {
            this._destroyed || (super.destroy(), this._indexBuffer.destroy(), this._indexBuffer = null,
                this._mesh = null, this._boneIndicesList = null, this._subIndexBufferStart = null,
                this._subIndexBufferCount = null, this._skinAnimationDatas = null);
        }
    }
    Ii._uniqueIDCounter = 0, Ii._type = h._typeCounter++;
    class xi {
        static parse(e, t, r, i) {
            xi._mesh = r, xi._subMeshes = i, xi._version = t, xi._readData = e, xi.READ_DATA(),
                xi.READ_BLOCK(), xi.READ_STRINGS();
            for (var n = 0, a = xi._BLOCK.count; n < a; n++) {
                xi._readData.pos = xi._BLOCK.blockStarts[n];
                var s = xi._readData.getUint16(),
                    o = xi._strings[s],
                    l = xi["READ_" + o];
                if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                l.call(null);
            }
            xi._mesh._bindPoseIndices = new Uint16Array(xi._bindPoseIndices), xi._bindPoseIndices.length = 0,
                xi._strings.length = 0, xi._readData = null, xi._version = null, xi._mesh = null,
                xi._subMeshes = null;
        }
        static _readString() {
            return xi._strings[xi._readData.getUint16()];
        }
        static READ_DATA() {
            xi._DATA.offset = xi._readData.getUint32(), xi._DATA.size = xi._readData.getUint32();
        }
        static READ_BLOCK() {
            for (var e = xi._BLOCK.count = xi._readData.getUint16(), t = xi._BLOCK.blockStarts = [], r = xi._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(xi._readData.getUint32()),
                r.push(xi._readData.getUint32());
        }
        static READ_STRINGS() {
            var e = xi._readData.getUint32(),
                t = xi._readData.getUint16(),
                r = xi._readData.pos;
            xi._readData.pos = e + xi._DATA.offset;
            for (var i = 0; i < t; i++) xi._strings[i] = xi._readData.readUTFString();
            xi._readData.pos = r;
        }
        static READ_MESH() {
            var e, r = t.LayaGL.instance,
                i = (xi._readString(), xi._readData.__getBuffer()),
                n = 0,
                a = xi._readData.getInt16(),
                s = xi._DATA.offset;
            for (e = 0; e < a; e++) {
                var o, l = s + xi._readData.getUint32(),
                    _ = xi._readData.getUint32(),
                    h = i.slice(l, l + _),
                    u = new Float32Array(h),
                    f = xi._readString();
                switch (xi._version) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                        o = v.getVertexDeclaration(f);
                        break;

                    case "LAYAMODEL:0401":
                        o = v.getVertexDeclaration(f, !1);
                        break;

                    default:
                        throw new Error("LoadModelV03: unknown version.");
                }
                if (!o) throw new Error("LoadModelV03: unknown vertexDeclaration.");
                var E = new d(4 * u.length, r.STATIC_DRAW, !0);
                E.vertexDeclaration = o, E.setData(u.buffer), xi._mesh._vertexBuffer = E, xi._mesh._vertexCount += E.vertexCount,
                    n += 4 * u.length;
            }
            var m = s + xi._readData.getUint32(),
                p = xi._readData.getUint32(),
                g = new Uint16Array(i.slice(m, m + p)),
                S = new c(c.INDEXTYPE_USHORT, p / 2, r.STATIC_DRAW, !0);
            S.setData(g), xi._mesh._indexBuffer = S, n += 2 * S.indexCount, xi._mesh._setBuffer(xi._mesh._vertexBuffer, S),
                xi._mesh._setCPUMemory(n), xi._mesh._setGPUMemory(n);
            var R = xi._mesh._boneNames = [],
                A = xi._readData.getUint16();
            for (R.length = A, e = 0; e < A; e++) R[e] = xi._strings[xi._readData.getUint16()];
            xi._readData.pos += 8;
            var D = xi._readData.getUint32(),
                I = xi._readData.getUint32(),
                x = new Float32Array(i.slice(s + D, s + D + I)),
                M = x.length,
                L = xi._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * M);
            for (xi._mesh._inverseBindPoses = [], e = 0; e < M; e += 16) {
                var C = new T(x[e + 0], x[e + 1], x[e + 2], x[e + 3], x[e + 4], x[e + 5], x[e + 6], x[e + 7], x[e + 8], x[e + 9], x[e + 10], x[e + 11], x[e + 12], x[e + 13], x[e + 14], x[e + 15], new Float32Array(L, 4 * e, 16));
                xi._mesh._inverseBindPoses[e / 16] = C;
            }
            return !0;
        }
        static READ_SUBMESH() {
            var e = xi._readData.__getBuffer(),
                t = new Ii(xi._mesh);
            xi._readData.getInt16(), xi._readData.getUint32(), xi._readData.getUint32();
            var r = xi._readData.getUint32(),
                i = xi._readData.getUint32(),
                n = xi._mesh._indexBuffer;
            t._indexBuffer = n, t._setIndexRange(r, i);
            var a = xi._mesh._vertexBuffer;
            t._vertexBuffer = a;
            var s = xi._DATA.offset,
                o = t._subIndexBufferStart,
                l = t._subIndexBufferCount,
                _ = t._boneIndicesList,
                h = xi._readData.getUint16();
            o.length = h, l.length = h, _.length = h;
            for (var c = xi._mesh._skinDataPathMarks, d = xi._bindPoseIndices, u = xi._subMeshes.length, f = 0; f < h; f++) {
                o[f] = xi._readData.getUint32(), l[f] = xi._readData.getUint32();
                for (var E = xi._readData.getUint32(), T = xi._readData.getUint32(), m = _[f] = new Uint16Array(e.slice(s + E, s + E + T)), p = 0, g = m.length; p < g; p++) {
                    var S = m[p],
                        v = d.indexOf(S); -
                    1 === v ? (m[p] = d.length, d.push(S), c.push([u, f, p])) : m[p] = v;
                }
            }
            return xi._subMeshes.push(t), !0;
        }
    }
    xi._BLOCK = {
        count: 0
    }, xi._DATA = {
        offset: 0,
        size: 0
    }, xi._strings = [], xi._bindPoseIndices = [];
    class Mi {
        static parse(e, t, r, i) {
            Mi._mesh = r, Mi._subMeshes = i, Mi._version = t, Mi._readData = e, Mi.READ_DATA(),
                Mi.READ_BLOCK(), Mi.READ_STRINGS();
            for (var n = 0, a = Mi._BLOCK.count; n < a; n++) {
                Mi._readData.pos = Mi._BLOCK.blockStarts[n];
                var s = Mi._readData.getUint16(),
                    o = Mi._strings[s],
                    l = Mi["READ_" + o];
                if (null == l) throw new Error("model file err,no this function:" + s + " " + o);
                l.call(null);
            }
            Mi._mesh._bindPoseIndices = new Uint16Array(Mi._bindPoseIndices), Mi._bindPoseIndices.length = 0,
                Mi._strings.length = 0, Mi._readData = null, Mi._version = null, Mi._mesh = null,
                Mi._subMeshes = null;
        }
        static _readString() {
            return Mi._strings[Mi._readData.getUint16()];
        }
        static READ_DATA() {
            Mi._DATA.offset = Mi._readData.getUint32(), Mi._DATA.size = Mi._readData.getUint32();
        }
        static READ_BLOCK() {
            for (var e = Mi._BLOCK.count = Mi._readData.getUint16(), t = Mi._BLOCK.blockStarts = [], r = Mi._BLOCK.blockLengths = [], i = 0; i < e; i++) t.push(Mi._readData.getUint32()),
                r.push(Mi._readData.getUint32());
        }
        static READ_STRINGS() {
            var e = Mi._readData.getUint32(),
                t = Mi._readData.getUint16(),
                r = Mi._readData.pos;
            Mi._readData.pos = e + Mi._DATA.offset;
            for (var i = 0; i < t; i++) Mi._strings[i] = Mi._readData.readUTFString();
            Mi._readData.pos = r;
        }
        static READ_MESH() {
            var e, r = t.LayaGL.instance,
                i = 0,
                n = (Mi._readString(), Mi._readData.__getBuffer()),
                a = Mi._readData.getInt16(),
                s = Mi._DATA.offset;
            for (e = 0; e < a; e++) {
                var o, l, _, h = s + Mi._readData.getUint32(),
                    u = Mi._readData.getUint32(),
                    f = Mi._readString(),
                    E = v.getVertexDeclaration(f, !1),
                    m = E.vertexStride,
                    p = f.split(","),
                    g = p.length;
                switch (Mi._version) {
                    case "LAYAMODEL:05":
                        o = n.slice(h, h + u * m), l = new Float32Array(o), _ = new Uint8Array(o);
                        break;

                    case "LAYAMODEL:COMPRESSION_05":
                        o = new ArrayBuffer(m * u), l = new Float32Array(o), _ = new Uint8Array(o);
                        var S = Mi._readData.pos;
                        Mi._readData.pos = h;
                        for (var R = 0; R < u; R++)
                            for (var A, D = R * m, I = 0; I < g; I++) switch (p[I]) {
                                case "POSITION":
                                    l[A = D / 4] = mi.convertToNumber(Mi._readData.getUint16()), l[A + 1] = mi.convertToNumber(Mi._readData.getUint16()),
                                        l[A + 2] = mi.convertToNumber(Mi._readData.getUint16()), D += 12;
                                    break;

                                case "NORMAL":
                                    l[A = D / 4] = Mi._readData.getUint8() / 127.5 - 1, l[A + 1] = Mi._readData.getUint8() / 127.5 - 1,
                                        l[A + 2] = Mi._readData.getUint8() / 127.5 - 1, D += 12;
                                    break;

                                case "COLOR":
                                    l[A = D / 4] = Mi._readData.getUint8() / 255, l[A + 1] = Mi._readData.getUint8() / 255,
                                        l[A + 2] = Mi._readData.getUint8() / 255, l[A + 3] = Mi._readData.getUint8() / 255,
                                        D += 16;
                                    break;

                                case "UV":
                                case "UV1":
                                    l[A = D / 4] = mi.convertToNumber(Mi._readData.getUint16()), l[A + 1] = mi.convertToNumber(Mi._readData.getUint16()),
                                        D += 8;
                                    break;

                                case "BLENDWEIGHT":
                                    l[A = D / 4] = Mi._readData.getUint8() / 255, l[A + 1] = Mi._readData.getUint8() / 255,
                                        l[A + 2] = Mi._readData.getUint8() / 255, l[A + 3] = Mi._readData.getUint8() / 255,
                                        D += 16;
                                    break;

                                case "BLENDINDICES":
                                    _[D] = Mi._readData.getUint8(), _[D + 1] = Mi._readData.getUint8(), _[D + 2] = Mi._readData.getUint8(),
                                        _[D + 3] = Mi._readData.getUint8(), D += 4;
                                    break;

                                case "TANGENT":
                                    l[A = D / 4] = Mi._readData.getUint8() / 127.5 - 1, l[A + 1] = Mi._readData.getUint8() / 127.5 - 1,
                                        l[A + 2] = Mi._readData.getUint8() / 127.5 - 1, l[A + 3] = Mi._readData.getUint8() / 127.5 - 1,
                                        D += 16;
                            }
                        Mi._readData.pos = S;
                }
                var x = new d(o.byteLength, r.STATIC_DRAW, !0);
                x.vertexDeclaration = E, x.setData(o), Mi._mesh._vertexBuffer = x, Mi._mesh._vertexCount += x.vertexCount,
                    i += 4 * l.length;
            }
            var M = s + Mi._readData.getUint32(),
                L = Mi._readData.getUint32(),
                C = new Uint16Array(n.slice(M, M + L)),
                y = new c(c.INDEXTYPE_USHORT, L / 2, r.STATIC_DRAW, !0);
            y.setData(C), Mi._mesh._indexBuffer = y, Mi._mesh._setBuffer(Mi._mesh._vertexBuffer, y),
                i += 2 * y.indexCount, Mi._mesh._setCPUMemory(i), Mi._mesh._setGPUMemory(i);
            var O = Mi._mesh._boneNames = [],
                N = Mi._readData.getUint16();
            for (O.length = N, e = 0; e < N; e++) O[e] = Mi._strings[Mi._readData.getUint16()];
            var P = Mi._readData.getUint32(),
                V = Mi._readData.getUint32(),
                w = new Float32Array(n.slice(s + P, s + P + V)),
                b = w.length,
                F = Mi._mesh._inverseBindPosesBuffer = new ArrayBuffer(4 * b);
            for (Mi._mesh._inverseBindPoses = [], e = 0; e < b; e += 16) {
                var B = new T(w[e + 0], w[e + 1], w[e + 2], w[e + 3], w[e + 4], w[e + 5], w[e + 6], w[e + 7], w[e + 8], w[e + 9], w[e + 10], w[e + 11], w[e + 12], w[e + 13], w[e + 14], w[e + 15], new Float32Array(F, 4 * e, 16));
                Mi._mesh._inverseBindPoses[e / 16] = B;
            }
            return !0;
        }
        static READ_SUBMESH() {
            var e = Mi._readData.__getBuffer(),
                t = new Ii(Mi._mesh);
            Mi._readData.getInt16();
            var r = Mi._readData.getUint32(),
                i = Mi._readData.getUint32(),
                n = Mi._mesh._indexBuffer;
            t._indexBuffer = n, t._setIndexRange(r, i);
            var a = Mi._mesh._vertexBuffer;
            t._vertexBuffer = a;
            var s = Mi._DATA.offset,
                o = t._subIndexBufferStart,
                l = t._subIndexBufferCount,
                _ = t._boneIndicesList,
                h = Mi._readData.getUint16();
            o.length = h, l.length = h, _.length = h;
            for (var c = Mi._mesh._skinDataPathMarks, d = Mi._bindPoseIndices, u = Mi._subMeshes.length, f = 0; f < h; f++) {
                o[f] = Mi._readData.getUint32(), l[f] = Mi._readData.getUint32();
                for (var E = Mi._readData.getUint32(), T = Mi._readData.getUint32(), m = _[f] = new Uint16Array(e.slice(s + E, s + E + T)), p = 0, g = m.length; p < g; p++) {
                    var S = m[p],
                        v = d.indexOf(S); -
                    1 === v ? (m[p] = d.length, d.push(S), c.push([u, f, p])) : m[p] = v;
                }
            }
            return Mi._subMeshes.push(t), !0;
        }
    }
    Mi._BLOCK = {
        count: 0
    }, Mi._DATA = {
        offset: 0,
        size: 0
    }, Mi._strings = [], Mi._bindPoseIndices = [];
    class Li {
        constructor() {}
        static read(e, r, i) {
            var n = new t.Byte(e);
            n.pos = 0;
            var a = n.readUTFString();
            switch (a) {
                case "LAYAMODEL:0301":
                case "LAYAMODEL:0400":
                case "LAYAMODEL:0401":
                    xi.parse(n, a, r, i);
                    break;

                case "LAYAMODEL:05":
                case "LAYAMODEL:COMPRESSION_05":
                    Mi.parse(n, a, r, i);
                    break;

                default:
                    throw new Error("MeshReader: unknown mesh version.");
            }
            r._setSubMeshes(i);
        }
    }
    class Ci extends t.Resource {
        constructor(e = !0) {
            super(), this._tempVector30 = new a(), this._tempVector31 = new a(), this._tempVector32 = new a(),
                this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1, this._needUpdateBounds = !0,
                this._bounds = new We(new a(), new a()), this._bufferState = new _(), this._instanceBufferState = new _(),
                this._vertexBuffer = null, this._indexBuffer = null, this._vertexCount = 0, this._isReadable = e,
                this._subMeshes = [], this._skinDataPathMarks = [];
        }
        static __init__() {
            var e = fe._physics3D;
            e && (Ci._nativeTempVector30 = new e.btVector3(0, 0, 0), Ci._nativeTempVector31 = new e.btVector3(0, 0, 0),
                Ci._nativeTempVector32 = new e.btVector3(0, 0, 0));
        }
        static _parse(e, t = null, r = null) {
            var i = new Ci();
            return Li.read(e, i, i._subMeshes), i;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, Ci.MESH);
        }
        get inverseAbsoluteBindPoses() {
            return this._inverseBindPoses;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(e) {
            this._bounds !== e && e.cloneTo(this._bounds);
        }
        _getPositionElement(e) {
            for (var t = e.vertexDeclaration._vertexElements, r = 0, i = t.length; r < i; r++) {
                var n = t[r];
                if (n._elementFormat === u.Vector3 && n._elementUsage === v.MESH_POSITION0) return n;
            }
            return null;
        }
        _getVerticeElementData(e, t) {
            e.length = this._vertexCount;
            var r = this._vertexBuffer.vertexDeclaration,
                s = r.getVertexElementByUsage(t);
            if (s) {
                var o = this._vertexBuffer.getUint8Data(),
                    l = this._vertexBuffer.getFloat32Data(),
                    _ = r.vertexStride,
                    h = _ / 4,
                    c = s._offset,
                    d = c / 4;
                switch (t) {
                    case v.MESH_TEXTURECOORDINATE0:
                    case v.MESH_TEXTURECOORDINATE1:
                        for (var u = 0; u < this._vertexCount; u++) {
                            var f = h * u + d;
                            e[u] = new i(l[f], l[f + 1]);
                        }
                        break;

                    case v.MESH_POSITION0:
                    case v.MESH_NORMAL0:
                        for (u = 0; u < this._vertexCount; u++) {
                            f = h * u + d;
                            e[u] = new a(l[f], l[f + 1], l[f + 2]);
                        }
                        break;

                    case v.MESH_TANGENT0:
                    case v.MESH_BLENDWEIGHT0:
                        for (u = 0; u < this._vertexCount; u++) {
                            f = h * u + d;
                            e[u] = new n(l[f], l[f + 1], l[f + 2], l[f + 3]);
                        }
                        break;

                    case v.MESH_COLOR0:
                        for (u = 0; u < this._vertexCount; u++) {
                            f = h * u + d;
                            e[u] = new I(l[f], l[f + 1], l[f + 2], l[f + 3]);
                        }
                        break;

                    case v.MESH_BLENDINDICES0:
                        for (u = 0; u < this._vertexCount; u++) {
                            f = _ * u + c;
                            e[u] = new n(o[f], o[f + 1], o[f + 2], o[f + 3]);
                        }
                        break;

                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
            }
        }
        _setVerticeElementData(e, t) {
            var r = this._vertexBuffer.vertexDeclaration,
                i = r.getVertexElementByUsage(t);
            if (i) {
                var n = this._vertexBuffer.getUint8Data(),
                    a = this._vertexBuffer.getFloat32Data(),
                    s = r.vertexStride,
                    o = s / 4,
                    l = i._offset,
                    _ = l / 4;
                switch (t) {
                    case v.MESH_TEXTURECOORDINATE0:
                    case v.MESH_TEXTURECOORDINATE1:
                        for (var h = 0, c = e.length; h < c; h++) {
                            var d = o * h + _,
                                u = e[h];
                            a[d] = u.x, a[d + 1] = u.y;
                        }
                        break;

                    case v.MESH_POSITION0:
                    case v.MESH_NORMAL0:
                        for (h = 0, c = e.length; h < c; h++) {
                            d = o * h + _;
                            var f = e[h];
                            a[d] = f.x, a[d + 1] = f.y, a[d + 2] = f.z;
                        }
                        break;

                    case v.MESH_TANGENT0:
                    case v.MESH_BLENDWEIGHT0:
                        for (h = 0, c = e.length; h < c; h++) {
                            d = o * h + _;
                            var E = e[h];
                            a[d] = E.x, a[d + 1] = E.y, a[d + 2] = E.z, a[d + 3] = E.w;
                        }
                        break;

                    case v.MESH_COLOR0:
                        for (h = 0, c = e.length; h < c; h++) {
                            d = o * h + _;
                            var T = e[h];
                            a[d] = T.r, a[d + 1] = T.g, a[d + 2] = T.b, a[d + 2] = T.a;
                        }
                        break;

                    case v.MESH_BLENDINDICES0:
                        for (h = 0, c = e.length; h < c; h++) {
                            d = s * h + l, E = e[h];
                            n[d] = E.x, n[d + 1] = E.y, n[d + 2] = E.z, n[d + 3] = E.w;
                        }
                        break;

                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
            } else console.warn("Mesh: the mesh don't have  this VertexElement.");
        }
        _disposeResource() {
            for (var e = 0, t = this._subMeshes.length; e < t; e++) this._subMeshes[e].destroy();
            this._nativeTriangleMesh && window.Physics3D.destroy(this._nativeTriangleMesh),
                this._vertexBuffer.destroy(), this._indexBuffer.destroy(), this._setCPUMemory(0),
                this._setGPUMemory(0), this._bufferState.destroy(), this._instanceBufferState.destroy(),
                this._bufferState = null, this._instanceBufferState = null, this._vertexBuffer = null,
                this._indexBuffer = null, this._subMeshes = null, this._nativeTriangleMesh = null,
                this._indexBuffer = null, this._boneNames = null, this._inverseBindPoses = null;
        }
        _setSubMeshes(e) {
            this._subMeshes = e;
            for (var t = 0, r = e.length; t < r; t++) e[t]._indexInMesh = t;
            this.calculateBounds();
        }
        _setBuffer(e, t) {
            var r = this._bufferState;
            r.bind(), r.applyVertexBuffer(e), r.applyIndexBuffer(t), r.unBind();
            var i = this._instanceBufferState;
            i.bind(), i.applyVertexBuffer(e), i.applyInstanceVertexBuffer(D.instance.instanceWorldMatrixBuffer),
                i.applyInstanceVertexBuffer(D.instance.instanceMVPMatrixBuffer), i.applyIndexBuffer(t),
                i.unBind();
        }
        _getPhysicMesh() {
            if (!this._nativeTriangleMesh) {
                for (var e = new window.Physics3D.btTriangleMesh(), t = Ci._nativeTempVector30, r = Ci._nativeTempVector31, i = Ci._nativeTempVector32, n = this._tempVector30, a = this._tempVector31, s = this._tempVector32, o = this._vertexBuffer, l = this._getPositionElement(o), _ = o.getFloat32Data(), h = o.vertexDeclaration.vertexStride / 4, c = l._offset / 4, d = this._indexBuffer.getData(), u = 0, f = d.length; u < f; u += 3) {
                    var E = d[u] * h + c,
                        T = d[u + 1] * h + c,
                        m = d[u + 2] * h + c;
                    n.setValue(_[E], _[E + 1], _[E + 2]), a.setValue(_[T], _[T + 1], _[T + 2]), s.setValue(_[m], _[m + 1], _[m + 2]),
                        M._convertToBulletVec3(n, t, !0), M._convertToBulletVec3(a, r, !0), M._convertToBulletVec3(s, i, !0),
                        e.addTriangle(t, r, i, !0);
                }
                this._nativeTriangleMesh = e;
            }
            return this._nativeTriangleMesh;
        }
        _uploadVerticesData() {
            var e = this._minVerticesUpdate,
                t = this._maxVerticesUpdate;
            if (-1 !== e && -1 !== t) {
                var r = 4 * e;
                this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, r, r, 4 * (t - e)),
                    this._minVerticesUpdate = -1, this._maxVerticesUpdate = -1;
            }
        }
        getSubMesh(e) {
            return this._subMeshes[e];
        }
        getPositions(e) {
            if (!this._isReadable) throw "Mesh:can't get positions on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_POSITION0);
        }
        setPositions(e) {
            if (!this._isReadable) throw "Mesh:setPosition() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_POSITION0), this._needUpdateBounds = !0;
        }
        getColors(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_COLOR0);
        }
        setColors(e) {
            if (!this._isReadable) throw "Mesh:setColors() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_COLOR0);
        }
        getUVs(e, t = 0) {
            if (!this._isReadable) throw "Mesh:can't get uvs on mesh,isReadable must be true.";
            switch (t) {
                case 0:
                    this._getVerticeElementData(e, v.MESH_TEXTURECOORDINATE0);
                    break;

                case 1:
                    this._getVerticeElementData(e, v.MESH_TEXTURECOORDINATE1);
                    break;

                default:
                    throw "Mesh:Invalid channel.";
            }
        }
        setUVs(e, t = 0) {
            if (!this._isReadable) throw "Mesh:setUVs() need isReadable must be true or use setVertices().";
            switch (t) {
                case 0:
                    this._setVerticeElementData(e, v.MESH_TEXTURECOORDINATE0);
                    break;

                case 1:
                    this._setVerticeElementData(e, v.MESH_TEXTURECOORDINATE1);
                    break;

                default:
                    throw "Mesh:Invalid channel.";
            }
        }
        getNormals(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_NORMAL0);
        }
        setNormals(e) {
            if (!this._isReadable) throw "Mesh:setNormals() need must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_NORMAL0);
        }
        getTangents(e) {
            if (!this._isReadable) throw "Mesh:can't get colors on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_TANGENT0);
        }
        setTangents(e) {
            if (!this._isReadable) throw "Mesh:setTangents() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_TANGENT0);
        }
        getBoneWeights(e) {
            if (!this._isReadable) throw "Mesh:can't get boneWeights on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_BLENDWEIGHT0);
        }
        setBoneWeights(e) {
            if (!this._isReadable) throw "Mesh:setBoneWeights() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_BLENDWEIGHT0);
        }
        getBoneIndices(e) {
            if (!this._isReadable) throw "Mesh:can't get boneIndices on mesh,isReadable must be true.";
            this._getVerticeElementData(e, v.MESH_BLENDINDICES0);
        }
        setBoneIndices(e) {
            if (!this._isReadable) throw "Mesh:setBoneIndices() need isReadable must be true or use setVertices().";
            this._setVerticeElementData(e, v.MESH_BLENDINDICES0);
        }
        markAsUnreadbale() {
            this._uploadVerticesData(), this._vertexBuffer.markAsUnreadbale(), this._isReadable = !1;
        }
        getVertexDeclaration() {
            return this._vertexBuffer._vertexDeclaration;
        }
        getVertices() {
            if (this._isReadable) return this._vertexBuffer.getUint8Data().buffer.slice(0);
            throw "Mesh:can't get vertices on mesh,isReadable must be true.";
        }
        setVertices(e) {
            this._vertexBuffer.setData(e), this._needUpdateBounds = !0;
        }
        getIndices() {
            if (this._isReadable) return this._indexBuffer.getData().slice();
            throw "Mesh:can't get indices on subMesh,mesh's isReadable must be true.";
        }
        setIndices(e) {
            this._indexBuffer.setData(e);
        }
        calculateBounds() {
            if (!this._isReadable) throw "Mesh:can't calculate bounds on subMesh,mesh's isReadable must be true.";
            if (this._needUpdateBounds) {
                var e = this._tempVector30,
                    t = this._tempVector31;
                e.x = e.y = e.z = Number.MAX_VALUE, t.x = t.y = t.z = -Number.MAX_VALUE;
                for (var r = this._vertexBuffer, i = this._getPositionElement(r), n = r.getFloat32Data(), a = r.vertexDeclaration.vertexStride / 4, s = i._offset / 4, o = 0, l = n.length; o < l; o += a) {
                    var _ = o + s,
                        h = n[_],
                        c = n[_ + 1],
                        d = n[_ + 2];
                    e.x = Math.min(e.x, h), e.y = Math.min(e.y, c), e.z = Math.min(e.z, d), t.x = Math.max(t.x, h),
                        t.y = Math.max(t.y, c), t.z = Math.max(t.z, d);
                }
                this._bounds.setMin(e), this._bounds.setMax(t), this._needUpdateBounds = !1;
            }
        }
        cloneTo(e) {
            var t = e,
                r = this._vertexBuffer,
                i = new d(r._byteLength, r.bufferUsage, r.canRead);
            i.vertexDeclaration = r.vertexDeclaration, i.setData(r.getUint8Data().slice().buffer),
                t._vertexBuffer = i, t._vertexCount += i.vertexCount;
            var n, a = this._indexBuffer,
                s = new c(c.INDEXTYPE_USHORT, a.indexCount, a.bufferUsage, a.canRead);
            s.setData(a.getData().slice()), t._indexBuffer = s, t._setBuffer(t._vertexBuffer, s),
                t._setCPUMemory(this.cpuMemory), t._setGPUMemory(this.gpuMemory);
            var o = this._boneNames,
                l = t._boneNames = [];
            for (n = 0; n < o.length; n++) l[n] = o[n];
            var _ = this._inverseBindPoses,
                h = t._inverseBindPoses = [];
            for (n = 0; n < _.length; n++) h[n] = _[n];
            for (t._bindPoseIndices = new Uint16Array(this._bindPoseIndices), n = 0; n < this._skinDataPathMarks.length; n++) t._skinDataPathMarks[n] = this._skinDataPathMarks[n].slice();
            for (n = 0; n < this.subMeshCount; n++) {
                var u = this._subMeshes[n],
                    f = u._subIndexBufferStart,
                    E = u._subIndexBufferCount,
                    T = u._boneIndicesList,
                    m = new Ii(t);
                m._subIndexBufferStart.length = f.length, m._subIndexBufferCount.length = E.length,
                    m._boneIndicesList.length = T.length;
                for (var p = 0; p < f.length; p++) m._subIndexBufferStart[p] = f[p];
                for (p = 0; p < E.length; p++) m._subIndexBufferCount[p] = E[p];
                for (p = 0; p < T.length; p++) m._boneIndicesList[p] = new Uint16Array(T[p]);
                m._indexBuffer = s, m._indexStart = u._indexStart, m._indexCount = u._indexCount,
                    m._indices = new Uint16Array(s.getData().buffer, 2 * u._indexStart, u._indexCount);
                var g = t._vertexBuffer;
                m._vertexBuffer = g, t._subMeshes.push(m);
            }
            t._setSubMeshes(t._subMeshes);
        }
        clone() {
            var e = new Ci();
            return this.cloneTo(e), e;
        }
    }
    Ci.MESH = "MESH";
    class yi extends t.BaseTexture {
        constructor(e, r = t.BaseTexture.FORMAT_R8G8B8, i = !1) {
            super(r, i), this._glTextureType = t.LayaGL.instance.TEXTURE_CUBE_MAP, this._width = e,
                this._height = e;
            var n = t.LayaGL.instance;
            if (this._setWarpMode(n.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(n.TEXTURE_WRAP_T, this._wrapModeV),
                this._setFilterMode(this._filterMode), this._setAnisotropy(this._anisoLevel), this._mipmap) {
                this._mipmapCount = Math.ceil(Math.log2(e));
                for (var a = 0; a < this._mipmapCount; a++) this._setPixels([], a, Math.max(e >> a, 1), Math.max(e >> a, 1));
                this._setGPUMemory(e * e * 4 * (1 + 1 / 3) * 6);
            } else this._mipmapCount = 1, this._setGPUMemory(e * e * 4 * 6);
        }
        static __init__() {
            var e = new Uint8Array(3);
            e[0] = 128, e[1] = 128, e[2] = 128, yi.grayTexture = new yi(1, t.BaseTexture.FORMAT_R8G8B8, !1),
                yi.grayTexture.setSixSidePixels([e, e, e, e, e, e]), yi.grayTexture.lock = !0;
        }
        static _parse(e, t = null, r = null) {
            var i = r ? new yi(0, r[0], r[1]) : new yi(0);
            return i.setSixSideImageSources(e), i;
        }
        static load(e, r) {
            t.ILaya.loader.create(e, r, null, yi.TEXTURECUBE);
        }
        get defaulteTexture() {
            return yi.grayTexture;
        }
        _setPixels(e, r, i, n) {
            var a = t.LayaGL.instance,
                s = this._getGLFormat();
            t.WebGLContext.bindTexture(a, this._glTextureType, this._glTexture), this.format === t.BaseTexture.FORMAT_R8G8B8 ? (a.pixelStorei(a.UNPACK_ALIGNMENT, 1),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[0]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[1]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[2]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[3]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[4]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[5]),
                a.pixelStorei(a.UNPACK_ALIGNMENT, 4)) : (a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Z, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[0]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Z, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[1]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[2]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_X, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[3]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_Y, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[4]),
                a.texImage2D(a.TEXTURE_CUBE_MAP_NEGATIVE_Y, r, s, i, n, 0, s, a.UNSIGNED_BYTE, e[5]));
        }
        setSixSideImageSources(e, r = !1) {
            for (var i, n, a = 0; a < 6; a++) {
                var s = e[a];
                if (!s) return void console.log("TextureCube: image Source can't be null.");
                var o = s.width,
                    l = s.height;
                if (a > 0 && i !== o) return void console.log("TextureCube: each side image's width and height must same.");
                if ((i = o) !== (n = l)) return void console.log("TextureCube: each side image's width and height must same.");
            }
            this._width = i, this._height = n;
            var _ = t.LayaGL.instance;
            t.WebGLContext.bindTexture(_, this._glTextureType, this._glTexture);
            var h = this._getGLFormat();
            if (t.Render.isConchApp) {
                if (1 == r)
                    for (var c = 0; c < 6; c++) e[c].setPremultiplyAlpha(r);
                _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[0]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[1]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[2]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[3]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[4]),
                    _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, _.RGBA, _.RGBA, _.UNSIGNED_BYTE, e[5]);
            } else r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !0), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[0]),
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, h, h, _.UNSIGNED_BYTE, e[1]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[2]),
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, h, h, _.UNSIGNED_BYTE, e[3]), _.texImage2D(_.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[4]),
                _.texImage2D(_.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, h, h, _.UNSIGNED_BYTE, e[5]), r && _.pixelStorei(_.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1);
            this._mipmap && this._isPot(i) && this._isPot(n) ? (_.generateMipmap(this._glTextureType),
                    this._setGPUMemory(i * n * 4 * (1 + 1 / 3) * 6)) : this._setGPUMemory(i * n * 4 * 6),
                this._setWarpMode(_.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(_.TEXTURE_WRAP_T, this._wrapModeV),
                this._setFilterMode(this._filterMode), this._readyed = !0, this._activeResource();
        }
        setSixSidePixels(e, r = 0) {
            if (!e) throw new Error("TextureCube:pixels can't be null.");
            var i = Math.max(this._width >> r, 1),
                n = Math.max(this._height >> r, 1),
                a = i * n * this._getFormatByteCount();
            if (e[0].length < a) throw "TextureCube:pixels length should at least " + a + ".";
            if (this._setPixels(e, r, i, n), 0 === r) {
                var s = t.LayaGL.instance;
                this._setWarpMode(s.TEXTURE_WRAP_S, this._wrapModeU), this._setWarpMode(s.TEXTURE_WRAP_T, this._wrapModeV);
            }
            this._readyed = !0, this._activeResource();
        }
        _recoverResource() {}
    }
    yi.TEXTURECUBE = "TEXTURECUBE";
    class Oi extends De {
        constructor(e, t) {
            super(e, t), this._isTrigger = !1;
        }
        get isTrigger() {
            return this._isTrigger;
        }
        set isTrigger(e) {
            if (this._isTrigger = e, this._nativeColliderObject) {
                var t = this._nativeColliderObject.getCollisionFlags();
                e ? 0 == (t & De.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && this._nativeColliderObject.setCollisionFlags(t | De.COLLISIONFLAGS_NO_CONTACT_RESPONSE) : 0 != (t & De.COLLISIONFLAGS_NO_CONTACT_RESPONSE) && this._nativeColliderObject.setCollisionFlags(t ^ De.COLLISIONFLAGS_NO_CONTACT_RESPONSE);
            }
        }
        _onAdded() {
            super._onAdded(), this.isTrigger = this._isTrigger;
        }
        _cloneTo(e) {
            super._cloneTo(e), e.isTrigger = this._isTrigger;
        }
    }
    class Ni extends Oi {
        constructor(e = Ee.COLLISIONFILTERGROUP_DEFAULTFILTER, t = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            super(e, t), this._enableProcessCollisions = !1;
        }
        _addToSimulation() {
            this._simulation._addPhysicsCollider(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removePhysicsCollider(this);
        }
        _onTransformChanged(e) {
            (e &= w.TRANSFORM_WORLDPOSITION | w.TRANSFORM_WORLDQUATERNION | w.TRANSFORM_WORLDSCALE) && (this._transformFlag |= e,
                this._isValid() && -1 === this._inPhysicUpdateListIndex && this._simulation._physicsUpdateList.add(this));
        }
        _parse(e) {
            null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                super._parse(e), this._parseShape(e.shapes);
        }
        _onAdded() {
            var e = new fe._physics3D.btCollisionObject();
            e.setUserIndex(this.id), e.forceActivationState(De.ACTIVATIONSTATE_DISABLE_SIMULATION);
            var t = e.getCollisionFlags();
            this.owner.isStatic ? ((t & De.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (t ^= De.COLLISIONFLAGS_KINEMATIC_OBJECT),
                    t |= De.COLLISIONFLAGS_STATIC_OBJECT) : ((t & De.COLLISIONFLAGS_STATIC_OBJECT) > 0 && (t ^= De.COLLISIONFLAGS_STATIC_OBJECT),
                    t |= De.COLLISIONFLAGS_KINEMATIC_OBJECT), e.setCollisionFlags(t), this._nativeColliderObject = e,
                super._onAdded();
        }
    }
    class Pi extends De {
        constructor(e = .1, t = null, r = Ee.COLLISIONFILTERGROUP_DEFAULTFILTER, i = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            super(r, i), this._upAxis = new a(0, 1, 0), this._maxSlope = 45, this._jumpSpeed = 10,
                this._fallSpeed = 55, this._gravity = new a(0, 3 * -9.8, 0), this._nativeKinematicCharacter = null,
                this._stepHeight = e, t && (this._upAxis = t);
        }
        static __init__() {
            Pi._nativeTempVector30 = new fe._physics3D.btVector3(0, 0, 0);
        }
        get fallSpeed() {
            return this._fallSpeed;
        }
        set fallSpeed(e) {
            this._fallSpeed = e, this._nativeKinematicCharacter.setFallSpeed(e);
        }
        get jumpSpeed() {
            return this._jumpSpeed;
        }
        set jumpSpeed(e) {
            this._jumpSpeed = e, this._nativeKinematicCharacter.setJumpSpeed(e);
        }
        get gravity() {
            return this._gravity;
        }
        set gravity(e) {
            this._gravity = e;
            var t = Pi._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeKinematicCharacter.setGravity(t);
        }
        get maxSlope() {
            return this._maxSlope;
        }
        set maxSlope(e) {
            this._maxSlope = e, this._nativeKinematicCharacter.setMaxSlope(e / 180 * Math.PI);
        }
        get isGrounded() {
            return this._nativeKinematicCharacter.onGround();
        }
        get stepHeight() {
            return this._stepHeight;
        }
        set stepHeight(e) {
            this._stepHeight = e, this._constructCharacter();
        }
        get upAxis() {
            return this._upAxis;
        }
        set upAxis(e) {
            this._upAxis = e, this._constructCharacter();
        }
        _constructCharacter() {
            var e = fe._physics3D;
            this._nativeKinematicCharacter && e.destroy(this._nativeKinematicCharacter);
            var t = Pi._nativeTempVector30;
            t.setValue(this._upAxis.x, this._upAxis.y, this._upAxis.z), this._nativeKinematicCharacter = new e.btKinematicCharacterController(this._nativeColliderObject, this._colliderShape._nativeShape, this._stepHeight, t),
                this.fallSpeed = this._fallSpeed, this.maxSlope = this._maxSlope, this.jumpSpeed = this._jumpSpeed,
                this.gravity = this._gravity;
        }
        _onShapeChange(e) {
            super._onShapeChange(e), this._constructCharacter();
        }
        _onAdded() {
            var e = new fe._physics3D.btPairCachingGhostObject();
            e.setUserIndex(this.id), e.setCollisionFlags(De.COLLISIONFLAGS_CHARACTER_OBJECT),
                this._nativeColliderObject = e, this._colliderShape && this._constructCharacter(),
                super._onAdded();
        }
        _addToSimulation() {
            this._simulation._characters.push(this), this._simulation._addCharacter(this, this._collisionGroup, this._canCollideWith);
        }
        _removeFromSimulation() {
            this._simulation._removeCharacter(this);
            var e = this._simulation._characters;
            e.splice(e.indexOf(this), 1);
        }
        _cloneTo(e) {
            super._cloneTo(e);
            var t = e;
            t.stepHeight = this._stepHeight, t.upAxis = this._upAxis, t.maxSlope = this._maxSlope,
                t.jumpSpeed = this._jumpSpeed, t.fallSpeed = this._fallSpeed, t.gravity = this._gravity;
        }
        _onDestroy() {
            fe._physics3D.destroy(this._nativeKinematicCharacter), super._onDestroy(), this._nativeKinematicCharacter = null;
        }
        move(e) {
            var t = Pi._nativeVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeKinematicCharacter.setWalkDirection(t);
        }
        jump(e = null) {
            if (e) {
                var t = Pi._nativeVector30;
                M._convertToBulletVec3(e, t, !0), this._nativeKinematicCharacter.jump(t);
            } else this._nativeKinematicCharacter.jump();
        }
    }
    Pi.UPAXIS_X = 0, Pi.UPAXIS_Y = 1, Pi.UPAXIS_Z = 2;
    class Vi extends Oi {
        constructor(e = Ee.COLLISIONFILTERGROUP_DEFAULTFILTER, t = Ee.COLLISIONFILTERGROUP_ALLFILTER) {
            super(e, t), this._isKinematic = !1, this._mass = 1, this._gravity = new a(0, -10, 0),
                this._angularDamping = 0, this._linearDamping = 0, this._overrideGravity = !1, this._totalTorque = new a(0, 0, 0),
                this._totalForce = new a(0, 0, 0), this._linearVelocity = new a(), this._angularVelocity = new a(),
                this._linearFactor = new a(1, 1, 1), this._angularFactor = new a(1, 1, 1), this._detectCollisions = !0;
        }
        static __init__() {
            Vi._nativeTempVector30 = new fe._physics3D.btVector3(0, 0, 0), Vi._nativeTempVector31 = new fe._physics3D.btVector3(0, 0, 0),
                Vi._nativeVector3Zero = new fe._physics3D.btVector3(0, 0, 0), Vi._nativeInertia = new fe._physics3D.btVector3(0, 0, 0),
                Vi._nativeImpulse = new fe._physics3D.btVector3(0, 0, 0), Vi._nativeImpulseOffset = new fe._physics3D.btVector3(0, 0, 0),
                Vi._nativeGravity = new fe._physics3D.btVector3(0, 0, 0);
        }
        get mass() {
            return this._mass;
        }
        set mass(e) {
            e = Math.max(e, 1e-7), this._mass = e, this._isKinematic || this._updateMass(e);
        }
        get isKinematic() {
            return this._isKinematic;
        }
        set isKinematic(e) {
            this._isKinematic = e;
            var t = !!(this._simulation && this._enabled && this._colliderShape);
            t && this._removeFromSimulation();
            var r = this._nativeColliderObject,
                i = r.getCollisionFlags();
            e ? (i |= De.COLLISIONFLAGS_KINEMATIC_OBJECT, r.setCollisionFlags(i), this._nativeColliderObject.forceActivationState(De.ACTIVATIONSTATE_DISABLE_DEACTIVATION),
                this._enableProcessCollisions = !1, this._updateMass(0)) : ((i & De.COLLISIONFLAGS_KINEMATIC_OBJECT) > 0 && (i ^= De.COLLISIONFLAGS_KINEMATIC_OBJECT),
                r.setCollisionFlags(i), this._nativeColliderObject.setActivationState(De.ACTIVATIONSTATE_ACTIVE_TAG),
                this._enableProcessCollisions = !0, this._updateMass(this._mass));
            var n = Vi._nativeVector3Zero;
            r.setInterpolationLinearVelocity(n), r.setLinearVelocity(n), r.setInterpolationAngularVelocity(n),
                r.setAngularVelocity(n), t && this._addToSimulation();
        }
        get linearDamping() {
            return this._linearDamping;
        }
        set linearDamping(e) {
            this._linearDamping = e, this._nativeColliderObject && this._nativeColliderObject.setDamping(e, this._angularDamping);
        }
        get angularDamping() {
            return this._angularDamping;
        }
        set angularDamping(e) {
            this._angularDamping = e, this._nativeColliderObject && this._nativeColliderObject.setDamping(this._linearDamping, e);
        }
        get overrideGravity() {
            return this._overrideGravity;
        }
        set overrideGravity(e) {
            if (this._overrideGravity = e, this._nativeColliderObject) {
                var t = this._nativeColliderObject.getFlags();
                e ? 0 == (t & Vi._BT_DISABLE_WORLD_GRAVITY) && this._nativeColliderObject.setFlags(t | Vi._BT_DISABLE_WORLD_GRAVITY) : (t & Vi._BT_DISABLE_WORLD_GRAVITY) > 0 && this._nativeColliderObject.setFlags(t ^ Vi._BT_DISABLE_WORLD_GRAVITY);
            }
        }
        get gravity() {
            return this._gravity;
        }
        set gravity(e) {
            this._gravity = e, Vi._nativeGravity.setValue(-e.x, e.y, e.z), this._nativeColliderObject.setGravity(Vi._nativeGravity);
        }
        get totalForce() {
            if (this._nativeColliderObject) {
                var e = this._nativeColliderObject.getTotalForce();
                return M._convertToLayaVec3(e, this._totalForce, !0), this._totalForce;
            }
            return null;
        }
        get linearFactor() {
            return this._nativeColliderObject ? this._linearFactor : null;
        }
        set linearFactor(e) {
            if (this._linearFactor = e, this._nativeColliderObject) {
                var t = Vi._nativeTempVector30;
                M._convertToBulletVec3(e, t, !1), this._nativeColliderObject.setLinearFactor(t);
            }
        }
        get linearVelocity() {
            return this._nativeColliderObject && M._convertToLayaVec3(this._nativeColliderObject.getLinearVelocity(), this._linearVelocity, !0),
                this._linearVelocity;
        }
        set linearVelocity(e) {
            if (this._linearVelocity = e, this._nativeColliderObject) {
                var t = Vi._nativeTempVector30;
                M._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setLinearVelocity(t);
            }
        }
        get angularFactor() {
            return this._nativeColliderObject ? this._angularFactor : null;
        }
        set angularFactor(e) {
            if (this._angularFactor = e, this._nativeColliderObject) {
                var t = Vi._nativeTempVector30;
                M._convertToBulletVec3(e, t, !1), this._nativeColliderObject.setAngularFactor(t);
            }
        }
        get angularVelocity() {
            return this._nativeColliderObject && M._convertToLayaVec3(this._nativeColliderObject.getAngularVelocity(), this._angularVelocity, !0),
                this._angularVelocity;
        }
        set angularVelocity(e) {
            if (this._angularVelocity = e, this._nativeColliderObject) {
                var t = Vi._nativeTempVector30;
                M._convertToBulletVec3(e, t, !0), this.isSleeping && this.wakeUp(), this._nativeColliderObject.setAngularVelocity(t);
            }
        }
        get totalTorque() {
            if (this._nativeColliderObject) {
                var e = this._nativeColliderObject.getTotalTorque();
                return M._convertToLayaVec3(e, this._totalTorque, !0), this._totalTorque;
            }
            return null;
        }
        get detectCollisions() {
            return this._detectCollisions;
        }
        set detectCollisions(e) {
            this._detectCollisions !== e && (this._detectCollisions = e, this._colliderShape && this._enabled && this._simulation && (this._simulation._removeRigidBody(this),
                this._simulation._addRigidBody(this, this._collisionGroup, e ? this._canCollideWith : 0)));
        }
        get isSleeping() {
            return !!this._nativeColliderObject && this._nativeColliderObject.getActivationState() === De.ACTIVATIONSTATE_ISLAND_SLEEPING;
        }
        get sleepLinearVelocity() {
            return this._nativeColliderObject.getLinearSleepingThreshold();
        }
        set sleepLinearVelocity(e) {
            this._nativeColliderObject.setSleepingThresholds(e, this._nativeColliderObject.getAngularSleepingThreshold());
        }
        get sleepAngularVelocity() {
            return this._nativeColliderObject.getAngularSleepingThreshold();
        }
        set sleepAngularVelocity(e) {
            this._nativeColliderObject.setSleepingThresholds(this._nativeColliderObject.getLinearSleepingThreshold(), e);
        }
        _updateMass(e) {
            this._nativeColliderObject && this._colliderShape && (this._colliderShape._nativeShape.calculateLocalInertia(e, Vi._nativeInertia),
                this._nativeColliderObject.setMassProps(e, Vi._nativeInertia), this._nativeColliderObject.updateInertiaTensor());
        }
        _delegateMotionStateGetWorldTransform(e) {}
        _delegateMotionStateSetWorldTransform(e) {
            var t = this._rigidbody;
            t._simulation._updatedRigidbodies++;
            var r = fe._physics3D,
                i = r.wrapPointer(e, r.btTransform);
            t._updateTransformComponent(i);
        }
        _delegateMotionStateGetWorldTransformNative(e, t) {}
        _delegateMotionStateSetWorldTransformNative(e, t) {
            var r = e;
            r._simulation._updatedRigidbodies++;
            var i = fe._physics3D,
                n = i.wrapPointer(t, i.btTransform);
            r._updateTransformComponent(n);
        }
        _onScaleChange(e) {
            super._onScaleChange(e), this._updateMass(this._isKinematic ? 0 : this._mass);
        }
        _delegateMotionStateClear() {
            this._rigidbody = null;
        }
        _onAdded() {
            var e = fe._physics3D,
                t = new e.LayaMotionState();
            null != window.conch && e.LayaMotionState.prototype.setRigidbody ? (t.setRigidbody(this),
                    t.setNativeGetWorldTransform(this._delegateMotionStateGetWorldTransformNative),
                    t.setNativeSetWorldTransform(this._delegateMotionStateSetWorldTransformNative)) : (t.getWorldTransform = this._delegateMotionStateGetWorldTransform,
                    t.setWorldTransform = this._delegateMotionStateSetWorldTransform), t.clear = this._delegateMotionStateClear,
                t._rigidbody = this, this._nativeMotionState = t;
            var r = new e.btRigidBodyConstructionInfo(0, t, null, Vi._nativeVector3Zero),
                i = new e.btRigidBody(r);
            i.setUserIndex(this.id), this._nativeColliderObject = i, super._onAdded(), this.mass = this._mass,
                this.linearFactor = this._linearFactor, this.angularFactor = this._angularFactor,
                this.linearDamping = this._linearDamping, this.angularDamping = this._angularDamping,
                this.overrideGravity = this._overrideGravity, this.gravity = this._gravity, this.isKinematic = this._isKinematic,
                e.destroy(r);
        }
        _onShapeChange(e) {
            super._onShapeChange(e), this._isKinematic ? this._updateMass(0) : (this._nativeColliderObject.setCenterOfMassTransform(this._nativeColliderObject.getWorldTransform()),
                this._updateMass(this._mass));
        }
        _parse(e) {
            null != e.friction && (this.friction = e.friction), null != e.rollingFriction && (this.rollingFriction = e.rollingFriction),
                null != e.restitution && (this.restitution = e.restitution), null != e.isTrigger && (this.isTrigger = e.isTrigger),
                null != e.mass && (this.mass = e.mass), null != e.isKinematic && (this.isKinematic = e.isKinematic),
                null != e.linearDamping && (this.linearDamping = e.linearDamping), null != e.angularDamping && (this.angularDamping = e.angularDamping),
                null != e.overrideGravity && (this.overrideGravity = e.overrideGravity), e.gravity && (this.gravity.fromArray(e.gravity),
                    this.gravity = this.gravity), super._parse(e), this._parseShape(e.shapes);
        }
        _onDestroy() {
            var e = fe._physics3D;
            this._nativeMotionState.clear(), e.destroy(this._nativeMotionState), super._onDestroy(),
                this._nativeMotionState = null, this._gravity = null, this._totalTorque = null,
                this._linearVelocity = null, this._angularVelocity = null, this._linearFactor = null,
                this._angularFactor = null;
        }
        _addToSimulation() {
            this._simulation._addRigidBody(this, this._collisionGroup, this._detectCollisions ? this._canCollideWith : 0);
        }
        _removeFromSimulation() {
            this._simulation._removeRigidBody(this);
        }
        _cloneTo(e) {
            super._cloneTo(e);
            var t = e;
            t.isKinematic = this._isKinematic, t.mass = this._mass, t.gravity = this._gravity,
                t.angularDamping = this._angularDamping, t.linearDamping = this._linearDamping,
                t.overrideGravity = this._overrideGravity, t.linearVelocity = this._linearVelocity,
                t.angularVelocity = this._angularVelocity, t.linearFactor = this._linearFactor,
                t.angularFactor = this._angularFactor, t.detectCollisions = this._detectCollisions;
        }
        applyForce(e, t = null) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var r = Vi._nativeTempVector30;
            if (r.setValue(-e.x, e.y, e.z), t) {
                var i = Vi._nativeTempVector31;
                i.setValue(-t.x, t.y, t.z), this._nativeColliderObject.applyForce(r, i);
            } else this._nativeColliderObject.applyCentralForce(r);
        }
        applyTorque(e) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = Vi._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeColliderObject.applyTorque(t);
        }
        applyImpulse(e, t = null) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            Vi._nativeImpulse.setValue(-e.x, e.y, e.z), t ? (Vi._nativeImpulseOffset.setValue(-t.x, t.y, t.z),
                this._nativeColliderObject.applyImpulse(Vi._nativeImpulse, Vi._nativeImpulseOffset)) : this._nativeColliderObject.applyCentralImpulse(Vi._nativeImpulse);
        }
        applyTorqueImpulse(e) {
            if (null == this._nativeColliderObject) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            var t = Vi._nativeTempVector30;
            t.setValue(-e.x, e.y, e.z), this._nativeColliderObject.applyTorqueImpulse(t);
        }
        wakeUp() {
            this._nativeColliderObject && this._nativeColliderObject.activate(!1);
        }
        clearForces() {
            var e = this._nativeColliderObject;
            if (null == e) throw "Attempted to call a Physics function that is avaliable only when the Entity has been already added to the Scene.";
            e.clearForces();
            var t = Vi._nativeVector3Zero;
            e.setInterpolationLinearVelocity(t), e.setLinearVelocity(t), e.setInterpolationAngularVelocity(t),
                e.setAngularVelocity(t);
        }
    }
    Vi.TYPE_STATIC = 0, Vi.TYPE_DYNAMIC = 1, Vi.TYPE_KINEMATIC = 2, Vi._BT_DISABLE_WORLD_GRAVITY = 1,
        Vi._BT_ENABLE_GYROPSCOPIC_FORCE = 2;
    class wi extends Te {
        static __init__() {
            wi._nativeNormal = new fe._physics3D.btVector3(0, 0, 0);
        }
        constructor(e, t) {
            super(), this._normal = e, this._offset = t, this._type = Te.SHAPETYPES_STATICPLANE,
                wi._nativeNormal.setValue(-e.x, e.y, e.z), this._nativeShape = new fe._physics3D.btStaticPlaneShape(wi._nativeNormal, t);
        }
        clone() {
            var e = new wi(this._normal, this._offset);
            return this.cloneTo(e), e;
        }
    }
    class bi {
        static __init__() {}
        static _createMesh(e, r, i) {
            var n = t.LayaGL.instance,
                a = new Ci(),
                s = new Ii(a),
                o = new d(4 * r.length, n.STATIC_DRAW, !0);
            o.vertexDeclaration = e, o.setData(r.buffer), a._vertexBuffer = o, a._vertexCount += o.vertexCount;
            var l = new c(c.INDEXTYPE_USHORT, i.length, n.STATIC_DRAW, !0);
            l.setData(i), a._indexBuffer = l;
            a._setBuffer(o, l), s._vertexBuffer = o, s._indexBuffer = l, s._setIndexRange(0, l.indexCount);
            var _ = s._subIndexBufferStart,
                h = s._subIndexBufferCount,
                u = s._boneIndicesList;
            _.length = 1, h.length = 1, u.length = 1, _[0] = 0, h[0] = l.indexCount;
            var f = [];
            f.push(s), a._setSubMeshes(f);
            var E = o._byteLength + l._byteLength;
            return a._setCPUMemory(E), a._setGPUMemory(E), a;
        }
        static createBox(e = 1, t = 1, r = 1) {
            var i = v.getVertexDeclaration("POSITION,NORMAL,UV"),
                n = e / 2,
                a = t / 2,
                s = r / 2,
                o = new Float32Array([-n, a, -s, 0, 1, 0, 0, 0, n, a, -s, 0, 1, 0, 1, 0, n, a, s, 0, 1, 0, 1, 1, -n, a, s, 0, 1, 0, 0, 1, -n, -a, -s, 0, -1, 0, 0, 1, n, -a, -s, 0, -1, 0, 1, 1, n, -a, s, 0, -1, 0, 1, 0, -n, -a, s, 0, -1, 0, 0, 0, -n, a, -s, -1, 0, 0, 0, 0, -n, a, s, -1, 0, 0, 1, 0, -n, -a, s, -1, 0, 0, 1, 1, -n, -a, -s, -1, 0, 0, 0, 1, n, a, -s, 1, 0, 0, 1, 0, n, a, s, 1, 0, 0, 0, 0, n, -a, s, 1, 0, 0, 0, 1, n, -a, -s, 1, 0, 0, 1, 1, -n, a, s, 0, 0, 1, 0, 0, n, a, s, 0, 0, 1, 1, 0, n, -a, s, 0, 0, 1, 1, 1, -n, -a, s, 0, 0, 1, 0, 1, -n, a, -s, 0, 0, -1, 1, 0, n, a, -s, 0, 0, -1, 0, 0, n, -a, -s, 0, 0, -1, 0, 1, -n, -a, -s, 0, 0, -1, 1, 1]),
                l = new Uint16Array([0, 1, 2, 2, 3, 0, 4, 7, 6, 6, 5, 4, 8, 9, 10, 10, 11, 8, 12, 15, 14, 14, 13, 12, 16, 17, 18, 18, 19, 16, 20, 23, 22, 22, 21, 20]);
            return bi._createMesh(i, o, l);
        }
        static createCapsule(e = .5, t = 2, r = 16, i = 32) {
            var n, a, s = (r + 1) * (i + 1) * 2 + 2 * (i + 1),
                o = 3 * r * (i + 1) * 2 * 2 + 2 * i * 3,
                l = v.getVertexDeclaration("POSITION,NORMAL,UV"),
                _ = l.vertexStride / 4,
                h = new Float32Array(s * _),
                c = new Uint16Array(o),
                d = Math.PI / 2 / r,
                u = 2 * Math.PI / i,
                f = t / 2 - e,
                E = 0,
                T = 0,
                m = 0,
                p = 0,
                g = 0,
                S = 0;
            for (n = 0; n <= r; n++)
                for (a = 0; a <= i; a++) E = e * Math.cos(n * d) * Math.cos(a * u + Math.PI),
                    T = e * Math.sin(n * d), m = e * Math.cos(n * d) * Math.sin(a * u + Math.PI), h[p++] = E,
                    h[p++] = T + f, h[p++] = m, h[p++] = E, h[p++] = T, h[p++] = m, h[p++] = 1 - a / i,
                    h[p++] = (1 - n / r) * (Math.PI * e / 2 / (t + Math.PI * e)), n < r && (c[g++] = n * (i + 1) + a + (i + 1),
                        c[g++] = n * (i + 1) + a, c[g++] = n * (i + 1) + a + 1, c[g++] = n * (i + 1) + a + i,
                        c[g++] = n * (i + 1) + a, c[g++] = n * (i + 1) + a + (i + 1));
            for (S += (r + 1) * (i + 1), n = 0; n <= r; n++)
                for (a = 0; a <= i; a++) E = e * Math.cos(n * d) * Math.cos(a * u + Math.PI),
                    T = e * Math.sin(-n * d), m = e * Math.cos(n * d) * Math.sin(a * u + Math.PI), h[p++] = E,
                    h[p++] = T - f, h[p++] = m, h[p++] = E, h[p++] = T, h[p++] = m, h[p++] = 1 - a / i,
                    h[p++] = (n / r * (Math.PI * e / 2) + (t + Math.PI * e / 2)) / (t + Math.PI * e),
                    n < r && (c[g++] = S + n * (i + 1) + a, c[g++] = S + n * (i + 1) + a + (i + 1),
                        c[g++] = S + n * (i + 1) + a + 1, c[g++] = S + n * (i + 1) + a, c[g++] = S + n * (i + 1) + a + i,
                        c[g++] = S + n * (i + 1) + a + (i + 1));
            for (S += (r + 1) * (i + 1), a = 0; a <= i; a++) E = e * Math.cos(a * u + Math.PI),
                T = f, m = e * Math.sin(a * u + Math.PI), h[p++] = E, h[p + 8 * (i + 1) - 1] = E,
                h[p++] = T, h[p + 8 * (i + 1) - 1] = -T, h[p++] = m, h[p + 8 * (i + 1) - 1] = m,
                h[p++] = E, h[p + 8 * (i + 1) - 1] = E, h[p++] = 0, h[p + 8 * (i + 1) - 1] = 0,
                h[p++] = m, h[p + 8 * (i + 1) - 1] = m, h[p++] = 1 - 1 * a / i, h[p + 8 * (i + 1) - 1] = 1 - 1 * a / i,
                h[p++] = Math.PI * e / 2 / (t + Math.PI * e), h[p + 8 * (i + 1) - 1] = (Math.PI * e / 2 + t) / (t + Math.PI * e);
            for (a = 0; a < i; a++) c[g++] = a + S + (i + 1), c[g++] = a + S + 1, c[g++] = a + S,
                c[g++] = a + S + (i + 1), c[g++] = a + S + (i + 1) + 1, c[g++] = a + S + 1;
            return S += 2 * (i + 1), bi._createMesh(l, h, c);
        }
        static createCone(e = .5, t = 1, r = 32) {
            for (var i, n = r + 1 + 1 + 2 * (r + 1), s = 6 * r + 3 * r, o = v.getVertexDeclaration("POSITION,NORMAL,UV"), l = o.vertexStride / 4, _ = new Float32Array(n * l), h = new Uint16Array(s), c = 2 * Math.PI / r, d = t / 2, u = 0, f = 0, T = 0, m = 0, p = 0, g = new a(), S = new a(0, -1, 0), R = new a(0, d, 0), A = new a(), D = new a(), I = new E(), x = new a(), M = 0, L = 0, C = 0; C <= r; C++) u = C * c,
                T = Math.cos(u + Math.PI) * e, m = d, p = Math.sin(u + Math.PI) * e, _[M++] = 0,
                _[M + 8 * (r + 1) - 1] = T, _[M++] = m, _[M + 8 * (r + 1) - 1] = -m, _[M++] = 0,
                _[M + 8 * (r + 1) - 1] = p, g.x = T, g.y = 0, g.z = p, A.x = T, A.y = -m, A.z = p,
                a.subtract(A, R, D), a.normalize(D, D), i = Math.acos(a.dot(S, D)), a.cross(S, D, x),
                a.normalize(x, x), E.createFromAxisAngle(x, i, I), a.normalize(g, g), a.transformQuat(g, I, g),
                a.normalize(g, g), _[M++] = g.x, _[M + 8 * (r + 1) - 1] = g.x, _[M++] = g.y, _[M + 8 * (r + 1) - 1] = g.y,
                _[M++] = g.z, _[M + 8 * (r + 1) - 1] = g.z, _[M++] = 1 - 1 * C / r, _[M + 8 * (r + 1) - 1] = 1 - 1 * C / r,
                _[M++] = 0, _[M + 8 * (r + 1) - 1] = 1;
            M += 8 * (r + 1);
            for (var y = 0; y < r; y++) h[L++] = y + f + (r + 1), h[L++] = y + f + 1, h[L++] = y + f,
                h[L++] = y + f + (r + 1), h[L++] = y + f + (r + 1) + 1, h[L++] = y + f + 1;
            f += 2 * (r + 1);
            for (var O = 0; O <= r; O++) 0 === O && (_[M++] = 0, _[M++] = -d, _[M++] = 0, _[M++] = 0,
                    _[M++] = -1, _[M++] = 0, _[M++] = .5, _[M++] = .5), u = O * c, T = Math.cos(u + Math.PI) * e,
                m = -d, p = Math.sin(u + Math.PI) * e, _[M++] = T, _[M++] = m, _[M++] = p, _[M++] = 0,
                _[M++] = -1, _[M++] = 0, _[M++] = .5 + .5 * Math.cos(u), _[M++] = .5 + .5 * Math.sin(u);
            for (var N = 0; N < r; N++) h[L++] = 0 + f, h[L++] = N + 2 + f, h[L++] = N + 1 + f;
            return f += r + 1 + 1, bi._createMesh(o, _, h);
        }
        static createCylinder(e = .5, t = 2, r = 32) {
            for (var i = r + 1 + 1 + 2 * (r + 1) + (r + 1 + 1), n = 3 * r + 6 * r + 3 * r, a = v.getVertexDeclaration("POSITION,NORMAL,UV"), s = a.vertexStride / 4, o = new Float32Array(i * s), l = new Uint16Array(n), _ = 2 * Math.PI / r, h = t / 2, c = 0, d = 0, u = 0, f = 0, E = 0, T = 0, m = 0, p = 0; p <= r; p++) 0 === p && (o[T++] = 0,
                    o[T++] = h, o[T++] = 0, o[T++] = 0, o[T++] = 1, o[T++] = 0, o[T++] = .5, o[T++] = .5),
                c = p * _, u = Math.cos(c) * e, f = h, E = Math.sin(c) * e, o[T++] = u, o[T++] = f,
                o[T++] = E, o[T++] = 0, o[T++] = 1, o[T++] = 0, o[T++] = .5 + .5 * Math.cos(c),
                o[T++] = .5 + .5 * Math.sin(c);
            for (var g = 0; g < r; g++) l[m++] = 0, l[m++] = g + 1, l[m++] = g + 2;
            d += r + 1 + 1;
            for (var S = 0; S <= r; S++) c = S * _, u = Math.cos(c + Math.PI) * e, f = h, E = Math.sin(c + Math.PI) * e,
                o[T++] = u, o[T + 8 * (r + 1) - 1] = u, o[T++] = f, o[T + 8 * (r + 1) - 1] = -f,
                o[T++] = E, o[T + 8 * (r + 1) - 1] = E, o[T++] = u, o[T + 8 * (r + 1) - 1] = u,
                o[T++] = 0, o[T + 8 * (r + 1) - 1] = 0, o[T++] = E, o[T + 8 * (r + 1) - 1] = E,
                o[T++] = 1 - 1 * S / r, o[T + 8 * (r + 1) - 1] = 1 - 1 * S / r, o[T++] = 0, o[T + 8 * (r + 1) - 1] = 1;
            T += 8 * (r + 1);
            for (var R = 0; R < r; R++) l[m++] = R + d + (r + 1), l[m++] = R + d + 1, l[m++] = R + d,
                l[m++] = R + d + (r + 1), l[m++] = R + d + (r + 1) + 1, l[m++] = R + d + 1;
            d += 2 * (r + 1);
            for (var A = 0; A <= r; A++) 0 === A && (o[T++] = 0, o[T++] = -h, o[T++] = 0, o[T++] = 0,
                    o[T++] = -1, o[T++] = 0, o[T++] = .5, o[T++] = .5), c = A * _, u = Math.cos(c + Math.PI) * e,
                f = -h, E = Math.sin(c + Math.PI) * e, o[T++] = u, o[T++] = f, o[T++] = E, o[T++] = 0,
                o[T++] = -1, o[T++] = 0, o[T++] = .5 + .5 * Math.cos(c), o[T++] = .5 + .5 * Math.sin(c);
            for (var D = 0; D < r; D++) l[m++] = 0 + d, l[m++] = D + 2 + d, l[m++] = D + 1 + d;
            return d += r + 1 + 1, bi._createMesh(a, o, l);
        }
        static createPlane(e = 10, t = 10, r = 10, i = 10) {
            for (var n = (r + 1) * (i + 1), a = new Uint16Array(r * i * 2 * 3), s = v.getVertexDeclaration("POSITION,NORMAL,UV"), o = s.vertexStride / 4, l = new Float32Array(n * o), _ = e / 2, h = t / 2, c = e / r, d = t / i, u = 0, f = 0; f <= i; f++)
                for (var E = 0; E <= r; E++) l[u++] = E * c - _,
                    l[u++] = 0, l[u++] = f * d - h, l[u++] = 0, l[u++] = 1, l[u++] = 0, l[u++] = 1 * E / r,
                    l[u++] = 1 * f / i;
            var T = 0;
            for (f = 0; f < i; f++)
                for (E = 0; E < r; E++) a[T++] = (f + 1) * (r + 1) + E,
                    a[T++] = f * (r + 1) + E, a[T++] = (f + 1) * (r + 1) + E + 1, a[T++] = f * (r + 1) + E,
                    a[T++] = f * (r + 1) + E + 1, a[T++] = (f + 1) * (r + 1) + E + 1;
            return bi._createMesh(s, l, a);
        }
        static createQuad(e = 1, t = 1) {
            var r = v.getVertexDeclaration("POSITION,NORMAL,UV"),
                i = (r.vertexStride, e / 2),
                n = t / 2,
                a = new Float32Array([i, n, 0, 0, 0, 1, 0, 0, i, n, 0, 0, 0, 1, 1, 0, -i, -n, 0, 0, 0, 1, 0, 1, i, -n, 0, 0, 0, 1, 1, 1]),
                s = new Uint16Array([0, 1, 2, 3, 2, 1]);
            return bi._createMesh(r, a, s);
        }
        static createSphere(e = .5, t = 32, r = 32) {
            var i = (t + 1) * (r + 1),
                n = 3 * t * (r + 1) * 2,
                a = new Uint16Array(n),
                s = v.getVertexDeclaration("POSITION,NORMAL,UV"),
                o = s.vertexStride / 4,
                l = new Float32Array(i * o),
                _ = Math.PI / t,
                h = 2 * Math.PI / r,
                c = 0;
            i = 0, n = 0;
            for (var d = 0; d < t + 1; d++)
                for (var u = Math.sin(d * _), f = Math.cos(d * _), E = 0; E < r + 1; E++) {
                    var T = u * Math.sin(E * h + 1 * Math.PI / 2),
                        m = u * Math.cos(E * h + 1 * Math.PI / 2);
                    l[i + 0] = T * e, l[i + 1] = f * e, l[i + 2] = m * e, l[i + 3] = T, l[i + 4] = f,
                        l[i + 5] = m, l[i + 6] = E / r, l[i + 7] = d / t, i += o, d != t - 1 && (a[n++] = c + (r + 1),
                            a[n++] = c, a[n++] = c + 1, a[n++] = c + r, a[n++] = c, a[n++] = c + (r + 1), c++);
                }
            return bi._createMesh(s, l, a);
        }
    }
    class Fi {
        constructor(e, t, r, i) {
            this._position = e, this._normal = t, this._textureCoord0 = r, this._textureCoord1 = i;
        }
        static __init__() {
            Fi._vertexDeclaration = new g(40, [new S(0, u.Vector3, Fi.TERRAIN_POSITION0), new S(12, u.Vector3, Fi.TERRAIN_NORMAL0), new S(24, u.Vector2, Fi.TERRAIN_TEXTURECOORDINATE0), new S(32, u.Vector2, Fi.TERRAIN_TEXTURECOORDINATE1)]);
        }
        static get vertexDeclaration() {
            return Fi._vertexDeclaration;
        }
        get position() {
            return this._position;
        }
        get normal() {
            return this._normal;
        }
        get textureCoord0() {
            return this._textureCoord0;
        }
        get textureCoord1() {
            return this._textureCoord1;
        }
        get vertexDeclaration() {
            return Fi._vertexDeclaration;
        }
    }
    Fi.TERRAIN_POSITION0 = 0, Fi.TERRAIN_NORMAL0 = 1, Fi.TERRAIN_TEXTURECOORDINATE0 = 2,
        Fi.TERRAIN_TEXTURECOORDINATE1 = 3;
    class Bi {
        constructor() {}
        static get enbalePhysics() {
            return fe._enbalePhysics;
        }
        static _cancelLoadByUrl(e) {
            t.Laya.loader.cancelLoadByUrl(e), Bi._innerFirstLevelLoaderManager.cancelLoadByUrl(e),
                Bi._innerSecondLevelLoaderManager.cancelLoadByUrl(e), Bi._innerThirdLevelLoaderManager.cancelLoadByUrl(e),
                Bi._innerFourthLevelLoaderManager.cancelLoadByUrl(e);
        }
        static _changeWebGLSize(e, r) {
            t.WebGL.onStageResize(e, r), J.clientWidth = e, J.clientHeight = r;
        }
        static __init__(e, r, i) {
            if (t.Config.isAntialias = i.isAntialias, t.Config.isAlpha = i.isAlpha, t.Config.premultipliedAlpha = i.premultipliedAlpha,
                t.Config.isStencil = i.isStencil, t.WebGL.enable()) {
                t.RunDriver.changeWebGLSize = Bi._changeWebGLSize, t.Render.is3DMode = !0, t.Laya.init(e, r),
                    t.Render.supportWebGLPlusRendering || (t.LayaGL.instance = t.WebGLContext.mainContext,
                        t.LayaGL.instance.createCommandEncoder = function(e = 128, r = 64, i = !1) {
                            return new t.CommandEncoder(this, e, r, i);
                        }), o.Scene3D = oi, o.MeshRenderStaticBatchManager = ue, o.MeshRenderDynamicBatchManager = ce,
                    o.SubMeshDynamicBatch = R, o.Laya3D = Bi, o.Matrix4x4 = T, Bi.enableNative3D(),
                    u.__init__(), v.__init__(), rt.__init__(), it.__init__(), Pt.__init__(), Jt.__init__(),
                    Fi.__init__(), $r.__init__(), D.__init__(), R.__init__(), fe._physics3D = window.Physics3D,
                    fe._physics3D && (wi.__init__(), Te.__init__(), ge.__init__(), De.__init__(), ye.__init__(),
                        me.__init__(), ve.__init__(), Pi.__init__(), Vi.__init__()), Ci.__init__(), bi.__init__(),
                    b.__init__(), F.__init__(), Ye.__init__(), Yt.__init__(), xt.__init__(), rr.__init__(),
                    bt.__init__(), oi.__init__(), ue.__init__(), Ge.__initDefine__(), He.__initDefine__(),
                    Gt.__initDefine__(), Ut.__initDefine__(), zt.__initDefine__(), Ht.__initDefine__(),
                    Zt.__initDefine__(), Ft.__initDefine__(), Wt.__initDefine__(), qe.__initDefine__(),
                    Bt.__initDefine__(), Jr.__initDefine__(), Di.__initDefine__(), Qr.__init__(), te.__init__(),
                    t.ClassUtils.regClass("Laya.EffectMaterial", Ft), t.ClassUtils.regClass("Laya.UnlitMaterial", Ht),
                    t.ClassUtils.regClass("Laya.BlinnPhongMaterial", He), t.ClassUtils.regClass("Laya.SkyProceduralMaterial", zt),
                    t.ClassUtils.regClass("Laya.PBRStandardMaterial", Gt), t.ClassUtils.regClass("Laya.PBRSpecularMaterial", Ut),
                    t.ClassUtils.regClass("Laya.SkyBoxMaterial", Di), t.ClassUtils.regClass("Laya.WaterPrimaryMaterial", Wt),
                    t.ClassUtils.regClass("Laya.ExtendTerrainMaterial", Bt), t.ClassUtils.regClass("Laya.ShurikenParticleMaterial", qe),
                    t.ClassUtils.regClass("Laya.TrailMaterial", Zt), t.ClassUtils.regClass("Laya.PhysicsCollider", Ni),
                    t.ClassUtils.regClass("Laya.Rigidbody3D", Vi), t.ClassUtils.regClass("Laya.CharacterController", Pi),
                    t.ClassUtils.regClass("Laya.Animator", V), t.ClassUtils.regClass("PhysicsCollider", Ni),
                    t.ClassUtils.regClass("CharacterController", Pi), t.ClassUtils.regClass("Animator", V),
                    t.ClassUtils.regClass("Rigidbody3D", Vi), Jr.defaultMaterial = new Jr(), He.defaultMaterial = new He(),
                    Ft.defaultMaterial = new Ft(), Gt.defaultMaterial = new Gt(), Ut.defaultMaterial = new Ut(),
                    Ht.defaultMaterial = new Ht(), qe.defaultMaterial = new qe(), Zt.defaultMaterial = new Zt(),
                    zt.defaultMaterial = new zt(), Di.defaultMaterial = new Di(), Wt.defaultMaterial = new Wt(),
                    Jr.defaultMaterial.lock = !0, He.defaultMaterial.lock = !0, Ft.defaultMaterial.lock = !0,
                    Gt.defaultMaterial.lock = !0, Ut.defaultMaterial.lock = !0, Ht.defaultMaterial.lock = !0,
                    qe.defaultMaterial.lock = !0, Zt.defaultMaterial.lock = !0, zt.defaultMaterial.lock = !0,
                    Di.defaultMaterial.lock = !0, Wt.defaultMaterial.lock = !0, t.Texture2D.__init__(),
                    yi.__init__(), q.__init__(), Vt.__init__(), $.__init__(), ee.__init__(), U.__init__(),
                    mi.__init__();
                var n = t.LoaderManager.createMap;
                n.lh = [Bi.HIERARCHY, li._parse], n.ls = [Bi.HIERARCHY, li._parseScene], n.lm = [Bi.MESH, Ci._parse],
                    n.lmat = [Bi.MATERIAL, Ge._parse], n.ltc = [Bi.TEXTURECUBE, yi._parse], n.jpg = [Bi.TEXTURE2D, t.Texture2D._parse],
                    n.jpeg = [Bi.TEXTURE2D, t.Texture2D._parse], n.bmp = [Bi.TEXTURE2D, t.Texture2D._parse],
                    n.gif = [Bi.TEXTURE2D, t.Texture2D._parse], n.png = [Bi.TEXTURE2D, t.Texture2D._parse],
                    n.dds = [Bi.TEXTURE2D, t.Texture2D._parse], n.ktx = [Bi.TEXTURE2D, t.Texture2D._parse],
                    n.pvr = [Bi.TEXTURE2D, t.Texture2D._parse], n.lani = [Bi.ANIMATIONCLIP, Si._parse],
                    n.lav = [Bi.AVATAR, Ai._parse];
                var a = t.Loader.parserMap;
                a[Bi.HIERARCHY] = Bi._loadHierarchy, a[Bi.MESH] = Bi._loadMesh, a[Bi.MATERIAL] = Bi._loadMaterial,
                    a[Bi.TEXTURECUBE] = Bi._loadTextureCube, a[Bi.TEXTURE2D] = Bi._loadTexture2D, a[Bi.ANIMATIONCLIP] = Bi._loadAnimationClip,
                    a[Bi.AVATAR] = Bi._loadAvatar, Bi._innerFirstLevelLoaderManager.on(t.Event.ERROR, null, Bi._eventLoadManagerError),
                    Bi._innerSecondLevelLoaderManager.on(t.Event.ERROR, null, Bi._eventLoadManagerError),
                    Bi._innerThirdLevelLoaderManager.on(t.Event.ERROR, null, Bi._eventLoadManagerError),
                    Bi._innerFourthLevelLoaderManager.on(t.Event.ERROR, null, Bi._eventLoadManagerError);
            } else alert("Laya3D init error,must support webGL!");
        }
        static enableNative3D() {
            if (t.Render.isConchApp) {
                var e = p,
                    r = nr,
                    i = Xt,
                    n = Ai,
                    a = U;
                if (t.Render.supportWebGLPlusRendering && (e.prototype._initData = e.prototype._initDataForNative,
                        e.prototype.setBool = e.prototype.setBoolForNative, e.prototype.getBool = e.prototype.getBoolForNative,
                        e.prototype.setInt = e.prototype.setIntForNative, e.prototype.getInt = e.prototype.getIntForNative,
                        e.prototype.setNumber = e.prototype.setNumberForNative, e.prototype.getNumber = e.prototype.getNumberForNative,
                        e.prototype.setVector = e.prototype.setVectorForNative, e.prototype.getVector = e.prototype.getVectorForNative,
                        e.prototype.setVector2 = e.prototype.setVector2ForNative, e.prototype.getVector2 = e.prototype.getVector2ForNative,
                        e.prototype.setVector3 = e.prototype.setVector3ForNative, e.prototype.getVector3 = e.prototype.getVector3ForNative,
                        e.prototype.setQuaternion = e.prototype.setQuaternionForNative, e.prototype.getQuaternion = e.prototype.getQuaternionForNative,
                        e.prototype.setMatrix4x4 = e.prototype.setMatrix4x4ForNative, e.prototype.getMatrix4x4 = e.prototype.getMatrix4x4ForNative,
                        e.prototype.setBuffer = e.prototype.setBufferForNative, e.prototype.getBuffer = e.prototype.getBufferForNative,
                        e.prototype.setTexture = e.prototype.setTextureForNative, e.prototype.getTexture = e.prototype.getTextureForNative,
                        e.prototype.setAttribute = e.prototype.setAttributeForNative, e.prototype.getAttribute = e.prototype.getAttributeForNative,
                        e.prototype.cloneTo = e.prototype.cloneToForNative, e.prototype.getData = e.prototype.getDataForNative,
                        r.prototype._uniformMatrix2fv = r.prototype._uniformMatrix2fvForNative, r.prototype._uniformMatrix3fv = r.prototype._uniformMatrix3fvForNative,
                        r.prototype._uniformMatrix4fv = r.prototype._uniformMatrix4fvForNative), t.Render.supportWebGLPlusCulling && (a.renderObjectCulling = U.renderObjectCullingNative),
                    t.Render.supportWebGLPlusAnimation) {
                    n.prototype._cloneDatasToAnimator = n.prototype._cloneDatasToAnimatorNative;
                    var s = Si;
                    s.prototype._evaluateClipDatasRealTime = s.prototype._evaluateClipDatasRealTimeForNative,
                        i.prototype._computeSkinnedData = i.prototype._computeSkinnedDataForNative;
                }
            }
            t.WebGL.shaderHighPrecision = !1;
            var o = t.LayaGL.instance;
            o.getShaderPrecisionFormat(o.FRAGMENT_SHADER, o.HIGH_FLOAT).precision ? t.WebGL.shaderHighPrecision = !0 : t.WebGL.shaderHighPrecision = !1;
        }
        static formatRelativePath(e, t) {
            var r;
            if (r = e + t, "." === t.charAt(0)) {
                for (var i = r.split("/"), n = 0, a = i.length; n < a; n++)
                    if (".." == i[n]) {
                        var s = n - 1;
                        s > 0 && ".." !== i[s] && (i.splice(s, 2), n -= 2);
                    }
                r = i.join("/");
            }
            return r;
        }
        static _endLoad(e, r = null, i = null) {
            if (i)
                for (var n = 0, a = i.length; n < a; n++) {
                    var s = t.Loader.getRes(i[n]);
                    s && s._removeReference();
                }
            e.endLoad(r);
        }
        static _eventLoadManagerError(e) {
            t.Laya.loader.event(t.Event.ERROR, e);
        }
        static _addHierarchyInnerUrls(e, t, r, i, n, a, s = null, o = null) {
            var l = Bi.formatRelativePath(i, n);
            return r && (l += r), e.push({
                url: l,
                type: a,
                constructParams: s,
                propertyParams: o
            }), t.push(l), l;
        }
        static _getSprite3DHierarchyInnerUrls(e, t, r, i, n, a, s, o) {
            var l, _, h = e.props;
            switch (e.type) {
                case "Scene3D":
                    var c = h.lightmaps;
                    for (l = 0, _ = c.length; l < _; l++) {
                        var d = c[l];
                        d.path = Bi._addHierarchyInnerUrls(n, a, s, o, d.path, Bi.TEXTURE2D, d.constructParams, d.propertyParams);
                    }
                    var u = h.reflectionTexture;
                    if (u && (h.reflectionTexture = Bi._addHierarchyInnerUrls(i, a, s, o, u, Bi.TEXTURECUBE)),
                        h.sky) {
                        var f = h.sky.material;
                        f && (f.path = Bi._addHierarchyInnerUrls(r, a, s, o, f.path, Bi.MATERIAL));
                    }
                    break;

                case "Camera":
                    var E = h.skyboxMaterial;
                    E && (E.path = Bi._addHierarchyInnerUrls(r, a, s, o, E.path, Bi.MATERIAL));
                    break;

                case "TrailSprite3D":
                case "MeshSprite3D":
                case "SkinnedMeshSprite3D":
                    var T = h.meshPath;
                    T && (h.meshPath = Bi._addHierarchyInnerUrls(t, a, s, o, T, Bi.MESH));
                    var m = h.materials;
                    if (m)
                        for (l = 0, _ = m.length; l < _; l++) m[l].path = Bi._addHierarchyInnerUrls(r, a, s, o, m[l].path, Bi.MATERIAL);
                    break;

                case "ShuriKenParticle3D":
                    var p = h.meshPath;
                    p && (h.meshPath = Bi._addHierarchyInnerUrls(t, a, s, o, p, Bi.MESH)), h.material.path = Bi._addHierarchyInnerUrls(r, a, s, o, h.material.path, Bi.MATERIAL);
                    break;

                case "Terrain":
                    Bi._addHierarchyInnerUrls(n, a, s, o, h.dataPath, Bi.TERRAINRES);
            }
            var g = e.components;
            if (g)
                for (var S = 0, v = g.length; S < v; S++) {
                    var R = g[S];
                    switch (R.type) {
                        case "Animator":
                            R.avatarPath;
                            var A = R.avatar;
                            A && (A.path = Bi._addHierarchyInnerUrls(n, a, s, o, A.path, Bi.AVATAR));
                            var D = R.clipPaths;
                            if (D)
                                for (l = 0, _ = D.length; l < _; l++) D[l] = Bi._addHierarchyInnerUrls(n, a, s, o, D[l], Bi.ANIMATIONCLIP);
                            else {
                                var I = R.layers;
                                for (l = 0; l < I.length; l++)
                                    for (var x = I[l].states, M = 0, L = x.length; M < L; M++) {
                                        var C = x[M].clipPath;
                                        C && (x[M].clipPath = Bi._addHierarchyInnerUrls(n, a, s, o, C, Bi.ANIMATIONCLIP));
                                    }
                            }
                            break;

                        case "PhysicsCollider":
                        case "Rigidbody3D":
                        case "CharacterController":
                            var y = R.shapes;
                            for (l = 0; l < y.length; l++) {
                                var O = y[l];
                                if ("MeshColliderShape" === O.type) {
                                    var N = O.mesh;
                                    N && (O.mesh = Bi._addHierarchyInnerUrls(t, a, s, o, N, Bi.MESH));
                                }
                            }
                    }
                }
            var P = e.child;
            for (l = 0, _ = P.length; l < _; l++) Bi._getSprite3DHierarchyInnerUrls(P[l], t, r, i, n, a, s, o);
        }
        static _loadHierarchy(e) {
            e.on(t.Event.LOADED, null, Bi._onHierarchylhLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _onHierarchylhLoaded(e, r) {
            var i = e.url,
                n = M.getURLVerion(i),
                a = t.URL.getPath(i),
                s = [],
                o = [],
                l = [],
                _ = [],
                h = [];
            Bi._getSprite3DHierarchyInnerUrls(r.data, s, o, l, _, h, n, a);
            var c = s.length + o.length + _.length,
                d = c + 1,
                u = 1 / d;
            if (Bi._onProcessChange(e, 0, u, 1), _.length > 0) {
                var f = c / d,
                    E = t.Handler.create(null, Bi._onProcessChange, [e, u, f], !1);
                Bi._innerFourthLevelLoaderManager._create(_, !1, t.Handler.create(null, Bi._onHierarchyInnerForthLevResouLoaded, [e, E, r, h, s, o, l, u + f * _.length, f]), E, null, null, null, 1, !0);
            } else Bi._onHierarchyInnerForthLevResouLoaded(e, null, r, h, s, o, l, u, f);
        }
        static _onHierarchyInnerForthLevResouLoaded(e, r, i, n, a, s, o, l, _) {
            if (r && r.recover(), o.length > 0) {
                var h = t.Handler.create(null, Bi._onProcessChange, [e, l, _], !1);
                Bi._innerThirdLevelLoaderManager._create(o, !1, t.Handler.create(null, Bi._onHierarchyInnerThirdLevResouLoaded, [e, h, i, n, a, s, l + _ * s.length, _]), r, null, null, null, 1, !0);
            } else Bi._onHierarchyInnerThirdLevResouLoaded(e, null, i, n, a, s, l, _);
        }
        static _onHierarchyInnerThirdLevResouLoaded(e, r, i, n, a, s, o, l) {
            if (r && r.recover(), s.length > 0) {
                var _ = t.Handler.create(null, Bi._onProcessChange, [e, o, l], !1);
                Bi._innerSecondLevelLoaderManager._create(s, !1, t.Handler.create(null, Bi._onHierarchyInnerSecondLevResouLoaded, [e, _, i, n, a, o + l * s.length, l]), r, null, null, null, 1, !0);
            } else Bi._onHierarchyInnerSecondLevResouLoaded(e, null, i, n, a, o, l);
        }
        static _onHierarchyInnerSecondLevResouLoaded(e, r, i, n, a, s, o) {
            if (r && r.recover(), a.length > 0) {
                var l = t.Handler.create(null, Bi._onProcessChange, [e, s, o], !1);
                Bi._innerFirstLevelLoaderManager._create(a, !1, t.Handler.create(null, Bi._onHierarchyInnerFirstLevResouLoaded, [e, l, i, n]), r, null, null, null, 1, !0);
            } else Bi._onHierarchyInnerFirstLevResouLoaded(e, null, i, n);
        }
        static _onHierarchyInnerFirstLevResouLoaded(e, t, r, i) {
            t && t.recover(), e._cache = e._createCache;
            var n = "Scene3D" === r.data.type ? li._parseScene(r, e._propertyParams, e._constructParams) : li._parse(r, e._propertyParams, e._constructParams);
            Bi._endLoad(e, n, i);
        }
        static _loadMesh(e) {
            e.on(t.Event.LOADED, null, Bi._onMeshLmLoaded, [e]), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
        }
        static _onMeshLmLoaded(e, t) {
            e._cache = e._createCache;
            var r = Ci._parse(t, e._propertyParams, e._constructParams);
            Bi._endLoad(e, r);
        }
        static _loadMaterial(e) {
            e.on(t.Event.LOADED, null, Bi._onMaterilLmatLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _onMaterilLmatLoaded(e, r) {
            var i, n = e.url,
                a = M.getURLVerion(n),
                s = t.URL.getPath(n),
                o = [],
                l = [];
            r.customProps;
            switch (r.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    var _, h, c = r.props.textures;
                    if (c)
                        for (_ = 0, h = c.length; _ < h; _++) {
                            var d = c[_],
                                u = d.path;
                            u && (i = Bi.formatRelativePath(s, u), a && (i += a), o.push({
                                url: i,
                                constructParams: d.constructParams,
                                propertyParams: d.propertyParams
                            }), l.push(i), d.path = i);
                        }
                    break;

                default:
                    throw new Error("Laya3D:unkonwn version.");
            }
            var f = o.length,
                E = f + 1,
                T = 1 / E;
            if (Bi._onProcessChange(e, 0, T, 1), f > 0) {
                var m = t.Handler.create(null, Bi._onProcessChange, [e, T, f / E], !1);
                Bi._innerFourthLevelLoaderManager._create(o, !1, t.Handler.create(null, Bi._onMateialTexturesLoaded, [e, m, r, l]), m, null, null, null, 1, !0);
            } else Bi._onMateialTexturesLoaded(e, null, r, null);
        }
        static _onMateialTexturesLoaded(e, t, r, i) {
            e._cache = e._createCache;
            var n = Ge._parse(r, e._propertyParams, e._constructParams);
            Bi._endLoad(e, n, i), t && t.recover();
        }
        static _loadAvatar(e) {
            e.on(t.Event.LOADED, null, function(t) {
                e._cache = e._createCache;
                var r = Ai._parse(t, e._propertyParams, e._constructParams);
                Bi._endLoad(e, r);
            }), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _loadAnimationClip(e) {
            e.on(t.Event.LOADED, null, function(t) {
                e._cache = e._createCache;
                var r = Si._parse(t, e._propertyParams, e._constructParams);
                Bi._endLoad(e, r);
            }), e.load(e.url, t.Loader.BUFFER, !1, null, !0);
        }
        static _loadTexture2D(e) {
            var r, i = e.url,
                n = i.lastIndexOf(".") + 1,
                a = i.indexOf("?"),
                s = -1 == a ? i.length : a;
            switch (i.substr(n, s - n)) {
                case "jpg":
                case "jpeg":
                case "bmp":
                case "gif":
                case "png":
                    r = "nativeimage";
                    break;

                case "dds":
                case "ktx":
                case "pvr":
                    r = t.Loader.BUFFER;
            }
            e.on(t.Event.LOADED, null, function(r) {
                e._cache = e._createCache;
                var i = t.Texture2D._parse(r, e._propertyParams, e._constructParams);
                Bi._endLoad(e, i);
            }), e.load(e.url, r, !1, null, !0);
        }
        static _loadTextureCube(e) {
            e.on(t.Event.LOADED, null, Bi._onTextureCubeLtcLoaded, [e]), e.load(e.url, t.Loader.JSON, !1, null, !0);
        }
        static _onTextureCubeLtcLoaded(e, r) {
            var i = t.URL.getPath(e.url),
                n = [Bi.formatRelativePath(i, r.front), Bi.formatRelativePath(i, r.back), Bi.formatRelativePath(i, r.left), Bi.formatRelativePath(i, r.right), Bi.formatRelativePath(i, r.up), Bi.formatRelativePath(i, r.down)];
            Bi._onProcessChange(e, 0, 1 / 7, 1);
            var a = t.Handler.create(null, Bi._onProcessChange, [e, 1 / 7, 6 / 7], !1);
            Bi._innerFourthLevelLoaderManager.load(n, t.Handler.create(null, Bi._onTextureCubeImagesLoaded, [e, n, a]), a, "nativeimage");
        }
        static _onTextureCubeImagesLoaded(e, r, i) {
            for (var n = new Array(6), a = 0; a < 6; a++) n[a] = t.Loader.getRes(r[a]);
            e._cache = e._createCache;
            var s = yi._parse(n, e._propertyParams, e._constructParams);
            for (i.recover(), a = 0; a < 6; a++) t.Loader.clearRes(r[a]);
            Bi._endLoad(e, s);
        }
        static _onProcessChange(e, r, i, n) {
            (n = r + n * i) < 1 && e.event(t.Event.PROGRESS, n);
        }
        static init(e, t, r = null, i = null) {
            if (!Bi._isInit) {
                Bi._isInit = !0, (r = r || s._default).cloneTo(Bi._config), U.debugFrustumCulling = r.debugFrustumCulling,
                    Bi._editerEnvironment = Bi._config._editerEnvironment, oi.octreeCulling = r.octreeCulling,
                    oi.octreeInitialSize = r.octreeInitialSize, oi.octreeInitialCenter = r.octreeInitialCenter,
                    oi.octreeMinNodeSize = r.octreeMinNodeSize, oi.octreeLooseness = r.octreeLooseness;
                var n = window.Physics3D;
                null == n ? (fe._enbalePhysics = !1, Bi.__init__(e, t, Bi._config), i && i.run()) : (fe._enbalePhysics = !0,
                    n(1024 * Bi._config.defaultPhysicsMemory * 1024).then(function() {
                        Bi.__init__(e, t, Bi._config), i && i.run();
                    }));
            }
        }
    }
    Bi.HIERARCHY = "HIERARCHY", Bi.MESH = "MESH", Bi.MATERIAL = "MATERIAL", Bi.TEXTURE2D = "TEXTURE2D",
        Bi.TEXTURECUBE = "TEXTURECUBE", Bi.ANIMATIONCLIP = "ANIMATIONCLIP", Bi.AVATAR = "AVATAR",
        Bi.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA", Bi.TERRAINRES = "TERRAIN", Bi._innerFirstLevelLoaderManager = new t.LoaderManager(),
        Bi._innerSecondLevelLoaderManager = new t.LoaderManager(), Bi._innerThirdLevelLoaderManager = new t.LoaderManager(),
        Bi._innerFourthLevelLoaderManager = new t.LoaderManager(), Bi._isInit = !1, Bi._editerEnvironment = !1,
        Bi._config = new s(), Bi.physicsSettings = new Nt(), window.Laya3D = Bi;
    class Ui extends t.Component {
        constructor() {
            super(...arguments), this._indexInPool = -1;
        }
        get isSingleton() {
            return !1;
        }
        _checkProcessTriggers() {
            var e = Ui.prototype;
            return this.onTriggerEnter !== e.onTriggerEnter || (this.onTriggerStay !== e.onTriggerStay || this.onTriggerExit !== e.onTriggerExit);
        }
        _checkProcessCollisions() {
            var e = Ui.prototype;
            return this.onCollisionEnter !== e.onCollisionEnter || (this.onCollisionStay !== e.onCollisionStay || this.onCollisionExit !== e.onCollisionExit);
        }
        _onAwake() {
            this.onAwake(), this.onStart !== Ui.prototype.onStart && t.Laya.startTimer.callLater(this, this.onStart);
        }
        _onEnable() {
            this.owner._scene._addScript(this);
            var e = Ui.prototype;
            this.onKeyDown !== e.onKeyDown && t.Laya.stage.on(t.Event.KEY_DOWN, this, this.onKeyDown),
                this.onKeyPress !== e.onKeyPress && t.Laya.stage.on(t.Event.KEY_PRESS, this, this.onKeyUp),
                this.onKeyUp !== e.onKeyUp && t.Laya.stage.on(t.Event.KEY_UP, this, this.onKeyUp);
        }
        _onDisable() {
            this.owner._scene._removeScript(this), this.owner.offAllCaller(this), t.Laya.stage.offAllCaller(this);
        }
        _isScript() {
            return !0;
        }
        _onAdded() {
            var e = this.owner,
                t = e._scripts;
            t || (e._scripts = t = []), t.push(this), e._needProcessCollisions || (e._needProcessCollisions = this._checkProcessCollisions()),
                e._needProcessTriggers || (e._needProcessTriggers = this._checkProcessTriggers());
        }
        _onDestroy() {
            var e = this.owner._scripts;
            e.splice(e.indexOf(this), 1);
            var t = this.owner;
            t._needProcessTriggers = !1;
            for (var r = 0, i = e.length; r < i; r++)
                if (e[r]._checkProcessTriggers()) {
                    t._needProcessTriggers = !0;
                    break;
                }
            for (t._needProcessCollisions = !1, r = 0, i = e.length; r < i; r++)
                if (e[r]._checkProcessCollisions()) {
                    t._needProcessCollisions = !0;
                    break;
                }
            this.onDestroy();
        }
        onAwake() {}
        onEnable() {}
        onStart() {}
        onTriggerEnter(e) {}
        onTriggerStay(e) {}
        onTriggerExit(e) {}
        onCollisionEnter(e) {}
        onCollisionStay(e) {}
        onCollisionExit(e) {}
        onMouseDown() {}
        onMouseDrag() {}
        onMouseClick() {}
        onMouseUp() {}
        onMouseEnter() {}
        onMouseOver() {}
        onMouseOut() {}
        onKeyDown(e) {}
        onKeyPress(e) {}
        onKeyUp(e) {}
        onUpdate() {}
        onLateUpdate() {}
        onPreRender() {}
        onPostRender() {}
        onDisable() {}
        onDestroy() {}
    }
    class Gi {
        constructor(e, t, r, i) {
            this._datas = [], this._w = e, this._h = t, this._minHeight = r, this._maxHeight = i;
        }
        static creatFromMesh(e, t, r, i) {
            for (var n = [], s = [], o = e.subMeshCount, l = 0; l < o; l++) {
                for (var _ = e.getSubMesh(l), h = _._vertexBuffer, c = h.getFloat32Data(), d = [], u = 0; u < c.length; u += h.vertexDeclaration.vertexStride / 4) {
                    var f = new a(c[u + 0], c[u + 1], c[u + 2]);
                    d.push(f);
                }
                n.push(d);
                var E = _._indexBuffer;
                s.push(E.getData());
            }
            var T = e.bounds,
                m = T.getMin().x,
                p = T.getMin().z,
                g = T.getMax().x,
                S = T.getMax().z,
                v = T.getMin().y,
                R = T.getMax().y,
                A = g - m,
                D = S - p,
                I = i.x = A / (t - 1),
                x = i.y = D / (r - 1),
                M = new Gi(t, r, v, R),
                L = Gi._tempRay,
                C = L.direction;
            C.x = 0, C.y = -1, C.z = 0;
            var y = R + .1;
            L.origin.y = y;
            for (var O = 0; O < r; O++) {
                var N = p + O * x;
                M._datas[O] = [];
                for (var P = 0; P < t; P++) {
                    var V = m + P * I,
                        w = L.origin;
                    w.x = V, w.z = N;
                    var b = Gi._getPosition(L, n, s);
                    M._datas[O][P] = b === Number.MAX_VALUE ? NaN : y - b;
                }
            }
            return M;
        }
        static createFromImage(e, t, r) {
            for (var i = e.width, n = e.height, a = new Gi(i, n, t, r), s = (r - t) / 254, o = e.getPixels(), l = 0, _ = 0; _ < n; _++)
                for (var h = a._datas[_] = [], c = 0; c < i; c++) {
                    var d = o[l++],
                        u = o[l++],
                        f = o[l++],
                        E = o[l++];
                    h[c] = 255 == d && 255 == u && 255 == f && 255 == E ? NaN : (d + u + f) / 3 * s + t;
                }
            return a;
        }
        static _getPosition(e, t, r) {
            for (var i = Number.MAX_VALUE, n = 0; n < t.length; n++)
                for (var a = t[n], s = r[n], o = 0; o < s.length; o += 3) {
                    var l = a[s[o + 0]],
                        _ = a[s[o + 1]],
                        h = a[s[o + 2]],
                        c = Z.rayIntersectsTriangle(e, l, _, h);
                    !isNaN(c) && c < i && (i = c);
                }
            return i;
        }
        get width() {
            return this._w;
        }
        get height() {
            return this._h;
        }
        get maxHeight() {
            return this._maxHeight;
        }
        get minHeight() {
            return this._minHeight;
        }
        _inBounds(e, t) {
            return e >= 0 && e < this._h && t >= 0 && t < this._w;
        }
        getHeight(e, t) {
            return this._inBounds(e, t) ? this._datas[e][t] : NaN;
        }
    }
    Gi._tempRay = new z(new a(), new a());
    class zi extends Ye {
        constructor(e, t, r = null) {
            super(e, r), this._heightMap = t, this._cellSize = new i();
        }
        static createFromMesh(e, t, r, i = null) {
            var n = new zi(e, null, i);
            return n._initCreateFromMesh(t, r), n;
        }
        static createFromMeshAndHeightMap(e, t, r, i, n = null) {
            var a = new zi(e, null, n);
            return a._initCreateFromMeshHeightMap(t, r, i), a;
        }
        get minX() {
            var e = this.transform.worldMatrix.elements;
            return this._minX * this._getScaleX() + e[12];
        }
        get minZ() {
            var e = this.transform.worldMatrix.elements;
            return this._minZ * this._getScaleZ() + e[14];
        }
        get width() {
            return (this._heightMap.width - 1) * this._cellSize.x * this._getScaleX();
        }
        get depth() {
            return (this._heightMap.height - 1) * this._cellSize.y * this._getScaleZ();
        }
        _disableRotation() {
            var e = this.transform.rotation;
            e.x = 0, e.y = 0, e.z = 0, e.w = 1, this.transform.rotation = e;
        }
        _getScaleX() {
            var e = this.transform.worldMatrix.elements,
                t = e[0],
                r = e[1],
                i = e[2];
            return Math.sqrt(t * t + r * r + i * i);
        }
        _getScaleZ() {
            var e = this.transform.worldMatrix.elements,
                t = e[8],
                r = e[9],
                i = e[10];
            return Math.sqrt(t * t + r * r + i * i);
        }
        _initCreateFromMesh(e, t) {
            this._heightMap = Gi.creatFromMesh(this.meshFilter.sharedMesh, e, t, this._cellSize);
            var r = this.meshFilter.sharedMesh.bounds,
                i = r.getMin();
            r.getMax();
            this._minX = i.x, this._minZ = i.z;
        }
        _initCreateFromMeshHeightMap(e, t, r) {
            var i = this.meshFilter.sharedMesh.bounds;
            this._heightMap = Gi.createFromImage(e, t, r), this._computeCellSize(i);
            var n = i.getMin();
            i.getMax();
            this._minX = n.x, this._minZ = n.z;
        }
        _computeCellSize(e) {
            var t = e.getMin(),
                r = e.getMax(),
                i = t.x,
                n = t.z,
                a = r.x - i,
                s = r.z - n;
            this._cellSize.x = a / (this._heightMap.width - 1), this._cellSize.y = s / (this._heightMap.height - 1);
        }
        _update(e) {
            this._disableRotation();
        }
        getHeight(e, t) {
            zi._tempVector3.x = e, zi._tempVector3.y = 0, zi._tempVector3.z = t, this._disableRotation();
            var r = this.transform.worldMatrix;
            r.invert(zi._tempMatrix4x4), a.transformCoordinate(zi._tempVector3, zi._tempMatrix4x4, zi._tempVector3),
                e = zi._tempVector3.x, t = zi._tempVector3.z;
            var i = (e - this._minX) / this._cellSize.x,
                n = (t - this._minZ) / this._cellSize.y,
                s = Math.floor(n),
                o = Math.floor(i),
                l = i - o,
                _ = n - s,
                h = r.elements,
                c = h[4],
                d = h[5],
                u = h[6],
                f = Math.sqrt(c * c + d * d + u * u),
                E = h[13],
                T = this._heightMap.getHeight(s, o + 1),
                m = this._heightMap.getHeight(s + 1, o);
            if (isNaN(T) || isNaN(m)) return NaN;
            if (l + _ <= 1) {
                var p = this._heightMap.getHeight(s, o);
                return isNaN(p) ? NaN : (p + l * (T - p) + _ * (m - p)) * f + E;
            }
            var g = this._heightMap.getHeight(s + 1, o + 1);
            return isNaN(g) ? NaN : (g + (1 - l) * (m - g) + (1 - _) * (T - g)) * f + E;
        }
    }
    zi._tempVector3 = new a(), zi._tempMatrix4x4 = new T();
    class Hi {
        constructor() {
            this._currentLength = 0, this._elements = new Float32Array(12);
        }
        get gradientCount() {
            return this._currentLength / 3;
        }
        add(e, t) {
            this._currentLength < 8 ? (6 === this._currentLength && 1 !== e && (e = 1, console.log("GradientDataVector2 warning:the forth key is  be force set to 1.")),
                this._elements[this._currentLength++] = e, this._elements[this._currentLength++] = t.x,
                this._elements[this._currentLength++] = t.y) : console.log("GradientDataVector2 warning:data count must lessEqual than 4");
        }
        cloneTo(e) {
            var t = e;
            t._currentLength = this._currentLength;
            for (var r = t._elements, i = 0, n = this._elements.length; i < n; i++) r[i] = this._elements[i];
        }
        clone() {
            var e = new Hi();
            return this.cloneTo(e), e;
        }
    }
    class Wi {
        constructor() {}
        render(e) {}
    }
    class ki extends Wi {
        constructor() {
            super(), this._shader = null, this._shaderData = new p(), this._linearColor = new I(),
                this._bloomTextureTexelSize = new n(), this._shaderThreshold = new n(), this._shaderParams = new n(),
                this._pyramid = null, this._intensity = 0, this._threshold = 1, this._softKnee = .5,
                this._diffusion = 7, this._anamorphicRatio = 0, this._dirtIntensity = 0, this._shaderSetting = new n(),
                this._dirtTileOffset = new n(), this.clamp = 65472, this.color = new I(1, 1, 1, 1),
                this.fastMode = !1, this.dirtTexture = null, this._shader = L.find("PostProcessBloom"),
                this._pyramid = new Array(2 * ki.MAXPYRAMIDSIZE);
        }
        get intensity() {
            return this._intensity;
        }
        set intensity(e) {
            this._intensity = Math.max(e, 0);
        }
        get threshold() {
            return this._threshold;
        }
        set threshold(e) {
            this._threshold = Math.max(e, 0);
        }
        get softKnee() {
            return this._softKnee;
        }
        set softKnee(e) {
            this._softKnee = Math.min(Math.max(e, 0), 1);
        }
        get diffusion() {
            return this._diffusion;
        }
        set diffusion(e) {
            this._diffusion = Math.min(Math.max(e, 1), 10);
        }
        get anamorphicRatio() {
            return this._anamorphicRatio;
        }
        set anamorphicRatio(e) {
            this._anamorphicRatio = Math.min(Math.max(e, -1), 1);
        }
        get dirtIntensity() {
            return this._dirtIntensity;
        }
        set dirtIntensity(e) {
            this._dirtIntensity = Math.max(e, 0);
        }
        render(e) {
            var r = e.command,
                i = e.camera.viewport;
            this._shaderData.setTexture(ki.SHADERVALUE_AUTOEXPOSURETEX, t.Texture2D.whiteTexture);
            var a, s = this._anamorphicRatio,
                o = s < 0 ? -s : 0,
                l = s > 0 ? s : 0,
                _ = Math.floor(i.width / (2 - o)),
                h = Math.floor(i.height / (2 - l)),
                c = Math.max(_, h);
            a = Math.log2(c) + this._diffusion - 10;
            var d = Math.floor(a),
                u = Math.min(Math.max(d, 1), ki.MAXPYRAMIDSIZE),
                f = .5 + a - d;
            this._shaderData.setNumber(ki.SHADERVALUE_SAMPLESCALE, f);
            var E = I.gammaToLinearSpace(this.threshold),
                T = E * this._softKnee + 1e-5;
            this._shaderThreshold.setValue(E, E - T, 2 * T, .25 / T), this._shaderData.setVector(ki.SHADERVALUE_THRESHOLD, this._shaderThreshold);
            var m = I.gammaToLinearSpace(this.clamp);
            this._shaderParams.setValue(m, 0, 0, 0), this._shaderData.setVector(ki.SHADERVALUE_PARAMS, this._shaderParams);
            for (var p = this.fastMode ? 1 : 0, g = e.source, S = 0; S < u; S++) {
                var v = 2 * S,
                    R = v + 1,
                    A = 0 == S ? ki.SUBSHADER_PREFILTER13 + p : ki.SUBSHADER_DOWNSAMPLE13 + p,
                    D = Y.createFromPool(_, h, t.BaseTexture.FORMAT_R8G8B8, t.BaseTexture.FORMAT_DEPTHSTENCIL_NONE, t.BaseTexture.FILTERMODE_BILINEAR);
                if (this._pyramid[v] = D, S !== u - 1) {
                    var x = Y.createFromPool(_, h, t.BaseTexture.FORMAT_R8G8B8, t.BaseTexture.FORMAT_DEPTHSTENCIL_NONE, t.BaseTexture.FILTERMODE_BILINEAR);
                    this._pyramid[R] = x;
                }
                r.blitScreenTriangle(g, D, this._shader, this._shaderData, A), g = D, _ = Math.max(Math.floor(_ / 2), 1),
                    h = Math.max(Math.floor(h / 2), 1);
            }
            var M = this._pyramid[2 * (u - 1)];
            for (S = u - 2; S >= 0; S--) R = (v = 2 * S) + 1, D = this._pyramid[v], x = this._pyramid[R],
                r.setShaderDataTexture(this._shaderData, ki.SHADERVALUE_BLOOMTEX, D), r.blitScreenTriangle(M, x, this._shader, this._shaderData, ki.SUBSHADER_UPSAMPLETENT + p),
                M = x;
            var L = this._linearColor;
            this.color.toLinear(L);
            var C = Math.pow(2, this._intensity / 10) - 1,
                y = this._shaderSetting;
            this._shaderSetting.setValue(f, C, this._dirtIntensity, u);
            var O = this.dirtTexture ? this.dirtTexture : t.Texture2D.blackTexture,
                N = O.width / O.height,
                P = i.width / i.height,
                V = this._dirtTileOffset;
            N > P ? V.setValue(P / N, 1, .5 * (1 - V.x), 0) : N < P && V.setValue(1, N / P, 0, .5 * (1 - V.y));
            var w = e.compositeShaderData;
            for (this.fastMode ? w.addDefine(bt.SHADERDEFINE_BLOOM_LOW) : w.addDefine(bt.SHADERDEFINE_BLOOM),
                this._bloomTextureTexelSize.setValue(1 / M.width, 1 / M.height, M.width, M.height),
                w.setVector(bt.SHADERVALUE_BLOOM_DIRTTILEOFFSET, V), w.setVector(bt.SHADERVALUE_BLOOM_SETTINGS, y),
                w.setVector(bt.SHADERVALUE_BLOOM_COLOR, new n(L.r, L.g, L.b, L.a)), w.setTexture(bt.SHADERVALUE_BLOOM_DIRTTEX, O),
                w.setTexture(bt.SHADERVALUE_BLOOMTEX, M), w.setVector(bt.SHADERVALUE_BLOOMTEX_TEXELSIZE, this._bloomTextureTexelSize),
                S = 0; S < u; S++) R = (v = 2 * S) + 1, Y.recoverToPool(this._pyramid[v]), 0 !== S && S !== u - 1 && Y.recoverToPool(this._pyramid[R]);
            e.deferredReleaseTextures.push(M);
        }
    }
    ki.SHADERVALUE_MAINTEX = L.propertyNameToID("u_MainTex"), ki.SHADERVALUE_AUTOEXPOSURETEX = L.propertyNameToID("u_AutoExposureTex"),
        ki.SHADERVALUE_SAMPLESCALE = L.propertyNameToID("u_SampleScale"), ki.SHADERVALUE_THRESHOLD = L.propertyNameToID("u_Threshold"),
        ki.SHADERVALUE_PARAMS = L.propertyNameToID("u_Params"), ki.SHADERVALUE_BLOOMTEX = L.propertyNameToID("u_BloomTex"),
        ki.SUBSHADER_PREFILTER13 = 0, ki.SUBSHADER_PREFILTER4 = 1, ki.SUBSHADER_DOWNSAMPLE13 = 2,
        ki.SUBSHADER_DOWNSAMPLE4 = 3, ki.SUBSHADER_UPSAMPLETENT = 4, ki.SUBSHADER_UPSAMPLEBOX = 5,
        ki.MAXPYRAMIDSIZE = 16;
    class Xi {
        constructor(e) {
            if (!(e instanceof Array) || 4 !== e.length) throw new Error("Rand:Seed must be an array with 4 numbers");
            this._state0U = 0 | e[0], this._state0L = 0 | e[1], this._state1U = 0 | e[2], this._state1L = 0 | e[3];
        }
        randomint() {
            var e = this._state0U,
                t = this._state0L,
                r = this._state1U,
                i = this._state1L,
                n = (i >>> 0) + (t >>> 0),
                a = r + e + (n / 2 >>> 31) >>> 0,
                s = n >>> 0;
            this._state0U = r, this._state0L = i;
            var o = 0,
                l = 0;
            o = (e ^= o = e << 23 | (-512 & t) >>> 9) ^ r, l = (t ^= l = t << 23) ^ i;
            o ^= e >>> 18, l ^= t >>> 18 | (262143 & e) << 14;
            return o ^= r >>> 5, l ^= i >>> 5 | (31 & r) << 27, this._state1U = o, this._state1L = l, [a, s];
        }
        random() {
            var e = this.randomint(),
                t = e[0],
                r = 1023 << 20 | t >>> 12,
                i = 0 | (e[1] >>> 12 | (4095 & t) << 20);
            return Xi._CONVERTION_BUFFER.setUint32(0, r, !1), Xi._CONVERTION_BUFFER.setUint32(4, i, !1),
                Xi._CONVERTION_BUFFER.getFloat64(0, !1) - 1;
        }
    }
    Xi._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8)), Xi.defaultRand = new Xi([0, Date.now() / 65536, 0, Date.now() % 65536]);
    class Yi {
        constructor(e, t) {
            this._width = 0, this._height = 0, this._width = e, this._height = t;
        }
        static get fullScreen() {
            return new Yi(-1, -1);
        }
        get width() {
            return -1 === this._width ? J.clientWidth : this._width;
        }
        get height() {
            return -1 === this._height ? J.clientHeight : this._height;
        }
    }
    e.AnimationClip = Si, e.AnimationClipParser03 = Ti, e.AnimationClipParser04 = pi,
        e.AnimationEvent = hi, e.AnimationNode = Ri, e.AnimationTransform3D = vi, e.Animator = V,
        e.AnimatorControllerLayer = O, e.AnimatorPlayState = y, e.AnimatorState = N, e.AnimatorStateScript = class {
            constructor() {}
            onStateEnter() {}
            onStateUpdate() {}
            onStateExit() {}
        }, e.Avatar = Ai, e.BaseCamera = Q, e.BaseMaterial = Ge, e.BaseRender = ke, e.BaseShape = Et,
        e.BatchMark = A, e.BlinnPhongMaterial = He, e.BlitScreenQuadCMD = re, e.BloomEffect = ki,
        e.BoundBox = Oe, e.BoundFrustum = k, e.BoundSphere = Ne, e.Bounds = We, e.BoundsOctree = si,
        e.BoundsOctreeNode = ni, e.BoxColliderShape = me, e.BoxShape = mt, e.BufferState = _,
        e.Burst = st, e.Camera = oe, e.CapsuleColliderShape = pe, e.CastShadowList = Mt,
        e.CharacterController = Pi, e.CircleShape = pt, e.ColliderShape = Te, e.Collision = Le,
        e.CollisionTool = Ce, e.CollisionUtils = W, e.Color = I, e.ColorOverLifetime = lt,
        e.Command = te, e.CommandBuffer = ae, e.CompoundColliderShape = ge, e.ConchQuaternion = Ei,
        e.ConchVector3 = fi, e.ConchVector4 = ui, e.ConeColliderShape = Se, e.ConeShape = gt,
        e.Config3D = s, e.Constraint3D = class {
            constructor() {}
        }, e.ConstraintComponent = class extends t.Component {
            constructor() {
                super(), this._feedbackEnabled = !1;
            }
            get enabled() {
                return super.enabled;
            }
            set enabled(e) {
                this._nativeConstraint.IsEnabled = e, super.enabled = e;
            }
            get breakingImpulseThreshold() {
                return this._breakingImpulseThreshold;
            }
            set breakingImpulseThreshold(e) {
                this._nativeConstraint.BreakingImpulseThreshold = e, this._breakingImpulseThreshold = e;
            }
            get appliedImpulse() {
                return this._feedbackEnabled || (this._nativeConstraint.EnableFeedback(!0), this._feedbackEnabled = !0),
                    this._nativeConstraint.AppliedImpulse;
            }
            get connectedBody() {
                return this._connectedBody;
            }
            set connectedBody(e) {
                this._connectedBody = e;
            }
            _onDestroy() {
                fe._physics3D.destroy(this._nativeConstraint), this._nativeConstraint = null;
            }
        }, e.ContactPoint = xe, e.ContainmentType = H, e.CylinderColliderShape = ve, e.DefineDatas = m,
        e.DirectionLight = we, e.DynamicBatchManager = l, e.EffectMaterial = Ft, e.Emission = $e,
        e.ExtendTerrainMaterial = Bt, e.FloatKeyframe = qt, e.FrameOverTime = _t, e.FrustumCulling = U,
        e.GeometryElement = h, e.Gradient = je, e.GradientAngularVelocity = ht, e.GradientColor = ot,
        e.GradientDataInt = ct, e.GradientDataNumber = et, e.GradientDataVector2 = Hi, e.GradientMode = Ze,
        e.GradientSize = dt, e.GradientVelocity = ut, e.HalfFloatUtils = mi, e.HeightMap = Gi,
        e.HeightfieldColliderShape = class {
            constructor() {}
        }, e.HemisphereShape = St, e.HitResult = Me, e.ILaya3D = o, e.IndexBuffer3D = c,
        e.Input3D = Ot, e.Keyframe = jt, e.KeyframeNode = _i, e.KeyframeNodeList = gi, e.KeyframeNodeOwner = P,
        e.Laya3D = Bi, e.LightSprite = Ve, e.LoadModelV04 = xi, e.LoadModelV05 = Mi, e.MathUtils3D = r,
        e.Matrix3x3 = f, e.Matrix4x4 = T, e.Mesh = Ci, e.MeshColliderShape = Re, e.MeshFilter = Ue,
        e.MeshReader = Li, e.MeshRenderDynamicBatchManager = ce, e.MeshRenderStaticBatchManager = ue,
        e.MeshRenderer = Xe, e.MeshSprite3D = Ye, e.MeshSprite3DShaderDeclaration = Be,
        e.MeshTerrainSprite3D = zi, e.MouseTouch = Ct, e.OctreeMotionList = ai, e.PBRSpecularMaterial = Ut,
        e.PBRStandardMaterial = Gt, e.ParallelSplitShadowMap = Pe, e.Physics3D = fe, e.Physics3DUtils = Ee,
        e.PhysicsCollider = Ni, e.PhysicsComponent = De, e.PhysicsSettings = Nt, e.PhysicsSimulation = ye,
        e.PhysicsTriggerComponent = Oi, e.PhysicsUpdateList = Ie, e.Picker = Z, e.PixelLineData = class {
            constructor() {
                this.startPosition = new a(), this.endPosition = new a(), this.startColor = new I(),
                    this.endColor = new I();
            }
            cloneTo(e) {
                this.startPosition.cloneTo(e.startPosition), this.endPosition.cloneTo(e.endPosition),
                    this.startColor.cloneTo(e.startColor), this.endColor.cloneTo(e.endColor);
            }
        }, e.PixelLineFilter = ei, e.PixelLineMaterial = Jr, e.PixelLineRenderer = ti, e.PixelLineSprite3D = ri,
        e.PixelLineVertex = $r, e.Plane = G, e.Point2PointConstraint = class {
            constructor() {
                this._pivotInA = new a(), this._pivotInB = new a();
            }
            get pivotInA() {
                return this._pivotInA;
            }
            set pivotInA(e) {
                this._pivotInA = e;
            }
            get pivotInB() {
                return this._pivotInB;
            }
            set pivotInB(e) {
                this._pivotInB = e;
            }
            get damping() {
                return this._damping;
            }
            set damping(e) {
                this._damping = e;
            }
            get impulseClamp() {
                return this._impulseClamp;
            }
            set impulseClamp(e) {
                this._impulseClamp = e;
            }
            get tau() {
                return this._tau;
            }
            set tau(e) {
                this._tau = e;
            }
        }, e.PointLight = be, e.PostProcess = bt, e.PostProcessEffect = Wi, e.PostProcessRenderContext = wt,
        e.PrimitiveMesh = bi, e.Quaternion = E, e.QuaternionKeyframe = ci, e.Rand = nt,
        e.RandX = Xi, e.Ray = z, e.RenderContext3D = J, e.RenderElement = le, e.RenderQueue = ii,
        e.RenderState = ze, e.RenderTexture = Y, e.RenderableSprite3D = F, e.Rigidbody3D = Vi,
        e.RotationOverLifetime = ft, e.Scene3D = oi, e.Scene3DShaderDeclaration = se, e.Scene3DUtils = li,
        e.SceneManager = class {
            constructor() {}
        }, e.ScreenQuad = $, e.ScreenTriangle = ee, e.Script3D = Ui, e.SetRenderTargetCMD = ie,
        e.SetShaderDataTextureCMD = ne, e.Shader3D = L, e.ShaderData = p, e.ShaderDefines = C,
        e.ShaderInit3D = Qr, e.ShaderInstance = nr, e.ShaderPass = ar, e.ShaderVariable = ir,
        e.ShapeUtils = Tt, e.ShuriKenParticle3D = xt, e.ShuriKenParticle3DShaderDeclaration = Ke,
        e.ShurikenParticleData = Je, e.ShurikenParticleMaterial = qe, e.ShurikenParticleRenderer = Qe,
        e.ShurikenParticleSystem = at, e.SimpleSingletonList = Lt, e.SingletonList = he,
        e.Size = Yi, e.SizeOverLifetime = Rt, e.SkinnedMeshRenderer = Xt, e.SkinnedMeshSprite3D = Yt,
        e.SkinnedMeshSprite3DShaderDeclaration = kt, e.SkyBox = q, e.SkyBoxMaterial = Di,
        e.SkyDome = Vt, e.SkyMesh = j, e.SkyProceduralMaterial = zt, e.SkyRenderer = K,
        e.SphereColliderShape = Ae, e.SphereShape = vt, e.SpotLight = Fe, e.Sprite3D = b,
        e.StartFrame = At, e.StaticBatchManager = B, e.StaticPlaneColliderShape = wi, e.SubMesh = Ii,
        e.SubMeshDynamicBatch = R, e.SubMeshInstanceBatch = D, e.SubMeshRenderElement = _e,
        e.SubMeshStaticBatch = de, e.SubShader = sr, e.TextMesh = class {
            get text() {
                return this._text;
            }
            set text(e) {
                this._text = e;
            }
            get fontSize() {
                return this._fontSize;
            }
            set fontSize(e) {
                this._fontSize = e;
            }
            get color() {
                return this._color;
            }
            set color(e) {
                this._color = e;
            }
            constructor() {}
            _createVertexBuffer(e) {}
            _resizeVertexBuffer(e) {}
            _addChar() {}
        }, e.TextureCube = yi, e.TextureGenerator = x, e.TextureMode = Kt, e.TextureSheetAnimation = Dt,
        e.Touch = yt, e.TrailFilter = er, e.TrailGeometry = $t, e.TrailMaterial = Zt, e.TrailRenderer = tr,
        e.TrailSprite3D = rr, e.Transform3D = w, e.UnlitMaterial = Ht, e.Utils3D = M, e.Vector2 = i,
        e.Vector3 = a, e.Vector3Keyframe = di, e.Vector4 = n, e.VelocityOverLifetime = It,
        e.VertexBuffer3D = d, e.VertexDeclaration = g, e.VertexElement = S, e.VertexElementFormat = u,
        e.VertexMesh = v, e.VertexPositionTerrain = Fi, e.VertexPositionTexture0 = Pt, e.VertexShuriKenParticle = tt,
        e.VertexShurikenParticleBillboard = rt, e.VertexShurikenParticleMesh = it, e.VertexTrail = Jt,
        e.Viewport = X, e.WaterPrimaryMaterial = Wt;
}(window.Laya = window.Laya || {}, Laya);